pub fn sub_822A2C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A2C80 size=112
    let mut pc: u32 = 0x822A2C80;
    'dispatch: loop {
        match pc {
            0x822A2C80 => {
    //   block [0x822A2C80..0x822A2CD8)
	// 822A2C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A2C84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A2C88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822A2C8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A2C90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A2C94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A2C98: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 822A2C9C: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A2CA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822A2CA4: 419A0034  beq cr6, 0x822a2cd8
	if ctx.cr[6].eq {
	pc = 0x822A2CD8; continue 'dispatch;
	}
	// 822A2CA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A2CAC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A2CB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A2CB4: 4E800421  bctrl
	ctx.lr = 0x822A2CB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A2CB8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822A2CBC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A2CC0: 409A0018  bne cr6, 0x822a2cd8
	if !ctx.cr[6].eq {
	pc = 0x822A2CD8; continue 'dispatch;
	}
	// 822A2CC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822A2CC8: 48963231  bl 0x82c05ef8
	ctx.lr = 0x822A2CCC;
	sub_82C05EF8(ctx, base);
	// 822A2CCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822A2CD0: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 822A2CD4: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
            }
            0x822A2CD8 => {
    //   block [0x822A2CD8..0x822A2CF0)
	// 822A2CD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822A2CDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A2CE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A2CE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822A2CE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822A2CEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A2CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A2CF0 size=236
    //   switch @ 0x822A2D24: r10 with 9 label(s)
    //       case  0 → 0x822A2D34
    //       case  1 → 0x822A2D84
    //       case  2 → 0x822A2D5C
    //       case  3 → 0x822A2D98
    //       case  4 → 0x822A2DB0
    //       case  5 → 0x822A2DC4
    //       case  6 → 0x822A2DCC
    //       case  7 → 0x822A2DD4
    //       case  8 → 0x822A2DD4
    let mut pc: u32 = 0x822A2CF0;
    'dispatch: loop {
        match pc {
            0x822A2CF0 => {
    //   block [0x822A2CF0..0x822A2D34)
	// 822A2CF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822A2CF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822A2CF8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A2CFC: 554A073E  clrlwi r10, r10, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 822A2D00: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822A2D04: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 822A2D08: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
	// 822A2D0C: 3D80820A  lis r12, -0x7df6
	ctx.r[12].s64 = -2113273856;
	// 822A2D10: 398C0468  addi r12, r12, 0x468
	ctx.r[12].s64 = ctx.r[12].s64 + 1128;
	// 822A2D14: 7C0C50AE  lbzx r0, r12, r10
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822A2D18: 3D80822A  lis r12, -0x7dd6
	ctx.r[12].s64 = -2111176704;
	// 822A2D1C: 398C2D34  addi r12, r12, 0x2d34
	ctx.r[12].s64 = ctx.r[12].s64 + 11572;
	// 822A2D20: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 822A2D24: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 822A2D28: 60000000  nop
	// 822A2D2C: 60000000  nop
	// 822A2D30: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            0x822A2D34 => {
    //   block [0x822A2D34..0x822A2D3C)
	// 822A2D34: 394430AC  addi r10, r4, 0x30ac
	ctx.r[10].s64 = ctx.r[4].s64 + 12460;
	// 822A2D38: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	pc = 0x822A2D3C; continue 'dispatch;
            }
            0x822A2D3C => {
    //   block [0x822A2D3C..0x822A2D4C)
	// 822A2D3C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A2D40: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A2D44: 409A0008  bne cr6, 0x822a2d4c
	if !ctx.cr[6].eq {
	pc = 0x822A2D4C; continue 'dispatch;
	}
	// 822A2D48: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x822A2D4C; continue 'dispatch;
            }
            0x822A2D4C => {
    //   block [0x822A2D4C..0x822A2D5C)
	// 822A2D4C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822A2D50: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822A2D54: 4082FFE8  bne 0x822a2d3c
	if !ctx.cr[0].eq {
	pc = 0x822A2D3C; continue 'dispatch;
	}
	// 822A2D58: 4E800020  blr
	return;
            }
            0x822A2D5C => {
    //   block [0x822A2D5C..0x822A2D64)
	// 822A2D5C: 39443100  addi r10, r4, 0x3100
	ctx.r[10].s64 = ctx.r[4].s64 + 12544;
	// 822A2D60: 3920001A  li r9, 0x1a
	ctx.r[9].s64 = 26;
	pc = 0x822A2D64; continue 'dispatch;
            }
            0x822A2D64 => {
    //   block [0x822A2D64..0x822A2D74)
	// 822A2D64: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A2D68: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A2D6C: 409A0008  bne cr6, 0x822a2d74
	if !ctx.cr[6].eq {
	pc = 0x822A2D74; continue 'dispatch;
	}
	// 822A2D70: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x822A2D74; continue 'dispatch;
            }
            0x822A2D74 => {
    //   block [0x822A2D74..0x822A2D84)
	// 822A2D74: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822A2D78: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822A2D7C: 4082FFE8  bne 0x822a2d64
	if !ctx.cr[0].eq {
	pc = 0x822A2D64; continue 'dispatch;
	}
	// 822A2D80: 4E800020  blr
	return;
            }
            0x822A2D84 => {
    //   block [0x822A2D84..0x822A2D88)
	// 822A2D84: 81443094  lwz r10, 0x3094(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12436 as u32) ) } as u64;
	pc = 0x822A2D88; continue 'dispatch;
            }
            0x822A2D88 => {
    //   block [0x822A2D88..0x822A2D98)
	// 822A2D88: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A2D8C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 822A2D90: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822A2D94: 4E800020  blr
	return;
            }
            0x822A2D98 => {
    //   block [0x822A2D98..0x822A2DA8)
	// 822A2D98: 81443098  lwz r10, 0x3098(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12440 as u32) ) } as u64;
	// 822A2D9C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A2DA0: 409A0008  bne cr6, 0x822a2da8
	if !ctx.cr[6].eq {
	pc = 0x822A2DA8; continue 'dispatch;
	}
	// 822A2DA4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x822A2DA8; continue 'dispatch;
            }
            0x822A2DA8 => {
    //   block [0x822A2DA8..0x822A2DB0)
	// 822A2DA8: 814430A8  lwz r10, 0x30a8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12456 as u32) ) } as u64;
	// 822A2DAC: 4BFFFFDC  b 0x822a2d88
	pc = 0x822A2D88; continue 'dispatch;
            }
            0x822A2DB0 => {
    //   block [0x822A2DB0..0x822A2DB4)
	// 822A2DB0: 81442E2C  lwz r10, 0x2e2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(11820 as u32) ) } as u64;
	pc = 0x822A2DB4; continue 'dispatch;
            }
            0x822A2DB4 => {
    //   block [0x822A2DB4..0x822A2DC4)
	// 822A2DB4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822A2DB8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822A2DBC: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822A2DC0: 4E800020  blr
	return;
            }
            0x822A2DC4 => {
    //   block [0x822A2DC4..0x822A2DCC)
	// 822A2DC4: 81443198  lwz r10, 0x3198(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12696 as u32) ) } as u64;
	// 822A2DC8: 4BFFFFEC  b 0x822a2db4
	pc = 0x822A2DB4; continue 'dispatch;
            }
            0x822A2DCC => {
    //   block [0x822A2DCC..0x822A2DD4)
	// 822A2DCC: 81443194  lwz r10, 0x3194(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12692 as u32) ) } as u64;
	// 822A2DD0: 4BFFFFE4  b 0x822a2db4
	pc = 0x822A2DB4; continue 'dispatch;
            }
            0x822A2DD4 => {
    //   block [0x822A2DD4..0x822A2DDC)
	// 822A2DD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822A2DD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A2DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A2DE0 size=2952
    let mut pc: u32 = 0x822A2DE0;
    'dispatch: loop {
        match pc {
            0x822A2DE0 => {
    //   block [0x822A2DE0..0x822A2E28)
	// 822A2DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A2DE4: 48A0660D  bl 0x82ca93f0
	ctx.lr = 0x822A2DE8;
	sub_82CA93D0(ctx, base);
	// 822A2DE8: DBA1FF90  stfd f29, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[29].u64 ) };
	// 822A2DEC: DBC1FF98  stfd f30, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 822A2DF0: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 822A2DF4: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 822A2DF8: 48D63BD5  bl 0x830069cc
	ctx.lr = 0x822A2DFC;
	sub_83006760(ctx, base);
	// 822A2DFC: 9421FD00  stwu r1, -0x300(r1)
	ea = ctx.r[1].u32.wrapping_add(-768 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A2E00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822A2E04: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 822A2E08: 485509C9  bl 0x827f37d0
	ctx.lr = 0x822A2E0C;
	sub_827F37D0(ctx, base);
	// 822A2E0C: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 822A2E10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822A2E14: 4BFEA245  bl 0x8228d058
	ctx.lr = 0x822A2E18;
	sub_8228D058(ctx, base);
	// 822A2E18: 395E0080  addi r10, r30, 0x80
	ctx.r[10].s64 = ctx.r[30].s64 + 128;
	// 822A2E1C: 39610130  addi r11, r1, 0x130
	ctx.r[11].s64 = ctx.r[1].s64 + 304;
	// 822A2E20: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 822A2E24: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x822A2E28; continue 'dispatch;
            }
            0x822A2E28 => {
    //   block [0x822A2E28..0x822A2E4C)
	// 822A2E28: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822A2E2C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 822A2E30: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822A2E34: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A2E38: 4200FFF0  bdnz 0x822a2e28
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822A2E28; continue 'dispatch;
	}
	// 822A2E3C: 395E0040  addi r10, r30, 0x40
	ctx.r[10].s64 = ctx.r[30].s64 + 64;
	// 822A2E40: 39610170  addi r11, r1, 0x170
	ctx.r[11].s64 = ctx.r[1].s64 + 368;
	// 822A2E44: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 822A2E48: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x822A2E4C; continue 'dispatch;
            }
            0x822A2E4C => {
    //   block [0x822A2E4C..0x822A2E7C)
	// 822A2E4C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822A2E50: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 822A2E54: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822A2E58: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A2E5C: 4200FFF0  bdnz 0x822a2e4c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822A2E4C; continue 'dispatch;
	}
	// 822A2E60: 817E00D0  lwz r11, 0xd0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 822A2E64: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 822A2E68: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822A2E6C: 917E00D0  stw r11, 0xd0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 822A2E70: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 822A2E74: 41980008  blt cr6, 0x822a2e7c
	if ctx.cr[6].lt {
	pc = 0x822A2E7C; continue 'dispatch;
	}
	// 822A2E78: 92FE00D0  stw r23, 0xd0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(208 as u32), ctx.r[23].u32 ) };
	pc = 0x822A2E7C; continue 'dispatch;
            }
            0x822A2E7C => {
    //   block [0x822A2E7C..0x822A3968)
	// 822A2E7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822A2E80: C001010C  lfs f0, 0x10c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A2E84: 3941006C  addi r10, r1, 0x6c
	ctx.r[10].s64 = ctx.r[1].s64 + 108;
	// 822A2E88: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822A2E8C: 3BABCBBC  addi r29, r11, -0x3444
	ctx.r[29].s64 = ctx.r[11].s64 + -13380;
	// 822A2E90: C1A10108  lfs f13, 0x108(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822A2E94: 38C1006C  addi r6, r1, 0x6c
	ctx.r[6].s64 = ctx.r[1].s64 + 108;
	// 822A2E98: D1A100B0  stfs f13, 0xb0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 822A2E9C: 39010110  addi r8, r1, 0x110
	ctx.r[8].s64 = ctx.r[1].s64 + 272;
	// 822A2EA0: 80FE00D0  lwz r7, 0xd0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 822A2EA4: 392100B0  addi r9, r1, 0xb0
	ctx.r[9].s64 = ctx.r[1].s64 + 176;
	// 822A2EA8: 80BE00C4  lwz r5, 0xc4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A3968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A3968 size=652
    let mut pc: u32 = 0x822A3968;
    'dispatch: loop {
        match pc {
            0x822A3968 => {
    //   block [0x822A3968..0x822A39B0)
	// 822A3968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A396C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A3970: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822A3974: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A3978: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822A397C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A3980: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822A3984: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822A3988: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822A398C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A3990: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A3994: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 822A3998: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A399C: 419A0014  beq cr6, 0x822a39b0
	if ctx.cr[6].eq {
	pc = 0x822A39B0; continue 'dispatch;
	}
	// 822A39A0: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 822A39A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A39A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A39AC: 409A0008  bne cr6, 0x822a39b4
	if !ctx.cr[6].eq {
	pc = 0x822A39B4; continue 'dispatch;
	}
	pc = 0x822A39B0; continue 'dispatch;
            }
            0x822A39B0 => {
    //   block [0x822A39B0..0x822A39B4)
	// 822A39B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822A39B4; continue 'dispatch;
            }
            0x822A39B4 => {
    //   block [0x822A39B4..0x822A3A0C)
	// 822A39B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A39B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A39BC: 409A021C  bne cr6, 0x822a3bd8
	if !ctx.cr[6].eq {
	pc = 0x822A3BD8; continue 'dispatch;
	}
	// 822A39C0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822A39C4: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A39C8: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 822A39CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A39D0: C3EA6C58  lfs f31, 0x6c58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27736 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822A39D4: 419A0038  beq cr6, 0x822a3a0c
	if ctx.cr[6].eq {
	pc = 0x822A3A0C; continue 'dispatch;
	}
	// 822A39D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A39DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A39E0: 419A0084  beq cr6, 0x822a3a64
	if ctx.cr[6].eq {
	pc = 0x822A3A64; continue 'dispatch;
	}
	// 822A39E4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822A39E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A39EC: 419A0020  beq cr6, 0x822a3a0c
	if ctx.cr[6].eq {
	pc = 0x822A3A0C; continue 'dispatch;
	}
	// 822A39F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A39F4: 4BED0445  bl 0x82173e38
	ctx.lr = 0x822A39F8;
	sub_82173E38(ctx, base);
	// 822A39F8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 822A39FC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822A3A00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A3A04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A3A08: 409A0008  bne cr6, 0x822a3a10
	if !ctx.cr[6].eq {
	pc = 0x822A3A10; continue 'dispatch;
	}
	pc = 0x822A3A0C; continue 'dispatch;
            }
            0x822A3A0C => {
    //   block [0x822A3A0C..0x822A3A10)
	// 822A3A0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822A3A10; continue 'dispatch;
            }
            0x822A3A10 => {
    //   block [0x822A3A10..0x822A3A64)
	// 822A3A10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A3A14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A3A18: 419A01A4  beq cr6, 0x822a3bbc
	if ctx.cr[6].eq {
	pc = 0x822A3BBC; continue 'dispatch;
	}
	// 822A3A1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A3A20: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822A3A24: 4BED0415  bl 0x82173e38
	ctx.lr = 0x822A3A28;
	sub_82173E38(ctx, base);
	// 822A3A28: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822A3A2C: 556AD7FE  rlwinm r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 822A3A30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A3A34: 419A0104  beq cr6, 0x822a3b38
	if ctx.cr[6].eq {
	pc = 0x822A3B38; continue 'dispatch;
	}
	// 822A3A38: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A3A3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A3A40: 419A0030  beq cr6, 0x822a3a70
	if ctx.cr[6].eq {
	pc = 0x822A3A70; continue 'dispatch;
	}
	// 822A3A44: 894B0066  lbz r10, 0x66(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(102 as u32) ) } as u64;
	// 822A3A48: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A3A4C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822A3A50: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822A3A54: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A3A58: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822A3A5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A3A60: 480000DC  b 0x822a3b3c
	pc = 0x822A3B3C; continue 'dispatch;
            }
            0x822A3A64 => {
    //   block [0x822A3A64..0x822A3A70)
	// 822A3A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A3A68: 4BEF03D1  bl 0x82193e38
	ctx.lr = 0x822A3A6C;
	sub_82193E38(ctx, base);
	// 822A3A6C: 4BFFFFA0  b 0x822a3a0c
	pc = 0x822A3A0C; continue 'dispatch;
            }
            0x822A3A70 => {
    //   block [0x822A3A70..0x822A3A90)
	// 822A3A70: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A3A74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822A3A78: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A3A7C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822A3A80: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A3A84: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822A3A88: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A3A8C: 40810054  ble 0x822a3ae0
	if !ctx.cr[0].gt {
	pc = 0x822A3AE0; continue 'dispatch;
	}
	pc = 0x822A3A90; continue 'dispatch;
            }
            0x822A3A90 => {
    //   block [0x822A3A90..0x822A3AB0)
	// 822A3A90: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A3A94: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A3A98: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822A3A9C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A3AA0: 2F070066  cmpwi cr6, r7, 0x66
	ctx.cr[6].compare_i32(ctx.r[7].s32, 102, &mut ctx.xer);
	// 822A3AA4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822A3AA8: 41980008  blt cr6, 0x822a3ab0
	if ctx.cr[6].lt {
	pc = 0x822A3AB0; continue 'dispatch;
	}
	// 822A3AAC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822A3AB0; continue 'dispatch;
            }
            0x822A3AB0 => {
    //   block [0x822A3AB0..0x822A3ACC)
	// 822A3AB0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A3AB4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A3AB8: 419A0014  beq cr6, 0x822a3acc
	if ctx.cr[6].eq {
	pc = 0x822A3ACC; continue 'dispatch;
	}
	// 822A3ABC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A3AC0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A3AC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A3AC8: 4800000C  b 0x822a3ad4
	pc = 0x822A3AD4; continue 'dispatch;
            }
            0x822A3ACC => {
    //   block [0x822A3ACC..0x822A3AD4)
	// 822A3ACC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A3AD0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822A3AD4; continue 'dispatch;
            }
            0x822A3AD4 => {
    //   block [0x822A3AD4..0x822A3AE0)
	// 822A3AD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A3AD8: 4199FFB8  bgt cr6, 0x822a3a90
	if ctx.cr[6].gt {
	pc = 0x822A3A90; continue 'dispatch;
	}
	// 822A3ADC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822A3AE0; continue 'dispatch;
            }
            0x822A3AE0 => {
    //   block [0x822A3AE0..0x822A3AFC)
	// 822A3AE0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A3AE4: 419A0040  beq cr6, 0x822a3b24
	if ctx.cr[6].eq {
	pc = 0x822A3B24; continue 'dispatch;
	}
	// 822A3AE8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A3AEC: 2F0B0066  cmpwi cr6, r11, 0x66
	ctx.cr[6].compare_i32(ctx.r[11].s32, 102, &mut ctx.xer);
	// 822A3AF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A3AF4: 41990008  bgt cr6, 0x822a3afc
	if ctx.cr[6].gt {
	pc = 0x822A3AFC; continue 'dispatch;
	}
	// 822A3AF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822A3AFC; continue 'dispatch;
            }
            0x822A3AFC => {
    //   block [0x822A3AFC..0x822A3B24)
	// 822A3AFC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A3B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A3B04: 409A0020  bne cr6, 0x822a3b24
	if !ctx.cr[6].eq {
	pc = 0x822A3B24; continue 'dispatch;
	}
	// 822A3B08: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A3B0C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822A3B10: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822A3B14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A3B18: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822A3B1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A3B20: 4800001C  b 0x822a3b3c
	pc = 0x822A3B3C; continue 'dispatch;
            }
            0x822A3B24 => {
    //   block [0x822A3B24..0x822A3B38)
	// 822A3B24: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A3B28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A3B2C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822A3B30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A3B34: 48000008  b 0x822a3b3c
	pc = 0x822A3B3C; continue 'dispatch;
            }
            0x822A3B38 => {
    //   block [0x822A3B38..0x822A3B3C)
	// 822A3B38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822A3B3C; continue 'dispatch;
            }
            0x822A3B3C => {
    //   block [0x822A3B3C..0x822A3B88)
	// 822A3B3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A3B40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A3B44: 419A0078  beq cr6, 0x822a3bbc
	if ctx.cr[6].eq {
	pc = 0x822A3BBC; continue 'dispatch;
	}
	// 822A3B48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822A3B4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A3B50: 48009769  bl 0x822ad2b8
	ctx.lr = 0x822A3B54;
	sub_822AD2B8(ctx, base);
	// 822A3B54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822A3B58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A3B5C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 822A3B60: 4BFF7659  bl 0x8229b1b8
	ctx.lr = 0x822A3B64;
	sub_8229B1B8(ctx, base);
	// 822A3B64: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822A3B68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A3B6C: 419A0048  beq cr6, 0x822a3bb4
	if ctx.cr[6].eq {
	pc = 0x822A3BB4; continue 'dispatch;
	}
	// 822A3B70: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A3B74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A3B78: 409A0010  bne cr6, 0x822a3b88
	if !ctx.cr[6].eq {
	pc = 0x822A3B88; continue 'dispatch;
	}
	// 822A3B7C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 822A3B80: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 822A3B84: 48000008  b 0x822a3b8c
	pc = 0x822A3B8C; continue 'dispatch;
            }
            0x822A3B88 => {
    //   block [0x822A3B88..0x822A3B8C)
	// 822A3B88: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822A3B8C; continue 'dispatch;
            }
            0x822A3B8C => {
    //   block [0x822A3B8C..0x822A3BB4)
	// 822A3B8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A3B90: 4827BB41  bl 0x8251f6d0
	ctx.lr = 0x822A3B94;
	sub_8251F6D0(ctx, base);
	// 822A3B94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822A3B98: 419A001C  beq cr6, 0x822a3bb4
	if ctx.cr[6].eq {
	pc = 0x822A3BB4; continue 'dispatch;
	}
	// 822A3B9C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822A3BA0: C0030040  lfs f0, 0x40(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A3BA4: C1AB9484  lfs f13, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822A3BA8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822A3BAC: 419A0008  beq cr6, 0x822a3bb4
	if ctx.cr[6].eq {
	pc = 0x822A3BB4; continue 'dispatch;
	}
	// 822A3BB0: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x822A3BB4; continue 'dispatch;
            }
            0x822A3BB4 => {
    //   block [0x822A3BB4..0x822A3BBC)
	// 822A3BB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A3BB8: 4BF71221  bl 0x82214dd8
	ctx.lr = 0x822A3BBC;
	sub_82214DD8(ctx, base);
	pc = 0x822A3BBC; continue 'dispatch;
            }
            0x822A3BBC => {
    //   block [0x822A3BBC..0x822A3BD8)
	// 822A3BBC: C01E0184  lfs f0, 0x184(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A3BC0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 822A3BC4: 419A0014  beq cr6, 0x822a3bd8
	if ctx.cr[6].eq {
	pc = 0x822A3BD8; continue 'dispatch;
	}
	// 822A3BC8: D3FE0184  stfs f31, 0x184(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 822A3BCC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822A3BD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822A3BD4: 482B095D  bl 0x82554530
	ctx.lr = 0x822A3BD8;
	sub_82554530(ctx, base);
	pc = 0x822A3BD8; continue 'dispatch;
            }
            0x822A3BD8 => {
    //   block [0x822A3BD8..0x822A3BF4)
	// 822A3BD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822A3BDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A3BE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A3BE4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822A3BE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822A3BEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822A3BF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A3BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A3BF8 size=3212
    let mut pc: u32 = 0x822A3BF8;
    'dispatch: loop {
        match pc {
            0x822A3BF8 => {
    //   block [0x822A3BF8..0x822A3C38)
	// 822A3BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A3BFC: 48A057F5  bl 0x82ca93f0
	ctx.lr = 0x822A3C00;
	sub_82CA93D0(ctx, base);
	// 822A3C00: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 822A3C04: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 822A3C08: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A3C0C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822A3C10: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 822A3C14: 894B9477  lbz r10, -0x6b89(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-27529 as u32) ) } as u64;
	// 822A3C18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A3C1C: 419A0C58  beq cr6, 0x822a4874
	if ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A3C20: 8176004C  lwz r11, 0x4c(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A3C24: 3FC08332  lis r30, -0x7cce
	ctx.r[30].s64 = -2093875200;
	// 822A3C28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A3C2C: 4098000C  bge cr6, 0x822a3c38
	if !ctx.cr[6].lt {
	pc = 0x822A3C38; continue 'dispatch;
	}
	// 822A3C30: 817E9650  lwz r11, -0x69b0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822A3C34: 9176004C  stw r11, 0x4c(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	pc = 0x822A3C38; continue 'dispatch;
            }
            0x822A3C38 => {
    //   block [0x822A3C38..0x822A3C68)
	// 822A3C38: 89760021  lbz r11, 0x21(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[22].u32.wrapping_add(33 as u32) ) } as u64;
	// 822A3C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A3C40: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822A3C44: 3AEB6AB8  addi r23, r11, 0x6ab8
	ctx.r[23].s64 = ctx.r[11].s64 + 27320;
	// 822A3C48: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822A3C4C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A3C50: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822A3C54: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A3C58: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A3C5C: 419A000C  beq cr6, 0x822a3c68
	if ctx.cr[6].eq {
	pc = 0x822A3C68; continue 'dispatch;
	}
	// 822A3C60: 4BF88559  bl 0x8222c1b8
	ctx.lr = 0x822A3C64;
	sub_8222C1B8(ctx, base);
	// 822A3C64: 48000008  b 0x822a3c6c
	pc = 0x822A3C6C; continue 'dispatch;
            }
            0x822A3C68 => {
    //   block [0x822A3C68..0x822A3C6C)
	// 822A3C68: 48641E11  bl 0x828e5a78
	ctx.lr = 0x822A3C6C;
	sub_828E5A78(ctx, base);
	pc = 0x822A3C6C; continue 'dispatch;
            }
            0x822A3C6C => {
    //   block [0x822A3C6C..0x822A3C90)
	// 822A3C6C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822A3C70: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 822A3C74: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 822A3C78: 419A0018  beq cr6, 0x822a3c90
	if ctx.cr[6].eq {
	pc = 0x822A3C90; continue 'dispatch;
	}
	// 822A3C7C: 897A0090  lbz r11, 0x90(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(144 as u32) ) } as u64;
	// 822A3C80: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822A3C84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A3C88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A3C8C: 409A0008  bne cr6, 0x822a3c94
	if !ctx.cr[6].eq {
	pc = 0x822A3C94; continue 'dispatch;
	}
	pc = 0x822A3C90; continue 'dispatch;
            }
            0x822A3C90 => {
    //   block [0x822A3C90..0x822A3C94)
	// 822A3C90: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A3C94; continue 'dispatch;
            }
            0x822A3C94 => {
    //   block [0x822A3C94..0x822A3CE0)
	// 822A3C94: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A3C98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A3C9C: 419A0BD8  beq cr6, 0x822a4874
	if ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A3CA0: 83160004  lwz r24, 4(r22)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A3CA4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822A3CA8: 81580034  lwz r10, 0x34(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(52 as u32) ) } as u64;
	// 822A3CAC: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822A3CB0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A3CB4: 419A00E8  beq cr6, 0x822a3d9c
	if ctx.cr[6].eq {
	pc = 0x822A3D9C; continue 'dispatch;
	}
	// 822A3CB8: 8178008C  lwz r11, 0x8c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A3CBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A3CC0: 419A0020  beq cr6, 0x822a3ce0
	if ctx.cr[6].eq {
	pc = 0x822A3CE0; continue 'dispatch;
	}
	// 822A3CC4: 894B009F  lbz r10, 0x9f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(159 as u32) ) } as u64;
	// 822A3CC8: 81780048  lwz r11, 0x48(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A3CCC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822A3CD0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822A3CD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A3CD8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A3CDC: 480000C4  b 0x822a3da0
	pc = 0x822A3DA0; continue 'dispatch;
            }
            0x822A3CE0 => {
    //   block [0x822A3CE0..0x822A3CFC)
	// 822A3CE0: 81580048  lwz r10, 0x48(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A3CE4: 80D8004C  lwz r6, 0x4c(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A3CE8: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 822A3CEC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A3CF0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822A3CF4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A3CF8: 40810054  ble 0x822a3d4c
	if !ctx.cr[0].gt {
	pc = 0x822A3D4C; continue 'dispatch;
	}
	pc = 0x822A3CFC; continue 'dispatch;
            }
            0x822A3CFC => {
    //   block [0x822A3CFC..0x822A3D1C)
	// 822A3CFC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A3D00: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A3D04: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822A3D08: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A3D0C: 2F07009F  cmpwi cr6, r7, 0x9f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 159, &mut ctx.xer);
	// 822A3D10: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822A3D14: 41980008  blt cr6, 0x822a3d1c
	if ctx.cr[6].lt {
	pc = 0x822A3D1C; continue 'dispatch;
	}
	// 822A3D18: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x822A3D1C; continue 'dispatch;
            }
            0x822A3D1C => {
    //   block [0x822A3D1C..0x822A3D38)
	// 822A3D1C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A3D20: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A3D24: 419A0014  beq cr6, 0x822a3d38
	if ctx.cr[6].eq {
	pc = 0x822A3D38; continue 'dispatch;
	}
	// 822A3D28: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A3D2C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A3D30: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A3D34: 4800000C  b 0x822a3d40
	pc = 0x822A3D40; continue 'dispatch;
            }
            0x822A3D38 => {
    //   block [0x822A3D38..0x822A3D40)
	// 822A3D38: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A3D3C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822A3D40; continue 'dispatch;
            }
            0x822A3D40 => {
    //   block [0x822A3D40..0x822A3D4C)
	// 822A3D40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A3D44: 4199FFB8  bgt cr6, 0x822a3cfc
	if ctx.cr[6].gt {
	pc = 0x822A3CFC; continue 'dispatch;
	}
	// 822A3D48: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822A3D4C; continue 'dispatch;
            }
            0x822A3D4C => {
    //   block [0x822A3D4C..0x822A3D68)
	// 822A3D4C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A3D50: 419A003C  beq cr6, 0x822a3d8c
	if ctx.cr[6].eq {
	pc = 0x822A3D8C; continue 'dispatch;
	}
	// 822A3D54: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A3D58: 2F0B009F  cmpwi cr6, r11, 0x9f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 159, &mut ctx.xer);
	// 822A3D5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A3D60: 41990008  bgt cr6, 0x822a3d68
	if ctx.cr[6].gt {
	pc = 0x822A3D68; continue 'dispatch;
	}
	// 822A3D64: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A3D68; continue 'dispatch;
            }
            0x822A3D68 => {
    //   block [0x822A3D68..0x822A3D8C)
	// 822A3D68: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A3D6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A3D70: 409A001C  bne cr6, 0x822a3d8c
	if !ctx.cr[6].eq {
	pc = 0x822A3D8C; continue 'dispatch;
	}
	// 822A3D74: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A3D78: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A3D7C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822A3D80: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822A3D84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A3D88: 48000018  b 0x822a3da0
	pc = 0x822A3DA0; continue 'dispatch;
            }
            0x822A3D8C => {
    //   block [0x822A3D8C..0x822A3D9C)
	// 822A3D8C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A3D90: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A3D94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A3D98: 48000008  b 0x822a3da0
	pc = 0x822A3DA0; continue 'dispatch;
            }
            0x822A3D9C => {
    //   block [0x822A3D9C..0x822A3DA0)
	// 822A3D9C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x822A3DA0; continue 'dispatch;
            }
            0x822A3DA0 => {
    //   block [0x822A3DA0..0x822A3DD0)
	// 822A3DA0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822A3DA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A3DA8: 419A0034  beq cr6, 0x822a3ddc
	if ctx.cr[6].eq {
	pc = 0x822A3DDC; continue 'dispatch;
	}
	// 822A3DAC: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 822A3DB0: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822A3DB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A3DB8: 419A001C  beq cr6, 0x822a3dd4
	if ctx.cr[6].eq {
	pc = 0x822A3DD4; continue 'dispatch;
	}
	// 822A3DBC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A3DC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A3DC4: 419A000C  beq cr6, 0x822a3dd0
	if ctx.cr[6].eq {
	pc = 0x822A3DD0; continue 'dispatch;
	}
	// 822A3DC8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822A3DCC: 4800000C  b 0x822a3dd8
	pc = 0x822A3DD8; continue 'dispatch;
            }
            0x822A3DD0 => {
    //   block [0x822A3DD0..0x822A3DD4)
	// 822A3DD0: 4BEF0069  bl 0x82193e38
	ctx.lr = 0x822A3DD4;
	sub_82193E38(ctx, base);
	pc = 0x822A3DD4; continue 'dispatch;
            }
            0x822A3DD4 => {
    //   block [0x822A3DD4..0x822A3DD8)
	// 822A3DD4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A3DD8; continue 'dispatch;
            }
            0x822A3DD8 => {
    //   block [0x822A3DD8..0x822A3DDC)
	// 822A3DD8: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	pc = 0x822A3DDC; continue 'dispatch;
            }
            0x822A3DDC => {
    //   block [0x822A3DDC..0x822A3DF8)
	// 822A3DDC: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 822A3DE0: 419A0018  beq cr6, 0x822a3df8
	if ctx.cr[6].eq {
	pc = 0x822A3DF8; continue 'dispatch;
	}
	// 822A3DE4: 89780090  lbz r11, 0x90(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(144 as u32) ) } as u64;
	// 822A3DE8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822A3DEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A3DF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A3DF4: 409A0008  bne cr6, 0x822a3dfc
	if !ctx.cr[6].eq {
	pc = 0x822A3DFC; continue 'dispatch;
	}
	pc = 0x822A3DF8; continue 'dispatch;
            }
            0x822A3DF8 => {
    //   block [0x822A3DF8..0x822A3DFC)
	// 822A3DF8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A3DFC; continue 'dispatch;
            }
            0x822A3DFC => {
    //   block [0x822A3DFC..0x822A3E48)
	// 822A3DFC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A3E00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A3E04: 419A0A70  beq cr6, 0x822a4874
	if ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A3E08: 81780024  lwz r11, 0x24(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) } as u64;
	// 822A3E0C: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 822A3E10: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 822A3E14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A3E18: 419A00F4  beq cr6, 0x822a3f0c
	if ctx.cr[6].eq {
	pc = 0x822A3F0C; continue 'dispatch;
	}
	// 822A3E1C: 8178008C  lwz r11, 0x8c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A3E20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A3E24: 419A0024  beq cr6, 0x822a3e48
	if ctx.cr[6].eq {
	pc = 0x822A3E48; continue 'dispatch;
	}
	// 822A3E28: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 822A3E2C: 81780048  lwz r11, 0x48(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A3E30: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822A3E34: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822A3E38: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A3E3C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822A3E40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A3E44: 480000CC  b 0x822a3f10
	pc = 0x822A3F10; continue 'dispatch;
            }
            0x822A3E48 => {
    //   block [0x822A3E48..0x822A3E64)
	// 822A3E48: 81580048  lwz r10, 0x48(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A3E4C: 80D8004C  lwz r6, 0x4c(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A3E50: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 822A3E54: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A3E58: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822A3E5C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A3E60: 40810054  ble 0x822a3eb4
	if !ctx.cr[0].gt {
	pc = 0x822A3EB4; continue 'dispatch;
	}
	pc = 0x822A3E64; continue 'dispatch;
            }
            0x822A3E64 => {
    //   block [0x822A3E64..0x822A3E84)
	// 822A3E64: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A3E68: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A3E6C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822A3E70: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A3E74: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 822A3E78: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822A3E7C: 41980008  blt cr6, 0x822a3e84
	if ctx.cr[6].lt {
	pc = 0x822A3E84; continue 'dispatch;
	}
	// 822A3E80: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x822A3E84; continue 'dispatch;
            }
            0x822A3E84 => {
    //   block [0x822A3E84..0x822A3EA0)
	// 822A3E84: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A3E88: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A3E8C: 419A0014  beq cr6, 0x822a3ea0
	if ctx.cr[6].eq {
	pc = 0x822A3EA0; continue 'dispatch;
	}
	// 822A3E90: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A3E94: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A3E98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A3E9C: 4800000C  b 0x822a3ea8
	pc = 0x822A3EA8; continue 'dispatch;
            }
            0x822A3EA0 => {
    //   block [0x822A3EA0..0x822A3EA8)
	// 822A3EA0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A3EA4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822A3EA8; continue 'dispatch;
            }
            0x822A3EA8 => {
    //   block [0x822A3EA8..0x822A3EB4)
	// 822A3EA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A3EAC: 4199FFB8  bgt cr6, 0x822a3e64
	if ctx.cr[6].gt {
	pc = 0x822A3E64; continue 'dispatch;
	}
	// 822A3EB0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822A3EB4; continue 'dispatch;
            }
            0x822A3EB4 => {
    //   block [0x822A3EB4..0x822A3ED0)
	// 822A3EB4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A3EB8: 419A0040  beq cr6, 0x822a3ef8
	if ctx.cr[6].eq {
	pc = 0x822A3EF8; continue 'dispatch;
	}
	// 822A3EBC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A3EC0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 822A3EC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A3EC8: 41990008  bgt cr6, 0x822a3ed0
	if ctx.cr[6].gt {
	pc = 0x822A3ED0; continue 'dispatch;
	}
	// 822A3ECC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A3ED0; continue 'dispatch;
            }
            0x822A3ED0 => {
    //   block [0x822A3ED0..0x822A3EF8)
	// 822A3ED0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A3ED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A3ED8: 409A0020  bne cr6, 0x822a3ef8
	if !ctx.cr[6].eq {
	pc = 0x822A3EF8; continue 'dispatch;
	}
	// 822A3EDC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A3EE0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822A3EE4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822A3EE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A3EEC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822A3EF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A3EF4: 4800001C  b 0x822a3f10
	pc = 0x822A3F10; continue 'dispatch;
            }
            0x822A3EF8 => {
    //   block [0x822A3EF8..0x822A3F0C)
	// 822A3EF8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A3EFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A3F00: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822A3F04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A3F08: 48000008  b 0x822a3f10
	pc = 0x822A3F10; continue 'dispatch;
            }
            0x822A3F0C => {
    //   block [0x822A3F0C..0x822A3F10)
	// 822A3F0C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A3F10; continue 'dispatch;
            }
            0x822A3F10 => {
    //   block [0x822A3F10..0x822A3F40)
	// 822A3F10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A3F14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A3F18: 419A095C  beq cr6, 0x822a4874
	if ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A3F1C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822A3F20: 4BEECC41  bl 0x82190b60
	ctx.lr = 0x822A3F24;
	sub_82190B60(ctx, base);
	// 822A3F24: 81760060  lwz r11, 0x60(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(96 as u32) ) } as u64;
	// 822A3F28: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822A3F2C: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 822A3F30: 419A0010  beq cr6, 0x822a3f40
	if ctx.cr[6].eq {
	pc = 0x822A3F40; continue 'dispatch;
	}
	// 822A3F34: 817E9650  lwz r11, -0x69b0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822A3F38: 93960060  stw r28, 0x60(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 822A3F3C: 9176004C  stw r11, 0x4c(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	pc = 0x822A3F40; continue 'dispatch;
            }
            0x822A3F40 => {
    //   block [0x822A3F40..0x822A3F58)
	// 822A3F40: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822A3F44: 894B6B65  lbz r10, 0x6b65(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27493 as u32) ) } as u64;
	// 822A3F48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A3F4C: 419A000C  beq cr6, 0x822a3f58
	if ctx.cr[6].eq {
	pc = 0x822A3F58; continue 'dispatch;
	}
	// 822A3F50: 817E9650  lwz r11, -0x69b0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822A3F54: 9176004C  stw r11, 0x4c(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	pc = 0x822A3F58; continue 'dispatch;
            }
            0x822A3F58 => {
    //   block [0x822A3F58..0x822A4050)
	// 822A3F58: 8156004C  lwz r10, 0x4c(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A3F5C: 817E9650  lwz r11, -0x69b0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822A3F60: 7FCA5851  subf. r30, r10, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822A3F64: 41800910  blt 0x822a4874
	if ctx.cr[0].lt {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A3F68: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822A3F6C: 4BEECBF5  bl 0x82190b60
	ctx.lr = 0x822A3F70;
	sub_82190B60(ctx, base);
	// 822A3F70: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822A3F74: 3FA08332  lis r29, -0x7cce
	ctx.r[29].s64 = -2093875200;
	// 822A3F78: 394B9490  addi r10, r11, -0x6b70
	ctx.r[10].s64 = ctx.r[11].s64 + -27504;
	// 822A3F7C: 5469103A  slwi r9, r3, 2
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822A3F80: 7FC807B4  extsw r8, r30
	ctx.r[8].s64 = ctx.r[30].s32 as i64;
	// 822A3F84: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822A3F88: C9BD9660  lfd f13, -0x69a0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(-27040 as u32) ) };
	// 822A3F8C: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 822A3F90: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A3F94: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 822A3F98: 7D69542E  lfsx f11, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822A3F9C: FC006018  frsp f0, f12
	ctx.f[0].f64 = (ctx.f[12].f64 as f32) as f64;
	// 822A3FA0: FD4B0372  fmul f10, f11, f13
	ctx.f[10].f64 = ctx.f[11].f64 * ctx.f[13].f64;
	// 822A3FA4: 3B6BB4CC  addi r27, r11, -0x4b34
	ctx.r[27].s64 = ctx.r[11].s64 + -19252;
	// 822A3FA8: FDA05018  frsp f13, f10
	ctx.f[13].f64 = (ctx.f[10].f64 as f32) as f64;
	// 822A3FAC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822A3FB0: 409800A0  bge cr6, 0x822a4050
	if !ctx.cr[6].lt {
	pc = 0x822A4050; continue 'dispatch;
	}
	// 822A3FB4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 822A3FB8: EFE06824  fdivs f31, f0, f13
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 822A3FBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A3FC0: 48185F19  bl 0x82429ed8
	ctx.lr = 0x822A3FC4;
	sub_82429ED8(ctx, base);
	// 822A3FC4: 88C10052  lbz r6, 0x52(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 822A3FC8: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A3FCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822A3FD0: 89010051  lbz r8, 0x51(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 822A3FD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A3FD8: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 822A3FDC: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 822A3FE0: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822A3FE4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822A3FE8: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822A3FEC: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 822A3FF0: FD606E9C  fcfid f11, f13
	ctx.f[11].f64 = (ctx.f[13].s64 as f64);
	// 822A3FF4: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822A3FF8: FD40069C  fcfid f10, f0
	ctx.f[10].f64 = (ctx.f[0].s64 as f64);
	// 822A3FFC: FD205818  frsp f9, f11
	ctx.f[9].f64 = (ctx.f[11].f64 as f32) as f64;
	// 822A4000: FD00669C  fcfid f8, f12
	ctx.f[8].f64 = (ctx.f[12].s64 as f64);
	// 822A4004: FCE05018  frsp f7, f10
	ctx.f[7].f64 = (ctx.f[10].f64 as f32) as f64;
	// 822A4008: ECC907F2  fmuls f6, f9, f31
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[31].f64) as f32) as f64);
	// 822A400C: FCA04018  frsp f5, f8
	ctx.f[5].f64 = (ctx.f[8].f64 as f32) as f64;
	// 822A4010: EC8707F2  fmuls f4, f7, f31
	ctx.f[4].f64 = (((ctx.f[7].f64 * ctx.f[31].f64) as f32) as f64);
	// 822A4014: FC60365E  fctidz f3, f6
	ctx.f[3].s64 = if ctx.f[6].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[6].f64.trunc() as i64 };
	// 822A4018: D8610058  stfd f3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[3].u64 ) };
	// 822A401C: 8921005F  lbz r9, 0x5f(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 822A4020: EC4507F2  fmuls f2, f5, f31
	ctx.f[2].f64 = (((ctx.f[5].f64 * ctx.f[31].f64) as f32) as f64);
	// 822A4024: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 822A4028: FC20265E  fctidz f1, f4
	ctx.f[1].s64 = if ctx.f[4].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[4].f64.trunc() as i64 };
	// 822A402C: D8210058  stfd f1, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[1].u64 ) };
	// 822A4030: 8901005F  lbz r8, 0x5f(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 822A4034: FC00165E  fctidz f0, f2
	ctx.f[0].s64 = if ctx.f[2].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[2].f64.trunc() as i64 };
	// 822A4038: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 822A403C: 88E1005F  lbz r7, 0x5f(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 822A4040: 98E10051  stb r7, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[7].u8 ) };
	// 822A4044: 99010052  stb r8, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[8].u8 ) };
	// 822A4048: 482CF8A9  bl 0x825738f0
	ctx.lr = 0x822A404C;
	sub_825738F0(ctx, base);
	// 822A404C: 48000008  b 0x822a4054
	pc = 0x822A4054; continue 'dispatch;
            }
            0x822A4050 => {
    //   block [0x822A4050..0x822A4054)
	// 822A4050: C3FBDFC4  lfs f31, -0x203c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-8252 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x822A4054; continue 'dispatch;
            }
            0x822A4054 => {
    //   block [0x822A4054..0x822A40C0)
	// 822A4054: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4058: C01BDE08  lfs f0, -0x21f8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-8696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A405C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822A4060: EFFF0032  fmuls f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 822A4064: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A4068: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822A406C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4070: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4074: 4BF8E705  bl 0x82232778
	ctx.lr = 0x822A4078;
	sub_82232778(ctx, base);
	// 822A4078: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822A407C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822A4080: 419A012C  beq cr6, 0x822a41ac
	if ctx.cr[6].eq {
	pc = 0x822A41AC; continue 'dispatch;
	}
	// 822A4084: 815A002C  lwz r10, 0x2c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 822A4088: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822A408C: 55499FFE  rlwinm r9, r10, 0x13, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00001FFFu64;
	// 822A4090: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A4094: 419A00E8  beq cr6, 0x822a417c
	if ctx.cr[6].eq {
	pc = 0x822A417C; continue 'dispatch;
	}
	// 822A4098: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A409C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A40A0: 419A0020  beq cr6, 0x822a40c0
	if ctx.cr[6].eq {
	pc = 0x822A40C0; continue 'dispatch;
	}
	// 822A40A4: 894B004D  lbz r10, 0x4d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(77 as u32) ) } as u64;
	// 822A40A8: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A40AC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822A40B0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822A40B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A40B8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A40BC: 480000C4  b 0x822a4180
	pc = 0x822A4180; continue 'dispatch;
            }
            0x822A40C0 => {
    //   block [0x822A40C0..0x822A40DC)
	// 822A40C0: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A40C4: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A40C8: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 822A40CC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A40D0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822A40D4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A40D8: 40810054  ble 0x822a412c
	if !ctx.cr[0].gt {
	pc = 0x822A412C; continue 'dispatch;
	}
	pc = 0x822A40DC; continue 'dispatch;
            }
            0x822A40DC => {
    //   block [0x822A40DC..0x822A40FC)
	// 822A40DC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A40E0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A40E4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822A40E8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A40EC: 2F07004D  cmpwi cr6, r7, 0x4d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 77, &mut ctx.xer);
	// 822A40F0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822A40F4: 41980008  blt cr6, 0x822a40fc
	if ctx.cr[6].lt {
	pc = 0x822A40FC; continue 'dispatch;
	}
	// 822A40F8: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x822A40FC; continue 'dispatch;
            }
            0x822A40FC => {
    //   block [0x822A40FC..0x822A4118)
	// 822A40FC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A4100: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A4104: 419A0014  beq cr6, 0x822a4118
	if ctx.cr[6].eq {
	pc = 0x822A4118; continue 'dispatch;
	}
	// 822A4108: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A410C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A4110: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A4114: 4800000C  b 0x822a4120
	pc = 0x822A4120; continue 'dispatch;
            }
            0x822A4118 => {
    //   block [0x822A4118..0x822A4120)
	// 822A4118: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A411C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822A4120; continue 'dispatch;
            }
            0x822A4120 => {
    //   block [0x822A4120..0x822A412C)
	// 822A4120: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A4124: 4199FFB8  bgt cr6, 0x822a40dc
	if ctx.cr[6].gt {
	pc = 0x822A40DC; continue 'dispatch;
	}
	// 822A4128: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822A412C; continue 'dispatch;
            }
            0x822A412C => {
    //   block [0x822A412C..0x822A4148)
	// 822A412C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A4130: 419A003C  beq cr6, 0x822a416c
	if ctx.cr[6].eq {
	pc = 0x822A416C; continue 'dispatch;
	}
	// 822A4134: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4138: 2F0B004D  cmpwi cr6, r11, 0x4d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 77, &mut ctx.xer);
	// 822A413C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A4140: 41990008  bgt cr6, 0x822a4148
	if ctx.cr[6].gt {
	pc = 0x822A4148; continue 'dispatch;
	}
	// 822A4144: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A4148; continue 'dispatch;
            }
            0x822A4148 => {
    //   block [0x822A4148..0x822A416C)
	// 822A4148: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A414C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A4150: 409A001C  bne cr6, 0x822a416c
	if !ctx.cr[6].eq {
	pc = 0x822A416C; continue 'dispatch;
	}
	// 822A4154: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A4158: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A415C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822A4160: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822A4164: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4168: 48000018  b 0x822a4180
	pc = 0x822A4180; continue 'dispatch;
            }
            0x822A416C => {
    //   block [0x822A416C..0x822A417C)
	// 822A416C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A4170: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A4174: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4178: 48000008  b 0x822a4180
	pc = 0x822A4180; continue 'dispatch;
            }
            0x822A417C => {
    //   block [0x822A417C..0x822A4180)
	// 822A417C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x822A4180; continue 'dispatch;
            }
            0x822A4180 => {
    //   block [0x822A4180..0x822A41AC)
	// 822A4180: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822A4184: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A4188: 419A0024  beq cr6, 0x822a41ac
	if ctx.cr[6].eq {
	pc = 0x822A41AC; continue 'dispatch;
	}
	// 822A418C: 386B00C4  addi r3, r11, 0xc4
	ctx.r[3].s64 = ctx.r[11].s64 + 196;
	// 822A4190: 80960004  lwz r4, 4(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4194: 4822BB25  bl 0x824cfcb8
	ctx.lr = 0x822A4198;
	sub_824CFCB8(ctx, base);
	// 822A4198: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822A419C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A41A0: 419A000C  beq cr6, 0x822a41ac
	if ctx.cr[6].eq {
	pc = 0x822A41AC; continue 'dispatch;
	}
	// 822A41A4: C01BFFB4  lfs f0, -0x4c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A41A8: EFFF0032  fmuls f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x822A41AC; continue 'dispatch;
            }
            0x822A41AC => {
    //   block [0x822A41AC..0x822A4260)
	// 822A41AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822A41B0: C81D9660  lfd f0, -0x69a0(r29)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(-27040 as u32) ) };
	// 822A41B4: 7FCA07B4  extsw r10, r30
	ctx.r[10].s64 = ctx.r[30].s32 as i64;
	// 822A41B8: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 822A41BC: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 822A41C0: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822A41C4: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 822A41C8: C9AB0DF0  lfd f13, 0xdf0(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3568 as u32) ) };
	// 822A41CC: FD600372  fmul f11, f0, f13
	ctx.f[11].f64 = ctx.f[0].f64 * ctx.f[13].f64;
	// 822A41D0: D3E96C70  stfs f31, 0x6c70(r9)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(27760 as u32), tmp.u32 ) };
	// 822A41D4: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 822A41D8: 4198069C  blt cr6, 0x822a4874
	if ctx.cr[6].lt {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A41DC: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A41E0: 388000B5  li r4, 0xb5
	ctx.r[4].s64 = 181;
	// 822A41E4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A41E8: 814B00A8  lwz r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 822A41EC: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A41F0: 4BF11071  bl 0x821b5260
	ctx.lr = 0x822A41F4;
	sub_821B5260(ctx, base);
	// 822A41F4: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822A41F8: 409A0150  bne cr6, 0x822a4348
	if !ctx.cr[6].eq {
	pc = 0x822A4348; continue 'dispatch;
	}
	// 822A41FC: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4200: 38800033  li r4, 0x33
	ctx.r[4].s64 = 51;
	// 822A4204: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A4208: 814B00A8  lwz r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 822A420C: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4210: 4BF11051  bl 0x821b5260
	ctx.lr = 0x822A4214;
	sub_821B5260(ctx, base);
	// 822A4214: 81380024  lwz r9, 0x24(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) } as u64;
	// 822A4218: 552837FE  rlwinm r8, r9, 6, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x03FFFFFFu64;
	// 822A421C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822A4220: 419A0654  beq cr6, 0x822a4874
	if ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A4224: 815A002C  lwz r10, 0x2c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 822A4228: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822A422C: 55499FFE  rlwinm r9, r10, 0x13, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00001FFFu64;
	// 822A4230: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A4234: 419A00E8  beq cr6, 0x822a431c
	if ctx.cr[6].eq {
	pc = 0x822A431C; continue 'dispatch;
	}
	// 822A4238: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A423C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A4240: 419A0020  beq cr6, 0x822a4260
	if ctx.cr[6].eq {
	pc = 0x822A4260; continue 'dispatch;
	}
	// 822A4244: 894B004D  lbz r10, 0x4d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(77 as u32) ) } as u64;
	// 822A4248: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A424C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822A4250: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822A4254: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A4258: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A425C: 480000C4  b 0x822a4320
	pc = 0x822A4320; continue 'dispatch;
            }
            0x822A4260 => {
    //   block [0x822A4260..0x822A427C)
	// 822A4260: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A4264: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A4268: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 822A426C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A4270: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822A4274: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A4278: 40810054  ble 0x822a42cc
	if !ctx.cr[0].gt {
	pc = 0x822A42CC; continue 'dispatch;
	}
	pc = 0x822A427C; continue 'dispatch;
            }
            0x822A427C => {
    //   block [0x822A427C..0x822A429C)
	// 822A427C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A4280: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A4284: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822A4288: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A428C: 2F07004D  cmpwi cr6, r7, 0x4d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 77, &mut ctx.xer);
	// 822A4290: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822A4294: 41980008  blt cr6, 0x822a429c
	if ctx.cr[6].lt {
	pc = 0x822A429C; continue 'dispatch;
	}
	// 822A4298: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x822A429C; continue 'dispatch;
            }
            0x822A429C => {
    //   block [0x822A429C..0x822A42B8)
	// 822A429C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A42A0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A42A4: 419A0014  beq cr6, 0x822a42b8
	if ctx.cr[6].eq {
	pc = 0x822A42B8; continue 'dispatch;
	}
	// 822A42A8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A42AC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A42B0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A42B4: 4800000C  b 0x822a42c0
	pc = 0x822A42C0; continue 'dispatch;
            }
            0x822A42B8 => {
    //   block [0x822A42B8..0x822A42C0)
	// 822A42B8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A42BC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822A42C0; continue 'dispatch;
            }
            0x822A42C0 => {
    //   block [0x822A42C0..0x822A42CC)
	// 822A42C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A42C4: 4199FFB8  bgt cr6, 0x822a427c
	if ctx.cr[6].gt {
	pc = 0x822A427C; continue 'dispatch;
	}
	// 822A42C8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822A42CC; continue 'dispatch;
            }
            0x822A42CC => {
    //   block [0x822A42CC..0x822A42E8)
	// 822A42CC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A42D0: 419A003C  beq cr6, 0x822a430c
	if ctx.cr[6].eq {
	pc = 0x822A430C; continue 'dispatch;
	}
	// 822A42D4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A42D8: 2F0B004D  cmpwi cr6, r11, 0x4d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 77, &mut ctx.xer);
	// 822A42DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A42E0: 41990008  bgt cr6, 0x822a42e8
	if ctx.cr[6].gt {
	pc = 0x822A42E8; continue 'dispatch;
	}
	// 822A42E4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A42E8; continue 'dispatch;
            }
            0x822A42E8 => {
    //   block [0x822A42E8..0x822A430C)
	// 822A42E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A42EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A42F0: 409A001C  bne cr6, 0x822a430c
	if !ctx.cr[6].eq {
	pc = 0x822A430C; continue 'dispatch;
	}
	// 822A42F4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A42F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A42FC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822A4300: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822A4304: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4308: 48000018  b 0x822a4320
	pc = 0x822A4320; continue 'dispatch;
            }
            0x822A430C => {
    //   block [0x822A430C..0x822A431C)
	// 822A430C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A4310: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A4314: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4318: 48000008  b 0x822a4320
	pc = 0x822A4320; continue 'dispatch;
            }
            0x822A431C => {
    //   block [0x822A431C..0x822A4320)
	// 822A431C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x822A4320; continue 'dispatch;
            }
            0x822A4320 => {
    //   block [0x822A4320..0x822A4348)
	// 822A4320: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822A4324: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A4328: 419A054C  beq cr6, 0x822a4874
	if ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A432C: 386B00C4  addi r3, r11, 0xc4
	ctx.r[3].s64 = ctx.r[11].s64 + 196;
	// 822A4330: 80960004  lwz r4, 4(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4334: 4822B985  bl 0x824cfcb8
	ctx.lr = 0x822A4338;
	sub_824CFCB8(ctx, base);
	// 822A4338: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 822A433C: CBC1FF98  lfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 822A4340: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 822A4344: 48A050FC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x822A4348 => {
    //   block [0x822A4348..0x822A4380)
	// 822A4348: 2F1C0003  cmpwi cr6, r28, 3
	ctx.cr[6].compare_i32(ctx.r[28].s32, 3, &mut ctx.xer);
	// 822A434C: 409A0034  bne cr6, 0x822a4380
	if !ctx.cr[6].eq {
	pc = 0x822A4380; continue 'dispatch;
	}
	// 822A4350: 81780024  lwz r11, 0x24(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) } as u64;
	// 822A4354: 556A37FE  rlwinm r10, r11, 6, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 822A4358: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A435C: 419A0518  beq cr6, 0x822a4874
	if ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A4360: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4364: 388000B6  li r4, 0xb6
	ctx.r[4].s64 = 182;
	// 822A4368: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A436C: 814B00A8  lwz r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 822A4370: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4374: 4BF10EED  bl 0x821b5260
	ctx.lr = 0x822A4378;
	sub_821B5260(ctx, base);
	// 822A4378: 388000B8  li r4, 0xb8
	ctx.r[4].s64 = 184;
	// 822A437C: 480004E4  b 0x822a4860
	pc = 0x822A4860; continue 'dispatch;
            }
            0x822A4380 => {
    //   block [0x822A4380..0x822A43DC)
	// 822A4380: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 822A4384: 409A04F0  bne cr6, 0x822a4874
	if !ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A4388: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A438C: 38800034  li r4, 0x34
	ctx.r[4].s64 = 52;
	// 822A4390: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A4394: 814B00A8  lwz r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 822A4398: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A439C: 4BF10EC5  bl 0x821b5260
	ctx.lr = 0x822A43A0;
	sub_821B5260(ctx, base);
	// 822A43A0: 813A0028  lwz r9, 0x28(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 822A43A4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822A43A8: 55283FFE  rlwinm r8, r9, 7, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x01FFFFFFu64;
	// 822A43AC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822A43B0: 419A00E8  beq cr6, 0x822a4498
	if ctx.cr[6].eq {
	pc = 0x822A4498; continue 'dispatch;
	}
	// 822A43B4: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A43B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A43BC: 419A0020  beq cr6, 0x822a43dc
	if ctx.cr[6].eq {
	pc = 0x822A43DC; continue 'dispatch;
	}
	// 822A43C0: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 822A43C4: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A43C8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822A43CC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822A43D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A43D4: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A43D8: 480000C4  b 0x822a449c
	pc = 0x822A449C; continue 'dispatch;
            }
            0x822A43DC => {
    //   block [0x822A43DC..0x822A43F8)
	// 822A43DC: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A43E0: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A43E4: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 822A43E8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A43EC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822A43F0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A43F4: 40810054  ble 0x822a4448
	if !ctx.cr[0].gt {
	pc = 0x822A4448; continue 'dispatch;
	}
	pc = 0x822A43F8; continue 'dispatch;
            }
            0x822A43F8 => {
    //   block [0x822A43F8..0x822A4418)
	// 822A43F8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A43FC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A4400: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822A4404: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4408: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 822A440C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822A4410: 41980008  blt cr6, 0x822a4418
	if ctx.cr[6].lt {
	pc = 0x822A4418; continue 'dispatch;
	}
	// 822A4414: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x822A4418; continue 'dispatch;
            }
            0x822A4418 => {
    //   block [0x822A4418..0x822A4434)
	// 822A4418: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A441C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A4420: 419A0014  beq cr6, 0x822a4434
	if ctx.cr[6].eq {
	pc = 0x822A4434; continue 'dispatch;
	}
	// 822A4424: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A4428: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A442C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A4430: 4800000C  b 0x822a443c
	pc = 0x822A443C; continue 'dispatch;
            }
            0x822A4434 => {
    //   block [0x822A4434..0x822A443C)
	// 822A4434: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A4438: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822A443C; continue 'dispatch;
            }
            0x822A443C => {
    //   block [0x822A443C..0x822A4448)
	// 822A443C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A4440: 4199FFB8  bgt cr6, 0x822a43f8
	if ctx.cr[6].gt {
	pc = 0x822A43F8; continue 'dispatch;
	}
	// 822A4444: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822A4448; continue 'dispatch;
            }
            0x822A4448 => {
    //   block [0x822A4448..0x822A4464)
	// 822A4448: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A444C: 419A003C  beq cr6, 0x822a4488
	if ctx.cr[6].eq {
	pc = 0x822A4488; continue 'dispatch;
	}
	// 822A4450: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4454: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 822A4458: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A445C: 41990008  bgt cr6, 0x822a4464
	if ctx.cr[6].gt {
	pc = 0x822A4464; continue 'dispatch;
	}
	// 822A4460: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A4464; continue 'dispatch;
            }
            0x822A4464 => {
    //   block [0x822A4464..0x822A4488)
	// 822A4464: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A4468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A446C: 409A001C  bne cr6, 0x822a4488
	if !ctx.cr[6].eq {
	pc = 0x822A4488; continue 'dispatch;
	}
	// 822A4470: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A4474: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822A4478: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822A447C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4480: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A4484: 48000018  b 0x822a449c
	pc = 0x822A449C; continue 'dispatch;
            }
            0x822A4488 => {
    //   block [0x822A4488..0x822A4498)
	// 822A4488: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A448C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4490: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A4494: 48000008  b 0x822a449c
	pc = 0x822A449C; continue 'dispatch;
            }
            0x822A4498 => {
    //   block [0x822A4498..0x822A449C)
	// 822A4498: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A449C; continue 'dispatch;
            }
            0x822A449C => {
    //   block [0x822A449C..0x822A4500)
	// 822A449C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A44A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A44A4: 419A03D0  beq cr6, 0x822a4874
	if ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A44A8: C3E30018  lfs f31, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822A44AC: C3C30014  lfs f30, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822A44B0: 4BF98E71  bl 0x8223d320
	ctx.lr = 0x822A44B4;
	sub_8223D320(ctx, base);
	// 822A44B4: EDA1F028  fsubs f13, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[30].f64) as f32) as f64);
	// 822A44B8: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A44BC: ED9FF028  fsubs f12, f31, f30
	ctx.f[12].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 822A44C0: ED6D6024  fdivs f11, f13, f12
	ctx.f[11].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 822A44C4: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 822A44C8: 409903AC  ble cr6, 0x822a4874
	if !ctx.cr[6].gt {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A44CC: 8976002A  lbz r11, 0x2a(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[22].u32.wrapping_add(42 as u32) ) } as u64;
	// 822A44D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A44D4: 419A002C  beq cr6, 0x822a4500
	if ctx.cr[6].eq {
	pc = 0x822A4500; continue 'dispatch;
	}
	// 822A44D8: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A44DC: 38800058  li r4, 0x58
	ctx.r[4].s64 = 88;
	// 822A44E0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A44E4: 814B00A8  lwz r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 822A44E8: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A44EC: 48004F65  bl 0x822a9450
	ctx.lr = 0x822A44F0;
	sub_822A9450(ctx, base);
	// 822A44F0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822A44F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A44F8: 409A0008  bne cr6, 0x822a4500
	if !ctx.cr[6].eq {
	pc = 0x822A4500; continue 'dispatch;
	}
	// 822A44FC: 9B36002A  stb r25, 0x2a(r22)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[22].u32.wrapping_add(42 as u32), ctx.r[25].u8 ) };
	pc = 0x822A4500; continue 'dispatch;
            }
            0x822A4500 => {
    //   block [0x822A4500..0x822A4548)
	// 822A4500: 8976002A  lbz r11, 0x2a(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[22].u32.wrapping_add(42 as u32) ) } as u64;
	// 822A4504: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A4508: 409A036C  bne cr6, 0x822a4874
	if !ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A450C: 815A0028  lwz r10, 0x28(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 822A4510: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822A4514: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 822A4518: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A451C: 419A00E4  beq cr6, 0x822a4600
	if ctx.cr[6].eq {
	pc = 0x822A4600; continue 'dispatch;
	}
	// 822A4520: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A4524: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A4528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A452C: 419A001C  beq cr6, 0x822a4548
	if ctx.cr[6].eq {
	pc = 0x822A4548; continue 'dispatch;
	}
	// 822A4530: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822A4534: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 822A4538: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822A453C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4540: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A4544: 480000C0  b 0x822a4604
	pc = 0x822A4604; continue 'dispatch;
            }
            0x822A4548 => {
    //   block [0x822A4548..0x822A4560)
	// 822A4548: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A454C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 822A4550: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A4554: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822A4558: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A455C: 40810054  ble 0x822a45b0
	if !ctx.cr[0].gt {
	pc = 0x822A45B0; continue 'dispatch;
	}
	pc = 0x822A4560; continue 'dispatch;
            }
            0x822A4560 => {
    //   block [0x822A4560..0x822A4580)
	// 822A4560: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A4564: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A4568: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822A456C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4570: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 822A4574: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822A4578: 41980008  blt cr6, 0x822a4580
	if ctx.cr[6].lt {
	pc = 0x822A4580; continue 'dispatch;
	}
	// 822A457C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x822A4580; continue 'dispatch;
            }
            0x822A4580 => {
    //   block [0x822A4580..0x822A459C)
	// 822A4580: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A4584: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A4588: 419A0014  beq cr6, 0x822a459c
	if ctx.cr[6].eq {
	pc = 0x822A459C; continue 'dispatch;
	}
	// 822A458C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A4590: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A4594: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A4598: 4800000C  b 0x822a45a4
	pc = 0x822A45A4; continue 'dispatch;
            }
            0x822A459C => {
    //   block [0x822A459C..0x822A45A4)
	// 822A459C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A45A0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822A45A4; continue 'dispatch;
            }
            0x822A45A4 => {
    //   block [0x822A45A4..0x822A45B0)
	// 822A45A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A45A8: 4199FFB8  bgt cr6, 0x822a4560
	if ctx.cr[6].gt {
	pc = 0x822A4560; continue 'dispatch;
	}
	// 822A45AC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822A45B0; continue 'dispatch;
            }
            0x822A45B0 => {
    //   block [0x822A45B0..0x822A45CC)
	// 822A45B0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A45B4: 419A003C  beq cr6, 0x822a45f0
	if ctx.cr[6].eq {
	pc = 0x822A45F0; continue 'dispatch;
	}
	// 822A45B8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A45BC: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 822A45C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A45C4: 41990008  bgt cr6, 0x822a45cc
	if ctx.cr[6].gt {
	pc = 0x822A45CC; continue 'dispatch;
	}
	// 822A45C8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A45CC; continue 'dispatch;
            }
            0x822A45CC => {
    //   block [0x822A45CC..0x822A45F0)
	// 822A45CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A45D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A45D4: 409A001C  bne cr6, 0x822a45f0
	if !ctx.cr[6].eq {
	pc = 0x822A45F0; continue 'dispatch;
	}
	// 822A45D8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A45DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A45E0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822A45E4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822A45E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A45EC: 48000018  b 0x822a4604
	pc = 0x822A4604; continue 'dispatch;
            }
            0x822A45F0 => {
    //   block [0x822A45F0..0x822A4600)
	// 822A45F0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A45F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A45F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A45FC: 48000008  b 0x822a4604
	pc = 0x822A4604; continue 'dispatch;
            }
            0x822A4600 => {
    //   block [0x822A4600..0x822A4604)
	// 822A4600: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x822A4604; continue 'dispatch;
            }
            0x822A4604 => {
    //   block [0x822A4604..0x822A4660)
	// 822A4604: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822A4608: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A460C: 419A0268  beq cr6, 0x822a4874
	if ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A4610: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822A4614: 4BF49D35  bl 0x821ee348
	ctx.lr = 0x822A4618;
	sub_821EE348(ctx, base);
	// 822A4618: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822A461C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A4620: 409A0254  bne cr6, 0x822a4874
	if !ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A4624: 81580024  lwz r10, 0x24(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) } as u64;
	// 822A4628: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822A462C: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 822A4630: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A4634: 419A00E4  beq cr6, 0x822a4718
	if ctx.cr[6].eq {
	pc = 0x822A4718; continue 'dispatch;
	}
	// 822A4638: 8178008C  lwz r11, 0x8c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A463C: 81580048  lwz r10, 0x48(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A4640: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A4644: 419A001C  beq cr6, 0x822a4660
	if ctx.cr[6].eq {
	pc = 0x822A4660; continue 'dispatch;
	}
	// 822A4648: 896B0014  lbz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A464C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 822A4650: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822A4654: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4658: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A465C: 480000C0  b 0x822a471c
	pc = 0x822A471C; continue 'dispatch;
            }
            0x822A4660 => {
    //   block [0x822A4660..0x822A4678)
	// 822A4660: 80D8004C  lwz r6, 0x4c(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A4664: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 822A4668: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A466C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822A4670: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A4674: 40810054  ble 0x822a46c8
	if !ctx.cr[0].gt {
	pc = 0x822A46C8; continue 'dispatch;
	}
	pc = 0x822A4678; continue 'dispatch;
            }
            0x822A4678 => {
    //   block [0x822A4678..0x822A4698)
	// 822A4678: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A467C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A4680: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822A4684: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4688: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 822A468C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822A4690: 41980008  blt cr6, 0x822a4698
	if ctx.cr[6].lt {
	pc = 0x822A4698; continue 'dispatch;
	}
	// 822A4694: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x822A4698; continue 'dispatch;
            }
            0x822A4698 => {
    //   block [0x822A4698..0x822A46B4)
	// 822A4698: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A469C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A46A0: 419A0014  beq cr6, 0x822a46b4
	if ctx.cr[6].eq {
	pc = 0x822A46B4; continue 'dispatch;
	}
	// 822A46A4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A46A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A46AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A46B0: 4800000C  b 0x822a46bc
	pc = 0x822A46BC; continue 'dispatch;
            }
            0x822A46B4 => {
    //   block [0x822A46B4..0x822A46BC)
	// 822A46B4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A46B8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822A46BC; continue 'dispatch;
            }
            0x822A46BC => {
    //   block [0x822A46BC..0x822A46C8)
	// 822A46BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A46C0: 4199FFB8  bgt cr6, 0x822a4678
	if ctx.cr[6].gt {
	pc = 0x822A4678; continue 'dispatch;
	}
	// 822A46C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822A46C8; continue 'dispatch;
            }
            0x822A46C8 => {
    //   block [0x822A46C8..0x822A46E4)
	// 822A46C8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A46CC: 419A003C  beq cr6, 0x822a4708
	if ctx.cr[6].eq {
	pc = 0x822A4708; continue 'dispatch;
	}
	// 822A46D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A46D4: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 822A46D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A46DC: 41990008  bgt cr6, 0x822a46e4
	if ctx.cr[6].gt {
	pc = 0x822A46E4; continue 'dispatch;
	}
	// 822A46E0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A46E4; continue 'dispatch;
            }
            0x822A46E4 => {
    //   block [0x822A46E4..0x822A4708)
	// 822A46E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A46E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A46EC: 409A001C  bne cr6, 0x822a4708
	if !ctx.cr[6].eq {
	pc = 0x822A4708; continue 'dispatch;
	}
	// 822A46F0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A46F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A46F8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822A46FC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822A4700: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4704: 48000018  b 0x822a471c
	pc = 0x822A471C; continue 'dispatch;
            }
            0x822A4708 => {
    //   block [0x822A4708..0x822A4718)
	// 822A4708: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A470C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A4710: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4714: 48000008  b 0x822a471c
	pc = 0x822A471C; continue 'dispatch;
            }
            0x822A4718 => {
    //   block [0x822A4718..0x822A471C)
	// 822A4718: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x822A471C; continue 'dispatch;
            }
            0x822A471C => {
    //   block [0x822A471C..0x822A473C)
	// 822A471C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822A4720: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A4724: 419A0150  beq cr6, 0x822a4874
	if ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A4728: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 822A472C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 822A4730: 419A000C  beq cr6, 0x822a473c
	if ctx.cr[6].eq {
	pc = 0x822A473C; continue 'dispatch;
	}
	// 822A4734: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 822A4738: 409A013C  bne cr6, 0x822a4874
	if !ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	pc = 0x822A473C; continue 'dispatch;
            }
            0x822A473C => {
    //   block [0x822A473C..0x822A4778)
	// 822A473C: 815A0034  lwz r10, 0x34(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(52 as u32) ) } as u64;
	// 822A4740: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822A4744: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822A4748: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A474C: 419A00E4  beq cr6, 0x822a4830
	if ctx.cr[6].eq {
	pc = 0x822A4830; continue 'dispatch;
	}
	// 822A4750: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A4754: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A4758: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A475C: 419A001C  beq cr6, 0x822a4778
	if ctx.cr[6].eq {
	pc = 0x822A4778; continue 'dispatch;
	}
	// 822A4760: 896B0085  lbz r11, 0x85(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(133 as u32) ) } as u64;
	// 822A4764: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 822A4768: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822A476C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4770: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A4774: 480000C0  b 0x822a4834
	pc = 0x822A4834; continue 'dispatch;
            }
            0x822A4778 => {
    //   block [0x822A4778..0x822A4790)
	// 822A4778: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A477C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 822A4780: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A4784: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822A4788: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A478C: 40810054  ble 0x822a47e0
	if !ctx.cr[0].gt {
	pc = 0x822A47E0; continue 'dispatch;
	}
	pc = 0x822A4790; continue 'dispatch;
            }
            0x822A4790 => {
    //   block [0x822A4790..0x822A47B0)
	// 822A4790: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A4794: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A4798: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822A479C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A47A0: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 822A47A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822A47A8: 41980008  blt cr6, 0x822a47b0
	if ctx.cr[6].lt {
	pc = 0x822A47B0; continue 'dispatch;
	}
	// 822A47AC: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x822A47B0; continue 'dispatch;
            }
            0x822A47B0 => {
    //   block [0x822A47B0..0x822A47CC)
	// 822A47B0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A47B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A47B8: 419A0014  beq cr6, 0x822a47cc
	if ctx.cr[6].eq {
	pc = 0x822A47CC; continue 'dispatch;
	}
	// 822A47BC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A47C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A47C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A47C8: 4800000C  b 0x822a47d4
	pc = 0x822A47D4; continue 'dispatch;
            }
            0x822A47CC => {
    //   block [0x822A47CC..0x822A47D4)
	// 822A47CC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A47D0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822A47D4; continue 'dispatch;
            }
            0x822A47D4 => {
    //   block [0x822A47D4..0x822A47E0)
	// 822A47D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A47D8: 4199FFB8  bgt cr6, 0x822a4790
	if ctx.cr[6].gt {
	pc = 0x822A4790; continue 'dispatch;
	}
	// 822A47DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822A47E0; continue 'dispatch;
            }
            0x822A47E0 => {
    //   block [0x822A47E0..0x822A47FC)
	// 822A47E0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A47E4: 419A003C  beq cr6, 0x822a4820
	if ctx.cr[6].eq {
	pc = 0x822A4820; continue 'dispatch;
	}
	// 822A47E8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A47EC: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 822A47F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A47F4: 41990008  bgt cr6, 0x822a47fc
	if ctx.cr[6].gt {
	pc = 0x822A47FC; continue 'dispatch;
	}
	// 822A47F8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A47FC; continue 'dispatch;
            }
            0x822A47FC => {
    //   block [0x822A47FC..0x822A4820)
	// 822A47FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A4800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A4804: 409A001C  bne cr6, 0x822a4820
	if !ctx.cr[6].eq {
	pc = 0x822A4820; continue 'dispatch;
	}
	// 822A4808: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A480C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A4810: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822A4814: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822A4818: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A481C: 48000018  b 0x822a4834
	pc = 0x822A4834; continue 'dispatch;
            }
            0x822A4820 => {
    //   block [0x822A4820..0x822A4830)
	// 822A4820: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A4824: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A4828: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A482C: 48000008  b 0x822a4834
	pc = 0x822A4834; continue 'dispatch;
            }
            0x822A4830 => {
    //   block [0x822A4830..0x822A4834)
	// 822A4830: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x822A4834; continue 'dispatch;
            }
            0x822A4834 => {
    //   block [0x822A4834..0x822A4860)
	// 822A4834: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822A4838: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A483C: 419A0038  beq cr6, 0x822a4874
	if ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A4840: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 822A4844: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822A4848: 4BF5F751  bl 0x82203f98
	ctx.lr = 0x822A484C;
	sub_82203F98(ctx, base);
	// 822A484C: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 822A4850: 419A0024  beq cr6, 0x822a4874
	if ctx.cr[6].eq {
	pc = 0x822A4874; continue 'dispatch;
	}
	// 822A4854: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A4858: 38800058  li r4, 0x58
	ctx.r[4].s64 = 88;
	// 822A485C: 9956002A  stb r10, 0x2a(r22)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[22].u32.wrapping_add(42 as u32), ctx.r[10].u8 ) };
	pc = 0x822A4860; continue 'dispatch;
            }
            0x822A4860 => {
    //   block [0x822A4860..0x822A4874)
	// 822A4860: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4864: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A4868: 810900A8  lwz r8, 0xa8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(168 as u32) ) } as u64;
	// 822A486C: 80680004  lwz r3, 4(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4870: 4BF109F1  bl 0x821b5260
	ctx.lr = 0x822A4874;
	sub_821B5260(ctx, base);
	pc = 0x822A4874; continue 'dispatch;
            }
            0x822A4874 => {
    //   block [0x822A4874..0x822A4884)
	// 822A4874: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 822A4878: CBC1FF98  lfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 822A487C: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 822A4880: 48A04BC0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A4888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A4888 size=360
    let mut pc: u32 = 0x822A4888;
    'dispatch: loop {
        match pc {
            0x822A4888 => {
    //   block [0x822A4888..0x822A48C0)
	// 822A4888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A488C: 48A04B6D  bl 0x82ca93f8
	ctx.lr = 0x822A4890;
	sub_82CA93D0(ctx, base);
	// 822A4890: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A4894: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822A4898: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822A489C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 822A48A0: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 822A48A4: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 822A48A8: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A48AC: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A48B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A48B4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822A48B8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822A48BC: 419A0020  beq cr6, 0x822a48dc
	if ctx.cr[6].eq {
	pc = 0x822A48DC; continue 'dispatch;
	}
	pc = 0x822A48C0; continue 'dispatch;
            }
            0x822A48C0 => {
    //   block [0x822A48C0..0x822A48DC)
	// 822A48C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822A48C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A48C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822A48CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822A48D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822A48D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A48D8: 4082FFE8  bne 0x822a48c0
	if !ctx.cr[0].eq {
	pc = 0x822A48C0; continue 'dispatch;
	}
	pc = 0x822A48DC; continue 'dispatch;
            }
            0x822A48DC => {
    //   block [0x822A48DC..0x822A4914)
	// 822A48DC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A48E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822A48E4: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822A48E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A48EC: 4E800421  bctrl
	ctx.lr = 0x822A48F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A48F0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822A48F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A48F8: 419A001C  beq cr6, 0x822a4914
	if ctx.cr[6].eq {
	pc = 0x822A4914; continue 'dispatch;
	}
	// 822A48FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4900: 484656D9  bl 0x82709fd8
	ctx.lr = 0x822A4904;
	sub_82709FD8(ctx, base);
	// 822A4904: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822A490C: 419A0008  beq cr6, 0x822a4914
	if ctx.cr[6].eq {
	pc = 0x822A4914; continue 'dispatch;
	}
	// 822A4910: 4BFE1899  bl 0x822861a8
	ctx.lr = 0x822A4914;
	sub_822861A8(ctx, base);
            }
            0x822A4914 => {
    //   block [0x822A4914..0x822A4950)
	// 822A4914: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4918: 3B9E0018  addi r28, r30, 0x18
	ctx.r[28].s64 = ctx.r[30].s64 + 24;
	// 822A491C: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A4920: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4924: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822A4928: 419A0028  beq cr6, 0x822a4950
	if ctx.cr[6].eq {
	pc = 0x822A4950; continue 'dispatch;
	}
	// 822A492C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822A4930: 4BF131E9  bl 0x821b7b18
	ctx.lr = 0x822A4934;
	sub_821B7B18(ctx, base);
	// 822A4934: 935C0000  stw r26, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 822A4938: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822A493C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822A4940: 419A0010  beq cr6, 0x822a4950
	if ctx.cr[6].eq {
	pc = 0x822A4950; continue 'dispatch;
	}
	// 822A4944: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4948: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822A494C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x822A4950; continue 'dispatch;
            }
            0x822A4950 => {
    //   block [0x822A4950..0x822A4988)
	// 822A4950: 83B90004  lwz r29, 4(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4954: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4958: 83990000  lwz r28, 0(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A495C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822A4960: 419A0028  beq cr6, 0x822a4988
	if ctx.cr[6].eq {
	pc = 0x822A4988; continue 'dispatch;
	}
	// 822A4964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A4968: 4BF131B1  bl 0x821b7b18
	ctx.lr = 0x822A496C;
	sub_821B7B18(ctx, base);
	// 822A496C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822A4970: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822A4974: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822A4978: 419A0010  beq cr6, 0x822a4988
	if ctx.cr[6].eq {
	pc = 0x822A4988; continue 'dispatch;
	}
	// 822A497C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4980: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822A4984: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x822A4988; continue 'dispatch;
            }
            0x822A4988 => {
    //   block [0x822A4988..0x822A49F0)
	// 822A4988: 9B1E0028  stb r24, 0x28(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[24].u8 ) };
	// 822A498C: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A4990: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4994: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4998: 4BF11AC1  bl 0x821b6458
	ctx.lr = 0x822A499C;
	sub_821B6458(ctx, base);
	// 822A499C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A49A0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822A49A4: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A49A8: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 822A49AC: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A49B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822A49B4: 38EA0B7C  addi r7, r10, 0xb7c
	ctx.r[7].s64 = ctx.r[10].s64 + 2940;
	// 822A49B8: 913E000C  stw r9, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 822A49BC: 911B0004  stw r8, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 822A49C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822A49C4: 90FB0000  stw r7, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 822A49C8: 83E6003C  lwz r31, 0x3c(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(60 as u32) ) } as u64;
	// 822A49CC: 4BF6FECD  bl 0x82214898
	ctx.lr = 0x822A49D0;
	sub_82214898(ctx, base);
	// 822A49D0: 93FB0008  stw r31, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 822A49D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A49D8: 4BF13141  bl 0x821b7b18
	ctx.lr = 0x822A49DC;
	sub_821B7B18(ctx, base);
	// 822A49DC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822A49E0: 4BF13139  bl 0x821b7b18
	ctx.lr = 0x822A49E4;
	sub_821B7B18(ctx, base);
	// 822A49E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822A49E8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822A49EC: 48A04A5C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A4A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A4A00 size=680
    let mut pc: u32 = 0x822A4A00;
    'dispatch: loop {
        match pc {
            0x822A4A00 => {
    //   block [0x822A4A00..0x822A4CA8)
	// 822A4A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A4A04: 48A04A05  bl 0x82ca9408
	ctx.lr = 0x822A4A08;
	sub_82CA93D0(ctx, base);
	// 822A4A08: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 822A4A0C: 48A092B5  bl 0x82cadcc0
	ctx.lr = 0x822A4A10;
	sub_82CADCA0(ctx, base);
	// 822A4A10: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A4A14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A4A18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822A4A1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822A4A20: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4A24: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 822A4A28: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A4A2C: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 822A4A30: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822A4A34: 4E800421  bctrl
	ctx.lr = 0x822A4A38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A4A38: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 822A4A3C: 38E00090  li r7, 0x90
	ctx.r[7].s64 = 144;
	// 822A4A40: 3BBF00E4  addi r29, r31, 0xe4
	ctx.r[29].s64 = ctx.r[31].s64 + 228;
	// 822A4A44: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822A4A48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A4CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A4CA8 size=400
    let mut pc: u32 = 0x822A4CA8;
    'dispatch: loop {
        match pc {
            0x822A4CA8 => {
    //   block [0x822A4CA8..0x822A4D0C)
	// 822A4CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A4CAC: 48A04761  bl 0x82ca940c
	ctx.lr = 0x822A4CB0;
	sub_82CA93D0(ctx, base);
	// 822A4CB0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822A4CB4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A4CB8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822A4CBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A4CC0: 3BAB9484  addi r29, r11, -0x6b7c
	ctx.r[29].s64 = ctx.r[11].s64 + -27516;
	// 822A4CC4: 3BDF00B0  addi r30, r31, 0xb0
	ctx.r[30].s64 = ctx.r[31].s64 + 176;
	// 822A4CC8: C03F00E4  lfs f1, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822A4CCC: C3FD000C  lfs f31, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822A4CD0: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 822A4CD4: 40980038  bge cr6, 0x822a4d0c
	if !ctx.cr[6].lt {
	pc = 0x822A4D0C; continue 'dispatch;
	}
	// 822A4CD8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822A4CDC: E8DF00A0  ld r6, 0xa0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	// 822A4CE0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822A4CE4: E8FF00A8  ld r7, 0xa8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	// 822A4CE8: E89F00B0  ld r4, 0xb0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	// 822A4CEC: E8BF00B8  ld r5, 0xb8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	// 822A4CF0: C04B9A80  lfs f2, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822A4CF4: 4BF6822D  bl 0x8220cf20
	ctx.lr = 0x822A4CF8;
	sub_8220CF20(ctx, base);
	// 822A4CF8: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 822A4CFC: F95F00B0  std r10, 0xb0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u64 ) };
	// 822A4D00: E9230008  ld r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 822A4D04: F93F00B8  std r9, 0xb8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[9].u64 ) };
	// 822A4D08: 48000018  b 0x822a4d20
	pc = 0x822A4D20; continue 'dispatch;
            }
            0x822A4D0C => {
    //   block [0x822A4D0C..0x822A4D20)
	// 822A4D0C: E97F00A0  ld r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	// 822A4D10: 393F00A0  addi r9, r31, 0xa0
	ctx.r[9].s64 = ctx.r[31].s64 + 160;
	// 822A4D14: E95F00A8  ld r10, 0xa8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	// 822A4D18: F97F00B0  std r11, 0xb0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u64 ) };
	// 822A4D1C: F95F00B8  std r10, 0xb8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[10].u64 ) };
	pc = 0x822A4D20; continue 'dispatch;
            }
            0x822A4D20 => {
    //   block [0x822A4D20..0x822A4E38)
	// 822A4D20: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822A4D24: E89E0000  ld r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 822A4D28: E8BE0008  ld r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 822A4D2C: 4800F595  bl 0x822b42c0
	ctx.lr = 0x822A4D30;
	sub_822B42C0(ctx, base);
	// 822A4D30: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 822A4D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A4D38: 4BED6731  bl 0x8217b468
	ctx.lr = 0x822A4D3C;
	sub_8217B468(ctx, base);
	// 822A4D3C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 822A4D40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822A4D44: 4BF0B325  bl 0x821b0068
	ctx.lr = 0x822A4D48;
	sub_821B0068(ctx, base);
	// 822A4D48: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 822A4D4C: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 822A4D50: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A4D54: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 822A4D58: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822A4D5C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822A4D60: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822A4D64: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822A4D68: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A4E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A4E38 size=116
    let mut pc: u32 = 0x822A4E38;
    'dispatch: loop {
        match pc {
            0x822A4E38 => {
    //   block [0x822A4E38..0x822A4E54)
	// 822A4E38: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822A4E3C: 814B6AB8  lwz r10, 0x6ab8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822A4E40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A4E44: 419A0010  beq cr6, 0x822a4e54
	if ctx.cr[6].eq {
	pc = 0x822A4E54; continue 'dispatch;
	}
	// 822A4E48: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822A4E4C: 896B6A5E  lbz r11, 0x6a5e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27230 as u32) ) } as u64;
	// 822A4E50: 48000008  b 0x822a4e58
	pc = 0x822A4E58; continue 'dispatch;
            }
            0x822A4E54 => {
    //   block [0x822A4E54..0x822A4E58)
	// 822A4E54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822A4E58; continue 'dispatch;
            }
            0x822A4E58 => {
    //   block [0x822A4E58..0x822A4E94)
	// 822A4E58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A4E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A4E60: 419A004C  beq cr6, 0x822a4eac
	if ctx.cr[6].eq {
		sub_822A4EAC(ctx, base);
		return;
	}
	// 822A4E64: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A4E68: 814B011C  lwz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 822A4E6C: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 822A4E70: 409A003C  bne cr6, 0x822a4eac
	if !ctx.cr[6].eq {
		sub_822A4EAC(ctx, base);
		return;
	}
	// 822A4E74: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A4E78: 894B0034  lbz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 822A4E7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A4E80: 419A0014  beq cr6, 0x822a4e94
	if ctx.cr[6].eq {
	pc = 0x822A4E94; continue 'dispatch;
	}
	// 822A4E84: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 822A4E88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A4E8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A4E90: 409A0008  bne cr6, 0x822a4e98
	if !ctx.cr[6].eq {
	pc = 0x822A4E98; continue 'dispatch;
	}
	pc = 0x822A4E94; continue 'dispatch;
            }
            0x822A4E94 => {
    //   block [0x822A4E94..0x822A4E98)
	// 822A4E94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822A4E98; continue 'dispatch;
            }
            0x822A4E98 => {
    //   block [0x822A4E98..0x822A4EAC)
	// 822A4E98: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A4E9C: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822A4EA0: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822A4EA4: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 822A4EA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A4EAC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A4EAC size=8
    let mut pc: u32 = 0x822A4EAC;
    'dispatch: loop {
        match pc {
            0x822A4EAC => {
    //   block [0x822A4EAC..0x822A4EB4)
	// 822A4EAC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822A4EB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A4EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A4EB8 size=84
    let mut pc: u32 = 0x822A4EB8;
    'dispatch: loop {
        match pc {
            0x822A4EB8 => {
    //   block [0x822A4EB8..0x822A4F0C)
	// 822A4EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A4EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A4EC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A4EC4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A4EC8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822A4ECC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822A4ED0: 394BA978  addi r10, r11, -0x5688
	ctx.r[10].s64 = ctx.r[11].s64 + -22152;
	// 822A4ED4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822A4ED8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A4EDC: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A4EE0: 4BF55CF1  bl 0x821fabd0
	ctx.lr = 0x822A4EE4;
	sub_821FABD0(ctx, base);
	// 822A4EE4: 81210068  lwz r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 822A4EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A4EEC: 8101006C  lwz r8, 0x6c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822A4EF0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822A4EF4: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 822A4EF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822A4EFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A4F00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A4F04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822A4F08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A4F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A4F10 size=2240
    let mut pc: u32 = 0x822A4F10;
    'dispatch: loop {
        match pc {
            0x822A4F10 => {
    //   block [0x822A4F10..0x822A57D0)
	// 822A4F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A4F14: 48A044ED  bl 0x82ca9400
	ctx.lr = 0x822A4F18;
	sub_82CA93D0(ctx, base);
	// 822A4F18: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A57D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822A57D0 size=444
    let mut pc: u32 = 0x822A57D0;
    'dispatch: loop {
        match pc {
            0x822A57D0 => {
    //   block [0x822A57D0..0x822A5924)
	// 822A57D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A57D4: 48A03C2D  bl 0x82ca9400
	ctx.lr = 0x822A57D8;
	sub_82CA93D0(ctx, base);
	// 822A57D8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A57DC: 81450014  lwz r10, 0x14(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A57E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822A57E4: 409A01A4  bne cr6, 0x822a5988
	if !ctx.cr[6].eq {
	pc = 0x822A5988; continue 'dispatch;
	}
	// 822A57E8: 81250030  lwz r9, 0x30(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(48 as u32) ) } as u64;
	// 822A57EC: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 822A57F0: 80E5002C  lwz r7, 0x2c(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 822A57F4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822A57F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822A57FC: 7CC74850  subf r6, r7, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 822A5800: 392A91A0  addi r9, r10, -0x6e60
	ctx.r[9].s64 = ctx.r[10].s64 + -28256;
	// 822A5804: 7CDF1E70  srawi r31, r6, 3
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[6].s32 >> 3) as i64;
	// 822A5808: C00816C8  lfs f0, 0x16c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(5832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A580C: 2F1F0004  cmpwi cr6, r31, 4
	ctx.cr[6].compare_i32(ctx.r[31].s32, 4, &mut ctx.xer);
	// 822A5810: 41980114  blt cr6, 0x822a5924
	if ctx.cr[6].lt {
	pc = 0x822A5924; continue 'dispatch;
	}
	// 822A5814: 38BFFFFD  addi r5, r31, -3
	ctx.r[5].s64 = ctx.r[31].s64 + -3;
	// 822A5818: 39430050  addi r10, r3, 0x50
	ctx.r[10].s64 = ctx.r[3].s64 + 80;
	// 822A581C: 80C40008  lwz r6, 8(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A5820: 390AFFD0  addi r8, r10, -0x30
	ctx.r[8].s64 = ctx.r[10].s64 + -48;
	// 822A5824: 3BC1FFA0  addi r30, r1, -0x60
	ctx.r[30].s64 = ctx.r[1].s64 + -96;
	pc = 0x822A5924; continue 'dispatch;
            }
            0x822A5924 => {
    //   block [0x822A5924..0x822A5988)
	// 822A5924: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 822A5928: 40980060  bge cr6, 0x822a5988
	if !ctx.cr[6].lt {
	pc = 0x822A5988; continue 'dispatch;
	}
	// 822A592C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822A5930: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822A5934: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822A5938: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 822A593C: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 822A5940: 81040008  lwz r8, 8(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A5944: 38E1FFA0  addi r7, r1, -0x60
	ctx.r[7].s64 = ctx.r[1].s64 + -96;
	pc = 0x822A5988; continue 'dispatch;
            }
            0x822A5988 => {
    //   block [0x822A5988..0x822A598C)
	// 822A5988: 48A03AC8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A5990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A5990 size=612
    let mut pc: u32 = 0x822A5990;
    'dispatch: loop {
        match pc {
            0x822A5990 => {
    //   block [0x822A5990..0x822A5BF4)
	// 822A5990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A5994: 48A03A71  bl 0x82ca9404
	ctx.lr = 0x822A5998;
	sub_82CA93D0(ctx, base);
	// 822A5998: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 822A599C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 822A59A0: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A5BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A5BF8 size=64
    let mut pc: u32 = 0x822A5BF8;
    'dispatch: loop {
        match pc {
            0x822A5BF8 => {
    //   block [0x822A5BF8..0x822A5C24)
	// 822A5BF8: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 822A5BFC: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 822A5C00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A5C04: 409A0034  bne cr6, 0x822a5c38
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x822A5C38);
		return;
	}
	// 822A5C08: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A5C0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A5C10: 419A0014  beq cr6, 0x822a5c24
	if ctx.cr[6].eq {
	pc = 0x822A5C24; continue 'dispatch;
	}
	// 822A5C14: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A5C18: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822A5C1C: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A5C20: 40820018  bne 0x822a5c38
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x822A5C38);
		return;
	}
	pc = 0x822A5C24; continue 'dispatch;
            }
            0x822A5C24 => {
    //   block [0x822A5C24..0x822A5C38)
	// 822A5C24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A5C28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A5C2C: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822A5C30: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822A5C34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A5C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A5C50 size=136
    let mut pc: u32 = 0x822A5C50;
    'dispatch: loop {
        match pc {
            0x822A5C50 => {
    //   block [0x822A5C50..0x822A5CA4)
	// 822A5C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A5C54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A5C58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A5C5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A5C60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A5C64: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A5C68: 4BF46DC9  bl 0x821eca30
	ctx.lr = 0x822A5C6C;
	sub_821ECA30(ctx, base);
	// 822A5C6C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822A5C70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A5C74: 409A004C  bne cr6, 0x822a5cc0
	if !ctx.cr[6].eq {
	pc = 0x822A5CC0; continue 'dispatch;
	}
	// 822A5C78: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 822A5C7C: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 822A5C80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A5C84: 409A0028  bne cr6, 0x822a5cac
	if !ctx.cr[6].eq {
	pc = 0x822A5CAC; continue 'dispatch;
	}
	// 822A5C88: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A5C8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A5C90: 419A0014  beq cr6, 0x822a5ca4
	if ctx.cr[6].eq {
	pc = 0x822A5CA4; continue 'dispatch;
	}
	// 822A5C94: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A5C98: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822A5C9C: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A5CA0: 4082000C  bne 0x822a5cac
	if !ctx.cr[0].eq {
	pc = 0x822A5CAC; continue 'dispatch;
	}
	pc = 0x822A5CA4; continue 'dispatch;
            }
            0x822A5CA4 => {
    //   block [0x822A5CA4..0x822A5CAC)
	// 822A5CA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A5CA8: 48000008  b 0x822a5cb0
	pc = 0x822A5CB0; continue 'dispatch;
            }
            0x822A5CAC => {
    //   block [0x822A5CAC..0x822A5CB0)
	// 822A5CAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822A5CB0; continue 'dispatch;
            }
            0x822A5CB0 => {
    //   block [0x822A5CB0..0x822A5CC0)
	// 822A5CB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A5CB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822A5CB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A5CBC: 419A0008  beq cr6, 0x822a5cc4
	if ctx.cr[6].eq {
	pc = 0x822A5CC4; continue 'dispatch;
	}
	pc = 0x822A5CC0; continue 'dispatch;
            }
            0x822A5CC0 => {
    //   block [0x822A5CC0..0x822A5CC4)
	// 822A5CC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822A5CC4; continue 'dispatch;
            }
            0x822A5CC4 => {
    //   block [0x822A5CC4..0x822A5CD8)
	// 822A5CC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822A5CC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A5CCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A5CD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822A5CD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A5CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A5CD8 size=148
    let mut pc: u32 = 0x822A5CD8;
    'dispatch: loop {
        match pc {
            0x822A5CD8 => {
    //   block [0x822A5CD8..0x822A5D3C)
	// 822A5CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A5CDC: 48A03731  bl 0x82ca940c
	ctx.lr = 0x822A5CE0;
	sub_82CA93D0(ctx, base);
	// 822A5CE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A5CE4: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 822A5CE8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822A5CEC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 822A5CF0: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822A5CF4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A5CF8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 822A5CFC: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 822A5D00: 48021FD9  bl 0x822c7cd8
	ctx.lr = 0x822A5D04;
	sub_822C7CD8(ctx, base);
	// 822A5D04: 2F030005  cmpwi cr6, r3, 5
	ctx.cr[6].compare_i32(ctx.r[3].s32, 5, &mut ctx.xer);
	// 822A5D08: 419A0044  beq cr6, 0x822a5d4c
	if ctx.cr[6].eq {
	pc = 0x822A5D4C; continue 'dispatch;
	}
	// 822A5D0C: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822A5D10: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A5D14: 83EB0034  lwz r31, 0x34(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 822A5D18: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A5D1C: 4BF46D15  bl 0x821eca30
	ctx.lr = 0x822A5D20;
	sub_821ECA30(ctx, base);
	// 822A5D20: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822A5D24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A5D28: 409A0014  bne cr6, 0x822a5d3c
	if !ctx.cr[6].eq {
	pc = 0x822A5D3C; continue 'dispatch;
	}
	// 822A5D2C: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 822A5D30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A5D34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A5D38: 409A0008  bne cr6, 0x822a5d40
	if !ctx.cr[6].eq {
	pc = 0x822A5D40; continue 'dispatch;
	}
	pc = 0x822A5D3C; continue 'dispatch;
            }
            0x822A5D3C => {
    //   block [0x822A5D3C..0x822A5D40)
	// 822A5D3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822A5D40; continue 'dispatch;
            }
            0x822A5D40 => {
    //   block [0x822A5D40..0x822A5D4C)
	// 822A5D40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A5D44: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822A5D48: 555EE7BC  rlwinm r30, r10, 0x1c, 0x1e, 0x1e
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	pc = 0x822A5D4C; continue 'dispatch;
            }
            0x822A5D4C => {
    //   block [0x822A5D4C..0x822A5D6C)
	// 822A5D4C: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 822A5D50: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 822A5D54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822A5D58: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822A5D5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822A5D60: 4BFF1429  bl 0x82297188
	ctx.lr = 0x822A5D64;
	sub_82297188(ctx, base);
	// 822A5D64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822A5D68: 48A036F4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A5D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A5D70 size=120
    let mut pc: u32 = 0x822A5D70;
    'dispatch: loop {
        match pc {
            0x822A5D70 => {
    //   block [0x822A5D70..0x822A5DBC)
	// 822A5D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A5D74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A5D78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A5D7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A5D80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A5D84: 4BF46CAD  bl 0x821eca30
	ctx.lr = 0x822A5D88;
	sub_821ECA30(ctx, base);
	// 822A5D88: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822A5D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A5D90: 419A002C  beq cr6, 0x822a5dbc
	if ctx.cr[6].eq {
	pc = 0x822A5DBC; continue 'dispatch;
	}
	// 822A5D94: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 822A5D98: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 822A5D9C: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 822A5DA0: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 822A5DA4: 69030001  xori r3, r8, 1
	ctx.r[3].u64 = ctx.r[8].u64 ^ 1;
	// 822A5DA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822A5DAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A5DB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A5DB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822A5DB8: 4E800020  blr
	return;
            }
            0x822A5DBC => {
    //   block [0x822A5DBC..0x822A5DE8)
	// 822A5DBC: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 822A5DC0: 4BFFFE39  bl 0x822a5bf8
	ctx.lr = 0x822A5DC4;
	sub_822A5BF8(ctx, base);
	// 822A5DC4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822A5DC8: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822A5DCC: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822A5DD0: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 822A5DD4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822A5DD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A5DDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A5DE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822A5DE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A5DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A5DE8 size=252
    let mut pc: u32 = 0x822A5DE8;
    'dispatch: loop {
        match pc {
            0x822A5DE8 => {
    //   block [0x822A5DE8..0x822A5E6C)
	// 822A5DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A5DEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A5DF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A5DF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A5DF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A5DFC: 48032925  bl 0x822d8720
	ctx.lr = 0x822A5E00;
	sub_822D8720(ctx, base);
	// 822A5E00: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822A5E04: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 822A5E08: 390001C0  li r8, 0x1c0
	ctx.r[8].s64 = 448;
	// 822A5E0C: 392000D0  li r9, 0xd0
	ctx.r[9].s64 = 208;
	// 822A5E10: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822A5E14: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822A5E18: C00A9A80  lfs f0, -0x6580(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A5E1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A5E20: 419A004C  beq cr6, 0x822a5e6c
	if ctx.cr[6].eq {
	pc = 0x822A5E6C; continue 'dispatch;
	}
	pc = 0x822A5E6C; continue 'dispatch;
            }
            0x822A5E6C => {
    //   block [0x822A5E6C..0x822A5EE4)
	// 822A5E6C: 815F00B4  lwz r10, 0xb4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 822A5E70: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822A5E74: 419A005C  beq cr6, 0x822a5ed0
	if ctx.cr[6].eq {
	pc = 0x822A5ED0; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A5EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A5EE8 size=496
    let mut pc: u32 = 0x822A5EE8;
    'dispatch: loop {
        match pc {
            0x822A5EE8 => {
    //   block [0x822A5EE8..0x822A5F54)
	// 822A5EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A5EEC: 48A03521  bl 0x82ca940c
	ctx.lr = 0x822A5EF0;
	sub_82CA93D0(ctx, base);
	// 822A5EF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A5EF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A5EF8: 4BF42FC9  bl 0x821e8ec0
	ctx.lr = 0x822A5EFC;
	sub_821E8EC0(ctx, base);
	// 822A5EFC: 811F0030  lwz r8, 0x30(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822A5F00: 3BBF3438  addi r29, r31, 0x3438
	ctx.r[29].s64 = ctx.r[31].s64 + 13368;
	// 822A5F04: 395F344C  addi r10, r31, 0x344c
	ctx.r[10].s64 = ctx.r[31].s64 + 13388;
	// 822A5F08: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822A5F0C: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 822A5F10: 911F3460  stw r8, 0x3460(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13408 as u32), ctx.r[8].u32 ) };
	// 822A5F14: 811F0034  lwz r8, 0x34(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 822A5F18: 911F3464  stw r8, 0x3464(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13412 as u32), ctx.r[8].u32 ) };
	// 822A5F1C: 811F3A50  lwz r8, 0x3a50(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14928 as u32) ) } as u64;
	// 822A5F20: 911F3468  stw r8, 0x3468(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13416 as u32), ctx.r[8].u32 ) };
	// 822A5F24: 811F3A4C  lwz r8, 0x3a4c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14924 as u32) ) } as u64;
	// 822A5F28: 911F346C  stw r8, 0x346c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13420 as u32), ctx.r[8].u32 ) };
	// 822A5F2C: 811F3A44  lwz r8, 0x3a44(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14916 as u32) ) } as u64;
	// 822A5F30: 911F3470  stw r8, 0x3470(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13424 as u32), ctx.r[8].u32 ) };
	// 822A5F34: 811F3A48  lwz r8, 0x3a48(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14920 as u32) ) } as u64;
	// 822A5F38: 911F3474  stw r8, 0x3474(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13428 as u32), ctx.r[8].u32 ) };
	// 822A5F3C: 80FF33B8  lwz r7, 0x33b8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13240 as u32) ) } as u64;
	// 822A5F40: 811F33BC  lwz r8, 0x33bc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13244 as u32) ) } as u64;
	// 822A5F44: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 822A5F48: 90FF33B0  stw r7, 0x33b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13232 as u32), ctx.r[7].u32 ) };
	// 822A5F4C: 911F33B4  stw r8, 0x33b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13236 as u32), ctx.r[8].u32 ) };
	// 822A5F50: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x822A5F54; continue 'dispatch;
            }
            0x822A5F54 => {
    //   block [0x822A5F54..0x822A604C)
	// 822A5F54: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A5F58: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822A5F5C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822A5F60: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822A5F64: 4200FFF0  bdnz 0x822a5f54
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822A5F54; continue 'dispatch;
	}
	// 822A5F68: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822A5F6C: 93FD0010  stw r31, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 822A5F70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822A5F74: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822A5F78: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 822A5F7C: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 822A5F80: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822A5F84: 4BF2B62D  bl 0x821d15b0
	ctx.lr = 0x822A5F88;
	sub_821D15B0(ctx, base);
	// 822A5F88: 93FF33D0  stw r31, 0x33d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13264 as u32), ctx.r[31].u32 ) };
	// 822A5F8C: 93DF33C4  stw r30, 0x33c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13252 as u32), ctx.r[30].u32 ) };
	// 822A5F90: 387F33C0  addi r3, r31, 0x33c0
	ctx.r[3].s64 = ctx.r[31].s64 + 13248;
	// 822A5F94: 93DF33C8  stw r30, 0x33c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13256 as u32), ctx.r[30].u32 ) };
	// 822A5F98: 93DF33CC  stw r30, 0x33cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13260 as u32), ctx.r[30].u32 ) };
	// 822A5F9C: 93DF33C0  stw r30, 0x33c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13248 as u32), ctx.r[30].u32 ) };
	// 822A5FA0: 4BF2B611  bl 0x821d15b0
	ctx.lr = 0x822A5FA4;
	sub_821D15B0(ctx, base);
	// 822A5FA4: 93FF3434  stw r31, 0x3434(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13364 as u32), ctx.r[31].u32 ) };
	// 822A5FA8: 93DF3428  stw r30, 0x3428(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13352 as u32), ctx.r[30].u32 ) };
	// 822A5FAC: 387F3424  addi r3, r31, 0x3424
	ctx.r[3].s64 = ctx.r[31].s64 + 13348;
	// 822A5FB0: 93DF342C  stw r30, 0x342c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13356 as u32), ctx.r[30].u32 ) };
	// 822A5FB4: 93DF3430  stw r30, 0x3430(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13360 as u32), ctx.r[30].u32 ) };
	// 822A5FB8: 93DF3424  stw r30, 0x3424(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13348 as u32), ctx.r[30].u32 ) };
	// 822A5FBC: 4BF2B5F5  bl 0x821d15b0
	ctx.lr = 0x822A5FC0;
	sub_821D15B0(ctx, base);
	// 822A5FC0: 93FF33E4  stw r31, 0x33e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13284 as u32), ctx.r[31].u32 ) };
	// 822A5FC4: 93DF33D8  stw r30, 0x33d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13272 as u32), ctx.r[30].u32 ) };
	// 822A5FC8: 387F33D4  addi r3, r31, 0x33d4
	ctx.r[3].s64 = ctx.r[31].s64 + 13268;
	// 822A5FCC: 93DF33DC  stw r30, 0x33dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13276 as u32), ctx.r[30].u32 ) };
	// 822A5FD0: 93DF33E0  stw r30, 0x33e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13280 as u32), ctx.r[30].u32 ) };
	// 822A5FD4: 93DF33D4  stw r30, 0x33d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13268 as u32), ctx.r[30].u32 ) };
	// 822A5FD8: 4BF2B5D9  bl 0x821d15b0
	ctx.lr = 0x822A5FDC;
	sub_821D15B0(ctx, base);
	// 822A5FDC: 93FF33F8  stw r31, 0x33f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13304 as u32), ctx.r[31].u32 ) };
	// 822A5FE0: 93DF33EC  stw r30, 0x33ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13292 as u32), ctx.r[30].u32 ) };
	// 822A5FE4: 387F33E8  addi r3, r31, 0x33e8
	ctx.r[3].s64 = ctx.r[31].s64 + 13288;
	// 822A5FE8: 93DF33F0  stw r30, 0x33f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13296 as u32), ctx.r[30].u32 ) };
	// 822A5FEC: 93DF33F4  stw r30, 0x33f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13300 as u32), ctx.r[30].u32 ) };
	// 822A5FF0: 93DF33E8  stw r30, 0x33e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13288 as u32), ctx.r[30].u32 ) };
	// 822A5FF4: 4BF2B5BD  bl 0x821d15b0
	ctx.lr = 0x822A5FF8;
	sub_821D15B0(ctx, base);
	// 822A5FF8: 93FF340C  stw r31, 0x340c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13324 as u32), ctx.r[31].u32 ) };
	// 822A5FFC: 93DF3400  stw r30, 0x3400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13312 as u32), ctx.r[30].u32 ) };
	// 822A6000: 387F33FC  addi r3, r31, 0x33fc
	ctx.r[3].s64 = ctx.r[31].s64 + 13308;
	// 822A6004: 93DF3404  stw r30, 0x3404(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13316 as u32), ctx.r[30].u32 ) };
	// 822A6008: 93DF3408  stw r30, 0x3408(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13320 as u32), ctx.r[30].u32 ) };
	// 822A600C: 93DF33FC  stw r30, 0x33fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13308 as u32), ctx.r[30].u32 ) };
	// 822A6010: 4BF2B5A1  bl 0x821d15b0
	ctx.lr = 0x822A6014;
	sub_821D15B0(ctx, base);
	// 822A6014: 93FF3420  stw r31, 0x3420(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13344 as u32), ctx.r[31].u32 ) };
	// 822A6018: 93DF3414  stw r30, 0x3414(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13332 as u32), ctx.r[30].u32 ) };
	// 822A601C: 387F3410  addi r3, r31, 0x3410
	ctx.r[3].s64 = ctx.r[31].s64 + 13328;
	// 822A6020: 93DF3418  stw r30, 0x3418(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13336 as u32), ctx.r[30].u32 ) };
	// 822A6024: 93DF341C  stw r30, 0x341c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13340 as u32), ctx.r[30].u32 ) };
	// 822A6028: 93DF3410  stw r30, 0x3410(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13328 as u32), ctx.r[30].u32 ) };
	// 822A602C: 4BF2B585  bl 0x821d15b0
	ctx.lr = 0x822A6030;
	sub_821D15B0(ctx, base);
	// 822A6030: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A6034: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A6038: 396300FC  addi r11, r3, 0xfc
	ctx.r[11].s64 = ctx.r[3].s64 + 252;
	// 822A603C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822A6040: 4099000C  ble cr6, 0x822a604c
	if !ctx.cr[6].gt {
	pc = 0x822A604C; continue 'dispatch;
	}
	// 822A6044: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822A6048: 4BF2B569  bl 0x821d15b0
	ctx.lr = 0x822A604C;
	sub_821D15B0(ctx, base);
	pc = 0x822A604C; continue 'dispatch;
            }
            0x822A604C => {
    //   block [0x822A604C..0x822A6080)
	// 822A604C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 822A6050: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822A6054: 817F3384  lwz r11, 0x3384(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13188 as u32) ) } as u64;
	// 822A6058: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822A605C: 817F31CC  lwz r11, 0x31cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12748 as u32) ) } as u64;
	// 822A6060: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822A6064: 817F31CC  lwz r11, 0x31cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12748 as u32) ) } as u64;
	// 822A6068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A606C: 813F32C0  lwz r9, 0x32c0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12992 as u32) ) } as u64;
	// 822A6070: 811F32C4  lwz r8, 0x32c4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12996 as u32) ) } as u64;
	// 822A6074: 40990054  ble cr6, 0x822a60c8
	if !ctx.cr[6].gt {
	pc = 0x822A60C8; continue 'dispatch;
	}
	// 822A6078: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 822A607C: 397F31D4  addi r11, r31, 0x31d4
	ctx.r[11].s64 = ctx.r[31].s64 + 12756;
	pc = 0x822A6080; continue 'dispatch;
            }
            0x822A6080 => {
    //   block [0x822A6080..0x822A60C8)
	// 822A6080: 80EBFFFC  lwz r7, -4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822A6084: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822A6088: 7CE93850  subf r7, r9, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 822A608C: 90EAFFFC  stw r7, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[7].u32 ) };
	// 822A6090: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6094: 7CE83850  subf r7, r8, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 822A6098: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 822A609C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A60A0: 7CE93850  subf r7, r9, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 822A60A4: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 822A60A8: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A60AC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 822A60B0: 7CE83850  subf r7, r8, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 822A60B4: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 822A60B8: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 822A60BC: 80FF31CC  lwz r7, 0x31cc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12748 as u32) ) } as u64;
	// 822A60C0: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 822A60C4: 4198FFBC  blt cr6, 0x822a6080
	if ctx.cr[6].lt {
	pc = 0x822A6080; continue 'dispatch;
	}
	pc = 0x822A60C8; continue 'dispatch;
            }
            0x822A60C8 => {
    //   block [0x822A60C8..0x822A60D8)
	// 822A60C8: 396300FC  addi r11, r3, 0xfc
	ctx.r[11].s64 = ctx.r[3].s64 + 252;
	// 822A60CC: 917F3440  stw r11, 0x3440(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13376 as u32), ctx.r[11].u32 ) };
	// 822A60D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822A60D4: 48A03388  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A60D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A60D8 size=168
    let mut pc: u32 = 0x822A60D8;
    'dispatch: loop {
        match pc {
            0x822A60D8 => {
    //   block [0x822A60D8..0x822A616C)
	// 822A60D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A60DC: 48A03331  bl 0x82ca940c
	ctx.lr = 0x822A60E0;
	sub_82CA93D0(ctx, base);
	// 822A60E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A60E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A60E8: 48925AB1  bl 0x82bcbb98
	ctx.lr = 0x822A60EC;
	sub_82BCBB98(ctx, base);
	// 822A60EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822A60F0: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A60F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A60F8: 38BEFFF0  addi r5, r30, -0x10
	ctx.r[5].s64 = ctx.r[30].s64 + -16;
	// 822A60FC: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6100: 4BFF47C9  bl 0x8229a8c8
	ctx.lr = 0x822A6104;
	sub_8229A8C8(ctx, base);
	// 822A6104: 817EFFF8  lwz r11, -8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A6108: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822A610C: 815EFFFC  lwz r10, -4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822A6110: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822A6114: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A6118: 812BFFFC  lwz r9, -4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822A611C: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 822A6120: 4198004C  blt cr6, 0x822a616c
	if ctx.cr[6].lt {
	pc = 0x822A616C; continue 'dispatch;
	}
	// 822A6124: 816BFFF8  lwz r11, -8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A6128: 894B0005  lbz r10, 5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 822A612C: 554907BE  clrlwi r9, r10, 0x1e
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 822A6130: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A6134: 419A0038  beq cr6, 0x822a616c
	if ctx.cr[6].eq {
	pc = 0x822A616C; continue 'dispatch;
	}
	// 822A6138: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A613C: 894B0005  lbz r10, 5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 822A6140: 5549077A  rlwinm r9, r10, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822A6144: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A6148: 419A0024  beq cr6, 0x822a616c
	if ctx.cr[6].eq {
	pc = 0x822A616C; continue 'dispatch;
	}
	// 822A614C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822A6150: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A6154: 5548063E  clrlwi r8, r10, 0x18
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822A6158: 550807B8  rlwinm r8, r8, 0, 0x1e, 0x1c
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 822A615C: 990B0005  stb r8, 5(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(5 as u32), ctx.r[8].u8 ) };
	// 822A6160: 80E90028  lwz r7, 0x28(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 822A6164: 90EB0018  stw r7, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 822A6168: 91690028  stw r11, 0x28(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	pc = 0x822A616C; continue 'dispatch;
            }
            0x822A616C => {
    //   block [0x822A616C..0x822A6180)
	// 822A616C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A6170: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 822A6174: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822A6178: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822A617C: 48A032E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A6180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A6180 size=28
    let mut pc: u32 = 0x822A6180;
    'dispatch: loop {
        match pc {
            0x822A6180 => {
    //   block [0x822A6180..0x822A619C)
	// 822A6180: 81632934  lwz r11, 0x2934(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10548 as u32) ) } as u64;
	// 822A6184: 508B456E  rlwimi r11, r4, 8, 0x15, 0x17
	ctx.r[11].u64 = (((ctx.r[4].u32).rotate_left(8) as u64) & 0x0000000000000700) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFF8FF);
	// 822A6188: 91632934  stw r11, 0x2934(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10548 as u32), ctx.r[11].u32 ) };
	// 822A618C: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 822A6190: 616B0800  ori r11, r11, 0x800
	ctx.r[11].u64 = ctx.r[11].u64 | 2048;
	// 822A6194: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 822A6198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A61A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A61A0 size=28
    let mut pc: u32 = 0x822A61A0;
    'dispatch: loop {
        match pc {
            0x822A61A0 => {
    //   block [0x822A61A0..0x822A61BC)
	// 822A61A0: 81632940  lwz r11, 0x2940(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10560 as u32) ) } as u64;
	// 822A61A4: 508B1F38  rlwimi r11, r4, 3, 0x1c, 0x1c
	ctx.r[11].u64 = (((ctx.r[4].u32).rotate_left(3) as u64) & 0x0000000000000008) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFFF7);
	// 822A61A8: 91632940  stw r11, 0x2940(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10560 as u32), ctx.r[11].u32 ) };
	// 822A61AC: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 822A61B0: 616B0100  ori r11, r11, 0x100
	ctx.r[11].u64 = ctx.r[11].u64 | 256;
	// 822A61B4: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 822A61B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A61C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A61C0 size=916
    let mut pc: u32 = 0x822A61C0;
    'dispatch: loop {
        match pc {
            0x822A61C0 => {
    //   block [0x822A61C0..0x822A6210)
	// 822A61C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A61C4: 48A0323D  bl 0x82ca9400
	ctx.lr = 0x822A61C8;
	sub_82CA93D0(ctx, base);
	// 822A61C8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 822A61CC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A61D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A61D4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822A61D8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822A61DC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822A61E0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A61E4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822A61E8: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 822A61EC: 93DF31CC  stw r30, 0x31cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12748 as u32), ctx.r[30].u32 ) };
	// 822A61F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822A61F4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822A61F8: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 822A61FC: 419A0080  beq cr6, 0x822a627c
	if ctx.cr[6].eq {
	pc = 0x822A627C; continue 'dispatch;
	}
	// 822A6200: 393F32C4  addi r9, r31, 0x32c4
	ctx.r[9].s64 = ctx.r[31].s64 + 12996;
	// 822A6204: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 822A6208: 395F31D4  addi r10, r31, 0x31d4
	ctx.r[10].s64 = ctx.r[31].s64 + 12756;
	// 822A620C: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	pc = 0x822A6210; continue 'dispatch;
            }
            0x822A6210 => {
    //   block [0x822A6210..0x822A6220)
	// 822A6210: 80EBFFFC  lwz r7, -4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822A6214: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 822A6218: 41990008  bgt cr6, 0x822a6220
	if ctx.cr[6].gt {
	pc = 0x822A6220; continue 'dispatch;
	}
	// 822A621C: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	pc = 0x822A6220; continue 'dispatch;
            }
            0x822A6220 => {
    //   block [0x822A6220..0x822A6230)
	// 822A6220: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6224: 7F1D3840  cmplw cr6, r29, r7
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[7].u32, &mut ctx.xer);
	// 822A6228: 41990008  bgt cr6, 0x822a6230
	if ctx.cr[6].gt {
	pc = 0x822A6230; continue 'dispatch;
	}
	// 822A622C: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	pc = 0x822A6230; continue 'dispatch;
            }
            0x822A6230 => {
    //   block [0x822A6230..0x822A627C)
	// 822A6230: 80EBFFF4  lwz r7, -0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 822A6234: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822A6238: 90EAFFFC  stw r7, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[7].u32 ) };
	// 822A623C: 80EBFFF8  lwz r7, -8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A6240: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 822A6244: 80EBFFFC  lwz r7, -4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822A6248: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 822A624C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6250: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 822A6254: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 822A6258: 80EBFFF4  lwz r7, -0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 822A625C: 54E70034  rlwinm r7, r7, 0, 0, 0x1a
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 822A6260: 90E9FFFC  stw r7, -4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-4 as u32), ctx.r[7].u32 ) };
	// 822A6264: 80EBFFF8  lwz r7, -8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A6268: 54E70034  rlwinm r7, r7, 0, 0, 0x1a
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 822A626C: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 822A6270: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 822A6274: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 822A6278: 4082FF98  bne 0x822a6210
	if !ctx.cr[0].eq {
	pc = 0x822A6210; continue 'dispatch;
	}
	pc = 0x822A627C; continue 'dispatch;
            }
            0x822A627C => {
    //   block [0x822A627C..0x822A6298)
	// 822A627C: 578B07BD  rlwinm. r11, r28, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A6280: 41820018  beq 0x822a6298
	if ctx.cr[0].eq {
	pc = 0x822A6298; continue 'dispatch;
	}
	// 822A6284: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 822A6288: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822A628C: 5784F7FE  rlwinm r4, r28, 0x1e, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[28].u32 as u64 & 0x00000003u64;
	// 822A6290: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A6294: 48024725  bl 0x822ca9b8
	ctx.lr = 0x822A6298;
	sub_822CA9B8(ctx, base);
	pc = 0x822A6298; continue 'dispatch;
            }
            0x822A6298 => {
    //   block [0x822A6298..0x822A62D8)
	// 822A6298: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822A629C: 93BF3380  stw r29, 0x3380(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13184 as u32), ctx.r[29].u32 ) };
	// 822A62A0: 578A07FF  clrlwi. r10, r28, 0x1f
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822A62A4: 90DF337C  stw r6, 0x337c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13180 as u32), ctx.r[6].u32 ) };
	// 822A62A8: 939F3384  stw r28, 0x3384(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13188 as u32), ctx.r[28].u32 ) };
	// 822A62AC: 3BAB1AA8  addi r29, r11, 0x1aa8
	ctx.r[29].s64 = ctx.r[11].s64 + 6824;
	// 822A62B0: 40820114  bne 0x822a63c4
	if !ctx.cr[0].eq {
	pc = 0x822A63C4; continue 'dispatch;
	}
	// 822A62B4: 897F2ABF  lbz r11, 0x2abf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10943 as u32) ) } as u64;
	// 822A62B8: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A62BC: 40820108  bne 0x822a63c4
	if !ctx.cr[0].eq {
	pc = 0x822A63C4; continue 'dispatch;
	}
	// 822A62C0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 822A62C4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822A62C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822A62CC: 419A004C  beq cr6, 0x822a6318
	if ctx.cr[6].eq {
	pc = 0x822A6318; continue 'dispatch;
	}
	// 822A62D0: 395F31DC  addi r10, r31, 0x31dc
	ctx.r[10].s64 = ctx.r[31].s64 + 12764;
	// 822A62D4: 397F32C4  addi r11, r31, 0x32c4
	ctx.r[11].s64 = ctx.r[31].s64 + 12996;
	pc = 0x822A62D8; continue 'dispatch;
            }
            0x822A62D8 => {
    //   block [0x822A62D8..0x822A62FC)
	// 822A62D8: 810BFFFC  lwz r8, -4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822A62DC: 812AFFFC  lwz r9, -4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822A62E0: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A62E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A62E8: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822A62EC: 7D042850  subf r8, r4, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 822A62F0: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822A62F4: 41990008  bgt cr6, 0x822a62fc
	if ctx.cr[6].gt {
	pc = 0x822A62FC; continue 'dispatch;
	}
	// 822A62F8: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	pc = 0x822A62FC; continue 'dispatch;
            }
            0x822A62FC => {
    //   block [0x822A62FC..0x822A6308)
	// 822A62FC: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822A6300: 41990008  bgt cr6, 0x822a6308
	if ctx.cr[6].gt {
	pc = 0x822A6308; continue 'dispatch;
	}
	// 822A6304: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	pc = 0x822A6308; continue 'dispatch;
            }
            0x822A6308 => {
    //   block [0x822A6308..0x822A6318)
	// 822A6308: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822A630C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 822A6310: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 822A6314: 4082FFC4  bne 0x822a62d8
	if !ctx.cr[0].eq {
	pc = 0x822A62D8; continue 'dispatch;
	}
	pc = 0x822A6318; continue 'dispatch;
            }
            0x822A6318 => {
    //   block [0x822A6318..0x822A63C4)
	// 822A6318: 389F3168  addi r4, r31, 0x3168
	ctx.r[4].s64 = ctx.r[31].s64 + 12648;
	// 822A631C: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 822A6320: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822A6324: 90C1005C  stw r6, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
	// 822A6328: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 822A632C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 822A6330: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 822A6334: 48A0314D  bl 0x82ca9480
	ctx.lr = 0x822A6338;
	sub_82CA9480(ctx, base);
	// 822A6338: 817F3184  lwz r11, 0x3184(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12676 as u32) ) } as u64;
	// 822A633C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 822A6340: 813F3188  lwz r9, 0x3188(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12680 as u32) ) } as u64;
	// 822A6344: 811F318C  lwz r8, 0x318c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12684 as u32) ) } as u64;
	// 822A6348: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822A634C: 80FF3190  lwz r7, 0x3190(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12688 as u32) ) } as u64;
	// 822A6350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A6354: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822A6358: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 822A635C: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 822A6360: 90EA000C  stw r7, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 822A6364: 4BF53BF5  bl 0x821f9f58
	ctx.lr = 0x822A6368;
	sub_821F9F58(ctx, base);
	// 822A6368: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822A636C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A6370: 388B1590  addi r4, r11, 0x1590
	ctx.r[4].s64 = ctx.r[11].s64 + 5520;
	// 822A6374: 4BF53895  bl 0x821f9c08
	ctx.lr = 0x822A6378;
	sub_821F9C08(ctx, base);
	// 822A6378: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822A637C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 822A6380: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822A6384: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822A6388: 3880003F  li r4, 0x3f
	ctx.r[4].s64 = 63;
	// 822A638C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A6390: 4BF3CC51  bl 0x821e2fe0
	ctx.lr = 0x822A6394;
	sub_821E2FE0(ctx, base);
	// 822A6394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A6398: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 822A639C: C0C10084  lfs f6, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 822A63A0: C0A10080  lfs f5, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 822A63A4: C081007C  lfs f4, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 822A63A8: C0610078  lfs f3, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 822A63AC: C0410074  lfs f2, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822A63B0: C0210070  lfs f1, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822A63B4: 4BF5394D  bl 0x821f9d00
	ctx.lr = 0x822A63B8;
	sub_821F9D00(ctx, base);
	// 822A63B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822A63BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A63C0: 4BF53849  bl 0x821f9c08
	ctx.lr = 0x822A63C4;
	sub_821F9C08(ctx, base);
	pc = 0x822A63C4; continue 'dispatch;
            }
            0x822A63C4 => {
    //   block [0x822A63C4..0x822A63DC)
	// 822A63C4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 822A63C8: 419A0014  beq cr6, 0x822a63dc
	if ctx.cr[6].eq {
	pc = 0x822A63DC; continue 'dispatch;
	}
	// 822A63CC: 39603390  li r11, 0x3390
	ctx.r[11].s64 = 13200;
	pc = 0x822A63DC; continue 'dispatch;
            }
            0x822A63DC => {
    //   block [0x822A63DC..0x822A6554)
	// 822A63DC: FB7F3390  std r27, 0x3390(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(13200 as u32), ctx.r[27].u64 ) };
	// 822A63E0: FB7F3398  std r27, 0x3398(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(13208 as u32), ctx.r[27].u64 ) };
	// 822A63E4: 817F3098  lwz r11, 0x3098(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12440 as u32) ) } as u64;
	// 822A63E8: D3FF33A0  stfs f31, 0x33a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13216 as u32), tmp.u32 ) };
	// 822A63EC: 937F33A4  stw r27, 0x33a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13220 as u32), ctx.r[27].u32 ) };
	// 822A63F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A63F4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822A63F8: 409A0008  bne cr6, 0x822a6400
	if !ctx.cr[6].eq {
	pc = 0x822A6400; continue 'dispatch;
	}
	// 822A63FC: 815F30A8  lwz r10, 0x30a8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12456 as u32) ) } as u64;
	// 822A6400: 893F2ABC  lbz r9, 0x2abc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 822A6404: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 822A6408: 80FF309C  lwz r7, 0x309c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12444 as u32) ) } as u64;
	// 822A640C: 80DF30A0  lwz r6, 0x30a0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12448 as u32) ) } as u64;
	// 822A6410: 61290020  ori r9, r9, 0x20
	ctx.r[9].u64 = ctx.r[9].u64 | 32;
	// 822A6414: 80BF30A4  lwz r5, 0x30a4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12452 as u32) ) } as u64;
	// 822A6418: 809F30A8  lwz r4, 0x30a8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12456 as u32) ) } as u64;
	// 822A641C: 55230739  rlwinm. r3, r9, 0, 0x1c, 0x1c
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 822A6420: 915F31B4  stw r10, 0x31b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12724 as u32), ctx.r[10].u32 ) };
	// 822A6424: 917F31B8  stw r11, 0x31b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12728 as u32), ctx.r[11].u32 ) };
	// 822A6428: 90FF31BC  stw r7, 0x31bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12732 as u32), ctx.r[7].u32 ) };
	// 822A642C: 90DF31C0  stw r6, 0x31c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12736 as u32), ctx.r[6].u32 ) };
	// 822A6430: 90BF31C4  stw r5, 0x31c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12740 as u32), ctx.r[5].u32 ) };
	// 822A6434: 909F31C8  stw r4, 0x31c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12744 as u32), ctx.r[4].u32 ) };
	// 822A6438: 911F31B0  stw r8, 0x31b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12720 as u32), ctx.r[8].u32 ) };
	// 822A643C: 993F2ABC  stb r9, 0x2abc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10940 as u32), ctx.r[9].u8 ) };
	// 822A6440: 937F31AC  stw r27, 0x31ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12716 as u32), ctx.r[27].u32 ) };
	// 822A6444: 40820044  bne 0x822a6488
	if !ctx.cr[0].eq {
	pc = 0x822A6488; continue 'dispatch;
	}
	// 822A6448: 552B063E  clrlwi r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 822A644C: 556B077B  rlwinm. r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A6450: 40820038  bne 0x822a6488
	if !ctx.cr[0].eq {
	pc = 0x822A6488; continue 'dispatch;
	}
	// 822A6454: 897F2F9B  lbz r11, 0x2f9b(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12187 as u32) ) } as u64;
	// 822A6458: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822A645C: 4082002C  bne 0x822a6488
	if !ctx.cr[0].eq {
	pc = 0x822A6488; continue 'dispatch;
	}
	// 822A6460: 552B063E  clrlwi r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 822A6464: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A6468: 4182000C  beq 0x822a6474
	if ctx.cr[0].eq {
	pc = 0x822A6474; continue 'dispatch;
	}
	// 822A646C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A6470: 4800000C  b 0x822a647c
	pc = 0x822A647C; continue 'dispatch;
	// 822A6474: 897F2ABC  lbz r11, 0x2abc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 822A6478: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822A647C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A6480: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A6484: 40820008  bne 0x822a648c
	if !ctx.cr[0].eq {
	pc = 0x822A648C; continue 'dispatch;
	}
	// 822A6488: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 822A648C: 895F2ABC  lbz r10, 0x2abc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 822A6490: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 822A6494: 937F31A8  stw r27, 0x31a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12712 as u32), ctx.r[27].u32 ) };
	// 822A6498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A649C: 516A07FE  rlwimi r10, r11, 0, 0x1f, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(0) as u64) & 0x0000000000000001) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFFE);
	// 822A64A0: 913F31A4  stw r9, 0x31a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12708 as u32), ctx.r[9].u32 ) };
	// 822A64A4: 937F2AB4  stw r27, 0x2ab4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10932 as u32), ctx.r[27].u32 ) };
	// 822A64A8: 937F2AB8  stw r27, 0x2ab8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10936 as u32), ctx.r[27].u32 ) };
	// 822A64AC: 995F2ABC  stb r10, 0x2abc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10940 as u32), ctx.r[10].u8 ) };
	// 822A64B0: 4BFFFA39  bl 0x822a5ee8
	ctx.lr = 0x822A64B4;
	sub_822A5EE8(ctx, base);
	// 822A64B4: 817F3440  lwz r11, 0x3440(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13376 as u32) ) } as u64;
	// 822A64B8: 813F3444  lwz r9, 0x3444(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13380 as u32) ) } as u64;
	// 822A64BC: 387F3438  addi r3, r31, 0x3438
	ctx.r[3].s64 = ctx.r[31].s64 + 13368;
	// 822A64C0: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 822A64C4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822A64C8: 4099000C  ble cr6, 0x822a64d4
	if !ctx.cr[6].gt {
	pc = 0x822A64D4; continue 'dispatch;
	}
	// 822A64CC: 4BF2B0E5  bl 0x821d15b0
	ctx.lr = 0x822A64D0;
	sub_821D15B0(ctx, base);
	// 822A64D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822A64D4: 3D408600  lis r10, -0x7a00
	ctx.r[10].s64 = -2046820352;
	// 822A64D8: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 822A64DC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822A64E0: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 822A64E4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822A64E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822A64EC: 913F3440  stw r9, 0x3440(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13376 as u32), ctx.r[9].u32 ) };
	// 822A64F0: 40990010  ble cr6, 0x822a6500
	if !ctx.cr[6].gt {
	pc = 0x822A6500; continue 'dispatch;
	}
	// 822A64F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A64F8: 4BF429C9  bl 0x821e8ec0
	ctx.lr = 0x822A64FC;
	sub_821E8EC0(ctx, base);
	// 822A64FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822A6500: 3D40C000  lis r10, -0x4000
	ctx.r[10].s64 = -1073741824;
	// 822A6504: 39200019  li r9, 0x19
	ctx.r[9].s64 = 25;
	// 822A6508: 614A4600  ori r10, r10, 0x4600
	ctx.r[10].u64 = ctx.r[10].u64 | 17920;
	// 822A650C: 38800046  li r4, 0x46
	ctx.r[4].s64 = 70;
	// 822A6510: 954B0004  stwu r10, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[11].u32 = ea;
	// 822A6514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A6518: 952B0004  stwu r9, 4(r11)
	ea = ctx.r[11].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[11].u32 = ea;
	// 822A651C: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 822A6520: 4BF6D5B9  bl 0x82213ad8
	ctx.lr = 0x822A6524;
	sub_82213AD8(ctx, base);
	// 822A6524: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822A6528: 41820008  beq 0x822a6530
	if ctx.cr[0].eq {
	pc = 0x822A6530; continue 'dispatch;
	}
	// 822A652C: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 822A6530: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822A6534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A6538: 4BF53A21  bl 0x821f9f58
	ctx.lr = 0x822A653C;
	sub_821F9F58(ctx, base);
	// 822A653C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822A6540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A6544: 48000015  bl 0x822a6558
	ctx.lr = 0x822A6548;
	sub_822A6558(ctx, base);
	// 822A6548: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 822A654C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822A6550: 48A02F00  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A6558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A6558 size=244
    let mut pc: u32 = 0x822A6558;
    'dispatch: loop {
        match pc {
            0x822A6558 => {
    //   block [0x822A6558..0x822A658C)
	// 822A6558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A655C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A6560: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A6564: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A6568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A656C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 822A6570: 409A0070  bne cr6, 0x822a65e0
	if !ctx.cr[6].eq {
	pc = 0x822A65E0; continue 'dispatch;
	}
	// 822A6574: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 822A6578: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822A657C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A6580: 4099000C  ble cr6, 0x822a658c
	if !ctx.cr[6].gt {
	pc = 0x822A658C; continue 'dispatch;
	}
	// 822A6584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A6588: 4BF42939  bl 0x821e8ec0
	ctx.lr = 0x822A658C;
	sub_821E8EC0(ctx, base);
	pc = 0x822A658C; continue 'dispatch;
            }
            0x822A658C => {
    //   block [0x822A658C..0x822A65E0)
	// 822A658C: 3D60C000  lis r11, -0x4000
	ctx.r[11].s64 = -1073741824;
	// 822A6590: 3D40C000  lis r10, -0x4000
	ctx.r[10].s64 = -1073741824;
	// 822A6594: 616B6000  ori r11, r11, 0x6000
	ctx.r[11].u64 = ctx.r[11].u64 | 24576;
	// 822A6598: 614A6200  ori r10, r10, 0x6200
	ctx.r[10].u64 = ctx.r[10].u64 | 25088;
	// 822A659C: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 822A65A0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822A65A4: 813F31A4  lwz r9, 0x31a4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12708 as u32) ) } as u64;
	// 822A65A8: 3D00C000  lis r8, -0x4000
	ctx.r[8].s64 = -1073741824;
	// 822A65AC: 3CE0C000  lis r7, -0x4000
	ctx.r[7].s64 = -1073741824;
	// 822A65B0: 61086100  ori r8, r8, 0x6100
	ctx.r[8].u64 = ctx.r[8].u64 | 24832;
	// 822A65B4: 60E76300  ori r7, r7, 0x6300
	ctx.r[7].u64 = ctx.r[7].u64 | 25344;
	// 822A65B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822A65BC: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 822A65C0: 95430004  stwu r10, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[3].u32 = ea;
	// 822A65C4: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 822A65C8: 95030004  stwu r8, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[8].u32) };
	ctx.r[3].u32 = ea;
	// 822A65CC: 817F31A8  lwz r11, 0x31a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12712 as u32) ) } as u64;
	// 822A65D0: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 822A65D4: 94E30004  stwu r7, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[7].u32) };
	ctx.r[3].u32 = ea;
	// 822A65D8: 94C30004  stwu r6, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[6].u32) };
	ctx.r[3].u32 = ea;
	// 822A65DC: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	pc = 0x822A65E0; continue 'dispatch;
            }
            0x822A65E0 => {
    //   block [0x822A65E0..0x822A664C)
	// 822A65E0: 817F28C8  lwz r11, 0x28c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10440 as u32) ) } as u64;
	// 822A65E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A65E8: 815F28C4  lwz r10, 0x28c4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10436 as u32) ) } as u64;
	// 822A65EC: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822A65F0: 556B881C  slwi r11, r11, 0x11
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(17);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822A65F4: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A65F8: 7D278E70  srawi r7, r9, 0x11
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 17) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[9].s32 >> 17) as i64;
	// 822A65FC: 554A881C  slwi r10, r10, 0x11
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(17);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822A6600: 7D668E70  srawi r6, r11, 0x11
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 17) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[11].s32 >> 17) as i64;
	// 822A6604: 7D058E70  srawi r5, r8, 0x11
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 17) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[8].s32 >> 17) as i64;
	// 822A6608: 7D448E70  srawi r4, r10, 0x11
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 17) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[10].s32 >> 17) as i64;
	// 822A660C: 4BF5330D  bl 0x821f9918
	ctx.lr = 0x822A6610;
	sub_821F9918(ctx, base);
	// 822A6610: 817F2AA4  lwz r11, 0x2aa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10916 as u32) ) } as u64;
	// 822A6614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A6618: 5564A7BE  rlwinm r4, r11, 0x14, 0x1e, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 822A661C: 48008F4D  bl 0x822af568
	ctx.lr = 0x822A6620;
	sub_822AF568(ctx, base);
	// 822A6620: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822A6624: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 822A6628: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822A662C: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 822A6630: F97F0018  std r11, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 822A6634: F97F0020  std r11, 0x20(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 822A6638: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822A663C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A6640: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A6644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822A6648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A6650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A6650 size=1256
    let mut pc: u32 = 0x822A6650;
    'dispatch: loop {
        match pc {
            0x822A6650 => {
    //   block [0x822A6650..0x822A66B0)
	// 822A6650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A6654: 48A02D99  bl 0x82ca93ec
	ctx.lr = 0x822A6658;
	sub_82CA93D0(ctx, base);
	// 822A6658: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 822A665C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A6660: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 822A6664: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 822A6668: 7F35CB78  mr r21, r25
	ctx.r[21].u64 = ctx.r[25].u64;
	// 822A666C: 80770004  lwz r3, 4(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A6670: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 822A6674: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6678: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A667C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A6680: 4E800421  bctrl
	ctx.lr = 0x822A6684;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A6684: 80D70004  lwz r6, 4(r23)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A6688: 3BE0000C  li r31, 0xc
	ctx.r[31].s64 = 12;
	// 822A668C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822A6690: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822A6694: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 822A6698: 81260018  lwz r9, 0x18(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 822A669C: 80A6001C  lwz r5, 0x1c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A66A0: 7D092850  subf r8, r9, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	// 822A66A4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 822A66A8: 7D68FBD7  divw. r11, r8, r31
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[31].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A66AC: 4081005C  ble 0x822a6708
	if !ctx.cr[0].gt {
	pc = 0x822A6708; continue 'dispatch;
	}
            }
            0x822A66B0 => {
    //   block [0x822A66B0..0x822A66D8)
	// 822A66B0: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A66B4: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A66B8: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822A66BC: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A66C0: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 822A66C4: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A66C8: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 822A66CC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822A66D0: 41980008  blt cr6, 0x822a66d8
	if ctx.cr[6].lt {
	pc = 0x822A66D8; continue 'dispatch;
	}
	// 822A66D4: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x822A66D8; continue 'dispatch;
            }
            0x822A66D8 => {
    //   block [0x822A66D8..0x822A66F4)
	// 822A66D8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A66DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A66E0: 419A0014  beq cr6, 0x822a66f4
	if ctx.cr[6].eq {
	pc = 0x822A66F4; continue 'dispatch;
	}
	// 822A66E4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822A66E8: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 822A66EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A66F0: 4800000C  b 0x822a66fc
	pc = 0x822A66FC; continue 'dispatch;
            }
            0x822A66F4 => {
    //   block [0x822A66F4..0x822A66FC)
	// 822A66F4: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822A66F8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x822A66FC; continue 'dispatch;
            }
            0x822A66FC => {
    //   block [0x822A66FC..0x822A6708)
	// 822A66FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A6700: 4199FFB0  bgt cr6, 0x822a66b0
	if ctx.cr[6].gt {
	pc = 0x822A66B0; continue 'dispatch;
	}
	// 822A6704: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x822A6708; continue 'dispatch;
            }
            0x822A6708 => {
    //   block [0x822A6708..0x822A6724)
	// 822A6708: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 822A670C: 419A0034  beq cr6, 0x822a6740
	if ctx.cr[6].eq {
	pc = 0x822A6740; continue 'dispatch;
	}
	// 822A6710: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6714: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822A6718: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A671C: 41990008  bgt cr6, 0x822a6724
	if ctx.cr[6].gt {
	pc = 0x822A6724; continue 'dispatch;
	}
	// 822A6720: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A6724; continue 'dispatch;
            }
            0x822A6724 => {
    //   block [0x822A6724..0x822A6740)
	// 822A6724: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A6728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A672C: 409A0014  bne cr6, 0x822a6740
	if !ctx.cr[6].eq {
	pc = 0x822A6740; continue 'dispatch;
	}
	// 822A6730: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A6734: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 822A6738: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822A673C: 48000008  b 0x822a6744
	pc = 0x822A6744; continue 'dispatch;
            }
            0x822A6740 => {
    //   block [0x822A6740..0x822A6744)
	// 822A6740: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x822A6744; continue 'dispatch;
            }
            0x822A6744 => {
    //   block [0x822A6744..0x822A675C)
	// 822A6744: 8146001C  lwz r10, 0x1c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A6748: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822A674C: 419A0010  beq cr6, 0x822a675c
	if ctx.cr[6].eq {
	pc = 0x822A675C; continue 'dispatch;
	}
	// 822A6750: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A6754: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A6758: 48000008  b 0x822a6760
	pc = 0x822A6760; continue 'dispatch;
            }
            0x822A675C => {
    //   block [0x822A675C..0x822A6760)
	// 822A675C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A6760; continue 'dispatch;
            }
            0x822A6760 => {
    //   block [0x822A6760..0x822A67C8)
	// 822A6760: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A6764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6768: 419A03C4  beq cr6, 0x822a6b2c
	if ctx.cr[6].eq {
	pc = 0x822A6B2C; continue 'dispatch;
	}
	// 822A676C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6770: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822A6774: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A6778: 4E800421  bctrl
	ctx.lr = 0x822A677C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A677C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 822A6780: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 822A6784: 419A03A8  beq cr6, 0x822a6b2c
	if ctx.cr[6].eq {
	pc = 0x822A6B2C; continue 'dispatch;
	}
	// 822A6788: 81770010  lwz r11, 0x10(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A678C: 3B57000C  addi r26, r23, 0xc
	ctx.r[26].s64 = ctx.r[23].s64 + 12;
	// 822A6790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6794: 419A0398  beq cr6, 0x822a6b2c
	if ctx.cr[6].eq {
	pc = 0x822A6B2C; continue 'dispatch;
	}
	// 822A6798: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A679C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822A67A0: 7D09FBD7  divw. r8, r9, r31
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[31].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822A67A4: 41820388  beq 0x822a6b2c
	if ctx.cr[0].eq {
	pc = 0x822A6B2C; continue 'dispatch;
	}
	// 822A67A8: 89770037  lbz r11, 0x37(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(55 as u32) ) } as u64;
	// 822A67AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A67B0: 409A037C  bne cr6, 0x822a6b2c
	if !ctx.cr[6].eq {
	pc = 0x822A6B2C; continue 'dispatch;
	}
	// 822A67B4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A67B8: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822A67BC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822A67C0: 40990008  ble cr6, 0x822a67c8
	if !ctx.cr[6].gt {
	pc = 0x822A67C8; continue 'dispatch;
	}
	// 822A67C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
            }
            0x822A67C8 => {
    //   block [0x822A67C8..0x822A67D8)
	// 822A67C8: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822A67CC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822A67D0: 3F00820A  lis r24, -0x7df6
	ctx.r[24].s64 = -2113273856;
	// 822A67D4: 3B6BAA9C  addi r27, r11, -0x5564
	ctx.r[27].s64 = ctx.r[11].s64 + -21860;
	pc = 0x822A67D8; continue 'dispatch;
            }
            0x822A67D8 => {
    //   block [0x822A67D8..0x822A67EC)
	// 822A67D8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A67DC: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A67E0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A67E4: 40990008  ble cr6, 0x822a67ec
	if !ctx.cr[6].gt {
	pc = 0x822A67EC; continue 'dispatch;
	}
	// 822A67E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A67EC; continue 'dispatch;
            }
            0x822A67EC => {
    //   block [0x822A67EC..0x822A67F8)
	// 822A67EC: 7F1AD040  cmplw cr6, r26, r26
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[26].u32, &mut ctx.xer);
	// 822A67F0: 419A0008  beq cr6, 0x822a67f8
	if ctx.cr[6].eq {
	pc = 0x822A67F8; continue 'dispatch;
	}
	// 822A67F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A67F8; continue 'dispatch;
            }
            0x822A67F8 => {
    //   block [0x822A67F8..0x822A680C)
	// 822A67F8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A67FC: 419A0330  beq cr6, 0x822a6b2c
	if ctx.cr[6].eq {
	pc = 0x822A6B2C; continue 'dispatch;
	}
	// 822A6800: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822A6804: 41980008  blt cr6, 0x822a680c
	if ctx.cr[6].lt {
	pc = 0x822A680C; continue 'dispatch;
	}
	// 822A6808: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A680C; continue 'dispatch;
            }
            0x822A680C => {
    //   block [0x822A680C..0x822A6830)
	// 822A680C: 83BC0000  lwz r29, 0(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6810: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 822A6814: 4810A225  bl 0x823b0a38
	ctx.lr = 0x822A6818;
	sub_823B0A38(ctx, base);
	// 822A6818: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A681C: 80FB0008  lwz r7, 8(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A6820: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 822A6824: 7D6A3850  subf r11, r10, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 822A6828: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A682C: 4081003C  ble 0x822a6868
	if !ctx.cr[0].gt {
	pc = 0x822A6868; continue 'dispatch;
	}
	pc = 0x822A6830; continue 'dispatch;
            }
            0x822A6830 => {
    //   block [0x822A6830..0x822A6858)
	// 822A6830: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A6834: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A6838: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822A683C: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6840: 7F061840  cmplw cr6, r6, r3
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[3].u32, &mut ctx.xer);
	// 822A6844: 40980014  bge cr6, 0x822a6858
	if !ctx.cr[6].lt {
	pc = 0x822A6858; continue 'dispatch;
	}
	// 822A6848: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A684C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A6850: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A6854: 4800000C  b 0x822a6860
	pc = 0x822A6860; continue 'dispatch;
            }
            0x822A6858 => {
    //   block [0x822A6858..0x822A6860)
	// 822A6858: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A685C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822A6860; continue 'dispatch;
            }
            0x822A6860 => {
    //   block [0x822A6860..0x822A6868)
	// 822A6860: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A6864: 4199FFCC  bgt cr6, 0x822a6830
	if ctx.cr[6].gt {
	pc = 0x822A6830; continue 'dispatch;
	}
	pc = 0x822A6868; continue 'dispatch;
            }
            0x822A6868 => {
    //   block [0x822A6868..0x822A68C8)
	// 822A6868: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 822A686C: 419A0184  beq cr6, 0x822a69f0
	if ctx.cr[6].eq {
	pc = 0x822A69F0; continue 'dispatch;
	}
	// 822A6870: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6874: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A6878: 41980178  blt cr6, 0x822a69f0
	if ctx.cr[6].lt {
	pc = 0x822A69F0; continue 'dispatch;
	}
	// 822A687C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 822A6880: 3BCA0004  addi r30, r10, 4
	ctx.r[30].s64 = ctx.r[10].s64 + 4;
	// 822A6884: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 822A6888: 4BFC5E79  bl 0x8226c700
	ctx.lr = 0x822A688C;
	sub_8226C700(ctx, base);
	// 822A688C: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 822A6890: 556A27FE  rlwinm r10, r11, 4, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 822A6894: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A6898: 419A00F0  beq cr6, 0x822a6988
	if ctx.cr[6].eq {
	pc = 0x822A6988; continue 'dispatch;
	}
	// 822A689C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A68A0: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A68A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A68A8: 419A0020  beq cr6, 0x822a68c8
	if ctx.cr[6].eq {
	pc = 0x822A68C8; continue 'dispatch;
	}
	// 822A68AC: 896B001C  lbz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A68B0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 822A68B4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822A68B8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A68BC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822A68C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A68C4: 480000C8  b 0x822a698c
	pc = 0x822A698C; continue 'dispatch;
            }
            0x822A68C8 => {
    //   block [0x822A68C8..0x822A68E0)
	// 822A68C8: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A68CC: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 822A68D0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A68D4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822A68D8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A68DC: 40810054  ble 0x822a6930
	if !ctx.cr[0].gt {
	pc = 0x822A6930; continue 'dispatch;
	}
	pc = 0x822A68E0; continue 'dispatch;
            }
            0x822A68E0 => {
    //   block [0x822A68E0..0x822A6900)
	// 822A68E0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A68E4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A68E8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822A68EC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A68F0: 2F07001C  cmpwi cr6, r7, 0x1c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 28, &mut ctx.xer);
	// 822A68F4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822A68F8: 41980008  blt cr6, 0x822a6900
	if ctx.cr[6].lt {
	pc = 0x822A6900; continue 'dispatch;
	}
	// 822A68FC: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x822A6900; continue 'dispatch;
            }
            0x822A6900 => {
    //   block [0x822A6900..0x822A691C)
	// 822A6900: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A6904: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A6908: 419A0014  beq cr6, 0x822a691c
	if ctx.cr[6].eq {
	pc = 0x822A691C; continue 'dispatch;
	}
	// 822A690C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A6910: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A6914: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A6918: 4800000C  b 0x822a6924
	pc = 0x822A6924; continue 'dispatch;
            }
            0x822A691C => {
    //   block [0x822A691C..0x822A6924)
	// 822A691C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A6920: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822A6924; continue 'dispatch;
            }
            0x822A6924 => {
    //   block [0x822A6924..0x822A6930)
	// 822A6924: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A6928: 4199FFB8  bgt cr6, 0x822a68e0
	if ctx.cr[6].gt {
	pc = 0x822A68E0; continue 'dispatch;
	}
	// 822A692C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x822A6930; continue 'dispatch;
            }
            0x822A6930 => {
    //   block [0x822A6930..0x822A694C)
	// 822A6930: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A6934: 419A0040  beq cr6, 0x822a6974
	if ctx.cr[6].eq {
	pc = 0x822A6974; continue 'dispatch;
	}
	// 822A6938: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A693C: 2F0B001C  cmpwi cr6, r11, 0x1c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 28, &mut ctx.xer);
	// 822A6940: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A6944: 41990008  bgt cr6, 0x822a694c
	if ctx.cr[6].gt {
	pc = 0x822A694C; continue 'dispatch;
	}
	// 822A6948: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A694C; continue 'dispatch;
            }
            0x822A694C => {
    //   block [0x822A694C..0x822A6974)
	// 822A694C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A6950: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6954: 409A0020  bne cr6, 0x822a6974
	if !ctx.cr[6].eq {
	pc = 0x822A6974; continue 'dispatch;
	}
	// 822A6958: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822A695C: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 822A6960: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822A6964: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A6968: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822A696C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A6970: 4800001C  b 0x822a698c
	pc = 0x822A698C; continue 'dispatch;
            }
            0x822A6974 => {
    //   block [0x822A6974..0x822A6988)
	// 822A6974: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A6978: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A697C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822A6980: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A6984: 48000008  b 0x822a698c
	pc = 0x822A698C; continue 'dispatch;
            }
            0x822A6988 => {
    //   block [0x822A6988..0x822A698C)
	// 822A6988: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A698C; continue 'dispatch;
            }
            0x822A698C => {
    //   block [0x822A698C..0x822A69C4)
	// 822A698C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A6990: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6994: 419A005C  beq cr6, 0x822a69f0
	if ctx.cr[6].eq {
	pc = 0x822A69F0; continue 'dispatch;
	}
	// 822A6998: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822A699C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A69A0: 48011E31  bl 0x822b87d0
	ctx.lr = 0x822A69A4;
	sub_822B87D0(ctx, base);
	// 822A69A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A69A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822A69AC: 419A0018  beq cr6, 0x822a69c4
	if ctx.cr[6].eq {
	pc = 0x822A69C4; continue 'dispatch;
	}
	// 822A69B0: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 822A69B4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822A69B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A69BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A69C0: 409A0008  bne cr6, 0x822a69c8
	if !ctx.cr[6].eq {
	pc = 0x822A69C8; continue 'dispatch;
	}
	pc = 0x822A69C4; continue 'dispatch;
            }
            0x822A69C4 => {
    //   block [0x822A69C4..0x822A69C8)
	// 822A69C4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A69C8; continue 'dispatch;
            }
            0x822A69C8 => {
    //   block [0x822A69C8..0x822A69F0)
	// 822A69C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A69CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A69D0: 419A0020  beq cr6, 0x822a69f0
	if ctx.cr[6].eq {
	pc = 0x822A69F0; continue 'dispatch;
	}
	// 822A69D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822A69D8: 4BECD461  bl 0x82173e38
	ctx.lr = 0x822A69DC;
	sub_82173E38(ctx, base);
	// 822A69DC: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 822A69E0: 419A0010  beq cr6, 0x822a69f0
	if ctx.cr[6].eq {
	pc = 0x822A69F0; continue 'dispatch;
	}
	// 822A69E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822A69E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822A69EC: 4BEFEC0D  bl 0x821a55f8
	ctx.lr = 0x822A69F0;
	sub_821A55F8(ctx, base);
	pc = 0x822A69F0; continue 'dispatch;
            }
            0x822A69F0 => {
    //   block [0x822A69F0..0x822A6A30)
	// 822A69F0: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 822A69F4: C0370060  lfs f1, 0x60(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822A69F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822A69FC: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 822A6A00: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 822A6A04: 48000135  bl 0x822a6b38
	ctx.lr = 0x822A6A08;
	sub_822A6B38(ctx, base);
	// 822A6A08: C01D0054  lfs f0, 0x54(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A6A0C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 822A6A10: 40990048  ble cr6, 0x822a6a58
	if !ctx.cr[6].gt {
	pc = 0x822A6A58; continue 'dispatch;
	}
	// 822A6A14: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A6A18: 62B50001  ori r21, r21, 1
	ctx.r[21].u64 = ctx.r[21].u64 | 1;
	// 822A6A1C: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A6A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6A24: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 822A6A28: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 822A6A2C: 419A0020  beq cr6, 0x822a6a4c
	if ctx.cr[6].eq {
	pc = 0x822A6A4C; continue 'dispatch;
	}
	pc = 0x822A6A30; continue 'dispatch;
            }
            0x822A6A30 => {
    //   block [0x822A6A30..0x822A6A4C)
	// 822A6A30: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 822A6A34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A6A38: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 822A6A3C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822A6A40: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822A6A44: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A6A48: 4082FFE8  bne 0x822a6a30
	if !ctx.cr[0].eq {
	pc = 0x822A6A30; continue 'dispatch;
	}
	pc = 0x822A6A4C; continue 'dispatch;
            }
            0x822A6A4C => {
    //   block [0x822A6A4C..0x822A6A58)
	// 822A6A4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A6A50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A6A54: 409A0008  bne cr6, 0x822a6a5c
	if !ctx.cr[6].eq {
	pc = 0x822A6A5C; continue 'dispatch;
	}
	pc = 0x822A6A58; continue 'dispatch;
            }
            0x822A6A58 => {
    //   block [0x822A6A58..0x822A6A5C)
	// 822A6A58: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822A6A5C; continue 'dispatch;
            }
            0x822A6A5C => {
    //   block [0x822A6A5C..0x822A6A78)
	// 822A6A5C: 56AA07FE  clrlwi r10, r21, 0x1f
	ctx.r[10].u64 = ctx.r[21].u32 as u64 & 0x00000001u64;
	// 822A6A60: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A6A64: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822A6A68: 419A0010  beq cr6, 0x822a6a78
	if ctx.cr[6].eq {
	pc = 0x822A6A78; continue 'dispatch;
	}
	// 822A6A6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822A6A70: 56B5003C  rlwinm r21, r21, 0, 0, 0x1e
	ctx.r[21].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	// 822A6A74: 4BF110A5  bl 0x821b7b18
	ctx.lr = 0x822A6A78;
	sub_821B7B18(ctx, base);
	pc = 0x822A6A78; continue 'dispatch;
            }
            0x822A6A78 => {
    //   block [0x822A6A78..0x822A6AA0)
	// 822A6A78: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 822A6A7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6A80: 419A0094  beq cr6, 0x822a6b14
	if ctx.cr[6].eq {
	pc = 0x822A6B14; continue 'dispatch;
	}
	// 822A6A84: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A6A88: 3BFD0010  addi r31, r29, 0x10
	ctx.r[31].s64 = ctx.r[29].s64 + 16;
	// 822A6A8C: 807D0010  lwz r3, 0x10(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A6A90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6A94: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 822A6A98: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 822A6A9C: 419A0020  beq cr6, 0x822a6abc
	if ctx.cr[6].eq {
	pc = 0x822A6ABC; continue 'dispatch;
	}
	pc = 0x822A6AA0; continue 'dispatch;
            }
            0x822A6AA0 => {
    //   block [0x822A6AA0..0x822A6ABC)
	// 822A6AA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822A6AA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A6AA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822A6AAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822A6AB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822A6AB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A6AB8: 4082FFE8  bne 0x822a6aa0
	if !ctx.cr[0].eq {
	pc = 0x822A6AA0; continue 'dispatch;
	}
	pc = 0x822A6ABC; continue 'dispatch;
            }
            0x822A6ABC => {
    //   block [0x822A6ABC..0x822A6AE4)
	// 822A6ABC: C03892CC  lfs f1, -0x6d34(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-27956 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822A6AC0: 48F8B5D9  bl 0x83232098
	ctx.lr = 0x822A6AC4;
	sub_83232098(ctx, base);
	// 822A6AC4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822A6AC8: 4BF11051  bl 0x821b7b18
	ctx.lr = 0x822A6ACC;
	sub_821B7B18(ctx, base);
	// 822A6ACC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A6AD0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6AD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6AD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822A6ADC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822A6AE0: 419A0020  beq cr6, 0x822a6b00
	if ctx.cr[6].eq {
	pc = 0x822A6B00; continue 'dispatch;
	}
	pc = 0x822A6AE4; continue 'dispatch;
            }
            0x822A6AE4 => {
    //   block [0x822A6AE4..0x822A6B00)
	// 822A6AE4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822A6AE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A6AEC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822A6AF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822A6AF4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822A6AF8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A6AFC: 4082FFE8  bne 0x822a6ae4
	if !ctx.cr[0].eq {
	pc = 0x822A6AE4; continue 'dispatch;
	}
	pc = 0x822A6B00; continue 'dispatch;
            }
            0x822A6B00 => {
    //   block [0x822A6B00..0x822A6B14)
	// 822A6B00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A6B04: 4BF11015  bl 0x821b7b18
	ctx.lr = 0x822A6B08;
	sub_821B7B18(ctx, base);
	// 822A6B08: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 822A6B0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A6B10: 4BF11009  bl 0x821b7b18
	ctx.lr = 0x822A6B14;
	sub_821B7B18(ctx, base);
	pc = 0x822A6B14; continue 'dispatch;
            }
            0x822A6B14 => {
    //   block [0x822A6B14..0x822A6B24)
	// 822A6B14: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A6B18: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822A6B1C: 41980008  blt cr6, 0x822a6b24
	if ctx.cr[6].lt {
	pc = 0x822A6B24; continue 'dispatch;
	}
	// 822A6B20: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A6B24; continue 'dispatch;
            }
            0x822A6B24 => {
    //   block [0x822A6B24..0x822A6B2C)
	// 822A6B24: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 822A6B28: 4BFFFCB0  b 0x822a67d8
	pc = 0x822A67D8; continue 'dispatch;
            }
            0x822A6B2C => {
    //   block [0x822A6B2C..0x822A6B38)
	// 822A6B2C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822A6B30: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 822A6B34: 48A02908  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A6B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A6B38 size=4988
    let mut pc: u32 = 0x822A6B38;
    'dispatch: loop {
        match pc {
            0x822A6B38 => {
    //   block [0x822A6B38..0x822A6BA0)
	// 822A6B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A6B3C: 48A02895  bl 0x82ca93d0
	ctx.lr = 0x822A6B40;
	sub_82CA93D0(ctx, base);
	// 822A6B40: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 822A6B44: 48A0716D  bl 0x82cadcb0
	ctx.lr = 0x822A6B48;
	sub_82CADCA0(ctx, base);
	// 822A6B48: 3981FEF0  addi r12, r1, -0x110
	ctx.r[12].s64 = ctx.r[1].s64 + -272;
	// 822A6B4C: 48D5FE61  bl 0x830069ac
	ctx.lr = 0x822A6B50;
	sub_83006760(ctx, base);
	// 822A6B50: 9421F990  stwu r1, -0x670(r1)
	ea = ctx.r[1].u32.wrapping_add(-1648 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A6B54: FF200890  fmr f25, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[25].f64 = ctx.f[1].f64;
	// 822A6B58: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 822A6B5C: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 822A6B60: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822A6B64: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 822A6B68: 93210684  stw r25, 0x684(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1668 as u32), ctx.r[25].u32 ) };
	// 822A6B6C: 39C00001  li r14, 1
	ctx.r[14].s64 = 1;
	// 822A6B70: 90A10694  stw r5, 0x694(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1684 as u32), ctx.r[5].u32 ) };
	// 822A6B74: 92C1068C  stw r22, 0x68c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1676 as u32), ctx.r[22].u32 ) };
	// 822A6B78: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822A6B7C: 8959006C  lbz r10, 0x6c(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(108 as u32) ) } as u64;
	// 822A6B80: 99410060  stb r10, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u8 ) };
	// 822A6B84: EC19F828  fsubs f0, f25, f31
	ctx.f[0].f64 = (((ctx.f[25].f64 - ctx.f[31].f64) as f32) as f64);
	// 822A6B88: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 822A6B8C: C00B9054  lfs f0, -0x6fac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A6B90: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	// 822A6B94: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822A6B98: 41980008  blt cr6, 0x822a6ba0
	if ctx.cr[6].lt {
	pc = 0x822A6BA0; continue 'dispatch;
	}
	// 822A6B9C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822A6BA0; continue 'dispatch;
            }
            0x822A6BA0 => {
    //   block [0x822A6BA0..0x822A6BE8)
	// 822A6BA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A6BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6BA8: 409A12F4  bne cr6, 0x822a7e9c
	if !ctx.cr[6].eq {
	pc = 0x822A7E9C; continue 'dispatch;
	}
	// 822A6BAC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822A6BB0: 4BFC5B51  bl 0x8226c700
	ctx.lr = 0x822A6BB4;
	sub_8226C700(ctx, base);
	// 822A6BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A6BB8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822A6BBC: 93E1010C  stw r31, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[31].u32 ) };
	// 822A6BC0: 4BECD279  bl 0x82173e38
	ctx.lr = 0x822A6BC4;
	sub_82173E38(ctx, base);
	// 822A6BC4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822A6BC8: 93A10100  stw r29, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[29].u32 ) };
	// 822A6BCC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822A6BD0: 419A0018  beq cr6, 0x822a6be8
	if ctx.cr[6].eq {
	pc = 0x822A6BE8; continue 'dispatch;
	}
	// 822A6BD4: 897D0090  lbz r11, 0x90(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 822A6BD8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822A6BDC: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	// 822A6BE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A6BE4: 409A0008  bne cr6, 0x822a6bec
	if !ctx.cr[6].eq {
	pc = 0x822A6BEC; continue 'dispatch;
	}
	pc = 0x822A6BE8; continue 'dispatch;
            }
            0x822A6BE8 => {
    //   block [0x822A6BE8..0x822A6BEC)
	// 822A6BE8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822A6BEC; continue 'dispatch;
            }
            0x822A6BEC => {
    //   block [0x822A6BEC..0x822A6C5C)
	// 822A6BEC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A6BF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6BF4: 419A12A8  beq cr6, 0x822a7e9c
	if ctx.cr[6].eq {
	pc = 0x822A7E9C; continue 'dispatch;
	}
	// 822A6BF8: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 822A6BFC: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 822A6C00: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6C04: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 822A6C08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A6C0C: 4E800421  bctrl
	ctx.lr = 0x822A6C10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A6C10: 80BF0024  lwz r5, 0x24(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 822A6C14: 7FD8F378  mr r24, r30
	ctx.r[24].u64 = ctx.r[30].u64;
	// 822A6C18: 93C100C8  stw r30, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[30].u32 ) };
	// 822A6C1C: 54A9D7FE  rlwinm r9, r5, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[5].u32 as u64 & 0x0000003Fu64;
	// 822A6C20: 930100CC  stw r24, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[24].u32 ) };
	// 822A6C24: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A6C28: 419A0100  beq cr6, 0x822a6d28
	if ctx.cr[6].eq {
	pc = 0x822A6D28; continue 'dispatch;
	}
	// 822A6C2C: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A6C30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6C34: 419A0028  beq cr6, 0x822a6c5c
	if ctx.cr[6].eq {
	pc = 0x822A6C5C; continue 'dispatch;
	}
	// 822A6C38: 894B0006  lbz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 822A6C3C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A6C40: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822A6C44: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822A6C48: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A6C4C: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 822A6C50: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	// 822A6C54: 930100CC  stw r24, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[24].u32 ) };
	// 822A6C58: 480000D4  b 0x822a6d2c
	pc = 0x822A6D2C; continue 'dispatch;
            }
            0x822A6C5C => {
    //   block [0x822A6C5C..0x822A6C78)
	// 822A6C5C: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A6C60: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A6C64: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 822A6C68: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A6C6C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 822A6C70: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A6C74: 40810054  ble 0x822a6cc8
	if !ctx.cr[0].gt {
	pc = 0x822A6CC8; continue 'dispatch;
	}
	pc = 0x822A6C78; continue 'dispatch;
            }
            0x822A6C78 => {
    //   block [0x822A6C78..0x822A6C98)
	// 822A6C78: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A6C7C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A6C80: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822A6C84: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6C88: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 822A6C8C: 7DC77378  mr r7, r14
	ctx.r[7].u64 = ctx.r[14].u64;
	// 822A6C90: 41980008  blt cr6, 0x822a6c98
	if ctx.cr[6].lt {
	pc = 0x822A6C98; continue 'dispatch;
	}
	// 822A6C94: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x822A6C98; continue 'dispatch;
            }
            0x822A6C98 => {
    //   block [0x822A6C98..0x822A6CB4)
	// 822A6C98: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A6C9C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A6CA0: 419A0014  beq cr6, 0x822a6cb4
	if ctx.cr[6].eq {
	pc = 0x822A6CB4; continue 'dispatch;
	}
	// 822A6CA4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A6CA8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A6CAC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A6CB0: 4800000C  b 0x822a6cbc
	pc = 0x822A6CBC; continue 'dispatch;
            }
            0x822A6CB4 => {
    //   block [0x822A6CB4..0x822A6CBC)
	// 822A6CB4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A6CB8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822A6CBC; continue 'dispatch;
            }
            0x822A6CBC => {
    //   block [0x822A6CBC..0x822A6CC8)
	// 822A6CBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A6CC0: 4199FFB8  bgt cr6, 0x822a6c78
	if ctx.cr[6].gt {
	pc = 0x822A6C78; continue 'dispatch;
	}
	// 822A6CC4: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x822A6CC8; continue 'dispatch;
            }
            0x822A6CC8 => {
    //   block [0x822A6CC8..0x822A6CE4)
	// 822A6CC8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A6CCC: 419A0044  beq cr6, 0x822a6d10
	if ctx.cr[6].eq {
	pc = 0x822A6D10; continue 'dispatch;
	}
	// 822A6CD0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6CD4: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 822A6CD8: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	// 822A6CDC: 41990008  bgt cr6, 0x822a6ce4
	if ctx.cr[6].gt {
	pc = 0x822A6CE4; continue 'dispatch;
	}
	// 822A6CE0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822A6CE4; continue 'dispatch;
            }
            0x822A6CE4 => {
    //   block [0x822A6CE4..0x822A6D10)
	// 822A6CE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A6CE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6CEC: 409A0024  bne cr6, 0x822a6d10
	if !ctx.cr[6].eq {
	pc = 0x822A6D10; continue 'dispatch;
	}
	// 822A6CF0: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 822A6CF4: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 822A6CF8: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 822A6CFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A6D00: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 822A6D04: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	// 822A6D08: 930100CC  stw r24, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[24].u32 ) };
	// 822A6D0C: 48000020  b 0x822a6d2c
	pc = 0x822A6D2C; continue 'dispatch;
            }
            0x822A6D10 => {
    //   block [0x822A6D10..0x822A6D28)
	// 822A6D10: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A6D14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A6D18: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 822A6D1C: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	// 822A6D20: 930100CC  stw r24, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[24].u32 ) };
	// 822A6D24: 48000008  b 0x822a6d2c
	pc = 0x822A6D2C; continue 'dispatch;
            }
            0x822A6D28 => {
    //   block [0x822A6D28..0x822A6D2C)
	// 822A6D28: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822A6D2C; continue 'dispatch;
            }
            0x822A6D2C => {
    //   block [0x822A6D2C..0x822A6D70)
	// 822A6D2C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A6D30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6D34: 419A1168  beq cr6, 0x822a7e9c
	if ctx.cr[6].eq {
	pc = 0x822A7E9C; continue 'dispatch;
	}
	// 822A6D38: 54AB57FE  rlwinm r11, r5, 0xa, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x003FFFFFu64;
	// 822A6D3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6D40: 419A00F4  beq cr6, 0x822a6e34
	if ctx.cr[6].eq {
	pc = 0x822A6E34; continue 'dispatch;
	}
	// 822A6D44: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A6D48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6D4C: 419A0024  beq cr6, 0x822a6d70
	if ctx.cr[6].eq {
	pc = 0x822A6D70; continue 'dispatch;
	}
	// 822A6D50: 894B0016  lbz r10, 0x16(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 822A6D54: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A6D58: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822A6D5C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822A6D60: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A6D64: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 822A6D68: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	// 822A6D6C: 480000CC  b 0x822a6e38
	pc = 0x822A6E38; continue 'dispatch;
            }
            0x822A6D70 => {
    //   block [0x822A6D70..0x822A6D8C)
	// 822A6D70: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A6D74: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A6D78: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 822A6D7C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A6D80: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 822A6D84: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A6D88: 40810054  ble 0x822a6ddc
	if !ctx.cr[0].gt {
	pc = 0x822A6DDC; continue 'dispatch;
	}
	pc = 0x822A6D8C; continue 'dispatch;
            }
            0x822A6D8C => {
    //   block [0x822A6D8C..0x822A6DAC)
	// 822A6D8C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A6D90: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A6D94: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822A6D98: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6D9C: 2F070016  cmpwi cr6, r7, 0x16
	ctx.cr[6].compare_i32(ctx.r[7].s32, 22, &mut ctx.xer);
	// 822A6DA0: 7DC77378  mr r7, r14
	ctx.r[7].u64 = ctx.r[14].u64;
	// 822A6DA4: 41980008  blt cr6, 0x822a6dac
	if ctx.cr[6].lt {
	pc = 0x822A6DAC; continue 'dispatch;
	}
	// 822A6DA8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x822A6DAC; continue 'dispatch;
            }
            0x822A6DAC => {
    //   block [0x822A6DAC..0x822A6DC8)
	// 822A6DAC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A6DB0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A6DB4: 419A0014  beq cr6, 0x822a6dc8
	if ctx.cr[6].eq {
	pc = 0x822A6DC8; continue 'dispatch;
	}
	// 822A6DB8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A6DBC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A6DC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A6DC4: 4800000C  b 0x822a6dd0
	pc = 0x822A6DD0; continue 'dispatch;
            }
            0x822A6DC8 => {
    //   block [0x822A6DC8..0x822A6DD0)
	// 822A6DC8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A6DCC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822A6DD0; continue 'dispatch;
            }
            0x822A6DD0 => {
    //   block [0x822A6DD0..0x822A6DDC)
	// 822A6DD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A6DD4: 4199FFB8  bgt cr6, 0x822a6d8c
	if ctx.cr[6].gt {
	pc = 0x822A6D8C; continue 'dispatch;
	}
	// 822A6DD8: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x822A6DDC; continue 'dispatch;
            }
            0x822A6DDC => {
    //   block [0x822A6DDC..0x822A6DF8)
	// 822A6DDC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A6DE0: 419A0040  beq cr6, 0x822a6e20
	if ctx.cr[6].eq {
	pc = 0x822A6E20; continue 'dispatch;
	}
	// 822A6DE4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A6DE8: 2F0B0016  cmpwi cr6, r11, 0x16
	ctx.cr[6].compare_i32(ctx.r[11].s32, 22, &mut ctx.xer);
	// 822A6DEC: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	// 822A6DF0: 41990008  bgt cr6, 0x822a6df8
	if ctx.cr[6].gt {
	pc = 0x822A6DF8; continue 'dispatch;
	}
	// 822A6DF4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822A6DF8; continue 'dispatch;
            }
            0x822A6DF8 => {
    //   block [0x822A6DF8..0x822A6E20)
	// 822A6DF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A6DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6E00: 409A0020  bne cr6, 0x822a6e20
	if !ctx.cr[6].eq {
	pc = 0x822A6E20; continue 'dispatch;
	}
	// 822A6E04: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 822A6E08: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 822A6E0C: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 822A6E10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A6E14: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 822A6E18: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	// 822A6E1C: 4800001C  b 0x822a6e38
	pc = 0x822A6E38; continue 'dispatch;
            }
            0x822A6E20 => {
    //   block [0x822A6E20..0x822A6E34)
	// 822A6E20: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A6E24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A6E28: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 822A6E2C: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	// 822A6E30: 48000008  b 0x822a6e38
	pc = 0x822A6E38; continue 'dispatch;
            }
            0x822A6E34 => {
    //   block [0x822A6E34..0x822A6E38)
	// 822A6E34: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822A6E38; continue 'dispatch;
            }
            0x822A6E38 => {
    //   block [0x822A6E38..0x822A7E9C)
	// 822A6E38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A6E3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A6E40: 419A105C  beq cr6, 0x822a7e9c
	if ctx.cr[6].eq {
	pc = 0x822A7E9C; continue 'dispatch;
	}
	// 822A6E44: 394101F0  addi r10, r1, 0x1f0
	ctx.r[10].s64 = ctx.r[1].s64 + 496;
	// 822A6E48: 392101A0  addi r9, r1, 0x1a0
	ctx.r[9].s64 = ctx.r[1].s64 + 416;
	// 822A6E4C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822A6E50: 390101C0  addi r8, r1, 0x1c0
	ctx.r[8].s64 = ctx.r[1].s64 + 448;
	// 822A6E54: 38E101F0  addi r7, r1, 0x1f0
	ctx.r[7].s64 = ctx.r[1].s64 + 496;
	pc = 0x822A7E9C; continue 'dispatch;
            }
            0x822A7E9C => {
    //   block [0x822A7E9C..0x822A7EB4)
	// 822A7E9C: 38210670  addi r1, r1, 0x670
	ctx.r[1].s64 = ctx.r[1].s64 + 1648;
	// 822A7EA0: 3981FEF0  addi r12, r1, -0x110
	ctx.r[12].s64 = ctx.r[1].s64 + -272;
	// 822A7EA4: 48D5EDA1  bl 0x83006c44
	ctx.lr = 0x822A7EA8;
	sub_830069F8(ctx, base);
	// 822A7EA8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 822A7EAC: 48A05E51  bl 0x82cadcfc
	ctx.lr = 0x822A7EB0;
	sub_82CADCEC(ctx, base);
	// 822A7EB0: 48A01570  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A7EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A7EB8 size=148
    let mut pc: u32 = 0x822A7EB8;
    'dispatch: loop {
        match pc {
            0x822A7EB8 => {
    //   block [0x822A7EB8..0x822A7EF4)
	// 822A7EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A7EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A7EC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A7EC4: 8163FFF8  lwz r11, -8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A7EC8: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822A7ECC: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 822A7ED0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A7ED4: 419A0040  beq cr6, 0x822a7f14
	if ctx.cr[6].eq {
	pc = 0x822A7F14; continue 'dispatch;
	}
	// 822A7ED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A7EDC: 419A0018  beq cr6, 0x822a7ef4
	if ctx.cr[6].eq {
	pc = 0x822A7EF4; continue 'dispatch;
	}
	// 822A7EE0: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 822A7EE4: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822A7EE8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A7EEC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A7EF0: 409A0008  bne cr6, 0x822a7ef8
	if !ctx.cr[6].eq {
	pc = 0x822A7EF8; continue 'dispatch;
	}
	pc = 0x822A7EF4; continue 'dispatch;
            }
            0x822A7EF4 => {
    //   block [0x822A7EF4..0x822A7EF8)
	// 822A7EF4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x822A7EF8; continue 'dispatch;
            }
            0x822A7EF8 => {
    //   block [0x822A7EF8..0x822A7F0C)
	// 822A7EF8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822A7EFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A7F00: 409A000C  bne cr6, 0x822a7f0c
	if !ctx.cr[6].eq {
	pc = 0x822A7F0C; continue 'dispatch;
	}
	// 822A7F04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822A7F08: 4800000C  b 0x822a7f14
	pc = 0x822A7F14; continue 'dispatch;
            }
            0x822A7F0C => {
    //   block [0x822A7F0C..0x822A7F14)
	// 822A7F0C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A7F10: 5564007E  clrlwi r4, r11, 1
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	pc = 0x822A7F14; continue 'dispatch;
            }
            0x822A7F14 => {
    //   block [0x822A7F14..0x822A7F3C)
	// 822A7F14: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A7F18: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 822A7F1C: 419A0020  beq cr6, 0x822a7f3c
	if ctx.cr[6].eq {
	pc = 0x822A7F3C; continue 'dispatch;
	}
	// 822A7F20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822A7F24: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 822A7F28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822A7F2C: 394B113C  addi r10, r11, 0x113c
	ctx.r[10].s64 = ctx.r[11].s64 + 4412;
	// 822A7F30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822A7F34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822A7F38: 4BF82B91  bl 0x8222aac8
	ctx.lr = 0x822A7F3C;
	sub_8222AAC8(ctx, base);
	pc = 0x822A7F3C; continue 'dispatch;
            }
            0x822A7F3C => {
    //   block [0x822A7F3C..0x822A7F4C)
	// 822A7F3C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822A7F40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A7F44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A7F48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A7F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A7F50 size=292
    let mut pc: u32 = 0x822A7F50;
    'dispatch: loop {
        match pc {
            0x822A7F50 => {
    //   block [0x822A7F50..0x822A7F84)
	// 822A7F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A7F54: 48A014B1  bl 0x82ca9404
	ctx.lr = 0x822A7F58;
	sub_82CA93D0(ctx, base);
	// 822A7F58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A7F5C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822A7F60: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822A7F64: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822A7F68: 388B8D14  addi r4, r11, -0x72ec
	ctx.r[4].s64 = ctx.r[11].s64 + -29420;
	// 822A7F6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822A7F70: 4BF58801  bl 0x82200770
	ctx.lr = 0x822A7F74;
	sub_82200770(ctx, base);
	// 822A7F74: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A7F78: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 822A7F7C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 822A7F80: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822A7F84; continue 'dispatch;
            }
            0x822A7F84 => {
    //   block [0x822A7F84..0x822A7F88)
	// 822A7F84: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x822A7F88; continue 'dispatch;
            }
            0x822A7F88 => {
    //   block [0x822A7F88..0x822A7F9C)
	// 822A7F88: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A7F8C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 822A7F90: 419A000C  beq cr6, 0x822a7f9c
	if ctx.cr[6].eq {
	pc = 0x822A7F9C; continue 'dispatch;
	}
	// 822A7F94: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822A7F98: 419A0008  beq cr6, 0x822a7fa0
	if ctx.cr[6].eq {
	pc = 0x822A7FA0; continue 'dispatch;
	}
	pc = 0x822A7F9C; continue 'dispatch;
            }
            0x822A7F9C => {
    //   block [0x822A7F9C..0x822A7FA0)
	// 822A7F9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A7FA0; continue 'dispatch;
            }
            0x822A7FA0 => {
    //   block [0x822A7FA0..0x822A7FB4)
	// 822A7FA0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A7FA4: 419A00B4  beq cr6, 0x822a8058
	if ctx.cr[6].eq {
	pc = 0x822A8058; continue 'dispatch;
	}
	// 822A7FA8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 822A7FAC: 409A0008  bne cr6, 0x822a7fb4
	if !ctx.cr[6].eq {
	pc = 0x822A7FB4; continue 'dispatch;
	}
	// 822A7FB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A7FB4; continue 'dispatch;
            }
            0x822A7FB4 => {
    //   block [0x822A7FB4..0x822A7FC4)
	// 822A7FB4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A7FB8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A7FBC: 409A0008  bne cr6, 0x822a7fc4
	if !ctx.cr[6].eq {
	pc = 0x822A7FC4; continue 'dispatch;
	}
	// 822A7FC0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A7FC4; continue 'dispatch;
            }
            0x822A7FC4 => {
    //   block [0x822A7FC4..0x822A7FF8)
	// 822A7FC4: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A7FC8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822A7FCC: 897F0048  lbz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A7FD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A7FD4: 409A0024  bne cr6, 0x822a7ff8
	if !ctx.cr[6].eq {
	pc = 0x822A7FF8; continue 'dispatch;
	}
	// 822A7FD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A7FDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A7FE0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A7FE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A7FE8: 4E800421  bctrl
	ctx.lr = 0x822A7FEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A7FEC: 893F0048  lbz r9, 0x48(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A7FF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A7FF4: 419A0008  beq cr6, 0x822a7ffc
	if ctx.cr[6].eq {
	pc = 0x822A7FFC; continue 'dispatch;
	}
            }
            0x822A7FF8 => {
    //   block [0x822A7FF8..0x822A7FFC)
	// 822A7FF8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x822A7FFC; continue 'dispatch;
            }
            0x822A7FFC => {
    //   block [0x822A7FFC..0x822A8040)
	// 822A7FFC: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 822A8000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A8004: 419A003C  beq cr6, 0x822a8040
	if ctx.cr[6].eq {
	pc = 0x822A8040; continue 'dispatch;
	}
	// 822A8008: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A800C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A8010: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A8014: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A8018: 4E800421  bctrl
	ctx.lr = 0x822A801C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A801C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822A8020: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822A8024: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A8028: 4859FFE1  bl 0x82848008
	ctx.lr = 0x822A802C;
	sub_82848008(ctx, base);
	// 822A802C: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 822A8030: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 822A8034: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822A8038: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A803C: 4BFFFF4C  b 0x822a7f88
	pc = 0x822A7F88; continue 'dispatch;
            }
            0x822A8040 => {
    //   block [0x822A8040..0x822A8050)
	// 822A8040: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A8044: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A8048: 409A0008  bne cr6, 0x822a8050
	if !ctx.cr[6].eq {
	pc = 0x822A8050; continue 'dispatch;
	}
	// 822A804C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A8050; continue 'dispatch;
            }
            0x822A8050 => {
    //   block [0x822A8050..0x822A8058)
	// 822A8050: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8054: 4BFFFF30  b 0x822a7f84
	pc = 0x822A7F84; continue 'dispatch;
            }
            0x822A8058 => {
    //   block [0x822A8058..0x822A806C)
	// 822A8058: 8941005C  lbz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822A805C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A8060: 419A000C  beq cr6, 0x822a806c
	if ctx.cr[6].eq {
	pc = 0x822A806C; continue 'dispatch;
	}
	// 822A8064: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822A8068: 490118ED  bl 0x832b9954
	ctx.lr = 0x822A806C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x822A806C; continue 'dispatch;
            }
            0x822A806C => {
    //   block [0x822A806C..0x822A8074)
	// 822A806C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822A8070: 48A013E4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A8078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A8078 size=2116
    let mut pc: u32 = 0x822A8078;
    'dispatch: loop {
        match pc {
            0x822A8078 => {
    //   block [0x822A8078..0x822A80BC)
	// 822A8078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A807C: 48A01379  bl 0x82ca93f4
	ctx.lr = 0x822A8080;
	sub_82CA93D0(ctx, base);
	// 822A8080: DBA1FF98  stfd f29, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[29].u64 ) };
	// 822A8084: DBC1FFA0  stfd f30, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 822A8088: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 822A808C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A8090: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822A8094: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822A8098: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 822A809C: 3B5C0004  addi r26, r28, 4
	ctx.r[26].s64 = ctx.r[28].s64 + 4;
	// 822A80A0: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 822A80A4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A80A8: C3BE0018  lfs f29, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822A80AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A80B0: 409A000C  bne cr6, 0x822a80bc
	if !ctx.cr[6].eq {
	pc = 0x822A80BC; continue 'dispatch;
	}
	// 822A80B4: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	// 822A80B8: 48000010  b 0x822a80c8
	pc = 0x822A80C8; continue 'dispatch;
            }
            0x822A80BC => {
    //   block [0x822A80BC..0x822A80C8)
	// 822A80BC: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A80C0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822A80C4: 7D381E70  srawi r24, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[24].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x822A80C8; continue 'dispatch;
            }
            0x822A80C8 => {
    //   block [0x822A80C8..0x822A80FC)
	// 822A80C8: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A80CC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A80D0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822A80D4: 419A01F8  beq cr6, 0x822a82cc
	if ctx.cr[6].eq {
	pc = 0x822A82CC; continue 'dispatch;
	}
	// 822A80D8: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A80DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A80E0: 419A01EC  beq cr6, 0x822a82cc
	if ctx.cr[6].eq {
	pc = 0x822A82CC; continue 'dispatch;
	}
	// 822A80E4: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 822A80E8: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822A80EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A80F0: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 822A80F4: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 822A80F8: 419A0020  beq cr6, 0x822a8118
	if ctx.cr[6].eq {
	pc = 0x822A8118; continue 'dispatch;
	}
	pc = 0x822A80FC; continue 'dispatch;
            }
            0x822A80FC => {
    //   block [0x822A80FC..0x822A8118)
	// 822A80FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822A8100: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A8104: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822A8108: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822A810C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822A8110: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A8114: 4082FFE8  bne 0x822a80fc
	if !ctx.cr[0].eq {
	pc = 0x822A80FC; continue 'dispatch;
	}
	pc = 0x822A8118; continue 'dispatch;
            }
            0x822A8118 => {
    //   block [0x822A8118..0x822A8160)
	// 822A8118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A811C: C03F0020  lfs f1, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822A8120: 484B8CD9  bl 0x82760df8
	ctx.lr = 0x822A8124;
	sub_82760DF8(ctx, base);
	// 822A8124: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 822A8128: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A812C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822A8130: 392A9490  addi r9, r10, -0x6b70
	ctx.r[9].s64 = ctx.r[10].s64 + -27504;
	// 822A8134: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A8138: C3E9FFF4  lfs f31, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822A813C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822A8140: FCE0F090  fmr f7, f30
	ctx.f[7].f64 = ctx.f[30].f64;
	// 822A8144: 409A001C  bne cr6, 0x822a8160
	if !ctx.cr[6].eq {
	pc = 0x822A8160; continue 'dispatch;
	}
	// 822A8148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A814C: C03E001C  lfs f1, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822A8150: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 822A8154: 484B9135  bl 0x82761288
	ctx.lr = 0x822A8158;
	sub_82761288(ctx, base);
	// 822A8158: FCE00890  fmr f7, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[7].f64 = ctx.f[1].f64;
	// 822A815C: 48000110  b 0x822a826c
	pc = 0x822A826C; continue 'dispatch;
            }
            0x822A8160 => {
    //   block [0x822A8160..0x822A81E0)
	// 822A8160: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 822A8164: 409A007C  bne cr6, 0x822a81e0
	if !ctx.cr[6].eq {
	pc = 0x822A81E0; continue 'dispatch;
	}
	// 822A8168: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822A816C: E89E0008  ld r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 822A8170: 4854A7E1  bl 0x827f2950
	ctx.lr = 0x822A8174;
	sub_827F2950(ctx, base);
	// 822A8174: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 822A8178: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 822A817C: D3E10054  stfs f31, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822A8180: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 822A8184: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822A8188: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 822A818C: C03C0030  lfs f1, 0x30(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822A8190: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 822A8194: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 822A8198: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 822A819C: C1A10070  lfs f13, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x822A81E0; continue 'dispatch;
            }
            0x822A81E0 => {
    //   block [0x822A81E0..0x822A826C)
	// 822A81E0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822A81E4: 409A007C  bne cr6, 0x822a8260
	if !ctx.cr[6].eq {
	pc = 0x822A8260; continue 'dispatch;
	}
	// 822A81E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822A81EC: E89E0008  ld r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 822A81F0: 4854A761  bl 0x827f2950
	ctx.lr = 0x822A81F4;
	sub_827F2950(ctx, base);
	// 822A81F4: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 822A81F8: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 822A81FC: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822A8200: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 822A8204: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822A8208: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 822A820C: C03C0030  lfs f1, 0x30(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822A8210: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 822A8214: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 822A8218: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 822A821C: C1A10070  lfs f13, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x822A826C; continue 'dispatch;
            }
            0x822A826C => {
    //   block [0x822A826C..0x822A82CC)
	// 822A826C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A8270: C03F0028  lfs f1, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822A8274: 4802B3D5  bl 0x822d3648
	ctx.lr = 0x822A8278;
	sub_822D3648(ctx, base);
	// 822A8278: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822A827C: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 822A8280: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8284: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A8288: 390A0E68  addi r8, r10, 0xe68
	ctx.r[8].s64 = ctx.r[10].s64 + 3688;
	// 822A828C: C00B9A80  lfs f0, -0x6580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A8290: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 822A8294: 80E90014  lwz r7, 0x14(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A8298: EDA70028  fsubs f13, f7, f0
	ctx.f[13].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 822A829C: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 822A82A0: 7CC00026  mfcr r6
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[6].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822A82A4: 54C5DF7A  rlwinm r5, r6, 0x1b, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 822A82A8: 54C4F77A  rlwinm r4, r6, 0x1e, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 822A82AC: 7CAB2378  or r11, r5, r4
	ctx.r[11].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 822A82B0: 7D885C2E  lfsx f12, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822A82B4: FC2C382E  fsel f1, f12, f0, f7
	ctx.f[1].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[7].f64 };
	// 822A82B8: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 822A82BC: 4E800421  bctrl
	ctx.lr = 0x822A82C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A82C0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 822A82C4: 4BF0F855  bl 0x821b7b18
	ctx.lr = 0x822A82C8;
	sub_821B7B18(ctx, base);
	// 822A82C8: 480004B0  b 0x822a8778
	pc = 0x822A8778; continue 'dispatch;
            }
            0x822A82CC => {
    //   block [0x822A82CC..0x822A88BC)
	// 822A82CC: 894B0030  lbz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822A82D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A82D4: 409A0010  bne cr6, 0x822a82e4
	if !ctx.cr[6].eq {
	pc = 0x822A82E4; continue 'dispatch;
	}
	// 822A82D8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A82DC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822A82E0: 409A009C  bne cr6, 0x822a837c
	if !ctx.cr[6].eq {
	pc = 0x822A837C; continue 'dispatch;
	}
	// 822A82E4: 807C0014  lwz r3, 0x14(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A82E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822A82EC: 419A0090  beq cr6, 0x822a837c
	if ctx.cr[6].eq {
	pc = 0x822A837C; continue 'dispatch;
	}
	// 822A82F0: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822A82F4: 4802B355  bl 0x822d3648
	ctx.lr = 0x822A82F8;
	sub_822D3648(ctx, base);
	// 822A82F8: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A82FC: 807C0014  lwz r3, 0x14(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A8300: 894B0030  lbz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822A8304: C0030020  lfs f0, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A8308: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 822A830C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A8310: 419A0054  beq cr6, 0x822a8364
	if ctx.cr[6].eq {
	pc = 0x822A8364; continue 'dispatch;
	}
	// 822A8314: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 822A8318: 4099004C  ble cr6, 0x822a8364
	if !ctx.cr[6].gt {
	pc = 0x822A8364; continue 'dispatch;
	}
	// 822A831C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822A8320: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822A8324: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 822A8328: 390A9490  addi r8, r10, -0x6b70
	ctx.r[8].s64 = ctx.r[10].s64 + -27504;
	// 822A832C: 38E90E68  addi r7, r9, 0xe68
	ctx.r[7].s64 = ctx.r[9].s64 + 3688;
	// 822A8330: C1AB9A80  lfs f13, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822A8334: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822A8338: ED816828  fsubs f12, f1, f13
	ctx.f[12].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 822A833C: 98DC0029  stb r6, 0x29(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(41 as u32), ctx.r[6].u8 ) };
	// 822A8340: C1A8FFF4  lfs f13, -0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822A8344: ED606028  fsubs f11, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 822A8348: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 822A834C: 7CA00026  mfcr r5
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[5].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822A8350: 54A4DF7A  rlwinm r4, r5, 0x1b, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 822A8354: 54ABF77A  rlwinm r11, r5, 0x1e, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x00000003u64;
	// 822A8358: 7C8A5B78  or r10, r4, r11
	ctx.r[10].u64 = ctx.r[4].u64 | ctx.r[11].u64;
	// 822A835C: 7D47542E  lfsx f10, r7, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822A8360: FC0A032E  fsel f0, f10, f12, f0
	ctx.f[0].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 822A8364: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8368: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 822A836C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A8370: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A8374: 4E800421  bctrl
	ctx.lr = 0x822A8378;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A8378: 48000400  b 0x822a8778
	pc = 0x822A8778; continue 'dispatch;
	// 822A837C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 822A8380: 419A03F8  beq cr6, 0x822a8778
	if ctx.cr[6].eq {
	pc = 0x822A8778; continue 'dispatch;
	}
	// 822A8384: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822A8388: 92E10070  stw r23, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[23].u32 ) };
	// 822A838C: 92E10074  stw r23, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[23].u32 ) };
	// 822A8390: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 822A8394: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 822A8398: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 822A839C: 92E1005C  stw r23, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[23].u32 ) };
	// 822A83A0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822A83A4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822A83A8: C3EB9490  lfs f31, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822A83AC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 822A83B0: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822A83B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822A83B8: 4854F449  bl 0x827f7800
	ctx.lr = 0x822A83BC;
	sub_827F7800(ctx, base);
	// 822A83BC: 83C10070  lwz r30, 0x70(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 822A83C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822A83C4: 419A03A4  beq cr6, 0x822a8768
	if ctx.cr[6].eq {
	pc = 0x822A8768; continue 'dispatch;
	}
	// 822A83C8: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822A83CC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822A83D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822A83D4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A83D8: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822A83DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A83E0: 4E800421  bctrl
	ctx.lr = 0x822A83E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A83E4: 809C0014  lwz r4, 0x14(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A83E8: 3B3C0014  addi r25, r28, 0x14
	ctx.r[25].s64 = ctx.r[28].s64 + 20;
	// 822A83EC: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822A83F0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822A83F4: 419A001C  beq cr6, 0x822a8410
	if ctx.cr[6].eq {
	pc = 0x822A8410; continue 'dispatch;
	}
	// 822A83F8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A83FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822A8400: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822A8404: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A8408: 4E800421  bctrl
	ctx.lr = 0x822A840C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A840C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8410: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 822A8414: 892AEB8D  lbz r9, -0x1473(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-5235 as u32) ) } as u64;
	// 822A8418: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A841C: 419A0258  beq cr6, 0x822a8674
	if ctx.cr[6].eq {
	pc = 0x822A8674; continue 'dispatch;
	}
	// 822A8420: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 822A8424: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A8428: 419A024C  beq cr6, 0x822a8674
	if ctx.cr[6].eq {
	pc = 0x822A8674; continue 'dispatch;
	}
	// 822A842C: 817B0024  lwz r11, 0x24(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 822A8430: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 822A8434: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 822A8438: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A843C: 419A00D8  beq cr6, 0x822a8514
	if ctx.cr[6].eq {
	pc = 0x822A8514; continue 'dispatch;
	}
	// 822A8440: 817B008C  lwz r11, 0x8c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A8444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A8448: 419A001C  beq cr6, 0x822a8464
	if ctx.cr[6].eq {
	pc = 0x822A8464; continue 'dispatch;
	}
	// 822A844C: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 822A8450: 817B0048  lwz r11, 0x48(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A8454: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822A8458: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822A845C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A8460: 480000B0  b 0x822a8510
	pc = 0x822A8510; continue 'dispatch;
	// 822A8464: 815B0048  lwz r10, 0x48(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A8468: 80DB004C  lwz r6, 0x4c(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A846C: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 822A8470: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A8474: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822A8478: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A847C: 40810054  ble 0x822a84d0
	if !ctx.cr[0].gt {
	pc = 0x822A84D0; continue 'dispatch;
	}
	// 822A8480: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A8484: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A8488: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822A848C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8490: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 822A8494: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822A8498: 41980008  blt cr6, 0x822a84a0
	if ctx.cr[6].lt {
	pc = 0x822A84A0; continue 'dispatch;
	}
	// 822A849C: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 822A84A0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A84A4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A84A8: 419A0014  beq cr6, 0x822a84bc
	if ctx.cr[6].eq {
	pc = 0x822A84BC; continue 'dispatch;
	}
	// 822A84AC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A84B0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A84B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A84B8: 4800000C  b 0x822a84c4
	pc = 0x822A84C4; continue 'dispatch;
	// 822A84BC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A84C0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 822A84C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A84C8: 4199FFB8  bgt cr6, 0x822a8480
	if ctx.cr[6].gt {
	pc = 0x822A8480; continue 'dispatch;
	}
	// 822A84CC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822A84D0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A84D4: 419A0034  beq cr6, 0x822a8508
	if ctx.cr[6].eq {
	pc = 0x822A8508; continue 'dispatch;
	}
	// 822A84D8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A84DC: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 822A84E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A84E4: 41990008  bgt cr6, 0x822a84ec
	if ctx.cr[6].gt {
	pc = 0x822A84EC; continue 'dispatch;
	}
	// 822A84E8: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822A84EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A84F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A84F4: 409A0014  bne cr6, 0x822a8508
	if !ctx.cr[6].eq {
	pc = 0x822A8508; continue 'dispatch;
	}
	// 822A84F8: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822A84FC: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 822A8500: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 822A8504: 48000008  b 0x822a850c
	pc = 0x822A850C; continue 'dispatch;
	// 822A8508: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A850C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A8510: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822A8514: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8518: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822A851C: 419A0010  beq cr6, 0x822a852c
	if ctx.cr[6].eq {
	pc = 0x822A852C; continue 'dispatch;
	}
	// 822A8520: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822A8524: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A8528: 48005AF9  bl 0x822ae020
	ctx.lr = 0x822A852C;
	sub_822AE020(ctx, base);
	// 822A852C: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A8530: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822A8534: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 822A8538: C1AB0028  lfs f13, 0x28(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822A853C: C00A9A80  lfs f0, -0x6580(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A8540: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822A8544: 4099003C  ble cr6, 0x822a8580
	if !ctx.cr[6].gt {
	pc = 0x822A8580; continue 'dispatch;
	}
	// 822A8548: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822A854C: 894B6D44  lbz r10, 0x6d44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27972 as u32) ) } as u64;
	// 822A8550: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A8554: 409A002C  bne cr6, 0x822a8580
	if !ctx.cr[6].eq {
	pc = 0x822A8580; continue 'dispatch;
	}
	// 822A8558: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 822A855C: 4BF76CFD  bl 0x8221f258
	ctx.lr = 0x822A8560;
	sub_8221F258(ctx, base);
	// 822A8560: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822A8564: 419A0018  beq cr6, 0x822a857c
	if ctx.cr[6].eq {
	pc = 0x822A857C; continue 'dispatch;
	}
	// 822A8568: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A856C: C02B0028  lfs f1, 0x28(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822A8570: 4BFE35D1  bl 0x8228bb40
	ctx.lr = 0x822A8574;
	sub_8228BB40(ctx, base);
	// 822A8574: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 822A8578: 48000008  b 0x822a8580
	pc = 0x822A8580; continue 'dispatch;
	// 822A857C: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 822A8580: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822A8584: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 822A8588: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822A858C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822A8590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A8594: 4BF25BAD  bl 0x821ce140
	ctx.lr = 0x822A8598;
	sub_821CE140(ctx, base);
	// 822A8598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A859C: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A85A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A85A4: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822A85A8: 419A0078  beq cr6, 0x822a8620
	if ctx.cr[6].eq {
	pc = 0x822A8620; continue 'dispatch;
	}
	// 822A85AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822A85B0: 419A0040  beq cr6, 0x822a85f0
	if ctx.cr[6].eq {
	pc = 0x822A85F0; continue 'dispatch;
	}
	// 822A85B4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 822A85B8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 822A85BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A85C0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 822A85C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A85C8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822A85CC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A85D0: 4082FFE8  bne 0x822a85b8
	if !ctx.cr[0].eq {
	pc = 0x822A85B8; continue 'dispatch;
	}
	// 822A85D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A85D8: 409A0014  bne cr6, 0x822a85ec
	if !ctx.cr[6].eq {
	pc = 0x822A85EC; continue 'dispatch;
	}
	// 822A85DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A85E0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A85E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A85E8: 4E800421  bctrl
	ctx.lr = 0x822A85EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A85EC: 92FC0000  stw r23, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 822A85F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A85F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A85F8: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822A85FC: 419A0024  beq cr6, 0x822a8620
	if ctx.cr[6].eq {
	pc = 0x822A8620; continue 'dispatch;
	}
	// 822A8600: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822A8604: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822A8608: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A860C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822A8610: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822A8614: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822A8618: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A861C: 4082FFE8  bne 0x822a8604
	if !ctx.cr[0].eq {
	pc = 0x822A8604; continue 'dispatch;
	}
	// 822A8620: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A8624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A8628: 419A0070  beq cr6, 0x822a8698
	if ctx.cr[6].eq {
	pc = 0x822A8698; continue 'dispatch;
	}
	// 822A862C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822A8630: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 822A8634: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822A8638: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A863C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822A8640: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822A8644: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822A8648: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A864C: 4082FFE8  bne 0x822a8634
	if !ctx.cr[0].eq {
	pc = 0x822A8634; continue 'dispatch;
	}
	// 822A8650: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 822A8654: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A8658: 409A0014  bne cr6, 0x822a866c
	if !ctx.cr[6].eq {
	pc = 0x822A866C; continue 'dispatch;
	}
	// 822A865C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8660: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A8664: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A8668: 4E800421  bctrl
	ctx.lr = 0x822A866C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A866C: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 822A8670: 48000028  b 0x822a8698
	pc = 0x822A8698; continue 'dispatch;
	// 822A8674: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8678: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822A867C: 419A001C  beq cr6, 0x822a8698
	if ctx.cr[6].eq {
	pc = 0x822A8698; continue 'dispatch;
	}
	// 822A8680: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822A8684: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822A8688: 4BFB74D9  bl 0x8225fb60
	ctx.lr = 0x822A868C;
	sub_8225FB60(ctx, base);
	// 822A868C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822A8690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A8694: 482BA545  bl 0x82562bd8
	ctx.lr = 0x822A8698;
	sub_82562BD8(ctx, base);
	// 822A8698: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822A869C: C03D0028  lfs f1, 0x28(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822A86A0: 4802AFA9  bl 0x822d3648
	ctx.lr = 0x822A86A4;
	sub_822D3648(ctx, base);
	// 822A86A4: C3C10054  lfs f30, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822A86A8: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 822A86AC: EFFF0824  fdivs f31, f31, f1
	ctx.f[31].f64 = ((ctx.f[31].f64 / ctx.f[1].f64) as f32) as f64;
	// 822A86B0: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 822A86B4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A86B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A86BC: 419A0018  beq cr6, 0x822a86d4
	if ctx.cr[6].eq {
	pc = 0x822A86D4; continue 'dispatch;
	}
	// 822A86C0: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A86C4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822A86C8: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 822A86CC: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822A86D0: 41980008  blt cr6, 0x822a86d8
	if ctx.cr[6].lt {
	pc = 0x822A86D8; continue 'dispatch;
	}
	// 822A86D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 822A86D8: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 822A86DC: 7FFE582E  lwzx r31, r30, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822A86E0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A86E4: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 822A86E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A86EC: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 822A86F0: 419A0020  beq cr6, 0x822a8710
	if ctx.cr[6].eq {
	pc = 0x822A8710; continue 'dispatch;
	}
	// 822A86F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822A86F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A86FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822A8700: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822A8704: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822A8708: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822A870C: 4082FFE8  bne 0x822a86f4
	if !ctx.cr[0].eq {
	pc = 0x822A86F4; continue 'dispatch;
	}
	// 822A8710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A8714: C03F0028  lfs f1, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822A8718: 4802AF31  bl 0x822d3648
	ctx.lr = 0x822A871C;
	sub_822D3648(ctx, base);
	// 822A871C: EC0107F2  fmuls f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 822A8720: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8724: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822A8728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A872C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A8730: ED8007B2  fmuls f12, f0, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 822A8734: ED6C0772  fmuls f11, f12, f29
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[29].f64) as f32) as f64);
	// 822A8738: EC2D582A  fadds f1, f13, f11
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 822A873C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A8740: 4E800421  bctrl
	ctx.lr = 0x822A8744;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A8744: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 822A8748: 4BF0F3D1  bl 0x821b7b18
	ctx.lr = 0x822A874C;
	sub_821B7B18(ctx, base);
	// 822A874C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822A8750: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 822A8754: 7F1DC040  cmplw cr6, r29, r24
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[24].u32, &mut ctx.xer);
	// 822A8758: 409AFF5C  bne cr6, 0x822a86b4
	if !ctx.cr[6].eq {
	pc = 0x822A86B4; continue 'dispatch;
	}
	// 822A875C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 822A8760: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822A8764: 4BED2C35  bl 0x8217b398
	ctx.lr = 0x822A8768;
	sub_8217B398(ctx, base);
	// 822A8768: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822A876C: 4BF0F3AD  bl 0x821b7b18
	ctx.lr = 0x822A8770;
	sub_821B7B18(ctx, base);
	// 822A8770: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822A8774: 4BF0F3A5  bl 0x821b7b18
	ctx.lr = 0x822A8778;
	sub_821B7B18(ctx, base);
	// 822A8778: 897C0028  lbz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 822A877C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A8780: 419A0128  beq cr6, 0x822a88a8
	if ctx.cr[6].eq {
	pc = 0x822A88A8; continue 'dispatch;
	}
	// 822A8784: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A8788: 894B0033  lbz r10, 0x33(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(51 as u32) ) } as u64;
	// 822A878C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A8790: 409A0118  bne cr6, 0x822a88a8
	if !ctx.cr[6].eq {
	pc = 0x822A88A8; continue 'dispatch;
	}
	// 822A8794: 815B0028  lwz r10, 0x28(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 822A8798: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822A879C: 5549A7FE  rlwinm r9, r10, 0x14, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000FFFu64;
	// 822A87A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A87A4: 419A00E8  beq cr6, 0x822a888c
	if ctx.cr[6].eq {
	pc = 0x822A888C; continue 'dispatch;
	}
	// 822A87A8: 817B008C  lwz r11, 0x8c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A87AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A87B0: 419A0020  beq cr6, 0x822a87d0
	if ctx.cr[6].eq {
	pc = 0x822A87D0; continue 'dispatch;
	}
	// 822A87B4: 894B002C  lbz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822A87B8: 817B0048  lwz r11, 0x48(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A87BC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822A87C0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822A87C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A87C8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A87CC: 480000C4  b 0x822a8890
	pc = 0x822A8890; continue 'dispatch;
	// 822A87D0: 815B0048  lwz r10, 0x48(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A87D4: 80DB004C  lwz r6, 0x4c(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A87D8: 92E10070  stw r23, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[23].u32 ) };
	// 822A87DC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A87E0: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 822A87E4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A87E8: 40810054  ble 0x822a883c
	if !ctx.cr[0].gt {
	pc = 0x822A883C; continue 'dispatch;
	}
	// 822A87EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A87F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A87F4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822A87F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A87FC: 2F07002C  cmpwi cr6, r7, 0x2c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 44, &mut ctx.xer);
	// 822A8800: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822A8804: 41980008  blt cr6, 0x822a880c
	if ctx.cr[6].lt {
	pc = 0x822A880C; continue 'dispatch;
	}
	// 822A8808: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 822A880C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A8810: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A8814: 419A0014  beq cr6, 0x822a8828
	if ctx.cr[6].eq {
	pc = 0x822A8828; continue 'dispatch;
	}
	// 822A8818: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A881C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A8820: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A8824: 4800000C  b 0x822a8830
	pc = 0x822A8830; continue 'dispatch;
	// 822A8828: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A882C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 822A8830: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A8834: 4199FFB8  bgt cr6, 0x822a87ec
	if ctx.cr[6].gt {
	pc = 0x822A87EC; continue 'dispatch;
	}
	// 822A8838: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 822A883C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A8840: 419A003C  beq cr6, 0x822a887c
	if ctx.cr[6].eq {
	pc = 0x822A887C; continue 'dispatch;
	}
	// 822A8844: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8848: 2F0B002C  cmpwi cr6, r11, 0x2c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 44, &mut ctx.xer);
	// 822A884C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A8850: 41990008  bgt cr6, 0x822a8858
	if ctx.cr[6].gt {
	pc = 0x822A8858; continue 'dispatch;
	}
	// 822A8854: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822A8858: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A885C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A8860: 409A001C  bne cr6, 0x822a887c
	if !ctx.cr[6].eq {
	pc = 0x822A887C; continue 'dispatch;
	}
	// 822A8864: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 822A8868: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A886C: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 822A8870: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 822A8874: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A8878: 48000018  b 0x822a8890
	pc = 0x822A8890; continue 'dispatch;
	// 822A887C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A8880: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A8884: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A8888: 48000008  b 0x822a8890
	pc = 0x822A8890; continue 'dispatch;
	// 822A888C: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 822A8890: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822A8894: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A8898: 419A0010  beq cr6, 0x822a88a8
	if ctx.cr[6].eq {
	pc = 0x822A88A8; continue 'dispatch;
	}
	// 822A889C: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 822A88A0: 6149000F  ori r9, r10, 0xf
	ctx.r[9].u64 = ctx.r[10].u64 | 15;
	// 822A88A4: 912B0064  stw r9, 0x64(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 822A88A8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 822A88AC: CBA1FF98  lfd f29, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 822A88B0: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 822A88B4: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 822A88B8: 48A00B8C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A88C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A88C0 size=256
    let mut pc: u32 = 0x822A88C0;
    'dispatch: loop {
        match pc {
            0x822A88C0 => {
    //   block [0x822A88C0..0x822A89A4)
	// 822A88C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A88C4: 48A00B49  bl 0x82ca940c
	ctx.lr = 0x822A88C8;
	sub_82CA93D0(ctx, base);
	// 822A88C8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A88CC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822A88D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A88D4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822A88D8: 388B8D14  addi r4, r11, -0x72ec
	ctx.r[4].s64 = ctx.r[11].s64 + -29420;
	// 822A88DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822A88E0: 4BF57E91  bl 0x82200770
	ctx.lr = 0x822A88E4;
	sub_82200770(ctx, base);
	// 822A88E4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 822A88E8: 813F0050  lwz r9, 0x50(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A88EC: 83CA9650  lwz r30, -0x69b0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822A88F0: 7F1E4800  cmpw cr6, r30, r9
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[9].s32, &mut ctx.xer);
	// 822A88F4: 419800B0  blt cr6, 0x822a89a4
	if ctx.cr[6].lt {
	pc = 0x822A89A4; continue 'dispatch;
	}
	// 822A88F8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822A88FC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 822A8900: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822A8904: 3BAA7978  addi r29, r10, 0x7978
	ctx.r[29].s64 = ctx.r[10].s64 + 31096;
	// 822A8908: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822A890C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A8910: 81090078  lwz r8, 0x78(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(120 as u32) ) } as u64;
	// 822A8914: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A8918: 80870000  lwz r4, 0(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A891C: 48125CA5  bl 0x823ce5c0
	ctx.lr = 0x822A8920;
	sub_823CE5C0(ctx, base);
	// 822A8920: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822A8924: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A8928: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822A892C: 481257E5  bl 0x823ce110
	ctx.lr = 0x822A8930;
	sub_823CE110(ctx, base);
	// 822A8930: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822A8934: 4BF0F1E5  bl 0x821b7b18
	ctx.lr = 0x822A8938;
	sub_821B7B18(ctx, base);
	// 822A8938: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 822A893C: 3CA0820C  lis r5, -0x7df4
	ctx.r[5].s64 = -2113142784;
	// 822A8940: 38C6798C  addi r6, r6, 0x798c
	ctx.r[6].s64 = ctx.r[6].s64 + 31116;
	// 822A8944: 38A579BC  addi r5, r5, 0x79bc
	ctx.r[5].s64 = ctx.r[5].s64 + 31164;
	// 822A8948: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822A894C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822A8950: 481BAA51  bl 0x824633a0
	ctx.lr = 0x822A8954;
	sub_824633A0(ctx, base);
	// 822A8954: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822A8958: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822A895C: 483061C5  bl 0x825aeb20
	ctx.lr = 0x822A8960;
	sub_825AEB20(ctx, base);
	// 822A8960: 7FC407B4  extsw r4, r30
	ctx.r[4].s64 = ctx.r[30].s32 as i64;
	// 822A8964: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822A8968: 987F004B  stb r3, 0x4b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(75 as u32), ctx.r[3].u8 ) };
	// 822A896C: F8810068  std r4, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[4].u64 ) };
	// 822A8970: C8010068  lfd f0, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 822A8974: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 822A8978: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 822A897C: C80B9660  lfd f0, -0x69a0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 822A8980: FD8D002A  fadd f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 + ctx.f[0].f64;
	// 822A8984: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 822A8988: 39800050  li r12, 0x50
	ctx.r[12].s64 = 80;
	// 822A898C: 7D7F67AE  stfiwx f11, r31, r12
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[12].u32), tmp.u32) };
	// 822A8990: 4BF6C449  bl 0x82214dd8
	ctx.lr = 0x822A8994;
	sub_82214DD8(ctx, base);
	// 822A8994: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822A8998: 4BF0F181  bl 0x821b7b18
	ctx.lr = 0x822A899C;
	sub_821B7B18(ctx, base);
	// 822A899C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A89A0: 4BF0F179  bl 0x821b7b18
	ctx.lr = 0x822A89A4;
	sub_821B7B18(ctx, base);
	pc = 0x822A89A4; continue 'dispatch;
            }
            0x822A89A4 => {
    //   block [0x822A89A4..0x822A89B8)
	// 822A89A4: 8941005C  lbz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822A89A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A89AC: 419A000C  beq cr6, 0x822a89b8
	if ctx.cr[6].eq {
	pc = 0x822A89B8; continue 'dispatch;
	}
	// 822A89B0: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822A89B4: 49010FA1  bl 0x832b9954
	ctx.lr = 0x822A89B8;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x822A89B8; continue 'dispatch;
            }
            0x822A89B8 => {
    //   block [0x822A89B8..0x822A89C0)
	// 822A89B8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822A89BC: 48A00AA0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A89C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A89C0 size=120
    let mut pc: u32 = 0x822A89C0;
    'dispatch: loop {
        match pc {
            0x822A89C0 => {
    //   block [0x822A89C0..0x822A89F8)
	// 822A89C0: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 822A89C4: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 822A89C8: 392B1B00  addi r9, r11, 0x1b00
	ctx.r[9].s64 = ctx.r[11].s64 + 6912;
	// 822A89CC: 816A1B10  lwz r11, 0x1b10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6928 as u32) ) } as u64;
	// 822A89D0: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822A89D4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822A89D8: 409A0020  bne cr6, 0x822a89f8
	if !ctx.cr[6].eq {
	pc = 0x822A89F8; continue 'dispatch;
	}
	// 822A89DC: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 822A89E0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 822A89E4: 38E8B2B0  addi r7, r8, -0x4d50
	ctx.r[7].s64 = ctx.r[8].s64 + -19792;
	// 822A89E8: 916A1B10  stw r11, 0x1b10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6928 as u32), ctx.r[11].u32 ) };
	pc = 0x822A89F8; continue 'dispatch;
            }
            0x822A89F8 => {
    //   block [0x822A89F8..0x822A8A38)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A8A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A8A38 size=196
    let mut pc: u32 = 0x822A8A38;
    'dispatch: loop {
        match pc {
            0x822A8A38 => {
    //   block [0x822A8A38..0x822A8A88)
	// 822A8A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A8A3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A8A40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A8A44: 3D00834C  lis r8, -0x7cb4
	ctx.r[8].s64 = -2092171264;
	// 822A8A48: 546B083C  slwi r11, r3, 1
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822A8A4C: 38E8DED4  addi r7, r8, -0x212c
	ctx.r[7].s64 = ctx.r[8].s64 + -8492;
	// 822A8A50: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 822A8A54: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 822A8A58: 7CC35A14  add r6, r3, r11
	ctx.r[6].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 822A8A5C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 822A8A60: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A8A64: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822A8A68: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822A8A6C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A8A70: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8A74: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822A8A78: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822A8A7C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822A8A80: 41980008  blt cr6, 0x822a8a88
	if ctx.cr[6].lt {
	pc = 0x822A8A88; continue 'dispatch;
	}
	// 822A8A84: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	pc = 0x822A8A88; continue 'dispatch;
            }
            0x822A8A88 => {
    //   block [0x822A8A88..0x822A8AEC)
	// 822A8A88: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8A8C: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 822A8A90: 4198005C  blt cr6, 0x822a8aec
	if ctx.cr[6].lt {
	pc = 0x822A8AEC; continue 'dispatch;
	}
	// 822A8A94: 7C8B1670  srawi r11, r4, 2
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 2) as i64;
	// 822A8A98: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A8A9C: 7D0B0194  addze r8, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[8].s64 = tmp.s64;
	// 822A8AA0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 822A8AA4: 794BFFE6  rldicr r11, r10, 0x3f, 0x3f
	ctx.r[11].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 822A8AA8: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 822A8AAC: 7D633C36  srd r3, r11, r7
	if (ctx.r[7].u8 & 0x40) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = (ctx.r[11].u64) >> ((ctx.r[7].u8 & 0x3F) as u32);
	}
	// 822A8AB0: E9491760  ld r10, 0x1760(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(5984 as u32) ) };
	// 822A8AB4: 7C6A5038  and r10, r3, r10
	ctx.r[10].u64 = ctx.r[3].u64 & ctx.r[10].u64;
	// 822A8AB8: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 822A8ABC: 419A0030  beq cr6, 0x822a8aec
	if ctx.cr[6].eq {
	pc = 0x822A8AEC; continue 'dispatch;
	}
	// 822A8AC0: 7D462214  add r10, r6, r4
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[4].u64;
	// 822A8AC4: 5489F0BE  srwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822A8AC8: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 822A8ACC: 3CE08336  lis r7, -0x7cca
	ctx.r[7].s64 = -2093613056;
	// 822A8AD0: 5503F0BE  srwi r3, r8, 2
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shr(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 822A8AD4: 7D491850  subf r10, r9, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[9].s64;
	// 822A8AD8: 79480020  clrldi r8, r10, 0x20
	ctx.r[8].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 822A8ADC: 80670364  lwz r3, 0x364(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(868 as u32) ) } as u64;
	// 822A8AE0: 7D674634  srad r7, r11, r8
	tmp.u64 = (ctx.r[8].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[11].s64 < 0) && ((ctx.r[11].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[7].s64 = ctx.r[11].s64 >> tmp.u64;
	// 822A8AE4: 7CE74C36  srd r7, r7, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[7].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 822A8AE8: 4BF71D99  bl 0x8221a880
	ctx.lr = 0x822A8AEC;
	sub_8221A880(ctx, base);
	pc = 0x822A8AEC; continue 'dispatch;
            }
            0x822A8AEC => {
    //   block [0x822A8AEC..0x822A8AFC)
	// 822A8AEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822A8AF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A8AF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A8AF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A8B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A8B00 size=332
    let mut pc: u32 = 0x822A8B00;
    'dispatch: loop {
        match pc {
            0x822A8B00 => {
    //   block [0x822A8B00..0x822A8C4C)
	// 822A8B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A8B04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A8B08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A8B0C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 822A8B10: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A8C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A8C50 size=440
    let mut pc: u32 = 0x822A8C50;
    'dispatch: loop {
        match pc {
            0x822A8C50 => {
    //   block [0x822A8C50..0x822A8CF8)
	// 822A8C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A8C54: 48A007B1  bl 0x82ca9404
	ctx.lr = 0x822A8C58;
	sub_82CA93D0(ctx, base);
	// 822A8C58: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A8C5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822A8C60: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822A8C64: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822A8C68: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8C6C: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 822A8C70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A8C74: 4E800421  bctrl
	ctx.lr = 0x822A8C78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A8C78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A8C7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822A8C80: 419A0180  beq cr6, 0x822a8e00
	if ctx.cr[6].eq {
	pc = 0x822A8E00; continue 'dispatch;
	}
	// 822A8C84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822A8C88: 48021E71  bl 0x822caaf8
	ctx.lr = 0x822A8C8C;
	sub_822CAAF8(ctx, base);
	// 822A8C8C: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 822A8C90: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822A8C94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A8C98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A8C9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8CA0: 419A0058  beq cr6, 0x822a8cf8
	if ctx.cr[6].eq {
	pc = 0x822A8CF8; continue 'dispatch;
	}
	// 822A8CA4: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A8CA8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A8CAC: 4E800421  bctrl
	ctx.lr = 0x822A8CB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A8CB0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 822A8CB4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822A8CB8: 38E90B7C  addi r7, r9, 0xb7c
	ctx.r[7].s64 = ctx.r[9].s64 + 2940;
	// 822A8CBC: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 822A8CC0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822A8CC4: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 822A8CC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A8CCC: 4BF6BBCD  bl 0x82214898
	ctx.lr = 0x822A8CD0;
	sub_82214898(ctx, base);
	// 822A8CD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822A8CD4: 387E0038  addi r3, r30, 0x38
	ctx.r[3].s64 = ctx.r[30].s64 + 56;
	// 822A8CD8: 48000131  bl 0x822a8e08
	ctx.lr = 0x822A8CDC;
	sub_822A8E08(ctx, base);
	// 822A8CDC: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 822A8CE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A8CE4: 38A60B7C  addi r5, r6, 0xb7c
	ctx.r[5].s64 = ctx.r[6].s64 + 2940;
	// 822A8CE8: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 822A8CEC: 4BEEB14D  bl 0x82193e38
	ctx.lr = 0x822A8CF0;
	sub_82193E38(ctx, base);
	// 822A8CF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822A8CF4: 48A00760  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x822A8CF8 => {
    //   block [0x822A8CF8..0x822A8D3C)
	// 822A8CF8: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A8CFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A8D00: 4E800421  bctrl
	ctx.lr = 0x822A8D04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A8D04: 813E003C  lwz r9, 0x3c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 822A8D08: 3BFE0038  addi r31, r30, 0x38
	ctx.r[31].s64 = ctx.r[30].s64 + 56;
	// 822A8D0C: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 822A8D10: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822A8D14: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 822A8D18: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 822A8D1C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8D20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822A8D24: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A8D28: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 822A8D2C: E8E10058  ld r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822A8D30: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 822A8D34: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822A8D38: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
            }
            0x822A8D3C => {
    //   block [0x822A8D3C..0x822A8D68)
	// 822A8D3C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822A8D40: 419A0040  beq cr6, 0x822a8d80
	if ctx.cr[6].eq {
	pc = 0x822A8D80; continue 'dispatch;
	}
	// 822A8D44: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A8D48: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 822A8D4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A8D50: 419A001C  beq cr6, 0x822a8d6c
	if ctx.cr[6].eq {
	pc = 0x822A8D6C; continue 'dispatch;
	}
	// 822A8D54: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8D58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A8D5C: 419A000C  beq cr6, 0x822a8d68
	if ctx.cr[6].eq {
	pc = 0x822A8D68; continue 'dispatch;
	}
	// 822A8D60: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822A8D64: 4800000C  b 0x822a8d70
	pc = 0x822A8D70; continue 'dispatch;
            }
            0x822A8D68 => {
    //   block [0x822A8D68..0x822A8D6C)
	// 822A8D68: 4BEEB0D1  bl 0x82193e38
	ctx.lr = 0x822A8D6C;
	sub_82193E38(ctx, base);
	pc = 0x822A8D6C; continue 'dispatch;
            }
            0x822A8D6C => {
    //   block [0x822A8D6C..0x822A8D70)
	// 822A8D6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822A8D70; continue 'dispatch;
            }
            0x822A8D70 => {
    //   block [0x822A8D70..0x822A8D80)
	// 822A8D70: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 822A8D74: 419A000C  beq cr6, 0x822a8d80
	if ctx.cr[6].eq {
	pc = 0x822A8D80; continue 'dispatch;
	}
	// 822A8D78: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8D7C: 4BFFFFC0  b 0x822a8d3c
	pc = 0x822A8D3C; continue 'dispatch;
            }
            0x822A8D80 => {
    //   block [0x822A8D80..0x822A8D90)
	// 822A8D80: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822A8D84: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A8D88: 419A0008  beq cr6, 0x822a8d90
	if ctx.cr[6].eq {
	pc = 0x822A8D90; continue 'dispatch;
	}
	// 822A8D8C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A8D90; continue 'dispatch;
            }
            0x822A8D90 => {
    //   block [0x822A8D90..0x822A8DA4)
	// 822A8D90: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A8D94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A8D98: 419A000C  beq cr6, 0x822a8da4
	if ctx.cr[6].eq {
	pc = 0x822A8DA4; continue 'dispatch;
	}
	// 822A8D9C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822A8DA0: 419A0008  beq cr6, 0x822a8da8
	if ctx.cr[6].eq {
	pc = 0x822A8DA8; continue 'dispatch;
	}
	pc = 0x822A8DA4; continue 'dispatch;
            }
            0x822A8DA4 => {
    //   block [0x822A8DA4..0x822A8DA8)
	// 822A8DA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A8DA8; continue 'dispatch;
            }
            0x822A8DA8 => {
    //   block [0x822A8DA8..0x822A8E00)
	// 822A8DA8: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822A8DAC: 409A0054  bne cr6, 0x822a8e00
	if !ctx.cr[6].eq {
	pc = 0x822A8E00; continue 'dispatch;
	}
	// 822A8DB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822A8DB4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822A8DB8: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 822A8DBC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822A8DC0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822A8DC4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 822A8DC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A8DCC: 4BF6BACD  bl 0x82214898
	ctx.lr = 0x822A8DD0;
	sub_82214898(ctx, base);
	// 822A8DD0: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A8DD4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822A8DD8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 822A8DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A8DE0: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 822A8DE4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822A8DE8: 481AD331  bl 0x82456118
	ctx.lr = 0x822A8DEC;
	sub_82456118(ctx, base);
	// 822A8DEC: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 822A8DF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A8DF4: 38C70B7C  addi r6, r7, 0xb7c
	ctx.r[6].s64 = ctx.r[7].s64 + 2940;
	// 822A8DF8: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 822A8DFC: 4BEEB03D  bl 0x82193e38
	ctx.lr = 0x822A8E00;
	sub_82193E38(ctx, base);
	pc = 0x822A8E00; continue 'dispatch;
            }
            0x822A8E00 => {
    //   block [0x822A8E00..0x822A8E08)
	// 822A8E00: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822A8E04: 48A00650  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A8E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A8E08 size=212
    let mut pc: u32 = 0x822A8E08;
    'dispatch: loop {
        match pc {
            0x822A8E08 => {
    //   block [0x822A8E08..0x822A8E30)
	// 822A8E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A8E0C: 48A005FD  bl 0x82ca9408
	ctx.lr = 0x822A8E10;
	sub_82CA93D0(ctx, base);
	// 822A8E10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A8E14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822A8E18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822A8E1C: 4BEEDF55  bl 0x82196d70
	ctx.lr = 0x822A8E20;
	sub_82196D70(ctx, base);
	// 822A8E20: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 822A8E24: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 822A8E28: 839D0004  lwz r28, 4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A8E2C: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822A8E30; continue 'dispatch;
            }
            0x822A8E30 => {
    //   block [0x822A8E30..0x822A8E34)
	// 822A8E30: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	pc = 0x822A8E34; continue 'dispatch;
            }
            0x822A8E34 => {
    //   block [0x822A8E34..0x822A8E44)
	// 822A8E34: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822A8E38: 419A000C  beq cr6, 0x822a8e44
	if ctx.cr[6].eq {
	pc = 0x822A8E44; continue 'dispatch;
	}
	// 822A8E3C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822A8E40: 419A0008  beq cr6, 0x822a8e48
	if ctx.cr[6].eq {
	pc = 0x822A8E48; continue 'dispatch;
	}
	pc = 0x822A8E44; continue 'dispatch;
            }
            0x822A8E44 => {
    //   block [0x822A8E44..0x822A8E48)
	// 822A8E44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A8E48; continue 'dispatch;
            }
            0x822A8E48 => {
    //   block [0x822A8E48..0x822A8E5C)
	// 822A8E48: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 822A8E4C: 419A0074  beq cr6, 0x822a8ec0
	if ctx.cr[6].eq {
	pc = 0x822A8EC0; continue 'dispatch;
	}
	// 822A8E50: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822A8E54: 409A0008  bne cr6, 0x822a8e5c
	if !ctx.cr[6].eq {
	pc = 0x822A8E5C; continue 'dispatch;
	}
	// 822A8E58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A8E5C; continue 'dispatch;
            }
            0x822A8E5C => {
    //   block [0x822A8E5C..0x822A8E6C)
	// 822A8E5C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A8E60: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A8E64: 409A0008  bne cr6, 0x822a8e6c
	if !ctx.cr[6].eq {
	pc = 0x822A8E6C; continue 'dispatch;
	}
	// 822A8E68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A8E6C; continue 'dispatch;
            }
            0x822A8E6C => {
    //   block [0x822A8E6C..0x822A8EA8)
	// 822A8E6C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 822A8E70: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 822A8E74: 4BEF837D  bl 0x821a11f0
	ctx.lr = 0x822A8E78;
	sub_821A11F0(ctx, base);
	// 822A8E78: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822A8E7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A8E80: 419A0028  beq cr6, 0x822a8ea8
	if ctx.cr[6].eq {
	pc = 0x822A8EA8; continue 'dispatch;
	}
	// 822A8E84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822A8E88: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A8E8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822A8E90: 4BEE1DE1  bl 0x8218ac70
	ctx.lr = 0x822A8E94;
	sub_8218AC70(ctx, base);
	// 822A8E94: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 822A8E98: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822A8E9C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822A8EA0: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A8EA4: 4BFFFF90  b 0x822a8e34
	pc = 0x822A8E34; continue 'dispatch;
            }
            0x822A8EA8 => {
    //   block [0x822A8EA8..0x822A8EB8)
	// 822A8EA8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A8EAC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A8EB0: 409A0008  bne cr6, 0x822a8eb8
	if !ctx.cr[6].eq {
	pc = 0x822A8EB8; continue 'dispatch;
	}
	// 822A8EB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A8EB8; continue 'dispatch;
            }
            0x822A8EB8 => {
    //   block [0x822A8EB8..0x822A8EC0)
	// 822A8EB8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A8EBC: 4BFFFF74  b 0x822a8e30
	pc = 0x822A8E30; continue 'dispatch;
            }
            0x822A8EC0 => {
    //   block [0x822A8EC0..0x822A8EDC)
	// 822A8EC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822A8EC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822A8EC8: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 822A8ECC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 822A8ED0: 4BEEAF69  bl 0x82193e38
	ctx.lr = 0x822A8ED4;
	sub_82193E38(ctx, base);
	// 822A8ED4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822A8ED8: 48A00580  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A8EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A8EE0 size=136
    let mut pc: u32 = 0x822A8EE0;
    'dispatch: loop {
        match pc {
            0x822A8EE0 => {
    //   block [0x822A8EE0..0x822A8F68)
	// 822A8EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A8EE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A8EE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A8EEC: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A8F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A8F68 size=332
    let mut pc: u32 = 0x822A8F68;
    'dispatch: loop {
        match pc {
            0x822A8F68 => {
    //   block [0x822A8F68..0x822A904C)
	// 822A8F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A8F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A8F70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A8F74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A8F78: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 822A8F7C: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 822A8F80: 396B2390  addi r11, r11, 0x2390
	ctx.r[11].s64 = ctx.r[11].s64 + 9104;
	// 822A8F84: 38CA7E70  addi r6, r10, 0x7e70
	ctx.r[6].s64 = ctx.r[10].s64 + 32368;
	// 822A8F88: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822A8F8C: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 822A8F90: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 822A8F94: 38AB2008  addi r5, r11, 0x2008
	ctx.r[5].s64 = ctx.r[11].s64 + 8200;
	// 822A8F98: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 822A8F9C: 394A63A0  addi r10, r10, 0x63a0
	ctx.r[10].s64 = ctx.r[10].s64 + 25504;
	// 822A8FA0: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 822A8FA4: 7CC7592E  stwx r6, r7, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 822A8FA8: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 822A8FAC: 80EB2000  lwz r7, 0x2000(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 822A8FB0: 812B400C  lwz r9, 0x400c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 822A8FB4: 553F1838  slwi r31, r9, 3
	ctx.r[31].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822A8FB8: 39280001  addi r9, r8, 1
	ctx.r[9].s64 = ctx.r[8].s64 + 1;
	// 822A8FBC: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A8FC0: 912B2004  stw r9, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 822A8FC4: 910B2000  stw r8, 0x2000(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8192 as u32), ctx.r[8].u32 ) };
	// 822A8FC8: 7CDF292E  stwx r6, r31, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[5].u32), ctx.r[6].u32) };
	// 822A8FCC: 88AA005D  lbz r5, 0x5d(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(93 as u32) ) } as u64;
	// 822A8FD0: 80EB4008  lwz r7, 0x4008(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16392 as u32) ) } as u64;
	// 822A8FD4: 80CA004C  lwz r6, 0x4c(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A8FD8: 810B400C  lwz r8, 0x400c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 822A8FDC: 39280001  addi r9, r8, 1
	ctx.r[9].s64 = ctx.r[8].s64 + 1;
	// 822A8FE0: 1D052008  mulli r8, r5, 0x2008
	ctx.r[8].s32 = ((ctx.r[5].s32 as i64 * 8200 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 822A8FE4: 912B400C  stw r9, 0x400c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16396 as u32), ctx.r[9].u32 ) };
	// 822A8FE8: 7D285A14  add r9, r8, r11
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 822A8FEC: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A8FF0: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 822A8FF4: 910B4008  stw r8, 0x4008(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16392 as u32), ctx.r[8].u32 ) };
	// 822A8FF8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 822A8FFC: 419A0090  beq cr6, 0x822a908c
	if ctx.cr[6].eq {
	pc = 0x822A908C; continue 'dispatch;
	}
	// 822A9000: 81692000  lwz r11, 0x2000(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 822A9004: 810A0050  lwz r8, 0x50(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A9008: 7D674038  and r7, r11, r8
	ctx.r[7].u64 = ctx.r[11].u64 & ctx.r[8].u64;
	// 822A900C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A9010: 409A003C  bne cr6, 0x822a904c
	if !ctx.cr[6].eq {
	pc = 0x822A904C; continue 'dispatch;
	}
	// 822A9014: 80E92004  lwz r7, 0x2004(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 822A9018: 7D6B4378  or r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[8].u64;
	// 822A901C: 38CA0048  addi r6, r10, 0x48
	ctx.r[6].s64 = ctx.r[10].s64 + 72;
	// 822A9020: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 822A9024: 916A0050  stw r11, 0x50(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822A9028: 7CC5492E  stwx r6, r5, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32), ctx.r[6].u32) };
	// 822A902C: 816A004C  lwz r11, 0x4c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A9030: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 822A9034: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A9038: 7CE84A14  add r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 822A903C: 91670004  stw r11, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822A9040: 81692004  lwz r11, 0x2004(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 822A9044: 38CB0001  addi r6, r11, 1
	ctx.r[6].s64 = ctx.r[11].s64 + 1;
	// 822A9048: 90C92004  stw r6, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x822A904C; continue 'dispatch;
            }
            0x822A904C => {
    //   block [0x822A904C..0x822A908C)
	// 822A904C: 896A005C  lbz r11, 0x5c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 822A9050: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822A9054: 912A004C  stw r9, 0x4c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(76 as u32), ctx.r[9].u32 ) };
	// 822A9058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A905C: 409A0030  bne cr6, 0x822a908c
	if !ctx.cr[6].eq {
	pc = 0x822A908C; continue 'dispatch;
	}
	// 822A9060: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 822A9064: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A9068: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 822A906C: 996A005C  stb r11, 0x5c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(92 as u32), ctx.r[11].u8 ) };
	// 822A9070: 38EA0048  addi r7, r10, 0x48
	ctx.r[7].s64 = ctx.r[10].s64 + 72;
	// 822A9074: 38C80DB8  addi r6, r8, 0xdb8
	ctx.r[6].s64 = ctx.r[8].s64 + 3512;
	// 822A9078: 81690DB0  lwz r11, 0xdb0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3504 as u32) ) } as u64;
	// 822A907C: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 822A9080: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822A9084: 91690DB0  stw r11, 0xdb0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 822A9088: 7CE5312E  stwx r7, r5, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32), ctx.r[7].u32) };
	pc = 0x822A908C; continue 'dispatch;
            }
            0x822A908C => {
    //   block [0x822A908C..0x822A90B4)
	// 822A908C: 4BF93F15  bl 0x8223cfa0
	ctx.lr = 0x822A9090;
	sub_8223CFA0(ctx, base);
	// 822A9090: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A9094: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A9098: 4BF76249  bl 0x8221f2e0
	ctx.lr = 0x822A909C;
	sub_8221F2E0(ctx, base);
	// 822A909C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A90A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822A90A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A90A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A90AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822A90B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A90B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A90B8 size=128
    let mut pc: u32 = 0x822A90B8;
    'dispatch: loop {
        match pc {
            0x822A90B8 => {
    //   block [0x822A90B8..0x822A9104)
	// 822A90B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A90BC: 48A0034D  bl 0x82ca9408
	ctx.lr = 0x822A90C0;
	sub_82CA93D0(ctx, base);
	// 822A90C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A90C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A90C8: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A90CC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A90D0: 395E0003  addi r10, r30, 3
	ctx.r[10].s64 = ctx.r[30].s64 + 3;
	// 822A90D4: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822A90D8: 555D003A  rlwinm r29, r10, 0, 0, 0x1d
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822A90DC: 3B9D0004  addi r28, r29, 4
	ctx.r[28].s64 = ctx.r[29].s64 + 4;
	// 822A90E0: 41980034  blt cr6, 0x822a9114
	if ctx.cr[6].lt {
	pc = 0x822A9114; continue 'dispatch;
	}
	// 822A90E4: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822A90E8: 4099002C  ble cr6, 0x822a9114
	if !ctx.cr[6].gt {
	pc = 0x822A9114; continue 'dispatch;
	}
	// 822A90EC: 4BFEB745  bl 0x82294830
	ctx.lr = 0x822A90F0;
	sub_82294830(ctx, base);
	// 822A90F0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A90F4: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822A90F8: 4198000C  blt cr6, 0x822a9104
	if ctx.cr[6].lt {
	pc = 0x822A9104; continue 'dispatch;
	}
	// 822A90FC: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822A9100: 41990020  bgt cr6, 0x822a9120
	if ctx.cr[6].gt {
	pc = 0x822A9120; continue 'dispatch;
	}
	pc = 0x822A9104; continue 'dispatch;
            }
            0x822A9104 => {
    //   block [0x822A9104..0x822A9114)
	// 822A9104: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A9108: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822A910C: 409A0008  bne cr6, 0x822a9114
	if !ctx.cr[6].eq {
	pc = 0x822A9114; continue 'dispatch;
	}
	// 822A9110: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x822A9114; continue 'dispatch;
            }
            0x822A9114 => {
    //   block [0x822A9114..0x822A9120)
	// 822A9114: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A9118: 7D6BEA15  add. r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A911C: 40820010  bne 0x822a912c
	if !ctx.cr[0].eq {
	pc = 0x822A912C; continue 'dispatch;
	}
	pc = 0x822A9120; continue 'dispatch;
            }
            0x822A9120 => {
    //   block [0x822A9120..0x822A912C)
	// 822A9120: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822A9124: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822A9128: 48A00330  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x822A912C => {
    //   block [0x822A912C..0x822A9138)
	// 822A912C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9130: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822A9134: 48A00324  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A9138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822A9138 size=104
    let mut pc: u32 = 0x822A9138;
    'dispatch: loop {
        match pc {
            0x822A9138 => {
    //   block [0x822A9138..0x822A91A0)
	// 822A9138: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 822A913C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822A9140: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 822A9144: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 822A9148: C001FFF4  lfs f0, -0xc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A914C: F921FFF8  std r9, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[9].u64 ) };
	// 822A9150: C1A1FFFC  lfs f13, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822A9154: C181FFF0  lfs f12, -0x10(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822A9158: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822A915C: C161FFF8  lfs f11, -8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822A9160: ED4C02F2  fmuls f10, f12, f11
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 822A9164: ED20537A  fmadds f9, f0, f13, f10
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64);
	// 822A9168: C00A9A80  lfs f0, -0x6580(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A916C: EC20482C  fsqrts f1, f9
	ctx.f[1].f64 = ((ctx.f[9].f64).sqrt() as f32) as f64;
	// 822A9170: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 822A9174: 4198002C  blt cr6, 0x822a91a0
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x822A91A0);
		return;
	}
	// 822A9178: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 822A917C: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822A9180: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822A9184: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A9188: ED600824  fdivs f11, f0, f1
	ctx.f[11].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 822A918C: ED4D02F2  fmuls f10, f13, f11
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 822A9190: D1430000  stfs f10, 0(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822A9194: ED2C02F2  fmuls f9, f12, f11
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 822A9198: D1230004  stfs f9, 4(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822A919C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A91B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A91B0 size=104
    let mut pc: u32 = 0x822A91B0;
    'dispatch: loop {
        match pc {
            0x822A91B0 => {
    //   block [0x822A91B0..0x822A9200)
	// 822A91B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A91B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A91B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822A91BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A91C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A91C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A91C8: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 822A91CC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822A91D0: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822A91D4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A91D8: 7C895050  subf r4, r9, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 822A91DC: 4BF7F995  bl 0x82228b70
	ctx.lr = 0x822A91E0;
	sub_82228B70(ctx, base);
	// 822A91E0: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 822A91E4: 409A001C  bne cr6, 0x822a9200
	if !ctx.cr[6].eq {
	pc = 0x822A9200; continue 'dispatch;
	}
	// 822A91E8: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A91EC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A91F0: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A91F4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822A91F8: 41980008  blt cr6, 0x822a9200
	if ctx.cr[6].lt {
	pc = 0x822A9200; continue 'dispatch;
	}
	// 822A91FC: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x822A9200; continue 'dispatch;
            }
            0x822A9200 => {
    //   block [0x822A9200..0x822A9218)
	// 822A9200: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822A9204: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A9208: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A920C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822A9210: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822A9214: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A9218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A9218 size=568
    let mut pc: u32 = 0x822A9218;
    'dispatch: loop {
        match pc {
            0x822A9218 => {
    //   block [0x822A9218..0x822A9254)
	// 822A9218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A921C: 48A001ED  bl 0x82ca9408
	ctx.lr = 0x822A9220;
	sub_82CA93D0(ctx, base);
	// 822A9220: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822A9224: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A9228: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822A922C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822A9230: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822A9234: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822A9238: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822A923C: 4BF1B0AD  bl 0x821c42e8
	ctx.lr = 0x822A9240;
	sub_821C42E8(ctx, base);
	// 822A9240: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 822A9244: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 822A9248: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A924C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A9250: 4198000C  blt cr6, 0x822a925c
	if ctx.cr[6].lt {
	pc = 0x822A925C; continue 'dispatch;
	}
	pc = 0x822A9254; continue 'dispatch;
            }
            0x822A9254 => {
    //   block [0x822A9254..0x822A925C)
	// 822A9254: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822A9258: 480001EC  b 0x822a9444
	pc = 0x822A9444; continue 'dispatch;
            }
            0x822A925C => {
    //   block [0x822A925C..0x822A9294)
	// 822A925C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822A9260: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A9264: 39030001  addi r8, r3, 1
	ctx.r[8].s64 = ctx.r[3].s64 + 1;
	// 822A9268: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822A926C: 7CE859D6  mullw r7, r8, r11
	ctx.r[7].s32 = ((ctx.r[8].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 822A9270: C16A0BEC  lfs f11, 0xbec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822A9274: 7D4B19D6  mullw r10, r11, r3
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * ctx.r[3].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 822A9278: 3BEA0001  addi r31, r10, 1
	ctx.r[31].s64 = ctx.r[10].s64 + 1;
	// 822A927C: 7F1F3840  cmplw cr6, r31, r7
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[7].u32, &mut ctx.xer);
	// 822A9280: 4098FFD4  bge cr6, 0x822a9254
	if !ctx.cr[6].lt {
	pc = 0x822A9254; continue 'dispatch;
	}
	// 822A9284: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A9288: 57EB2834  slwi r11, r31, 5
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822A928C: 7D485A14  add r10, r8, r11
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 822A9290: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	pc = 0x822A9294; continue 'dispatch;
            }
            0x822A9294 => {
    //   block [0x822A9294..0x822A92F4)
	// 822A9294: 7CCB402E  lwzx r6, r11, r8
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 822A9298: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 822A929C: 419A0070  beq cr6, 0x822a930c
	if ctx.cr[6].eq {
	pc = 0x822A930C; continue 'dispatch;
	}
	// 822A92A0: C1AAFFFC  lfs f13, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822A92A4: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A92A8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822A92AC: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822A92B0: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822A92B4: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 822A92B8: C14A0004  lfs f10, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822A92BC: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822A92C0: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 822A92C4: C15E0018  lfs f10, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822A92C8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 822A92CC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 822A92D0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 822A92D4: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 822A92D8: 41980094  blt cr6, 0x822a936c
	if ctx.cr[6].lt {
	pc = 0x822A936C; continue 'dispatch;
	}
	// 822A92DC: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A92E0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 822A92E4: 40980010  bge cr6, 0x822a92f4
	if !ctx.cr[6].lt {
	pc = 0x822A92F4; continue 'dispatch;
	}
	// 822A92E8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A92EC: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822A92F0: C1690010  lfs f11, 0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x822A92F4; continue 'dispatch;
            }
            0x822A92F4 => {
    //   block [0x822A92F4..0x822A930C)
	// 822A92F4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822A92F8: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 822A92FC: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 822A9300: 7F1F3840  cmplw cr6, r31, r7
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[7].u32, &mut ctx.xer);
	// 822A9304: 4198FF90  blt cr6, 0x822a9294
	if ctx.cr[6].lt {
	pc = 0x822A9294; continue 'dispatch;
	}
	// 822A9308: 48000014  b 0x822a931c
	pc = 0x822A931C; continue 'dispatch;
            }
            0x822A930C => {
    //   block [0x822A930C..0x822A931C)
	// 822A930C: 57EB2834  slwi r11, r31, 5
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822A9310: 7FEB4214  add r31, r11, r8
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 822A9314: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822A9318: 409A0010  bne cr6, 0x822a9328
	if !ctx.cr[6].eq {
	pc = 0x822A9328; continue 'dispatch;
	}
	pc = 0x822A931C; continue 'dispatch;
            }
            0x822A931C => {
    //   block [0x822A931C..0x822A9328)
	// 822A931C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A9320: 419AFF34  beq cr6, 0x822a9254
	if ctx.cr[6].eq {
	pc = 0x822A9254; continue 'dispatch;
	}
	// 822A9324: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	pc = 0x822A9328; continue 'dispatch;
            }
            0x822A9328 => {
    //   block [0x822A9328..0x822A936C)
	// 822A9328: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822A932C: C17D0004  lfs f11, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822A9330: D1610068  stfs f11, 0x68(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822A9334: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 822A9338: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A933C: C19E001C  lfs f12, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822A9340: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822A9344: C16B0C18  lfs f11, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822A9348: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 822A934C: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822A9350: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 822A9354: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822A9358: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822A935C: 4198005C  blt cr6, 0x822a93b8
	if ctx.cr[6].lt {
	pc = 0x822A93B8; continue 'dispatch;
	}
	// 822A9360: 39610074  addi r11, r1, 0x74
	ctx.r[11].s64 = ctx.r[1].s64 + 116;
	// 822A9364: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822A9368: 48000064  b 0x822a93cc
	pc = 0x822A93CC; continue 'dispatch;
            }
            0x822A936C => {
    //   block [0x822A936C..0x822A938C)
	// 822A936C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822A9370: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A9374: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 822A9378: 419A0014  beq cr6, 0x822a938c
	if ctx.cr[6].eq {
	pc = 0x822A938C; continue 'dispatch;
	}
	// 822A937C: 4BFB763D  bl 0x822609b8
	ctx.lr = 0x822A9380;
	sub_822609B8(ctx, base);
	// 822A9380: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A9384: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 822A9388: 48000014  b 0x822a939c
	pc = 0x822A939C; continue 'dispatch;
            }
            0x822A938C => {
    //   block [0x822A938C..0x822A939C)
	// 822A938C: 4BFB762D  bl 0x822609b8
	ctx.lr = 0x822A9390;
	sub_822609B8(ctx, base);
	// 822A9390: C01E0010  lfs f0, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A9394: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822A9398: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x822A939C; continue 'dispatch;
            }
            0x822A939C => {
    //   block [0x822A939C..0x822A93B8)
	// 822A939C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A93A0: 57EB2834  slwi r11, r31, 5
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822A93A4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822A93A8: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822A93AC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A93B0: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822A93B4: 48000090  b 0x822a9444
	pc = 0x822A9444; continue 'dispatch;
            }
            0x822A93B8 => {
    //   block [0x822A93B8..0x822A93CC)
	// 822A93B8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822A93BC: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822A93C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A93C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A93C8: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	pc = 0x822A93CC; continue 'dispatch;
            }
            0x822A93CC => {
    //   block [0x822A93CC..0x822A93E8)
	// 822A93CC: EC0D6024  fdivs f0, f13, f12
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 822A93D0: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 822A93D4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822A93D8: 41980010  blt cr6, 0x822a93e8
	if ctx.cr[6].lt {
	pc = 0x822A93E8; continue 'dispatch;
	}
	// 822A93DC: 39610078  addi r11, r1, 0x78
	ctx.r[11].s64 = ctx.r[1].s64 + 120;
	// 822A93E0: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822A93E4: 48000018  b 0x822a93fc
	pc = 0x822A93FC; continue 'dispatch;
            }
            0x822A93E8 => {
    //   block [0x822A93E8..0x822A93FC)
	// 822A93E8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822A93EC: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822A93F0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A93F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A93F8: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	pc = 0x822A93FC; continue 'dispatch;
            }
            0x822A93FC => {
    //   block [0x822A93FC..0x822A941C)
	// 822A93FC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 822A9400: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 822A9404: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 822A9408: 419A0014  beq cr6, 0x822a941c
	if ctx.cr[6].eq {
	pc = 0x822A941C; continue 'dispatch;
	}
	// 822A940C: 4BFB75AD  bl 0x822609b8
	ctx.lr = 0x822A9410;
	sub_822609B8(ctx, base);
	// 822A9410: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A9414: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 822A9418: 48000014  b 0x822a942c
	pc = 0x822A942C; continue 'dispatch;
            }
            0x822A941C => {
    //   block [0x822A941C..0x822A942C)
	// 822A941C: 4BFB759D  bl 0x822609b8
	ctx.lr = 0x822A9420;
	sub_822609B8(ctx, base);
	// 822A9420: C01E0010  lfs f0, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A9424: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822A9428: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x822A942C; continue 'dispatch;
            }
            0x822A942C => {
    //   block [0x822A942C..0x822A9444)
	// 822A942C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822A9430: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822A9434: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822A9438: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822A943C: 4BF1AA6D  bl 0x821c3ea8
	ctx.lr = 0x822A9440;
	sub_821C3EA8(ctx, base);
	// 822A9440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x822A9444; continue 'dispatch;
            }
            0x822A9444 => {
    //   block [0x822A9444..0x822A9450)
	// 822A9444: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822A9448: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822A944C: 48A0000C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A9450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A9450 size=52
    let mut pc: u32 = 0x822A9450;
    'dispatch: loop {
        match pc {
            0x822A9450 => {
    //   block [0x822A9450..0x822A9460)
	// 822A9450: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A9454: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A9458: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822A945C: 419A0020  beq cr6, 0x822a947c
	if ctx.cr[6].eq {
	pc = 0x822A947C; continue 'dispatch;
	}
	pc = 0x822A9460; continue 'dispatch;
            }
            0x822A9460 => {
    //   block [0x822A9460..0x822A947C)
	// 822A9460: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9464: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9468: 7F082000  cmpw cr6, r8, r4
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[4].s32, &mut ctx.xer);
	// 822A946C: 419A0018  beq cr6, 0x822a9484
	if ctx.cr[6].eq {
		sub_822A9484(ctx, base);
		return;
	}
	// 822A9470: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 822A9474: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822A9478: 409AFFE8  bne cr6, 0x822a9460
	if !ctx.cr[6].eq {
	pc = 0x822A9460; continue 'dispatch;
	}
	pc = 0x822A947C; continue 'dispatch;
            }
            0x822A947C => {
    //   block [0x822A947C..0x822A9484)
	// 822A947C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822A9480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A9484(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822A9484 size=100
    let mut pc: u32 = 0x822A9484;
    'dispatch: loop {
        match pc {
            0x822A9484 => {
    //   block [0x822A9484..0x822A94C4)
	// 822A9484: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822A9488: 894A0026  lbz r10, 0x26(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(38 as u32) ) } as u64;
	// 822A948C: 212A0000  subfic r9, r10, 0
	ctx.xer.ca = ctx.r[10].u32 <= 0 as u32;
	ctx.r[9].s64 = (0 as i64) - ctx.r[10].s64;
	// 822A9490: 7D094910  subfe r8, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[8].u32 = res;
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 822A9494: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822A9498: 550A07FA  rlwinm r10, r8, 0, 0x1f, 0x1d
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 822A949C: 38EA0009  addi r7, r10, 9
	ctx.r[7].s64 = ctx.r[10].s64 + 9;
	// 822A94A0: 80CB0020  lwz r6, 0x20(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822A94A4: 54E5103A  slwi r5, r7, 2
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 822A94A8: 80660058  lwz r3, 0x58(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 822A94AC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A94B0: 7D45582E  lwzx r10, r5, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822A94B4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A94B8: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A94BC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822A94C0: 419AFFBC  beq cr6, 0x822a947c
	if ctx.cr[6].eq {
		sub_822A9450(ctx, base);
		return;
	}
	pc = 0x822A94C4; continue 'dispatch;
            }
            0x822A94C4 => {
    //   block [0x822A94C4..0x822A94E8)
	// 822A94C4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A94C8: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A94CC: 7F082040  cmplw cr6, r8, r4
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[4].u32, &mut ctx.xer);
	// 822A94D0: 419A0018  beq cr6, 0x822a94e8
	if ctx.cr[6].eq {
		sub_822A94E8(ctx, base);
		return;
	}
	// 822A94D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822A94D8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822A94DC: 409AFFE8  bne cr6, 0x822a94c4
	if !ctx.cr[6].eq {
	pc = 0x822A94C4; continue 'dispatch;
	}
	// 822A94E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822A94E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A94E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A94E8 size=8
    let mut pc: u32 = 0x822A94E8;
    'dispatch: loop {
        match pc {
            0x822A94E8 => {
    //   block [0x822A94E8..0x822A94F0)
	// 822A94E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822A94EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A94F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A94F0 size=8
    let mut pc: u32 = 0x822A94F0;
    'dispatch: loop {
        match pc {
            0x822A94F0 => {
    //   block [0x822A94F0..0x822A94F8)
	// 822A94F0: 88630034  lbz r3, 0x34(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 822A94F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A94F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A94F8 size=36
    let mut pc: u32 = 0x822A94F8;
    'dispatch: loop {
        match pc {
            0x822A94F8 => {
    //   block [0x822A94F8..0x822A951C)
	// 822A94F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822A94FC: 814B0078  lwz r10, 0x78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 822A9500: 806B0070  lwz r3, 0x70(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 822A9504: 7F0A1800  cmpw cr6, r10, r3
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[3].s32, &mut ctx.xer);
	// 822A9508: 409A0024  bne cr6, 0x822a952c
	if !ctx.cr[6].eq {
		sub_822A952C(ctx, base);
		return;
	}
	// 822A950C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822A9510: 409A000C  bne cr6, 0x822a951c
	if !ctx.cr[6].eq {
		sub_822A951C(ctx, base);
		return;
	}
	// 822A9514: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822A9518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A951C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A951C size=16
    let mut pc: u32 = 0x822A951C;
    'dispatch: loop {
        match pc {
            0x822A951C => {
    //   block [0x822A951C..0x822A952C)
	// 822A951C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9520: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822A9524: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A9528: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A952C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A952C size=28
    let mut pc: u32 = 0x822A952C;
    'dispatch: loop {
        match pc {
            0x822A952C => {
    //   block [0x822A952C..0x822A9548)
	// 822A952C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A9530: 419AFFE4  beq cr6, 0x822a9514
	if ctx.cr[6].eq {
		sub_822A94F8(ctx, base);
		return;
	}
	// 822A9534: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822A9538: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822A953C: 409A000C  bne cr6, 0x822a9548
	if !ctx.cr[6].eq {
		sub_822A9548(ctx, base);
		return;
	}
	// 822A9540: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822A9544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A9548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A9548 size=28
    let mut pc: u32 = 0x822A9548;
    'dispatch: loop {
        match pc {
            0x822A9548 => {
    //   block [0x822A9548..0x822A955C)
	// 822A9548: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 822A954C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822A9550: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A9554: 41990008  bgt cr6, 0x822a955c
	if ctx.cr[6].gt {
	pc = 0x822A955C; continue 'dispatch;
	}
	// 822A9558: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822A955C; continue 'dispatch;
            }
            0x822A955C => {
    //   block [0x822A955C..0x822A9564)
	// 822A955C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A9560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A9568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A9568 size=56
    let mut pc: u32 = 0x822A9568;
    'dispatch: loop {
        match pc {
            0x822A9568 => {
    //   block [0x822A9568..0x822A95A0)
	// 822A9568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A956C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A9570: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A9574: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 822A9578: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A957C: 4BF41ED5  bl 0x821eb450
	ctx.lr = 0x822A9580;
	sub_821EB450(ctx, base);
	// 822A9580: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822A9584: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822A9588: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822A958C: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 822A9590: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822A9594: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A9598: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A959C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A95A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822A95A0 size=8
    let mut pc: u32 = 0x822A95A0;
    'dispatch: loop {
        match pc {
            0x822A95A0 => {
    //   block [0x822A95A0..0x822A95A8)
	// 822A95A0: 88630060  lbz r3, 0x60(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 822A95A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A95A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A95A8 size=404
    let mut pc: u32 = 0x822A95A8;
    'dispatch: loop {
        match pc {
            0x822A95A8 => {
    //   block [0x822A95A8..0x822A9604)
	// 822A95A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A95AC: 489FFE5D  bl 0x82ca9408
	ctx.lr = 0x822A95B0;
	sub_82CA93D0(ctx, base);
	// 822A95B0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822A95B4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A95B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822A95BC: 4BF3A17D  bl 0x821e3738
	ctx.lr = 0x822A95C0;
	sub_821E3738(ctx, base);
	// 822A95C0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A95C4: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 822A95C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822A95CC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 822A95D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A95D4: 419A0030  beq cr6, 0x822a9604
	if ctx.cr[6].eq {
	pc = 0x822A9604; continue 'dispatch;
	}
	// 822A95D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A95DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A95E0: 419A0074  beq cr6, 0x822a9654
	if ctx.cr[6].eq {
	pc = 0x822A9654; continue 'dispatch;
	}
	// 822A95E4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822A95E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A95EC: 419A0018  beq cr6, 0x822a9604
	if ctx.cr[6].eq {
	pc = 0x822A9604; continue 'dispatch;
	}
	// 822A95F0: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 822A95F4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822A95F8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 822A95FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A9600: 409A0008  bne cr6, 0x822a9608
	if !ctx.cr[6].eq {
	pc = 0x822A9608; continue 'dispatch;
	}
	pc = 0x822A9604; continue 'dispatch;
            }
            0x822A9604 => {
    //   block [0x822A9604..0x822A9608)
	// 822A9604: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822A9608; continue 'dispatch;
            }
            0x822A9608 => {
    //   block [0x822A9608..0x822A9654)
	// 822A9608: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822A960C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A9610: 3BAA9490  addi r29, r10, -0x6b70
	ctx.r[29].s64 = ctx.r[10].s64 + -27504;
	// 822A9614: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9618: C3FDFFF4  lfs f31, -0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822A961C: 419A0060  beq cr6, 0x822a967c
	if ctx.cr[6].eq {
	pc = 0x822A967C; continue 'dispatch;
	}
	// 822A9620: C01E0078  lfs f0, 0x78(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A9624: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822A9628: 409A0054  bne cr6, 0x822a967c
	if !ctx.cr[6].eq {
	pc = 0x822A967C; continue 'dispatch;
	}
	// 822A962C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 822A9630: 4BF75C29  bl 0x8221f258
	ctx.lr = 0x822A9634;
	sub_8221F258(ctx, base);
	// 822A9634: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822A9638: 419A0024  beq cr6, 0x822a965c
	if ctx.cr[6].eq {
	pc = 0x822A965C; continue 'dispatch;
	}
	// 822A963C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822A9640: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822A9644: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822A9648: 394BB6F8  addi r10, r11, -0x4908
	ctx.r[10].s64 = ctx.r[11].s64 + -18696;
	// 822A964C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822A9650: 48000010  b 0x822a9660
	pc = 0x822A9660; continue 'dispatch;
            }
            0x822A9654 => {
    //   block [0x822A9654..0x822A965C)
	// 822A9654: 4BEEA7E5  bl 0x82193e38
	ctx.lr = 0x822A9658;
	sub_82193E38(ctx, base);
	// 822A9658: 4BFFFFAC  b 0x822a9604
	pc = 0x822A9604; continue 'dispatch;
            }
            0x822A965C => {
    //   block [0x822A965C..0x822A9660)
	// 822A965C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x822A9660; continue 'dispatch;
            }
            0x822A9660 => {
    //   block [0x822A9660..0x822A967C)
	// 822A9660: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A9664: 4BF1244D  bl 0x821bbab0
	ctx.lr = 0x822A9668;
	sub_821BBAB0(ctx, base);
	// 822A9668: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822A966C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822A9670: 4BFC27F9  bl 0x8226be68
	ctx.lr = 0x822A9674;
	sub_8226BE68(ctx, base);
	// 822A9674: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A9678: 4BF0E4A1  bl 0x821b7b18
	ctx.lr = 0x822A967C;
	sub_821B7B18(ctx, base);
	pc = 0x822A967C; continue 'dispatch;
            }
            0x822A967C => {
    //   block [0x822A967C..0x822A96F8)
	// 822A967C: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 822A9680: 4BF75BD9  bl 0x8221f258
	ctx.lr = 0x822A9684;
	sub_8221F258(ctx, base);
	// 822A9684: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822A9688: 419A0070  beq cr6, 0x822a96f8
	if ctx.cr[6].eq {
	pc = 0x822A96F8; continue 'dispatch;
	}
	// 822A968C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822A9690: C1BE0078  lfs f13, 0x78(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822A9694: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A9698: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822A969C: 394B1DEC  addi r10, r11, 0x1dec
	ctx.r[10].s64 = ctx.r[11].s64 + 7660;
	// 822A96A0: D3E30008  stfs f31, 8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822A96A4: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822A96A8: 9B83000C  stb r28, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 822A96AC: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 822A96B0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822A96B4: D3E3002C  stfs f31, 0x2c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 822A96B8: 9BE3000D  stb r31, 0xd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(13 as u32), ctx.r[31].u8 ) };
	// 822A96BC: D1A30030  stfs f13, 0x30(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 822A96C0: 9BE3000E  stb r31, 0xe(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(14 as u32), ctx.r[31].u8 ) };
	// 822A96C4: D3E30034  stfs f31, 0x34(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 822A96C8: 9BE30020  stb r31, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[31].u8 ) };
	// 822A96CC: D3E30038  stfs f31, 0x38(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 822A96D0: 9B830040  stb r28, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[28].u8 ) };
	// 822A96D4: D3E3003C  stfs f31, 0x3c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 822A96D8: 9BE30041  stb r31, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[31].u8 ) };
	// 822A96DC: 9BE30042  stb r31, 0x42(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(66 as u32), ctx.r[31].u8 ) };
	// 822A96E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822A96E4: 9BE30043  stb r31, 0x43(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(67 as u32), ctx.r[31].u8 ) };
	// 822A96E8: 93E30048  stw r31, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[31].u32 ) };
	// 822A96EC: 93E3004C  stw r31, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 822A96F0: 9B830054  stb r28, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[28].u8 ) };
	// 822A96F4: 48000008  b 0x822a96fc
	pc = 0x822A96FC; continue 'dispatch;
            }
            0x822A96F8 => {
    //   block [0x822A96F8..0x822A96FC)
	// 822A96F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x822A96FC; continue 'dispatch;
            }
            0x822A96FC => {
    //   block [0x822A96FC..0x822A970C)
	// 822A96FC: C01E007C  lfs f0, 0x7c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A9700: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822A9704: 40990008  ble cr6, 0x822a970c
	if !ctx.cr[6].gt {
	pc = 0x822A970C; continue 'dispatch;
	}
	// 822A9708: D0040038  stfs f0, 0x38(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(56 as u32), tmp.u32 ) };
	pc = 0x822A970C; continue 'dispatch;
            }
            0x822A970C => {
    //   block [0x822A970C..0x822A973C)
	// 822A970C: C01E0080  lfs f0, 0x80(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A9710: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822A9714: D004003C  stfs f0, 0x3c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 822A9718: 4BF12399  bl 0x821bbab0
	ctx.lr = 0x822A971C;
	sub_821BBAB0(ctx, base);
	// 822A971C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822A9720: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822A9724: 4BFC2745  bl 0x8226be68
	ctx.lr = 0x822A9728;
	sub_8226BE68(ctx, base);
	// 822A9728: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822A972C: 4BF0E3ED  bl 0x821b7b18
	ctx.lr = 0x822A9730;
	sub_821B7B18(ctx, base);
	// 822A9730: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822A9734: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822A9738: 489FFD20  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A9740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A9740 size=200
    let mut pc: u32 = 0x822A9740;
    'dispatch: loop {
        match pc {
            0x822A9740 => {
    //   block [0x822A9740..0x822A97AC)
	// 822A9740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A9744: 489FFCC9  bl 0x82ca940c
	ctx.lr = 0x822A9748;
	sub_82CA93D0(ctx, base);
	// 822A9748: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A974C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A9750: 83DF0078  lwz r30, 0x78(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 822A9754: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822A9758: 419A00A8  beq cr6, 0x822a9800
	if ctx.cr[6].eq {
	pc = 0x822A9800; continue 'dispatch;
	}
	// 822A975C: 83BF003C  lwz r29, 0x3c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 822A9760: 4BECAD09  bl 0x82174468
	ctx.lr = 0x822A9764;
	sub_82174468(ctx, base);
	// 822A9764: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822A9768: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822A976C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822A9770: 4BF0CCE9  bl 0x821b6458
	ctx.lr = 0x822A9774;
	sub_821B6458(ctx, base);
	// 822A9774: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822A9778: 4BF75AE1  bl 0x8221f258
	ctx.lr = 0x822A977C;
	sub_8221F258(ctx, base);
	// 822A977C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822A9780: 419A002C  beq cr6, 0x822a97ac
	if ctx.cr[6].eq {
	pc = 0x822A97AC; continue 'dispatch;
	}
	// 822A9784: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 822A9788: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822A978C: 813F0054  lwz r9, 0x54(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 822A9790: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822A9794: 390A1D24  addi r8, r10, 0x1d24
	ctx.r[8].s64 = ctx.r[10].s64 + 7460;
	// 822A9798: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 822A979C: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 822A97A0: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822A97A4: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 822A97A8: 48000008  b 0x822a97b0
	pc = 0x822A97B0; continue 'dispatch;
            }
            0x822A97AC => {
    //   block [0x822A97AC..0x822A97B0)
	// 822A97AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x822A97B0; continue 'dispatch;
            }
            0x822A97B0 => {
    //   block [0x822A97B0..0x822A97E8)
	// 822A97B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A97B4: 83DF0078  lwz r30, 0x78(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 822A97B8: 4BF122F9  bl 0x821bbab0
	ctx.lr = 0x822A97BC;
	sub_821BBAB0(ctx, base);
	// 822A97BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822A97C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822A97C4: 4BFC26A5  bl 0x8226be68
	ctx.lr = 0x822A97C8;
	sub_8226BE68(ctx, base);
	// 822A97C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A97CC: 4BF0E34D  bl 0x821b7b18
	ctx.lr = 0x822A97D0;
	sub_821B7B18(ctx, base);
	// 822A97D0: 897F005C  lbz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 822A97D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A97D8: 419A0010  beq cr6, 0x822a97e8
	if ctx.cr[6].eq {
	pc = 0x822A97E8; continue 'dispatch;
	}
	// 822A97DC: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 822A97E0: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 822A97E4: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	pc = 0x822A97E8; continue 'dispatch;
            }
            0x822A97E8 => {
    //   block [0x822A97E8..0x822A9800)
	// 822A97E8: 897F0050  lbz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A97EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A97F0: 419A0010  beq cr6, 0x822a9800
	if ctx.cr[6].eq {
	pc = 0x822A9800; continue 'dispatch;
	}
	// 822A97F4: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 822A97F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822A97FC: 994B0050  stb r10, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	pc = 0x822A9800; continue 'dispatch;
            }
            0x822A9800 => {
    //   block [0x822A9800..0x822A9808)
	// 822A9800: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822A9804: 489FFC58  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A9808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A9808 size=476
    let mut pc: u32 = 0x822A9808;
    'dispatch: loop {
        match pc {
            0x822A9808 => {
    //   block [0x822A9808..0x822A9864)
	// 822A9808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A980C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A9810: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822A9814: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A9818: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A981C: 81630150  lwz r11, 0x150(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(336 as u32) ) } as u64;
	// 822A9820: 3BE3014C  addi r31, r3, 0x14c
	ctx.r[31].s64 = ctx.r[3].s64 + 332;
	// 822A9824: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822A9828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A982C: 419A0038  beq cr6, 0x822a9864
	if ctx.cr[6].eq {
	pc = 0x822A9864; continue 'dispatch;
	}
	// 822A9830: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9834: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A9838: 419A0080  beq cr6, 0x822a98b8
	if ctx.cr[6].eq {
	pc = 0x822A98B8; continue 'dispatch;
	}
	// 822A983C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822A9840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9844: 419A0020  beq cr6, 0x822a9864
	if ctx.cr[6].eq {
	pc = 0x822A9864; continue 'dispatch;
	}
	// 822A9848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A984C: 4BECA5ED  bl 0x82173e38
	ctx.lr = 0x822A9850;
	sub_82173E38(ctx, base);
	// 822A9850: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 822A9854: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822A9858: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A985C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A9860: 409A0008  bne cr6, 0x822a9868
	if !ctx.cr[6].eq {
	pc = 0x822A9868; continue 'dispatch;
	}
	pc = 0x822A9864; continue 'dispatch;
            }
            0x822A9864 => {
    //   block [0x822A9864..0x822A9868)
	// 822A9864: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822A9868; continue 'dispatch;
            }
            0x822A9868 => {
    //   block [0x822A9868..0x822A98B8)
	// 822A9868: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A986C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9870: 419A0158  beq cr6, 0x822a99c8
	if ctx.cr[6].eq {
	pc = 0x822A99C8; continue 'dispatch;
	}
	// 822A9874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A9878: 4BECA5C1  bl 0x82173e38
	ctx.lr = 0x822A987C;
	sub_82173E38(ctx, base);
	// 822A987C: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 822A9880: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 822A9884: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A9888: 419A0100  beq cr6, 0x822a9988
	if ctx.cr[6].eq {
	pc = 0x822A9988; continue 'dispatch;
	}
	// 822A988C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A9890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9894: 419A0030  beq cr6, 0x822a98c4
	if ctx.cr[6].eq {
	pc = 0x822A98C4; continue 'dispatch;
	}
	// 822A9898: 894B00F5  lbz r10, 0xf5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(245 as u32) ) } as u64;
	// 822A989C: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A98A0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822A98A4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822A98A8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A98AC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 822A98B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A98B4: 480000D8  b 0x822a998c
	pc = 0x822A998C; continue 'dispatch;
            }
            0x822A98B8 => {
    //   block [0x822A98B8..0x822A98C4)
	// 822A98B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A98BC: 4BEEA57D  bl 0x82193e38
	ctx.lr = 0x822A98C0;
	sub_82193E38(ctx, base);
	// 822A98C0: 4BFFFFA4  b 0x822a9864
	pc = 0x822A9864; continue 'dispatch;
            }
            0x822A98C4 => {
    //   block [0x822A98C4..0x822A98E0)
	// 822A98C4: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822A98C8: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A98CC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 822A98D0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822A98D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822A98D8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A98DC: 40810054  ble 0x822a9930
	if !ctx.cr[0].gt {
	pc = 0x822A9930; continue 'dispatch;
	}
	pc = 0x822A98E0; continue 'dispatch;
            }
            0x822A98E0 => {
    //   block [0x822A98E0..0x822A9900)
	// 822A98E0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822A98E4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822A98E8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822A98EC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A98F0: 2F0700F5  cmpwi cr6, r7, 0xf5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 245, &mut ctx.xer);
	// 822A98F4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822A98F8: 41980008  blt cr6, 0x822a9900
	if ctx.cr[6].lt {
	pc = 0x822A9900; continue 'dispatch;
	}
	// 822A98FC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x822A9900; continue 'dispatch;
            }
            0x822A9900 => {
    //   block [0x822A9900..0x822A991C)
	// 822A9900: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822A9904: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822A9908: 419A0014  beq cr6, 0x822a991c
	if ctx.cr[6].eq {
	pc = 0x822A991C; continue 'dispatch;
	}
	// 822A990C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822A9910: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822A9914: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822A9918: 4800000C  b 0x822a9924
	pc = 0x822A9924; continue 'dispatch;
            }
            0x822A991C => {
    //   block [0x822A991C..0x822A9924)
	// 822A991C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822A9920: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822A9924; continue 'dispatch;
            }
            0x822A9924 => {
    //   block [0x822A9924..0x822A9930)
	// 822A9924: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822A9928: 4199FFB8  bgt cr6, 0x822a98e0
	if ctx.cr[6].gt {
	pc = 0x822A98E0; continue 'dispatch;
	}
	// 822A992C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822A9930; continue 'dispatch;
            }
            0x822A9930 => {
    //   block [0x822A9930..0x822A994C)
	// 822A9930: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822A9934: 419A0040  beq cr6, 0x822a9974
	if ctx.cr[6].eq {
	pc = 0x822A9974; continue 'dispatch;
	}
	// 822A9938: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A993C: 2F0B00F5  cmpwi cr6, r11, 0xf5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 245, &mut ctx.xer);
	// 822A9940: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A9944: 41990008  bgt cr6, 0x822a994c
	if ctx.cr[6].gt {
	pc = 0x822A994C; continue 'dispatch;
	}
	// 822A9948: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822A994C; continue 'dispatch;
            }
            0x822A994C => {
    //   block [0x822A994C..0x822A9974)
	// 822A994C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A9950: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9954: 409A0020  bne cr6, 0x822a9974
	if !ctx.cr[6].eq {
	pc = 0x822A9974; continue 'dispatch;
	}
	// 822A9958: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822A995C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822A9960: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822A9964: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A9968: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 822A996C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A9970: 4800001C  b 0x822a998c
	pc = 0x822A998C; continue 'dispatch;
            }
            0x822A9974 => {
    //   block [0x822A9974..0x822A9988)
	// 822A9974: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822A9978: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A997C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 822A9980: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A9984: 48000008  b 0x822a998c
	pc = 0x822A998C; continue 'dispatch;
            }
            0x822A9988 => {
    //   block [0x822A9988..0x822A998C)
	// 822A9988: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822A998C; continue 'dispatch;
            }
            0x822A998C => {
    //   block [0x822A998C..0x822A99C8)
	// 822A998C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A9990: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9994: 419A0034  beq cr6, 0x822a99c8
	if ctx.cr[6].eq {
	pc = 0x822A99C8; continue 'dispatch;
	}
	// 822A9998: 897E000C  lbz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A999C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A99A0: 419A0028  beq cr6, 0x822a99c8
	if ctx.cr[6].eq {
	pc = 0x822A99C8; continue 'dispatch;
	}
	// 822A99A4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822A99A8: 38800012  li r4, 0x12
	ctx.r[4].s64 = 18;
	// 822A99AC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822A99B0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A99B4: 812A00A8  lwz r9, 0xa8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(168 as u32) ) } as u64;
	// 822A99B8: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A99BC: 4BF0B8A5  bl 0x821b5260
	ctx.lr = 0x822A99C0;
	sub_821B5260(ctx, base);
	// 822A99C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822A99C4: 48000008  b 0x822a99cc
	pc = 0x822A99CC; continue 'dispatch;
            }
            0x822A99C8 => {
    //   block [0x822A99C8..0x822A99CC)
	// 822A99C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822A99CC; continue 'dispatch;
            }
            0x822A99CC => {
    //   block [0x822A99CC..0x822A99E4)
	// 822A99CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822A99D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A99D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A99D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822A99DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822A99E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A99E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A99E8 size=96
    let mut pc: u32 = 0x822A99E8;
    'dispatch: loop {
        match pc {
            0x822A99E8 => {
    //   block [0x822A99E8..0x822A9A48)
	// 822A99E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A99EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A99F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822A99F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A99F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A99FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A9A00: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 822A9A04: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 822A9A08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822A9A0C: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 822A9A10: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822A9A14: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 822A9A18: 4BF4A341  bl 0x821f3d58
	ctx.lr = 0x822A9A1C;
	sub_821F3D58(ctx, base);
	// 822A9A1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822A9A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A9A24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822A9A28: 4BFD1DF9  bl 0x8227b820
	ctx.lr = 0x822A9A2C;
	sub_8227B820(ctx, base);
	// 822A9A2C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A9A30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822A9A34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A9A38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A9A3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822A9A40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822A9A44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A9A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A9A48 size=200
    let mut pc: u32 = 0x822A9A48;
    'dispatch: loop {
        match pc {
            0x822A9A48 => {
    //   block [0x822A9A48..0x822A9AD4)
	// 822A9A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A9A4C: 489FF9C1  bl 0x82ca940c
	ctx.lr = 0x822A9A50;
	sub_82CA93D0(ctx, base);
	// 822A9A50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A9A54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A9A58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822A9A5C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 822A9A60: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822A9A64: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 822A9A68: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 822A9A6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822A9A70: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822A9A74: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822A9A78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822A9A7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822A9A80: 4BFDA2B1  bl 0x82283d30
	ctx.lr = 0x822A9A84;
	sub_82283D30(ctx, base);
	// 822A9A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A9A88: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A9A8C: 4BFC95CD  bl 0x82273058
	ctx.lr = 0x822A9A90;
	sub_82273058(ctx, base);
	// 822A9A90: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9A94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822A9A98: 419A006C  beq cr6, 0x822a9b04
	if ctx.cr[6].eq {
	pc = 0x822A9B04; continue 'dispatch;
	}
	// 822A9A9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9AA0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822A9AA4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A9AA8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A9AAC: 4E800421  bctrl
	ctx.lr = 0x822A9AB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A9AB0: 57C9063E  clrlwi r9, r30, 0x18
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 822A9AB4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 822A9AB8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A9ABC: 419A0018  beq cr6, 0x822a9ad4
	if ctx.cr[6].eq {
	pc = 0x822A9AD4; continue 'dispatch;
	}
	// 822A9AC0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9AC4: 484B6E65  bl 0x82760928
	ctx.lr = 0x822A9AC8;
	sub_82760928(ctx, base);
	// 822A9AC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822A9ACC: 419A0008  beq cr6, 0x822a9ad4
	if ctx.cr[6].eq {
	pc = 0x822A9AD4; continue 'dispatch;
	}
	// 822A9AD0: 9BC30025  stb r30, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[30].u8 ) };
            }
            0x822A9AD4 => {
    //   block [0x822A9AD4..0x822A9B04)
	// 822A9AD4: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 822A9AD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9ADC: 419A0028  beq cr6, 0x822a9b04
	if ctx.cr[6].eq {
	pc = 0x822A9B04; continue 'dispatch;
	}
	// 822A9AE0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9AE4: 484B6E45  bl 0x82760928
	ctx.lr = 0x822A9AE8;
	sub_82760928(ctx, base);
	// 822A9AE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822A9AEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822A9AF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9AF4: 419A0014  beq cr6, 0x822a9b08
	if ctx.cr[6].eq {
	pc = 0x822A9B08; continue 'dispatch;
	}
	// 822A9AF8: 9BCB0026  stb r30, 0x26(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(38 as u32), ctx.r[30].u8 ) };
	// 822A9AFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822A9B00: 489FF95C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822A9B04 => {
    //   block [0x822A9B04..0x822A9B08)
	// 822A9B04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x822A9B08; continue 'dispatch;
            }
            0x822A9B08 => {
    //   block [0x822A9B08..0x822A9B10)
	// 822A9B08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822A9B0C: 489FF950  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A9B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A9B10 size=140
    let mut pc: u32 = 0x822A9B10;
    'dispatch: loop {
        match pc {
            0x822A9B10 => {
    //   block [0x822A9B10..0x822A9B9C)
	// 822A9B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A9B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A9B18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822A9B1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A9B20: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A9B24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822A9B28: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9B2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822A9B30: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 822A9B34: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822A9B38: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 822A9B3C: 811E0034  lwz r8, 0x34(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 822A9B40: C00B0C38  lfs f0, 0xc38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822A9B44: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A9B48: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A9BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A9BA0 size=188
    let mut pc: u32 = 0x822A9BA0;
    'dispatch: loop {
        match pc {
            0x822A9BA0 => {
    //   block [0x822A9BA0..0x822A9C5C)
	// 822A9BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A9BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A9BA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822A9BAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A9BB0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A9BB4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822A9BB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822A9BBC: E87F0000  ld r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 822A9BC0: E89F0008  ld r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 822A9BC4: E8BF0010  ld r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 822A9BC8: E8DF0018  ld r6, 0x18(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 822A9BCC: E8FF0020  ld r7, 0x20(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	// 822A9BD0: E91F0028  ld r8, 0x28(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	// 822A9BD4: E93F0030  ld r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	// 822A9BD8: E95F0038  ld r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	// 822A9BDC: 4BFE4B05  bl 0x8228e6e0
	ctx.lr = 0x822A9BE0;
	sub_8228E6E0(ctx, base);
	// 822A9BE0: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 822A9BE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A9BE8: 389F0030  addi r4, r31, 0x30
	ctx.r[4].s64 = ctx.r[31].s64 + 48;
	// 822A9BEC: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A9C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A9C60 size=152
    let mut pc: u32 = 0x822A9C60;
    'dispatch: loop {
        match pc {
            0x822A9C60 => {
    //   block [0x822A9C60..0x822A9CA8)
	// 822A9C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A9C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A9C68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822A9C6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A9C70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A9C74: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 822A9C78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822A9C7C: 38A1008C  addi r5, r1, 0x8c
	ctx.r[5].s64 = ctx.r[1].s64 + 140;
	// 822A9C80: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 822A9C84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A9C88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822A9C8C: 480CB7F5  bl 0x82375480
	ctx.lr = 0x822A9C90;
	sub_82375480(ctx, base);
	// 822A9C90: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A9C94: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A9C98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9C9C: 419A000C  beq cr6, 0x822a9ca8
	if ctx.cr[6].eq {
	pc = 0x822A9CA8; continue 'dispatch;
	}
	// 822A9CA0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822A9CA4: 419A0008  beq cr6, 0x822a9cac
	if ctx.cr[6].eq {
	pc = 0x822A9CAC; continue 'dispatch;
	}
	pc = 0x822A9CA8; continue 'dispatch;
            }
            0x822A9CA8 => {
    //   block [0x822A9CA8..0x822A9CAC)
	// 822A9CA8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A9CAC; continue 'dispatch;
            }
            0x822A9CAC => {
    //   block [0x822A9CAC..0x822A9CC4)
	// 822A9CAC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822A9CB0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822A9CB4: 419A0028  beq cr6, 0x822a9cdc
	if ctx.cr[6].eq {
	pc = 0x822A9CDC; continue 'dispatch;
	}
	// 822A9CB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9CBC: 409A0008  bne cr6, 0x822a9cc4
	if !ctx.cr[6].eq {
	pc = 0x822A9CC4; continue 'dispatch;
	}
	// 822A9CC0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A9CC4; continue 'dispatch;
            }
            0x822A9CC4 => {
    //   block [0x822A9CC4..0x822A9CD4)
	// 822A9CC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A9CC8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822A9CCC: 409A0008  bne cr6, 0x822a9cd4
	if !ctx.cr[6].eq {
	pc = 0x822A9CD4; continue 'dispatch;
	}
	// 822A9CD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822A9CD4; continue 'dispatch;
            }
            0x822A9CD4 => {
    //   block [0x822A9CD4..0x822A9CDC)
	// 822A9CD4: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A9CD8: 48000008  b 0x822a9ce0
	pc = 0x822A9CE0; continue 'dispatch;
            }
            0x822A9CDC => {
    //   block [0x822A9CDC..0x822A9CE0)
	// 822A9CDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822A9CE0; continue 'dispatch;
            }
            0x822A9CE0 => {
    //   block [0x822A9CE0..0x822A9CF8)
	// 822A9CE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822A9CE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822A9CE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822A9CEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822A9CF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822A9CF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A9CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822A9CF8 size=104
    let mut pc: u32 = 0x822A9CF8;
    'dispatch: loop {
        match pc {
            0x822A9CF8 => {
    //   block [0x822A9CF8..0x822A9D60)
	// 822A9CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A9CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822A9D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822A9D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822A9D08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A9D0C: 80630030  lwz r3, 0x30(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822A9D10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822A9D14: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822A9D18: 48B9C829  bl 0x82e46540
	ctx.lr = 0x822A9D1C;
	sub_82E46540(ctx, base);
	// 822A9D1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9D20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822A9D24: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822A9D28: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822A9D2C: 4E800421  bctrl
	ctx.lr = 0x822A9D30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A9D30: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 822A9D34: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822A9D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822A9D60 size=828
    let mut pc: u32 = 0x822A9D60;
    'dispatch: loop {
        match pc {
            0x822A9D60 => {
    //   block [0x822A9D60..0x822A9D9C)
	// 822A9D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822A9D64: 489FF6A1  bl 0x82ca9404
	ctx.lr = 0x822A9D68;
	sub_82CA93D0(ctx, base);
	// 822A9D68: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 822A9D6C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822A9D70: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822A9D74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822A9D78: 389E0030  addi r4, r30, 0x30
	ctx.r[4].s64 = ctx.r[30].s64 + 48;
	// 822A9D7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A9D80: 4BF569F1  bl 0x82200770
	ctx.lr = 0x822A9D84;
	sub_82200770(ctx, base);
	// 822A9D84: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822A9D88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A9D8C: 83FE002C  lwz r31, 0x2c(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 822A9D90: 419A000C  beq cr6, 0x822a9d9c
	if ctx.cr[6].eq {
	pc = 0x822A9D9C; continue 'dispatch;
	}
	// 822A9D94: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A9D98: 4900FBBD  bl 0x832b9954
	ctx.lr = 0x822A9D9C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x822A9D9C; continue 'dispatch;
            }
            0x822A9D9C => {
    //   block [0x822A9D9C..0x822A9DE8)
	// 822A9D9C: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	// 822A9DA0: 419A01D8  beq cr6, 0x822a9f78
	if ctx.cr[6].eq {
	pc = 0x822A9F78; continue 'dispatch;
	}
	// 822A9DA4: 2F1F0004  cmpwi cr6, r31, 4
	ctx.cr[6].compare_i32(ctx.r[31].s32, 4, &mut ctx.xer);
	// 822A9DA8: 409A02E8  bne cr6, 0x822aa090
	if !ctx.cr[6].eq {
	pc = 0x822AA090; continue 'dispatch;
	}
	// 822A9DAC: 895E0050  lbz r10, 0x50(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A9DB0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 822A9DB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A9DB8: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 822A9DBC: 419A0040  beq cr6, 0x822a9dfc
	if ctx.cr[6].eq {
	pc = 0x822A9DFC; continue 'dispatch;
	}
	// 822A9DC0: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 822A9DC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822A9DC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822A9DCC: 807F6D9C  lwz r3, 0x6d9c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28060 as u32) ) } as u64;
	// 822A9DD0: 48752F81  bl 0x829fcd50
	ctx.lr = 0x822A9DD4;
	sub_829FCD50(ctx, base);
	// 822A9DD4: 817E004C  lwz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 822A9DD8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822A9DDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9DE0: 419A0008  beq cr6, 0x822a9de8
	if ctx.cr[6].eq {
	pc = 0x822A9DE8; continue 'dispatch;
	}
	// 822A9DE4: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822A9DE8; continue 'dispatch;
            }
            0x822A9DE8 => {
    //   block [0x822A9DE8..0x822A9DFC)
	// 822A9DE8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 822A9DEC: 809F6D9C  lwz r4, 0x6d9c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28060 as u32) ) } as u64;
	// 822A9DF0: 48753769  bl 0x829fd558
	ctx.lr = 0x822A9DF4;
	sub_829FD558(ctx, base);
	// 822A9DF4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 822A9DF8: 4BF6AFE1  bl 0x82214dd8
	ctx.lr = 0x822A9DFC;
	sub_82214DD8(ctx, base);
	pc = 0x822A9DFC; continue 'dispatch;
            }
            0x822A9DFC => {
    //   block [0x822A9DFC..0x822A9EC8)
	// 822A9DFC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822A9E00: 816BE9EC  lwz r11, -0x1614(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5652 as u32) ) } as u64;
	// 822A9E04: 806B0024  lwz r3, 0x24(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822A9E08: 48755289  bl 0x829ff090
	ctx.lr = 0x822A9E0C;
	sub_829FF090(ctx, base);
	// 822A9E0C: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 822A9E10: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 822A9E14: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822A9E18: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A9E1C: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 822A9E20: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A9E24: 4806E9DD  bl 0x82318800
	ctx.lr = 0x822A9E28;
	sub_82318800(ctx, base);
	// 822A9E28: 807F6AB8  lwz r3, 0x6ab8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822A9E2C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822A9E30: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822A9E34: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9E38: 80E80014  lwz r7, 0x14(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A9E3C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 822A9E40: 4E800421  bctrl
	ctx.lr = 0x822A9E44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A9E44: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822A9E48: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9E4C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822A9E50: 80860004  lwz r4, 4(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A9E54: 81650014  lwz r11, 0x14(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 822A9E58: 83840008  lwz r28, 8(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A9E5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822A9E60: 4E800421  bctrl
	ctx.lr = 0x822A9E64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A9E64: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822A9E68: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 822A9E6C: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9E70: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822A9E74: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A9E78: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A9E7C: 80C90010  lwz r6, 0x10(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 822A9E80: CBE80110  lfd f31, 0x110(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(272 as u32) ) };
	// 822A9E84: 83670000  lwz r27, 0(r7)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9E88: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 822A9E8C: 4E800421  bctrl
	ctx.lr = 0x822A9E90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822A9E90: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822A9E94: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822A9E98: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822A9E9C: 480DEBED  bl 0x82388a88
	ctx.lr = 0x822A9EA0;
	sub_82388A88(ctx, base);
	// 822A9EA0: 3C80820B  lis r4, -0x7df5
	ctx.r[4].s64 = -2113208320;
	// 822A9EA4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822A9EA8: 3884D428  addi r4, r4, -0x2bd8
	ctx.r[4].s64 = ctx.r[4].s64 + -11224;
	// 822A9EAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A9EB0: 4BF83021  bl 0x8222ced0
	ctx.lr = 0x822A9EB4;
	sub_8222CED0(ctx, base);
	// 822A9EB4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A9EB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822A9EBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9EC0: 419A0008  beq cr6, 0x822a9ec8
	if ctx.cr[6].eq {
	pc = 0x822A9EC8; continue 'dispatch;
	}
	// 822A9EC4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x822A9EC8 => {
    //   block [0x822A9EC8..0x822A9EDC)
	// 822A9EC8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822A9ECC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822A9ED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9ED4: 419A0008  beq cr6, 0x822a9edc
	if ctx.cr[6].eq {
	pc = 0x822A9EDC; continue 'dispatch;
	}
	// 822A9ED8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822A9EDC; continue 'dispatch;
            }
            0x822A9EDC => {
    //   block [0x822A9EDC..0x822A9F18)
	// 822A9EDC: 4BF3C8ED  bl 0x821e67c8
	ctx.lr = 0x822A9EE0;
	sub_821E67C8(ctx, base);
	// 822A9EE0: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 822A9EE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822A9EE8: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822A9EEC: 695D0001  xori r29, r10, 1
	ctx.r[29].u64 = ctx.r[10].u64 ^ 1;
	// 822A9EF0: 4BF6AEE9  bl 0x82214dd8
	ctx.lr = 0x822A9EF4;
	sub_82214DD8(ctx, base);
	// 822A9EF4: 57A9063E  clrlwi r9, r29, 0x18
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 822A9EF8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822A9EFC: 419A001C  beq cr6, 0x822a9f18
	if ctx.cr[6].eq {
	pc = 0x822A9F18; continue 'dispatch;
	}
	// 822A9F00: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822A9F04: 38800041  li r4, 0x41
	ctx.r[4].s64 = 65;
	// 822A9F08: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A9F0C: 814B00A8  lwz r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 822A9F10: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822A9F14: 4BF0B34D  bl 0x821b5260
	ctx.lr = 0x822A9F18;
	sub_821B5260(ctx, base);
	pc = 0x822A9F18; continue 'dispatch;
            }
            0x822A9F18 => {
    //   block [0x822A9F18..0x822A9F40)
	// 822A9F18: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 822A9F1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822A9F20: 48117D91  bl 0x823c1cb0
	ctx.lr = 0x822A9F24;
	sub_823C1CB0(ctx, base);
	// 822A9F24: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822A9F28: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822A9F2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9F30: 419A0010  beq cr6, 0x822a9f40
	if ctx.cr[6].eq {
	pc = 0x822A9F40; continue 'dispatch;
	}
	// 822A9F34: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822A9F38: 894A6A5E  lbz r10, 0x6a5e(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(27230 as u32) ) } as u64;
	// 822A9F3C: 48000008  b 0x822a9f44
	pc = 0x822A9F44; continue 'dispatch;
            }
            0x822A9F40 => {
    //   block [0x822A9F40..0x822A9F44)
	// 822A9F40: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x822A9F44; continue 'dispatch;
            }
            0x822A9F44 => {
    //   block [0x822A9F44..0x822A9F78)
	// 822A9F44: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822A9F48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A9F4C: 419A0144  beq cr6, 0x822aa090
	if ctx.cr[6].eq {
	pc = 0x822AA090; continue 'dispatch;
	}
	// 822A9F50: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822A9F54: 806B008C  lwz r3, 0x8c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822A9F58: 89430144  lbz r10, 0x144(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(324 as u32) ) } as u64;
	// 822A9F5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822A9F60: 419A0130  beq cr6, 0x822aa090
	if ctx.cr[6].eq {
	pc = 0x822AA090; continue 'dispatch;
	}
	// 822A9F64: 9BA30144  stb r29, 0x144(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(324 as u32), ctx.r[29].u8 ) };
	// 822A9F68: 48082C41  bl 0x8232cba8
	ctx.lr = 0x822A9F6C;
	sub_8232CBA8(ctx, base);
	// 822A9F6C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822A9F70: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822A9F74: 489FF4E0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x822A9F78 => {
    //   block [0x822A9F78..0x822A9F9C)
	// 822A9F78: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822A9F7C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822A9F80: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822A9F84: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 822A9F88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822A9F8C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822A9F90: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822A9F94: 41990008  bgt cr6, 0x822a9f9c
	if ctx.cr[6].gt {
	pc = 0x822A9F9C; continue 'dispatch;
	}
	// 822A9F98: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x822A9F9C; continue 'dispatch;
            }
            0x822A9F9C => {
    //   block [0x822A9F9C..0x822AA03C)
	// 822A9F9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822A9FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9FA4: 409A00EC  bne cr6, 0x822aa090
	if !ctx.cr[6].eq {
	pc = 0x822AA090; continue 'dispatch;
	}
	// 822A9FA8: 897E0050  lbz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 822A9FAC: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 822A9FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822A9FB4: 419A0088  beq cr6, 0x822aa03c
	if ctx.cr[6].eq {
	pc = 0x822AA03C; continue 'dispatch;
	}
	// 822A9FB8: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 822A9FBC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 822A9FC0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822A9FC4: 38ABD424  addi r5, r11, -0x2bdc
	ctx.r[5].s64 = ctx.r[11].s64 + -11228;
	// 822A9FC8: 809C6D9C  lwz r4, 0x6d9c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28060 as u32) ) } as u64;
	// 822A9FCC: 4875358D  bl 0x829fd558
	ctx.lr = 0x822A9FD0;
	sub_829FD558(ctx, base);
	// 822A9FD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822A9FD4: 387E004C  addi r3, r30, 0x4c
	ctx.r[3].s64 = ctx.r[30].s64 + 76;
	// 822A9FD8: 4BFBB1C9  bl 0x822651a0
	ctx.lr = 0x822A9FDC;
	sub_822651A0(ctx, base);
	// 822A9FDC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822A9FE0: 4BF6ADF9  bl 0x82214dd8
	ctx.lr = 0x822A9FE4;
	sub_82214DD8(ctx, base);
	// 822A9FE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822A9FE8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822A9FEC: 388A0CA0  addi r4, r10, 0xca0
	ctx.r[4].s64 = ctx.r[10].s64 + 3232;
	// 822A9FF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822A9FF4: 4BF82EDD  bl 0x8222ced0
	ctx.lr = 0x822A9FF8;
	sub_8222CED0(ctx, base);
	// 822A9FF8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822A9FFC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822AA000: 807C6D9C  lwz r3, 0x6d9c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28060 as u32) ) } as u64;
	// 822AA004: 48752C9D  bl 0x829fcca0
	ctx.lr = 0x822AA008;
	sub_829FCCA0(ctx, base);
	// 822AA008: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822AA00C: 4BF6ADCD  bl 0x82214dd8
	ctx.lr = 0x822AA010;
	sub_82214DD8(ctx, base);
	// 822AA010: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822AA014: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 822AA018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AA01C: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AA020: 80A96AF8  lwz r5, 0x6af8(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27384 as u32) ) } as u64;
	// 822AA024: 80880094  lwz r4, 0x94(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(148 as u32) ) } as u64;
	// 822AA028: 48199709  bl 0x82443730
	ctx.lr = 0x822AA02C;
	sub_82443730(ctx, base);
	// 822AA02C: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AA030: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822AA034: D01E0058  stfs f0, 0x58(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822AA038: D1BE0054  stfs f13, 0x54(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x822AA03C; continue 'dispatch;
            }
            0x822AA03C => {
    //   block [0x822AA03C..0x822AA06C)
	// 822AA03C: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 822AA040: 4BF75219  bl 0x8221f258
	ctx.lr = 0x822AA044;
	sub_8221F258(ctx, base);
	// 822AA044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822AA048: 419A0024  beq cr6, 0x822aa06c
	if ctx.cr[6].eq {
	pc = 0x822AA06C; continue 'dispatch;
	}
	// 822AA04C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 822AA050: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 822AA054: 93A3000C  stw r29, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 822AA058: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822AA05C: 394BD93C  addi r10, r11, -0x26c4
	ctx.r[10].s64 = ctx.r[11].s64 + -9924;
	// 822AA060: 93A30010  stw r29, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 822AA064: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822AA068: 48000008  b 0x822aa070
	pc = 0x822AA070; continue 'dispatch;
            }
            0x822AA06C => {
    //   block [0x822AA06C..0x822AA070)
	// 822AA06C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x822AA070; continue 'dispatch;
            }
            0x822AA070 => {
    //   block [0x822AA070..0x822AA090)
	// 822AA070: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822AA074: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AA078: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 822AA07C: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AA080: 4806E699  bl 0x82318718
	ctx.lr = 0x822AA084;
	sub_82318718(ctx, base);
	// 822AA084: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 822AA088: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AA08C: 48117C25  bl 0x823c1cb0
	ctx.lr = 0x822AA090;
	sub_823C1CB0(ctx, base);
	pc = 0x822AA090; continue 'dispatch;
            }
            0x822AA090 => {
    //   block [0x822AA090..0x822AA09C)
	// 822AA090: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822AA094: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822AA098: 489FF3BC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AA0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AA0A0 size=328
    let mut pc: u32 = 0x822AA0A0;
    'dispatch: loop {
        match pc {
            0x822AA0A0 => {
    //   block [0x822AA0A0..0x822AA110)
	// 822AA0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AA0A4: 489FF361  bl 0x82ca9404
	ctx.lr = 0x822AA0A8;
	sub_82CA93D0(ctx, base);
	// 822AA0A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AA0AC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822AA0B0: 3BEBFB30  addi r31, r11, -0x4d0
	ctx.r[31].s64 = ctx.r[11].s64 + -1232;
	// 822AA0B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AA0B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AA0BC: 419A0124  beq cr6, 0x822aa1e0
	if ctx.cr[6].eq {
	pc = 0x822AA1E0; continue 'dispatch;
	}
	// 822AA0C0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AA0C4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822AA0C8: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AA0CC: 41820114  beq 0x822aa1e0
	if ctx.cr[0].eq {
	pc = 0x822AA1E0; continue 'dispatch;
	}
	// 822AA0D0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822AA0D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AA0D8: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 822AA0DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822AA0E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822AA0E4: 996A6E60  stb r11, 0x6e60(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28256 as u32), ctx.r[11].u8 ) };
	// 822AA0E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822AA0EC: 817B6E58  lwz r11, 0x6e58(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28248 as u32) ) } as u64;
	// 822AA0F0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AA0F4: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 822AA0F8: 4801C199  bl 0x822c6290
	ctx.lr = 0x822AA0FC;
	sub_822C6290(ctx, base);
	// 822AA0FC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822AA100: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 822AA104: 419A00DC  beq cr6, 0x822aa1e0
	if ctx.cr[6].eq {
	pc = 0x822AA1E0; continue 'dispatch;
	}
	// 822AA108: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822AA10C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x822AA110; continue 'dispatch;
            }
            0x822AA110 => {
    //   block [0x822AA110..0x822AA190)
	// 822AA110: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AA114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AA118: 419A00A8  beq cr6, 0x822aa1c0
	if ctx.cr[6].eq {
	pc = 0x822AA1C0; continue 'dispatch;
	}
	// 822AA11C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AA120: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822AA124: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822AA128: 7D2B1670  srawi r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 822AA12C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822AA130: 40980090  bge cr6, 0x822aa1c0
	if !ctx.cr[6].lt {
	pc = 0x822AA1C0; continue 'dispatch;
	}
	// 822AA134: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AA138: 7D5D582E  lwzx r10, r29, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822AA13C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AA140: 812B00B4  lwz r9, 0xb4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) } as u64;
	// 822AA144: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822AA148: 419A006C  beq cr6, 0x822aa1b4
	if ctx.cr[6].eq {
	pc = 0x822AA1B4; continue 'dispatch;
	}
	// 822AA14C: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 822AA150: 2F08FFFF  cmpwi cr6, r8, -1
	ctx.cr[6].compare_i32(ctx.r[8].s32, -1, &mut ctx.xer);
	// 822AA154: 419A0060  beq cr6, 0x822aa1b4
	if ctx.cr[6].eq {
	pc = 0x822AA1B4; continue 'dispatch;
	}
	// 822AA158: 814B00F0  lwz r10, 0xf0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 822AA15C: 7C68E214  add r3, r8, r28
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[28].u64;
	// 822AA160: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 822AA164: 419A0044  beq cr6, 0x822aa1a8
	if ctx.cr[6].eq {
	pc = 0x822AA1A8; continue 'dispatch;
	}
	// 822AA168: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 822AA16C: 419A0024  beq cr6, 0x822aa190
	if ctx.cr[6].eq {
	pc = 0x822AA190; continue 'dispatch;
	}
	// 822AA170: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 822AA174: 409A0040  bne cr6, 0x822aa1b4
	if !ctx.cr[6].eq {
	pc = 0x822AA1B4; continue 'dispatch;
	}
	// 822AA178: 80AB00B0  lwz r5, 0xb0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) } as u64;
	// 822AA17C: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AA180: 487AF171  bl 0x82a592f0
	ctx.lr = 0x822AA184;
	sub_82A592F0(ctx, base);
	// 822AA184: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822AA188: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822AA18C: 4BFFFF84  b 0x822aa110
	pc = 0x822AA110; continue 'dispatch;
            }
            0x822AA190 => {
    //   block [0x822AA190..0x822AA1A8)
	// 822AA190: 80AB00B0  lwz r5, 0xb0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) } as u64;
	// 822AA194: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AA198: 4BECFA69  bl 0x82179c00
	ctx.lr = 0x822AA19C;
	sub_82179C00(ctx, base);
	// 822AA19C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822AA1A0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822AA1A4: 4BFFFF6C  b 0x822aa110
	pc = 0x822AA110; continue 'dispatch;
            }
            0x822AA1A8 => {
    //   block [0x822AA1A8..0x822AA1B4)
	// 822AA1A8: 80AB00B0  lwz r5, 0xb0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) } as u64;
	// 822AA1AC: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AA1B0: 48014BD9  bl 0x822bed88
	ctx.lr = 0x822AA1B4;
	sub_822BED88(ctx, base);
	pc = 0x822AA1B4; continue 'dispatch;
            }
            0x822AA1B4 => {
    //   block [0x822AA1B4..0x822AA1C0)
	// 822AA1B4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822AA1B8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822AA1BC: 4BFFFF54  b 0x822aa110
	pc = 0x822AA110; continue 'dispatch;
            }
            0x822AA1C0 => {
    //   block [0x822AA1C0..0x822AA1E0)
	// 822AA1C0: 817B6E58  lwz r11, 0x6e58(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28248 as u32) ) } as u64;
	// 822AA1C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822AA1C8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AA1CC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AA1D0: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 822AA1D4: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822AA1D8: 5544003A  rlwinm r4, r10, 0, 0, 0x1d
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822AA1DC: 48018455  bl 0x822c2630
	ctx.lr = 0x822AA1E0;
	sub_822C2630(ctx, base);
	pc = 0x822AA1E0; continue 'dispatch;
            }
            0x822AA1E0 => {
    //   block [0x822AA1E0..0x822AA1E8)
	// 822AA1E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822AA1E4: 489FF270  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AA1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AA1E8 size=84
    let mut pc: u32 = 0x822AA1E8;
    'dispatch: loop {
        match pc {
            0x822AA1E8 => {
    //   block [0x822AA1E8..0x822AA23C)
	// 822AA1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AA1EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AA1F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AA1F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AA1F8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 822AA1FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AA200: 4BF80979  bl 0x8222ab78
	ctx.lr = 0x822AA204;
	sub_8222AB78(ctx, base);
	// 822AA204: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 822AA208: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 822AA20C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822AA210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AA214: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822AA218: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 822AA21C: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 822AA220: 997F0038  stb r11, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 822AA224: 4BEFB9AD  bl 0x821a5bd0
	ctx.lr = 0x822AA228;
	sub_821A5BD0(ctx, base);
	// 822AA228: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AA22C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AA230: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AA234: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AA238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AA240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822AA240 size=84
    let mut pc: u32 = 0x822AA240;
    'dispatch: loop {
        match pc {
            0x822AA240 => {
    //   block [0x822AA240..0x822AA294)
	// 822AA240: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 822AA244: 89696E7F  lbz r11, 0x6e7f(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(28287 as u32) ) } as u64;
	// 822AA248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AA24C: 419A0048  beq cr6, 0x822aa294
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x822AA294);
		return;
	}
	// 822AA250: 3D008336  lis r8, -0x7cca
	ctx.r[8].s64 = -2093613056;
	// 822AA254: 398001FF  li r12, 0x1ff
	ctx.r[12].s64 = 511;
	// 822AA258: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822AA25C: 798C1F06  sldi r12, r12, 0x23
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(35);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 822AA260: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822AA264: 99496E7F  stb r10, 0x6e7f(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28287 as u32), ctx.r[10].u8 ) };
	// 822AA268: 81680364  lwz r11, 0x364(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(868 as u32) ) } as u64;
	// 822AA26C: E8EB0008  ld r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 822AA270: 7CE66378  or r6, r7, r12
	ctx.r[6].u64 = ctx.r[7].u64 | ctx.r[12].u64;
	// 822AA274: 398000FF  li r12, 0xff
	ctx.r[12].s64 = 255;
	// 822AA278: F8CB0008  std r6, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u64 ) };
	// 822AA27C: 81680364  lwz r11, 0x364(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(868 as u32) ) } as u64;
	// 822AA280: 798C2E86  sldi r12, r12, 0x25
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(37);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 822AA284: E8AB0000  ld r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822AA288: 7CA46378  or r4, r5, r12
	ctx.r[4].u64 = ctx.r[5].u64 | ctx.r[12].u64;
	// 822AA28C: F88B0000  std r4, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 822AA290: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AA2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AA2A0 size=104
    let mut pc: u32 = 0x822AA2A0;
    'dispatch: loop {
        match pc {
            0x822AA2A0 => {
    //   block [0x822AA2A0..0x822AA308)
	// 822AA2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AA2A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AA2A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AA2AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AA2B0: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 822AA2B4: 39800003  li r12, 3
	ctx.r[12].s64 = 3;
	// 822AA2B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AA2BC: 798CF046  sldi r12, r12, 0x3e
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(62);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 822AA2C0: 816A0364  lwz r11, 0x364(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 822AA2C4: E92B0008  ld r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 822AA2C8: 7D286378  or r8, r9, r12
	ctx.r[8].u64 = ctx.r[9].u64 | ctx.r[12].u64;
	// 822AA2CC: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 822AA2D0: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 822AA2D4: 816A0364  lwz r11, 0x364(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 822AA2D8: 798CAFE6  rldicr r12, r12, 0x35, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(53) & 0xFFFFFFFFFFFFFFFF;
	// 822AA2DC: E8EB0000  ld r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822AA2E0: 7CE66378  or r6, r7, r12
	ctx.r[6].u64 = ctx.r[7].u64 | ctx.r[12].u64;
	// 822AA2E4: F8CB0000  std r6, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 822AA2E8: 48000631  bl 0x822aa918
	ctx.lr = 0x822AA2EC;
	sub_822AA918(ctx, base);
	// 822AA2EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AA2F0: 4BFD2C69  bl 0x8227cf58
	ctx.lr = 0x822AA2F4;
	sub_8227CF58(ctx, base);
	// 822AA2F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AA2F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AA2FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AA300: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AA304: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AA308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822AA308 size=56
    let mut pc: u32 = 0x822AA308;
    'dispatch: loop {
        match pc {
            0x822AA308 => {
    //   block [0x822AA308..0x822AA340)
	// 822AA308: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 822AA30C: 39800003  li r12, 3
	ctx.r[12].s64 = 3;
	// 822AA310: 798CF046  sldi r12, r12, 0x3e
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(62);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 822AA314: 816A0364  lwz r11, 0x364(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 822AA318: E92B0008  ld r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 822AA31C: 7D286378  or r8, r9, r12
	ctx.r[8].u64 = ctx.r[9].u64 | ctx.r[12].u64;
	// 822AA320: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 822AA324: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 822AA328: 816A0364  lwz r11, 0x364(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 822AA32C: 798CAFE6  rldicr r12, r12, 0x35, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(53) & 0xFFFFFFFFFFFFFFFF;
	// 822AA330: E8EB0000  ld r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822AA334: 7CE66378  or r6, r7, r12
	ctx.r[6].u64 = ctx.r[7].u64 | ctx.r[12].u64;
	// 822AA338: F8CB0000  std r6, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 822AA33C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AA340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822AA340 size=216
    let mut pc: u32 = 0x822AA340;
    'dispatch: loop {
        match pc {
            0x822AA340 => {
    //   block [0x822AA340..0x822AA418)
	// 822AA340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AA344: 489FF0C9  bl 0x82ca940c
	ctx.lr = 0x822AA348;
	sub_82CA93D0(ctx, base);
	// 822AA348: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AA418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AA418 size=108
    let mut pc: u32 = 0x822AA418;
    'dispatch: loop {
        match pc {
            0x822AA418 => {
    //   block [0x822AA418..0x822AA484)
	// 822AA418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AA41C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AA420: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AA424: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AA428: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 822AA42C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AA430: 4BF7DCC9  bl 0x822280f8
	ctx.lr = 0x822AA434;
	sub_822280F8(ctx, base);
	// 822AA434: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AA438: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822AA43C: 4E800421  bctrl
	ctx.lr = 0x822AA440;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822AA440: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822AA444: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AA448: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822AA44C: 7D470034  cntlzw r7, r10
	ctx.r[7].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 822AA450: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822AA454: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 822AA458: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 822AA45C: 68C50001  xori r5, r6, 1
	ctx.r[5].u64 = ctx.r[6].u64 ^ 1;
	// 822AA460: 90A90000  stw r5, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 822AA464: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AA468: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 822AA46C: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 822AA470: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AA474: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AA478: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AA47C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AA480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AA488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822AA488 size=420
    let mut pc: u32 = 0x822AA488;
    'dispatch: loop {
        match pc {
            0x822AA488 => {
    //   block [0x822AA488..0x822AA62C)
	// 822AA488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AA48C: 489FEF79  bl 0x82ca9404
	ctx.lr = 0x822AA490;
	sub_82CA93D0(ctx, base);
	// 822AA490: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 822AA494: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AA498: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AA49C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AA4A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822AA4A4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822AA4A8: 4BF74581  bl 0x8221ea28
	ctx.lr = 0x822AA4AC;
	sub_8221EA28(ctx, base);
	// 822AA4AC: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AA4B0: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 822AA4B4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 822AA4B8: C15F0034  lfs f10, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822AA4BC: C13F0038  lfs f9, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822AA4C0: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 822AA4C4: C11F003C  lfs f8, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822AA4C8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 822AA4CC: D1410058  stfs f10, 0x58(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822AA4D0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822AA4D4: D121005C  stfs f9, 0x5c(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 822AA4D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822AA4DC: D1010060  stfs f8, 0x60(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822AA4E0: 807F4170  lwz r3, 0x4170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16752 as u32) ) } as u64;
	// 822AA4E4: C81C70A0  lfd f0, 0x70a0(r28)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(28832 as u32) ) };
	// 822AA4E8: C9BB70A8  lfd f13, 0x70a8(r27)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(28840 as u32) ) };
	// 822AA4EC: C03F41A8  lfs f1, 0x41a8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16808 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822AA4F0: FCEB0028  fsub f7, f11, f0
	ctx.f[7].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 822AA4F4: FFE76824  fdiv f31, f7, f13
	ctx.f[31].f64 = ctx.f[7].f64 / ctx.f[13].f64;
	// 822AA4F8: 480004A9  bl 0x822aa9a0
	ctx.lr = 0x822AA4FC;
	sub_822AA9A0(ctx, base);
	// 822AA4FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AA500: 4BF74529  bl 0x8221ea28
	ctx.lr = 0x822AA504;
	sub_8221EA28(ctx, base);
	// 822AA504: C8C10050  lfd f6, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AA508: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 822AA50C: C9BC70A0  lfd f13, 0x70a0(r28)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(28832 as u32) ) };
	// 822AA510: C99B70A8  lfd f12, 0x70a8(r27)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(28840 as u32) ) };
	// 822AA514: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822AA518: C09F0020  lfs f4, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 822AA51C: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 822AA520: C07F0024  lfs f3, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 822AA524: C05F0028  lfs f2, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822AA528: 392A0E68  addi r9, r10, 0xe68
	ctx.r[9].s64 = ctx.r[10].s64 + 3688;
	// 822AA52C: C03F4198  lfs f1, 0x4198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16792 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822AA530: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AA534: C11F41A4  lfs f8, 0x41a4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16804 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822AA538: C13F4194  lfs f9, 0x4194(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16788 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822AA53C: C17F419C  lfs f11, 0x419c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16796 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822AA540: FCE56828  fsub f7, f5, f13
	ctx.f[7].f64 = ctx.f[5].f64 - ctx.f[13].f64;
	// 822AA544: C15F41A0  lfs f10, 0x41a0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16800 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822AA548: FCC76024  fdiv f6, f7, f12
	ctx.f[6].f64 = ctx.f[7].f64 / ctx.f[12].f64;
	// 822AA54C: FCA6F828  fsub f5, f6, f31
	ctx.f[5].f64 = ctx.f[6].f64 - ctx.f[31].f64;
	// 822AA550: FDA02818  frsp f13, f5
	ctx.f[13].f64 = (ctx.f[5].f64 as f32) as f64;
	// 822AA554: D1BF00CC  stfs f13, 0xcc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 822AA558: C19D200C  lfs f12, 0x200c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8204 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822AA55C: C0FD2014  lfs f7, 0x2014(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8212 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 822AA560: C0DD2008  lfs f6, 0x2008(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8200 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 822AA564: ECA62028  fsubs f5, f6, f4
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[4].f64) as f32) as f64);
	// 822AA568: EDAC1828  fsubs f13, f12, f3
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[3].f64) as f32) as f64);
	// 822AA56C: EFE71028  fsubs f31, f7, f2
	ctx.f[31].f64 = (((ctx.f[7].f64 - ctx.f[2].f64) as f32) as f64);
	// 822AA570: FF050000  fcmpu cr6, f5, f0
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[0].f64);
	// 822AA574: 7D000026  mfcr r8
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[8].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822AA578: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822AA57C: 5505DF7A  rlwinm r5, r8, 0x1b, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 822AA580: 5504F77A  rlwinm r4, r8, 0x1e, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 822AA584: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822AA588: 54E3DF7A  rlwinm r3, r7, 0x1b, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 822AA58C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 822AA590: 54EBF77A  rlwinm r11, r7, 0x1e, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 822AA594: 7CC00026  mfcr r6
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[6].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822AA598: 7CA72378  or r7, r5, r4
	ctx.r[7].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 822AA59C: ECA74028  fsubs f5, f7, f8
	ctx.f[5].f64 = (((ctx.f[7].f64 - ctx.f[8].f64) as f32) as f64);
	// 822AA5A0: 54CADF7A  rlwinm r10, r6, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 822AA5A4: 54C8F77A  rlwinm r8, r6, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 822AA5A8: 7C665B78  or r6, r3, r11
	ctx.r[6].u64 = ctx.r[3].u64 | ctx.r[11].u64;
	// 822AA5AC: 7D454378  or r5, r10, r8
	ctx.r[5].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 822AA5B0: 7C093C2E  lfsx f0, r9, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AA5B4: FCC0312E  fsel f6, f0, f4, f6
	ctx.f[6].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[4].f64 } else { ctx.f[6].f64 };
	// 822AA5B8: 7DA9342E  lfsx f13, r9, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822AA5BC: 7C892C2E  lfsx f4, r9, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 822AA5C0: FC6D1B2E  fsel f3, f13, f12, f3
	ctx.f[3].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[3].f64 };
	// 822AA5C4: FC4411EE  fsel f2, f4, f7, f2
	ctx.f[2].f64 = if ctx.f[4].f64 >= 0.0 { ctx.f[7].f64 } else { ctx.f[2].f64 };
	// 822AA5C8: EC060828  fsubs f0, f6, f1
	ctx.f[0].f64 = (((ctx.f[6].f64 - ctx.f[1].f64) as f32) as f64);
	// 822AA5CC: EDA35828  fsubs f13, f3, f11
	ctx.f[13].f64 = (((ctx.f[3].f64 - ctx.f[11].f64) as f32) as f64);
	// 822AA5D0: ED825028  fsubs f12, f2, f10
	ctx.f[12].f64 = (((ctx.f[2].f64 - ctx.f[10].f64) as f32) as f64);
	// 822AA5D4: ECE00A7A  fmadds f7, f0, f9, f1
	ctx.f[7].f64 = (((ctx.f[0].f64 * ctx.f[9].f64 + ctx.f[1].f64) as f32) as f64);
	// 822AA5D8: D0FF4198  stfs f7, 0x4198(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16792 as u32), tmp.u32 ) };
	// 822AA5DC: ECCD5A7A  fmadds f6, f13, f9, f11
	ctx.f[6].f64 = (((ctx.f[13].f64 * ctx.f[9].f64 + ctx.f[11].f64) as f32) as f64);
	// 822AA5E0: D0DF419C  stfs f6, 0x419c(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16796 as u32), tmp.u32 ) };
	// 822AA5E4: EC8C527A  fmadds f4, f12, f9, f10
	ctx.f[4].f64 = (((ctx.f[12].f64 * ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64);
	// 822AA5E8: D09F41A0  stfs f4, 0x41a0(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16800 as u32), tmp.u32 ) };
	// 822AA5EC: EC69417A  fmadds f3, f9, f5, f8
	ctx.f[3].f64 = (((ctx.f[9].f64 * ctx.f[5].f64 + ctx.f[8].f64) as f32) as f64);
	// 822AA5F0: D07F41A4  stfs f3, 0x41a4(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16804 as u32), tmp.u32 ) };
	// 822AA5F4: D0FF00D4  stfs f7, 0xd4(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 822AA5F8: D0DF00D8  stfs f6, 0xd8(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 822AA5FC: D09F00DC  stfs f4, 0xdc(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 822AA600: C05D2008  lfs f2, 0x2008(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8200 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822AA604: D05F00E0  stfs f2, 0xe0(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 822AA608: C03D200C  lfs f1, 0x200c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8204 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822AA60C: D03F00E4  stfs f1, 0xe4(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 822AA610: C01D2014  lfs f0, 0x2014(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AA614: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 822AA618: C1BD201C  lfs f13, 0x201c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8220 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822AA61C: D1BF00EC  stfs f13, 0xec(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 822AA620: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822AA624: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822AA628: 489FEE2C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AA630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AA630 size=104
    let mut pc: u32 = 0x822AA630;
    'dispatch: loop {
        match pc {
            0x822AA630 => {
    //   block [0x822AA630..0x822AA680)
	// 822AA630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AA634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AA638: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822AA63C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AA640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AA644: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AA648: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822AA64C: 4800D8F5  bl 0x822b7f40
	ctx.lr = 0x822AA650;
	sub_822B7F40(ctx, base);
	// 822AA650: 807E007C  lwz r3, 0x7c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 822AA654: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AA658: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 822AA65C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822AA660: 4E800421  bctrl
	ctx.lr = 0x822AA664;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822AA664: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822AA668: 419A0018  beq cr6, 0x822aa680
	if ctx.cr[6].eq {
	pc = 0x822AA680; continue 'dispatch;
	}
	// 822AA66C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AA670: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 822AA674: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822AA678: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822AA67C: 4E800421  bctrl
	ctx.lr = 0x822AA680;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822AA680 => {
    //   block [0x822AA680..0x822AA698)
	// 822AA680: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AA684: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AA688: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AA68C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822AA690: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AA694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AA698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AA698 size=372
    let mut pc: u32 = 0x822AA698;
    'dispatch: loop {
        match pc {
            0x822AA698 => {
    //   block [0x822AA698..0x822AA6C0)
	// 822AA698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AA69C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AA6A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AA6A4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822AA6A8: 419A0018  beq cr6, 0x822aa6c0
	if ctx.cr[6].eq {
	pc = 0x822AA6C0; continue 'dispatch;
	}
	// 822AA6AC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 822AA6B0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822AA6B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AA6B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AA6BC: 409A0008  bne cr6, 0x822aa6c4
	if !ctx.cr[6].eq {
	pc = 0x822AA6C4; continue 'dispatch;
	}
	pc = 0x822AA6C0; continue 'dispatch;
            }
            0x822AA6C0 => {
    //   block [0x822AA6C0..0x822AA6C4)
	// 822AA6C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822AA6C4; continue 'dispatch;
            }
            0x822AA6C4 => {
    //   block [0x822AA6C4..0x822AA70C)
	// 822AA6C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AA6C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AA6CC: 419A012C  beq cr6, 0x822aa7f8
	if ctx.cr[6].eq {
	pc = 0x822AA7F8; continue 'dispatch;
	}
	// 822AA6D0: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 822AA6D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822AA6D8: 55494FFE  rlwinm r9, r10, 9, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x007FFFFFu64;
	// 822AA6DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822AA6E0: 419A00E8  beq cr6, 0x822aa7c8
	if ctx.cr[6].eq {
	pc = 0x822AA7C8; continue 'dispatch;
	}
	// 822AA6E4: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AA6E8: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AA6EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AA6F0: 419A001C  beq cr6, 0x822aa70c
	if ctx.cr[6].eq {
	pc = 0x822AA70C; continue 'dispatch;
	}
	// 822AA6F4: 896B0057  lbz r11, 0x57(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(87 as u32) ) } as u64;
	// 822AA6F8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 822AA6FC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822AA700: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AA704: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822AA708: 480000C4  b 0x822aa7cc
	pc = 0x822AA7CC; continue 'dispatch;
            }
            0x822AA70C => {
    //   block [0x822AA70C..0x822AA728)
	// 822AA70C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AA710: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822AA714: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822AA718: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822AA71C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822AA720: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AA724: 40810054  ble 0x822aa778
	if !ctx.cr[0].gt {
	pc = 0x822AA778; continue 'dispatch;
	}
	pc = 0x822AA728; continue 'dispatch;
            }
            0x822AA728 => {
    //   block [0x822AA728..0x822AA748)
	// 822AA728: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AA72C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AA730: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822AA734: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AA738: 2F070057  cmpwi cr6, r7, 0x57
	ctx.cr[6].compare_i32(ctx.r[7].s32, 87, &mut ctx.xer);
	// 822AA73C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AA740: 41980008  blt cr6, 0x822aa748
	if ctx.cr[6].lt {
	pc = 0x822AA748; continue 'dispatch;
	}
	// 822AA744: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822AA748; continue 'dispatch;
            }
            0x822AA748 => {
    //   block [0x822AA748..0x822AA764)
	// 822AA748: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AA74C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AA750: 419A0014  beq cr6, 0x822aa764
	if ctx.cr[6].eq {
	pc = 0x822AA764; continue 'dispatch;
	}
	// 822AA754: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AA758: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AA75C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AA760: 4800000C  b 0x822aa76c
	pc = 0x822AA76C; continue 'dispatch;
            }
            0x822AA764 => {
    //   block [0x822AA764..0x822AA76C)
	// 822AA764: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AA768: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822AA76C; continue 'dispatch;
            }
            0x822AA76C => {
    //   block [0x822AA76C..0x822AA778)
	// 822AA76C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AA770: 4199FFB8  bgt cr6, 0x822aa728
	if ctx.cr[6].gt {
	pc = 0x822AA728; continue 'dispatch;
	}
	// 822AA774: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822AA778; continue 'dispatch;
            }
            0x822AA778 => {
    //   block [0x822AA778..0x822AA794)
	// 822AA778: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AA77C: 419A003C  beq cr6, 0x822aa7b8
	if ctx.cr[6].eq {
	pc = 0x822AA7B8; continue 'dispatch;
	}
	// 822AA780: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AA784: 2F0B0057  cmpwi cr6, r11, 0x57
	ctx.cr[6].compare_i32(ctx.r[11].s32, 87, &mut ctx.xer);
	// 822AA788: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AA78C: 41990008  bgt cr6, 0x822aa794
	if ctx.cr[6].gt {
	pc = 0x822AA794; continue 'dispatch;
	}
	// 822AA790: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822AA794; continue 'dispatch;
            }
            0x822AA794 => {
    //   block [0x822AA794..0x822AA7B8)
	// 822AA794: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AA798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AA79C: 409A001C  bne cr6, 0x822aa7b8
	if !ctx.cr[6].eq {
	pc = 0x822AA7B8; continue 'dispatch;
	}
	// 822AA7A0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AA7A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822AA7A8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822AA7AC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822AA7B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AA7B4: 48000018  b 0x822aa7cc
	pc = 0x822AA7CC; continue 'dispatch;
            }
            0x822AA7B8 => {
    //   block [0x822AA7B8..0x822AA7C8)
	// 822AA7B8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822AA7BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822AA7C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AA7C4: 48000008  b 0x822aa7cc
	pc = 0x822AA7CC; continue 'dispatch;
            }
            0x822AA7C8 => {
    //   block [0x822AA7C8..0x822AA7CC)
	// 822AA7C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x822AA7CC; continue 'dispatch;
            }
            0x822AA7CC => {
    //   block [0x822AA7CC..0x822AA7F8)
	// 822AA7CC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822AA7D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AA7D4: 419A0024  beq cr6, 0x822aa7f8
	if ctx.cr[6].eq {
	pc = 0x822AA7F8; continue 'dispatch;
	}
	// 822AA7D8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AA7DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822AA7E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822AA7E4: 4E800421  bctrl
	ctx.lr = 0x822AA7E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822AA7E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AA7EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AA7F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AA7F4: 4E800020  blr
	return;
            }
            0x822AA7F8 => {
    //   block [0x822AA7F8..0x822AA80C)
	// 822AA7F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822AA7FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AA800: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AA804: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AA808: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AA810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822AA810 size=100
    let mut pc: u32 = 0x822AA810;
    'dispatch: loop {
        match pc {
            0x822AA810 => {
    //   block [0x822AA810..0x822AA874)
	// 822AA810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AA814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AA818: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AA81C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AA820: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822AA824: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AA828: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822AA82C: C04B9054  lfs f2, -0x6fac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28588 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822AA830: 4BF8F841  bl 0x8223a070
	ctx.lr = 0x822AA834;
	sub_8223A070(ctx, base);
	// 822AA834: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822AA838: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822AA83C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 822AA840: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 822AA844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AA848: 1020038C  vspltisw v1, 0
	for i in 0..4 {
		ctx.v[1].u32[i] = 0;
	}
	// 822AA84C: C00A9490  lfs f0, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AA850: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AA878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AA878 size=160
    let mut pc: u32 = 0x822AA878;
    'dispatch: loop {
        match pc {
            0x822AA878 => {
    //   block [0x822AA878..0x822AA918)
	// 822AA878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AA87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AA880: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AA884: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822AA888: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 822AA88C: 39000100  li r8, 0x100
	ctx.r[8].s64 = 256;
	// 822AA890: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822AA894: 798CE7E6  rldicr r12, r12, 0x3c, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(60) & 0xFFFFFFFFFFFFFFFF;
	// 822AA898: E94A1760  ld r10, 0x1760(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(5984 as u32) ) };
	// 822AA89C: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 822AA8A0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 822AA8A4: 7D466038  and r6, r10, r12
	ctx.r[6].u64 = ctx.r[10].u64 & ctx.r[12].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AA918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AA918 size=132
    let mut pc: u32 = 0x822AA918;
    'dispatch: loop {
        match pc {
            0x822AA918 => {
    //   block [0x822AA918..0x822AA988)
	// 822AA918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AA91C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AA920: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AA924: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AA928: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822AA92C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AA930: 996A70D1  stb r11, 0x70d1(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28881 as u32), ctx.r[11].u8 ) };
	// 822AA934: 4BF73B6D  bl 0x8221e4a0
	ctx.lr = 0x822AA938;
	sub_8221E4A0(ctx, base);
	// 822AA938: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 822AA93C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822AA940: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 822AA944: 4BF1BB35  bl 0x821c6478
	ctx.lr = 0x822AA948;
	sub_821C6478(ctx, base);
	// 822AA948: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 822AA94C: 890970C3  lbz r8, 0x70c3(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(28867 as u32) ) } as u64;
	// 822AA950: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822AA954: 419A0034  beq cr6, 0x822aa988
	if ctx.cr[6].eq {
	pc = 0x822AA988; continue 'dispatch;
	}
	// 822AA958: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822AA95C: 394B7198  addi r10, r11, 0x7198
	ctx.r[10].s64 = ctx.r[11].s64 + 29080;
	// 822AA960: 892A010C  lbz r9, 0x10c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(268 as u32) ) } as u64;
	// 822AA964: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822AA968: 419A0020  beq cr6, 0x822aa988
	if ctx.cr[6].eq {
	pc = 0x822AA988; continue 'dispatch;
	}
	// 822AA96C: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 822AA970: 81632AA4  lwz r11, 0x2aa4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10916 as u32) ) } as u64;
	// 822AA974: 556A04A6  rlwinm r10, r11, 0, 0x12, 0x13
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822AA978: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AA97C: 419A000C  beq cr6, 0x822aa988
	if ctx.cr[6].eq {
	pc = 0x822AA988; continue 'dispatch;
	}
	// 822AA980: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822AA984: 48004BE5  bl 0x822af568
	ctx.lr = 0x822AA988;
	sub_822AF568(ctx, base);
	pc = 0x822AA988; continue 'dispatch;
            }
            0x822AA988 => {
    //   block [0x822AA988..0x822AA99C)
	// 822AA988: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AA98C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AA990: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AA994: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AA998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AA9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822AA9A0 size=1740
    let mut pc: u32 = 0x822AA9A0;
    'dispatch: loop {
        match pc {
            0x822AA9A0 => {
    //   block [0x822AA9A0..0x822AAA34)
	// 822AA9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AA9A4: 489FEA41  bl 0x82ca93e4
	ctx.lr = 0x822AA9A8;
	sub_82CA93D0(ctx, base);
	// 822AA9A8: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 822AA9AC: 9421F6E0  stwu r1, -0x920(r1)
	ea = ctx.r[1].u32.wrapping_add(-2336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AA9B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AA9B4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822AA9B8: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 822AA9BC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 822AA9C0: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 822AA9C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822AA9C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822AA9CC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822AA9D0: 4BFE5A19  bl 0x822903e8
	ctx.lr = 0x822AA9D4;
	sub_822903E8(ctx, base);
	// 822AA9D4: 3BD70008  addi r30, r23, 8
	ctx.r[30].s64 = ctx.r[23].s64 + 8;
	// 822AA9D8: 38A01000  li r5, 0x1000
	ctx.r[5].s64 = 4096;
	// 822AA9DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822AA9E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AA9E4: 82D70000  lwz r22, 0(r23)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AA9E8: 489FEFC9  bl 0x82ca99b0
	ctx.lr = 0x822AA9EC;
	sub_82CA99B0(ctx, base);
	// 822AA9EC: 8381006C  lwz r28, 0x6c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822AA9F0: 7C00E22C  dcbt 0, r28
	// 822AA9F4: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 822AA9F8: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822AA9FC: C0170004  lfs f0, 4(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AAA00: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822AAA04: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AAA08: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 822AAA0C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822AAA10: FDA06018  frsp f13, f12
	ctx.f[13].f64 = (ctx.f[12].f64 as f32) as f64;
	// 822AAA14: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822AAA18: 81010060  lwz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822AAA1C: 3BBF000C  addi r29, r31, 0xc
	ctx.r[29].s64 = ctx.r[31].s64 + 12;
	// 822AAA20: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822AAA24: 7F2941D6  mullw r25, r9, r8
	ctx.r[25].s32 = ((ctx.r[9].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[25].s64 = ctx.r[25].s32 as i64;
	// 822AAA28: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 822AAA2C: 40990008  ble cr6, 0x822aaa34
	if !ctx.cr[6].gt {
	pc = 0x822AAA34; continue 'dispatch;
	}
	// 822AAA30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822AAA34; continue 'dispatch;
            }
            0x822AAA34 => {
    //   block [0x822AAA34..0x822AAA4C)
	// 822AAA34: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AAA38: 831D0008  lwz r24, 8(r29)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AAA3C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AAA40: 7F0BC040  cmplw cr6, r11, r24
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[24].u32, &mut ctx.xer);
	// 822AAA44: 40990008  ble cr6, 0x822aaa4c
	if !ctx.cr[6].gt {
	pc = 0x822AAA4C; continue 'dispatch;
	}
	// 822AAA48: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822AAA4C; continue 'dispatch;
            }
            0x822AAA4C => {
    //   block [0x822AAA4C..0x822AB06C)
	// 822AAA4C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822AAA50: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822AAA54: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 822AAA58: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822AAA5C: 3AAB92D4  addi r21, r11, -0x6d2c
	ctx.r[21].s64 = ctx.r[11].s64 + -27948;
	// 822AAA60: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822AAA64: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 822AAA68: 3880FFF0  li r4, -0x10
	ctx.r[4].s64 = -16;
	// 822AAA6C: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 822AAA70: C13501BC  lfs f9, 0x1bc(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(444 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822AAA74: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 822AAA78: ED090024  fdivs f8, f9, f0
	ctx.f[8].f64 = ((ctx.f[9].f64 / ctx.f[0].f64) as f32) as f64;
	// 822AAA7C: D1010050  stfs f8, 0x50(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AB070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AB070 size=116
    let mut pc: u32 = 0x822AB070;
    'dispatch: loop {
        match pc {
            0x822AB070 => {
    //   block [0x822AB070..0x822AB0A4)
	// 822AB070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AB074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AB078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822AB07C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AB080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AB084: 3D607FFF  lis r11, 0x7fff
	ctx.r[11].s64 = 2147418112;
	// 822AB088: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822AB08C: 616AFFFF  ori r10, r11, 0xffff
	ctx.r[10].u64 = ctx.r[11].u64 | 65535;
	// 822AB090: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AB094: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822AB098: 4099000C  ble cr6, 0x822ab0a4
	if !ctx.cr[6].gt {
	pc = 0x822AB0A4; continue 'dispatch;
	}
	// 822AB09C: 4879C42D  bl 0x82a474c8
	ctx.lr = 0x822AB0A0;
	sub_82A474C8(ctx, base);
	// 822AB0A0: 48000028  b 0x822ab0c8
	pc = 0x822AB0C8; continue 'dispatch;
            }
            0x822AB0A4 => {
    //   block [0x822AB0A4..0x822AB0C8)
	// 822AB0A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822AB0A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AB0AC: 487AD7BD  bl 0x82a58868
	ctx.lr = 0x822AB0B0;
	sub_82A58868(ctx, base);
	// 822AB0B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822AB0B4: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822AB0B8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822AB0BC: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822AB0C0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822AB0C4: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x822AB0C8; continue 'dispatch;
            }
            0x822AB0C8 => {
    //   block [0x822AB0C8..0x822AB0E4)
	// 822AB0C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822AB0CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AB0D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AB0D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AB0D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822AB0DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AB0E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AB0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822AB0E8 size=468
    let mut pc: u32 = 0x822AB0E8;
    'dispatch: loop {
        match pc {
            0x822AB0E8 => {
    //   block [0x822AB0E8..0x822AB2BC)
	// 822AB0E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AB0EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AB0F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AB0F4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 822AB0F8: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AB2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AB2C0 size=180
    let mut pc: u32 = 0x822AB2C0;
    'dispatch: loop {
        match pc {
            0x822AB2C0 => {
    //   block [0x822AB2C0..0x822AB374)
	// 822AB2C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AB2C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AB2C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822AB2CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AB2D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AB2D4: 54AA653E  srwi r10, r5, 0x14
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shr(20);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822AB2D8: 80C30008  lwz r6, 8(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AB2DC: 5489653E  srwi r9, r4, 0x14
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shr(20);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822AB2E0: 396A0200  addi r11, r10, 0x200
	ctx.r[11].s64 = ctx.r[10].s64 + 512;
	// 822AB2E4: 54CA653E  srwi r10, r6, 0x14
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shr(20);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822AB2E8: 556704E6  rlwinm r7, r11, 0, 0x13, 0x13
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822AB2EC: 54A800FE  clrlwi r8, r5, 3
	ctx.r[8].u64 = ctx.r[5].u32 as u64 & 0x1FFFFFFFu64;
	// 822AB2F0: 39290200  addi r9, r9, 0x200
	ctx.r[9].s64 = ctx.r[9].s64 + 512;
	// 822AB2F4: 394A0200  addi r10, r10, 0x200
	ctx.r[10].s64 = ctx.r[10].s64 + 512;
	// 822AB2F8: 7FE74214  add r31, r7, r8
	ctx.r[31].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 822AB2FC: 552704E6  rlwinm r7, r9, 0, 0x13, 0x13
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 822AB300: 3D604000  lis r11, 0x4000
	ctx.r[11].s64 = 1073741824;
	// 822AB304: 54C900FE  clrlwi r9, r6, 3
	ctx.r[9].u64 = ctx.r[6].u32 as u64 & 0x1FFFFFFFu64;
	// 822AB308: 554A04E6  rlwinm r10, r10, 0, 0x13, 0x13
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822AB30C: 548800FE  clrlwi r8, r4, 3
	ctx.r[8].u64 = ctx.r[4].u32 as u64 & 0x1FFFFFFFu64;
	// 822AB310: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822AB314: 7FEBF850  subf r31, r11, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 822AB318: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 822AB31C: 3925FFFC  addi r9, r5, -4
	ctx.r[9].s64 = ctx.r[5].s64 + -4;
	// 822AB320: 93E40000  stw r31, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822AB324: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 822AB328: 7FCB4050  subf r30, r11, r8
	ctx.r[30].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 822AB32C: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 822AB330: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822AB334: 7C0006AC  eieio
	// 822AB338: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822AB33C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822AB340: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AB344: 4BF261C5  bl 0x821d1508
	ctx.lr = 0x822AB348;
	sub_821D1508(ctx, base);
	// 822AB348: 93C60000  stw r30, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822AB34C: 7C0006AC  eieio
	// 822AB350: 38870010  addi r4, r7, 0x10
	ctx.r[4].s64 = ctx.r[7].s64 + 16;
	// 822AB354: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 822AB358: 4BF261B1  bl 0x821d1508
	ctx.lr = 0x822AB35C;
	sub_821D1508(ctx, base);
	// 822AB35C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AB360: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AB364: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AB368: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822AB36C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AB370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AB378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AB378 size=232
    let mut pc: u32 = 0x822AB378;
    'dispatch: loop {
        match pc {
            0x822AB378 => {
    //   block [0x822AB378..0x822AB3AC)
	// 822AB378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AB37C: 489FE089  bl 0x82ca9404
	ctx.lr = 0x822AB380;
	sub_82CA93D0(ctx, base);
	// 822AB380: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AB384: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 822AB388: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 822AB38C: 836100EC  lwz r27, 0xec(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 822AB390: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822AB394: 839B0004  lwz r28, 4(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AB398: 4BF73EC1  bl 0x8221f258
	ctx.lr = 0x822AB39C;
	sub_8221F258(ctx, base);
	// 822AB39C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AB3A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822AB3A4: 419A0008  beq cr6, 0x822ab3ac
	if ctx.cr[6].eq {
	pc = 0x822AB3AC; continue 'dispatch;
	}
	// 822AB3A8: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x822AB3AC; continue 'dispatch;
            }
            0x822AB3AC => {
    //   block [0x822AB3AC..0x822AB3BC)
	// 822AB3AC: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 822AB3B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822AB3B4: 419A0008  beq cr6, 0x822ab3bc
	if ctx.cr[6].eq {
	pc = 0x822AB3BC; continue 'dispatch;
	}
	// 822AB3B8: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x822AB3BC; continue 'dispatch;
            }
            0x822AB3BC => {
    //   block [0x822AB3BC..0x822AB3DC)
	// 822AB3BC: 357F0008  addic. r11, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AB3C0: 4182001C  beq 0x822ab3dc
	if ctx.cr[0].eq {
	pc = 0x822AB3DC; continue 'dispatch;
	}
	// 822AB3C4: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 822AB3C8: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 822AB3CC: E93E0008  ld r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 822AB3D0: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 822AB3D4: E91E0010  ld r8, 0x10(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	// 822AB3D8: F90B0010  std r8, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u64 ) };
	pc = 0x822AB3DC; continue 'dispatch;
            }
            0x822AB3DC => {
    //   block [0x822AB3DC..0x822AB444)
	// 822AB3DC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822AB3E0: 3D400AAA  lis r10, 0xaaa
	ctx.r[10].s64 = 178913280;
	// 822AB3E4: 3BCB504C  addi r30, r11, 0x504c
	ctx.r[30].s64 = ctx.r[11].s64 + 20556;
	// 822AB3E8: 6149AAAA  ori r9, r10, 0xaaaa
	ctx.r[9].u64 = ctx.r[10].u64 | 43690;
	// 822AB3EC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AB3F0: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 822AB3F4: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 822AB3F8: 4098004C  bge cr6, 0x822ab444
	if !ctx.cr[6].lt {
	pc = 0x822AB444; continue 'dispatch;
	}
	// 822AB3FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822AB400: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AB404: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 822AB408: 48046B39  bl 0x822f1f40
	ctx.lr = 0x822AB40C;
	sub_822F1F40(ctx, base);
	// 822AB40C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822AB410: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822AB414: 4804699D  bl 0x822f1db0
	ctx.lr = 0x822AB418;
	sub_822F1DB0(ctx, base);
	// 822AB418: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822AB41C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822AB420: 3B8A1720  addi r28, r10, 0x1720
	ctx.r[28].s64 = ctx.r[10].s64 + 5920;
	// 822AB424: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 822AB428: 480469F9  bl 0x822f1e20
	ctx.lr = 0x822AB42C;
	sub_822F1E20(ctx, base);
	// 822AB42C: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 822AB430: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822AB434: 483D03AD  bl 0x8267b7e0
	ctx.lr = 0x822AB438;
	sub_8267B7E0(ctx, base);
	// 822AB438: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AB43C: 4BEC63D5  bl 0x82171810
	ctx.lr = 0x822AB440;
	sub_82171810(ctx, base);
	// 822AB440: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x822AB444; continue 'dispatch;
            }
            0x822AB444 => {
    //   block [0x822AB444..0x822AB460)
	// 822AB444: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822AB448: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822AB44C: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822AB450: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AB454: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822AB458: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 822AB45C: 489FDFF8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AB460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AB460 size=168
    let mut pc: u32 = 0x822AB460;
    'dispatch: loop {
        match pc {
            0x822AB460 => {
    //   block [0x822AB460..0x822AB4E8)
	// 822AB460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AB464: 489FDFA5  bl 0x82ca9408
	ctx.lr = 0x822AB468;
	sub_82CA93D0(ctx, base);
	// 822AB468: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AB46C: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 822AB470: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 822AB474: 83A100DC  lwz r29, 0xdc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 822AB478: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822AB47C: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AB480: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AB484: 48155F65  bl 0x824013e8
	ctx.lr = 0x822AB488;
	sub_824013E8(ctx, base);
	// 822AB488: 3D6003C3  lis r11, 0x3c3
	ctx.r[11].s64 = 63111168;
	// 822AB48C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AB490: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822AB494: 6169C3C3  ori r9, r11, 0xc3c3
	ctx.r[9].u64 = ctx.r[11].u64 | 50115;
	// 822AB498: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 822AB49C: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 822AB4A0: 40980048  bge cr6, 0x822ab4e8
	if !ctx.cr[6].lt {
	pc = 0x822AB4E8; continue 'dispatch;
	}
	// 822AB4A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822AB4A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AB4AC: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 822AB4B0: 48046A91  bl 0x822f1f40
	ctx.lr = 0x822AB4B4;
	sub_822F1F40(ctx, base);
	// 822AB4B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822AB4B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822AB4BC: 480468F5  bl 0x822f1db0
	ctx.lr = 0x822AB4C0;
	sub_822F1DB0(ctx, base);
	// 822AB4C0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822AB4C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822AB4C8: 3B8A1720  addi r28, r10, 0x1720
	ctx.r[28].s64 = ctx.r[10].s64 + 5920;
	// 822AB4CC: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 822AB4D0: 48046951  bl 0x822f1e20
	ctx.lr = 0x822AB4D4;
	sub_822F1E20(ctx, base);
	// 822AB4D4: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 822AB4D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822AB4DC: 483D0305  bl 0x8267b7e0
	ctx.lr = 0x822AB4E0;
	sub_8267B7E0(ctx, base);
	// 822AB4E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AB4E4: 4BEC632D  bl 0x82171810
	ctx.lr = 0x822AB4E8;
	sub_82171810(ctx, base);
	pc = 0x822AB4E8; continue 'dispatch;
            }
            0x822AB4E8 => {
    //   block [0x822AB4E8..0x822AB508)
	// 822AB4E8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AB4EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822AB4F0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822AB4F4: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822AB4F8: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AB4FC: 93CA0000  stw r30, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822AB500: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822AB504: 489FDF54  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AB508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AB508 size=152
    let mut pc: u32 = 0x822AB508;
    'dispatch: loop {
        match pc {
            0x822AB508 => {
    //   block [0x822AB508..0x822AB5A0)
	// 822AB508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AB50C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AB510: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822AB514: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AB518: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AB51C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AB520: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 822AB524: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822AB528: 394B74E4  addi r10, r11, 0x74e4
	ctx.r[10].s64 = ctx.r[11].s64 + 29924;
	// 822AB52C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822AB530: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822AB534: 4BF44D0D  bl 0x821f0240
	ctx.lr = 0x822AB538;
	sub_821F0240(ctx, base);
	// 822AB538: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 822AB53C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822AB540: 39092A30  addi r8, r9, 0x2a30
	ctx.r[8].s64 = ctx.r[9].s64 + 10800;
	// 822AB544: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822AB548: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AB54C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822AB550: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 822AB554: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 822AB558: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 822AB55C: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 822AB560: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 822AB564: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 822AB568: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 822AB56C: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 822AB570: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 822AB574: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 822AB578: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 822AB57C: 997F0048  stb r11, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u8 ) };
	// 822AB580: 4BF69859  bl 0x82214dd8
	ctx.lr = 0x822AB584;
	sub_82214DD8(ctx, base);
	// 822AB584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AB588: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AB58C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AB590: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AB594: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822AB598: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AB59C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AB5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822AB5A0 size=276
    let mut pc: u32 = 0x822AB5A0;
    'dispatch: loop {
        match pc {
            0x822AB5A0 => {
    //   block [0x822AB5A0..0x822AB6B4)
	// 822AB5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AB5A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AB5A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822AB5AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AB5B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AB5B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AB5B8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 822AB5BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822AB5C0: 394B17F8  addi r10, r11, 0x17f8
	ctx.r[10].s64 = ctx.r[11].s64 + 6136;
	// 822AB5C4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822AB5C8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822AB5CC: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 822AB5D0: 4BEEB7A1  bl 0x82196d70
	ctx.lr = 0x822AB5D4;
	sub_82196D70(ctx, base);
	// 822AB5D4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 822AB5D8: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 822AB5DC: 4BEEB795  bl 0x82196d70
	ctx.lr = 0x822AB5E0;
	sub_82196D70(ctx, base);
	// 822AB5E0: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 822AB5E4: 389E0014  addi r4, r30, 0x14
	ctx.r[4].s64 = ctx.r[30].s64 + 20;
	// 822AB5E8: 4BECF149  bl 0x8217a730
	ctx.lr = 0x822AB5EC;
	sub_8217A730(ctx, base);
	// 822AB5EC: 88DE0025  lbz r6, 0x25(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(37 as u32) ) } as u64;
	// 822AB5F0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822AB5F4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822AB5F8: 38E90E0C  addi r7, r9, 0xe0c
	ctx.r[7].s64 = ctx.r[9].s64 + 3596;
	// 822AB5FC: 98DF0025  stb r6, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[6].u8 ) };
	// 822AB600: 911F002C  stw r8, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 822AB604: 90FF0028  stw r7, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[7].u32 ) };
	// 822AB608: 80BE0030  lwz r5, 0x30(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 822AB60C: 90BF0030  stw r5, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[5].u32 ) };
	// 822AB610: 809E0034  lwz r4, 0x34(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 822AB614: 909F0034  stw r4, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[4].u32 ) };
	// 822AB618: 807E0038  lwz r3, 0x38(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 822AB61C: 907F0038  stw r3, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[3].u32 ) };
	// 822AB620: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 822AB624: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 822AB628: C01E0040  lfs f0, 0x40(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AB62C: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822AB630: C1BE0044  lfs f13, 0x44(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822AB634: D1BF0044  stfs f13, 0x44(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 822AB638: 895E0048  lbz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AB63C: 995F0048  stb r10, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u8 ) };
	// 822AB640: 893E0049  lbz r9, 0x49(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(73 as u32) ) } as u64;
	// 822AB644: 993F0049  stb r9, 0x49(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(73 as u32), ctx.r[9].u8 ) };
	// 822AB648: 891E004A  lbz r8, 0x4a(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(74 as u32) ) } as u64;
	// 822AB64C: 991F004A  stb r8, 0x4a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(74 as u32), ctx.r[8].u8 ) };
	// 822AB650: 88FE004B  lbz r7, 0x4b(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(75 as u32) ) } as u64;
	// 822AB654: 98FF004B  stb r7, 0x4b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(75 as u32), ctx.r[7].u8 ) };
	// 822AB658: 88DE004C  lbz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AB65C: 98DF004C  stb r6, 0x4c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[6].u8 ) };
	// 822AB660: 88BE004D  lbz r5, 0x4d(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(77 as u32) ) } as u64;
	// 822AB664: 98BF004D  stb r5, 0x4d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(77 as u32), ctx.r[5].u8 ) };
	// 822AB668: 889E004E  lbz r4, 0x4e(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(78 as u32) ) } as u64;
	// 822AB66C: 989F004E  stb r4, 0x4e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(78 as u32), ctx.r[4].u8 ) };
	// 822AB670: 887E004F  lbz r3, 0x4f(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(79 as u32) ) } as u64;
	// 822AB674: 987F004F  stb r3, 0x4f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(79 as u32), ctx.r[3].u8 ) };
	// 822AB678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AB67C: 897E0050  lbz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 822AB680: 997F0050  stb r11, 0x50(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 822AB684: 895E0051  lbz r10, 0x51(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(81 as u32) ) } as u64;
	// 822AB688: 995F0051  stb r10, 0x51(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 822AB68C: 893E0052  lbz r9, 0x52(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(82 as u32) ) } as u64;
	// 822AB690: 993F0052  stb r9, 0x52(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(82 as u32), ctx.r[9].u8 ) };
	// 822AB694: 891E0053  lbz r8, 0x53(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(83 as u32) ) } as u64;
	// 822AB698: 991F0053  stb r8, 0x53(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	// 822AB69C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AB6A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AB6A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AB6A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822AB6AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AB6B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AB6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AB6B8 size=72
    let mut pc: u32 = 0x822AB6B8;
    'dispatch: loop {
        match pc {
            0x822AB6B8 => {
    //   block [0x822AB6B8..0x822AB6EC)
	// 822AB6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AB6BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AB6C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AB6C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AB6C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AB6CC: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 822AB6D0: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 822AB6D4: 392B44B0  addi r9, r11, 0x44b0
	ctx.r[9].s64 = ctx.r[11].s64 + 17584;
	// 822AB6D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AB6DC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822AB6E0: 419A000C  beq cr6, 0x822ab6ec
	if ctx.cr[6].eq {
	pc = 0x822AB6EC; continue 'dispatch;
	}
	// 822AB6E4: 4BF70655  bl 0x8221bd38
	ctx.lr = 0x822AB6E8;
	sub_8221BD38(ctx, base);
	// 822AB6E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x822AB6EC; continue 'dispatch;
            }
            0x822AB6EC => {
    //   block [0x822AB6EC..0x822AB700)
	// 822AB6EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AB6F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AB6F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AB6F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AB6FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AB700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AB700 size=232
    let mut pc: u32 = 0x822AB700;
    'dispatch: loop {
        match pc {
            0x822AB700 => {
    //   block [0x822AB700..0x822AB750)
	// 822AB700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AB704: 489FDD05  bl 0x82ca9408
	ctx.lr = 0x822AB708;
	sub_82CA93D0(ctx, base);
	// 822AB708: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AB70C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822AB710: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 822AB714: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 822AB718: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822AB71C: 4BF7F4C5  bl 0x8222abe0
	ctx.lr = 0x822AB720;
	sub_8222ABE0(ctx, base);
	// 822AB720: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822AB724: 3D60F0F0  lis r11, -0xf10
	ctx.r[11].s64 = -252706816;
	// 822AB728: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 822AB72C: 616AF0F0  ori r10, r11, 0xf0f0
	ctx.r[10].u64 = ctx.r[11].u64 | 61680;
	// 822AB730: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 822AB734: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822AB738: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AB73C: 4BF7F4A5  bl 0x8222abe0
	ctx.lr = 0x822AB740;
	sub_8222ABE0(ctx, base);
	// 822AB740: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 822AB744: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822AB748: 419A0008  beq cr6, 0x822ab750
	if ctx.cr[6].eq {
	pc = 0x822AB750; continue 'dispatch;
	}
	// 822AB74C: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x822AB750; continue 'dispatch;
            }
            0x822AB750 => {
    //   block [0x822AB750..0x822AB7D4)
	// 822AB750: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 822AB754: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 822AB758: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AB75C: 4BF7F485  bl 0x8222abe0
	ctx.lr = 0x822AB760;
	sub_8222ABE0(ctx, base);
	// 822AB760: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822AB764: 419A0070  beq cr6, 0x822ab7d4
	if ctx.cr[6].eq {
	pc = 0x822AB7D4; continue 'dispatch;
	}
	// 822AB768: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822AB76C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822AB770: 392B6A70  addi r9, r11, 0x6a70
	ctx.r[9].s64 = ctx.r[11].s64 + 27248;
	// 822AB774: 390A1B04  addi r8, r10, 0x1b04
	ctx.r[8].s64 = ctx.r[10].s64 + 6916;
	// 822AB778: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822AB77C: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AB780: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 822AB784: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x822AB7D4; continue 'dispatch;
            }
            0x822AB7D4 => {
    //   block [0x822AB7D4..0x822AB7E8)
	// 822AB7D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822AB7D8: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 822AB7DC: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822AB7E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822AB7E4: 489FDC74  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AB7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AB7E8 size=216
    let mut pc: u32 = 0x822AB7E8;
    'dispatch: loop {
        match pc {
            0x822AB7E8 => {
    //   block [0x822AB7E8..0x822AB838)
	// 822AB7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AB7EC: 489FDC21  bl 0x82ca940c
	ctx.lr = 0x822AB7F0;
	sub_82CA93D0(ctx, base);
	// 822AB7F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AB7F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822AB7F8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 822AB7FC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 822AB800: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822AB804: 4BF7F3DD  bl 0x8222abe0
	ctx.lr = 0x822AB808;
	sub_8222ABE0(ctx, base);
	// 822AB808: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822AB80C: 3D60F0F0  lis r11, -0xf10
	ctx.r[11].s64 = -252706816;
	// 822AB810: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 822AB814: 616AF0F0  ori r10, r11, 0xf0f0
	ctx.r[10].u64 = ctx.r[11].u64 | 61680;
	// 822AB818: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 822AB81C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822AB820: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AB824: 4BF7F3BD  bl 0x8222abe0
	ctx.lr = 0x822AB828;
	sub_8222ABE0(ctx, base);
	// 822AB828: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822AB82C: 419A000C  beq cr6, 0x822ab838
	if ctx.cr[6].eq {
	pc = 0x822AB838; continue 'dispatch;
	}
	// 822AB830: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 822AB834: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x822AB838; continue 'dispatch;
            }
            0x822AB838 => {
    //   block [0x822AB838..0x822AB888)
	// 822AB838: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 822AB83C: 38800024  li r4, 0x24
	ctx.r[4].s64 = 36;
	// 822AB840: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AB844: 4BF7F39D  bl 0x8222abe0
	ctx.lr = 0x822AB848;
	sub_8222ABE0(ctx, base);
	// 822AB848: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822AB84C: 419A0060  beq cr6, 0x822ab8ac
	if ctx.cr[6].eq {
	pc = 0x822AB8AC; continue 'dispatch;
	}
	// 822AB850: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822AB854: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822AB858: 392B6A70  addi r9, r11, 0x6a70
	ctx.r[9].s64 = ctx.r[11].s64 + 27248;
	// 822AB85C: 390A1660  addi r8, r10, 0x1660
	ctx.r[8].s64 = ctx.r[10].s64 + 5728;
	// 822AB860: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822AB864: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 822AB868: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AB86C: 3943000C  addi r10, r3, 0xc
	ctx.r[10].s64 = ctx.r[3].s64 + 12;
	// 822AB870: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 822AB874: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 822AB878: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 822AB87C: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AB880: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 822AB884: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x822AB888; continue 'dispatch;
            }
            0x822AB888 => {
    //   block [0x822AB888..0x822AB8AC)
	// 822AB888: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AB88C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822AB890: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822AB894: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822AB898: 4200FFF0  bdnz 0x822ab888
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822AB888; continue 'dispatch;
	}
	// 822AB89C: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 822AB8A0: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822AB8A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AB8A8: 489FDBB4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822AB8AC => {
    //   block [0x822AB8AC..0x822AB8C0)
	// 822AB8AC: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 822AB8B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822AB8B4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822AB8B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AB8BC: 489FDBA0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AB8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AB8C0 size=188
    let mut pc: u32 = 0x822AB8C0;
    'dispatch: loop {
        match pc {
            0x822AB8C0 => {
    //   block [0x822AB8C0..0x822AB958)
	// 822AB8C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AB8C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AB8C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822AB8CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AB8D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AB8D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AB8D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822AB8DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AB8E0: 419A0080  beq cr6, 0x822ab960
	if ctx.cr[6].eq {
	pc = 0x822AB960; continue 'dispatch;
	}
	// 822AB8E4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AB8E8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 822AB8EC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AB8F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AB8F4: 4BF7D815  bl 0x82229108
	ctx.lr = 0x822AB8F8;
	sub_82229108(ctx, base);
	// 822AB8F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822AB8FC: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 822AB900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AB904: 4BF7CA85  bl 0x82228388
	ctx.lr = 0x822AB908;
	sub_82228388(ctx, base);
	// 822AB908: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AB90C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 822AB910: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 822AB914: 39099700  addi r8, r9, -0x6900
	ctx.r[8].s64 = ctx.r[9].s64 + -26880;
	// 822AB918: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822AB91C: 419A003C  beq cr6, 0x822ab958
	if ctx.cr[6].eq {
	pc = 0x822AB958; continue 'dispatch;
	}
	// 822AB920: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AB924: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 822AB928: 409A0030  bne cr6, 0x822ab958
	if !ctx.cr[6].eq {
	pc = 0x822AB958; continue 'dispatch;
	}
	// 822AB92C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822AB930: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822AB934: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822AB938: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822AB93C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 822AB940: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822AB944: 48546D2D  bl 0x827f2670
	ctx.lr = 0x822AB948;
	sub_827F2670(ctx, base);
	// 822AB948: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AB94C: 392BFFF0  addi r9, r11, -0x10
	ctx.r[9].s64 = ctx.r[11].s64 + -16;
	// 822AB950: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 822AB954: 48000010  b 0x822ab964
	pc = 0x822AB964; continue 'dispatch;
            }
            0x822AB958 => {
    //   block [0x822AB958..0x822AB960)
	// 822AB958: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 822AB95C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x822AB960; continue 'dispatch;
            }
            0x822AB960 => {
    //   block [0x822AB960..0x822AB964)
	// 822AB960: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	pc = 0x822AB964; continue 'dispatch;
            }
            0x822AB964 => {
    //   block [0x822AB964..0x822AB97C)
	// 822AB964: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AB968: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AB96C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AB970: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822AB974: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AB978: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AB980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822AB980 size=172
    let mut pc: u32 = 0x822AB980;
    'dispatch: loop {
        match pc {
            0x822AB980 => {
    //   block [0x822AB980..0x822AB9D0)
	// 822AB980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AB984: 489FDA89  bl 0x82ca940c
	ctx.lr = 0x822AB988;
	sub_82CA93D0(ctx, base);
	// 822AB988: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AB98C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822AB990: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822AB994: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822AB998: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AB99C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AB9A0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822AB9A4: 409A0070  bne cr6, 0x822aba14
	if !ctx.cr[6].eq {
	pc = 0x822ABA14; continue 'dispatch;
	}
	// 822AB9A8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 822AB9AC: 409A0024  bne cr6, 0x822ab9d0
	if !ctx.cr[6].eq {
	pc = 0x822AB9D0; continue 'dispatch;
	}
	// 822AB9B0: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AB9B4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822AB9B8: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822AB9BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822AB9C0: 41980064  blt cr6, 0x822aba24
	if ctx.cr[6].lt {
	pc = 0x822ABA24; continue 'dispatch;
	}
	// 822AB9C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822AB9C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AB9CC: 489FDA90  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822AB9D0 => {
    //   block [0x822AB9D0..0x822AB9F8)
	// 822AB9D0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 822AB9D4: 409A0024  bne cr6, 0x822ab9f8
	if !ctx.cr[6].eq {
	pc = 0x822AB9F8; continue 'dispatch;
	}
	// 822AB9D8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AB9DC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AB9E0: 48788B19  bl 0x82a344f8
	ctx.lr = 0x822AB9E4;
	sub_82A344F8(ctx, base);
	// 822AB9E4: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 822AB9E8: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822AB9EC: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822AB9F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AB9F4: 489FDA68  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822AB9F8 => {
    //   block [0x822AB9F8..0x822ABA14)
	// 822AB9F8: 38C0000D  li r6, 0xd
	ctx.r[6].s64 = 13;
	// 822AB9FC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822ABA00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822ABA04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822ABA08: 48926FD9  bl 0x82bd29e0
	ctx.lr = 0x822ABA0C;
	sub_82BD29E0(ctx, base);
	// 822ABA0C: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 822ABA10: 409A0014  bne cr6, 0x822aba24
	if !ctx.cr[6].eq {
	pc = 0x822ABA24; continue 'dispatch;
	}
	pc = 0x822ABA14; continue 'dispatch;
            }
            0x822ABA14 => {
    //   block [0x822ABA14..0x822ABA24)
	// 822ABA14: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822ABA18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822ABA1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822ABA20: 48924699  bl 0x82bd00b8
	ctx.lr = 0x822ABA24;
	sub_82BD00B8(ctx, base);
	pc = 0x822ABA24; continue 'dispatch;
            }
            0x822ABA24 => {
    //   block [0x822ABA24..0x822ABA2C)
	// 822ABA24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822ABA28: 489FDA34  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ABA30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ABA30 size=216
    let mut pc: u32 = 0x822ABA30;
    'dispatch: loop {
        match pc {
            0x822ABA30 => {
    //   block [0x822ABA30..0x822ABA74)
	// 822ABA30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ABA34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822ABA38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822ABA3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ABA40: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822ABA44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822ABA48: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822ABA4C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ABA50: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 822ABA54: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ABA58: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ABA5C: 54EA003E  slwi r10, r7, 0
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822ABA60: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ABA64: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822ABA68: 409A000C  bne cr6, 0x822aba74
	if !ctx.cr[6].eq {
	pc = 0x822ABA74; continue 'dispatch;
	}
	// 822ABA6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 822ABA70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822ABA74; continue 'dispatch;
            }
            0x822ABA74 => {
    //   block [0x822ABA74..0x822ABAE8)
	// 822ABA74: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ABA78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ABA7C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ABA80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822ABA84: 4E800421  bctrl
	ctx.lr = 0x822ABA88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ABA88: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 822ABA8C: 419A005C  beq cr6, 0x822abae8
	if ctx.cr[6].eq {
	pc = 0x822ABAE8; continue 'dispatch;
	}
	// 822ABA90: 2F030008  cmpwi cr6, r3, 8
	ctx.cr[6].compare_i32(ctx.r[3].s32, 8, &mut ctx.xer);
	// 822ABA94: 419A0054  beq cr6, 0x822abae8
	if ctx.cr[6].eq {
	pc = 0x822ABAE8; continue 'dispatch;
	}
	// 822ABA98: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 822ABA9C: 894B0023  lbz r10, 0x23(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(35 as u32) ) } as u64;
	// 822ABAA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ABAA4: 409A0044  bne cr6, 0x822abae8
	if !ctx.cr[6].eq {
	pc = 0x822ABAE8; continue 'dispatch;
	}
	// 822ABAA8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822ABAAC: C9BF0078  lfd f13, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	// 822ABAB0: C80B9610  lfd f0, -0x69f0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27120 as u32) ) };
	// 822ABAB4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822ABAB8: 4098003C  bge cr6, 0x822abaf4
	if !ctx.cr[6].lt {
	pc = 0x822ABAF4; continue 'dispatch;
	}
	// 822ABABC: 4BF72F8D  bl 0x8221ea48
	ctx.lr = 0x822ABAC0;
	sub_8221EA48(ctx, base);
	// 822ABAC0: C81F0070  lfd f0, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	// 822ABAC4: FDA10028  fsub f13, f1, f0
	ctx.f[13].f64 = ctx.f[1].f64 - ctx.f[0].f64;
	// 822ABAC8: C99F0078  lfd f12, 0x78(r31)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	// 822ABACC: FD6D602A  fadd f11, f13, f12
	ctx.f[11].f64 = ctx.f[13].f64 + ctx.f[12].f64;
	// 822ABAD0: D97F0078  stfd f11, 0x78(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.f[11].u64 ) };
	// 822ABAD4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822ABAD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822ABADC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822ABAE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822ABAE4: 4E800020  blr
	return;
            }
            0x822ABAE8 => {
    //   block [0x822ABAE8..0x822ABAF4)
	// 822ABAE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822ABAEC: C80B0D38  lfd f0, 0xd38(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 822ABAF0: D81F0078  stfd f0, 0x78(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.f[0].u64 ) };
	pc = 0x822ABAF4; continue 'dispatch;
            }
            0x822ABAF4 => {
    //   block [0x822ABAF4..0x822ABB08)
	// 822ABAF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822ABAF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822ABAFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822ABB00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822ABB04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ABB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ABB08 size=812
    let mut pc: u32 = 0x822ABB08;
    'dispatch: loop {
        match pc {
            0x822ABB08 => {
    //   block [0x822ABB08..0x822ABB50)
	// 822ABB08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ABB0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822ABB10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822ABB14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822ABB18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ABB1C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822ABB20: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822ABB24: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 822ABB28: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822ABB2C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ABB30: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822ABB34: 892A0034  lbz r9, 0x34(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 822ABB38: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822ABB3C: 419A0014  beq cr6, 0x822abb50
	if ctx.cr[6].eq {
	pc = 0x822ABB50; continue 'dispatch;
	}
	// 822ABB40: 894A0035  lbz r10, 0x35(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(53 as u32) ) } as u64;
	// 822ABB44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ABB48: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822ABB4C: 409A0008  bne cr6, 0x822abb54
	if !ctx.cr[6].eq {
	pc = 0x822ABB54; continue 'dispatch;
	}
	pc = 0x822ABB50; continue 'dispatch;
            }
            0x822ABB50 => {
    //   block [0x822ABB50..0x822ABB54)
	// 822ABB50: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x822ABB54; continue 'dispatch;
            }
            0x822ABB54 => {
    //   block [0x822ABB54..0x822ABB6C)
	// 822ABB54: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822ABB58: 806B009C  lwz r3, 0x9c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 822ABB5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822ABB60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ABB64: 409A0008  bne cr6, 0x822abb6c
	if !ctx.cr[6].eq {
	pc = 0x822ABB6C; continue 'dispatch;
	}
	// 822ABB68: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	pc = 0x822ABB6C; continue 'dispatch;
            }
            0x822ABB6C => {
    //   block [0x822ABB6C..0x822ABB94)
	// 822ABB6C: 4BFB86C5  bl 0x82264230
	ctx.lr = 0x822ABB70;
	sub_82264230(ctx, base);
	// 822ABB70: 3863000C  addi r3, r3, 0xc
	ctx.r[3].s64 = ctx.r[3].s64 + 12;
	// 822ABB74: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ABB78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ABB7C: 419A001C  beq cr6, 0x822abb98
	if ctx.cr[6].eq {
	pc = 0x822ABB98; continue 'dispatch;
	}
	// 822ABB80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ABB84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ABB88: 419A000C  beq cr6, 0x822abb94
	if ctx.cr[6].eq {
	pc = 0x822ABB94; continue 'dispatch;
	}
	// 822ABB8C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822ABB90: 4800000C  b 0x822abb9c
	pc = 0x822ABB9C; continue 'dispatch;
            }
            0x822ABB94 => {
    //   block [0x822ABB94..0x822ABB98)
	// 822ABB94: 4BEE82A5  bl 0x82193e38
	ctx.lr = 0x822ABB98;
	sub_82193E38(ctx, base);
	pc = 0x822ABB98; continue 'dispatch;
            }
            0x822ABB98 => {
    //   block [0x822ABB98..0x822ABB9C)
	// 822ABB98: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822ABB9C; continue 'dispatch;
            }
            0x822ABB9C => {
    //   block [0x822ABB9C..0x822ABBD8)
	// 822ABB9C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 822ABBA0: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 822ABBA4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822ABBA8: 419A00F4  beq cr6, 0x822abc9c
	if ctx.cr[6].eq {
	pc = 0x822ABC9C; continue 'dispatch;
	}
	// 822ABBAC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822ABBB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ABBB4: 419A0024  beq cr6, 0x822abbd8
	if ctx.cr[6].eq {
	pc = 0x822ABBD8; continue 'dispatch;
	}
	// 822ABBB8: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 822ABBBC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822ABBC0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822ABBC4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822ABBC8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ABBCC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822ABBD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ABBD4: 480000CC  b 0x822abca0
	pc = 0x822ABCA0; continue 'dispatch;
            }
            0x822ABBD8 => {
    //   block [0x822ABBD8..0x822ABBF4)
	// 822ABBD8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822ABBDC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822ABBE0: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 822ABBE4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822ABBE8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822ABBEC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822ABBF0: 40810054  ble 0x822abc44
	if !ctx.cr[0].gt {
	pc = 0x822ABC44; continue 'dispatch;
	}
	pc = 0x822ABBF4; continue 'dispatch;
            }
            0x822ABBF4 => {
    //   block [0x822ABBF4..0x822ABC14)
	// 822ABBF4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822ABBF8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822ABBFC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822ABC00: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ABC04: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 822ABC08: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822ABC0C: 41980008  blt cr6, 0x822abc14
	if ctx.cr[6].lt {
	pc = 0x822ABC14; continue 'dispatch;
	}
	// 822ABC10: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x822ABC14; continue 'dispatch;
            }
            0x822ABC14 => {
    //   block [0x822ABC14..0x822ABC30)
	// 822ABC14: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822ABC18: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822ABC1C: 419A0014  beq cr6, 0x822abc30
	if ctx.cr[6].eq {
	pc = 0x822ABC30; continue 'dispatch;
	}
	// 822ABC20: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822ABC24: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822ABC28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822ABC2C: 4800000C  b 0x822abc38
	pc = 0x822ABC38; continue 'dispatch;
            }
            0x822ABC30 => {
    //   block [0x822ABC30..0x822ABC38)
	// 822ABC30: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822ABC34: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822ABC38; continue 'dispatch;
            }
            0x822ABC38 => {
    //   block [0x822ABC38..0x822ABC44)
	// 822ABC38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822ABC3C: 4199FFB8  bgt cr6, 0x822abbf4
	if ctx.cr[6].gt {
	pc = 0x822ABBF4; continue 'dispatch;
	}
	// 822ABC40: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x822ABC44; continue 'dispatch;
            }
            0x822ABC44 => {
    //   block [0x822ABC44..0x822ABC60)
	// 822ABC44: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822ABC48: 419A0040  beq cr6, 0x822abc88
	if ctx.cr[6].eq {
	pc = 0x822ABC88; continue 'dispatch;
	}
	// 822ABC4C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ABC50: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 822ABC54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ABC58: 41990008  bgt cr6, 0x822abc60
	if ctx.cr[6].gt {
	pc = 0x822ABC60; continue 'dispatch;
	}
	// 822ABC5C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822ABC60; continue 'dispatch;
            }
            0x822ABC60 => {
    //   block [0x822ABC60..0x822ABC88)
	// 822ABC60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822ABC64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ABC68: 409A0020  bne cr6, 0x822abc88
	if !ctx.cr[6].eq {
	pc = 0x822ABC88; continue 'dispatch;
	}
	// 822ABC6C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822ABC70: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822ABC74: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822ABC78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ABC7C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822ABC80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ABC84: 4800001C  b 0x822abca0
	pc = 0x822ABCA0; continue 'dispatch;
            }
            0x822ABC88 => {
    //   block [0x822ABC88..0x822ABC9C)
	// 822ABC88: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822ABC8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ABC90: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822ABC94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ABC98: 48000008  b 0x822abca0
	pc = 0x822ABCA0; continue 'dispatch;
            }
            0x822ABC9C => {
    //   block [0x822ABC9C..0x822ABCA0)
	// 822ABC9C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822ABCA0; continue 'dispatch;
            }
            0x822ABCA0 => {
    //   block [0x822ABCA0..0x822ABCD0)
	// 822ABCA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822ABCA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ABCA8: 419A0170  beq cr6, 0x822abe18
	if ctx.cr[6].eq {
	pc = 0x822ABE18; continue 'dispatch;
	}
	// 822ABCAC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822ABCB0: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822ABCB4: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 822ABCB8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ABCBC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822ABCC0: 419A0158  beq cr6, 0x822abe18
	if ctx.cr[6].eq {
	pc = 0x822ABE18; continue 'dispatch;
	}
	// 822ABCC4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822ABCC8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 822ABCCC: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x822ABCD0; continue 'dispatch;
            }
            0x822ABCD0 => {
    //   block [0x822ABCD0..0x822ABCF8)
	// 822ABCD0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822ABCD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822ABCD8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822ABCDC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822ABCE0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822ABCE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822ABCE8: 4082FFE8  bne 0x822abcd0
	if !ctx.cr[0].eq {
	pc = 0x822ABCD0; continue 'dispatch;
	}
	// 822ABCEC: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 822ABCF0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 822ABCF4: 3886708C  addi r4, r6, 0x708c
	ctx.r[4].s64 = ctx.r[6].s64 + 28812;
	pc = 0x822ABCF8; continue 'dispatch;
            }
            0x822ABCF8 => {
    //   block [0x822ABCF8..0x822ABD84)
	// 822ABCF8: 7CA000A6  mfmsr r5
	ctx.r[5].u64 = ctx.msr;
	// 822ABCFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822ABD00: 7CE02028  lwarx r7, 0, r4
	// lwarx
	let ea = ctx.r[4].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 822ABD04: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 822ABD08: 7CE0212D  stwcx. r7, 0, r4
	// stwcx.
	let addr = ctx.r[4].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822ABD0C: 7CA10164  mtmsrd r5, 1
	ctx.msr = (ctx.r[5].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822ABD10: 4082FFE8  bne 0x822abcf8
	if !ctx.cr[0].eq {
	pc = 0x822ABCF8; continue 'dispatch;
	}
	// 822ABD14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ABD18: 4BF42631  bl 0x821ee348
	ctx.lr = 0x822ABD1C;
	sub_821EE348(ctx, base);
	// 822ABD1C: 5463063E  clrlwi r3, r3, 0x18
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822ABD20: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822ABD24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822ABD28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822ABD2C: 419A0058  beq cr6, 0x822abd84
	if ctx.cr[6].eq {
	pc = 0x822ABD84; continue 'dispatch;
	}
	// 822ABD30: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822ABD34: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 822ABD38: 388B0350  addi r4, r11, 0x350
	ctx.r[4].s64 = ctx.r[11].s64 + 848;
	// 822ABD3C: 4BF81195  bl 0x8222ced0
	ctx.lr = 0x822ABD40;
	sub_8222CED0(ctx, base);
	// 822ABD40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822ABD44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822ABD48: 4BF444F9  bl 0x821f0240
	ctx.lr = 0x822ABD4C;
	sub_821F0240(ctx, base);
	// 822ABD4C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822ABD50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822ABD54: 388A04E8  addi r4, r10, 0x4e8
	ctx.r[4].s64 = ctx.r[10].s64 + 1256;
	// 822ABD58: 4BF2EC69  bl 0x821da9c0
	ctx.lr = 0x822ABD5C;
	sub_821DA9C0(ctx, base);
	// 822ABD5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822ABD60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822ABD64: 4BFB943D  bl 0x822651a0
	ctx.lr = 0x822ABD68;
	sub_822651A0(ctx, base);
	// 822ABD68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822ABD6C: 4BF6906D  bl 0x82214dd8
	ctx.lr = 0x822ABD70;
	sub_82214DD8(ctx, base);
	// 822ABD70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822ABD74: 4BF69065  bl 0x82214dd8
	ctx.lr = 0x822ABD78;
	sub_82214DD8(ctx, base);
	// 822ABD78: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822ABD7C: 38890374  addi r4, r9, 0x374
	ctx.r[4].s64 = ctx.r[9].s64 + 884;
	// 822ABD80: 48000054  b 0x822abdd4
	pc = 0x822ABDD4; continue 'dispatch;
            }
            0x822ABD84 => {
    //   block [0x822ABD84..0x822ABDD4)
	// 822ABD84: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822ABD88: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 822ABD8C: 388B0330  addi r4, r11, 0x330
	ctx.r[4].s64 = ctx.r[11].s64 + 816;
	// 822ABD90: 4BF81141  bl 0x8222ced0
	ctx.lr = 0x822ABD94;
	sub_8222CED0(ctx, base);
	// 822ABD94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822ABD98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822ABD9C: 4BF444A5  bl 0x821f0240
	ctx.lr = 0x822ABDA0;
	sub_821F0240(ctx, base);
	// 822ABDA0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822ABDA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822ABDA8: 388A04E8  addi r4, r10, 0x4e8
	ctx.r[4].s64 = ctx.r[10].s64 + 1256;
	// 822ABDAC: 4BF2EC15  bl 0x821da9c0
	ctx.lr = 0x822ABDB0;
	sub_821DA9C0(ctx, base);
	// 822ABDB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822ABDB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822ABDB8: 4BFB93E9  bl 0x822651a0
	ctx.lr = 0x822ABDBC;
	sub_822651A0(ctx, base);
	// 822ABDBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822ABDC0: 4BF69019  bl 0x82214dd8
	ctx.lr = 0x822ABDC4;
	sub_82214DD8(ctx, base);
	// 822ABDC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822ABDC8: 4BF69011  bl 0x82214dd8
	ctx.lr = 0x822ABDCC;
	sub_82214DD8(ctx, base);
	// 822ABDCC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 822ABDD0: 38890388  addi r4, r9, 0x388
	ctx.r[4].s64 = ctx.r[9].s64 + 904;
	pc = 0x822ABDD4; continue 'dispatch;
            }
            0x822ABDD4 => {
    //   block [0x822ABDD4..0x822ABE18)
	// 822ABDD4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822ABDD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822ABDDC: 4BF810F5  bl 0x8222ced0
	ctx.lr = 0x822ABDE0;
	sub_8222CED0(ctx, base);
	// 822ABDE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822ABDE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822ABDE8: 48062301  bl 0x8230e0e8
	ctx.lr = 0x822ABDEC;
	sub_8230E0E8(ctx, base);
	// 822ABDEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822ABDF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822ABDF4: 4800CAB5  bl 0x822b88a8
	ctx.lr = 0x822ABDF8;
	sub_822B88A8(ctx, base);
	// 822ABDF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822ABDFC: 4BF1A9FD  bl 0x821c67f8
	ctx.lr = 0x822ABE00;
	sub_821C67F8(ctx, base);
	// 822ABE00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822ABE04: 4BF1A9F5  bl 0x821c67f8
	ctx.lr = 0x822ABE08;
	sub_821C67F8(ctx, base);
	// 822ABE08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822ABE0C: 4BF68FCD  bl 0x82214dd8
	ctx.lr = 0x822ABE10;
	sub_82214DD8(ctx, base);
	// 822ABE10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ABE14: 48000008  b 0x822abe1c
	pc = 0x822ABE1C; continue 'dispatch;
            }
            0x822ABE18 => {
    //   block [0x822ABE18..0x822ABE1C)
	// 822ABE18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x822ABE1C; continue 'dispatch;
            }
            0x822ABE1C => {
    //   block [0x822ABE1C..0x822ABE34)
	// 822ABE1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822ABE20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822ABE24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822ABE28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822ABE2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822ABE30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ABE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822ABE38 size=2632
    let mut pc: u32 = 0x822ABE38;
    'dispatch: loop {
        match pc {
            0x822ABE38 => {
    //   block [0x822ABE38..0x822ABE90)
	// 822ABE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ABE3C: 489FD5C5  bl 0x82ca9400
	ctx.lr = 0x822ABE40;
	sub_82CA93D0(ctx, base);
	// 822ABE40: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ABE44: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 822ABE48: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822ABE4C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822ABE50: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822ABE54: 80BB6AB8  lwz r5, 0x6ab8(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822ABE58: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ABE5C: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ABE60: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822ABE64: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ABE68: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ABE6C: 386B0070  addi r3, r11, 0x70
	ctx.r[3].s64 = ctx.r[11].s64 + 112;
	// 822ABE70: 816B0074  lwz r11, 0x74(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 822ABE74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ABE78: 419A0020  beq cr6, 0x822abe98
	if ctx.cr[6].eq {
	pc = 0x822ABE98; continue 'dispatch;
	}
	// 822ABE7C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ABE80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ABE84: 419A000C  beq cr6, 0x822abe90
	if ctx.cr[6].eq {
	pc = 0x822ABE90; continue 'dispatch;
	}
	// 822ABE88: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822ABE8C: 48000010  b 0x822abe9c
	pc = 0x822ABE9C; continue 'dispatch;
            }
            0x822ABE90 => {
    //   block [0x822ABE90..0x822ABE98)
	// 822ABE90: 4BEE7FA9  bl 0x82193e38
	ctx.lr = 0x822ABE94;
	sub_82193E38(ctx, base);
	// 822ABE94: 80BB6AB8  lwz r5, 0x6ab8(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	pc = 0x822ABE98; continue 'dispatch;
            }
            0x822ABE98 => {
    //   block [0x822ABE98..0x822ABE9C)
	// 822ABE98: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822ABE9C; continue 'dispatch;
            }
            0x822ABE9C => {
    //   block [0x822ABE9C..0x822ABEC8)
	// 822ABE9C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822ABEA0: 409A09D8  bne cr6, 0x822ac878
	if !ctx.cr[6].eq {
	pc = 0x822AC878; continue 'dispatch;
	}
	// 822ABEA4: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ABEA8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822ABEAC: 894B0034  lbz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 822ABEB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ABEB4: 419A0014  beq cr6, 0x822abec8
	if ctx.cr[6].eq {
	pc = 0x822ABEC8; continue 'dispatch;
	}
	// 822ABEB8: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 822ABEBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ABEC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ABEC4: 409A0008  bne cr6, 0x822abecc
	if !ctx.cr[6].eq {
	pc = 0x822ABECC; continue 'dispatch;
	}
	pc = 0x822ABEC8; continue 'dispatch;
            }
            0x822ABEC8 => {
    //   block [0x822ABEC8..0x822ABECC)
	// 822ABEC8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822ABECC; continue 'dispatch;
            }
            0x822ABECC => {
    //   block [0x822ABECC..0x822ABF18)
	// 822ABECC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822ABED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ABED4: 419A0624  beq cr6, 0x822ac4f8
	if ctx.cr[6].eq {
	pc = 0x822AC4F8; continue 'dispatch;
	}
	// 822ABED8: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ABEDC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 822ABEE0: 81440024  lwz r10, 0x24(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 822ABEE4: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 822ABEE8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822ABEEC: 419A00E8  beq cr6, 0x822abfd4
	if ctx.cr[6].eq {
	pc = 0x822ABFD4; continue 'dispatch;
	}
	// 822ABEF0: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 822ABEF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ABEF8: 419A0020  beq cr6, 0x822abf18
	if ctx.cr[6].eq {
	pc = 0x822ABF18; continue 'dispatch;
	}
	// 822ABEFC: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822ABF00: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 822ABF04: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822ABF08: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822ABF0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822ABF10: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ABF14: 480000C4  b 0x822abfd8
	pc = 0x822ABFD8; continue 'dispatch;
            }
            0x822ABF18 => {
    //   block [0x822ABF18..0x822ABF34)
	// 822ABF18: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 822ABF1C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 822ABF20: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 822ABF24: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822ABF28: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822ABF2C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822ABF30: 40810054  ble 0x822abf84
	if !ctx.cr[0].gt {
	pc = 0x822ABF84; continue 'dispatch;
	}
	pc = 0x822ABF34; continue 'dispatch;
            }
            0x822ABF34 => {
    //   block [0x822ABF34..0x822ABF54)
	// 822ABF34: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822ABF38: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822ABF3C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822ABF40: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ABF44: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 822ABF48: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822ABF4C: 41980008  blt cr6, 0x822abf54
	if ctx.cr[6].lt {
	pc = 0x822ABF54; continue 'dispatch;
	}
	// 822ABF50: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x822ABF54; continue 'dispatch;
            }
            0x822ABF54 => {
    //   block [0x822ABF54..0x822ABF70)
	// 822ABF54: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822ABF58: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822ABF5C: 419A0014  beq cr6, 0x822abf70
	if ctx.cr[6].eq {
	pc = 0x822ABF70; continue 'dispatch;
	}
	// 822ABF60: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822ABF64: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822ABF68: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822ABF6C: 4800000C  b 0x822abf78
	pc = 0x822ABF78; continue 'dispatch;
            }
            0x822ABF70 => {
    //   block [0x822ABF70..0x822ABF78)
	// 822ABF70: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822ABF74: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822ABF78; continue 'dispatch;
            }
            0x822ABF78 => {
    //   block [0x822ABF78..0x822ABF84)
	// 822ABF78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822ABF7C: 4199FFB8  bgt cr6, 0x822abf34
	if ctx.cr[6].gt {
	pc = 0x822ABF34; continue 'dispatch;
	}
	// 822ABF80: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x822ABF84; continue 'dispatch;
            }
            0x822ABF84 => {
    //   block [0x822ABF84..0x822ABFA0)
	// 822ABF84: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822ABF88: 419A003C  beq cr6, 0x822abfc4
	if ctx.cr[6].eq {
	pc = 0x822ABFC4; continue 'dispatch;
	}
	// 822ABF8C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ABF90: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 822ABF94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ABF98: 41990008  bgt cr6, 0x822abfa0
	if ctx.cr[6].gt {
	pc = 0x822ABFA0; continue 'dispatch;
	}
	// 822ABF9C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822ABFA0; continue 'dispatch;
            }
            0x822ABFA0 => {
    //   block [0x822ABFA0..0x822ABFC4)
	// 822ABFA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822ABFA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ABFA8: 409A001C  bne cr6, 0x822abfc4
	if !ctx.cr[6].eq {
	pc = 0x822ABFC4; continue 'dispatch;
	}
	// 822ABFAC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822ABFB0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822ABFB4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822ABFB8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822ABFBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ABFC0: 48000018  b 0x822abfd8
	pc = 0x822ABFD8; continue 'dispatch;
            }
            0x822ABFC4 => {
    //   block [0x822ABFC4..0x822ABFD4)
	// 822ABFC4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822ABFC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822ABFCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ABFD0: 48000008  b 0x822abfd8
	pc = 0x822ABFD8; continue 'dispatch;
            }
            0x822ABFD4 => {
    //   block [0x822ABFD4..0x822ABFD8)
	// 822ABFD4: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x822ABFD8; continue 'dispatch;
            }
            0x822ABFD8 => {
    //   block [0x822ABFD8..0x822AC04C)
	// 822ABFD8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822ABFDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ABFE0: 419A0898  beq cr6, 0x822ac878
	if ctx.cr[6].eq {
	pc = 0x822AC878; continue 'dispatch;
	}
	// 822ABFE4: 896B0019  lbz r11, 0x19(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 822ABFE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ABFEC: 419A027C  beq cr6, 0x822ac268
	if ctx.cr[6].eq {
	pc = 0x822AC268; continue 'dispatch;
	}
	// 822ABFF0: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 822ABFF4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 822ABFF8: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 822ABFFC: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 822AC000: 9341006C  stw r26, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[26].u32 ) };
	// 822AC004: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AC008: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 822AC00C: E9440014  ld r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	// 822AC010: 38800052  li r4, 0x52
	ctx.r[4].s64 = 82;
	// 822AC014: 80FC0120  lwz r7, 0x120(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(288 as u32) ) } as u64;
	// 822AC018: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 822AC01C: 812B0058  lwz r9, 0x58(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822AC020: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC024: 80680010  lwz r3, 0x10(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 822AC028: 480F3019  bl 0x8239f040
	ctx.lr = 0x822AC02C;
	sub_8239F040(ctx, base);
	// 822AC02C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822AC030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC034: 419A0018  beq cr6, 0x822ac04c
	if ctx.cr[6].eq {
	pc = 0x822AC04C; continue 'dispatch;
	}
	// 822AC038: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 822AC03C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822AC040: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AC044: 41820008  beq 0x822ac04c
	if ctx.cr[0].eq {
	pc = 0x822AC04C; continue 'dispatch;
	}
	// 822AC048: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x822AC04C; continue 'dispatch;
            }
            0x822AC04C => {
    //   block [0x822AC04C..0x822AC0B0)
	// 822AC04C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822AC050: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 822AC054: 4BF05B55  bl 0x821b1ba8
	ctx.lr = 0x822AC058;
	sub_821B1BA8(ctx, base);
	// 822AC058: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822AC05C: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC060: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 822AC064: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 822AC068: 80FC0120  lwz r7, 0x120(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(288 as u32) ) } as u64;
	// 822AC06C: 38800050  li r4, 0x50
	ctx.r[4].s64 = 80;
	// 822AC070: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AC074: E90A0014  ld r8, 0x14(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	// 822AC078: 80690058  lwz r3, 0x58(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 822AC07C: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 822AC080: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC084: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822AC088: 480F2FB9  bl 0x8239f040
	ctx.lr = 0x822AC08C;
	sub_8239F040(ctx, base);
	// 822AC08C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822AC090: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC094: 419A001C  beq cr6, 0x822ac0b0
	if ctx.cr[6].eq {
	pc = 0x822AC0B0; continue 'dispatch;
	}
	// 822AC098: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 822AC09C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822AC0A0: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AC0A4: 4182000C  beq 0x822ac0b0
	if ctx.cr[0].eq {
	pc = 0x822AC0B0; continue 'dispatch;
	}
	// 822AC0A8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 822AC0AC: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	pc = 0x822AC0B0; continue 'dispatch;
            }
            0x822AC0B0 => {
    //   block [0x822AC0B0..0x822AC0D0)
	// 822AC0B0: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 822AC0B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC0B8: 409A0018  bne cr6, 0x822ac0d0
	if !ctx.cr[6].eq {
	pc = 0x822AC0D0; continue 'dispatch;
	}
	// 822AC0BC: 57AA063E  clrlwi r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 822AC0C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AC0C4: 419A0194  beq cr6, 0x822ac258
	if ctx.cr[6].eq {
	pc = 0x822AC258; continue 'dispatch;
	}
	// 822AC0C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC0CC: 419A0024  beq cr6, 0x822ac0f0
	if ctx.cr[6].eq {
	pc = 0x822AC0F0; continue 'dispatch;
	}
	pc = 0x822AC0D0; continue 'dispatch;
            }
            0x822AC0D0 => {
    //   block [0x822AC0D0..0x822AC0F0)
	// 822AC0D0: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822AC0D4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AC0D8: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822AC0DC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC0E0: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 822AC0E4: 81680454  lwz r11, 0x454(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(1108 as u32) ) } as u64;
	// 822AC0E8: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 822AC0EC: 90FC0120  stw r7, 0x120(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(288 as u32), ctx.r[7].u32 ) };
	pc = 0x822AC0F0; continue 'dispatch;
            }
            0x822AC0F0 => {
    //   block [0x822AC0F0..0x822AC13C)
	// 822AC0F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822AC0F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822AC0F8: 480F1C61  bl 0x8239dd58
	ctx.lr = 0x822AC0FC;
	sub_8239DD58(ctx, base);
	// 822AC0FC: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC100: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AC104: 81650028  lwz r11, 0x28(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 822AC108: 556AE7FE  rlwinm r10, r11, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 822AC10C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AC110: 419A00E8  beq cr6, 0x822ac1f8
	if ctx.cr[6].eq {
	pc = 0x822AC1F8; continue 'dispatch;
	}
	// 822AC114: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AC118: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC11C: 419A0020  beq cr6, 0x822ac13c
	if ctx.cr[6].eq {
	pc = 0x822AC13C; continue 'dispatch;
	}
	// 822AC120: 894B0024  lbz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822AC124: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AC128: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822AC12C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822AC130: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC134: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC138: 480000C4  b 0x822ac1fc
	pc = 0x822AC1FC; continue 'dispatch;
            }
            0x822AC13C => {
    //   block [0x822AC13C..0x822AC158)
	// 822AC13C: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AC140: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AC144: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 822AC148: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822AC14C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822AC150: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AC154: 40810054  ble 0x822ac1a8
	if !ctx.cr[0].gt {
	pc = 0x822AC1A8; continue 'dispatch;
	}
	pc = 0x822AC158; continue 'dispatch;
            }
            0x822AC158 => {
    //   block [0x822AC158..0x822AC178)
	// 822AC158: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AC15C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AC160: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822AC164: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC168: 2F070024  cmpwi cr6, r7, 0x24
	ctx.cr[6].compare_i32(ctx.r[7].s32, 36, &mut ctx.xer);
	// 822AC16C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AC170: 41980008  blt cr6, 0x822ac178
	if ctx.cr[6].lt {
	pc = 0x822AC178; continue 'dispatch;
	}
	// 822AC174: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x822AC178; continue 'dispatch;
            }
            0x822AC178 => {
    //   block [0x822AC178..0x822AC194)
	// 822AC178: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AC17C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AC180: 419A0014  beq cr6, 0x822ac194
	if ctx.cr[6].eq {
	pc = 0x822AC194; continue 'dispatch;
	}
	// 822AC184: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AC188: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AC18C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AC190: 4800000C  b 0x822ac19c
	pc = 0x822AC19C; continue 'dispatch;
            }
            0x822AC194 => {
    //   block [0x822AC194..0x822AC19C)
	// 822AC194: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AC198: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822AC19C; continue 'dispatch;
            }
            0x822AC19C => {
    //   block [0x822AC19C..0x822AC1A8)
	// 822AC19C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AC1A0: 4199FFB8  bgt cr6, 0x822ac158
	if ctx.cr[6].gt {
	pc = 0x822AC158; continue 'dispatch;
	}
	// 822AC1A4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x822AC1A8; continue 'dispatch;
            }
            0x822AC1A8 => {
    //   block [0x822AC1A8..0x822AC1C4)
	// 822AC1A8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AC1AC: 419A003C  beq cr6, 0x822ac1e8
	if ctx.cr[6].eq {
	pc = 0x822AC1E8; continue 'dispatch;
	}
	// 822AC1B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC1B4: 2F0B0024  cmpwi cr6, r11, 0x24
	ctx.cr[6].compare_i32(ctx.r[11].s32, 36, &mut ctx.xer);
	// 822AC1B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC1BC: 41990008  bgt cr6, 0x822ac1c4
	if ctx.cr[6].gt {
	pc = 0x822AC1C4; continue 'dispatch;
	}
	// 822AC1C0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822AC1C4; continue 'dispatch;
            }
            0x822AC1C4 => {
    //   block [0x822AC1C4..0x822AC1E8)
	// 822AC1C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AC1C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC1CC: 409A001C  bne cr6, 0x822ac1e8
	if !ctx.cr[6].eq {
	pc = 0x822AC1E8; continue 'dispatch;
	}
	// 822AC1D0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822AC1D4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822AC1D8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822AC1DC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC1E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC1E4: 48000018  b 0x822ac1fc
	pc = 0x822AC1FC; continue 'dispatch;
            }
            0x822AC1E8 => {
    //   block [0x822AC1E8..0x822AC1F8)
	// 822AC1E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822AC1EC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC1F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC1F4: 48000008  b 0x822ac1fc
	pc = 0x822AC1FC; continue 'dispatch;
            }
            0x822AC1F8 => {
    //   block [0x822AC1F8..0x822AC1FC)
	// 822AC1F8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822AC1FC; continue 'dispatch;
            }
            0x822AC1FC => {
    //   block [0x822AC1FC..0x822AC218)
	// 822AC1FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AC200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC204: 419A0014  beq cr6, 0x822ac218
	if ctx.cr[6].eq {
	pc = 0x822AC218; continue 'dispatch;
	}
	// 822AC208: C003001C  lfs f0, 0x1c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AC20C: C1A30014  lfs f13, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822AC210: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822AC214: 4821FA55  bl 0x824cbc68
	ctx.lr = 0x822AC218;
	sub_824CBC68(ctx, base);
	pc = 0x822AC218; continue 'dispatch;
            }
            0x822AC218 => {
    //   block [0x822AC218..0x822AC258)
	// 822AC218: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822AC21C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AC220: 812A011C  lwz r9, 0x11c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(284 as u32) ) } as u64;
	// 822AC224: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 822AC228: 409A0030  bne cr6, 0x822ac258
	if !ctx.cr[6].eq {
	pc = 0x822AC258; continue 'dispatch;
	}
	// 822AC22C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822AC230: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822AC234: 392A60F0  addi r9, r10, 0x60f0
	ctx.r[9].s64 = ctx.r[10].s64 + 24816;
	// 822AC238: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822AC23C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 822AC240: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AC244: 8068008C  lwz r3, 0x8c(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AC248: 480F2EF1  bl 0x8239f138
	ctx.lr = 0x822AC24C;
	sub_8239F138(ctx, base);
	// 822AC24C: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 822AC250: 38C72DC8  addi r6, r7, 0x2dc8
	ctx.r[6].s64 = ctx.r[7].s64 + 11720;
	// 822AC254: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	pc = 0x822AC258; continue 'dispatch;
            }
            0x822AC258 => {
    //   block [0x822AC258..0x822AC268)
	// 822AC258: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822AC25C: 4830DD05  bl 0x825b9f60
	ctx.lr = 0x822AC260;
	sub_825B9F60(ctx, base);
	// 822AC260: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822AC264: 489FD1EC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x822AC268 => {
    //   block [0x822AC268..0x822AC2A4)
	// 822AC268: 81440028  lwz r10, 0x28(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 822AC26C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 822AC270: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 822AC274: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822AC278: 419A00E8  beq cr6, 0x822ac360
	if ctx.cr[6].eq {
	pc = 0x822AC360; continue 'dispatch;
	}
	// 822AC27C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AC280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC284: 419A0020  beq cr6, 0x822ac2a4
	if ctx.cr[6].eq {
	pc = 0x822AC2A4; continue 'dispatch;
	}
	// 822AC288: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822AC28C: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AC290: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822AC294: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822AC298: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822AC29C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC2A0: 480000C4  b 0x822ac364
	pc = 0x822AC364; continue 'dispatch;
            }
            0x822AC2A4 => {
    //   block [0x822AC2A4..0x822AC2C0)
	// 822AC2A4: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AC2A8: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AC2AC: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 822AC2B0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822AC2B4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822AC2B8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AC2BC: 40810054  ble 0x822ac310
	if !ctx.cr[0].gt {
	pc = 0x822AC310; continue 'dispatch;
	}
	pc = 0x822AC2C0; continue 'dispatch;
            }
            0x822AC2C0 => {
    //   block [0x822AC2C0..0x822AC2E0)
	// 822AC2C0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AC2C4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AC2C8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822AC2CC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC2D0: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 822AC2D4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AC2D8: 41980008  blt cr6, 0x822ac2e0
	if ctx.cr[6].lt {
	pc = 0x822AC2E0; continue 'dispatch;
	}
	// 822AC2DC: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x822AC2E0; continue 'dispatch;
            }
            0x822AC2E0 => {
    //   block [0x822AC2E0..0x822AC2FC)
	// 822AC2E0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AC2E4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AC2E8: 419A0014  beq cr6, 0x822ac2fc
	if ctx.cr[6].eq {
	pc = 0x822AC2FC; continue 'dispatch;
	}
	// 822AC2EC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AC2F0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AC2F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AC2F8: 4800000C  b 0x822ac304
	pc = 0x822AC304; continue 'dispatch;
            }
            0x822AC2FC => {
    //   block [0x822AC2FC..0x822AC304)
	// 822AC2FC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AC300: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822AC304; continue 'dispatch;
            }
            0x822AC304 => {
    //   block [0x822AC304..0x822AC310)
	// 822AC304: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AC308: 4199FFB8  bgt cr6, 0x822ac2c0
	if ctx.cr[6].gt {
	pc = 0x822AC2C0; continue 'dispatch;
	}
	// 822AC30C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x822AC310; continue 'dispatch;
            }
            0x822AC310 => {
    //   block [0x822AC310..0x822AC32C)
	// 822AC310: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AC314: 419A003C  beq cr6, 0x822ac350
	if ctx.cr[6].eq {
	pc = 0x822AC350; continue 'dispatch;
	}
	// 822AC318: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC31C: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 822AC320: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC324: 41990008  bgt cr6, 0x822ac32c
	if ctx.cr[6].gt {
	pc = 0x822AC32C; continue 'dispatch;
	}
	// 822AC328: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822AC32C; continue 'dispatch;
            }
            0x822AC32C => {
    //   block [0x822AC32C..0x822AC350)
	// 822AC32C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AC330: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC334: 409A001C  bne cr6, 0x822ac350
	if !ctx.cr[6].eq {
	pc = 0x822AC350; continue 'dispatch;
	}
	// 822AC338: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822AC33C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822AC340: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822AC344: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822AC348: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC34C: 48000018  b 0x822ac364
	pc = 0x822AC364; continue 'dispatch;
            }
            0x822AC350 => {
    //   block [0x822AC350..0x822AC360)
	// 822AC350: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822AC354: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822AC358: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC35C: 48000008  b 0x822ac364
	pc = 0x822AC364; continue 'dispatch;
            }
            0x822AC360 => {
    //   block [0x822AC360..0x822AC364)
	// 822AC360: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x822AC364; continue 'dispatch;
            }
            0x822AC364 => {
    //   block [0x822AC364..0x822AC388)
	// 822AC364: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822AC368: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AC36C: 419A050C  beq cr6, 0x822ac878
	if ctx.cr[6].eq {
	pc = 0x822AC878; continue 'dispatch;
	}
	// 822AC370: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822AC374: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822AC378: 419A0010  beq cr6, 0x822ac388
	if ctx.cr[6].eq {
	pc = 0x822AC388; continue 'dispatch;
	}
	// 822AC37C: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 822AC380: 4BF3C811  bl 0x821e8b90
	ctx.lr = 0x822AC384;
	sub_821E8B90(ctx, base);
	// 822AC384: 48000008  b 0x822ac38c
	pc = 0x822AC38C; continue 'dispatch;
            }
            0x822AC388 => {
    //   block [0x822AC388..0x822AC38C)
	// 822AC388: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x822AC38C; continue 'dispatch;
            }
            0x822AC38C => {
    //   block [0x822AC38C..0x822AC3E4)
	// 822AC38C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822AC390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC394: 419A04E4  beq cr6, 0x822ac878
	if ctx.cr[6].eq {
	pc = 0x822AC878; continue 'dispatch;
	}
	// 822AC398: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822AC39C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822AC3A0: 480F19B9  bl 0x8239dd58
	ctx.lr = 0x822AC3A4;
	sub_8239DD58(ctx, base);
	// 822AC3A4: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC3A8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AC3AC: 81650028  lwz r11, 0x28(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 822AC3B0: 556AE7FE  rlwinm r10, r11, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 822AC3B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AC3B8: 419A00E4  beq cr6, 0x822ac49c
	if ctx.cr[6].eq {
	pc = 0x822AC49C; continue 'dispatch;
	}
	// 822AC3BC: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AC3C0: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AC3C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC3C8: 419A001C  beq cr6, 0x822ac3e4
	if ctx.cr[6].eq {
	pc = 0x822AC3E4; continue 'dispatch;
	}
	// 822AC3CC: 896B0024  lbz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822AC3D0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 822AC3D4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822AC3D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC3DC: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC3E0: 480000C0  b 0x822ac4a0
	pc = 0x822AC4A0; continue 'dispatch;
            }
            0x822AC3E4 => {
    //   block [0x822AC3E4..0x822AC3FC)
	// 822AC3E4: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AC3E8: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 822AC3EC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822AC3F0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822AC3F4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AC3F8: 40810054  ble 0x822ac44c
	if !ctx.cr[0].gt {
	pc = 0x822AC44C; continue 'dispatch;
	}
	pc = 0x822AC3FC; continue 'dispatch;
            }
            0x822AC3FC => {
    //   block [0x822AC3FC..0x822AC41C)
	// 822AC3FC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AC400: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AC404: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822AC408: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC40C: 2F070024  cmpwi cr6, r7, 0x24
	ctx.cr[6].compare_i32(ctx.r[7].s32, 36, &mut ctx.xer);
	// 822AC410: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AC414: 41980008  blt cr6, 0x822ac41c
	if ctx.cr[6].lt {
	pc = 0x822AC41C; continue 'dispatch;
	}
	// 822AC418: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x822AC41C; continue 'dispatch;
            }
            0x822AC41C => {
    //   block [0x822AC41C..0x822AC438)
	// 822AC41C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AC420: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AC424: 419A0014  beq cr6, 0x822ac438
	if ctx.cr[6].eq {
	pc = 0x822AC438; continue 'dispatch;
	}
	// 822AC428: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AC42C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AC430: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AC434: 4800000C  b 0x822ac440
	pc = 0x822AC440; continue 'dispatch;
            }
            0x822AC438 => {
    //   block [0x822AC438..0x822AC440)
	// 822AC438: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AC43C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822AC440; continue 'dispatch;
            }
            0x822AC440 => {
    //   block [0x822AC440..0x822AC44C)
	// 822AC440: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AC444: 4199FFB8  bgt cr6, 0x822ac3fc
	if ctx.cr[6].gt {
	pc = 0x822AC3FC; continue 'dispatch;
	}
	// 822AC448: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x822AC44C; continue 'dispatch;
            }
            0x822AC44C => {
    //   block [0x822AC44C..0x822AC468)
	// 822AC44C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AC450: 419A003C  beq cr6, 0x822ac48c
	if ctx.cr[6].eq {
	pc = 0x822AC48C; continue 'dispatch;
	}
	// 822AC454: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC458: 2F0B0024  cmpwi cr6, r11, 0x24
	ctx.cr[6].compare_i32(ctx.r[11].s32, 36, &mut ctx.xer);
	// 822AC45C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC460: 41990008  bgt cr6, 0x822ac468
	if ctx.cr[6].gt {
	pc = 0x822AC468; continue 'dispatch;
	}
	// 822AC464: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822AC468; continue 'dispatch;
            }
            0x822AC468 => {
    //   block [0x822AC468..0x822AC48C)
	// 822AC468: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AC46C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC470: 409A001C  bne cr6, 0x822ac48c
	if !ctx.cr[6].eq {
	pc = 0x822AC48C; continue 'dispatch;
	}
	// 822AC474: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822AC478: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822AC47C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822AC480: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC484: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC488: 48000018  b 0x822ac4a0
	pc = 0x822AC4A0; continue 'dispatch;
            }
            0x822AC48C => {
    //   block [0x822AC48C..0x822AC49C)
	// 822AC48C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822AC490: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC494: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC498: 48000008  b 0x822ac4a0
	pc = 0x822AC4A0; continue 'dispatch;
            }
            0x822AC49C => {
    //   block [0x822AC49C..0x822AC4A0)
	// 822AC49C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822AC4A0; continue 'dispatch;
            }
            0x822AC4A0 => {
    //   block [0x822AC4A0..0x822AC4BC)
	// 822AC4A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AC4A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC4A8: 419A0014  beq cr6, 0x822ac4bc
	if ctx.cr[6].eq {
	pc = 0x822AC4BC; continue 'dispatch;
	}
	// 822AC4AC: C003001C  lfs f0, 0x1c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AC4B0: C1A30014  lfs f13, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822AC4B4: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822AC4B8: 4821F7B1  bl 0x824cbc68
	ctx.lr = 0x822AC4BC;
	sub_824CBC68(ctx, base);
	pc = 0x822AC4BC; continue 'dispatch;
            }
            0x822AC4BC => {
    //   block [0x822AC4BC..0x822AC4F8)
	// 822AC4BC: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822AC4C0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AC4C4: 812A011C  lwz r9, 0x11c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(284 as u32) ) } as u64;
	// 822AC4C8: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 822AC4CC: 409A03AC  bne cr6, 0x822ac878
	if !ctx.cr[6].eq {
	pc = 0x822AC878; continue 'dispatch;
	}
	// 822AC4D0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822AC4D4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822AC4D8: 392A60F0  addi r9, r10, 0x60f0
	ctx.r[9].s64 = ctx.r[10].s64 + 24816;
	// 822AC4DC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 822AC4E0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 822AC4E4: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AC4E8: 8068008C  lwz r3, 0x8c(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AC4EC: 480F2C4D  bl 0x8239f138
	ctx.lr = 0x822AC4F0;
	sub_8239F138(ctx, base);
	// 822AC4F0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822AC4F4: 489FCF5C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x822AC4F8 => {
    //   block [0x822AC4F8..0x822AC540)
	// 822AC4F8: 80DC0004  lwz r6, 4(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC4FC: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 822AC500: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AC504: 81660028  lwz r11, 0x28(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(40 as u32) ) } as u64;
	// 822AC508: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822AC50C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AC510: 419A00F0  beq cr6, 0x822ac600
	if ctx.cr[6].eq {
	pc = 0x822AC600; continue 'dispatch;
	}
	// 822AC514: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AC518: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AC51C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC520: 419A0020  beq cr6, 0x822ac540
	if ctx.cr[6].eq {
	pc = 0x822AC540; continue 'dispatch;
	}
	// 822AC524: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822AC528: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 822AC52C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822AC530: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC534: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AC538: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC53C: 480000C8  b 0x822ac604
	pc = 0x822AC604; continue 'dispatch;
            }
            0x822AC540 => {
    //   block [0x822AC540..0x822AC558)
	// 822AC540: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AC544: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 822AC548: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 822AC54C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822AC550: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AC554: 40810054  ble 0x822ac5a8
	if !ctx.cr[0].gt {
	pc = 0x822AC5A8; continue 'dispatch;
	}
	pc = 0x822AC558; continue 'dispatch;
            }
            0x822AC558 => {
    //   block [0x822AC558..0x822AC578)
	// 822AC558: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AC55C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AC560: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822AC564: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC568: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 822AC56C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AC570: 41980008  blt cr6, 0x822ac578
	if ctx.cr[6].lt {
	pc = 0x822AC578; continue 'dispatch;
	}
	// 822AC574: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x822AC578; continue 'dispatch;
            }
            0x822AC578 => {
    //   block [0x822AC578..0x822AC594)
	// 822AC578: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AC57C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AC580: 419A0014  beq cr6, 0x822ac594
	if ctx.cr[6].eq {
	pc = 0x822AC594; continue 'dispatch;
	}
	// 822AC584: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AC588: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AC58C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AC590: 4800000C  b 0x822ac59c
	pc = 0x822AC59C; continue 'dispatch;
            }
            0x822AC594 => {
    //   block [0x822AC594..0x822AC59C)
	// 822AC594: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AC598: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822AC59C; continue 'dispatch;
            }
            0x822AC59C => {
    //   block [0x822AC59C..0x822AC5A8)
	// 822AC59C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AC5A0: 4199FFB8  bgt cr6, 0x822ac558
	if ctx.cr[6].gt {
	pc = 0x822AC558; continue 'dispatch;
	}
	// 822AC5A4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x822AC5A8; continue 'dispatch;
            }
            0x822AC5A8 => {
    //   block [0x822AC5A8..0x822AC5C4)
	// 822AC5A8: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 822AC5AC: 419A0040  beq cr6, 0x822ac5ec
	if ctx.cr[6].eq {
	pc = 0x822AC5EC; continue 'dispatch;
	}
	// 822AC5B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC5B4: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 822AC5B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC5BC: 41990008  bgt cr6, 0x822ac5c4
	if ctx.cr[6].gt {
	pc = 0x822AC5C4; continue 'dispatch;
	}
	// 822AC5C0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822AC5C4; continue 'dispatch;
            }
            0x822AC5C4 => {
    //   block [0x822AC5C4..0x822AC5EC)
	// 822AC5C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AC5C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC5CC: 409A0020  bne cr6, 0x822ac5ec
	if !ctx.cr[6].eq {
	pc = 0x822AC5EC; continue 'dispatch;
	}
	// 822AC5D0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822AC5D4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822AC5D8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822AC5DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC5E0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AC5E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC5E8: 4800001C  b 0x822ac604
	pc = 0x822AC604; continue 'dispatch;
            }
            0x822AC5EC => {
    //   block [0x822AC5EC..0x822AC600)
	// 822AC5EC: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 822AC5F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC5F4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AC5F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC5FC: 48000008  b 0x822ac604
	pc = 0x822AC604; continue 'dispatch;
            }
            0x822AC600 => {
    //   block [0x822AC600..0x822AC604)
	// 822AC600: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822AC604; continue 'dispatch;
            }
            0x822AC604 => {
    //   block [0x822AC604..0x822AC64C)
	// 822AC604: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AC608: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC60C: 419A026C  beq cr6, 0x822ac878
	if ctx.cr[6].eq {
	pc = 0x822AC878; continue 'dispatch;
	}
	// 822AC610: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 822AC614: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 822AC618: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AC61C: 419A00F0  beq cr6, 0x822ac70c
	if ctx.cr[6].eq {
	pc = 0x822AC70C; continue 'dispatch;
	}
	// 822AC620: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AC624: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AC628: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC62C: 419A0020  beq cr6, 0x822ac64c
	if ctx.cr[6].eq {
	pc = 0x822AC64C; continue 'dispatch;
	}
	// 822AC630: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 822AC634: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 822AC638: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822AC63C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC640: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822AC644: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC648: 480000C8  b 0x822ac710
	pc = 0x822AC710; continue 'dispatch;
            }
            0x822AC64C => {
    //   block [0x822AC64C..0x822AC664)
	// 822AC64C: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AC650: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 822AC654: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822AC658: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822AC65C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AC660: 40810054  ble 0x822ac6b4
	if !ctx.cr[0].gt {
	pc = 0x822AC6B4; continue 'dispatch;
	}
	pc = 0x822AC664; continue 'dispatch;
            }
            0x822AC664 => {
    //   block [0x822AC664..0x822AC684)
	// 822AC664: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AC668: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AC66C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822AC670: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC674: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 822AC678: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AC67C: 41980008  blt cr6, 0x822ac684
	if ctx.cr[6].lt {
	pc = 0x822AC684; continue 'dispatch;
	}
	// 822AC680: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x822AC684; continue 'dispatch;
            }
            0x822AC684 => {
    //   block [0x822AC684..0x822AC6A0)
	// 822AC684: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AC688: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AC68C: 419A0014  beq cr6, 0x822ac6a0
	if ctx.cr[6].eq {
	pc = 0x822AC6A0; continue 'dispatch;
	}
	// 822AC690: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AC694: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AC698: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AC69C: 4800000C  b 0x822ac6a8
	pc = 0x822AC6A8; continue 'dispatch;
            }
            0x822AC6A0 => {
    //   block [0x822AC6A0..0x822AC6A8)
	// 822AC6A0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AC6A4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822AC6A8; continue 'dispatch;
            }
            0x822AC6A8 => {
    //   block [0x822AC6A8..0x822AC6B4)
	// 822AC6A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AC6AC: 4199FFB8  bgt cr6, 0x822ac664
	if ctx.cr[6].gt {
	pc = 0x822AC664; continue 'dispatch;
	}
	// 822AC6B0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x822AC6B4; continue 'dispatch;
            }
            0x822AC6B4 => {
    //   block [0x822AC6B4..0x822AC6D0)
	// 822AC6B4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AC6B8: 419A0040  beq cr6, 0x822ac6f8
	if ctx.cr[6].eq {
	pc = 0x822AC6F8; continue 'dispatch;
	}
	// 822AC6BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC6C0: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 822AC6C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC6C8: 41990008  bgt cr6, 0x822ac6d0
	if ctx.cr[6].gt {
	pc = 0x822AC6D0; continue 'dispatch;
	}
	// 822AC6CC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822AC6D0; continue 'dispatch;
            }
            0x822AC6D0 => {
    //   block [0x822AC6D0..0x822AC6F8)
	// 822AC6D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AC6D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC6D8: 409A0020  bne cr6, 0x822ac6f8
	if !ctx.cr[6].eq {
	pc = 0x822AC6F8; continue 'dispatch;
	}
	// 822AC6DC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822AC6E0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822AC6E4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822AC6E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC6EC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822AC6F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC6F4: 4800001C  b 0x822ac710
	pc = 0x822AC710; continue 'dispatch;
            }
            0x822AC6F8 => {
    //   block [0x822AC6F8..0x822AC70C)
	// 822AC6F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822AC6FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC700: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822AC704: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC708: 48000008  b 0x822ac710
	pc = 0x822AC710; continue 'dispatch;
            }
            0x822AC70C => {
    //   block [0x822AC70C..0x822AC710)
	// 822AC70C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822AC710; continue 'dispatch;
            }
            0x822AC710 => {
    //   block [0x822AC710..0x822AC748)
	// 822AC710: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AC714: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC718: 419A0160  beq cr6, 0x822ac878
	if ctx.cr[6].eq {
	pc = 0x822AC878; continue 'dispatch;
	}
	// 822AC71C: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 822AC720: 4BF52EA9  bl 0x821ff5c8
	ctx.lr = 0x822AC724;
	sub_821FF5C8(ctx, base);
	// 822AC724: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822AC728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC72C: 419A014C  beq cr6, 0x822ac878
	if ctx.cr[6].eq {
	pc = 0x822AC878; continue 'dispatch;
	}
	// 822AC730: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822AC734: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822AC738: 419A0010  beq cr6, 0x822ac748
	if ctx.cr[6].eq {
	pc = 0x822AC748; continue 'dispatch;
	}
	// 822AC73C: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 822AC740: 4BF3C451  bl 0x821e8b90
	ctx.lr = 0x822AC744;
	sub_821E8B90(ctx, base);
	// 822AC744: 48000008  b 0x822ac74c
	pc = 0x822AC74C; continue 'dispatch;
            }
            0x822AC748 => {
    //   block [0x822AC748..0x822AC74C)
	// 822AC748: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x822AC74C; continue 'dispatch;
            }
            0x822AC74C => {
    //   block [0x822AC74C..0x822AC79C)
	// 822AC74C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822AC750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC754: 409A0124  bne cr6, 0x822ac878
	if !ctx.cr[6].eq {
	pc = 0x822AC878; continue 'dispatch;
	}
	// 822AC758: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC75C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AC760: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822AC764: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 822AC768: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822AC76C: 419A00F4  beq cr6, 0x822ac860
	if ctx.cr[6].eq {
	pc = 0x822AC860; continue 'dispatch;
	}
	// 822AC770: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AC774: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AC778: 419A0024  beq cr6, 0x822ac79c
	if ctx.cr[6].eq {
	pc = 0x822AC79C; continue 'dispatch;
	}
	// 822AC77C: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822AC780: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AC784: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 822AC788: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822AC78C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC790: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822AC794: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC798: 480000CC  b 0x822ac864
	pc = 0x822AC864; continue 'dispatch;
            }
            0x822AC79C => {
    //   block [0x822AC79C..0x822AC7B8)
	// 822AC79C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AC7A0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AC7A4: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 822AC7A8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822AC7AC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822AC7B0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AC7B4: 40810054  ble 0x822ac808
	if !ctx.cr[0].gt {
	pc = 0x822AC808; continue 'dispatch;
	}
	pc = 0x822AC7B8; continue 'dispatch;
            }
            0x822AC7B8 => {
    //   block [0x822AC7B8..0x822AC7D8)
	// 822AC7B8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AC7BC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AC7C0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822AC7C4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC7C8: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 822AC7CC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AC7D0: 41980008  blt cr6, 0x822ac7d8
	if ctx.cr[6].lt {
	pc = 0x822AC7D8; continue 'dispatch;
	}
	// 822AC7D4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x822AC7D8; continue 'dispatch;
            }
            0x822AC7D8 => {
    //   block [0x822AC7D8..0x822AC7F4)
	// 822AC7D8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AC7DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AC7E0: 419A0014  beq cr6, 0x822ac7f4
	if ctx.cr[6].eq {
	pc = 0x822AC7F4; continue 'dispatch;
	}
	// 822AC7E4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AC7E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AC7EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AC7F0: 4800000C  b 0x822ac7fc
	pc = 0x822AC7FC; continue 'dispatch;
            }
            0x822AC7F4 => {
    //   block [0x822AC7F4..0x822AC7FC)
	// 822AC7F4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AC7F8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822AC7FC; continue 'dispatch;
            }
            0x822AC7FC => {
    //   block [0x822AC7FC..0x822AC808)
	// 822AC7FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AC800: 4199FFB8  bgt cr6, 0x822ac7b8
	if ctx.cr[6].gt {
	pc = 0x822AC7B8; continue 'dispatch;
	}
	// 822AC804: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x822AC808; continue 'dispatch;
            }
            0x822AC808 => {
    //   block [0x822AC808..0x822AC824)
	// 822AC808: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AC80C: 419A0040  beq cr6, 0x822ac84c
	if ctx.cr[6].eq {
	pc = 0x822AC84C; continue 'dispatch;
	}
	// 822AC810: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC814: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 822AC818: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC81C: 41990008  bgt cr6, 0x822ac824
	if ctx.cr[6].gt {
	pc = 0x822AC824; continue 'dispatch;
	}
	// 822AC820: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822AC824; continue 'dispatch;
            }
            0x822AC824 => {
    //   block [0x822AC824..0x822AC84C)
	// 822AC824: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AC828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC82C: 409A0020  bne cr6, 0x822ac84c
	if !ctx.cr[6].eq {
	pc = 0x822AC84C; continue 'dispatch;
	}
	// 822AC830: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822AC834: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822AC838: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822AC83C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC840: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822AC844: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC848: 4800001C  b 0x822ac864
	pc = 0x822AC864; continue 'dispatch;
            }
            0x822AC84C => {
    //   block [0x822AC84C..0x822AC860)
	// 822AC84C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822AC850: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AC854: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822AC858: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AC85C: 48000008  b 0x822ac864
	pc = 0x822AC864; continue 'dispatch;
            }
            0x822AC860 => {
    //   block [0x822AC860..0x822AC864)
	// 822AC860: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x822AC864; continue 'dispatch;
            }
            0x822AC864 => {
    //   block [0x822AC864..0x822AC878)
	// 822AC864: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AC868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC86C: 419A000C  beq cr6, 0x822ac878
	if ctx.cr[6].eq {
	pc = 0x822AC878; continue 'dispatch;
	}
	// 822AC870: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822AC874: 480F7CAD  bl 0x823a4520
	ctx.lr = 0x822AC878;
	sub_823A4520(ctx, base);
	pc = 0x822AC878; continue 'dispatch;
            }
            0x822AC878 => {
    //   block [0x822AC878..0x822AC880)
	// 822AC878: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822AC87C: 489FCBD4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AC880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AC880 size=476
    let mut pc: u32 = 0x822AC880;
    'dispatch: loop {
        match pc {
            0x822AC880 => {
    //   block [0x822AC880..0x822AC8D4)
	// 822AC880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AC884: 489FCB89  bl 0x82ca940c
	ctx.lr = 0x822AC888;
	sub_82CA93D0(ctx, base);
	// 822AC888: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AC88C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822AC890: 897E0369  lbz r11, 0x369(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(873 as u32) ) } as u64;
	// 822AC894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC898: 409A01BC  bne cr6, 0x822aca54
	if !ctx.cr[6].eq {
	pc = 0x822ACA54; continue 'dispatch;
	}
	// 822AC89C: 3BBE0354  addi r29, r30, 0x354
	ctx.r[29].s64 = ctx.r[30].s64 + 852;
	// 822AC8A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822AC8A4: 4BFD8555  bl 0x82284df8
	ctx.lr = 0x822AC8A8;
	sub_82284DF8(ctx, base);
	// 822AC8A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC8AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AC8B0: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 822AC8B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822AC8B8: 4E800421  bctrl
	ctx.lr = 0x822AC8BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822AC8BC: 81030028  lwz r8, 0x28(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 822AC8C0: 81230020  lwz r9, 0x20(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 822AC8C4: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822AC8C8: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822AC8CC: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 822AC8D0: 419A008C  beq cr6, 0x822ac95c
	if ctx.cr[6].eq {
	pc = 0x822AC95C; continue 'dispatch;
	}
            }
            0x822AC8D4 => {
    //   block [0x822AC8D4..0x822AC8FC)
	// 822AC8D4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC8D8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822AC8DC: A14B001C  lhz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822AC8E0: 5547047E  clrlwi r7, r10, 0x11
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x00007FFFu64;
	// 822AC8E4: B0EB001C  sth r7, 0x1c(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[7].u16 ) };
	// 822AC8E8: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC8EC: 88CB001F  lbz r6, 0x1f(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(31 as u32) ) } as u64;
	// 822AC8F0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 822AC8F4: 419A004C  beq cr6, 0x822ac940
	if ctx.cr[6].eq {
	pc = 0x822AC940; continue 'dispatch;
	}
	// 822AC8F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x822AC8FC; continue 'dispatch;
            }
            0x822AC8FC => {
    //   block [0x822AC8FC..0x822AC918)
	// 822AC8FC: A0EB001C  lhz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822AC900: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822AC904: 54E607FE  clrlwi r6, r7, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 822AC908: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 822AC90C: 419A000C  beq cr6, 0x822ac918
	if ctx.cr[6].eq {
	pc = 0x822AC918; continue 'dispatch;
	}
	// 822AC910: 396B0044  addi r11, r11, 0x44
	ctx.r[11].s64 = ctx.r[11].s64 + 68;
	// 822AC914: 48000008  b 0x822ac91c
	pc = 0x822AC91C; continue 'dispatch;
            }
            0x822AC918 => {
    //   block [0x822AC918..0x822AC91C)
	// 822AC918: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	pc = 0x822AC91C; continue 'dispatch;
            }
            0x822AC91C => {
    //   block [0x822AC91C..0x822AC940)
	// 822AC91C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC920: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 822AC924: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AC928: 54E607FA  rlwinm r6, r7, 0, 0x1f, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 822AC92C: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 822AC930: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC934: 88AB001F  lbz r5, 0x1f(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(31 as u32) ) } as u64;
	// 822AC938: 7F082800  cmpw cr6, r8, r5
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[5].s32, &mut ctx.xer);
	// 822AC93C: 4198FFC0  blt cr6, 0x822ac8fc
	if ctx.cr[6].lt {
	pc = 0x822AC8FC; continue 'dispatch;
	}
	pc = 0x822AC940; continue 'dispatch;
            }
            0x822AC940 => {
    //   block [0x822AC940..0x822AC95C)
	// 822AC940: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 822AC944: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 822AC948: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 822AC94C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822AC950: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822AC954: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822AC958: 409AFF7C  bne cr6, 0x822ac8d4
	if !ctx.cr[6].eq {
	pc = 0x822AC8D4; continue 'dispatch;
	}
	pc = 0x822AC95C; continue 'dispatch;
            }
            0x822AC95C => {
    //   block [0x822AC95C..0x822AC9EC)
	// 822AC95C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC960: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AC964: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 822AC968: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822AC96C: 4E800421  bctrl
	ctx.lr = 0x822AC970;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822AC970: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AC974: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822AC978: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 822AC97C: 48906B6D  bl 0x82bb34e8
	ctx.lr = 0x822AC980;
	sub_82BB34E8(ctx, base);
	// 822AC980: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822AC984: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 822AC988: 48906B61  bl 0x82bb34e8
	ctx.lr = 0x822AC98C;
	sub_82BB34E8(ctx, base);
	// 822AC98C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822AC990: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 822AC994: 48906B55  bl 0x82bb34e8
	ctx.lr = 0x822AC998;
	sub_82BB34E8(ctx, base);
	// 822AC998: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822AC99C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AC9A0: 48906B49  bl 0x82bb34e8
	ctx.lr = 0x822AC9A4;
	sub_82BB34E8(ctx, base);
	// 822AC9A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822AC9A8: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 822AC9AC: 48906B3D  bl 0x82bb34e8
	ctx.lr = 0x822AC9B0;
	sub_82BB34E8(ctx, base);
	// 822AC9B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822AC9B4: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 822AC9B8: 48906B31  bl 0x82bb34e8
	ctx.lr = 0x822AC9BC;
	sub_82BB34E8(ctx, base);
	// 822AC9BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AC9C0: 4BEC85B1  bl 0x82174f70
	ctx.lr = 0x822AC9C4;
	sub_82174F70(ctx, base);
	// 822AC9C4: 809E01F4  lwz r4, 0x1f4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(500 as u32) ) } as u64;
	// 822AC9C8: 387E01EC  addi r3, r30, 0x1ec
	ctx.r[3].s64 = ctx.r[30].s64 + 492;
	// 822AC9CC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822AC9D0: 419A001C  beq cr6, 0x822ac9ec
	if ctx.cr[6].eq {
	pc = 0x822AC9EC; continue 'dispatch;
	}
	// 822AC9D4: A164001C  lhz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 822AC9D8: 556A04A4  rlwinm r10, r11, 0, 0x12, 0x12
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822AC9DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AC9E0: 419A000C  beq cr6, 0x822ac9ec
	if ctx.cr[6].eq {
	pc = 0x822AC9EC; continue 'dispatch;
	}
	// 822AC9E4: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AC9E8: 4BFD7FB9  bl 0x822849a0
	ctx.lr = 0x822AC9EC;
	sub_822849A0(ctx, base);
            }
            0x822AC9EC => {
    //   block [0x822AC9EC..0x822ACA10)
	// 822AC9EC: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 822AC9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AC9F4: 419A001C  beq cr6, 0x822aca10
	if ctx.cr[6].eq {
	pc = 0x822ACA10; continue 'dispatch;
	}
	// 822AC9F8: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 822AC9FC: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ACA00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ACA04: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822ACA08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822ACA0C: 4E800421  bctrl
	ctx.lr = 0x822ACA10;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822ACA10 => {
    //   block [0x822ACA10..0x822ACA54)
	// 822ACA10: 897E0364  lbz r11, 0x364(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(868 as u32) ) } as u64;
	// 822ACA14: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822ACA18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ACA1C: 409A0038  bne cr6, 0x822aca54
	if !ctx.cr[6].eq {
	pc = 0x822ACA54; continue 'dispatch;
	}
	// 822ACA20: 817E02DC  lwz r11, 0x2dc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(732 as u32) ) } as u64;
	// 822ACA24: 387E02DC  addi r3, r30, 0x2dc
	ctx.r[3].s64 = ctx.r[30].s64 + 732;
	// 822ACA28: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ACA2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822ACA30: 4E800421  bctrl
	ctx.lr = 0x822ACA34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ACA34: 813E001C  lwz r9, 0x1c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 822ACA38: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822ACA3C: 419A0018  beq cr6, 0x822aca54
	if ctx.cr[6].eq {
	pc = 0x822ACA54; continue 'dispatch;
	}
	// 822ACA40: 5523003E  slwi r3, r9, 0
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 822ACA44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ACA48: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822ACA4C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822ACA50: 4E800421  bctrl
	ctx.lr = 0x822ACA54;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822ACA54 => {
    //   block [0x822ACA54..0x822ACA5C)
	// 822ACA54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822ACA58: 489FCA04  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ACA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822ACA60 size=408
    let mut pc: u32 = 0x822ACA60;
    'dispatch: loop {
        match pc {
            0x822ACA60 => {
    //   block [0x822ACA60..0x822ACAA8)
	// 822ACA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ACA64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822ACA68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822ACA6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822ACA70: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822ACA74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ACA78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822ACA7C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822ACA80: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822ACA84: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 822ACA88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ACA8C: 419A001C  beq cr6, 0x822acaa8
	if ctx.cr[6].eq {
	pc = 0x822ACAA8; continue 'dispatch;
	}
	// 822ACA90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ACA94: 9BDF0024  stb r30, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u8 ) };
	// 822ACA98: 9BDF0025  stb r30, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[30].u8 ) };
	// 822ACA9C: 997F0002  stb r11, 2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[11].u8 ) };
	// 822ACAA0: 481249B9  bl 0x823d1458
	ctx.lr = 0x822ACAA4;
	sub_823D1458(ctx, base);
	// 822ACAA4: 9BDF0001  stb r30, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[30].u8 ) };
	pc = 0x822ACAA8; continue 'dispatch;
            }
            0x822ACAA8 => {
    //   block [0x822ACAA8..0x822ACAE4)
	// 822ACAA8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 822ACAAC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822ACAB0: 48000149  bl 0x822acbf8
	ctx.lr = 0x822ACAB4;
	sub_822ACBF8(ctx, base);
	// 822ACAB4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822ACAB8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822ACABC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ACAC0: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 822ACAC4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ACAC8: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ACACC: 54EA003E  slwi r10, r7, 0
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822ACAD0: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ACAD4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822ACAD8: 409A000C  bne cr6, 0x822acae4
	if !ctx.cr[6].eq {
	pc = 0x822ACAE4; continue 'dispatch;
	}
	// 822ACADC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 822ACAE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822ACAE4; continue 'dispatch;
            }
            0x822ACAE4 => {
    //   block [0x822ACAE4..0x822ACB14)
	// 822ACAE4: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ACAE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ACAEC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ACAF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822ACAF4: 4E800421  bctrl
	ctx.lr = 0x822ACAF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ACAF8: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 822ACAFC: 419A0018  beq cr6, 0x822acb14
	if ctx.cr[6].eq {
	pc = 0x822ACB14; continue 'dispatch;
	}
	// 822ACB00: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 822ACB04: 419A0010  beq cr6, 0x822acb14
	if ctx.cr[6].eq {
	pc = 0x822ACB14; continue 'dispatch;
	}
	// 822ACB08: 2F030008  cmpwi cr6, r3, 8
	ctx.cr[6].compare_i32(ctx.r[3].s32, 8, &mut ctx.xer);
	// 822ACB0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ACB10: 409A0008  bne cr6, 0x822acb18
	if !ctx.cr[6].eq {
	pc = 0x822ACB18; continue 'dispatch;
	}
            }
            0x822ACB14 => {
    //   block [0x822ACB14..0x822ACB18)
	// 822ACB14: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822ACB18; continue 'dispatch;
            }
            0x822ACB18 => {
    //   block [0x822ACB18..0x822ACB60)
	// 822ACB18: 895F0026  lbz r10, 0x26(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 822ACB1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ACB20: 419A00BC  beq cr6, 0x822acbdc
	if ctx.cr[6].eq {
	pc = 0x822ACBDC; continue 'dispatch;
	}
	// 822ACB24: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822ACB28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ACB2C: 419A00B0  beq cr6, 0x822acbdc
	if ctx.cr[6].eq {
	pc = 0x822ACBDC; continue 'dispatch;
	}
	// 822ACB30: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822ACB34: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822ACB38: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822ACB3C: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822ACB40: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 822ACB44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ACB48: 419A0018  beq cr6, 0x822acb60
	if ctx.cr[6].eq {
	pc = 0x822ACB60; continue 'dispatch;
	}
	// 822ACB4C: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822ACB50: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822ACB54: 7D2A1670  srawi r10, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 822ACB58: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822ACB5C: 41990008  bgt cr6, 0x822acb64
	if ctx.cr[6].gt {
	pc = 0x822ACB64; continue 'dispatch;
	}
	pc = 0x822ACB60; continue 'dispatch;
            }
            0x822ACB60 => {
    //   block [0x822ACB60..0x822ACB64)
	// 822ACB60: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822ACB64; continue 'dispatch;
            }
            0x822ACB64 => {
    //   block [0x822ACB64..0x822ACB90)
	// 822ACB64: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822ACB68: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ACB6C: 808A7C70  lwz r4, 0x7c70(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31856 as u32) ) } as u64;
	// 822ACB70: 48151611  bl 0x823fe180
	ctx.lr = 0x822ACB74;
	sub_823FE180(ctx, base);
	// 822ACB74: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822ACB78: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ACB7C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822ACB80: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 822ACB84: 4099000C  ble cr6, 0x822acb90
	if !ctx.cr[6].gt {
	pc = 0x822ACB90; continue 'dispatch;
	}
	// 822ACB88: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 822ACB8C: 48000014  b 0x822acba0
	pc = 0x822ACBA0; continue 'dispatch;
            }
            0x822ACB90 => {
    //   block [0x822ACB90..0x822ACBA0)
	// 822ACB90: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ACB94: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 822ACB98: 40990008  ble cr6, 0x822acba0
	if !ctx.cr[6].gt {
	pc = 0x822ACBA0; continue 'dispatch;
	}
	// 822ACB9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x822ACBA0; continue 'dispatch;
            }
            0x822ACBA0 => {
    //   block [0x822ACBA0..0x822ACBB8)
	// 822ACBA0: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 822ACBA4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822ACBA8: 419A0010  beq cr6, 0x822acbb8
	if ctx.cr[6].eq {
	pc = 0x822ACBB8; continue 'dispatch;
	}
	// 822ACBAC: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 822ACBB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ACBB4: 481256F5  bl 0x823d22a8
	ctx.lr = 0x822ACBB8;
	sub_823D22A8(ctx, base);
	pc = 0x822ACBB8; continue 'dispatch;
            }
            0x822ACBB8 => {
    //   block [0x822ACBB8..0x822ACBDC)
	// 822ACBB8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ACBBC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 822ACBC0: 409A001C  bne cr6, 0x822acbdc
	if !ctx.cr[6].eq {
	pc = 0x822ACBDC; continue 'dispatch;
	}
	// 822ACBC4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822ACBC8: C00BBC68  lfs f0, -0x4398(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ACBCC: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 822ACBD0: 409A000C  bne cr6, 0x822acbdc
	if !ctx.cr[6].eq {
	pc = 0x822ACBDC; continue 'dispatch;
	}
	// 822ACBD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ACBD8: 48125309  bl 0x823d1ee0
	ctx.lr = 0x822ACBDC;
	sub_823D1EE0(ctx, base);
	pc = 0x822ACBDC; continue 'dispatch;
            }
            0x822ACBDC => {
    //   block [0x822ACBDC..0x822ACBF8)
	// 822ACBDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822ACBE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822ACBE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822ACBE8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822ACBEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822ACBF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822ACBF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ACBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822ACBF8 size=676
    let mut pc: u32 = 0x822ACBF8;
    'dispatch: loop {
        match pc {
            0x822ACBF8 => {
    //   block [0x822ACBF8..0x822ACC48)
	// 822ACBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ACBFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822ACC00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822ACC04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822ACC08: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822ACC0C: 9421FB50  stwu r1, -0x4b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1200 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ACC10: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822ACC14: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822ACC18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822ACC1C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822ACC20: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ACC24: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 822ACC28: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ACC2C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ACC30: 54EA003E  slwi r10, r7, 0
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822ACC34: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ACC38: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822ACC3C: 409A000C  bne cr6, 0x822acc48
	if !ctx.cr[6].eq {
	pc = 0x822ACC48; continue 'dispatch;
	}
	// 822ACC40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 822ACC44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822ACC48; continue 'dispatch;
            }
            0x822ACC48 => {
    //   block [0x822ACC48..0x822ACC78)
	// 822ACC48: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ACC4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ACC50: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ACC54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822ACC58: 4E800421  bctrl
	ctx.lr = 0x822ACC5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ACC5C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 822ACC60: 419A0018  beq cr6, 0x822acc78
	if ctx.cr[6].eq {
	pc = 0x822ACC78; continue 'dispatch;
	}
	// 822ACC64: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 822ACC68: 419A0010  beq cr6, 0x822acc78
	if ctx.cr[6].eq {
	pc = 0x822ACC78; continue 'dispatch;
	}
	// 822ACC6C: 2F030008  cmpwi cr6, r3, 8
	ctx.cr[6].compare_i32(ctx.r[3].s32, 8, &mut ctx.xer);
	// 822ACC70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ACC74: 409A0008  bne cr6, 0x822acc7c
	if !ctx.cr[6].eq {
	pc = 0x822ACC7C; continue 'dispatch;
	}
            }
            0x822ACC78 => {
    //   block [0x822ACC78..0x822ACC7C)
	// 822ACC78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822ACC7C; continue 'dispatch;
            }
            0x822ACC7C => {
    //   block [0x822ACC7C..0x822ACCA4)
	// 822ACC7C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822ACC80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ACC84: 419A01C0  beq cr6, 0x822ace44
	if ctx.cr[6].eq {
	pc = 0x822ACE44; continue 'dispatch;
	}
	// 822ACC88: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ACC8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ACC90: 409A0014  bne cr6, 0x822acca4
	if !ctx.cr[6].eq {
	pc = 0x822ACCA4; continue 'dispatch;
	}
	// 822ACC94: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 822ACC98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ACC9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822ACCA0: 419A0008  beq cr6, 0x822acca8
	if ctx.cr[6].eq {
	pc = 0x822ACCA8; continue 'dispatch;
	}
	pc = 0x822ACCA4; continue 'dispatch;
            }
            0x822ACCA4 => {
    //   block [0x822ACCA4..0x822ACCA8)
	// 822ACCA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x822ACCA8; continue 'dispatch;
            }
            0x822ACCA8 => {
    //   block [0x822ACCA8..0x822ACCF0)
	// 822ACCA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822ACCAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ACCB0: 419A012C  beq cr6, 0x822acddc
	if ctx.cr[6].eq {
	pc = 0x822ACDDC; continue 'dispatch;
	}
	// 822ACCB4: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 822ACCB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ACCBC: 419A0120  beq cr6, 0x822acddc
	if ctx.cr[6].eq {
	pc = 0x822ACDDC; continue 'dispatch;
	}
	// 822ACCC0: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ACCC4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822ACCC8: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822ACCCC: EC0D07FA  fmadds f0, f13, f31, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 822ACCD0: 3BCB9484  addi r30, r11, -0x6b7c
	ctx.r[30].s64 = ctx.r[11].s64 + -27516;
	// 822ACCD4: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822ACCD8: C19E27E4  lfs f12, 0x27e4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(10212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822ACCDC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 822ACCE0: 41990010  bgt cr6, 0x822accf0
	if ctx.cr[6].gt {
	pc = 0x822ACCF0; continue 'dispatch;
	}
	// 822ACCE4: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822ACCE8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 822ACCEC: 40980014  bge cr6, 0x822acd00
	if !ctx.cr[6].lt {
	pc = 0x822ACD00; continue 'dispatch;
	}
	pc = 0x822ACCF0; continue 'dispatch;
            }
            0x822ACCF0 => {
    //   block [0x822ACCF0..0x822ACD00)
	// 822ACCF0: C01E4144  lfs f0, 0x4144(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ACCF4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822ACCF8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822ACCFC: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x822ACD00; continue 'dispatch;
            }
            0x822ACD00 => {
    //   block [0x822ACD00..0x822ACDDC)
	// 822ACD00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ACD04: 4812410D  bl 0x823d0e10
	ctx.lr = 0x822ACD08;
	sub_823D0E10(ctx, base);
	// 822ACD08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822ACD0C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822ACD10: 419A0170  beq cr6, 0x822ace80
	if ctx.cr[6].eq {
	pc = 0x822ACE80; continue 'dispatch;
	}
	// 822ACD14: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822ACD18: 48124009  bl 0x823d0d20
	ctx.lr = 0x822ACD1C;
	sub_823D0D20(ctx, base);
	// 822ACD1C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822ACD20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ACD24: 481241ED  bl 0x823d0f10
	ctx.lr = 0x822ACD28;
	sub_823D0F10(ctx, base);
	// 822ACD28: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	pc = 0x822ACDDC; continue 'dispatch;
            }
            0x822ACDDC => {
    //   block [0x822ACDDC..0x822ACE44)
	// 822ACDDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ACDE0: 409A0014  bne cr6, 0x822acdf4
	if !ctx.cr[6].eq {
	pc = 0x822ACDF4; continue 'dispatch;
	}
	// 822ACDE4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 822ACDE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ACDEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822ACDF0: 419A0008  beq cr6, 0x822acdf8
	if ctx.cr[6].eq {
	pc = 0x822ACDF8; continue 'dispatch;
	}
	// 822ACDF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ACDF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822ACDFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ACE00: 409A0080  bne cr6, 0x822ace80
	if !ctx.cr[6].eq {
	pc = 0x822ACE80; continue 'dispatch;
	}
	// 822ACE04: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822ACE08: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 822ACE0C: 419A0074  beq cr6, 0x822ace80
	if ctx.cr[6].eq {
	pc = 0x822ACE80; continue 'dispatch;
	}
	// 822ACE10: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822ACE14: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822ACE18: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822ACE1C: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822ACE20: 386B0090  addi r3, r11, 0x90
	ctx.r[3].s64 = ctx.r[11].s64 + 144;
	// 822ACE24: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 822ACE28: 814B0094  lwz r10, 0x94(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 822ACE2C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822ACE30: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822ACE34: 487EA535  bl 0x82a97368
	ctx.lr = 0x822ACE38;
	sub_82A97368(ctx, base);
	// 822ACE38: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 822ACE3C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 822ACE40: 48000040  b 0x822ace80
	pc = 0x822ACE80; continue 'dispatch;
            }
            0x822ACE44 => {
    //   block [0x822ACE44..0x822ACE80)
	// 822ACE44: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822ACE48: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 822ACE4C: 419A0034  beq cr6, 0x822ace80
	if ctx.cr[6].eq {
	pc = 0x822ACE80; continue 'dispatch;
	}
	// 822ACE50: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822ACE54: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822ACE58: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822ACE5C: 816A6B08  lwz r11, 0x6b08(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822ACE60: 386B0090  addi r3, r11, 0x90
	ctx.r[3].s64 = ctx.r[11].s64 + 144;
	// 822ACE64: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 822ACE68: 812B0094  lwz r9, 0x94(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 822ACE6C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 822ACE70: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822ACE74: 487EA4F5  bl 0x82a97368
	ctx.lr = 0x822ACE78;
	sub_82A97368(ctx, base);
	// 822ACE78: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 822ACE7C: 911F0014  stw r8, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	pc = 0x822ACE80; continue 'dispatch;
            }
            0x822ACE80 => {
    //   block [0x822ACE80..0x822ACE9C)
	// 822ACE80: 382104B0  addi r1, r1, 0x4b0
	ctx.r[1].s64 = ctx.r[1].s64 + 1200;
	// 822ACE84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822ACE88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822ACE8C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822ACE90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822ACE94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822ACE98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ACEA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ACEA0 size=468
    let mut pc: u32 = 0x822ACEA0;
    'dispatch: loop {
        match pc {
            0x822ACEA0 => {
    //   block [0x822ACEA0..0x822ACF10)
	// 822ACEA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ACEA4: 489FC569  bl 0x82ca940c
	ctx.lr = 0x822ACEA8;
	sub_82CA93D0(ctx, base);
	// 822ACEA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ACEAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822ACEB0: 4BED3F81  bl 0x82180e30
	ctx.lr = 0x822ACEB4;
	sub_82180E30(ctx, base);
	// 822ACEB4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822ACEB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ACEBC: 419A0174  beq cr6, 0x822ad030
	if ctx.cr[6].eq {
	pc = 0x822AD030; continue 'dispatch;
	}
	// 822ACEC0: 3BBF04C4  addi r29, r31, 0x4c4
	ctx.r[29].s64 = ctx.r[31].s64 + 1220;
	// 822ACEC4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822ACEC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822ACECC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 822ACED0: 4BEC6F69  bl 0x82173e38
	ctx.lr = 0x822ACED4;
	sub_82173E38(ctx, base);
	// 822ACED4: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822ACED8: 556AE7FE  rlwinm r10, r11, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 822ACEDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ACEE0: 419A00F4  beq cr6, 0x822acfd4
	if ctx.cr[6].eq {
	pc = 0x822ACFD4; continue 'dispatch;
	}
	// 822ACEE4: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822ACEE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ACEEC: 419A0024  beq cr6, 0x822acf10
	if ctx.cr[6].eq {
	pc = 0x822ACF10; continue 'dispatch;
	}
	// 822ACEF0: 894B0064  lbz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 822ACEF4: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822ACEF8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822ACEFC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822ACF00: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ACF04: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822ACF08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ACF0C: 480000CC  b 0x822acfd8
	pc = 0x822ACFD8; continue 'dispatch;
            }
            0x822ACF10 => {
    //   block [0x822ACF10..0x822ACF2C)
	// 822ACF10: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822ACF14: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822ACF18: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 822ACF1C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822ACF20: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822ACF24: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822ACF28: 40810054  ble 0x822acf7c
	if !ctx.cr[0].gt {
	pc = 0x822ACF7C; continue 'dispatch;
	}
	pc = 0x822ACF2C; continue 'dispatch;
            }
            0x822ACF2C => {
    //   block [0x822ACF2C..0x822ACF4C)
	// 822ACF2C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822ACF30: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822ACF34: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822ACF38: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ACF3C: 2F070064  cmpwi cr6, r7, 0x64
	ctx.cr[6].compare_i32(ctx.r[7].s32, 100, &mut ctx.xer);
	// 822ACF40: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822ACF44: 41980008  blt cr6, 0x822acf4c
	if ctx.cr[6].lt {
	pc = 0x822ACF4C; continue 'dispatch;
	}
	// 822ACF48: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x822ACF4C; continue 'dispatch;
            }
            0x822ACF4C => {
    //   block [0x822ACF4C..0x822ACF68)
	// 822ACF4C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822ACF50: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822ACF54: 419A0014  beq cr6, 0x822acf68
	if ctx.cr[6].eq {
	pc = 0x822ACF68; continue 'dispatch;
	}
	// 822ACF58: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822ACF5C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822ACF60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822ACF64: 4800000C  b 0x822acf70
	pc = 0x822ACF70; continue 'dispatch;
            }
            0x822ACF68 => {
    //   block [0x822ACF68..0x822ACF70)
	// 822ACF68: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822ACF6C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822ACF70; continue 'dispatch;
            }
            0x822ACF70 => {
    //   block [0x822ACF70..0x822ACF7C)
	// 822ACF70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822ACF74: 4199FFB8  bgt cr6, 0x822acf2c
	if ctx.cr[6].gt {
	pc = 0x822ACF2C; continue 'dispatch;
	}
	// 822ACF78: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822ACF7C; continue 'dispatch;
            }
            0x822ACF7C => {
    //   block [0x822ACF7C..0x822ACF98)
	// 822ACF7C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822ACF80: 419A0040  beq cr6, 0x822acfc0
	if ctx.cr[6].eq {
	pc = 0x822ACFC0; continue 'dispatch;
	}
	// 822ACF84: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ACF88: 2F0B0064  cmpwi cr6, r11, 0x64
	ctx.cr[6].compare_i32(ctx.r[11].s32, 100, &mut ctx.xer);
	// 822ACF8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ACF90: 41990008  bgt cr6, 0x822acf98
	if ctx.cr[6].gt {
	pc = 0x822ACF98; continue 'dispatch;
	}
	// 822ACF94: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822ACF98; continue 'dispatch;
            }
            0x822ACF98 => {
    //   block [0x822ACF98..0x822ACFC0)
	// 822ACF98: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822ACF9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ACFA0: 409A0020  bne cr6, 0x822acfc0
	if !ctx.cr[6].eq {
	pc = 0x822ACFC0; continue 'dispatch;
	}
	// 822ACFA4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822ACFA8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822ACFAC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822ACFB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ACFB4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822ACFB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ACFBC: 4800001C  b 0x822acfd8
	pc = 0x822ACFD8; continue 'dispatch;
            }
            0x822ACFC0 => {
    //   block [0x822ACFC0..0x822ACFD4)
	// 822ACFC0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822ACFC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ACFC8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822ACFCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ACFD0: 48000008  b 0x822acfd8
	pc = 0x822ACFD8; continue 'dispatch;
            }
            0x822ACFD4 => {
    //   block [0x822ACFD4..0x822ACFD8)
	// 822ACFD4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822ACFD8; continue 'dispatch;
            }
            0x822ACFD8 => {
    //   block [0x822ACFD8..0x822ACFF0)
	// 822ACFD8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822ACFDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ACFE0: 419A0010  beq cr6, 0x822acff0
	if ctx.cr[6].eq {
	pc = 0x822ACFF0; continue 'dispatch;
	}
	// 822ACFE4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822ACFE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ACFEC: 409A0080  bne cr6, 0x822ad06c
	if !ctx.cr[6].eq {
	pc = 0x822AD06C; continue 'dispatch;
	}
	pc = 0x822ACFF0; continue 'dispatch;
            }
            0x822ACFF0 => {
    //   block [0x822ACFF0..0x822AD030)
	// 822ACFF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822ACFF4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 822ACFF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822ACFFC: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 822AD000: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822AD004: 4BEE6E35  bl 0x82193e38
	ctx.lr = 0x822AD008;
	sub_82193E38(ctx, base);
	// 822AD008: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822AD00C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822AD010: 48224EB9  bl 0x824d1ec8
	ctx.lr = 0x822AD014;
	sub_824D1EC8(ctx, base);
	// 822AD014: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 822AD018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AD01C: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 822AD020: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 822AD024: 4BEE6E15  bl 0x82193e38
	ctx.lr = 0x822AD028;
	sub_82193E38(ctx, base);
	// 822AD028: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822AD02C: 489FC430  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822AD030 => {
    //   block [0x822AD030..0x822AD06C)
	// 822AD030: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822AD034: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822AD038: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 822AD03C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822AD040: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AD044: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 822AD048: 4BEE6DF1  bl 0x82193e38
	ctx.lr = 0x822AD04C;
	sub_82193E38(ctx, base);
	// 822AD04C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822AD050: 387F04C4  addi r3, r31, 0x4c4
	ctx.r[3].s64 = ctx.r[31].s64 + 1220;
	// 822AD054: 48224E75  bl 0x824d1ec8
	ctx.lr = 0x822AD058;
	sub_824D1EC8(ctx, base);
	// 822AD058: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 822AD05C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AD060: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 822AD064: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 822AD068: 4BEE6DD1  bl 0x82193e38
	ctx.lr = 0x822AD06C;
	sub_82193E38(ctx, base);
	pc = 0x822AD06C; continue 'dispatch;
            }
            0x822AD06C => {
    //   block [0x822AD06C..0x822AD074)
	// 822AD06C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822AD070: 489FC3EC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AD078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AD078 size=160
    let mut pc: u32 = 0x822AD078;
    'dispatch: loop {
        match pc {
            0x822AD078 => {
    //   block [0x822AD078..0x822AD0C8)
	// 822AD078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AD07C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AD080: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822AD084: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AD088: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AD08C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AD090: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 822AD094: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AD098: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AD09C: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AD0A0: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 822AD0A4: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822AD0A8: 40990020  ble cr6, 0x822ad0c8
	if !ctx.cr[6].gt {
	pc = 0x822AD0C8; continue 'dispatch;
	}
	// 822AD0AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822AD0B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822AD0B4: 7CAA2050  subf r5, r10, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 822AD0B8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 822AD0BC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AD0C0: 487E4739  bl 0x82a917f8
	ctx.lr = 0x822AD0C4;
	sub_82A917F8(ctx, base);
	// 822AD0C4: 4800003C  b 0x822ad100
	pc = 0x822AD100; continue 'dispatch;
            }
            0x822AD0C8 => {
    //   block [0x822AD0C8..0x822AD0FC)
	// 822AD0C8: 40980038  bge cr6, 0x822ad100
	if !ctx.cr[6].lt {
	pc = 0x822AD100; continue 'dispatch;
	}
	// 822AD0CC: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822AD0D0: 7C6A4A14  add r3, r10, r9
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822AD0D4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822AD0D8: 419A0028  beq cr6, 0x822ad100
	if ctx.cr[6].eq {
	pc = 0x822AD100; continue 'dispatch;
	}
	// 822AD0DC: 7D4B5850  subf r10, r11, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 822AD0E0: 7D4A1671  srawi. r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822AD0E4: 5546103A  slwi r6, r10, 2
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 822AD0E8: 7FC61A14  add r30, r6, r3
	ctx.r[30].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 822AD0EC: 40810010  ble 0x822ad0fc
	if !ctx.cr[0].gt {
	pc = 0x822AD0FC; continue 'dispatch;
	}
	// 822AD0F0: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 822AD0F4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 822AD0F8: 489FCF31  bl 0x82caa028
	ctx.lr = 0x822AD0FC;
	sub_82CAA028(ctx, base);
	pc = 0x822AD0FC; continue 'dispatch;
            }
            0x822AD0FC => {
    //   block [0x822AD0FC..0x822AD100)
	// 822AD0FC: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x822AD100; continue 'dispatch;
            }
            0x822AD100 => {
    //   block [0x822AD100..0x822AD118)
	// 822AD100: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AD104: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AD108: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AD10C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822AD110: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AD114: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AD118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AD118 size=64
    let mut pc: u32 = 0x822AD118;
    'dispatch: loop {
        match pc {
            0x822AD118 => {
    //   block [0x822AD118..0x822AD140)
	// 822AD118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AD11C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AD120: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AD124: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AD128: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AD12C: 41980014  blt cr6, 0x822ad140
	if ctx.cr[6].lt {
	pc = 0x822AD140; continue 'dispatch;
	}
	// 822AD130: 4BFEB609  bl 0x82298738
	ctx.lr = 0x822AD134;
	sub_82298738(ctx, base);
	// 822AD134: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822AD138: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AD13C: 409A0008  bne cr6, 0x822ad144
	if !ctx.cr[6].eq {
	pc = 0x822AD144; continue 'dispatch;
	}
	pc = 0x822AD140; continue 'dispatch;
            }
            0x822AD140 => {
    //   block [0x822AD140..0x822AD144)
	// 822AD140: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822AD144; continue 'dispatch;
            }
            0x822AD144 => {
    //   block [0x822AD144..0x822AD158)
	// 822AD144: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AD148: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AD14C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AD150: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AD154: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AD178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822AD178 size=316
    let mut pc: u32 = 0x822AD178;
    'dispatch: loop {
        match pc {
            0x822AD178 => {
    //   block [0x822AD178..0x822AD1EC)
	// 822AD178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AD17C: 489FC285  bl 0x82ca9400
	ctx.lr = 0x822AD180;
	sub_82CA93D0(ctx, base);
	// 822AD180: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AD184: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822AD188: 80630034  lwz r3, 0x34(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 822AD18C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822AD190: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 822AD194: 38EA0E2C  addi r7, r10, 0xe2c
	ctx.r[7].s64 = ctx.r[10].s64 + 3628;
	// 822AD198: 61260008  ori r6, r9, 8
	ctx.r[6].u64 = ctx.r[9].u64 | 8;
	// 822AD19C: C00B0C64  lfs f0, 0xc64(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3172 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AD1A0: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 822AD1A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822AD1A8: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 822AD1AC: 910100A0  stw r8, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[8].u32 ) };
	// 822AD1B0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822AD1B4: 90E10090  stw r7, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[7].u32 ) };
	// 822AD1B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822AD1BC: 90C100A8  stw r6, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[6].u32 ) };
	// 822AD1C0: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 822AD1C4: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 822AD1C8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AD1CC: 812A0038  lwz r9, 0x38(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 822AD1D0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822AD1D4: 4E800421  bctrl
	ctx.lr = 0x822AD1D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822AD1D8: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 822AD1DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AD1E0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822AD1E4: 41990008  bgt cr6, 0x822ad1ec
	if ctx.cr[6].gt {
	pc = 0x822AD1EC; continue 'dispatch;
	}
	// 822AD1E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
            }
            0x822AD1EC => {
    //   block [0x822AD1EC..0x822AD2A4)
	// 822AD1EC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 822AD1F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AD1F4: 419A00B0  beq cr6, 0x822ad2a4
	if ctx.cr[6].eq {
	pc = 0x822AD2A4; continue 'dispatch;
	}
	// 822AD1F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AD1FC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822AD200: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 822AD204: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AD208: 419A009C  beq cr6, 0x822ad2a4
	if ctx.cr[6].eq {
	pc = 0x822AD2A4; continue 'dispatch;
	}
	// 822AD20C: 3BBA0010  addi r29, r26, 0x10
	ctx.r[29].s64 = ctx.r[26].s64 + 16;
	// 822AD210: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822AD214: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 822AD218: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 822AD21C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 822AD220: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 822AD224: 7FFE5A14  add r31, r30, r11
	ctx.r[31].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 822AD228: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822AD22C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x822AD2A4; continue 'dispatch;
            }
            0x822AD2A4 => {
    //   block [0x822AD2A4..0x822AD2B4)
	// 822AD2A4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822AD2A8: 4BFB2661  bl 0x8225f908
	ctx.lr = 0x822AD2AC;
	sub_8225F908(ctx, base);
	// 822AD2AC: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 822AD2B0: 489FC1A0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AD2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AD2B8 size=104
    let mut pc: u32 = 0x822AD2B8;
    'dispatch: loop {
        match pc {
            0x822AD2B8 => {
    //   block [0x822AD2B8..0x822AD2DC)
	// 822AD2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AD2BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AD2C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AD2C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AD2C8: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 822AD2CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AD2D0: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 822AD2D4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822AD2D8: 419A0020  beq cr6, 0x822ad2f8
	if ctx.cr[6].eq {
	pc = 0x822AD2F8; continue 'dispatch;
	}
	pc = 0x822AD2DC; continue 'dispatch;
            }
            0x822AD2DC => {
    //   block [0x822AD2DC..0x822AD2F8)
	// 822AD2DC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AD2E0: 89240014  lbz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 822AD2E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822AD2E8: 409A0018  bne cr6, 0x822ad300
	if !ctx.cr[6].eq {
	pc = 0x822AD300; continue 'dispatch;
	}
	// 822AD2EC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 822AD2F0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822AD2F4: 409AFFE8  bne cr6, 0x822ad2dc
	if !ctx.cr[6].eq {
	pc = 0x822AD2DC; continue 'dispatch;
	}
	pc = 0x822AD2F8; continue 'dispatch;
            }
            0x822AD2F8 => {
    //   block [0x822AD2F8..0x822AD300)
	// 822AD2F8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822AD2FC: 388B5E78  addi r4, r11, 0x5e78
	ctx.r[4].s64 = ctx.r[11].s64 + 24184;
	pc = 0x822AD300; continue 'dispatch;
            }
            0x822AD300 => {
    //   block [0x822AD300..0x822AD320)
	// 822AD300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AD304: 4BF42F3D  bl 0x821f0240
	ctx.lr = 0x822AD308;
	sub_821F0240(ctx, base);
	// 822AD308: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AD30C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AD310: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AD314: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AD318: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AD31C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AD320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822AD320 size=24
    let mut pc: u32 = 0x822AD320;
    'dispatch: loop {
        match pc {
            0x822AD320 => {
    //   block [0x822AD320..0x822AD338)
	// 822AD320: 8163007C  lwz r11, 0x7c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 822AD324: 556A97FE  rlwinm r10, r11, 0x12, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00003FFFu64;
	// 822AD328: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AD32C: 419A000C  beq cr6, 0x822ad338
	if ctx.cr[6].eq {
		sub_822AD338(ctx, base);
		return;
	}
	// 822AD330: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822AD334: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AD338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822AD338 size=72
    let mut pc: u32 = 0x822AD338;
    'dispatch: loop {
        match pc {
            0x822AD338 => {
    //   block [0x822AD338..0x822AD370)
	// 822AD338: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822AD33C: 89630020  lbz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 822AD340: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822AD344: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AD348: 8109011C  lwz r8, 0x11c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(284 as u32) ) } as u64;
	// 822AD34C: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 822AD350: 409A0028  bne cr6, 0x822ad378
	if !ctx.cr[6].eq {
	pc = 0x822AD378; continue 'dispatch;
	}
	// 822AD354: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AD358: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD35C: 409A0014  bne cr6, 0x822ad370
	if !ctx.cr[6].eq {
	pc = 0x822AD370; continue 'dispatch;
	}
	// 822AD360: 89630021  lbz r11, 0x21(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(33 as u32) ) } as u64;
	// 822AD364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD368: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822AD36C: 419A0008  beq cr6, 0x822ad374
	if ctx.cr[6].eq {
	pc = 0x822AD374; continue 'dispatch;
	}
	pc = 0x822AD370; continue 'dispatch;
            }
            0x822AD370 => {
    //   block [0x822AD370..0x822AD374)
	// 822AD370: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x822AD374; continue 'dispatch;
            }
            0x822AD374 => {
    //   block [0x822AD374..0x822AD378)
	// 822AD374: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x822AD378; continue 'dispatch;
            }
            0x822AD378 => {
    //   block [0x822AD378..0x822AD380)
	// 822AD378: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822AD37C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AD380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AD380 size=496
    let mut pc: u32 = 0x822AD380;
    'dispatch: loop {
        match pc {
            0x822AD380 => {
    //   block [0x822AD380..0x822AD3D0)
	// 822AD380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AD384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AD388: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AD38C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AD390: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 822AD394: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822AD398: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822AD39C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AD3A0: 419A00F4  beq cr6, 0x822ad494
	if ctx.cr[6].eq {
	pc = 0x822AD494; continue 'dispatch;
	}
	// 822AD3A4: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AD3A8: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AD3AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD3B0: 419A0020  beq cr6, 0x822ad3d0
	if ctx.cr[6].eq {
	pc = 0x822AD3D0; continue 'dispatch;
	}
	// 822AD3B4: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822AD3B8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 822AD3BC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822AD3C0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AD3C4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AD3C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AD3CC: 480000CC  b 0x822ad498
	pc = 0x822AD498; continue 'dispatch;
            }
            0x822AD3D0 => {
    //   block [0x822AD3D0..0x822AD3EC)
	// 822AD3D0: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AD3D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822AD3D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822AD3DC: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822AD3E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822AD3E4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AD3E8: 40810054  ble 0x822ad43c
	if !ctx.cr[0].gt {
	pc = 0x822AD43C; continue 'dispatch;
	}
	pc = 0x822AD3EC; continue 'dispatch;
            }
            0x822AD3EC => {
    //   block [0x822AD3EC..0x822AD40C)
	// 822AD3EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AD3F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AD3F4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822AD3F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AD3FC: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 822AD400: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AD404: 41980008  blt cr6, 0x822ad40c
	if ctx.cr[6].lt {
	pc = 0x822AD40C; continue 'dispatch;
	}
	// 822AD408: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822AD40C; continue 'dispatch;
            }
            0x822AD40C => {
    //   block [0x822AD40C..0x822AD428)
	// 822AD40C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AD410: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AD414: 419A0014  beq cr6, 0x822ad428
	if ctx.cr[6].eq {
	pc = 0x822AD428; continue 'dispatch;
	}
	// 822AD418: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AD41C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AD420: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AD424: 4800000C  b 0x822ad430
	pc = 0x822AD430; continue 'dispatch;
            }
            0x822AD428 => {
    //   block [0x822AD428..0x822AD430)
	// 822AD428: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AD42C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822AD430; continue 'dispatch;
            }
            0x822AD430 => {
    //   block [0x822AD430..0x822AD43C)
	// 822AD430: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AD434: 4199FFB8  bgt cr6, 0x822ad3ec
	if ctx.cr[6].gt {
	pc = 0x822AD3EC; continue 'dispatch;
	}
	// 822AD438: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822AD43C; continue 'dispatch;
            }
            0x822AD43C => {
    //   block [0x822AD43C..0x822AD458)
	// 822AD43C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AD440: 419A0040  beq cr6, 0x822ad480
	if ctx.cr[6].eq {
	pc = 0x822AD480; continue 'dispatch;
	}
	// 822AD444: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AD448: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 822AD44C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AD450: 41990008  bgt cr6, 0x822ad458
	if ctx.cr[6].gt {
	pc = 0x822AD458; continue 'dispatch;
	}
	// 822AD454: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822AD458; continue 'dispatch;
            }
            0x822AD458 => {
    //   block [0x822AD458..0x822AD480)
	// 822AD458: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AD45C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD460: 409A0020  bne cr6, 0x822ad480
	if !ctx.cr[6].eq {
	pc = 0x822AD480; continue 'dispatch;
	}
	// 822AD464: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AD468: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822AD46C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822AD470: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AD474: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AD478: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AD47C: 4800001C  b 0x822ad498
	pc = 0x822AD498; continue 'dispatch;
            }
            0x822AD480 => {
    //   block [0x822AD480..0x822AD494)
	// 822AD480: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822AD484: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AD488: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AD48C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AD490: 48000008  b 0x822ad498
	pc = 0x822AD498; continue 'dispatch;
            }
            0x822AD494 => {
    //   block [0x822AD494..0x822AD498)
	// 822AD494: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822AD498; continue 'dispatch;
            }
            0x822AD498 => {
    //   block [0x822AD498..0x822AD4B8)
	// 822AD498: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AD49C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD4A0: 419A00B8  beq cr6, 0x822ad558
	if ctx.cr[6].eq {
	pc = 0x822AD558; continue 'dispatch;
	}
	// 822AD4A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AD4A8: 4BFFFE79  bl 0x822ad320
	ctx.lr = 0x822AD4AC;
	sub_822AD320(ctx, base);
	// 822AD4AC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822AD4B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD4B4: 419A001C  beq cr6, 0x822ad4d0
	if ctx.cr[6].eq {
	pc = 0x822AD4D0; continue 'dispatch;
	}
	pc = 0x822AD4B8; continue 'dispatch;
            }
            0x822AD4B8 => {
    //   block [0x822AD4B8..0x822AD4D0)
	// 822AD4B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822AD4BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AD4C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AD4C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AD4C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AD4CC: 4E800020  blr
	return;
            }
            0x822AD4D0 => {
    //   block [0x822AD4D0..0x822AD4F4)
	// 822AD4D0: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 822AD4D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD4D8: 409AFFE0  bne cr6, 0x822ad4b8
	if !ctx.cr[6].eq {
	pc = 0x822AD4B8; continue 'dispatch;
	}
	// 822AD4DC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822AD4E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822AD4E4: 419A0010  beq cr6, 0x822ad4f4
	if ctx.cr[6].eq {
	pc = 0x822AD4F4; continue 'dispatch;
	}
	// 822AD4E8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 822AD4EC: 4BF3B6A5  bl 0x821e8b90
	ctx.lr = 0x822AD4F0;
	sub_821E8B90(ctx, base);
	// 822AD4F0: 48000008  b 0x822ad4f8
	pc = 0x822AD4F8; continue 'dispatch;
            }
            0x822AD4F4 => {
    //   block [0x822AD4F4..0x822AD4F8)
	// 822AD4F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822AD4F8; continue 'dispatch;
            }
            0x822AD4F8 => {
    //   block [0x822AD4F8..0x822AD51C)
	// 822AD4F8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822AD4FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD500: 409AFFB8  bne cr6, 0x822ad4b8
	if !ctx.cr[6].eq {
	pc = 0x822AD4B8; continue 'dispatch;
	}
	// 822AD504: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822AD508: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822AD50C: 419A0010  beq cr6, 0x822ad51c
	if ctx.cr[6].eq {
	pc = 0x822AD51C; continue 'dispatch;
	}
	// 822AD510: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 822AD514: 4BF3B67D  bl 0x821e8b90
	ctx.lr = 0x822AD518;
	sub_821E8B90(ctx, base);
	// 822AD518: 48000008  b 0x822ad520
	pc = 0x822AD520; continue 'dispatch;
            }
            0x822AD51C => {
    //   block [0x822AD51C..0x822AD520)
	// 822AD51C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822AD520; continue 'dispatch;
            }
            0x822AD520 => {
    //   block [0x822AD520..0x822AD544)
	// 822AD520: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822AD524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD528: 409AFF90  bne cr6, 0x822ad4b8
	if !ctx.cr[6].eq {
	pc = 0x822AD4B8; continue 'dispatch;
	}
	// 822AD52C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822AD530: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822AD534: 419A0010  beq cr6, 0x822ad544
	if ctx.cr[6].eq {
	pc = 0x822AD544; continue 'dispatch;
	}
	// 822AD538: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 822AD53C: 4BF3B655  bl 0x821e8b90
	ctx.lr = 0x822AD540;
	sub_821E8B90(ctx, base);
	// 822AD540: 48000008  b 0x822ad548
	pc = 0x822AD548; continue 'dispatch;
            }
            0x822AD544 => {
    //   block [0x822AD544..0x822AD548)
	// 822AD544: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822AD548; continue 'dispatch;
            }
            0x822AD548 => {
    //   block [0x822AD548..0x822AD558)
	// 822AD548: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822AD54C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822AD550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD554: 409A0008  bne cr6, 0x822ad55c
	if !ctx.cr[6].eq {
	pc = 0x822AD55C; continue 'dispatch;
	}
	pc = 0x822AD558; continue 'dispatch;
            }
            0x822AD558 => {
    //   block [0x822AD558..0x822AD55C)
	// 822AD558: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822AD55C; continue 'dispatch;
            }
            0x822AD55C => {
    //   block [0x822AD55C..0x822AD570)
	// 822AD55C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AD560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AD564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AD568: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AD56C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AD570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822AD570 size=20
    let mut pc: u32 = 0x822AD570;
    'dispatch: loop {
        match pc {
            0x822AD570 => {
    //   block [0x822AD570..0x822AD584)
	// 822AD570: 816301EC  lwz r11, 0x1ec(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(492 as u32) ) } as u64;
	// 822AD574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD578: 409A000C  bne cr6, 0x822ad584
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x822AD584);
		return;
	}
	// 822AD57C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822AD580: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AD5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822AD5A8 size=336
    let mut pc: u32 = 0x822AD5A8;
    'dispatch: loop {
        match pc {
            0x822AD5A8 => {
    //   block [0x822AD5A8..0x822AD6F8)
	// 822AD5A8: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 822AD5AC: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 822AD5B0: 394400B0  addi r10, r4, 0xb0
	ctx.r[10].s64 = ctx.r[4].s64 + 176;
	// 822AD5B4: 390400F0  addi r8, r4, 0xf0
	ctx.r[8].s64 = ctx.r[4].s64 + 240;
	// 822AD5B8: 38E1FFC0  addi r7, r1, -0x40
	ctx.r[7].s64 = ctx.r[1].s64 + -64;
	// 822AD5BC: 3961FFA0  addi r11, r1, -0x60
	ctx.r[11].s64 = ctx.r[1].s64 + -96;
	// 822AD5C0: 38C1FFD0  addi r6, r1, -0x30
	ctx.r[6].s64 = ctx.r[1].s64 + -48;
	// 822AD5C4: 3921FFB0  addi r9, r1, -0x50
	ctx.r[9].s64 = ctx.r[1].s64 + -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AD6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822AD6F8 size=12
    let mut pc: u32 = 0x822AD6F8;
    'dispatch: loop {
        match pc {
            0x822AD6F8 => {
    //   block [0x822AD6F8..0x822AD704)
	// 822AD6F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 822AD6FC: 386B5B58  addi r3, r11, 0x5b58
	ctx.r[3].s64 = ctx.r[11].s64 + 23384;
	// 822AD700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AD708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822AD708 size=352
    let mut pc: u32 = 0x822AD708;
    'dispatch: loop {
        match pc {
            0x822AD708 => {
    //   block [0x822AD708..0x822AD7B0)
	// 822AD708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AD70C: 489FBCF1  bl 0x82ca93fc
	ctx.lr = 0x822AD710;
	sub_82CA93D0(ctx, base);
	// 822AD710: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AD714: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822AD718: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822AD71C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AD720: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822AD724: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822AD728: 4E800421  bctrl
	ctx.lr = 0x822AD72C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822AD72C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 822AD730: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822AD734: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 822AD738: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 822AD73C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822AD740: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 822AD744: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AD748: 80E80020  lwz r7, 0x20(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 822AD74C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 822AD750: 4E800421  bctrl
	ctx.lr = 0x822AD754;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822AD754: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822AD758: 4BF52B89  bl 0x822002e0
	ctx.lr = 0x822AD75C;
	sub_822002E0(ctx, base);
	// 822AD75C: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822AD760: 83210050  lwz r25, 0x50(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822AD764: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 822AD768: 419A00B0  beq cr6, 0x822ad818
	if ctx.cr[6].eq {
	pc = 0x822AD818; continue 'dispatch;
	}
	// 822AD76C: 38990024  addi r4, r25, 0x24
	ctx.r[4].s64 = ctx.r[25].s64 + 36;
	// 822AD770: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822AD774: 4BF42B7D  bl 0x821f02f0
	ctx.lr = 0x822AD778;
	sub_821F02F0(ctx, base);
	// 822AD778: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 822AD77C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD780: 419A0098  beq cr6, 0x822ad818
	if ctx.cr[6].eq {
	pc = 0x822AD818; continue 'dispatch;
	}
	// 822AD784: 815B0018  lwz r10, 0x18(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 822AD788: 3B40000C  li r26, 0xc
	ctx.r[26].s64 = 12;
	// 822AD78C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822AD790: 7D09D3D7  divw. r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822AD794: 41820084  beq 0x822ad818
	if ctx.cr[0].eq {
	pc = 0x822AD818; continue 'dispatch;
	}
	// 822AD798: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AD79C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AD7A0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822AD7A4: 7D09D3D7  divw. r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822AD7A8: 41820070  beq 0x822ad818
	if ctx.cr[0].eq {
	pc = 0x822AD818; continue 'dispatch;
	}
	// 822AD7AC: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
            }
            0x822AD7B0 => {
    //   block [0x822AD7B0..0x822AD818)
	// 822AD7B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822AD7B4: 7C3F5C2E  lfsx f1, r31, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822AD7B8: 7FDF5A14  add r30, r31, r11
	ctx.r[30].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 822AD7BC: 48025E8D  bl 0x822d3648
	ctx.lr = 0x822AD7C0;
	sub_822D3648(ctx, base);
	// 822AD7C0: D0210058  stfs f1, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822AD7C4: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 822AD7C8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822AD7CC: 4BF42A75  bl 0x821f0240
	ctx.lr = 0x822AD7D0;
	sub_821F0240(ctx, base);
	// 822AD7D0: 389E0008  addi r4, r30, 8
	ctx.r[4].s64 = ctx.r[30].s64 + 8;
	// 822AD7D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822AD7D8: 4BF42A69  bl 0x821f0240
	ctx.lr = 0x822AD7DC;
	sub_821F0240(ctx, base);
	// 822AD7DC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 822AD7E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AD7E4: 482B98E5  bl 0x825670c8
	ctx.lr = 0x822AD7E8;
	sub_825670C8(ctx, base);
	// 822AD7E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822AD7EC: 4BF675ED  bl 0x82214dd8
	ctx.lr = 0x822AD7F0;
	sub_82214DD8(ctx, base);
	// 822AD7F0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822AD7F4: 4BF675E5  bl 0x82214dd8
	ctx.lr = 0x822AD7F8;
	sub_82214DD8(ctx, base);
	// 822AD7F8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AD7FC: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AD800: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822AD804: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 822AD808: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822AD80C: 7D09D3D6  divw r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 822AD810: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822AD814: 409AFF9C  bne cr6, 0x822ad7b0
	if !ctx.cr[6].eq {
	pc = 0x822AD7B0; continue 'dispatch;
	}
	pc = 0x822AD818; continue 'dispatch;
            }
            0x822AD818 => {
    //   block [0x822AD818..0x822AD824)
	// 822AD818: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 822AD81C: 419A0044  beq cr6, 0x822ad860
	if ctx.cr[6].eq {
	pc = 0x822AD860; continue 'dispatch;
	}
	// 822AD820: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	pc = 0x822AD824; continue 'dispatch;
            }
            0x822AD824 => {
    //   block [0x822AD824..0x822AD860)
	// 822AD824: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822AD828: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822AD82C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822AD830: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822AD834: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822AD838: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822AD83C: 4082FFE8  bne 0x822ad824
	if !ctx.cr[0].eq {
	pc = 0x822AD824; continue 'dispatch;
	}
	// 822AD840: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 822AD844: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AD848: 409A0018  bne cr6, 0x822ad860
	if !ctx.cr[6].eq {
	pc = 0x822AD860; continue 'dispatch;
	}
	// 822AD84C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AD850: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822AD854: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AD858: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822AD85C: 4E800421  bctrl
	ctx.lr = 0x822AD860;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822AD860 => {
    //   block [0x822AD860..0x822AD868)
	// 822AD860: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822AD864: 489FBBE8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AD868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AD868 size=232
    let mut pc: u32 = 0x822AD868;
    'dispatch: loop {
        match pc {
            0x822AD868 => {
    //   block [0x822AD868..0x822AD8A0)
	// 822AD868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AD86C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AD870: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822AD874: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AD878: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AD87C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822AD880: 387E006C  addi r3, r30, 0x6c
	ctx.r[3].s64 = ctx.r[30].s64 + 108;
	// 822AD884: 3BFE0064  addi r31, r30, 0x64
	ctx.r[31].s64 = ctx.r[30].s64 + 100;
	// 822AD888: 817E006C  lwz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 822AD88C: 815E0064  lwz r10, 0x64(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 822AD890: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822AD894: 419A000C  beq cr6, 0x822ad8a0
	if ctx.cr[6].eq {
	pc = 0x822AD8A0; continue 'dispatch;
	}
	// 822AD898: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822AD89C: 4BECDAFD  bl 0x8217b398
	ctx.lr = 0x822AD8A0;
	sub_8217B398(ctx, base);
	pc = 0x822AD8A0; continue 'dispatch;
            }
            0x822AD8A0 => {
    //   block [0x822AD8A0..0x822AD8BC)
	// 822AD8A0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AD8A4: 480000AD  bl 0x822ad950
	ctx.lr = 0x822AD8A8;
	sub_822AD950(ctx, base);
	// 822AD8A8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822AD8AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD8B0: 419A000C  beq cr6, 0x822ad8bc
	if ctx.cr[6].eq {
	pc = 0x822AD8BC; continue 'dispatch;
	}
	// 822AD8B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AD8B8: 997E004F  stb r11, 0x4f(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(79 as u32), ctx.r[11].u8 ) };
	pc = 0x822AD8BC; continue 'dispatch;
            }
            0x822AD8BC => {
    //   block [0x822AD8BC..0x822AD910)
	// 822AD8BC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AD8C0: 4BFBDD41  bl 0x8226b600
	ctx.lr = 0x822AD8C4;
	sub_8226B600(ctx, base);
	// 822AD8C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AD8C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822AD8CC: 419A006C  beq cr6, 0x822ad938
	if ctx.cr[6].eq {
	pc = 0x822AD938; continue 'dispatch;
	}
	// 822AD8D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AD8D4: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822AD8D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822AD8DC: 4E800421  bctrl
	ctx.lr = 0x822AD8E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822AD8E0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822AD8E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822AD8E8: 409A0038  bne cr6, 0x822ad920
	if !ctx.cr[6].eq {
	pc = 0x822AD920; continue 'dispatch;
	}
	// 822AD8EC: 897E007D  lbz r11, 0x7d(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(125 as u32) ) } as u64;
	// 822AD8F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD8F4: 419A0044  beq cr6, 0x822ad938
	if ctx.cr[6].eq {
	pc = 0x822AD938; continue 'dispatch;
	}
	// 822AD8F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AD8FC: 894B004C  lbz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AD900: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AD904: 419A000C  beq cr6, 0x822ad910
	if ctx.cr[6].eq {
	pc = 0x822AD910; continue 'dispatch;
	}
	// 822AD908: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822AD90C: 48000008  b 0x822ad914
	pc = 0x822AD914; continue 'dispatch;
            }
            0x822AD910 => {
    //   block [0x822AD910..0x822AD914)
	// 822AD910: 896B004D  lbz r11, 0x4d(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(77 as u32) ) } as u64;
	pc = 0x822AD914; continue 'dispatch;
            }
            0x822AD914 => {
    //   block [0x822AD914..0x822AD920)
	// 822AD914: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AD918: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD91C: 419A001C  beq cr6, 0x822ad938
	if ctx.cr[6].eq {
	pc = 0x822AD938; continue 'dispatch;
	}
	pc = 0x822AD920; continue 'dispatch;
            }
            0x822AD920 => {
    //   block [0x822AD920..0x822AD938)
	// 822AD920: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AD924: 4BFD8885  bl 0x822861a8
	ctx.lr = 0x822AD928;
	sub_822861A8(ctx, base);
	// 822AD928: 817E0074  lwz r11, 0x74(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 822AD92C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AD930: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 822AD934: 4BEF35CD  bl 0x821a0f00
	ctx.lr = 0x822AD938;
	sub_821A0F00(ctx, base);
	pc = 0x822AD938; continue 'dispatch;
            }
            0x822AD938 => {
    //   block [0x822AD938..0x822AD950)
	// 822AD938: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AD93C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AD940: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AD944: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822AD948: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AD94C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AD950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AD950 size=324
    let mut pc: u32 = 0x822AD950;
    'dispatch: loop {
        match pc {
            0x822AD950 => {
    //   block [0x822AD950..0x822AD97C)
	// 822AD950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AD954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AD958: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AD95C: 8963004F  lbz r11, 0x4f(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(79 as u32) ) } as u64;
	// 822AD960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AD964: 419A0018  beq cr6, 0x822ad97c
	if ctx.cr[6].eq {
	pc = 0x822AD97C; continue 'dispatch;
	}
	// 822AD968: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822AD96C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AD970: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AD974: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AD978: 4E800020  blr
	return;
            }
            0x822AD97C => {
    //   block [0x822AD97C..0x822AD9A0)
	// 822AD97C: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 822AD980: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 822AD984: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 822AD988: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822AD98C: 7D093050  subf r8, r9, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 822AD990: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822AD994: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 822AD998: 7D685BD7  divw. r11, r8, r11
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AD99C: 4081005C  ble 0x822ad9f8
	if !ctx.cr[0].gt {
	pc = 0x822AD9F8; continue 'dispatch;
	}
	pc = 0x822AD9A0; continue 'dispatch;
            }
            0x822AD9A0 => {
    //   block [0x822AD9A0..0x822AD9C8)
	// 822AD9A0: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AD9A4: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AD9A8: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822AD9AC: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AD9B0: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 822AD9B4: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AD9B8: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 822AD9BC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AD9C0: 41980008  blt cr6, 0x822ad9c8
	if ctx.cr[6].lt {
	pc = 0x822AD9C8; continue 'dispatch;
	}
	// 822AD9C4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822AD9C8; continue 'dispatch;
            }
            0x822AD9C8 => {
    //   block [0x822AD9C8..0x822AD9E4)
	// 822AD9C8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AD9CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AD9D0: 419A0014  beq cr6, 0x822ad9e4
	if ctx.cr[6].eq {
	pc = 0x822AD9E4; continue 'dispatch;
	}
	// 822AD9D4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822AD9D8: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 822AD9DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AD9E0: 4800000C  b 0x822ad9ec
	pc = 0x822AD9EC; continue 'dispatch;
            }
            0x822AD9E4 => {
    //   block [0x822AD9E4..0x822AD9EC)
	// 822AD9E4: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822AD9E8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x822AD9EC; continue 'dispatch;
            }
            0x822AD9EC => {
    //   block [0x822AD9EC..0x822AD9F8)
	// 822AD9EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AD9F0: 4199FFB0  bgt cr6, 0x822ad9a0
	if ctx.cr[6].gt {
	pc = 0x822AD9A0; continue 'dispatch;
	}
	// 822AD9F4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x822AD9F8; continue 'dispatch;
            }
            0x822AD9F8 => {
    //   block [0x822AD9F8..0x822ADA14)
	// 822AD9F8: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AD9FC: 419A0034  beq cr6, 0x822ada30
	if ctx.cr[6].eq {
	pc = 0x822ADA30; continue 'dispatch;
	}
	// 822ADA00: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ADA04: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822ADA08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ADA0C: 41990008  bgt cr6, 0x822ada14
	if ctx.cr[6].gt {
	pc = 0x822ADA14; continue 'dispatch;
	}
	// 822ADA10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822ADA14; continue 'dispatch;
            }
            0x822ADA14 => {
    //   block [0x822ADA14..0x822ADA30)
	// 822ADA14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822ADA18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ADA1C: 409A0014  bne cr6, 0x822ada30
	if !ctx.cr[6].eq {
	pc = 0x822ADA30; continue 'dispatch;
	}
	// 822ADA20: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822ADA24: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822ADA28: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822ADA2C: 48000008  b 0x822ada34
	pc = 0x822ADA34; continue 'dispatch;
            }
            0x822ADA30 => {
    //   block [0x822ADA30..0x822ADA34)
	// 822ADA30: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x822ADA34; continue 'dispatch;
            }
            0x822ADA34 => {
    //   block [0x822ADA34..0x822ADA4C)
	// 822ADA34: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 822ADA38: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822ADA3C: 419A0010  beq cr6, 0x822ada4c
	if ctx.cr[6].eq {
	pc = 0x822ADA4C; continue 'dispatch;
	}
	// 822ADA40: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ADA44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ADA48: 4800000C  b 0x822ada54
	pc = 0x822ADA54; continue 'dispatch;
            }
            0x822ADA4C => {
    //   block [0x822ADA4C..0x822ADA54)
	// 822ADA4C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822ADA50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822ADA54; continue 'dispatch;
            }
            0x822ADA54 => {
    //   block [0x822ADA54..0x822ADA80)
	// 822ADA54: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822ADA58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ADA5C: 419A0024  beq cr6, 0x822ada80
	if ctx.cr[6].eq {
	pc = 0x822ADA80; continue 'dispatch;
	}
	// 822ADA60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ADA64: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822ADA68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822ADA6C: 4E800421  bctrl
	ctx.lr = 0x822ADA70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ADA70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822ADA74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822ADA78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822ADA7C: 4E800020  blr
	return;
            }
            0x822ADA80 => {
    //   block [0x822ADA80..0x822ADA94)
	// 822ADA80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822ADA84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822ADA88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822ADA8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822ADA90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ADA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ADA98 size=640
    let mut pc: u32 = 0x822ADA98;
    'dispatch: loop {
        match pc {
            0x822ADA98 => {
    //   block [0x822ADA98..0x822ADAF0)
	// 822ADA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ADA9C: 489FB965  bl 0x82ca9400
	ctx.lr = 0x822ADAA0;
	sub_82CA93D0(ctx, base);
	// 822ADAA0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ADAA4: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 822ADAA8: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 822ADAAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822ADAB0: 3B8B3BD4  addi r28, r11, 0x3bd4
	ctx.r[28].s64 = ctx.r[11].s64 + 15316;
	// 822ADAB4: 816A3BE4  lwz r11, 0x3be4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15332 as u32) ) } as u64;
	// 822ADAB8: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822ADABC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822ADAC0: 409A0030  bne cr6, 0x822adaf0
	if !ctx.cr[6].eq {
	pc = 0x822ADAF0; continue 'dispatch;
	}
	// 822ADAC4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 822ADAC8: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 822ADACC: 916A3BE4  stw r11, 0x3be4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15332 as u32), ctx.r[11].u32 ) };
	// 822ADAD0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 822ADAD4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822ADAD8: 913C0004  stw r9, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 822ADADC: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 822ADAE0: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 822ADAE4: 917C000C  stw r11, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822ADAE8: 386AB888  addi r3, r10, -0x4778
	ctx.r[3].s64 = ctx.r[10].s64 + -18296;
	// 822ADAEC: 489FC435  bl 0x82ca9f20
	ctx.lr = 0x822ADAF0;
	sub_82CA9F20(ctx, base);
	pc = 0x822ADAF0; continue 'dispatch;
            }
            0x822ADAF0 => {
    //   block [0x822ADAF0..0x822ADB20)
	// 822ADAF0: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 822ADAF4: 817A6AB8  lwz r11, 0x6ab8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822ADAF8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ADAFC: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 822ADB00: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ADB04: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ADB08: 550A003E  slwi r10, r8, 0
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822ADB0C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ADB10: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822ADB14: 409A000C  bne cr6, 0x822adb20
	if !ctx.cr[6].eq {
	pc = 0x822ADB20; continue 'dispatch;
	}
	// 822ADB18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 822ADB1C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822ADB20; continue 'dispatch;
            }
            0x822ADB20 => {
    //   block [0x822ADB20..0x822ADB54)
	// 822ADB20: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ADB24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ADB28: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ADB2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822ADB30: 4E800421  bctrl
	ctx.lr = 0x822ADB34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822ADB34: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 822ADB38: 419A004C  beq cr6, 0x822adb84
	if ctx.cr[6].eq {
	pc = 0x822ADB84; continue 'dispatch;
	}
	// 822ADB3C: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 822ADB40: 419A0044  beq cr6, 0x822adb84
	if ctx.cr[6].eq {
	pc = 0x822ADB84; continue 'dispatch;
	}
	// 822ADB44: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ADB48: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ADB4C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822ADB50: 419A002C  beq cr6, 0x822adb7c
	if ctx.cr[6].eq {
	pc = 0x822ADB7C; continue 'dispatch;
	}
            }
            0x822ADB54 => {
    //   block [0x822ADB54..0x822ADB7C)
	// 822ADB54: 817A6AB8  lwz r11, 0x6ab8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822ADB58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822ADB5C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ADB60: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822ADB64: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ADB68: 480A2D59  bl 0x823508c0
	ctx.lr = 0x822ADB6C;
	sub_823508C0(ctx, base);
	// 822ADB6C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ADB70: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 822ADB74: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822ADB78: 409AFFDC  bne cr6, 0x822adb54
	if !ctx.cr[6].eq {
	pc = 0x822ADB54; continue 'dispatch;
	}
	pc = 0x822ADB7C; continue 'dispatch;
            }
            0x822ADB7C => {
    //   block [0x822ADB7C..0x822ADB84)
	// 822ADB7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822ADB80: 488BB6B1  bl 0x82b69230
	ctx.lr = 0x822ADB84;
	sub_82B69230(ctx, base);
	pc = 0x822ADB84; continue 'dispatch;
            }
            0x822ADB84 => {
    //   block [0x822ADB84..0x822ADBE4)
	// 822ADB84: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 822ADB88: 894BEB04  lbz r10, -0x14fc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5372 as u32) ) } as u64;
	// 822ADB8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ADB90: 419A0180  beq cr6, 0x822add10
	if ctx.cr[6].eq {
	pc = 0x822ADD10; continue 'dispatch;
	}
	// 822ADB94: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 822ADB98: 4BF716C1  bl 0x8221f258
	ctx.lr = 0x822ADB9C;
	sub_8221F258(ctx, base);
	// 822ADB9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822ADBA0: 419A0044  beq cr6, 0x822adbe4
	if ctx.cr[6].eq {
	pc = 0x822ADBE4; continue 'dispatch;
	}
	// 822ADBA4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822ADBA8: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 822ADBAC: 392B4C64  addi r9, r11, 0x4c64
	ctx.r[9].s64 = ctx.r[11].s64 + 19556;
	// 822ADBB0: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 822ADBB4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822ADBB8: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822ADBBC: 93C3000C  stw r30, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 822ADBC0: 93C30010  stw r30, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 822ADBC4: 93C30014  stw r30, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 822ADBC8: 9963001A  stb r11, 0x1a(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(26 as u32), ctx.r[11].u8 ) };
	// 822ADBCC: 9963001B  stb r11, 0x1b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(27 as u32), ctx.r[11].u8 ) };
	// 822ADBD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822ADBD4: 9BC30019  stb r30, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[30].u8 ) };
	// 822ADBD8: 9BC30018  stb r30, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 822ADBDC: 9BC3001C  stb r30, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 822ADBE0: 48000008  b 0x822adbe8
	pc = 0x822ADBE8; continue 'dispatch;
            }
            0x822ADBE4 => {
    //   block [0x822ADBE4..0x822ADBE8)
	// 822ADBE4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822ADBE8; continue 'dispatch;
            }
            0x822ADBE8 => {
    //   block [0x822ADBE8..0x822ADC0C)
	// 822ADBE8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 822ADBEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ADBF0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 822ADBF4: 419A0018  beq cr6, 0x822adc0c
	if ctx.cr[6].eq {
	pc = 0x822ADC0C; continue 'dispatch;
	}
	// 822ADBF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822ADBFC: 487570C5  bl 0x82a04cc0
	ctx.lr = 0x822ADC00;
	sub_82A04CC0(ctx, base);
	// 822ADC00: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822ADC04: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822ADC08: 4800000C  b 0x822adc14
	pc = 0x822ADC14; continue 'dispatch;
            }
            0x822ADC0C => {
    //   block [0x822ADC0C..0x822ADC14)
	// 822ADC0C: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 822ADC10: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	pc = 0x822ADC14; continue 'dispatch;
            }
            0x822ADC14 => {
    //   block [0x822ADC14..0x822ADC44)
	// 822ADC14: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822ADC18: 3BC00020  li r30, 0x20
	ctx.r[30].s64 = 32;
	// 822ADC1C: 3BEB9C78  addi r31, r11, -0x6388
	ctx.r[31].s64 = ctx.r[11].s64 + -25480;
	// 822ADC20: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 822ADC24: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 822ADC28: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ADC2C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ADC30: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 822ADC34: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822ADC38: 419A000C  beq cr6, 0x822adc44
	if ctx.cr[6].eq {
	pc = 0x822ADC44; continue 'dispatch;
	}
	// 822ADC3C: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822ADC40: 419A0008  beq cr6, 0x822adc48
	if ctx.cr[6].eq {
	pc = 0x822ADC48; continue 'dispatch;
	}
	pc = 0x822ADC44; continue 'dispatch;
            }
            0x822ADC44 => {
    //   block [0x822ADC44..0x822ADC48)
	// 822ADC44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822ADC48; continue 'dispatch;
            }
            0x822ADC48 => {
    //   block [0x822ADC48..0x822ADC5C)
	// 822ADC48: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822ADC4C: 419A0058  beq cr6, 0x822adca4
	if ctx.cr[6].eq {
	pc = 0x822ADCA4; continue 'dispatch;
	}
	// 822ADC50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822ADC54: 409A0008  bne cr6, 0x822adc5c
	if !ctx.cr[6].eq {
	pc = 0x822ADC5C; continue 'dispatch;
	}
	// 822ADC58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822ADC5C; continue 'dispatch;
            }
            0x822ADC5C => {
    //   block [0x822ADC5C..0x822ADC6C)
	// 822ADC5C: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ADC60: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822ADC64: 409A0008  bne cr6, 0x822adc6c
	if !ctx.cr[6].eq {
	pc = 0x822ADC6C; continue 'dispatch;
	}
	// 822ADC68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822ADC6C; continue 'dispatch;
            }
            0x822ADC6C => {
    //   block [0x822ADC6C..0x822ADC7C)
	// 822ADC6C: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 822ADC70: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822ADC74: 409A0008  bne cr6, 0x822adc7c
	if !ctx.cr[6].eq {
	pc = 0x822ADC7C; continue 'dispatch;
	}
	// 822ADC78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822ADC7C; continue 'dispatch;
            }
            0x822ADC7C => {
    //   block [0x822ADC7C..0x822ADCA4)
	// 822ADC7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x822ADCA4; continue 'dispatch;
            }
            0x822ADCA4 => {
    //   block [0x822ADCA4..0x822ADD10)
	// 822ADCA4: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 822ADCA8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822ADCAC: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 822ADCB0: 419A0020  beq cr6, 0x822adcd0
	if ctx.cr[6].eq {
	pc = 0x822ADCD0; continue 'dispatch;
	}
	// 822ADCB4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 822ADCB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822ADCBC: 7D60D828  lwarx r11, 0, r27
	// lwarx
	let ea = ctx.r[27].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 822ADCC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822ADCC4: 7D60D92D  stwcx. r11, 0, r27
	// stwcx.
	let addr = ctx.r[27].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822ADCC8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822ADCCC: 4082FFE8  bne 0x822adcb4
	if !ctx.cr[0].eq {
	pc = 0x822ADCB4; continue 'dispatch;
	}
	// 822ADCD0: 817A6AB8  lwz r11, 0x6ab8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822ADCD4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 822ADCD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822ADCDC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ADCE0: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822ADCE4: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ADCE8: 480A2AF9  bl 0x823507e0
	ctx.lr = 0x822ADCEC;
	sub_823507E0(ctx, base);
	// 822ADCEC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822ADCF0: 4BF09E29  bl 0x821b7b18
	ctx.lr = 0x822ADCF4;
	sub_821B7B18(ctx, base);
	// 822ADCF4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822ADCF8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822ADCFC: 480A8E1D  bl 0x82356b18
	ctx.lr = 0x822ADD00;
	sub_82356B18(ctx, base);
	// 822ADD00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822ADD04: 4BF09E15  bl 0x821b7b18
	ctx.lr = 0x822ADD08;
	sub_821B7B18(ctx, base);
	// 822ADD08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822ADD0C: 4BF09E0D  bl 0x821b7b18
	ctx.lr = 0x822ADD10;
	sub_821B7B18(ctx, base);
	pc = 0x822ADD10; continue 'dispatch;
            }
            0x822ADD10 => {
    //   block [0x822ADD10..0x822ADD18)
	// 822ADD10: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822ADD14: 489FB73C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ADD18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822ADD18 size=420
    let mut pc: u32 = 0x822ADD18;
    'dispatch: loop {
        match pc {
            0x822ADD18 => {
    //   block [0x822ADD18..0x822ADD6C)
	// 822ADD18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ADD1C: 489FB6E5  bl 0x82ca9400
	ctx.lr = 0x822ADD20;
	sub_82CA93D0(ctx, base);
	// 822ADD20: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ADD24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822ADD28: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822ADD2C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822ADD30: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 822ADD34: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822ADD38: C01F0034  lfs f0, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ADD3C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 822ADD40: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822ADD44: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 822ADD48: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ADD4C: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 822ADD50: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 822ADD54: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 822ADD58: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ADD5C: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 822ADD60: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 822ADD64: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 822ADD68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x822ADD6C; continue 'dispatch;
            }
            0x822ADD6C => {
    //   block [0x822ADD6C..0x822ADDA8)
	// 822ADD6C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 822ADD70: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 822ADD74: 4200FFF8  bdnz 0x822add6c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822ADD6C; continue 'dispatch;
	}
	// 822ADD78: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ADD7C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 822ADD80: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822ADD84: 9B810118  stb r28, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[28].u8 ) };
	// 822ADD88: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ADD8C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 822ADD90: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822ADD94: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 822ADD98: C01E003C  lfs f0, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ADD9C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 822ADDA0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822ADDA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x822ADDA8; continue 'dispatch;
            }
            0x822ADDA8 => {
    //   block [0x822ADDA8..0x822ADDF4)
	// 822ADDA8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822ADDAC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822ADDB0: 4200FFF8  bdnz 0x822adda8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822ADDA8; continue 'dispatch;
	}
	// 822ADDB4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 822ADDB8: 9B8100B8  stb r28, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u8 ) };
	// 822ADDBC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822ADDC0: 3BABC064  addi r29, r11, -0x3f9c
	ctx.r[29].s64 = ctx.r[11].s64 + -16284;
	// 822ADDC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822ADDC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822ADDCC: 4BF3A8AD  bl 0x821e8678
	ctx.lr = 0x822ADDD0;
	sub_821E8678(ctx, base);
	// 822ADDD0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822ADDD4: 41820020  beq 0x822addf4
	if ctx.cr[0].eq {
	pc = 0x822ADDF4; continue 'dispatch;
	}
	// 822ADDD8: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ADDDC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822ADDE0: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ADDE4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822ADDE8: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ADDEC: 9B8100B8  stb r28, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u8 ) };
	// 822ADDF0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	pc = 0x822ADDF4; continue 'dispatch;
            }
            0x822ADDF4 => {
    //   block [0x822ADDF4..0x822ADE28)
	// 822ADDF4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822ADDF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822ADDFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822ADE00: 4BF3A879  bl 0x821e8678
	ctx.lr = 0x822ADE04;
	sub_821E8678(ctx, base);
	// 822ADE04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822ADE08: 41820020  beq 0x822ade28
	if ctx.cr[0].eq {
	pc = 0x822ADE28; continue 'dispatch;
	}
	// 822ADE0C: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ADE10: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822ADE14: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ADE18: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 822ADE1C: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822ADE20: 9B810118  stb r28, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[28].u8 ) };
	// 822ADE24: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	pc = 0x822ADE28; continue 'dispatch;
            }
            0x822ADE28 => {
    //   block [0x822ADE28..0x822ADE74)
	// 822ADE28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822ADE2C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 822ADE30: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 822ADE34: 3BAB1890  addi r29, r11, 0x1890
	ctx.r[29].s64 = ctx.r[11].s64 + 6288;
	// 822ADE38: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 822ADE3C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 822ADE40: 4BF00869  bl 0x821ae6a8
	ctx.lr = 0x822ADE44;
	sub_821AE6A8(ctx, base);
	// 822ADE44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822ADE48: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 822ADE4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822ADE50: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 822ADE54: 4BF00855  bl 0x821ae6a8
	ctx.lr = 0x822ADE58;
	sub_821AE6A8(ctx, base);
	// 822ADE58: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 822ADE5C: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 822ADE60: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822ADE64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822ADE68: 409A000C  bne cr6, 0x822ade74
	if !ctx.cr[6].eq {
	pc = 0x822ADE74; continue 'dispatch;
	}
	// 822ADE6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822ADE70: 48000028  b 0x822ade98
	pc = 0x822ADE98; continue 'dispatch;
            }
            0x822ADE74 => {
    //   block [0x822ADE74..0x822ADE98)
	// 822ADE74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822ADE78: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822ADE7C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 822ADE80: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822ADE84: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822ADE88: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 822ADE8C: C02A0C18  lfs f1, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822ADE90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822ADE94: 4E800421  bctrl
	ctx.lr = 0x822ADE98;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822ADE98 => {
    //   block [0x822ADE98..0x822ADEBC)
	// 822ADE98: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822ADE9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822ADEA0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822ADEA4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822ADEA8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822ADEAC: 997B0000  stb r11, 0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 822ADEB0: 995A0000  stb r10, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 822ADEB4: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 822ADEB8: 489FB598  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ADEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822ADEC0 size=12
    let mut pc: u32 = 0x822ADEC0;
    'dispatch: loop {
        match pc {
            0x822ADEC0 => {
    //   block [0x822ADEC0..0x822ADECC)
	// 822ADEC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822ADEC4: 91630194  stw r11, 0x194(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 822ADEC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ADED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822ADED0 size=164
    let mut pc: u32 = 0x822ADED0;
    'dispatch: loop {
        match pc {
            0x822ADED0 => {
    //   block [0x822ADED0..0x822ADEF4)
	// 822ADED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822ADED4: 489FB539  bl 0x82ca940c
	ctx.lr = 0x822ADED8;
	sub_82CA93D0(ctx, base);
	// 822ADED8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822ADEDC: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ADEE0: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822ADEE4: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 822ADEE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ADEEC: 409A007C  bne cr6, 0x822adf68
	if !ctx.cr[6].eq {
	pc = 0x822ADF68; continue 'dispatch;
	}
	// 822ADEF0: 83C40000  lwz r30, 0(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822ADEF4; continue 'dispatch;
            }
            0x822ADEF4 => {
    //   block [0x822ADEF4..0x822ADF08)
	// 822ADEF4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822ADEF8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822ADEFC: 409A000C  bne cr6, 0x822adf08
	if !ctx.cr[6].eq {
	pc = 0x822ADF08; continue 'dispatch;
	}
	// 822ADF00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822ADF04: 4800003C  b 0x822adf40
	pc = 0x822ADF40; continue 'dispatch;
            }
            0x822ADF08 => {
    //   block [0x822ADF08..0x822ADF18)
	// 822ADF08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ADF0C: 409A000C  bne cr6, 0x822adf18
	if !ctx.cr[6].eq {
	pc = 0x822ADF18; continue 'dispatch;
	}
	// 822ADF10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822ADF14: 4800002C  b 0x822adf40
	pc = 0x822ADF40; continue 'dispatch;
            }
            0x822ADF18 => {
    //   block [0x822ADF18..0x822ADF28)
	// 822ADF18: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822ADF1C: 409A000C  bne cr6, 0x822adf28
	if !ctx.cr[6].eq {
	pc = 0x822ADF28; continue 'dispatch;
	}
	// 822ADF20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822ADF24: 4800001C  b 0x822adf40
	pc = 0x822ADF40; continue 'dispatch;
            }
            0x822ADF28 => {
    //   block [0x822ADF28..0x822ADF40)
	// 822ADF28: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ADF2C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822ADF30: 4BFBF8C9  bl 0x8226d7f8
	ctx.lr = 0x822ADF34;
	sub_8226D7F8(ctx, base);
	// 822ADF34: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 822ADF38: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822ADF3C: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x822ADF40; continue 'dispatch;
            }
            0x822ADF40 => {
    //   block [0x822ADF40..0x822ADF54)
	// 822ADF40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822ADF44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ADF48: 419A000C  beq cr6, 0x822adf54
	if ctx.cr[6].eq {
	pc = 0x822ADF54; continue 'dispatch;
	}
	// 822ADF4C: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822ADF50: 4800000C  b 0x822adf5c
	pc = 0x822ADF5C; continue 'dispatch;
            }
            0x822ADF54 => {
    //   block [0x822ADF54..0x822ADF5C)
	// 822ADF54: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 822ADF58: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822ADF5C; continue 'dispatch;
            }
            0x822ADF5C => {
    //   block [0x822ADF5C..0x822ADF68)
	// 822ADF5C: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 822ADF60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822ADF64: 419AFF90  beq cr6, 0x822adef4
	if ctx.cr[6].eq {
	pc = 0x822ADEF4; continue 'dispatch;
	}
	pc = 0x822ADF68; continue 'dispatch;
            }
            0x822ADF68 => {
    //   block [0x822ADF68..0x822ADF74)
	// 822ADF68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822ADF6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822ADF70: 489FB4EC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822ADF78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822ADF78 size=164
    let mut pc: u32 = 0x822ADF78;
    'dispatch: loop {
        match pc {
            0x822ADF78 => {
    //   block [0x822ADF78..0x822AE01C)
	// 822ADF78: 39610020  addi r11, r1, 0x20
	ctx.r[11].s64 = ctx.r[1].s64 + 32;
	// 822ADF7C: F8A10028  std r5, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[5].u64 ) };
	// 822ADF80: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 822ADF84: F8810020  std r4, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[4].u64 ) };
	// 822ADF88: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 822ADF8C: 3881FFF0  addi r4, r1, -0x10
	ctx.r[4].s64 = ctx.r[1].s64 + -16;
	// 822ADF90: 38C99060  addi r6, r9, -0x6fa0
	ctx.r[6].s64 = ctx.r[9].s64 + -28576;
	// 822ADF94: E9030008  ld r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 822ADF98: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AE020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AE020 size=160
    let mut pc: u32 = 0x822AE020;
    'dispatch: loop {
        match pc {
            0x822AE020 => {
    //   block [0x822AE020..0x822AE03C)
	// 822AE020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AE024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AE028: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AE02C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822AE030: 39250060  addi r9, r5, 0x60
	ctx.r[9].s64 = ctx.r[5].s64 + 96;
	// 822AE034: 81650064  lwz r11, 0x64(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(100 as u32) ) } as u64;
	// 822AE038: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	pc = 0x822AE03C; continue 'dispatch;
            }
            0x822AE03C => {
    //   block [0x822AE03C..0x822AE04C)
	// 822AE03C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE040: 7F094840  cmplw cr6, r9, r9
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822AE044: 419A0008  beq cr6, 0x822ae04c
	if ctx.cr[6].eq {
	pc = 0x822AE04C; continue 'dispatch;
	}
	// 822AE048: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822AE04C; continue 'dispatch;
            }
            0x822AE04C => {
    //   block [0x822AE04C..0x822AE064)
	// 822AE04C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822AE050: 419A0030  beq cr6, 0x822ae080
	if ctx.cr[6].eq {
	pc = 0x822AE080; continue 'dispatch;
	}
	// 822AE054: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE058: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822AE05C: 409A0008  bne cr6, 0x822ae064
	if !ctx.cr[6].eq {
	pc = 0x822AE064; continue 'dispatch;
	}
	// 822AE060: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822AE064; continue 'dispatch;
            }
            0x822AE064 => {
    //   block [0x822AE064..0x822AE080)
	// 822AE064: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AE068: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 822AE06C: 419A0020  beq cr6, 0x822ae08c
	if ctx.cr[6].eq {
	pc = 0x822AE08C; continue 'dispatch;
	}
	// 822AE070: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822AE074: 409AFFC8  bne cr6, 0x822ae03c
	if !ctx.cr[6].eq {
	pc = 0x822AE03C; continue 'dispatch;
	}
	// 822AE078: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 822AE07C: 4BFFFFC0  b 0x822ae03c
	pc = 0x822AE03C; continue 'dispatch;
            }
            0x822AE080 => {
    //   block [0x822AE080..0x822AE08C)
	// 822AE080: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822AE084: 409A0008  bne cr6, 0x822ae08c
	if !ctx.cr[6].eq {
	pc = 0x822AE08C; continue 'dispatch;
	}
	// 822AE088: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822AE08C; continue 'dispatch;
            }
            0x822AE08C => {
    //   block [0x822AE08C..0x822AE0B0)
	// 822AE08C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE090: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AE094: 9164001C  stw r11, 0x1c(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 822AE098: 8125025C  lwz r9, 0x25c(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(604 as u32) ) } as u64;
	// 822AE09C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 822AE0A0: 409A0010  bne cr6, 0x822ae0b0
	if !ctx.cr[6].eq {
	pc = 0x822AE0B0; continue 'dispatch;
	}
	// 822AE0A4: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 822AE0A8: 482B5229  bl 0x825632d0
	ctx.lr = 0x822AE0AC;
	sub_825632D0(ctx, base);
	// 822AE0AC: 9065025C  stw r3, 0x25c(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(604 as u32), ctx.r[3].u32 ) };
	pc = 0x822AE0B0; continue 'dispatch;
            }
            0x822AE0B0 => {
    //   block [0x822AE0B0..0x822AE0C0)
	// 822AE0B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AE0B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AE0B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AE0BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AE0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AE0C0 size=336
    let mut pc: u32 = 0x822AE0C0;
    'dispatch: loop {
        match pc {
            0x822AE0C0 => {
    //   block [0x822AE0C0..0x822AE11C)
	// 822AE0C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AE0C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AE0C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AE0CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AE0D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AE0D4: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 822AE0D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE0DC: 419A0120  beq cr6, 0x822ae1fc
	if ctx.cr[6].eq {
	pc = 0x822AE1FC; continue 'dispatch;
	}
	// 822AE0E0: 4BFBE621  bl 0x8226c700
	ctx.lr = 0x822AE0E4;
	sub_8226C700(ctx, base);
	// 822AE0E4: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 822AE0E8: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 822AE0EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AE0F0: 419A00E8  beq cr6, 0x822ae1d8
	if ctx.cr[6].eq {
	pc = 0x822AE1D8; continue 'dispatch;
	}
	// 822AE0F4: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AE0F8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AE0FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE100: 419A001C  beq cr6, 0x822ae11c
	if ctx.cr[6].eq {
	pc = 0x822AE11C; continue 'dispatch;
	}
	// 822AE104: 896B0013  lbz r11, 0x13(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 822AE108: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 822AE10C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822AE110: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE114: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822AE118: 480000C8  b 0x822ae1e0
	pc = 0x822AE1E0; continue 'dispatch;
            }
            0x822AE11C => {
    //   block [0x822AE11C..0x822AE138)
	// 822AE11C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AE120: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822AE124: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822AE128: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822AE12C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822AE130: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AE134: 40810054  ble 0x822ae188
	if !ctx.cr[0].gt {
	pc = 0x822AE188; continue 'dispatch;
	}
	pc = 0x822AE138; continue 'dispatch;
            }
            0x822AE138 => {
    //   block [0x822AE138..0x822AE158)
	// 822AE138: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AE13C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AE140: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822AE144: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE148: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 822AE14C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AE150: 41980008  blt cr6, 0x822ae158
	if ctx.cr[6].lt {
	pc = 0x822AE158; continue 'dispatch;
	}
	// 822AE154: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822AE158; continue 'dispatch;
            }
            0x822AE158 => {
    //   block [0x822AE158..0x822AE174)
	// 822AE158: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AE15C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AE160: 419A0014  beq cr6, 0x822ae174
	if ctx.cr[6].eq {
	pc = 0x822AE174; continue 'dispatch;
	}
	// 822AE164: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AE168: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AE16C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AE170: 4800000C  b 0x822ae17c
	pc = 0x822AE17C; continue 'dispatch;
            }
            0x822AE174 => {
    //   block [0x822AE174..0x822AE17C)
	// 822AE174: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AE178: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822AE17C; continue 'dispatch;
            }
            0x822AE17C => {
    //   block [0x822AE17C..0x822AE188)
	// 822AE17C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AE180: 4199FFB8  bgt cr6, 0x822ae138
	if ctx.cr[6].gt {
	pc = 0x822AE138; continue 'dispatch;
	}
	// 822AE184: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822AE188; continue 'dispatch;
            }
            0x822AE188 => {
    //   block [0x822AE188..0x822AE1A4)
	// 822AE188: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AE18C: 419A003C  beq cr6, 0x822ae1c8
	if ctx.cr[6].eq {
	pc = 0x822AE1C8; continue 'dispatch;
	}
	// 822AE190: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE194: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 822AE198: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE19C: 41990008  bgt cr6, 0x822ae1a4
	if ctx.cr[6].gt {
	pc = 0x822AE1A4; continue 'dispatch;
	}
	// 822AE1A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822AE1A4; continue 'dispatch;
            }
            0x822AE1A4 => {
    //   block [0x822AE1A4..0x822AE1C8)
	// 822AE1A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AE1A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE1AC: 409A001C  bne cr6, 0x822ae1c8
	if !ctx.cr[6].eq {
	pc = 0x822AE1C8; continue 'dispatch;
	}
	// 822AE1B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AE1B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822AE1B8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822AE1BC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822AE1C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE1C4: 4800001C  b 0x822ae1e0
	pc = 0x822AE1E0; continue 'dispatch;
            }
            0x822AE1C8 => {
    //   block [0x822AE1C8..0x822AE1D8)
	// 822AE1C8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822AE1CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822AE1D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE1D4: 4800000C  b 0x822ae1e0
	pc = 0x822AE1E0; continue 'dispatch;
            }
            0x822AE1D8 => {
    //   block [0x822AE1D8..0x822AE1E0)
	// 822AE1D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822AE1DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x822AE1E0; continue 'dispatch;
            }
            0x822AE1E0 => {
    //   block [0x822AE1E0..0x822AE1FC)
	// 822AE1E0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822AE1E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AE1E8: 419A0014  beq cr6, 0x822ae1fc
	if ctx.cr[6].eq {
	pc = 0x822AE1FC; continue 'dispatch;
	}
	// 822AE1EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822AE1F0: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 822AE1F4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822AE1F8: 4BFFFE29  bl 0x822ae020
	ctx.lr = 0x822AE1FC;
	sub_822AE020(ctx, base);
	pc = 0x822AE1FC; continue 'dispatch;
            }
            0x822AE1FC => {
    //   block [0x822AE1FC..0x822AE210)
	// 822AE1FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AE200: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AE204: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AE208: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AE20C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AE210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822AE210 size=2008
    let mut pc: u32 = 0x822AE210;
    'dispatch: loop {
        match pc {
            0x822AE210 => {
    //   block [0x822AE210..0x822AE260)
	// 822AE210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AE214: 489FB1E1  bl 0x82ca93f4
	ctx.lr = 0x822AE218;
	sub_82CA93D0(ctx, base);
	// 822AE218: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AE21C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822AE220: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 822AE224: 3B7A012C  addi r27, r26, 0x12c
	ctx.r[27].s64 = ctx.r[26].s64 + 300;
	// 822AE228: 817A0130  lwz r11, 0x130(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(304 as u32) ) } as u64;
	// 822AE22C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE230: 419A0030  beq cr6, 0x822ae260
	if ctx.cr[6].eq {
	pc = 0x822AE260; continue 'dispatch;
	}
	// 822AE234: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE238: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AE23C: 419A0198  beq cr6, 0x822ae3d4
	if ctx.cr[6].eq {
	pc = 0x822AE3D4; continue 'dispatch;
	}
	// 822AE240: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822AE244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE248: 419A0018  beq cr6, 0x822ae260
	if ctx.cr[6].eq {
	pc = 0x822AE260; continue 'dispatch;
	}
	// 822AE24C: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 822AE250: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822AE254: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE258: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AE25C: 409A0008  bne cr6, 0x822ae264
	if !ctx.cr[6].eq {
	pc = 0x822AE264; continue 'dispatch;
	}
	pc = 0x822AE260; continue 'dispatch;
            }
            0x822AE260 => {
    //   block [0x822AE260..0x822AE264)
	// 822AE260: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x822AE264; continue 'dispatch;
            }
            0x822AE264 => {
    //   block [0x822AE264..0x822AE2AC)
	// 822AE264: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AE268: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 822AE26C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE270: 409A0054  bne cr6, 0x822ae2c4
	if !ctx.cr[6].eq {
	pc = 0x822AE2C4; continue 'dispatch;
	}
	// 822AE274: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822AE278: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AE27C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822AE280: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE284: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE288: 4BF7DF31  bl 0x8222c1b8
	ctx.lr = 0x822AE28C;
	sub_8222C1B8(ctx, base);
	// 822AE28C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822AE290: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822AE294: 419A0018  beq cr6, 0x822ae2ac
	if ctx.cr[6].eq {
	pc = 0x822AE2AC; continue 'dispatch;
	}
	// 822AE298: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 822AE29C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822AE2A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE2A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AE2A8: 409A0008  bne cr6, 0x822ae2b0
	if !ctx.cr[6].eq {
	pc = 0x822AE2B0; continue 'dispatch;
	}
	pc = 0x822AE2AC; continue 'dispatch;
            }
            0x822AE2AC => {
    //   block [0x822AE2AC..0x822AE2B0)
	// 822AE2AC: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x822AE2B0; continue 'dispatch;
            }
            0x822AE2B0 => {
    //   block [0x822AE2B0..0x822AE2C4)
	// 822AE2B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AE2B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE2B8: 419A000C  beq cr6, 0x822ae2c4
	if ctx.cr[6].eq {
	pc = 0x822AE2C4; continue 'dispatch;
	}
	// 822AE2BC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE2C0: 48566B19  bl 0x82814dd8
	ctx.lr = 0x822AE2C4;
	sub_82814DD8(ctx, base);
	pc = 0x822AE2C4; continue 'dispatch;
            }
            0x822AE2C4 => {
    //   block [0x822AE2C4..0x822AE334)
	// 822AE2C4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE2C8: 480007F9  bl 0x822aeac0
	ctx.lr = 0x822AE2CC;
	sub_822AEAC0(ctx, base);
	// 822AE2CC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE2D0: 4801FFA9  bl 0x822ce278
	ctx.lr = 0x822AE2D4;
	sub_822CE278(ctx, base);
	// 822AE2D4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE2D8: 4BFCDA69  bl 0x8227bd40
	ctx.lr = 0x822AE2DC;
	sub_8227BD40(ctx, base);
	// 822AE2DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE2E0: 4BFF1651  bl 0x8229f930
	ctx.lr = 0x822AE2E4;
	sub_8229F930(ctx, base);
	// 822AE2E4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE2E8: 4BECA009  bl 0x821782f0
	ctx.lr = 0x822AE2EC;
	sub_821782F0(ctx, base);
	// 822AE2EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE2F0: 4BED8011  bl 0x82186300
	ctx.lr = 0x822AE2F4;
	sub_82186300(ctx, base);
	// 822AE2F4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE2F8: 48001301  bl 0x822af5f8
	ctx.lr = 0x822AE2FC;
	sub_822AF5F8(ctx, base);
	// 822AE2FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE300: 48012811  bl 0x822c0b10
	ctx.lr = 0x822AE304;
	sub_822C0B10(ctx, base);
	// 822AE304: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE308: 480038C1  bl 0x822b1bc8
	ctx.lr = 0x822AE30C;
	sub_822B1BC8(ctx, base);
	// 822AE30C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE310: 4BED8AC1  bl 0x82186dd0
	ctx.lr = 0x822AE314;
	sub_82186DD0(ctx, base);
	// 822AE314: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE318: 4BED76D9  bl 0x821859f0
	ctx.lr = 0x822AE31C;
	sub_821859F0(ctx, base);
	// 822AE31C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE320: 48000E21  bl 0x822af140
	ctx.lr = 0x822AE324;
	sub_822AF140(ctx, base);
	// 822AE324: 3B9A0308  addi r28, r26, 0x308
	ctx.r[28].s64 = ctx.r[26].s64 + 776;
	// 822AE328: 3BE0000A  li r31, 0xa
	ctx.r[31].s64 = 10;
	// 822AE32C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 822AE330: 83BA0004  lwz r29, 4(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x822AE334; continue 'dispatch;
            }
            0x822AE334 => {
    //   block [0x822AE334..0x822AE370)
	// 822AE334: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822AE338: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AE33C: 480006AD  bl 0x822ae9e8
	ctx.lr = 0x822AE340;
	sub_822AE9E8(ctx, base);
	// 822AE340: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822AE344: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 822AE348: 4082FFEC  bne 0x822ae334
	if !ctx.cr[0].eq {
	pc = 0x822AE334; continue 'dispatch;
	}
	// 822AE34C: 817A00E8  lwz r11, 0xe8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(232 as u32) ) } as u64;
	// 822AE350: 3FA08332  lis r29, -0x7cce
	ctx.r[29].s64 = -2093875200;
	// 822AE354: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AE358: 40990018  ble cr6, 0x822ae370
	if !ctx.cr[6].gt {
	pc = 0x822AE370; continue 'dispatch;
	}
	// 822AE35C: 815D9650  lwz r10, -0x69b0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822AE360: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822AE364: 4099000C  ble cr6, 0x822ae370
	if !ctx.cr[6].gt {
	pc = 0x822AE370; continue 'dispatch;
	}
	// 822AE368: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE36C: 48566DCD  bl 0x82815138
	ctx.lr = 0x822AE370;
	sub_82815138(ctx, base);
	pc = 0x822AE370; continue 'dispatch;
            }
            0x822AE370 => {
    //   block [0x822AE370..0x822AE3D4)
	// 822AE370: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822AE374: 3F208332  lis r25, -0x7cce
	ctx.r[25].s64 = -2093875200;
	// 822AE378: 3BCBF1C8  addi r30, r11, -0xe38
	ctx.r[30].s64 = ctx.r[11].s64 + -3640;
	// 822AE37C: 817A00D8  lwz r11, 0xd8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(216 as u32) ) } as u64;
	// 822AE380: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AE384: 41980084  blt cr6, 0x822ae408
	if ctx.cr[6].lt {
	pc = 0x822AE408; continue 'dispatch;
	}
	// 822AE388: 815D9650  lwz r10, -0x69b0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822AE38C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822AE390: 41980078  blt cr6, 0x822ae408
	if ctx.cr[6].lt {
	pc = 0x822AE408; continue 'dispatch;
	}
	// 822AE394: 3BFA0590  addi r31, r26, 0x590
	ctx.r[31].s64 = ctx.r[26].s64 + 1424;
	// 822AE398: C03ECC3C  lfs f1, -0x33c4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-13252 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x822AE3D4; continue 'dispatch;
            }
            0x822AE3D4 => {
    //   block [0x822AE3D4..0x822AE408)
	// 822AE3D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822AE3D8: 4BEE5A61  bl 0x82193e38
	ctx.lr = 0x822AE3DC;
	sub_82193E38(ctx, base);
	// 822AE3DC: 4BFFFE84  b 0x822ae260
	pc = 0x822AE260; continue 'dispatch;
	// 822AE3E0: 817D9650  lwz r11, -0x69b0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822AE3E4: C8199660  lfd f0, -0x69a0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[25].u32.wrapping_add(-27040 as u32) ) };
	// 822AE3E8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 822AE3EC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822AE3F0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AE3F4: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 822AE3F8: FD6C002A  fadd f11, f12, f0
	ctx.f[11].f64 = ctx.f[12].f64 + ctx.f[0].f64;
	// 822AE3FC: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 822AE400: 398000D8  li r12, 0xd8
	ctx.r[12].s64 = 216;
	// 822AE404: 7D5A67AE  stfiwx f10, r26, r12
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[12].u32), tmp.u32) };
            }
            0x822AE408 => {
    //   block [0x822AE408..0x822AE9E8)
	// 822AE408: 817A00E4  lwz r11, 0xe4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(228 as u32) ) } as u64;
	// 822AE40C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AE410: 40990018  ble cr6, 0x822ae428
	if !ctx.cr[6].gt {
	pc = 0x822AE428; continue 'dispatch;
	}
	// 822AE414: 815D9650  lwz r10, -0x69b0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822AE418: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822AE41C: 4099000C  ble cr6, 0x822ae428
	if !ctx.cr[6].gt {
	pc = 0x822AE428; continue 'dispatch;
	}
	// 822AE420: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE424: 485656A5  bl 0x82813ac8
	ctx.lr = 0x822AE428;
	sub_82813AC8(ctx, base);
	// 822AE428: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE42C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE430: 419A0088  beq cr6, 0x822ae4b8
	if ctx.cr[6].eq {
	pc = 0x822AE4B8; continue 'dispatch;
	}
	// 822AE434: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE438: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AE43C: 419A0074  beq cr6, 0x822ae4b0
	if ctx.cr[6].eq {
	pc = 0x822AE4B0; continue 'dispatch;
	}
	// 822AE440: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822AE444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE448: 419A0018  beq cr6, 0x822ae460
	if ctx.cr[6].eq {
	pc = 0x822AE460; continue 'dispatch;
	}
	// 822AE44C: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 822AE450: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822AE454: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822AE458: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822AE45C: 409A0008  bne cr6, 0x822ae464
	if !ctx.cr[6].eq {
	pc = 0x822AE464; continue 'dispatch;
	}
	// 822AE460: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 822AE464: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822AE468: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AE46C: 419A01A4  beq cr6, 0x822ae610
	if ctx.cr[6].eq {
	pc = 0x822AE610; continue 'dispatch;
	}
	// 822AE470: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822AE474: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 822AE478: 552837FE  rlwinm r8, r9, 6, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x03FFFFFFu64;
	// 822AE47C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822AE480: 419A0104  beq cr6, 0x822ae584
	if ctx.cr[6].eq {
	pc = 0x822AE584; continue 'dispatch;
	}
	// 822AE484: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AE488: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AE48C: 419A0034  beq cr6, 0x822ae4c0
	if ctx.cr[6].eq {
	pc = 0x822AE4C0; continue 'dispatch;
	}
	// 822AE490: 894A007A  lbz r10, 0x7a(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(122 as u32) ) } as u64;
	// 822AE494: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AE498: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822AE49C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822AE4A0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE4A4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822AE4A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE4AC: 480000DC  b 0x822ae588
	pc = 0x822AE588; continue 'dispatch;
	// 822AE4B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822AE4B4: 4BEE5985  bl 0x82193e38
	ctx.lr = 0x822AE4B8;
	sub_82193E38(ctx, base);
	// 822AE4B8: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822AE4BC: 4BFFFFA4  b 0x822ae460
	pc = 0x822AE460; continue 'dispatch;
	// 822AE4C0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AE4C4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AE4C8: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 822AE4CC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822AE4D0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822AE4D4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AE4D8: 40810054  ble 0x822ae52c
	if !ctx.cr[0].gt {
	pc = 0x822AE52C; continue 'dispatch;
	}
	// 822AE4DC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AE4E0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AE4E4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822AE4E8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE4EC: 2F07007A  cmpwi cr6, r7, 0x7a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 122, &mut ctx.xer);
	// 822AE4F0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AE4F4: 41980008  blt cr6, 0x822ae4fc
	if ctx.cr[6].lt {
	pc = 0x822AE4FC; continue 'dispatch;
	}
	// 822AE4F8: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 822AE4FC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AE500: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AE504: 419A0014  beq cr6, 0x822ae518
	if ctx.cr[6].eq {
	pc = 0x822AE518; continue 'dispatch;
	}
	// 822AE508: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AE50C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AE510: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AE514: 4800000C  b 0x822ae520
	pc = 0x822AE520; continue 'dispatch;
	// 822AE518: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AE51C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 822AE520: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AE524: 4199FFB8  bgt cr6, 0x822ae4dc
	if ctx.cr[6].gt {
	pc = 0x822AE4DC; continue 'dispatch;
	}
	// 822AE528: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822AE52C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AE530: 419A0040  beq cr6, 0x822ae570
	if ctx.cr[6].eq {
	pc = 0x822AE570; continue 'dispatch;
	}
	// 822AE534: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE538: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 822AE53C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE540: 41990008  bgt cr6, 0x822ae548
	if ctx.cr[6].gt {
	pc = 0x822AE548; continue 'dispatch;
	}
	// 822AE544: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822AE548: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AE54C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE550: 409A0020  bne cr6, 0x822ae570
	if !ctx.cr[6].eq {
	pc = 0x822AE570; continue 'dispatch;
	}
	// 822AE554: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AE558: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822AE55C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822AE560: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE564: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822AE568: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE56C: 4800001C  b 0x822ae588
	pc = 0x822AE588; continue 'dispatch;
	// 822AE570: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822AE574: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE578: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822AE57C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE580: 48000008  b 0x822ae588
	pc = 0x822AE588; continue 'dispatch;
	// 822AE584: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822AE588: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AE58C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE590: 419A0080  beq cr6, 0x822ae610
	if ctx.cr[6].eq {
	pc = 0x822AE610; continue 'dispatch;
	}
	// 822AE594: C00A000C  lfs f0, 0xc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AE598: C1BEA2C8  lfs f13, -0x5d38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-23864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822AE59C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822AE5A0: 41980010  blt cr6, 0x822ae5b0
	if ctx.cr[6].lt {
	pc = 0x822AE5B0; continue 'dispatch;
	}
	// 822AE5A4: C1BEEF14  lfs f13, -0x10ec(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4332 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822AE5A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822AE5AC: 41980064  blt cr6, 0x822ae610
	if ctx.cr[6].lt {
	pc = 0x822AE610; continue 'dispatch;
	}
	// 822AE5B0: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 822AE5B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE5B8: 419A0020  beq cr6, 0x822ae5d8
	if ctx.cr[6].eq {
	pc = 0x822AE5D8; continue 'dispatch;
	}
	// 822AE5BC: C01EA2BC  lfs f0, -0x5d44(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-23876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AE5C0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 822AE5C4: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822AE5C8: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822AE5CC: ED6D603A  fmadds f11, f13, f0, f12
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 822AE5D0: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 822AE5D4: 41990008  bgt cr6, 0x822ae5dc
	if ctx.cr[6].gt {
	pc = 0x822AE5DC; continue 'dispatch;
	}
	// 822AE5D8: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 822AE5DC: 897A000C  lbz r11, 0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AE5E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE5E4: 419A0028  beq cr6, 0x822ae60c
	if ctx.cr[6].eq {
	pc = 0x822AE60C; continue 'dispatch;
	}
	// 822AE5E8: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 822AE5EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE5F0: 409A001C  bne cr6, 0x822ae60c
	if !ctx.cr[6].eq {
	pc = 0x822AE60C; continue 'dispatch;
	}
	// 822AE5F4: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822AE5F8: 38800017  li r4, 0x17
	ctx.r[4].s64 = 23;
	// 822AE5FC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AE600: 814B00A8  lwz r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 822AE604: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE608: 4BF06C59  bl 0x821b5260
	ctx.lr = 0x822AE60C;
	sub_821B5260(ctx, base);
	// 822AE60C: 9BFA000C  stb r31, 0xc(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[31].u8 ) };
	// 822AE610: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE614: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 822AE618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE61C: 419A0020  beq cr6, 0x822ae63c
	if ctx.cr[6].eq {
	pc = 0x822AE63C; continue 'dispatch;
	}
	// 822AE620: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE624: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AE628: 419A000C  beq cr6, 0x822ae634
	if ctx.cr[6].eq {
	pc = 0x822AE634; continue 'dispatch;
	}
	// 822AE62C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822AE630: 48000010  b 0x822ae640
	pc = 0x822AE640; continue 'dispatch;
	// 822AE634: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822AE638: 4BEE5801  bl 0x82193e38
	ctx.lr = 0x822AE63C;
	sub_82193E38(ctx, base);
	// 822AE63C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822AE640: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 822AE644: 5549C7FE  rlwinm r9, r10, 0x18, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822AE648: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822AE64C: 419A00F4  beq cr6, 0x822ae740
	if ctx.cr[6].eq {
	pc = 0x822AE740; continue 'dispatch;
	}
	// 822AE650: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AE654: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AE658: 419A0024  beq cr6, 0x822ae67c
	if ctx.cr[6].eq {
	pc = 0x822AE67C; continue 'dispatch;
	}
	// 822AE65C: 894A0088  lbz r10, 0x88(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(136 as u32) ) } as u64;
	// 822AE660: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AE664: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822AE668: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822AE66C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE670: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AE674: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE678: 480000CC  b 0x822ae744
	pc = 0x822AE744; continue 'dispatch;
	// 822AE67C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AE680: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AE684: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 822AE688: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822AE68C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822AE690: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AE694: 40810054  ble 0x822ae6e8
	if !ctx.cr[0].gt {
	pc = 0x822AE6E8; continue 'dispatch;
	}
	// 822AE698: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AE69C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AE6A0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822AE6A4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE6A8: 2F070088  cmpwi cr6, r7, 0x88
	ctx.cr[6].compare_i32(ctx.r[7].s32, 136, &mut ctx.xer);
	// 822AE6AC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AE6B0: 41980008  blt cr6, 0x822ae6b8
	if ctx.cr[6].lt {
	pc = 0x822AE6B8; continue 'dispatch;
	}
	// 822AE6B4: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 822AE6B8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AE6BC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AE6C0: 419A0014  beq cr6, 0x822ae6d4
	if ctx.cr[6].eq {
	pc = 0x822AE6D4; continue 'dispatch;
	}
	// 822AE6C4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AE6C8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AE6CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AE6D0: 4800000C  b 0x822ae6dc
	pc = 0x822AE6DC; continue 'dispatch;
	// 822AE6D4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AE6D8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 822AE6DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AE6E0: 4199FFB8  bgt cr6, 0x822ae698
	if ctx.cr[6].gt {
	pc = 0x822AE698; continue 'dispatch;
	}
	// 822AE6E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822AE6E8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AE6EC: 419A0040  beq cr6, 0x822ae72c
	if ctx.cr[6].eq {
	pc = 0x822AE72C; continue 'dispatch;
	}
	// 822AE6F0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE6F4: 2F0B0088  cmpwi cr6, r11, 0x88
	ctx.cr[6].compare_i32(ctx.r[11].s32, 136, &mut ctx.xer);
	// 822AE6F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE6FC: 41990008  bgt cr6, 0x822ae704
	if ctx.cr[6].gt {
	pc = 0x822AE704; continue 'dispatch;
	}
	// 822AE700: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822AE704: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AE708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE70C: 409A0020  bne cr6, 0x822ae72c
	if !ctx.cr[6].eq {
	pc = 0x822AE72C; continue 'dispatch;
	}
	// 822AE710: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AE714: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822AE718: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822AE71C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE720: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AE724: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE728: 4800001C  b 0x822ae744
	pc = 0x822AE744; continue 'dispatch;
	// 822AE72C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822AE730: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE734: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AE738: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE73C: 48000008  b 0x822ae744
	pc = 0x822AE744; continue 'dispatch;
	// 822AE740: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822AE744: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AE748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE74C: 419A00D4  beq cr6, 0x822ae820
	if ctx.cr[6].eq {
	pc = 0x822AE820; continue 'dispatch;
	}
	// 822AE750: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 822AE754: 389F0040  addi r4, r31, 0x40
	ctx.r[4].s64 = ctx.r[31].s64 + 64;
	// 822AE758: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE75C: 41990014  bgt cr6, 0x822ae770
	if ctx.cr[6].gt {
	pc = 0x822AE770; continue 'dispatch;
	}
	// 822AE760: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE768: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822AE76C: 40990008  ble cr6, 0x822ae774
	if !ctx.cr[6].gt {
	pc = 0x822AE774; continue 'dispatch;
	}
	// 822AE770: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE774: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AE778: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE77C: 419A00A4  beq cr6, 0x822ae820
	if ctx.cr[6].eq {
	pc = 0x822AE820; continue 'dispatch;
	}
	// 822AE780: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822AE784: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AE788: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 822AE78C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE790: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE794: 4BFB5CF5  bl 0x82264488
	ctx.lr = 0x822AE798;
	sub_82264488(ctx, base);
	// 822AE798: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822AE79C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822AE7A0: 419A0080  beq cr6, 0x822ae820
	if ctx.cr[6].eq {
	pc = 0x822AE820; continue 'dispatch;
	}
	// 822AE7A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822AE7A8: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 822AE7AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AE7B0: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 822AE7B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822AE7B8: 4BF660E1  bl 0x82214898
	ctx.lr = 0x822AE7BC;
	sub_82214898(ctx, base);
	// 822AE7BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822AE7C0: 387A0144  addi r3, r26, 0x144
	ctx.r[3].s64 = ctx.r[26].s64 + 324;
	// 822AE7C4: 48223705  bl 0x824d1ec8
	ctx.lr = 0x822AE7C8;
	sub_824D1EC8(ctx, base);
	// 822AE7C8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 822AE7CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AE7D0: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 822AE7D4: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 822AE7D8: 4BEE5661  bl 0x82193e38
	ctx.lr = 0x822AE7DC;
	sub_82193E38(ctx, base);
	// 822AE7DC: 817D9650  lwz r11, -0x69b0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822AE7E0: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 822AE7E4: C8199660  lfd f0, -0x69a0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[25].u32.wrapping_add(-27040 as u32) ) };
	// 822AE7E8: 7D6607B4  extsw r6, r11
	ctx.r[6].s64 = ctx.r[11].s32 as i64;
	// 822AE7EC: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822AE7F0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 822AE7F4: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 822AE7F8: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AE7FC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 822AE800: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822AE804: C9A71228  lfd f13, 0x1228(r7)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(4648 as u32) ) };
	// 822AE808: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822AE80C: FD60637A  fmadd f11, f0, f13, f12
	ctx.f[11].f64 = ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64;
	// 822AE810: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 822AE814: 398000E8  li r12, 0xe8
	ctx.r[12].s64 = 232;
	// 822AE818: 7D5A67AE  stfiwx f10, r26, r12
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[12].u32), tmp.u32) };
	// 822AE81C: 48565235  bl 0x82813a50
	ctx.lr = 0x822AE820;
	sub_82813A50(ctx, base);
	// 822AE820: 817A0114  lwz r11, 0x114(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(276 as u32) ) } as u64;
	// 822AE824: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822AE828: 419A000C  beq cr6, 0x822ae834
	if ctx.cr[6].eq {
	pc = 0x822AE834; continue 'dispatch;
	}
	// 822AE82C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 822AE830: 409A0050  bne cr6, 0x822ae880
	if !ctx.cr[6].eq {
	pc = 0x822AE880; continue 'dispatch;
	}
	// 822AE834: 817A00D4  lwz r11, 0xd4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(212 as u32) ) } as u64;
	// 822AE838: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AE83C: 40980044  bge cr6, 0x822ae880
	if !ctx.cr[6].lt {
	pc = 0x822AE880; continue 'dispatch;
	}
	// 822AE840: 817A0158  lwz r11, 0x158(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(344 as u32) ) } as u64;
	// 822AE844: 387A0154  addi r3, r26, 0x154
	ctx.r[3].s64 = ctx.r[26].s64 + 340;
	// 822AE848: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE84C: 419A0034  beq cr6, 0x822ae880
	if ctx.cr[6].eq {
	pc = 0x822AE880; continue 'dispatch;
	}
	// 822AE850: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE854: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AE858: 419A0068  beq cr6, 0x822ae8c0
	if ctx.cr[6].eq {
	pc = 0x822AE8C0; continue 'dispatch;
	}
	// 822AE85C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822AE860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE864: 419A001C  beq cr6, 0x822ae880
	if ctx.cr[6].eq {
	pc = 0x822AE880; continue 'dispatch;
	}
	// 822AE868: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822AE86C: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 822AE870: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AE874: 812A00A8  lwz r9, 0xa8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(168 as u32) ) } as u64;
	// 822AE878: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE87C: 4BF069E5  bl 0x821b5260
	ctx.lr = 0x822AE880;
	sub_821B5260(ctx, base);
	// 822AE880: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE884: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822AE888: 55494FFE  rlwinm r9, r10, 9, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x007FFFFFu64;
	// 822AE88C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822AE890: 419A00FC  beq cr6, 0x822ae98c
	if ctx.cr[6].eq {
	pc = 0x822AE98C; continue 'dispatch;
	}
	// 822AE894: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AE898: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AE89C: 419A002C  beq cr6, 0x822ae8c8
	if ctx.cr[6].eq {
	pc = 0x822AE8C8; continue 'dispatch;
	}
	// 822AE8A0: 892A0017  lbz r9, 0x17(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(23 as u32) ) } as u64;
	// 822AE8A4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AE8A8: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 822AE8AC: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822AE8B0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE8B4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AE8B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE8BC: 480000D8  b 0x822ae994
	pc = 0x822AE994; continue 'dispatch;
	// 822AE8C0: 4BEE5579  bl 0x82193e38
	ctx.lr = 0x822AE8C4;
	sub_82193E38(ctx, base);
	// 822AE8C4: 4BFFFFBC  b 0x822ae880
	pc = 0x822AE880; continue 'dispatch;
	// 822AE8C8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AE8CC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AE8D0: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 822AE8D4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822AE8D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822AE8DC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AE8E0: 40810054  ble 0x822ae934
	if !ctx.cr[0].gt {
	pc = 0x822AE934; continue 'dispatch;
	}
	// 822AE8E4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AE8E8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AE8EC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822AE8F0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE8F4: 2F070017  cmpwi cr6, r7, 0x17
	ctx.cr[6].compare_i32(ctx.r[7].s32, 23, &mut ctx.xer);
	// 822AE8F8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AE8FC: 41980008  blt cr6, 0x822ae904
	if ctx.cr[6].lt {
	pc = 0x822AE904; continue 'dispatch;
	}
	// 822AE900: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 822AE904: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AE908: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AE90C: 419A0014  beq cr6, 0x822ae920
	if ctx.cr[6].eq {
	pc = 0x822AE920; continue 'dispatch;
	}
	// 822AE910: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AE914: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AE918: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AE91C: 4800000C  b 0x822ae928
	pc = 0x822AE928; continue 'dispatch;
	// 822AE920: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AE924: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 822AE928: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AE92C: 4199FFB8  bgt cr6, 0x822ae8e4
	if ctx.cr[6].gt {
	pc = 0x822AE8E4; continue 'dispatch;
	}
	// 822AE930: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822AE934: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AE938: 419A0040  beq cr6, 0x822ae978
	if ctx.cr[6].eq {
	pc = 0x822AE978; continue 'dispatch;
	}
	// 822AE93C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AE940: 2F0B0017  cmpwi cr6, r11, 0x17
	ctx.cr[6].compare_i32(ctx.r[11].s32, 23, &mut ctx.xer);
	// 822AE944: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE948: 41990008  bgt cr6, 0x822ae950
	if ctx.cr[6].gt {
	pc = 0x822AE950; continue 'dispatch;
	}
	// 822AE94C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822AE950: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AE954: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AE958: 409A0020  bne cr6, 0x822ae978
	if !ctx.cr[6].eq {
	pc = 0x822AE978; continue 'dispatch;
	}
	// 822AE95C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AE960: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822AE964: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822AE968: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE96C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AE970: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE974: 48000020  b 0x822ae994
	pc = 0x822AE994; continue 'dispatch;
	// 822AE978: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822AE97C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AE980: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AE984: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AE988: 4800000C  b 0x822ae994
	pc = 0x822AE994; continue 'dispatch;
	// 822AE98C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822AE990: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 822AE994: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AE998: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822AE99C: 409A0044  bne cr6, 0x822ae9e0
	if !ctx.cr[6].eq {
	pc = 0x822AE9E0; continue 'dispatch;
	}
	// 822AE9A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AE9A4: 4817A265  bl 0x82428c08
	ctx.lr = 0x822AE9A8;
	sub_82428C08(ctx, base);
	// 822AE9A8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822AE9AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822AE9B0: 409A0018  bne cr6, 0x822ae9c8
	if !ctx.cr[6].eq {
	pc = 0x822AE9C8; continue 'dispatch;
	}
	// 822AE9B4: 997A002E  stb r11, 0x2e(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(46 as u32), ctx.r[11].u8 ) };
	// 822AE9B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AE9BC: 4800BF1D  bl 0x822ba8d8
	ctx.lr = 0x822AE9C0;
	sub_822BA8D8(ctx, base);
	// 822AE9C0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822AE9C4: 489FAA80  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
	// 822AE9C8: 897A002E  lbz r11, 0x2e(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(46 as u32) ) } as u64;
	// 822AE9CC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822AE9D0: 409A0010  bne cr6, 0x822ae9e0
	if !ctx.cr[6].eq {
	pc = 0x822AE9E0; continue 'dispatch;
	}
	// 822AE9D4: 9AFA002E  stb r23, 0x2e(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(46 as u32), ctx.r[23].u8 ) };
	// 822AE9D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AE9DC: 48025FA5  bl 0x822d4980
	ctx.lr = 0x822AE9E0;
	sub_822D4980(ctx, base);
	// 822AE9E0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822AE9E4: 489FAA60  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AE9E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822AE9E8 size=216
    let mut pc: u32 = 0x822AE9E8;
    'dispatch: loop {
        match pc {
            0x822AE9E8 => {
    //   block [0x822AE9E8..0x822AEA8C)
	// 822AE9E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AE9EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AE9F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822AE9F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AE9F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AE9FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AEA00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822AEA04: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AEA08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AEA0C: 419A009C  beq cr6, 0x822aeaa8
	if ctx.cr[6].eq {
	pc = 0x822AEAA8; continue 'dispatch;
	}
	// 822AEA10: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822AEA14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AEA18: 419A0090  beq cr6, 0x822aeaa8
	if ctx.cr[6].eq {
	pc = 0x822AEAA8; continue 'dispatch;
	}
	// 822AEA1C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822AEA20: C19F0000  lfs f12, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822AEA24: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 822AEA28: 392B9484  addi r9, r11, -0x6b7c
	ctx.r[9].s64 = ctx.r[11].s64 + -27516;
	// 822AEA2C: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AEA30: C9AA9660  lfd f13, -0x69a0(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 822AEA34: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 822AEA38: 81096C9C  lwz r8, 0x6c9c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27804 as u32) ) } as u64;
	// 822AEA3C: 80E96CA0  lwz r7, 0x6ca0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27808 as u32) ) } as u64;
	// 822AEA40: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 822AEA44: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 822AEA48: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AEA4C: FD606824  fdiv f11, f0, f13
	ctx.f[11].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 822AEA50: FCE05818  frsp f7, f11
	ctx.f[7].f64 = (ctx.f[11].f64 as f32) as f64;
	// 822AEA54: 41980038  blt cr6, 0x822aea8c
	if ctx.cr[6].lt {
	pc = 0x822AEA8C; continue 'dispatch;
	}
	// 822AEA58: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AEA5C: C0C30020  lfs f6, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 822AEA60: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822AEA64: 48024BE5  bl 0x822d3648
	ctx.lr = 0x822AEA68;
	sub_822D3648(ctx, base);
	// 822AEA68: C0BF0000  lfs f5, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 822AEA6C: EC86382A  fadds f4, f6, f7
	ctx.f[4].f64 = ((ctx.f[6].f64 + ctx.f[7].f64) as f32) as f64;
	// 822AEA70: EC650072  fmuls f3, f5, f1
	ctx.f[3].f64 = (((ctx.f[5].f64 * ctx.f[1].f64) as f32) as f64);
	// 822AEA74: FF041800  fcmpu cr6, f4, f3
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[3].f64);
	// 822AEA78: 40990014  ble cr6, 0x822aea8c
	if !ctx.cr[6].gt {
	pc = 0x822AEA8C; continue 'dispatch;
	}
	// 822AEA7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822AEA80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AEA84: 4855922D  bl 0x82807cb0
	ctx.lr = 0x822AEA88;
	sub_82807CB0(ctx, base);
	// 822AEA88: 48000020  b 0x822aeaa8
	pc = 0x822AEAA8; continue 'dispatch;
            }
            0x822AEA8C => {
    //   block [0x822AEA8C..0x822AEAA8)
	// 822AEA8C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AEA90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AEA94: C0030020  lfs f0, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AEA98: EC20382A  fadds f1, f0, f7
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64;
	// 822AEA9C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822AEAA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822AEAA4: 4E800421  bctrl
	ctx.lr = 0x822AEAA8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822AEAA8 => {
    //   block [0x822AEAA8..0x822AEAC0)
	// 822AEAA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822AEAAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AEAB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AEAB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822AEAB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AEABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AEAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822AEAC0 size=1660
    let mut pc: u32 = 0x822AEAC0;
    'dispatch: loop {
        match pc {
            0x822AEAC0 => {
    //   block [0x822AEAC0..0x822AF13C)
	// 822AEAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AEAC4: 489FA935  bl 0x82ca93f8
	ctx.lr = 0x822AEAC8;
	sub_82CA93D0(ctx, base);
	// 822AEAC8: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 822AEACC: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 822AEAD0: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AF140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AF140 size=828
    let mut pc: u32 = 0x822AF140;
    'dispatch: loop {
        match pc {
            0x822AF140 => {
    //   block [0x822AF140..0x822AF1BC)
	// 822AF140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AF144: 489FA2C1  bl 0x82ca9404
	ctx.lr = 0x822AF148;
	sub_82CA93D0(ctx, base);
	// 822AF148: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 822AF14C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AF150: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822AF154: 386B012C  addi r3, r11, 0x12c
	ctx.r[3].s64 = ctx.r[11].s64 + 300;
	// 822AF158: 838B0004  lwz r28, 4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF15C: 816B0130  lwz r11, 0x130(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) } as u64;
	// 822AF160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF164: 419A030C  beq cr6, 0x822af470
	if ctx.cr[6].eq {
	pc = 0x822AF470; continue 'dispatch;
	}
	// 822AF168: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AF16C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AF170: 419A004C  beq cr6, 0x822af1bc
	if ctx.cr[6].eq {
	pc = 0x822AF1BC; continue 'dispatch;
	}
	// 822AF174: 555B003E  slwi r27, r10, 0
	ctx.r[27].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 822AF178: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822AF17C: 419A02F4  beq cr6, 0x822af470
	if ctx.cr[6].eq {
	pc = 0x822AF470; continue 'dispatch;
	}
	// 822AF180: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 822AF184: 556AF7FE  rlwinm r10, r11, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 822AF188: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AF18C: 419A0108  beq cr6, 0x822af294
	if ctx.cr[6].eq {
	pc = 0x822AF294; continue 'dispatch;
	}
	// 822AF190: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AF194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF198: 419A0034  beq cr6, 0x822af1cc
	if ctx.cr[6].eq {
	pc = 0x822AF1CC; continue 'dispatch;
	}
	// 822AF19C: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 822AF1A0: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AF1A4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822AF1A8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822AF1AC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF1B0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 822AF1B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AF1B8: 480000E4  b 0x822af29c
	pc = 0x822AF29C; continue 'dispatch;
            }
            0x822AF1BC => {
    //   block [0x822AF1BC..0x822AF1CC)
	// 822AF1BC: 4BEE4C7D  bl 0x82193e38
	ctx.lr = 0x822AF1C0;
	sub_82193E38(ctx, base);
	// 822AF1C0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822AF1C4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822AF1C8: 489FA28C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x822AF1CC => {
    //   block [0x822AF1CC..0x822AF1EC)
	// 822AF1CC: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AF1D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822AF1D4: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AF1D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822AF1DC: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822AF1E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822AF1E4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AF1E8: 40810054  ble 0x822af23c
	if !ctx.cr[0].gt {
	pc = 0x822AF23C; continue 'dispatch;
	}
	pc = 0x822AF1EC; continue 'dispatch;
            }
            0x822AF1EC => {
    //   block [0x822AF1EC..0x822AF20C)
	// 822AF1EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AF1F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AF1F4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822AF1F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AF1FC: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 822AF200: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AF204: 41980008  blt cr6, 0x822af20c
	if ctx.cr[6].lt {
	pc = 0x822AF20C; continue 'dispatch;
	}
	// 822AF208: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822AF20C; continue 'dispatch;
            }
            0x822AF20C => {
    //   block [0x822AF20C..0x822AF228)
	// 822AF20C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AF210: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AF214: 419A0014  beq cr6, 0x822af228
	if ctx.cr[6].eq {
	pc = 0x822AF228; continue 'dispatch;
	}
	// 822AF218: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AF21C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AF220: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AF224: 4800000C  b 0x822af230
	pc = 0x822AF230; continue 'dispatch;
            }
            0x822AF228 => {
    //   block [0x822AF228..0x822AF230)
	// 822AF228: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AF22C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822AF230; continue 'dispatch;
            }
            0x822AF230 => {
    //   block [0x822AF230..0x822AF23C)
	// 822AF230: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AF234: 4199FFB8  bgt cr6, 0x822af1ec
	if ctx.cr[6].gt {
	pc = 0x822AF1EC; continue 'dispatch;
	}
	// 822AF238: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822AF23C; continue 'dispatch;
            }
            0x822AF23C => {
    //   block [0x822AF23C..0x822AF258)
	// 822AF23C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AF240: 419A0040  beq cr6, 0x822af280
	if ctx.cr[6].eq {
	pc = 0x822AF280; continue 'dispatch;
	}
	// 822AF244: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AF248: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822AF24C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AF250: 41990008  bgt cr6, 0x822af258
	if ctx.cr[6].gt {
	pc = 0x822AF258; continue 'dispatch;
	}
	// 822AF254: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822AF258; continue 'dispatch;
            }
            0x822AF258 => {
    //   block [0x822AF258..0x822AF280)
	// 822AF258: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AF25C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF260: 409A0020  bne cr6, 0x822af280
	if !ctx.cr[6].eq {
	pc = 0x822AF280; continue 'dispatch;
	}
	// 822AF264: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AF268: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822AF26C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822AF270: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF274: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 822AF278: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AF27C: 48000020  b 0x822af29c
	pc = 0x822AF29C; continue 'dispatch;
            }
            0x822AF280 => {
    //   block [0x822AF280..0x822AF294)
	// 822AF280: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822AF284: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF288: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 822AF28C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AF290: 4800000C  b 0x822af29c
	pc = 0x822AF29C; continue 'dispatch;
            }
            0x822AF294 => {
    //   block [0x822AF294..0x822AF29C)
	// 822AF294: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822AF298: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822AF29C; continue 'dispatch;
            }
            0x822AF29C => {
    //   block [0x822AF29C..0x822AF2E4)
	// 822AF29C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AF2A0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822AF2A4: 409A01CC  bne cr6, 0x822af470
	if !ctx.cr[6].eq {
	pc = 0x822AF470; continue 'dispatch;
	}
	// 822AF2A8: 817B0024  lwz r11, 0x24(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 822AF2AC: 556AF7FE  rlwinm r10, r11, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 822AF2B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AF2B4: 419A00F8  beq cr6, 0x822af3ac
	if ctx.cr[6].eq {
	pc = 0x822AF3AC; continue 'dispatch;
	}
	// 822AF2B8: 817B008C  lwz r11, 0x8c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AF2BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF2C0: 419A0024  beq cr6, 0x822af2e4
	if ctx.cr[6].eq {
	pc = 0x822AF2E4; continue 'dispatch;
	}
	// 822AF2C4: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 822AF2C8: 817B0048  lwz r11, 0x48(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AF2CC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822AF2D0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822AF2D4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF2D8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 822AF2DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AF2E0: 480000D4  b 0x822af3b4
	pc = 0x822AF3B4; continue 'dispatch;
            }
            0x822AF2E4 => {
    //   block [0x822AF2E4..0x822AF304)
	// 822AF2E4: 815B0048  lwz r10, 0x48(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AF2E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822AF2EC: 80DB004C  lwz r6, 0x4c(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AF2F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822AF2F4: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822AF2F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822AF2FC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AF300: 40810054  ble 0x822af354
	if !ctx.cr[0].gt {
	pc = 0x822AF354; continue 'dispatch;
	}
	pc = 0x822AF304; continue 'dispatch;
            }
            0x822AF304 => {
    //   block [0x822AF304..0x822AF324)
	// 822AF304: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AF308: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AF30C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822AF310: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AF314: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 822AF318: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AF31C: 41980008  blt cr6, 0x822af324
	if ctx.cr[6].lt {
	pc = 0x822AF324; continue 'dispatch;
	}
	// 822AF320: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822AF324; continue 'dispatch;
            }
            0x822AF324 => {
    //   block [0x822AF324..0x822AF340)
	// 822AF324: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AF328: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AF32C: 419A0014  beq cr6, 0x822af340
	if ctx.cr[6].eq {
	pc = 0x822AF340; continue 'dispatch;
	}
	// 822AF330: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AF334: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AF338: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AF33C: 4800000C  b 0x822af348
	pc = 0x822AF348; continue 'dispatch;
            }
            0x822AF340 => {
    //   block [0x822AF340..0x822AF348)
	// 822AF340: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AF344: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822AF348; continue 'dispatch;
            }
            0x822AF348 => {
    //   block [0x822AF348..0x822AF354)
	// 822AF348: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AF34C: 4199FFB8  bgt cr6, 0x822af304
	if ctx.cr[6].gt {
	pc = 0x822AF304; continue 'dispatch;
	}
	// 822AF350: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822AF354; continue 'dispatch;
            }
            0x822AF354 => {
    //   block [0x822AF354..0x822AF370)
	// 822AF354: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AF358: 419A0040  beq cr6, 0x822af398
	if ctx.cr[6].eq {
	pc = 0x822AF398; continue 'dispatch;
	}
	// 822AF35C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AF360: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822AF364: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AF368: 41990008  bgt cr6, 0x822af370
	if ctx.cr[6].gt {
	pc = 0x822AF370; continue 'dispatch;
	}
	// 822AF36C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822AF370; continue 'dispatch;
            }
            0x822AF370 => {
    //   block [0x822AF370..0x822AF398)
	// 822AF370: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AF374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF378: 409A0020  bne cr6, 0x822af398
	if !ctx.cr[6].eq {
	pc = 0x822AF398; continue 'dispatch;
	}
	// 822AF37C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AF380: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822AF384: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822AF388: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF38C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 822AF390: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AF394: 48000020  b 0x822af3b4
	pc = 0x822AF3B4; continue 'dispatch;
            }
            0x822AF398 => {
    //   block [0x822AF398..0x822AF3AC)
	// 822AF398: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822AF39C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF3A0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 822AF3A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AF3A8: 4800000C  b 0x822af3b4
	pc = 0x822AF3B4; continue 'dispatch;
            }
            0x822AF3AC => {
    //   block [0x822AF3AC..0x822AF3B4)
	// 822AF3AC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822AF3B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822AF3B4; continue 'dispatch;
            }
            0x822AF3B4 => {
    //   block [0x822AF3B4..0x822AF470)
	// 822AF3B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AF3B8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822AF3BC: 409A00B4  bne cr6, 0x822af470
	if !ctx.cr[6].eq {
	pc = 0x822AF470; continue 'dispatch;
	}
	// 822AF3C0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AF3C4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 822AF3C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822AF3CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AF3D0: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AF3D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822AF3D8: 4E800421  bctrl
	ctx.lr = 0x822AF3DC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822AF470 => {
    //   block [0x822AF470..0x822AF47C)
	// 822AF470: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822AF474: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822AF478: 489F9FDC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AF480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AF480 size=124
    let mut pc: u32 = 0x822AF480;
    'dispatch: loop {
        match pc {
            0x822AF480 => {
    //   block [0x822AF480..0x822AF4FC)
	// 822AF480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AF484: 489F9F89  bl 0x82ca940c
	ctx.lr = 0x822AF488;
	sub_82CA93D0(ctx, base);
	// 822AF488: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AF48C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822AF490: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822AF494: 39030010  addi r8, r3, 0x10
	ctx.r[8].s64 = ctx.r[3].s64 + 16;
	// 822AF498: 392BF798  addi r9, r11, -0x868
	ctx.r[9].s64 = ctx.r[11].s64 + -2152;
	// 822AF49C: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 822AF4A0: 394000C2  li r10, 0xc2
	ctx.r[10].s64 = 194;
	// 822AF4A4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF4A8: 7D27582E  lwzx r9, r7, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822AF4AC: 39690010  addi r11, r9, 0x10
	ctx.r[11].s64 = ctx.r[9].s64 + 16;
	// 822AF4B0: 7CE94050  subf r7, r9, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[9].s64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AF500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AF500 size=100
    let mut pc: u32 = 0x822AF500;
    'dispatch: loop {
        match pc {
            0x822AF500 => {
    //   block [0x822AF500..0x822AF538)
	// 822AF500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AF504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AF508: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AF50C: 4891C68D  bl 0x82bcbb98
	ctx.lr = 0x822AF510;
	sub_82BCBB98(ctx, base);
	// 822AF510: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF514: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822AF518: 419A0038  beq cr6, 0x822af550
	if ctx.cr[6].eq {
	pc = 0x822AF550; continue 'dispatch;
	}
	// 822AF51C: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 822AF520: 419A0018  beq cr6, 0x822af538
	if ctx.cr[6].eq {
	pc = 0x822AF538; continue 'dispatch;
	}
	// 822AF524: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822AF528: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AF52C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AF530: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AF534: 4E800020  blr
	return;
            }
            0x822AF538 => {
    //   block [0x822AF538..0x822AF550)
	// 822AF538: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AF53C: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 822AF540: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AF544: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AF548: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AF54C: 4E800020  blr
	return;
            }
            0x822AF550 => {
    //   block [0x822AF550..0x822AF564)
	// 822AF550: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AF554: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AF558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AF55C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AF560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AF568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822AF568 size=112
    let mut pc: u32 = 0x822AF568;
    'dispatch: loop {
        match pc {
            0x822AF568 => {
    //   block [0x822AF568..0x822AF5A0)
	// 822AF568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AF56C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822AF570: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822AF574: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AF578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822AF57C: 817F2AA4  lwz r11, 0x2aa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10916 as u32) ) } as u64;
	// 822AF580: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 822AF584: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822AF588: 508B64A6  rlwimi r11, r4, 0xc, 0x12, 0x13
	ctx.r[11].u64 = (((ctx.r[4].u32).rotate_left(12) as u64) & 0x0000000000003000) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFCFFF);
	// 822AF58C: 7F035040  cmplw cr6, r3, r10
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822AF590: 917F2AA4  stw r11, 0x2aa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10916 as u32), ctx.r[11].u32 ) };
	// 822AF594: 4099000C  ble cr6, 0x822af5a0
	if !ctx.cr[6].gt {
	pc = 0x822AF5A0; continue 'dispatch;
	}
	// 822AF598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822AF59C: 4BF39925  bl 0x821e8ec0
	ctx.lr = 0x822AF5A0;
	sub_821E8EC0(ctx, base);
	pc = 0x822AF5A0; continue 'dispatch;
            }
            0x822AF5A0 => {
    //   block [0x822AF5A0..0x822AF5D8)
	// 822AF5A0: 396005C8  li r11, 0x5c8
	ctx.r[11].s64 = 1480;
	// 822AF5A4: 3D400002  lis r10, 2
	ctx.r[10].s64 = 131072;
	// 822AF5A8: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 822AF5AC: 39600F01  li r11, 0xf01
	ctx.r[11].s64 = 3841;
	// 822AF5B0: 95430004  stwu r10, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[3].u32 = ea;
	// 822AF5B4: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 822AF5B8: 817F2AA4  lwz r11, 0x2aa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10916 as u32) ) } as u64;
	// 822AF5BC: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 822AF5C0: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 822AF5C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822AF5C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822AF5CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822AF5D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822AF5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AF5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822AF5D8 size=28
    let mut pc: u32 = 0x822AF5D8;
    'dispatch: loop {
        match pc {
            0x822AF5D8 => {
    //   block [0x822AF5D8..0x822AF5F4)
	// 822AF5D8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822AF5DC: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 822AF5E0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822AF5E4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822AF5E8: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 822AF5EC: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF5F0: 4BFC9630  b 0x82278c20
	sub_82278C20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822AF5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822AF5F8 size=2888
    let mut pc: u32 = 0x822AF5F8;
    'dispatch: loop {
        match pc {
            0x822AF5F8 => {
    //   block [0x822AF5F8..0x822AF690)
	// 822AF5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822AF5FC: 489F9DED  bl 0x82ca93e8
	ctx.lr = 0x822AF600;
	sub_82CA93D0(ctx, base);
	// 822AF600: DBC1FF88  stfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 822AF604: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 822AF608: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822AF60C: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 822AF610: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822AF614: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822AF618: 3AEB0B7C  addi r23, r11, 0xb7c
	ctx.r[23].s64 = ctx.r[11].s64 + 2940;
	// 822AF61C: 3B150154  addi r24, r21, 0x154
	ctx.r[24].s64 = ctx.r[21].s64 + 340;
	// 822AF620: 81750158  lwz r11, 0x158(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(344 as u32) ) } as u64;
	// 822AF624: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 822AF628: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 822AF62C: 3ACA0B7C  addi r22, r10, 0xb7c
	ctx.r[22].s64 = ctx.r[10].s64 + 2940;
	// 822AF630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF634: 419A0098  beq cr6, 0x822af6cc
	if ctx.cr[6].eq {
	pc = 0x822AF6CC; continue 'dispatch;
	}
	// 822AF638: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AF63C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AF640: 419A011C  beq cr6, 0x822af75c
	if ctx.cr[6].eq {
	pc = 0x822AF75C; continue 'dispatch;
	}
	// 822AF644: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822AF648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF64C: 419A0080  beq cr6, 0x822af6cc
	if ctx.cr[6].eq {
	pc = 0x822AF6CC; continue 'dispatch;
	}
	// 822AF650: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF654: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF658: 419A0038  beq cr6, 0x822af690
	if ctx.cr[6].eq {
	pc = 0x822AF690; continue 'dispatch;
	}
	// 822AF65C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AF660: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AF664: 419A0104  beq cr6, 0x822af768
	if ctx.cr[6].eq {
	pc = 0x822AF768; continue 'dispatch;
	}
	// 822AF668: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822AF66C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF670: 419A0020  beq cr6, 0x822af690
	if ctx.cr[6].eq {
	pc = 0x822AF690; continue 'dispatch;
	}
	// 822AF674: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822AF678: 4BEC47C1  bl 0x82173e38
	ctx.lr = 0x822AF67C;
	sub_82173E38(ctx, base);
	// 822AF67C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 822AF680: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822AF684: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AF688: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AF68C: 409A0008  bne cr6, 0x822af694
	if !ctx.cr[6].eq {
	pc = 0x822AF694; continue 'dispatch;
	}
	pc = 0x822AF690; continue 'dispatch;
            }
            0x822AF690 => {
    //   block [0x822AF690..0x822AF694)
	// 822AF690: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822AF694; continue 'dispatch;
            }
            0x822AF694 => {
    //   block [0x822AF694..0x822AF6CC)
	// 822AF694: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AF698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF69C: 409A0030  bne cr6, 0x822af6cc
	if !ctx.cr[6].eq {
	pc = 0x822AF6CC; continue 'dispatch;
	}
	// 822AF6A0: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 822AF6A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AF6A8: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 822AF6AC: 4BEE478D  bl 0x82193e38
	ctx.lr = 0x822AF6B0;
	sub_82193E38(ctx, base);
	// 822AF6B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822AF6B4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822AF6B8: 48222811  bl 0x824d1ec8
	ctx.lr = 0x822AF6BC;
	sub_824D1EC8(ctx, base);
	// 822AF6BC: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 822AF6C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AF6C4: 4BEE4775  bl 0x82193e38
	ctx.lr = 0x822AF6C8;
	sub_82193E38(ctx, base);
	// 822AF6C8: 93B500D4  stw r29, 0xd4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	pc = 0x822AF6CC; continue 'dispatch;
            }
            0x822AF6CC => {
    //   block [0x822AF6CC..0x822AF710)
	// 822AF6CC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822AF6D0: 807500D4  lwz r3, 0xd4(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(212 as u32) ) } as u64;
	// 822AF6D4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 822AF6D8: 828B9650  lwz r20, -0x69b0(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822AF6DC: 419802C4  blt cr6, 0x822af9a0
	if ctx.cr[6].lt {
	pc = 0x822AF9A0; continue 'dispatch;
	}
	// 822AF6E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822AF6E4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822AF6E8: 3BCB9484  addi r30, r11, -0x6b7c
	ctx.r[30].s64 = ctx.r[11].s64 + -27516;
	// 822AF6EC: C01E4144  lfs f0, 0x4144(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AF6F0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822AF6F4: 483C3EA5  bl 0x82673598
	ctx.lr = 0x822AF6F8;
	sub_82673598(ctx, base);
	// 822AF6F8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822AF6FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF700: 409A0010  bne cr6, 0x822af710
	if !ctx.cr[6].eq {
	pc = 0x822AF710; continue 'dispatch;
	}
	// 822AF704: 817500F4  lwz r11, 0xf4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(244 as u32) ) } as u64;
	// 822AF708: 7F0BA000  cmpw cr6, r11, r20
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[20].s32, &mut ctx.xer);
	// 822AF70C: 40980A24  bge cr6, 0x822b0130
	if !ctx.cr[6].lt {
	pc = 0x822B0130; continue 'dispatch;
	}
	pc = 0x822AF710; continue 'dispatch;
            }
            0x822AF710 => {
    //   block [0x822AF710..0x822AF75C)
	// 822AF710: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822AF714: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 822AF718: 806B6CEC  lwz r3, 0x6cec(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27884 as u32) ) } as u64;
	// 822AF71C: 4836A2B5  bl 0x826199d0
	ctx.lr = 0x822AF720;
	sub_826199D0(ctx, base);
	// 822AF720: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 822AF724: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 822AF728: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822AF72C: 419A010C  beq cr6, 0x822af838
	if ctx.cr[6].eq {
	pc = 0x822AF838; continue 'dispatch;
	}
	// 822AF730: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822AF734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF738: 419A003C  beq cr6, 0x822af774
	if ctx.cr[6].eq {
	pc = 0x822AF774; continue 'dispatch;
	}
	// 822AF73C: 894B003C  lbz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 822AF740: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AF744: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822AF748: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822AF74C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF750: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AF754: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AF758: 480000E4  b 0x822af83c
	pc = 0x822AF83C; continue 'dispatch;
            }
            0x822AF75C => {
    //   block [0x822AF75C..0x822AF768)
	// 822AF75C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822AF760: 4BEE46D9  bl 0x82193e38
	ctx.lr = 0x822AF764;
	sub_82193E38(ctx, base);
	// 822AF764: 4BFFFF68  b 0x822af6cc
	pc = 0x822AF6CC; continue 'dispatch;
            }
            0x822AF768 => {
    //   block [0x822AF768..0x822AF774)
	// 822AF768: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822AF76C: 4BEE46CD  bl 0x82193e38
	ctx.lr = 0x822AF770;
	sub_82193E38(ctx, base);
	// 822AF770: 4BFFFF20  b 0x822af690
	pc = 0x822AF690; continue 'dispatch;
            }
            0x822AF774 => {
    //   block [0x822AF774..0x822AF790)
	// 822AF774: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822AF778: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822AF77C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 822AF780: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822AF784: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822AF788: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AF78C: 40810054  ble 0x822af7e0
	if !ctx.cr[0].gt {
	pc = 0x822AF7E0; continue 'dispatch;
	}
	pc = 0x822AF790; continue 'dispatch;
            }
            0x822AF790 => {
    //   block [0x822AF790..0x822AF7B0)
	// 822AF790: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822AF794: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822AF798: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822AF79C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AF7A0: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 822AF7A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822AF7A8: 41980008  blt cr6, 0x822af7b0
	if ctx.cr[6].lt {
	pc = 0x822AF7B0; continue 'dispatch;
	}
	// 822AF7AC: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x822AF7B0; continue 'dispatch;
            }
            0x822AF7B0 => {
    //   block [0x822AF7B0..0x822AF7CC)
	// 822AF7B0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822AF7B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822AF7B8: 419A0014  beq cr6, 0x822af7cc
	if ctx.cr[6].eq {
	pc = 0x822AF7CC; continue 'dispatch;
	}
	// 822AF7BC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822AF7C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822AF7C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822AF7C8: 4800000C  b 0x822af7d4
	pc = 0x822AF7D4; continue 'dispatch;
            }
            0x822AF7CC => {
    //   block [0x822AF7CC..0x822AF7D4)
	// 822AF7CC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822AF7D0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822AF7D4; continue 'dispatch;
            }
            0x822AF7D4 => {
    //   block [0x822AF7D4..0x822AF7E0)
	// 822AF7D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822AF7D8: 4199FFB8  bgt cr6, 0x822af790
	if ctx.cr[6].gt {
	pc = 0x822AF790; continue 'dispatch;
	}
	// 822AF7DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822AF7E0; continue 'dispatch;
            }
            0x822AF7E0 => {
    //   block [0x822AF7E0..0x822AF7FC)
	// 822AF7E0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822AF7E4: 419A0040  beq cr6, 0x822af824
	if ctx.cr[6].eq {
	pc = 0x822AF824; continue 'dispatch;
	}
	// 822AF7E8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AF7EC: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 822AF7F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AF7F4: 41990008  bgt cr6, 0x822af7fc
	if ctx.cr[6].gt {
	pc = 0x822AF7FC; continue 'dispatch;
	}
	// 822AF7F8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822AF7FC; continue 'dispatch;
            }
            0x822AF7FC => {
    //   block [0x822AF7FC..0x822AF824)
	// 822AF7FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AF800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF804: 409A0020  bne cr6, 0x822af824
	if !ctx.cr[6].eq {
	pc = 0x822AF824; continue 'dispatch;
	}
	// 822AF808: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822AF80C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822AF810: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822AF814: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF818: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AF81C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AF820: 4800001C  b 0x822af83c
	pc = 0x822AF83C; continue 'dispatch;
            }
            0x822AF824 => {
    //   block [0x822AF824..0x822AF838)
	// 822AF824: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822AF828: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF82C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822AF830: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AF834: 48000008  b 0x822af83c
	pc = 0x822AF83C; continue 'dispatch;
            }
            0x822AF838 => {
    //   block [0x822AF838..0x822AF83C)
	// 822AF838: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822AF83C; continue 'dispatch;
            }
            0x822AF83C => {
    //   block [0x822AF83C..0x822AF850)
	// 822AF83C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AF840: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822AF844: 409A000C  bne cr6, 0x822af850
	if !ctx.cr[6].eq {
	pc = 0x822AF850; continue 'dispatch;
	}
	// 822AF848: 8975002B  lbz r11, 0x2b(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(43 as u32) ) } as u64;
	// 822AF84C: 997F0284  stb r11, 0x284(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u8 ) };
	pc = 0x822AF850; continue 'dispatch;
            }
            0x822AF850 => {
    //   block [0x822AF850..0x822AF894)
	// 822AF850: 93B500D4  stw r29, 0xd4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 822AF854: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822AF858: 4BEC45E1  bl 0x82173e38
	ctx.lr = 0x822AF85C;
	sub_82173E38(ctx, base);
	// 822AF85C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822AF860: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 822AF864: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822AF868: 4BECF401  bl 0x8217ec68
	ctx.lr = 0x822AF86C;
	sub_8217EC68(ctx, base);
	// 822AF86C: C01E2320  lfs f0, 0x2320(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8992 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822AF870: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822AF874: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 822AF878: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822AF87C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 822AF880: 41980014  blt cr6, 0x822af894
	if ctx.cr[6].lt {
	pc = 0x822AF894; continue 'dispatch;
	}
	// 822AF884: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822AF888: 409908A8  ble cr6, 0x822b0130
	if !ctx.cr[6].gt {
	pc = 0x822B0130; continue 'dispatch;
	}
	// 822AF88C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 822AF890: 40980038  bge cr6, 0x822af8c8
	if !ctx.cr[6].lt {
	pc = 0x822AF8C8; continue 'dispatch;
	}
	pc = 0x822AF894; continue 'dispatch;
            }
            0x822AF894 => {
    //   block [0x822AF894..0x822AF8C8)
	// 822AF894: 7E8B07B4  extsw r11, r20
	ctx.r[11].s64 = ctx.r[20].s32 as i64;
	// 822AF898: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 822AF89C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822AF8A0: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822AF8A4: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 822AF8A8: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 822AF8AC: C80A9660  lfd f0, -0x69a0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 822AF8B0: C9A91718  lfd f13, 0x1718(r9)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(5912 as u32) ) };
	// 822AF8B4: FD60637A  fmadd f11, f0, f13, f12
	ctx.f[11].f64 = ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64;
	// 822AF8B8: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 822AF8BC: D9410058  stfd f10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[10].u64 ) };
	// 822AF8C0: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822AF8C4: 48000034  b 0x822af8f8
	pc = 0x822AF8F8; continue 'dispatch;
            }
            0x822AF8C8 => {
    //   block [0x822AF8C8..0x822AF8F8)
	// 822AF8C8: 7E8B07B4  extsw r11, r20
	ctx.r[11].s64 = ctx.r[20].s32 as i64;
	// 822AF8CC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 822AF8D0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822AF8D4: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 822AF8D8: C9A99610  lfd f13, -0x69f0(r9)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-27120 as u32) ) };
	// 822AF8DC: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822AF8E0: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 822AF8E4: C80A9660  lfd f0, -0x69a0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 822AF8E8: FD60637A  fmadd f11, f0, f13, f12
	ctx.f[11].f64 = ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64;
	// 822AF8EC: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 822AF8F0: D9410058  stfd f10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[10].u64 ) };
	// 822AF8F4: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x822AF8F8; continue 'dispatch;
            }
            0x822AF8F8 => {
    //   block [0x822AF8F8..0x822AF9A0)
	// 822AF8F8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 822AF8FC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822AF900: 4BEE7471  bl 0x82196d70
	ctx.lr = 0x822AF904;
	sub_82196D70(ctx, base);
	// 822AF904: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822AF908: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822AF90C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822AF910: 4BEE7461  bl 0x82196d70
	ctx.lr = 0x822AF914;
	sub_82196D70(ctx, base);
	// 822AF914: 92FE0000  stw r23, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 822AF918: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822AF91C: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 822AF920: 4BEE4519  bl 0x82193e38
	ctx.lr = 0x822AF924;
	sub_82193E38(ctx, base);
	// 822AF924: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822AF928: 933E0004  stw r25, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822AF92C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 822AF930: 394BBC24  addi r10, r11, -0x43dc
	ctx.r[10].s64 = ctx.r[11].s64 + -17372;
	// 822AF934: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 822AF938: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 822AF93C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF940: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 822AF944: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822AF948: 48566E71  bl 0x828167b8
	ctx.lr = 0x822AF94C;
	sub_828167B8(ctx, base);
	// 822AF94C: 92E10070  stw r23, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[23].u32 ) };
	// 822AF950: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822AF954: 4BEE44E5  bl 0x82193e38
	ctx.lr = 0x822AF958;
	sub_82193E38(ctx, base);
	// 822AF958: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 822AF95C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 822AF960: 3869BC18  addi r3, r9, -0x43e8
	ctx.r[3].s64 = ctx.r[9].s64 + -17384;
	// 822AF964: 485666BD  bl 0x82816020
	ctx.lr = 0x822AF968;
	sub_82816020(ctx, base);
	// 822AF968: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 822AF96C: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 822AF970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AF974: 4BEE44C5  bl 0x82193e38
	ctx.lr = 0x822AF978;
	sub_82193E38(ctx, base);
	// 822AF978: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822AF97C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822AF980: 48222549  bl 0x824d1ec8
	ctx.lr = 0x822AF984;
	sub_824D1EC8(ctx, base);
	// 822AF984: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 822AF988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AF98C: 4BEE44AD  bl 0x82193e38
	ctx.lr = 0x822AF990;
	sub_82193E38(ctx, base);
	// 822AF990: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 822AF994: CBC1FF88  lfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 822AF998: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 822AF99C: 489F9A9C  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x822AF9A0 => {
    //   block [0x822AF9A0..0x822AF9E0)
	// 822AF9A0: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AF9A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF9A8: 419A0038  beq cr6, 0x822af9e0
	if ctx.cr[6].eq {
	pc = 0x822AF9E0; continue 'dispatch;
	}
	// 822AF9AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AF9B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AF9B4: 419A0124  beq cr6, 0x822afad8
	if ctx.cr[6].eq {
	pc = 0x822AFAD8; continue 'dispatch;
	}
	// 822AF9B8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822AF9BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF9C0: 419A0020  beq cr6, 0x822af9e0
	if ctx.cr[6].eq {
	pc = 0x822AF9E0; continue 'dispatch;
	}
	// 822AF9C4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822AF9C8: 4BEC4471  bl 0x82173e38
	ctx.lr = 0x822AF9CC;
	sub_82173E38(ctx, base);
	// 822AF9CC: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 822AF9D0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822AF9D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AF9D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AF9DC: 409A0008  bne cr6, 0x822af9e4
	if !ctx.cr[6].eq {
	pc = 0x822AF9E4; continue 'dispatch;
	}
	pc = 0x822AF9E0; continue 'dispatch;
            }
            0x822AF9E0 => {
    //   block [0x822AF9E0..0x822AF9E4)
	// 822AF9E0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x822AF9E4; continue 'dispatch;
            }
            0x822AF9E4 => {
    //   block [0x822AF9E4..0x822AFAD8)
	// 822AF9E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AF9E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AF9EC: 419A00F8  beq cr6, 0x822afae4
	if ctx.cr[6].eq {
	pc = 0x822AFAE4; continue 'dispatch;
	}
	// 822AF9F0: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 822AF9F4: 4BEC4A1D  bl 0x82174410
	ctx.lr = 0x822AF9F8;
	sub_82174410(ctx, base);
	// 822AF9F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822AF9FC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822AFA00: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 822AFA04: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AFA08: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 822AFA0C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822AFA10: 4E800421  bctrl
	ctx.lr = 0x822AFA14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822AFA14: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822AFA18: 4BEC4421  bl 0x82173e38
	ctx.lr = 0x822AFA1C;
	sub_82173E38(ctx, base);
	// 822AFA1C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 822AFA20: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 822AFA24: 8088007C  lwz r4, 0x7c(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(124 as u32) ) } as u64;
	// 822AFA28: 80E40000  lwz r7, 0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AFA2C: 80C70040  lwz r6, 0x40(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(64 as u32) ) } as u64;
	// 822AFA30: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 822AFA34: 4E800421  bctrl
	ctx.lr = 0x822AFA38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822AFA38: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 822AFA3C: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 822AFA40: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 822AFA44: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
            }
            0x822AFAD8 => {
    //   block [0x822AFAD8..0x822AFAE4)
	// 822AFAD8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822AFADC: 4BEE435D  bl 0x82193e38
	ctx.lr = 0x822AFAE0;
	sub_82193E38(ctx, base);
	// 822AFAE0: 4BFFFF00  b 0x822af9e0
	pc = 0x822AF9E0; continue 'dispatch;
            }
            0x822AFAE4 => {
    //   block [0x822AFAE4..0x822B0130)
	// 822AFAE4: 817500A0  lwz r11, 0xa0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(160 as u32) ) } as u64;
	// 822AFAE8: 7F145800  cmpw cr6, r20, r11
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822AFAEC: 409904E0  ble cr6, 0x822affcc
	if !ctx.cr[6].gt {
	pc = 0x822AFFCC; continue 'dispatch;
	}
	// 822AFAF0: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 822AFAF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AFAF8: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 822AFAFC: 4BEE433D  bl 0x82193e38
	ctx.lr = 0x822AFB00;
	sub_82193E38(ctx, base);
	// 822AFB00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822AFB04: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822AFB08: 482223C1  bl 0x824d1ec8
	ctx.lr = 0x822AFB0C;
	sub_824D1EC8(ctx, base);
	// 822AFB0C: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 822AFB10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822AFB14: 4BEE4325  bl 0x82193e38
	ctx.lr = 0x822AFB18;
	sub_82193E38(ctx, base);
	// 822AFB18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822AFB1C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 822AFB20: C3CB0BEC  lfs f30, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822AFB24: 4BEC48ED  bl 0x82174410
	ctx.lr = 0x822AFB28;
	sub_82174410(ctx, base);
	// 822AFB28: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 822AFB2C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 822AFB30: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 822AFB34: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AFB38: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 822AFB3C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 822AFB40: 4E800421  bctrl
	ctx.lr = 0x822AFB44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822AFB44: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822AFB48: 3B8BBC18  addi r28, r11, -0x43e8
	ctx.r[28].s64 = ctx.r[11].s64 + -17384;
	// 822AFB4C: 7F9AE378  mr r26, r28
	ctx.r[26].u64 = ctx.r[28].u64;
	// 822AFB50: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 822AFB54: 80FC0004  lwz r7, 4(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AFB58: 83670000  lwz r27, 0(r7)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AFB5C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 822AFB60: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 822AFB64: 419A000C  beq cr6, 0x822afb70
	if ctx.cr[6].eq {
	pc = 0x822AFB70; continue 'dispatch;
	}
	// 822AFB68: 7F1AE040  cmplw cr6, r26, r28
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[28].u32, &mut ctx.xer);
	// 822AFB6C: 419A0008  beq cr6, 0x822afb74
	if ctx.cr[6].eq {
	pc = 0x822AFB74; continue 'dispatch;
	}
	// 822AFB70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 822AFB74: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AFB78: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822AFB7C: 419A0254  beq cr6, 0x822afdd0
	if ctx.cr[6].eq {
	pc = 0x822AFDD0; continue 'dispatch;
	}
	// 822AFB80: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 822AFB84: 409A0008  bne cr6, 0x822afb8c
	if !ctx.cr[6].eq {
	pc = 0x822AFB8C; continue 'dispatch;
	}
	// 822AFB88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 822AFB8C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822AFB90: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822AFB94: 409A0008  bne cr6, 0x822afb9c
	if !ctx.cr[6].eq {
	pc = 0x822AFB9C; continue 'dispatch;
	}
	// 822AFB98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 822AFB9C: 387B0008  addi r3, r27, 8
	ctx.r[3].s64 = ctx.r[27].s64 + 8;
	// 822AFBA0: 4BEC4299  bl 0x82173e38
	ctx.lr = 0x822AFBA4;
	sub_82173E38(ctx, base);
	// 822AFBA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822AFBA8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822AFBAC: 419A0018  beq cr6, 0x822afbc4
	if ctx.cr[6].eq {
	pc = 0x822AFBC4; continue 'dispatch;
	}
	// 822AFBB0: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 822AFBB4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822AFBB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822AFBBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822AFBC0: 409A0008  bne cr6, 0x822afbc8
	if !ctx.cr[6].eq {
	pc = 0x822AFBC8; continue 'dispatch;
	}
	// 822AFBC4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822AFBC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822AFBCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822AFBD0: 419A01DC  beq cr6, 0x822afdac
	if ctx.cr[6].eq {
	pc = 0x822AFDAC; continue 'dispatch;
	}
	// 822AFBD4: 809E007C  lwz r4, 0x7c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 822AFBD8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822AFBDC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822AFBE0: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 822AFBE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822AFBE8: 4E800421  bctrl
	ctx.lr = 0x822AFBEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822AFBEC: 392100B0  addi r9, r1, 0xb0
	ctx.r[9].s64 = ctx.r[1].s64 + 176;
	// 822AFBF0: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 822AFBF4: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 822AFBF8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822AFBFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
            }
            0x822B0130 => {
    //   block [0x822B0130..0x822B0140)
	// 822B0130: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 822B0134: CBC1FF88  lfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 822B0138: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 822B013C: 489F92FC  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B0140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B0140 size=412
    let mut pc: u32 = 0x822B0140;
    'dispatch: loop {
        match pc {
            0x822B0140 => {
    //   block [0x822B0140..0x822B0168)
	// 822B0140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B0144: 489F92C9  bl 0x82ca940c
	ctx.lr = 0x822B0148;
	sub_82CA93D0(ctx, base);
	// 822B0148: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B014C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B0150: 897F0080  lbz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822B0154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0158: 419A0010  beq cr6, 0x822b0168
	if ctx.cr[6].eq {
	pc = 0x822B0168; continue 'dispatch;
	}
	// 822B015C: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 822B0160: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B0164: 419A0010  beq cr6, 0x822b0174
	if ctx.cr[6].eq {
	pc = 0x822B0174; continue 'dispatch;
	}
	pc = 0x822B0168; continue 'dispatch;
            }
            0x822B0168 => {
    //   block [0x822B0168..0x822B0174)
	// 822B0168: 897F0081  lbz r11, 0x81(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(129 as u32) ) } as u64;
	// 822B016C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0170: 409A0020  bne cr6, 0x822b0190
	if !ctx.cr[6].eq {
	pc = 0x822B0190; continue 'dispatch;
	}
	pc = 0x822B0174; continue 'dispatch;
            }
            0x822B0174 => {
    //   block [0x822B0174..0x822B0190)
	// 822B0174: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B0178: 394B9490  addi r10, r11, -0x6b70
	ctx.r[10].s64 = ctx.r[11].s64 + -27504;
	// 822B017C: C00AFFF4  lfs f0, -0xc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B0180: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822B0184: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 822B0188: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B018C: 489F92D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B0190 => {
    //   block [0x822B0190..0x822B02DC)
	// 822B0190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B0194: 4800114D  bl 0x822b12e0
	ctx.lr = 0x822B0198;
	sub_822B12E0(ctx, base);
	// 822B0198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B019C: 4BFEFBED  bl 0x8229fd88
	ctx.lr = 0x822B01A0;
	sub_8229FD88(ctx, base);
	// 822B01A0: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 822B01A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822B01A8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B01AC: 3BDF0024  addi r30, r31, 0x24
	ctx.r[30].s64 = ctx.r[31].s64 + 36;
	// 822B01B0: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822B01B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B01B8: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B01BC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B01C0: 80690030  lwz r3, 0x30(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 822B01C4: 4800675D  bl 0x822b6920
	ctx.lr = 0x822B01C8;
	sub_822B6920(ctx, base);
	// 822B01C8: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B01CC: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822B01D0: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 822B01D4: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822B01D8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822B01DC: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B01E0: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 822B01E4: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B01E8: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B01EC: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B01F0: 80660030  lwz r3, 0x30(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(48 as u32) ) } as u64;
	// 822B01F4: 4800672D  bl 0x822b6920
	ctx.lr = 0x822B01F8;
	sub_822B6920(ctx, base);
	// 822B01F8: C15F0024  lfs f10, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822B01FC: C13F001C  lfs f9, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822B0200: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 822B0204: ECE9502A  fadds f7, f9, f10
	ctx.f[7].f64 = ((ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64;
	// 822B0208: C0DF0038  lfs f6, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 822B020C: 38859490  addi r4, r5, -0x6b70
	ctx.r[4].s64 = ctx.r[5].s64 + -27504;
	// 822B0210: C19F0028  lfs f12, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B0214: ED61602A  fadds f11, f1, f12
	ctx.f[11].f64 = ((ctx.f[1].f64 + ctx.f[12].f64) as f32) as f64;
	// 822B0218: 3C608210  lis r3, -0x7df0
	ctx.r[3].s64 = -2112880640;
	// 822B021C: C11F0020  lfs f8, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822B0220: 39630E68  addi r11, r3, 0xe68
	ctx.r[11].s64 = ctx.r[3].s64 + 3688;
	// 822B0224: C1859490  lfs f12, -0x6b70(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B0228: C0044138  lfs f0, 0x4138(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B022C: C1A4FFF4  lfs f13, -0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B0230: EC8701B2  fmuls f4, f7, f6
	ctx.f[4].f64 = (((ctx.f[7].f64 * ctx.f[6].f64) as f32) as f64);
	// 822B0234: D09F0024  stfs f4, 0x24(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822B0238: ECA8582A  fadds f5, f8, f11
	ctx.f[5].f64 = ((ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64;
	// 822B023C: FC402090  fmr f2, f4
	ctx.f[2].f64 = ctx.f[4].f64;
	// 822B0240: EC6501B2  fmuls f3, f5, f6
	ctx.f[3].f64 = (((ctx.f[5].f64 * ctx.f[6].f64) as f32) as f64);
	// 822B0244: D07F0028  stfs f3, 0x28(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 822B0248: EC220028  fsubs f1, f2, f0
	ctx.f[1].f64 = (((ctx.f[2].f64 - ctx.f[0].f64) as f32) as f64);
	// 822B024C: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 822B0250: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B0254: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822B0258: 5548F77A  rlwinm r8, r10, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 822B025C: 7D274378  or r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 822B0260: 7D6B3C2E  lfsx f11, r11, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822B0264: FD4B00AE  fsel f10, f11, f2, f0
	ctx.f[10].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[2].f64 } else { ctx.f[0].f64 };
	// 822B0268: ED2A6028  fsubs f9, f10, f12
	ctx.f[9].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 822B026C: FF096800  fcmpu cr6, f9, f13
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[13].f64);
	// 822B0270: 7CC00026  mfcr r6
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[6].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B0274: 54C5DF7A  rlwinm r5, r6, 0x1b, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 822B0278: 54C4F77A  rlwinm r4, r6, 0x1e, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 822B027C: 7CA32378  or r3, r5, r4
	ctx.r[3].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 822B0280: 7D0B1C2E  lfsx f8, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822B0284: FCE8532E  fsel f7, f8, f12, f10
	ctx.f[7].f64 = if ctx.f[8].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[10].f64 };
	// 822B0288: D0FF0024  stfs f7, 0x24(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822B028C: C0DF0028  lfs f6, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 822B0290: ECA60028  fsubs f5, f6, f0
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[0].f64) as f32) as f64);
	// 822B0294: FF056800  fcmpu cr6, f5, f13
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[13].f64);
	// 822B0298: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B029C: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822B02A0: 5548F77A  rlwinm r8, r10, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 822B02A4: 7D274378  or r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 822B02A8: 7C8B3C2E  lfsx f4, r11, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 822B02AC: FC6401AE  fsel f3, f4, f6, f0
	ctx.f[3].f64 = if ctx.f[4].f64 >= 0.0 { ctx.f[6].f64 } else { ctx.f[0].f64 };
	// 822B02B0: EC436028  fsubs f2, f3, f12
	ctx.f[2].f64 = (((ctx.f[3].f64 - ctx.f[12].f64) as f32) as f64);
	// 822B02B4: FF026800  fcmpu cr6, f2, f13
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[13].f64);
	// 822B02B8: 7CC00026  mfcr r6
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[6].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B02BC: 54C5DF7A  rlwinm r5, r6, 0x1b, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 822B02C0: 54C4F77A  rlwinm r4, r6, 0x1e, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 822B02C4: 7CA32378  or r3, r5, r4
	ctx.r[3].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 822B02C8: 7C2B1C2E  lfsx f1, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822B02CC: FC011B2E  fsel f0, f1, f12, f3
	ctx.f[0].f64 = if ctx.f[1].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[3].f64 };
	// 822B02D0: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 822B02D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B02D8: 489F9184  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B02E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B02E0 size=412
    let mut pc: u32 = 0x822B02E0;
    'dispatch: loop {
        match pc {
            0x822B02E0 => {
    //   block [0x822B02E0..0x822B0360)
	// 822B02E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B02E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B02E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B02EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B02F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B02F4: 897F0081  lbz r11, 0x81(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(129 as u32) ) } as u64;
	// 822B02F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B02FC: 419A016C  beq cr6, 0x822b0468
	if ctx.cr[6].eq {
	pc = 0x822B0468; continue 'dispatch;
	}
	// 822B0300: 4BFF0D29  bl 0x822a1028
	ctx.lr = 0x822B0304;
	sub_822A1028(ctx, base);
	// 822B0304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B0308: 4BED1221  bl 0x82181528
	ctx.lr = 0x822B030C;
	sub_82181528(ctx, base);
	// 822B030C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B0310: 4BFFFE31  bl 0x822b0140
	ctx.lr = 0x822B0314;
	sub_822B0140(ctx, base);
	// 822B0314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B0318: 48000169  bl 0x822b0480
	ctx.lr = 0x822B031C;
	sub_822B0480(ctx, base);
	// 822B031C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0320: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822B0324: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822B0328: 552837FE  rlwinm r8, r9, 6, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x03FFFFFFu64;
	// 822B032C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822B0330: 419A00F8  beq cr6, 0x822b0428
	if ctx.cr[6].eq {
	pc = 0x822B0428; continue 'dispatch;
	}
	// 822B0334: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B0338: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B033C: 419A0024  beq cr6, 0x822b0360
	if ctx.cr[6].eq {
	pc = 0x822B0360; continue 'dispatch;
	}
	// 822B0340: 892A001A  lbz r9, 0x1a(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(26 as u32) ) } as u64;
	// 822B0344: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B0348: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 822B034C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822B0350: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0354: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B0358: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B035C: 480000D0  b 0x822b042c
	pc = 0x822B042C; continue 'dispatch;
            }
            0x822B0360 => {
    //   block [0x822B0360..0x822B0380)
	// 822B0360: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B0364: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822B0368: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B036C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 822B0370: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B0374: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B0378: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B037C: 40810054  ble 0x822b03d0
	if !ctx.cr[0].gt {
	pc = 0x822B03D0; continue 'dispatch;
	}
	pc = 0x822B0380; continue 'dispatch;
            }
            0x822B0380 => {
    //   block [0x822B0380..0x822B03A0)
	// 822B0380: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B0384: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B0388: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B038C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0390: 2F07001A  cmpwi cr6, r7, 0x1a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 26, &mut ctx.xer);
	// 822B0394: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B0398: 41980008  blt cr6, 0x822b03a0
	if ctx.cr[6].lt {
	pc = 0x822B03A0; continue 'dispatch;
	}
	// 822B039C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822B03A0; continue 'dispatch;
            }
            0x822B03A0 => {
    //   block [0x822B03A0..0x822B03BC)
	// 822B03A0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B03A4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B03A8: 419A0014  beq cr6, 0x822b03bc
	if ctx.cr[6].eq {
	pc = 0x822B03BC; continue 'dispatch;
	}
	// 822B03AC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B03B0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B03B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B03B8: 4800000C  b 0x822b03c4
	pc = 0x822B03C4; continue 'dispatch;
            }
            0x822B03BC => {
    //   block [0x822B03BC..0x822B03C4)
	// 822B03BC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B03C0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B03C4; continue 'dispatch;
            }
            0x822B03C4 => {
    //   block [0x822B03C4..0x822B03D0)
	// 822B03C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B03C8: 4199FFB8  bgt cr6, 0x822b0380
	if ctx.cr[6].gt {
	pc = 0x822B0380; continue 'dispatch;
	}
	// 822B03CC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B03D0; continue 'dispatch;
            }
            0x822B03D0 => {
    //   block [0x822B03D0..0x822B03EC)
	// 822B03D0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B03D4: 419A0040  beq cr6, 0x822b0414
	if ctx.cr[6].eq {
	pc = 0x822B0414; continue 'dispatch;
	}
	// 822B03D8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B03DC: 2F0B001A  cmpwi cr6, r11, 0x1a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 26, &mut ctx.xer);
	// 822B03E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B03E4: 41990008  bgt cr6, 0x822b03ec
	if ctx.cr[6].gt {
	pc = 0x822B03EC; continue 'dispatch;
	}
	// 822B03E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822B03EC; continue 'dispatch;
            }
            0x822B03EC => {
    //   block [0x822B03EC..0x822B0414)
	// 822B03EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B03F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B03F4: 409A0020  bne cr6, 0x822b0414
	if !ctx.cr[6].eq {
	pc = 0x822B0414; continue 'dispatch;
	}
	// 822B03F8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B03FC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822B0400: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B0404: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0408: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B040C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B0410: 4800001C  b 0x822b042c
	pc = 0x822B042C; continue 'dispatch;
            }
            0x822B0414 => {
    //   block [0x822B0414..0x822B0428)
	// 822B0414: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B0418: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B041C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B0420: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B0424: 48000008  b 0x822b042c
	pc = 0x822B042C; continue 'dispatch;
            }
            0x822B0428 => {
    //   block [0x822B0428..0x822B042C)
	// 822B0428: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822B042C; continue 'dispatch;
            }
            0x822B042C => {
    //   block [0x822B042C..0x822B0450)
	// 822B042C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B0430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0434: 419A0034  beq cr6, 0x822b0468
	if ctx.cr[6].eq {
	pc = 0x822B0468; continue 'dispatch;
	}
	// 822B0438: 816A009C  lwz r11, 0x9c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 822B043C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 822B0440: 419A0010  beq cr6, 0x822b0450
	if ctx.cr[6].eq {
	pc = 0x822B0450; continue 'dispatch;
	}
	// 822B0444: 2F0B0019  cmpwi cr6, r11, 0x19
	ctx.cr[6].compare_i32(ctx.r[11].s32, 25, &mut ctx.xer);
	// 822B0448: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822B044C: 409A0008  bne cr6, 0x822b0454
	if !ctx.cr[6].eq {
	pc = 0x822B0454; continue 'dispatch;
	}
	pc = 0x822B0450; continue 'dispatch;
            }
            0x822B0450 => {
    //   block [0x822B0450..0x822B0454)
	// 822B0450: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x822B0454; continue 'dispatch;
            }
            0x822B0454 => {
    //   block [0x822B0454..0x822B0468)
	// 822B0454: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B0458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B045C: 409A000C  bne cr6, 0x822b0468
	if !ctx.cr[6].eq {
	pc = 0x822B0468; continue 'dispatch;
	}
	// 822B0460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B0464: 4800118D  bl 0x822b15f0
	ctx.lr = 0x822B0468;
	sub_822B15F0(ctx, base);
	pc = 0x822B0468; continue 'dispatch;
            }
            0x822B0468 => {
    //   block [0x822B0468..0x822B047C)
	// 822B0468: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B046C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B0470: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B0474: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B0478: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B0480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B0480 size=408
    let mut pc: u32 = 0x822B0480;
    'dispatch: loop {
        match pc {
            0x822B0480 => {
    //   block [0x822B0480..0x822B04C8)
	// 822B0480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B0484: 489F8F89  bl 0x82ca940c
	ctx.lr = 0x822B0488;
	sub_82CA93D0(ctx, base);
	// 822B0488: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 822B048C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822B0490: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B0494: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 822B0498: 8163006C  lwz r11, 0x6c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 822B049C: 3BE30068  addi r31, r3, 0x68
	ctx.r[31].s64 = ctx.r[3].s64 + 104;
	// 822B04A0: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 822B04A4: 83C89650  lwz r30, -0x69b0(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822B04A8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 822B04AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B04B0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 822B04B4: 38E89490  addi r7, r8, -0x6b70
	ctx.r[7].s64 = ctx.r[8].s64 + -27504;
	// 822B04B8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 822B04BC: 3BAB0E68  addi r29, r11, 0xe68
	ctx.r[29].s64 = ctx.r[11].s64 + 3688;
	// 822B04C0: C3C89490  lfs f30, -0x6b70(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822B04C4: C3E7FFF4  lfs f31, -0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x822B04C8; continue 'dispatch;
            }
            0x822B04C8 => {
    //   block [0x822B04C8..0x822B04CC)
	// 822B04C8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B04CC; continue 'dispatch;
            }
            0x822B04CC => {
    //   block [0x822B04CC..0x822B04E0)
	// 822B04CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B04D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B04D4: 419A000C  beq cr6, 0x822b04e0
	if ctx.cr[6].eq {
	pc = 0x822B04E0; continue 'dispatch;
	}
	// 822B04D8: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822B04DC: 419A0008  beq cr6, 0x822b04e4
	if ctx.cr[6].eq {
	pc = 0x822B04E4; continue 'dispatch;
	}
	pc = 0x822B04E0; continue 'dispatch;
            }
            0x822B04E0 => {
    //   block [0x822B04E0..0x822B04E4)
	// 822B04E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B04E4; continue 'dispatch;
            }
            0x822B04E4 => {
    //   block [0x822B04E4..0x822B04F8)
	// 822B04E4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B04E8: 419A0120  beq cr6, 0x822b0608
	if ctx.cr[6].eq {
	pc = 0x822B0608; continue 'dispatch;
	}
	// 822B04EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B04F0: 409A0008  bne cr6, 0x822b04f8
	if !ctx.cr[6].eq {
	pc = 0x822B04F8; continue 'dispatch;
	}
	// 822B04F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B04F8; continue 'dispatch;
            }
            0x822B04F8 => {
    //   block [0x822B04F8..0x822B0508)
	// 822B04F8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B04FC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822B0500: 409A0008  bne cr6, 0x822b0508
	if !ctx.cr[6].eq {
	pc = 0x822B0508; continue 'dispatch;
	}
	// 822B0504: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B0508; continue 'dispatch;
            }
            0x822B0508 => {
    //   block [0x822B0508..0x822B051C)
	// 822B0508: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B050C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822B0510: 409A000C  bne cr6, 0x822b051c
	if !ctx.cr[6].eq {
	pc = 0x822B051C; continue 'dispatch;
	}
	// 822B0514: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 822B0518: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B051C; continue 'dispatch;
            }
            0x822B051C => {
    //   block [0x822B051C..0x822B0558)
	// 822B051C: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B0520: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B0524: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B0528: 7CE8F050  subf r7, r8, r30
	ctx.r[7].s64 = ctx.r[30].s64 - ctx.r[8].s64;
	// 822B052C: 7CE607B4  extsw r6, r7
	ctx.r[6].s64 = ctx.r[7].s32 as i64;
	// 822B0530: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 822B0534: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822B0538: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 822B053C: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 822B0540: ED2A683C  fnmsubs f9, f10, f0, f13
	ctx.f[9].f64 = -(((ctx.f[10].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822B0544: D12B0004  stfs f9, 4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822B0548: 80A90004  lwz r5, 4(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B054C: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 822B0550: 409A0008  bne cr6, 0x822b0558
	if !ctx.cr[6].eq {
	pc = 0x822B0558; continue 'dispatch;
	}
	// 822B0554: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B0558; continue 'dispatch;
            }
            0x822B0558 => {
    //   block [0x822B0558..0x822B05AC)
	// 822B0558: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B055C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822B0560: 7D000026  mfcr r8
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[8].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B0564: 5507DF7A  rlwinm r7, r8, 0x1b, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 822B0568: 5506F77A  rlwinm r6, r8, 0x1e, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 822B056C: 7CE53378  or r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 822B0570: 7DBD2C2E  lfsx f13, r29, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B0574: FD8DF82E  fsel f12, f13, f0, f31
	ctx.f[12].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[31].f64 };
	// 822B0578: ED6CF028  fsubs f11, f12, f30
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[30].f64) as f32) as f64);
	// 822B057C: FF0BF800  fcmpu cr6, f11, f31
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[31].f64);
	// 822B0580: 7C800026  mfcr r4
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[4].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B0584: 5483DF7A  rlwinm r3, r4, 0x1b, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 822B0588: 5488F77A  rlwinm r8, r4, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[4].u32 as u64 & 0x00000003u64;
	// 822B058C: 7C674378  or r7, r3, r8
	ctx.r[7].u64 = ctx.r[3].u64 | ctx.r[8].u64;
	// 822B0590: 7D5D3C2E  lfsx f10, r29, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822B0594: FD2A67AE  fsel f9, f10, f30, f12
	ctx.f[9].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[12].f64 };
	// 822B0598: D12B0004  stfs f9, 4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822B059C: 80C90004  lwz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B05A0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B05A4: 409A0008  bne cr6, 0x822b05ac
	if !ctx.cr[6].eq {
	pc = 0x822B05AC; continue 'dispatch;
	}
	// 822B05A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B05AC; continue 'dispatch;
            }
            0x822B05AC => {
    //   block [0x822B05AC..0x822B05C0)
	// 822B05AC: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 822B05B0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B05B4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B05B8: 409A0008  bne cr6, 0x822b05c0
	if !ctx.cr[6].eq {
	pc = 0x822B05C0; continue 'dispatch;
	}
	// 822B05BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B05C0; continue 'dispatch;
            }
            0x822B05C0 => {
    //   block [0x822B05C0..0x822B05F4)
	// 822B05C0: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B05C4: C0080004  lfs f0, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B05C8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822B05CC: 41990028  bgt cr6, 0x822b05f4
	if ctx.cr[6].gt {
	pc = 0x822B05F4; continue 'dispatch;
	}
	// 822B05D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822B05D4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B05D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822B05DC: 48597A2D  bl 0x82848008
	ctx.lr = 0x822B05E0;
	sub_82848008(ctx, base);
	// 822B05E0: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 822B05E4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822B05E8: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B05EC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822B05F0: 4BFFFEDC  b 0x822b04cc
	pc = 0x822B04CC; continue 'dispatch;
            }
            0x822B05F4 => {
    //   block [0x822B05F4..0x822B0600)
	// 822B05F4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B05F8: 409A0008  bne cr6, 0x822b0600
	if !ctx.cr[6].eq {
	pc = 0x822B0600; continue 'dispatch;
	}
	// 822B05FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B0600; continue 'dispatch;
            }
            0x822B0600 => {
    //   block [0x822B0600..0x822B0608)
	// 822B0600: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0604: 4BFFFEC4  b 0x822b04c8
	pc = 0x822B04C8; continue 'dispatch;
            }
            0x822B0608 => {
    //   block [0x822B0608..0x822B0618)
	// 822B0608: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822B060C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822B0610: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 822B0614: 489F8E48  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B0618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B0618 size=2852
    let mut pc: u32 = 0x822B0618;
    'dispatch: loop {
        match pc {
            0x822B0618 => {
    //   block [0x822B0618..0x822B0674)
	// 822B0618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B061C: 489F8DD1  bl 0x82ca93ec
	ctx.lr = 0x822B0620;
	sub_82CA93D0(ctx, base);
	// 822B0620: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 822B0624: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B0628: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 822B062C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822B0630: 7FF6FB78  mr r22, r31
	ctx.r[22].u64 = ctx.r[31].u64;
	// 822B0634: 80B50004  lwz r5, 4(r21)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0638: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 822B063C: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 822B0640: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B0644: 419A00F4  beq cr6, 0x822b0738
	if ctx.cr[6].eq {
	pc = 0x822B0738; continue 'dispatch;
	}
	// 822B0648: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B064C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0650: 419A0024  beq cr6, 0x822b0674
	if ctx.cr[6].eq {
	pc = 0x822B0674; continue 'dispatch;
	}
	// 822B0654: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 822B0658: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B065C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B0660: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B0664: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0668: 7D765B78  mr r22, r11
	ctx.r[22].u64 = ctx.r[11].u64;
	// 822B066C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B0670: 480000CC  b 0x822b073c
	pc = 0x822B073C; continue 'dispatch;
            }
            0x822B0674 => {
    //   block [0x822B0674..0x822B0690)
	// 822B0674: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B0678: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B067C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 822B0680: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B0684: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822B0688: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B068C: 40810054  ble 0x822b06e0
	if !ctx.cr[0].gt {
	pc = 0x822B06E0; continue 'dispatch;
	}
	pc = 0x822B0690; continue 'dispatch;
            }
            0x822B0690 => {
    //   block [0x822B0690..0x822B06B0)
	// 822B0690: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B0694: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B0698: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822B069C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B06A0: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 822B06A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B06A8: 41980008  blt cr6, 0x822b06b0
	if ctx.cr[6].lt {
	pc = 0x822B06B0; continue 'dispatch;
	}
	// 822B06AC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x822B06B0; continue 'dispatch;
            }
            0x822B06B0 => {
    //   block [0x822B06B0..0x822B06CC)
	// 822B06B0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B06B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B06B8: 419A0014  beq cr6, 0x822b06cc
	if ctx.cr[6].eq {
	pc = 0x822B06CC; continue 'dispatch;
	}
	// 822B06BC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B06C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B06C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B06C8: 4800000C  b 0x822b06d4
	pc = 0x822B06D4; continue 'dispatch;
            }
            0x822B06CC => {
    //   block [0x822B06CC..0x822B06D4)
	// 822B06CC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B06D0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B06D4; continue 'dispatch;
            }
            0x822B06D4 => {
    //   block [0x822B06D4..0x822B06E0)
	// 822B06D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B06D8: 4199FFB8  bgt cr6, 0x822b0690
	if ctx.cr[6].gt {
	pc = 0x822B0690; continue 'dispatch;
	}
	// 822B06DC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x822B06E0; continue 'dispatch;
            }
            0x822B06E0 => {
    //   block [0x822B06E0..0x822B06FC)
	// 822B06E0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B06E4: 419A0040  beq cr6, 0x822b0724
	if ctx.cr[6].eq {
	pc = 0x822B0724; continue 'dispatch;
	}
	// 822B06E8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B06EC: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 822B06F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B06F4: 41990008  bgt cr6, 0x822b06fc
	if ctx.cr[6].gt {
	pc = 0x822B06FC; continue 'dispatch;
	}
	// 822B06F8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B06FC; continue 'dispatch;
            }
            0x822B06FC => {
    //   block [0x822B06FC..0x822B0724)
	// 822B06FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B0700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0704: 409A0020  bne cr6, 0x822b0724
	if !ctx.cr[6].eq {
	pc = 0x822B0724; continue 'dispatch;
	}
	// 822B0708: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822B070C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822B0710: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822B0714: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0718: 7D765B78  mr r22, r11
	ctx.r[22].u64 = ctx.r[11].u64;
	// 822B071C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B0720: 4800001C  b 0x822b073c
	pc = 0x822B073C; continue 'dispatch;
            }
            0x822B0724 => {
    //   block [0x822B0724..0x822B0738)
	// 822B0724: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B0728: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B072C: 7D765B78  mr r22, r11
	ctx.r[22].u64 = ctx.r[11].u64;
	// 822B0730: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B0734: 48000008  b 0x822b073c
	pc = 0x822B073C; continue 'dispatch;
            }
            0x822B0738 => {
    //   block [0x822B0738..0x822B073C)
	// 822B0738: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B073C; continue 'dispatch;
            }
            0x822B073C => {
    //   block [0x822B073C..0x822B0788)
	// 822B073C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B0740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0744: 419A09EC  beq cr6, 0x822b1130
	if ctx.cr[6].eq {
	pc = 0x822B1130; continue 'dispatch;
	}
	// 822B0748: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 822B074C: 7FF7FB78  mr r23, r31
	ctx.r[23].u64 = ctx.r[31].u64;
	// 822B0750: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 822B0754: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B0758: 419A00F4  beq cr6, 0x822b084c
	if ctx.cr[6].eq {
	pc = 0x822B084C; continue 'dispatch;
	}
	// 822B075C: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B0760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0764: 419A0024  beq cr6, 0x822b0788
	if ctx.cr[6].eq {
	pc = 0x822B0788; continue 'dispatch;
	}
	// 822B0768: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 822B076C: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B0770: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B0774: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B0778: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B077C: 7D775B78  mr r23, r11
	ctx.r[23].u64 = ctx.r[11].u64;
	// 822B0780: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B0784: 480000CC  b 0x822b0850
	pc = 0x822B0850; continue 'dispatch;
            }
            0x822B0788 => {
    //   block [0x822B0788..0x822B07A4)
	// 822B0788: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B078C: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B0790: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 822B0794: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B0798: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822B079C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B07A0: 40810054  ble 0x822b07f4
	if !ctx.cr[0].gt {
	pc = 0x822B07F4; continue 'dispatch;
	}
	pc = 0x822B07A4; continue 'dispatch;
            }
            0x822B07A4 => {
    //   block [0x822B07A4..0x822B07C4)
	// 822B07A4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B07A8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B07AC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822B07B0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B07B4: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 822B07B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B07BC: 41980008  blt cr6, 0x822b07c4
	if ctx.cr[6].lt {
	pc = 0x822B07C4; continue 'dispatch;
	}
	// 822B07C0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x822B07C4; continue 'dispatch;
            }
            0x822B07C4 => {
    //   block [0x822B07C4..0x822B07E0)
	// 822B07C4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B07C8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B07CC: 419A0014  beq cr6, 0x822b07e0
	if ctx.cr[6].eq {
	pc = 0x822B07E0; continue 'dispatch;
	}
	// 822B07D0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B07D4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B07D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B07DC: 4800000C  b 0x822b07e8
	pc = 0x822B07E8; continue 'dispatch;
            }
            0x822B07E0 => {
    //   block [0x822B07E0..0x822B07E8)
	// 822B07E0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B07E4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B07E8; continue 'dispatch;
            }
            0x822B07E8 => {
    //   block [0x822B07E8..0x822B07F4)
	// 822B07E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B07EC: 4199FFB8  bgt cr6, 0x822b07a4
	if ctx.cr[6].gt {
	pc = 0x822B07A4; continue 'dispatch;
	}
	// 822B07F0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x822B07F4; continue 'dispatch;
            }
            0x822B07F4 => {
    //   block [0x822B07F4..0x822B0810)
	// 822B07F4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B07F8: 419A0040  beq cr6, 0x822b0838
	if ctx.cr[6].eq {
	pc = 0x822B0838; continue 'dispatch;
	}
	// 822B07FC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0800: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 822B0804: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B0808: 41990008  bgt cr6, 0x822b0810
	if ctx.cr[6].gt {
	pc = 0x822B0810; continue 'dispatch;
	}
	// 822B080C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B0810; continue 'dispatch;
            }
            0x822B0810 => {
    //   block [0x822B0810..0x822B0838)
	// 822B0810: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B0814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0818: 409A0020  bne cr6, 0x822b0838
	if !ctx.cr[6].eq {
	pc = 0x822B0838; continue 'dispatch;
	}
	// 822B081C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822B0820: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822B0824: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822B0828: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B082C: 7D775B78  mr r23, r11
	ctx.r[23].u64 = ctx.r[11].u64;
	// 822B0830: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B0834: 4800001C  b 0x822b0850
	pc = 0x822B0850; continue 'dispatch;
            }
            0x822B0838 => {
    //   block [0x822B0838..0x822B084C)
	// 822B0838: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B083C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0840: 7D775B78  mr r23, r11
	ctx.r[23].u64 = ctx.r[11].u64;
	// 822B0844: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B0848: 48000008  b 0x822b0850
	pc = 0x822B0850; continue 'dispatch;
            }
            0x822B084C => {
    //   block [0x822B084C..0x822B0850)
	// 822B084C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B0850; continue 'dispatch;
            }
            0x822B0850 => {
    //   block [0x822B0850..0x822B0898)
	// 822B0850: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B0854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0858: 419A08D8  beq cr6, 0x822b1130
	if ctx.cr[6].eq {
	pc = 0x822B1130; continue 'dispatch;
	}
	// 822B085C: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 822B0860: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822B0864: 5549D7FE  rlwinm r9, r10, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 822B0868: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B086C: 419A00E8  beq cr6, 0x822b0954
	if ctx.cr[6].eq {
	pc = 0x822B0954; continue 'dispatch;
	}
	// 822B0870: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B0874: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0878: 419A0020  beq cr6, 0x822b0898
	if ctx.cr[6].eq {
	pc = 0x822B0898; continue 'dispatch;
	}
	// 822B087C: 894B0006  lbz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 822B0880: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B0884: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B0888: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B088C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B0890: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0894: 480000C4  b 0x822b0958
	pc = 0x822B0958; continue 'dispatch;
            }
            0x822B0898 => {
    //   block [0x822B0898..0x822B08B4)
	// 822B0898: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B089C: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B08A0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 822B08A4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B08A8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822B08AC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B08B0: 40810054  ble 0x822b0904
	if !ctx.cr[0].gt {
	pc = 0x822B0904; continue 'dispatch;
	}
	pc = 0x822B08B4; continue 'dispatch;
            }
            0x822B08B4 => {
    //   block [0x822B08B4..0x822B08D4)
	// 822B08B4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B08B8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B08BC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B08C0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B08C4: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 822B08C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B08CC: 41980008  blt cr6, 0x822b08d4
	if ctx.cr[6].lt {
	pc = 0x822B08D4; continue 'dispatch;
	}
	// 822B08D0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x822B08D4; continue 'dispatch;
            }
            0x822B08D4 => {
    //   block [0x822B08D4..0x822B08F0)
	// 822B08D4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B08D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B08DC: 419A0014  beq cr6, 0x822b08f0
	if ctx.cr[6].eq {
	pc = 0x822B08F0; continue 'dispatch;
	}
	// 822B08E0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B08E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B08E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B08EC: 4800000C  b 0x822b08f8
	pc = 0x822B08F8; continue 'dispatch;
            }
            0x822B08F0 => {
    //   block [0x822B08F0..0x822B08F8)
	// 822B08F0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B08F4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B08F8; continue 'dispatch;
            }
            0x822B08F8 => {
    //   block [0x822B08F8..0x822B0904)
	// 822B08F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B08FC: 4199FFB8  bgt cr6, 0x822b08b4
	if ctx.cr[6].gt {
	pc = 0x822B08B4; continue 'dispatch;
	}
	// 822B0900: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x822B0904; continue 'dispatch;
            }
            0x822B0904 => {
    //   block [0x822B0904..0x822B0920)
	// 822B0904: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B0908: 419A003C  beq cr6, 0x822b0944
	if ctx.cr[6].eq {
	pc = 0x822B0944; continue 'dispatch;
	}
	// 822B090C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0910: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 822B0914: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B0918: 41990008  bgt cr6, 0x822b0920
	if ctx.cr[6].gt {
	pc = 0x822B0920; continue 'dispatch;
	}
	// 822B091C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B0920; continue 'dispatch;
            }
            0x822B0920 => {
    //   block [0x822B0920..0x822B0944)
	// 822B0920: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B0924: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0928: 409A001C  bne cr6, 0x822b0944
	if !ctx.cr[6].eq {
	pc = 0x822B0944; continue 'dispatch;
	}
	// 822B092C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822B0930: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B0934: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822B0938: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822B093C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0940: 48000018  b 0x822b0958
	pc = 0x822B0958; continue 'dispatch;
            }
            0x822B0944 => {
    //   block [0x822B0944..0x822B0954)
	// 822B0944: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B0948: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B094C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0950: 48000008  b 0x822b0958
	pc = 0x822B0958; continue 'dispatch;
            }
            0x822B0954 => {
    //   block [0x822B0954..0x822B0958)
	// 822B0954: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x822B0958; continue 'dispatch;
            }
            0x822B0958 => {
    //   block [0x822B0958..0x822B09C0)
	// 822B0958: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822B095C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B0960: 419A07D0  beq cr6, 0x822b1130
	if ctx.cr[6].eq {
	pc = 0x822B1130; continue 'dispatch;
	}
	// 822B0964: 8955003C  lbz r10, 0x3c(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(60 as u32) ) } as u64;
	// 822B0968: 830B0094  lwz r24, 0x94(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 822B096C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B0970: 419A0150  beq cr6, 0x822b0ac0
	if ctx.cr[6].eq {
	pc = 0x822B0AC0; continue 'dispatch;
	}
	// 822B0974: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B0978: C1B500B8  lfs f13, 0xb8(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B097C: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 822B0980: C00BFE3C  lfs f0, -0x1c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B0984: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822B0988: C1ABFE48  lfs f13, -0x1b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-440 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B098C: D01500B8  stfs f0, 0xb8(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822B0990: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822B0994: 419900F0  bgt cr6, 0x822b0a84
	if ctx.cr[6].gt {
	pc = 0x822B0A84; continue 'dispatch;
	}
	// 822B0998: 809500B0  lwz r4, 0xb0(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(176 as u32) ) } as u64;
	// 822B099C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822B09A0: 419A0790  beq cr6, 0x822b1130
	if ctx.cr[6].eq {
	pc = 0x822B1130; continue 'dispatch;
	}
	// 822B09A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822B09A8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 822B09AC: 482B299D  bl 0x82563348
	ctx.lr = 0x822B09B0;
	sub_82563348(ctx, base);
	// 822B09B0: 807500B0  lwz r3, 0xb0(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(176 as u32) ) } as u64;
	// 822B09B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B09B8: 419A0040  beq cr6, 0x822b09f8
	if ctx.cr[6].eq {
	pc = 0x822B09F8; continue 'dispatch;
	}
	// 822B09BC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x822B09C0; continue 'dispatch;
            }
            0x822B09C0 => {
    //   block [0x822B09C0..0x822B09F4)
	// 822B09C0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 822B09C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B09C8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 822B09CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B09D0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822B09D4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B09D8: 4082FFE8  bne 0x822b09c0
	if !ctx.cr[0].eq {
	pc = 0x822B09C0; continue 'dispatch;
	}
	// 822B09DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B09E0: 409A0014  bne cr6, 0x822b09f4
	if !ctx.cr[6].eq {
	pc = 0x822B09F4; continue 'dispatch;
	}
	// 822B09E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B09E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B09EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B09F0: 4E800421  bctrl
	ctx.lr = 0x822B09F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822B09F4 => {
    //   block [0x822B09F4..0x822B09F8)
	// 822B09F4: 93F500B0  stw r31, 0xb0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	pc = 0x822B09F8; continue 'dispatch;
            }
            0x822B09F8 => {
    //   block [0x822B09F8..0x822B0A04)
	// 822B09F8: 3BD50080  addi r30, r21, 0x80
	ctx.r[30].s64 = ctx.r[21].s64 + 128;
	// 822B09FC: 93F500B0  stw r31, 0xb0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 822B0A00: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	pc = 0x822B0A04; continue 'dispatch;
            }
            0x822B0A04 => {
    //   block [0x822B0A04..0x822B0A84)
	// 822B0A04: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0A08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0A0C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B0A10: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B0A14: 4E800421  bctrl
	ctx.lr = 0x822B0A18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B0A18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B0A1C: 4BF070FD  bl 0x821b7b18
	ctx.lr = 0x822B0A20;
	sub_821B7B18(ctx, base);
	// 822B0A20: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822B0A24: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822B0A28: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 822B0A2C: 4082FFD8  bne 0x822b0a04
	if !ctx.cr[0].eq {
	pc = 0x822B0A04; continue 'dispatch;
	}
	// 822B0A30: 807500A0  lwz r3, 0xa0(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(160 as u32) ) } as u64;
	// 822B0A34: 3BD500A0  addi r30, r21, 0xa0
	ctx.r[30].s64 = ctx.r[21].s64 + 160;
	// 822B0A38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0A3C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B0A40: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B0A44: 4E800421  bctrl
	ctx.lr = 0x822B0A48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B0A48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B0A4C: 4BF070CD  bl 0x821b7b18
	ctx.lr = 0x822B0A50;
	sub_821B7B18(ctx, base);
	// 822B0A50: 93F500A0  stw r31, 0xa0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 822B0A54: 807500A8  lwz r3, 0xa8(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(168 as u32) ) } as u64;
	// 822B0A58: 3BB500A8  addi r29, r21, 0xa8
	ctx.r[29].s64 = ctx.r[21].s64 + 168;
	// 822B0A5C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0A60: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B0A64: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 822B0A68: 4E800421  bctrl
	ctx.lr = 0x822B0A6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B0A6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B0A70: 4BF070A9  bl 0x821b7b18
	ctx.lr = 0x822B0A74;
	sub_821B7B18(ctx, base);
	// 822B0A74: 93F500A8  stw r31, 0xa8(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 822B0A78: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 822B0A7C: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 822B0A80: 489F89BC  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B0A84 => {
    //   block [0x822B0A84..0x822B0AC0)
	// 822B0A84: 807500A8  lwz r3, 0xa8(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(168 as u32) ) } as u64;
	// 822B0A88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B0A8C: 419A06A4  beq cr6, 0x822b1130
	if ctx.cr[6].eq {
	pc = 0x822B1130; continue 'dispatch;
	}
	// 822B0A90: C18B2314  lfs f12, 0x2314(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8980 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B0A94: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0A98: C1AB1FF0  lfs f13, 0x1ff0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B0A9C: EDA0637C  fnmsubs f13, f0, f13, f12
	ctx.f[13].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 822B0AA0: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B0AA4: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822B0AA8: EC2C0032  fmuls f1, f12, f0
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 822B0AAC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822B0AB0: 4E800421  bctrl
	ctx.lr = 0x822B0AB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B0AB4: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 822B0AB8: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 822B0ABC: 489F8980  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B0AC0 => {
    //   block [0x822B0AC0..0x822B0B0C)
	// 822B0AC0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822B0AC4: 81250030  lwz r9, 0x30(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(48 as u32) ) } as u64;
	// 822B0AC8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822B0ACC: 3B2A9490  addi r25, r10, -0x6b70
	ctx.r[25].s64 = ctx.r[10].s64 + -27504;
	// 822B0AD0: 5528E7FE  rlwinm r8, r9, 0x1c, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000000Fu64;
	// 822B0AD4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822B0AD8: C3F9FFF4  lfs f31, -0xc(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822B0ADC: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 822B0AE0: 419A00E8  beq cr6, 0x822b0bc8
	if ctx.cr[6].eq {
	pc = 0x822B0BC8; continue 'dispatch;
	}
	// 822B0AE4: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B0AE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0AEC: 419A0020  beq cr6, 0x822b0b0c
	if ctx.cr[6].eq {
	pc = 0x822B0B0C; continue 'dispatch;
	}
	// 822B0AF0: 894B0064  lbz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 822B0AF4: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B0AF8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B0AFC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B0B00: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B0B04: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0B08: 480000C4  b 0x822b0bcc
	pc = 0x822B0BCC; continue 'dispatch;
            }
            0x822B0B0C => {
    //   block [0x822B0B0C..0x822B0B28)
	// 822B0B0C: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B0B10: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B0B14: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 822B0B18: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B0B1C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822B0B20: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B0B24: 40810054  ble 0x822b0b78
	if !ctx.cr[0].gt {
	pc = 0x822B0B78; continue 'dispatch;
	}
	pc = 0x822B0B28; continue 'dispatch;
            }
            0x822B0B28 => {
    //   block [0x822B0B28..0x822B0B48)
	// 822B0B28: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B0B2C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B0B30: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B0B34: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0B38: 2F070064  cmpwi cr6, r7, 0x64
	ctx.cr[6].compare_i32(ctx.r[7].s32, 100, &mut ctx.xer);
	// 822B0B3C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B0B40: 41980008  blt cr6, 0x822b0b48
	if ctx.cr[6].lt {
	pc = 0x822B0B48; continue 'dispatch;
	}
	// 822B0B44: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x822B0B48; continue 'dispatch;
            }
            0x822B0B48 => {
    //   block [0x822B0B48..0x822B0B64)
	// 822B0B48: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B0B4C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B0B50: 419A0014  beq cr6, 0x822b0b64
	if ctx.cr[6].eq {
	pc = 0x822B0B64; continue 'dispatch;
	}
	// 822B0B54: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B0B58: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B0B5C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B0B60: 4800000C  b 0x822b0b6c
	pc = 0x822B0B6C; continue 'dispatch;
            }
            0x822B0B64 => {
    //   block [0x822B0B64..0x822B0B6C)
	// 822B0B64: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B0B68: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B0B6C; continue 'dispatch;
            }
            0x822B0B6C => {
    //   block [0x822B0B6C..0x822B0B78)
	// 822B0B6C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B0B70: 4199FFB8  bgt cr6, 0x822b0b28
	if ctx.cr[6].gt {
	pc = 0x822B0B28; continue 'dispatch;
	}
	// 822B0B74: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x822B0B78; continue 'dispatch;
            }
            0x822B0B78 => {
    //   block [0x822B0B78..0x822B0B94)
	// 822B0B78: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B0B7C: 419A003C  beq cr6, 0x822b0bb8
	if ctx.cr[6].eq {
	pc = 0x822B0BB8; continue 'dispatch;
	}
	// 822B0B80: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0B84: 2F0B0064  cmpwi cr6, r11, 0x64
	ctx.cr[6].compare_i32(ctx.r[11].s32, 100, &mut ctx.xer);
	// 822B0B88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B0B8C: 41990008  bgt cr6, 0x822b0b94
	if ctx.cr[6].gt {
	pc = 0x822B0B94; continue 'dispatch;
	}
	// 822B0B90: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B0B94; continue 'dispatch;
            }
            0x822B0B94 => {
    //   block [0x822B0B94..0x822B0BB8)
	// 822B0B94: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B0B98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0B9C: 409A001C  bne cr6, 0x822b0bb8
	if !ctx.cr[6].eq {
	pc = 0x822B0BB8; continue 'dispatch;
	}
	// 822B0BA0: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822B0BA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B0BA8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822B0BAC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822B0BB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0BB4: 48000018  b 0x822b0bcc
	pc = 0x822B0BCC; continue 'dispatch;
            }
            0x822B0BB8 => {
    //   block [0x822B0BB8..0x822B0BC8)
	// 822B0BB8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B0BBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B0BC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0BC4: 48000008  b 0x822b0bcc
	pc = 0x822B0BCC; continue 'dispatch;
            }
            0x822B0BC8 => {
    //   block [0x822B0BC8..0x822B0BCC)
	// 822B0BC8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x822B0BCC; continue 'dispatch;
            }
            0x822B0BCC => {
    //   block [0x822B0BCC..0x822B0BF0)
	// 822B0BCC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822B0BD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B0BD4: 419A005C  beq cr6, 0x822b0c30
	if ctx.cr[6].eq {
	pc = 0x822B0C30; continue 'dispatch;
	}
	// 822B0BD8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B0BDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B0BE0: 409A0010  bne cr6, 0x822b0bf0
	if !ctx.cr[6].eq {
	pc = 0x822B0BF0; continue 'dispatch;
	}
	// 822B0BE4: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 822B0BE8: C00B16A8  lfs f0, 0x16a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5800 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B0BEC: 48000044  b 0x822b0c30
	pc = 0x822B0C30; continue 'dispatch;
            }
            0x822B0BF0 => {
    //   block [0x822B0BF0..0x822B0C2C)
	// 822B0BF0: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 822B0BF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B0BF8: 419A0034  beq cr6, 0x822b0c2c
	if ctx.cr[6].eq {
	pc = 0x822B0C2C; continue 'dispatch;
	}
	// 822B0BFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0C00: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0C04: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B0C08: 4E800421  bctrl
	ctx.lr = 0x822B0C0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B0C0C: 78690020  clrldi r9, r3, 0x20
	ctx.r[9].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 822B0C10: C019003C  lfs f0, 0x3c(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B0C14: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 822B0C18: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B0C1C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 822B0C20: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 822B0C24: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 822B0C28: 48000008  b 0x822b0c30
	pc = 0x822B0C30; continue 'dispatch;
            }
            0x822B0C2C => {
    //   block [0x822B0C2C..0x822B0C30)
	// 822B0C2C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x822B0C30; continue 'dispatch;
            }
            0x822B0C30 => {
    //   block [0x822B0C30..0x822B0C5C)
	// 822B0C30: C1B9FE14  lfs f13, -0x1ec(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-492 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B0C34: 3B550080  addi r26, r21, 0x80
	ctx.r[26].s64 = ctx.r[21].s64 + 128;
	// 822B0C38: C199FE44  lfs f12, -0x1bc(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-444 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B0C3C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 822B0C40: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 822B0C44: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 822B0C48: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 822B0C4C: 3BABFE2C  addi r29, r11, -0x1d4
	ctx.r[29].s64 = ctx.r[11].s64 + -468;
	// 822B0C50: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822B0C54: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 822B0C58: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x822B0C5C; continue 'dispatch;
            }
            0x822B0C5C => {
    //   block [0x822B0C5C..0x822B0CC8)
	// 822B0C5C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0C64: 409A0064  bne cr6, 0x822b0cc8
	if !ctx.cr[6].eq {
	pc = 0x822B0CC8; continue 'dispatch;
	}
	// 822B0C68: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822B0C6C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B0C70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B0C74: 4BF7C25D  bl 0x8222ced0
	ctx.lr = 0x822B0C78;
	sub_8222CED0(ctx, base);
	// 822B0C78: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822B0C7C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822B0C80: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822B0C84: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 822B0C88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B0C8C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822B0C90: 4BFD30A1  bl 0x82283d30
	ctx.lr = 0x822B0C94;
	sub_82283D30(ctx, base);
	// 822B0C94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B0C98: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822B0C9C: 4BFC23BD  bl 0x82273058
	ctx.lr = 0x822B0CA0;
	sub_82273058(ctx, base);
	// 822B0CA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B0CA4: 4BF64135  bl 0x82214dd8
	ctx.lr = 0x822B0CA8;
	sub_82214DD8(ctx, base);
	// 822B0CA8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0CAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B0CB0: 419A0480  beq cr6, 0x822b1130
	if ctx.cr[6].eq {
	pc = 0x822B1130; continue 'dispatch;
	}
	// 822B0CB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0CB8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822B0CBC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B0CC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B0CC4: 4E800421  bctrl
	ctx.lr = 0x822B0CC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822B0CC8 => {
    //   block [0x822B0CC8..0x822B0D20)
	// 822B0CC8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822B0CCC: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 822B0CD0: 2F1C0004  cmpwi cr6, r28, 4
	ctx.cr[6].compare_i32(ctx.r[28].s32, 4, &mut ctx.xer);
	// 822B0CD4: 4198FF88  blt cr6, 0x822b0c5c
	if ctx.cr[6].lt {
	pc = 0x822B0C5C; continue 'dispatch;
	}
	// 822B0CD8: 817500A0  lwz r11, 0xa0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(160 as u32) ) } as u64;
	// 822B0CDC: 3B9500A0  addi r28, r21, 0xa0
	ctx.r[28].s64 = ctx.r[21].s64 + 160;
	// 822B0CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0CE4: 409A0074  bne cr6, 0x822b0d58
	if !ctx.cr[6].eq {
	pc = 0x822B0D58; continue 'dispatch;
	}
	// 822B0CE8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822B0CEC: 4BF6E56D  bl 0x8221f258
	ctx.lr = 0x822B0CF0;
	sub_8221F258(ctx, base);
	// 822B0CF0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822B0CF4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822B0CF8: 419A0028  beq cr6, 0x822b0d20
	if ctx.cr[6].eq {
	pc = 0x822B0D20; continue 'dispatch;
	}
	// 822B0CFC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 822B0D00: 484AFDC1  bl 0x82760ac0
	ctx.lr = 0x822B0D04;
	sub_82760AC0(ctx, base);
	// 822B0D04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822B0D08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B0D0C: 394B13F0  addi r10, r11, 0x13f0
	ctx.r[10].s64 = ctx.r[11].s64 + 5104;
	// 822B0D10: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822B0D14: 4BFD3255  bl 0x82283f68
	ctx.lr = 0x822B0D18;
	sub_82283F68(ctx, base);
	// 822B0D18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822B0D1C: 48000008  b 0x822b0d24
	pc = 0x822B0D24; continue 'dispatch;
            }
            0x822B0D20 => {
    //   block [0x822B0D20..0x822B0D24)
	// 822B0D20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x822B0D24; continue 'dispatch;
            }
            0x822B0D24 => {
    //   block [0x822B0D24..0x822B0D40)
	// 822B0D24: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822B0D28: 4BFC2331  bl 0x82273058
	ctx.lr = 0x822B0D2C;
	sub_82273058(ctx, base);
	// 822B0D2C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0D30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0D34: 419A03FC  beq cr6, 0x822b1130
	if ctx.cr[6].eq {
	pc = 0x822B1130; continue 'dispatch;
	}
	// 822B0D38: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 822B0D3C: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	pc = 0x822B0D40; continue 'dispatch;
            }
            0x822B0D40 => {
    //   block [0x822B0D40..0x822B0D58)
	// 822B0D40: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0D44: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0D48: 484B17B1  bl 0x827624f8
	ctx.lr = 0x822B0D4C;
	sub_827624F8(ctx, base);
	// 822B0D4C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822B0D50: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 822B0D54: 4082FFEC  bne 0x822b0d40
	if !ctx.cr[0].eq {
	pc = 0x822B0D40; continue 'dispatch;
	}
	pc = 0x822B0D58; continue 'dispatch;
            }
            0x822B0D58 => {
    //   block [0x822B0D58..0x822B0DE8)
	// 822B0D58: 817500A8  lwz r11, 0xa8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(168 as u32) ) } as u64;
	// 822B0D5C: 3BB500A8  addi r29, r21, 0xa8
	ctx.r[29].s64 = ctx.r[21].s64 + 168;
	// 822B0D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0D64: 409A00D0  bne cr6, 0x822b0e34
	if !ctx.cr[6].eq {
	pc = 0x822B0E34; continue 'dispatch;
	}
	// 822B0D68: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822B0D6C: 93E10098  stw r31, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u32 ) };
	// 822B0D70: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 822B0D74: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822B0D78: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 822B0D7C: 38C00040  li r6, 0x40
	ctx.r[6].s64 = 64;
	// 822B0D80: 93E100A0  stw r31, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 822B0D84: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 822B0D88: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 822B0D8C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 822B0D90: 93E100AC  stw r31, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[31].u32 ) };
	// 822B0D94: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 822B0D98: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 822B0D9C: 93E100B4  stw r31, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[31].u32 ) };
	// 822B0DA0: 9BE100B9  stb r31, 0xb9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(185 as u32), ctx.r[31].u8 ) };
	// 822B0DA4: 93E100C0  stw r31, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[31].u32 ) };
	// 822B0DA8: 93E100C4  stw r31, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[31].u32 ) };
	// 822B0DAC: 93E100C8  stw r31, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[31].u32 ) };
	// 822B0DB0: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 822B0DB4: 93E100D4  stw r31, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[31].u32 ) };
	// 822B0DB8: 93E100D8  stw r31, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[31].u32 ) };
	// 822B0DBC: 485B90FD  bl 0x82869eb8
	ctx.lr = 0x822B0DC0;
	sub_82869EB8(ctx, base);
	// 822B0DC0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822B0DC4: 4BF6E495  bl 0x8221f258
	ctx.lr = 0x822B0DC8;
	sub_8221F258(ctx, base);
	// 822B0DC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B0DCC: 419A001C  beq cr6, 0x822b0de8
	if ctx.cr[6].eq {
	pc = 0x822B0DE8; continue 'dispatch;
	}
	// 822B0DD0: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 822B0DD4: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0DD8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 822B0DDC: 484B0FFD  bl 0x82761dd8
	ctx.lr = 0x822B0DE0;
	sub_82761DD8(ctx, base);
	// 822B0DE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822B0DE4: 48000008  b 0x822b0dec
	pc = 0x822B0DEC; continue 'dispatch;
            }
            0x822B0DE8 => {
    //   block [0x822B0DE8..0x822B0DEC)
	// 822B0DE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x822B0DEC; continue 'dispatch;
            }
            0x822B0DEC => {
    //   block [0x822B0DEC..0x822B0E14)
	// 822B0DEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B0DF0: 4BFC2269  bl 0x82273058
	ctx.lr = 0x822B0DF4;
	sub_82273058(ctx, base);
	// 822B0DF4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0DF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B0DFC: 409A0018  bne cr6, 0x822b0e14
	if !ctx.cr[6].eq {
	pc = 0x822B0E14; continue 'dispatch;
	}
	// 822B0E00: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822B0E04: 4855694D  bl 0x82807750
	ctx.lr = 0x822B0E08;
	sub_82807750(ctx, base);
	// 822B0E08: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 822B0E0C: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 822B0E10: 489F862C  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B0E14 => {
    //   block [0x822B0E14..0x822B0E2C)
	// 822B0E14: D3F500B8  stfs f31, 0xb8(r21)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822B0E18: 484AFB11  bl 0x82760928
	ctx.lr = 0x822B0E1C;
	sub_82760928(ctx, base);
	// 822B0E1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B0E20: 419A000C  beq cr6, 0x822b0e2c
	if ctx.cr[6].eq {
	pc = 0x822B0E2C; continue 'dispatch;
	}
	// 822B0E24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B0E28: 99630030  stb r11, 0x30(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	pc = 0x822B0E2C; continue 'dispatch;
            }
            0x822B0E2C => {
    //   block [0x822B0E2C..0x822B0E34)
	// 822B0E2C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822B0E30: 48556921  bl 0x82807750
	ctx.lr = 0x822B0E34;
	sub_82807750(ctx, base);
	pc = 0x822B0E34; continue 'dispatch;
            }
            0x822B0E34 => {
    //   block [0x822B0E34..0x822B0E88)
	// 822B0E34: 817500B0  lwz r11, 0xb0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(176 as u32) ) } as u64;
	// 822B0E38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0E3C: 409A0110  bne cr6, 0x822b0f4c
	if !ctx.cr[6].eq {
	pc = 0x822B0F4C; continue 'dispatch;
	}
	// 822B0E40: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822B0E44: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0E48: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822B0E4C: 390000FF  li r8, 0xff
	ctx.r[8].s64 = 255;
	// 822B0E50: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 822B0E54: 38C00080  li r6, 0x80
	ctx.r[6].s64 = 128;
	// 822B0E58: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 822B0E5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822B0E60: 482B2259  bl 0x825630b8
	ctx.lr = 0x822B0E64;
	sub_825630B8(ctx, base);
	// 822B0E64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822B0E68: 817500B0  lwz r11, 0xb0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(176 as u32) ) } as u64;
	// 822B0E6C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0E70: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822B0E74: 419A007C  beq cr6, 0x822b0ef0
	if ctx.cr[6].eq {
	pc = 0x822B0EF0; continue 'dispatch;
	}
	// 822B0E78: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 822B0E7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B0E80: 419A0040  beq cr6, 0x822b0ec0
	if ctx.cr[6].eq {
	pc = 0x822B0EC0; continue 'dispatch;
	}
	// 822B0E84: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x822B0E88; continue 'dispatch;
            }
            0x822B0E88 => {
    //   block [0x822B0E88..0x822B0EBC)
	// 822B0E88: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 822B0E8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B0E90: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 822B0E94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B0E98: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822B0E9C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B0EA0: 4082FFE8  bne 0x822b0e88
	if !ctx.cr[0].eq {
	pc = 0x822B0E88; continue 'dispatch;
	}
	// 822B0EA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B0EA8: 409A0014  bne cr6, 0x822b0ebc
	if !ctx.cr[6].eq {
	pc = 0x822B0EBC; continue 'dispatch;
	}
	// 822B0EAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0EB0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0EB4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B0EB8: 4E800421  bctrl
	ctx.lr = 0x822B0EBC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822B0EBC => {
    //   block [0x822B0EBC..0x822B0EC0)
	// 822B0EBC: 93F500B0  stw r31, 0xb0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	pc = 0x822B0EC0; continue 'dispatch;
            }
            0x822B0EC0 => {
    //   block [0x822B0EC0..0x822B0ED4)
	// 822B0EC0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0EC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0EC8: 917500B0  stw r11, 0xb0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 822B0ECC: 419A0024  beq cr6, 0x822b0ef0
	if ctx.cr[6].eq {
	pc = 0x822B0EF0; continue 'dispatch;
	}
	// 822B0ED0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x822B0ED4; continue 'dispatch;
            }
            0x822B0ED4 => {
    //   block [0x822B0ED4..0x822B0EF0)
	// 822B0ED4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822B0ED8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B0EDC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822B0EE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822B0EE4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822B0EE8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B0EEC: 4082FFE8  bne 0x822b0ed4
	if !ctx.cr[0].eq {
	pc = 0x822B0ED4; continue 'dispatch;
	}
	pc = 0x822B0EF0; continue 'dispatch;
            }
            0x822B0EF0 => {
    //   block [0x822B0EF0..0x822B0F04)
	// 822B0EF0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822B0EF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0EF8: 419A0048  beq cr6, 0x822b0f40
	if ctx.cr[6].eq {
	pc = 0x822B0F40; continue 'dispatch;
	}
	// 822B0EFC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822B0F00: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x822B0F04; continue 'dispatch;
            }
            0x822B0F04 => {
    //   block [0x822B0F04..0x822B0F3C)
	// 822B0F04: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822B0F08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B0F0C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822B0F10: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822B0F14: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822B0F18: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B0F1C: 4082FFE8  bne 0x822b0f04
	if !ctx.cr[0].eq {
	pc = 0x822B0F04; continue 'dispatch;
	}
	// 822B0F20: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 822B0F24: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B0F28: 409A0014  bne cr6, 0x822b0f3c
	if !ctx.cr[6].eq {
	pc = 0x822B0F3C; continue 'dispatch;
	}
	// 822B0F2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0F30: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B0F34: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B0F38: 4E800421  bctrl
	ctx.lr = 0x822B0F3C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822B0F3C => {
    //   block [0x822B0F3C..0x822B0F40)
	// 822B0F3C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	pc = 0x822B0F40; continue 'dispatch;
            }
            0x822B0F40 => {
    //   block [0x822B0F40..0x822B0F4C)
	// 822B0F40: 817500B0  lwz r11, 0xb0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(176 as u32) ) } as u64;
	// 822B0F44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B0F48: 419A01E8  beq cr6, 0x822b1130
	if ctx.cr[6].eq {
	pc = 0x822B1130; continue 'dispatch;
	}
	pc = 0x822B0F4C; continue 'dispatch;
            }
            0x822B0F4C => {
    //   block [0x822B0F4C..0x822B0F78)
	// 822B0F4C: 81750074  lwz r11, 0x74(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(116 as u32) ) } as u64;
	// 822B0F50: 395B0006  addi r10, r27, 6
	ctx.r[10].s64 = ctx.r[27].s64 + 6;
	// 822B0F54: 81350070  lwz r9, 0x70(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(112 as u32) ) } as u64;
	// 822B0F58: C1B500B8  lfs f13, 0xb8(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B0F5C: C019FE3C  lfs f0, -0x1c4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B0F60: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B0F64: 7D071670  srawi r7, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 822B0F68: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 822B0F6C: 4198000C  blt cr6, 0x822b0f78
	if ctx.cr[6].lt {
	pc = 0x822B0F78; continue 'dispatch;
	}
	// 822B0F70: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822B0F74: 48000008  b 0x822b0f7c
	pc = 0x822B0F7C; continue 'dispatch;
            }
            0x822B0F78 => {
    //   block [0x822B0F78..0x822B0F7C)
	// 822B0F78: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x822B0F7C; continue 'dispatch;
            }
            0x822B0F7C => {
    //   block [0x822B0F7C..0x822B102C)
	// 822B0F7C: FD606090  fmr f11, f12
	ctx.f[11].f64 = ctx.f[12].f64;
	// 822B0F80: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 822B0F84: C0190000  lfs f0, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B0F88: 38EB0E68  addi r7, r11, 0xe68
	ctx.r[7].s64 = ctx.r[11].s64 + 3688;
	// 822B0F8C: D19500B8  stfs f12, 0xb8(r21)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822B0F90: C1B91FF0  lfs f13, 0x1ff0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B0F94: C1992314  lfs f12, 0x2314(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8980 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B0F98: FF0BF800  fcmpu cr6, f11, f31
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[31].f64);
	// 822B0F9C: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B0FA0: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822B0FA4: 5548F77A  rlwinm r8, r10, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 822B0FA8: 7D264378  or r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 822B0FAC: 7D47342E  lfsx f10, r7, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822B0FB0: FD2AFAEE  fsel f9, f10, f11, f31
	ctx.f[9].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[31].f64 };
	// 822B0FB4: ED090028  fsubs f8, f9, f0
	ctx.f[8].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 822B0FB8: FF08F800  fcmpu cr6, f8, f31
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[31].f64);
	// 822B0FBC: 7CA00026  mfcr r5
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[5].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B0FC0: 54A3F77A  rlwinm r3, r5, 0x1e, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[5].u32 as u64 & 0x00000003u64;
	// 822B0FC4: 54A4DF7A  rlwinm r4, r5, 0x1b, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 822B0FC8: 7C8B1B78  or r11, r4, r3
	ctx.r[11].u64 = ctx.r[4].u64 | ctx.r[3].u64;
	// 822B0FCC: 7CE75C2E  lfsx f7, r7, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 822B0FD0: FCC7482E  fsel f6, f7, f0, f9
	ctx.f[6].f64 = if ctx.f[7].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[9].f64 };
	// 822B0FD4: D0D500B8  stfs f6, 0xb8(r21)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822B0FD8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0FDC: FCA03090  fmr f5, f6
	ctx.f[5].f64 = ctx.f[6].f64;
	// 822B0FE0: EC85637C  fnmsubs f4, f5, f13, f12
	ctx.f[4].f64 = -(((ctx.f[5].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 822B0FE4: EC640172  fmuls f3, f4, f5
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[5].f64) as f32) as f64);
	// 822B0FE8: EC230172  fmuls f1, f3, f5
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[5].f64) as f32) as f64);
	// 822B0FEC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B0FF0: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B0FF4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822B0FF8: 4E800421  bctrl
	ctx.lr = 0x822B0FFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B0FFC: 81150074  lwz r8, 0x74(r21)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(116 as u32) ) } as u64;
	// 822B1000: 80F50070  lwz r7, 0x70(r21)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(112 as u32) ) } as u64;
	// 822B1004: 39550068  addi r10, r21, 0x68
	ctx.r[10].s64 = ctx.r[21].s64 + 104;
	// 822B1008: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 822B100C: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 822B1010: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 822B1014: 54C5003A  rlwinm r5, r6, 0, 0, 0x1d
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 822B1018: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 822B101C: 409A0010  bne cr6, 0x822b102c
	if !ctx.cr[6].eq {
	pc = 0x822B102C; continue 'dispatch;
	}
	// 822B1020: 3C607F00  lis r3, 0x7f00
	ctx.r[3].s64 = 2130706432;
	// 822B1024: 60630149  ori r3, r3, 0x149
	ctx.r[3].u64 = ctx.r[3].u64 | 329;
	// 822B1028: 48000054  b 0x822b107c
	pc = 0x822B107C; continue 'dispatch;
            }
            0x822B102C => {
    //   block [0x822B102C..0x822B1040)
	// 822B102C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 822B1030: 40980010  bge cr6, 0x822b1040
	if !ctx.cr[6].lt {
	pc = 0x822B1040; continue 'dispatch;
	}
	// 822B1034: 3C607F00  lis r3, 0x7f00
	ctx.r[3].s64 = 2130706432;
	// 822B1038: 60630149  ori r3, r3, 0x149
	ctx.r[3].u64 = ctx.r[3].u64 | 329;
	// 822B103C: 48000040  b 0x822b107c
	pc = 0x822B107C; continue 'dispatch;
            }
            0x822B1040 => {
    //   block [0x822B1040..0x822B1070)
	// 822B1040: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B1044: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1048: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 822B104C: 7CC81670  srawi r8, r6, 2
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[6].s32 >> 2) as i64;
	// 822B1050: 38A8FFFF  addi r5, r8, -1
	ctx.r[5].s64 = ctx.r[8].s64 + -1;
	// 822B1054: 7F1B2840  cmplw cr6, r27, r5
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[5].u32, &mut ctx.xer);
	// 822B1058: 40990018  ble cr6, 0x822b1070
	if !ctx.cr[6].gt {
	pc = 0x822B1070; continue 'dispatch;
	}
	// 822B105C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B1060: 54E8003E  slwi r8, r7, 0
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B1064: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822B1068: 7CEB1670  srawi r11, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 822B106C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	pc = 0x822B1070; continue 'dispatch;
            }
            0x822B1070 => {
    //   block [0x822B1070..0x822B107C)
	// 822B1070: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B1074: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822B1078: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x822B107C; continue 'dispatch;
            }
            0x822B107C => {
    //   block [0x822B107C..0x822B10A8)
	// 822B107C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 822B1080: 485B7599  bl 0x82868618
	ctx.lr = 0x822B1084;
	sub_82868618(ctx, base);
	// 822B1084: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 822B1088: 894BEBAF  lbz r10, -0x1451(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5201 as u32) ) } as u64;
	// 822B108C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B1090: 419A002C  beq cr6, 0x822b10bc
	if ctx.cr[6].eq {
	pc = 0x822B10BC; continue 'dispatch;
	}
	// 822B1094: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 822B1098: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 822B109C: 396B3CD4  addi r11, r11, 0x3cd4
	ctx.r[11].s64 = ctx.r[11].s64 + 15572;
	// 822B10A0: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 822B10A4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x822B10A8; continue 'dispatch;
            }
            0x822B10A8 => {
    //   block [0x822B10A8..0x822B10BC)
	// 822B10A8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B10AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822B10B0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822B10B4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822B10B8: 4200FFF0  bdnz 0x822b10a8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822B10A8; continue 'dispatch;
	}
	pc = 0x822B10BC; continue 'dispatch;
            }
            0x822B10BC => {
    //   block [0x822B10BC..0x822B10C8)
	// 822B10BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822B10C0: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 822B10C4: C3EB0B8C  lfs f31, 0xb8c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2956 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x822B10C8; continue 'dispatch;
            }
            0x822B10C8 => {
    //   block [0x822B10C8..0x822B1120)
	// 822B10C8: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 822B10CC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B10D0: 7FDF5A14  add r30, r31, r11
	ctx.r[30].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 822B10D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B10D8: 815EFFF0  lwz r10, -0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16 as u32) ) } as u64;
	// 822B10DC: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 822B10E0: 810B001C  lwz r8, 0x1c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822B10E4: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 822B10E8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B10EC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 822B10F0: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822B10F4: EC2C07F2  fmuls f1, f12, f31
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 822B10F8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 822B10FC: 4E800421  bctrl
	ctx.lr = 0x822B1100;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B1100: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B1104: 484AF825  bl 0x82760928
	ctx.lr = 0x822B1108;
	sub_82760928(ctx, base);
	// 822B1108: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B110C: 419A0014  beq cr6, 0x822b1120
	if ctx.cr[6].eq {
	pc = 0x822B1120; continue 'dispatch;
	}
	// 822B1110: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 822B1114: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B1118: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 822B111C: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
            }
            0x822B1120 => {
    //   block [0x822B1120..0x822B1130)
	// 822B1120: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822B1124: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 822B1128: 2F1F0010  cmpwi cr6, r31, 0x10
	ctx.cr[6].compare_i32(ctx.r[31].s32, 16, &mut ctx.xer);
	// 822B112C: 4198FF9C  blt cr6, 0x822b10c8
	if ctx.cr[6].lt {
	pc = 0x822B10C8; continue 'dispatch;
	}
	pc = 0x822B1130; continue 'dispatch;
            }
            0x822B1130 => {
    //   block [0x822B1130..0x822B113C)
	// 822B1130: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 822B1134: CBE1FF98  lfd f31, -0x68(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 822B1138: 489F8304  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B1140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B1140 size=412
    let mut pc: u32 = 0x822B1140;
    'dispatch: loop {
        match pc {
            0x822B1140 => {
    //   block [0x822B1140..0x822B11A4)
	// 822B1140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B1144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B1148: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B114C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B1150: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1154: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822B1158: 554917FE  rlwinm r9, r10, 2, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 822B115C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B1160: 419A0168  beq cr6, 0x822b12c8
	if ctx.cr[6].eq {
	pc = 0x822B12C8; continue 'dispatch;
	}
	// 822B1164: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 822B1168: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822B116C: 5549CFFE  rlwinm r9, r10, 0x19, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 822B1170: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B1174: 419A00F4  beq cr6, 0x822b1268
	if ctx.cr[6].eq {
	pc = 0x822B1268; continue 'dispatch;
	}
	// 822B1178: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B117C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B1180: 419A0024  beq cr6, 0x822b11a4
	if ctx.cr[6].eq {
	pc = 0x822B11A4; continue 'dispatch;
	}
	// 822B1184: 894A0087  lbz r10, 0x87(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(135 as u32) ) } as u64;
	// 822B1188: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B118C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B1190: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B1194: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1198: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B119C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B11A0: 480000CC  b 0x822b126c
	pc = 0x822B126C; continue 'dispatch;
            }
            0x822B11A4 => {
    //   block [0x822B11A4..0x822B11C0)
	// 822B11A4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B11A8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B11AC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822B11B0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B11B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B11B8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B11BC: 40810054  ble 0x822b1210
	if !ctx.cr[0].gt {
	pc = 0x822B1210; continue 'dispatch;
	}
	pc = 0x822B11C0; continue 'dispatch;
            }
            0x822B11C0 => {
    //   block [0x822B11C0..0x822B11E0)
	// 822B11C0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B11C4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B11C8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B11CC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B11D0: 2F070087  cmpwi cr6, r7, 0x87
	ctx.cr[6].compare_i32(ctx.r[7].s32, 135, &mut ctx.xer);
	// 822B11D4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B11D8: 41980008  blt cr6, 0x822b11e0
	if ctx.cr[6].lt {
	pc = 0x822B11E0; continue 'dispatch;
	}
	// 822B11DC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x822B11E0; continue 'dispatch;
            }
            0x822B11E0 => {
    //   block [0x822B11E0..0x822B11FC)
	// 822B11E0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B11E4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B11E8: 419A0014  beq cr6, 0x822b11fc
	if ctx.cr[6].eq {
	pc = 0x822B11FC; continue 'dispatch;
	}
	// 822B11EC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B11F0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B11F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B11F8: 4800000C  b 0x822b1204
	pc = 0x822B1204; continue 'dispatch;
            }
            0x822B11FC => {
    //   block [0x822B11FC..0x822B1204)
	// 822B11FC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B1200: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B1204; continue 'dispatch;
            }
            0x822B1204 => {
    //   block [0x822B1204..0x822B1210)
	// 822B1204: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B1208: 4199FFB8  bgt cr6, 0x822b11c0
	if ctx.cr[6].gt {
	pc = 0x822B11C0; continue 'dispatch;
	}
	// 822B120C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B1210; continue 'dispatch;
            }
            0x822B1210 => {
    //   block [0x822B1210..0x822B122C)
	// 822B1210: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B1214: 419A0040  beq cr6, 0x822b1254
	if ctx.cr[6].eq {
	pc = 0x822B1254; continue 'dispatch;
	}
	// 822B1218: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B121C: 2F0B0087  cmpwi cr6, r11, 0x87
	ctx.cr[6].compare_i32(ctx.r[11].s32, 135, &mut ctx.xer);
	// 822B1220: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1224: 41990008  bgt cr6, 0x822b122c
	if ctx.cr[6].gt {
	pc = 0x822B122C; continue 'dispatch;
	}
	// 822B1228: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B122C; continue 'dispatch;
            }
            0x822B122C => {
    //   block [0x822B122C..0x822B1254)
	// 822B122C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B1230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1234: 409A0020  bne cr6, 0x822b1254
	if !ctx.cr[6].eq {
	pc = 0x822B1254; continue 'dispatch;
	}
	// 822B1238: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B123C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822B1240: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B1244: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1248: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B124C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1250: 4800001C  b 0x822b126c
	pc = 0x822B126C; continue 'dispatch;
            }
            0x822B1254 => {
    //   block [0x822B1254..0x822B1268)
	// 822B1254: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B1258: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B125C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B1260: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1264: 48000008  b 0x822b126c
	pc = 0x822B126C; continue 'dispatch;
            }
            0x822B1268 => {
    //   block [0x822B1268..0x822B126C)
	// 822B1268: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B126C; continue 'dispatch;
            }
            0x822B126C => {
    //   block [0x822B126C..0x822B12C8)
	// 822B126C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B1270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1274: 419A0054  beq cr6, 0x822b12c8
	if ctx.cr[6].eq {
	pc = 0x822B12C8; continue 'dispatch;
	}
	// 822B1278: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822B127C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B1280: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 822B1284: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B1288: 4BF7BC49  bl 0x8222ced0
	ctx.lr = 0x822B128C;
	sub_8222CED0(ctx, base);
	// 822B128C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 822B1290: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822B1294: 388AF644  addi r4, r10, -0x9bc
	ctx.r[4].s64 = ctx.r[10].s64 + -2492;
	// 822B1298: 48951791  bl 0x82c02a28
	ctx.lr = 0x822B129C;
	sub_82C02A28(ctx, base);
	// 822B129C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822B12A0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822B12A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822B12A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B12AC: 4BF2835D  bl 0x821d9608
	ctx.lr = 0x822B12B0;
	sub_821D9608(ctx, base);
	// 822B12B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B12B4: 48954C45  bl 0x82c05ef8
	ctx.lr = 0x822B12B8;
	sub_82C05EF8(ctx, base);
	// 822B12B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822B12BC: 4BFD878D  bl 0x82289a48
	ctx.lr = 0x822B12C0;
	sub_82289A48(ctx, base);
	// 822B12C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B12C4: 4BF63B15  bl 0x82214dd8
	ctx.lr = 0x822B12C8;
	sub_82214DD8(ctx, base);
	pc = 0x822B12C8; continue 'dispatch;
            }
            0x822B12C8 => {
    //   block [0x822B12C8..0x822B12DC)
	// 822B12C8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822B12CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B12D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B12D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B12D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B12E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B12E0 size=784
    let mut pc: u32 = 0x822B12E0;
    'dispatch: loop {
        match pc {
            0x822B12E0 => {
    //   block [0x822B12E0..0x822B1324)
	// 822B12E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B12E4: 489F8125  bl 0x82ca9408
	ctx.lr = 0x822B12E8;
	sub_82CA93D0(ctx, base);
	// 822B12E8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822B12EC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B12F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B12F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B12F8: 3B8B9490  addi r28, r11, -0x6b70
	ctx.r[28].s64 = ctx.r[11].s64 + -27504;
	// 822B12FC: 3BDF0024  addi r30, r31, 0x24
	ctx.r[30].s64 = ctx.r[31].s64 + 36;
	// 822B1300: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 822B1304: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 822B1308: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B130C: 393F0054  addi r9, r31, 0x54
	ctx.r[9].s64 = ctx.r[31].s64 + 84;
	// 822B1310: C1BF0018  lfs f13, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B1314: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 822B1318: C3FCFFF4  lfs f31, -0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822B131C: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822B1320: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	pc = 0x822B1324; continue 'dispatch;
            }
            0x822B1324 => {
    //   block [0x822B1324..0x822B1330)
	// 822B1324: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B1328: 38C9FFFC  addi r6, r9, -4
	ctx.r[6].s64 = ctx.r[9].s64 + -4;
	// 822B132C: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822B1330; continue 'dispatch;
            }
            0x822B1330 => {
    //   block [0x822B1330..0x822B133C)
	// 822B1330: 7F063040  cmplw cr6, r6, r6
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B1334: 419A0008  beq cr6, 0x822b133c
	if ctx.cr[6].eq {
	pc = 0x822B133C; continue 'dispatch;
	}
	// 822B1338: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B133C; continue 'dispatch;
            }
            0x822B133C => {
    //   block [0x822B133C..0x822B1354)
	// 822B133C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 822B1340: 419A00AC  beq cr6, 0x822b13ec
	if ctx.cr[6].eq {
	pc = 0x822B13EC; continue 'dispatch;
	}
	// 822B1344: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B1348: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B134C: 409A0008  bne cr6, 0x822b1354
	if !ctx.cr[6].eq {
	pc = 0x822B1354; continue 'dispatch;
	}
	// 822B1350: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B1354; continue 'dispatch;
            }
            0x822B1354 => {
    //   block [0x822B1354..0x822B13A0)
	// 822B1354: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B1358: FD60F890  fmr f11, f31
	ctx.f[11].f64 = ctx.f[31].f64;
	// 822B135C: 809F0074  lwz r4, 0x74(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 822B1360: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B1364: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B1368: 7C832050  subf r4, r3, r4
	ctx.r[4].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 822B136C: 7C8307B4  extsw r3, r4
	ctx.r[3].s64 = ctx.r[4].s32 as i64;
	// 822B1370: F8610050  std r3, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u64 ) };
	// 822B1374: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B1378: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 822B137C: FDA06018  frsp f13, f12
	ctx.f[13].f64 = (ctx.f[12].f64 as f32) as f64;
	// 822B1380: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822B1384: 4098001C  bge cr6, 0x822b13a0
	if !ctx.cr[6].lt {
	pc = 0x822B13A0; continue 'dispatch;
	}
	// 822B1388: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B138C: C16B0010  lfs f11, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822B1390: ED4B6028  fsubs f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 822B1394: ED2A0024  fdivs f9, f10, f0
	ctx.f[9].f64 = ((ctx.f[10].f64 / ctx.f[0].f64) as f32) as f64;
	// 822B1398: ED69637A  fmadds f11, f9, f13, f12
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 822B139C: 4800002C  b 0x822b13c8
	pc = 0x822B13C8; continue 'dispatch;
            }
            0x822B13A0 => {
    //   block [0x822B13A0..0x822B13C8)
	// 822B13A0: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B13A4: ED4C002A  fadds f10, f12, f0
	ctx.f[10].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 822B13A8: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 822B13AC: 4098001C  bge cr6, 0x822b13c8
	if !ctx.cr[6].lt {
	pc = 0x822B13C8; continue 'dispatch;
	}
	// 822B13B0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822B13B4: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B13B8: C16B0014  lfs f11, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822B13BC: ED4B6828  fsubs f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 822B13C0: ED206024  fdivs f9, f0, f12
	ctx.f[9].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 822B13C4: ED696ABA  fmadds f11, f9, f10, f13
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	pc = 0x822B13C8; continue 'dispatch;
            }
            0x822B13C8 => {
    //   block [0x822B13C8..0x822B13E4)
	// 822B13C8: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B13CC: EDA0582A  fadds f13, f0, f11
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 822B13D0: D1A80000  stfs f13, 0(r8)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822B13D4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B13D8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B13DC: 409A0008  bne cr6, 0x822b13e4
	if !ctx.cr[6].eq {
	pc = 0x822B13E4; continue 'dispatch;
	}
	// 822B13E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B13E4; continue 'dispatch;
            }
            0x822B13E4 => {
    //   block [0x822B13E4..0x822B13EC)
	// 822B13E4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B13E8: 4BFFFF48  b 0x822b1330
	pc = 0x822B1330; continue 'dispatch;
            }
            0x822B13EC => {
    //   block [0x822B13EC..0x822B143C)
	// 822B13EC: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 822B13F0: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 822B13F4: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 822B13F8: 4082FF2C  bne 0x822b1324
	if !ctx.cr[0].eq {
	pc = 0x822B1324; continue 'dispatch;
	}
	// 822B13FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1400: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822B1404: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 822B1408: 55288FFE  rlwinm r8, r9, 0x11, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00007FFFu64;
	// 822B140C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822B1410: 419A00EC  beq cr6, 0x822b14fc
	if ctx.cr[6].eq {
	pc = 0x822B14FC; continue 'dispatch;
	}
	// 822B1414: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B1418: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B141C: 419A0020  beq cr6, 0x822b143c
	if ctx.cr[6].eq {
	pc = 0x822B143C; continue 'dispatch;
	}
	// 822B1420: 894A002F  lbz r10, 0x2f(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(47 as u32) ) } as u64;
	// 822B1424: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B1428: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B142C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B1430: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1434: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1438: 480000C8  b 0x822b1500
	pc = 0x822B1500; continue 'dispatch;
            }
            0x822B143C => {
    //   block [0x822B143C..0x822B145C)
	// 822B143C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B1440: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822B1444: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B1448: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 822B144C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B1450: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B1454: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B1458: 40810054  ble 0x822b14ac
	if !ctx.cr[0].gt {
	pc = 0x822B14AC; continue 'dispatch;
	}
	pc = 0x822B145C; continue 'dispatch;
            }
            0x822B145C => {
    //   block [0x822B145C..0x822B147C)
	// 822B145C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B1460: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B1464: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B1468: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B146C: 2F07002F  cmpwi cr6, r7, 0x2f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 47, &mut ctx.xer);
	// 822B1470: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B1474: 41980008  blt cr6, 0x822b147c
	if ctx.cr[6].lt {
	pc = 0x822B147C; continue 'dispatch;
	}
	// 822B1478: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822B147C; continue 'dispatch;
            }
            0x822B147C => {
    //   block [0x822B147C..0x822B1498)
	// 822B147C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B1480: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B1484: 419A0014  beq cr6, 0x822b1498
	if ctx.cr[6].eq {
	pc = 0x822B1498; continue 'dispatch;
	}
	// 822B1488: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B148C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B1490: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B1494: 4800000C  b 0x822b14a0
	pc = 0x822B14A0; continue 'dispatch;
            }
            0x822B1498 => {
    //   block [0x822B1498..0x822B14A0)
	// 822B1498: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B149C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B14A0; continue 'dispatch;
            }
            0x822B14A0 => {
    //   block [0x822B14A0..0x822B14AC)
	// 822B14A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B14A4: 4199FFB8  bgt cr6, 0x822b145c
	if ctx.cr[6].gt {
	pc = 0x822B145C; continue 'dispatch;
	}
	// 822B14A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B14AC; continue 'dispatch;
            }
            0x822B14AC => {
    //   block [0x822B14AC..0x822B14C8)
	// 822B14AC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B14B0: 419A003C  beq cr6, 0x822b14ec
	if ctx.cr[6].eq {
	pc = 0x822B14EC; continue 'dispatch;
	}
	// 822B14B4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B14B8: 2F0B002F  cmpwi cr6, r11, 0x2f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 47, &mut ctx.xer);
	// 822B14BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B14C0: 41990008  bgt cr6, 0x822b14c8
	if ctx.cr[6].gt {
	pc = 0x822B14C8; continue 'dispatch;
	}
	// 822B14C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822B14C8; continue 'dispatch;
            }
            0x822B14C8 => {
    //   block [0x822B14C8..0x822B14EC)
	// 822B14C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B14CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B14D0: 409A001C  bne cr6, 0x822b14ec
	if !ctx.cr[6].eq {
	pc = 0x822B14EC; continue 'dispatch;
	}
	// 822B14D4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B14D8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822B14DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B14E0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B14E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B14E8: 48000018  b 0x822b1500
	pc = 0x822B1500; continue 'dispatch;
            }
            0x822B14EC => {
    //   block [0x822B14EC..0x822B14FC)
	// 822B14EC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B14F0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B14F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B14F8: 48000008  b 0x822b1500
	pc = 0x822B1500; continue 'dispatch;
            }
            0x822B14FC => {
    //   block [0x822B14FC..0x822B1500)
	// 822B14FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822B1500; continue 'dispatch;
            }
            0x822B1500 => {
    //   block [0x822B1500..0x822B152C)
	// 822B1500: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B1504: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1508: 419A0024  beq cr6, 0x822b152c
	if ctx.cr[6].eq {
	pc = 0x822B152C; continue 'dispatch;
	}
	// 822B150C: C00A02A8  lfs f0, 0x2a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(680 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B1510: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B1514: ED80682A  fadds f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 822B1518: C17D0000  lfs f11, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822B151C: D19E0000  stfs f12, 0(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822B1520: C14A02AC  lfs f10, 0x2ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(684 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822B1524: ED2A582A  fadds f9, f10, f11
	ctx.f[9].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 822B1528: D13D0000  stfs f9, 0(r29)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x822B152C; continue 'dispatch;
            }
            0x822B152C => {
    //   block [0x822B152C..0x822B15F0)
	// 822B152C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B1530: 4BED5339  bl 0x82186868
	ctx.lr = 0x822B1534;
	sub_82186868(ctx, base);
	// 822B1534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B1538: 4BEEB499  bl 0x8219c9d0
	ctx.lr = 0x822B153C;
	sub_8219C9D0(ctx, base);
	// 822B153C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B1540: 4BEDDD71  bl 0x8218f2b0
	ctx.lr = 0x822B1544;
	sub_8218F2B0(ctx, base);
	// 822B1544: C01C4138  lfs f0, 0x4138(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B1548: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B154C: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 822B1550: ED6C0028  fsubs f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 822B1554: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B1558: 394B0E68  addi r10, r11, 0xe68
	ctx.r[10].s64 = ctx.r[11].s64 + 3688;
	// 822B155C: FF0BF800  fcmpu cr6, f11, f31
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[31].f64);
	// 822B1560: 7D200026  mfcr r9
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[9].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B1564: 5528DF7A  rlwinm r8, r9, 0x1b, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 822B1568: 5527F77A  rlwinm r7, r9, 0x1e, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 822B156C: 7D063B78  or r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 822B1570: 7D4A342E  lfsx f10, r10, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822B1574: FD2A032E  fsel f9, f10, f12, f0
	ctx.f[9].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 822B1578: ED096828  fsubs f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 822B157C: FF08F800  fcmpu cr6, f8, f31
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[31].f64);
	// 822B1580: 7CA00026  mfcr r5
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[5].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B1584: 54A4DF7A  rlwinm r4, r5, 0x1b, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 822B1588: 54A3F77A  rlwinm r3, r5, 0x1e, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[5].u32 as u64 & 0x00000003u64;
	// 822B158C: 7C8B1B78  or r11, r4, r3
	ctx.r[11].u64 = ctx.r[4].u64 | ctx.r[3].u64;
	// 822B1590: 7CEA5C2E  lfsx f7, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 822B1594: FCC74B6E  fsel f6, f7, f13, f9
	ctx.f[6].f64 = if ctx.f[7].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[9].f64 };
	// 822B1598: D0DE0000  stfs f6, 0(r30)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822B159C: C0BD0000  lfs f5, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 822B15A0: EC850028  fsubs f4, f5, f0
	ctx.f[4].f64 = (((ctx.f[5].f64 - ctx.f[0].f64) as f32) as f64);
	// 822B15A4: FF04F800  fcmpu cr6, f4, f31
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[31].f64);
	// 822B15A8: 7D200026  mfcr r9
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[9].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B15AC: 5528DF7A  rlwinm r8, r9, 0x1b, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 822B15B0: 5527F77A  rlwinm r7, r9, 0x1e, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 822B15B4: 7D063B78  or r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 822B15B8: 7C6A342E  lfsx f3, r10, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 822B15BC: FC43016E  fsel f2, f3, f5, f0
	ctx.f[2].f64 = if ctx.f[3].f64 >= 0.0 { ctx.f[5].f64 } else { ctx.f[0].f64 };
	// 822B15C0: EC226828  fsubs f1, f2, f13
	ctx.f[1].f64 = (((ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	// 822B15C4: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 822B15C8: 7CA00026  mfcr r5
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[5].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B15CC: 54A4DF7A  rlwinm r4, r5, 0x1b, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 822B15D0: 54A3F77A  rlwinm r3, r5, 0x1e, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[5].u32 as u64 & 0x00000003u64;
	// 822B15D4: 7C8B1B78  or r11, r4, r3
	ctx.r[11].u64 = ctx.r[4].u64 | ctx.r[3].u64;
	// 822B15D8: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B15DC: FDA0136E  fsel f13, f0, f13, f2
	ctx.f[13].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[2].f64 };
	// 822B15E0: D1BD0000  stfs f13, 0(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822B15E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822B15E8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822B15EC: 489F7E6C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B15F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B15F0 size=656
    let mut pc: u32 = 0x822B15F0;
    'dispatch: loop {
        match pc {
            0x822B15F0 => {
    //   block [0x822B15F0..0x822B1644)
	// 822B15F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B15F4: 489F7E19  bl 0x82ca940c
	ctx.lr = 0x822B15F8;
	sub_82CA93D0(ctx, base);
	// 822B15F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B15FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B1600: 897F0080  lbz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822B1604: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1608: 409A0270  bne cr6, 0x822b1878
	if !ctx.cr[6].eq {
	pc = 0x822B1878; continue 'dispatch;
	}
	// 822B160C: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B1610: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B1614: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B1618: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 822B161C: FD606A10  fabs f11, f13
	ctx.f[11].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 822B1620: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822B1624: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 822B1628: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 822B162C: 41980018  blt cr6, 0x822b1644
	if ctx.cr[6].lt {
	pc = 0x822B1644; continue 'dispatch;
	}
	// 822B1630: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822B1634: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B1638: 419A001C  beq cr6, 0x822b1654
	if ctx.cr[6].eq {
	pc = 0x822B1654; continue 'dispatch;
	}
	// 822B163C: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 822B1640: 48000014  b 0x822b1654
	pc = 0x822B1654; continue 'dispatch;
            }
            0x822B1644 => {
    //   block [0x822B1644..0x822B1654)
	// 822B1644: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822B1648: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822B164C: 419A0008  beq cr6, 0x822b1654
	if ctx.cr[6].eq {
	pc = 0x822B1654; continue 'dispatch;
	}
	// 822B1650: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	pc = 0x822B1654; continue 'dispatch;
            }
            0x822B1654 => {
    //   block [0x822B1654..0x822B16E4)
	// 822B1654: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B1658: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 822B165C: C19F004C  lfs f12, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B1660: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 822B1664: 41980214  blt cr6, 0x822b1878
	if ctx.cr[6].lt {
	pc = 0x822B1878; continue 'dispatch;
	}
	// 822B1668: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822B166C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B1670: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 822B1674: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B1678: 4BF7B859  bl 0x8222ced0
	ctx.lr = 0x822B167C;
	sub_8222CED0(ctx, base);
	// 822B167C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B1680: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B1684: 409A0190  bne cr6, 0x822b1814
	if !ctx.cr[6].eq {
	pc = 0x822B1814; continue 'dispatch;
	}
	// 822B1688: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B168C: C1BF000C  lfs f13, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B1690: 38AB92D4  addi r5, r11, -0x6d2c
	ctx.r[5].s64 = ctx.r[11].s64 + -27948;
	// 822B1694: C00501B0  lfs f0, 0x1b0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B1698: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822B169C: 419901C0  bgt cr6, 0x822b185c
	if ctx.cr[6].gt {
	pc = 0x822B185C; continue 'dispatch;
	}
	// 822B16A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B16A4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 822B16A8: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 822B16AC: 55288FFE  rlwinm r8, r9, 0x11, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00007FFFu64;
	// 822B16B0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822B16B4: 419A00F4  beq cr6, 0x822b17a8
	if ctx.cr[6].eq {
	pc = 0x822B17A8; continue 'dispatch;
	}
	// 822B16B8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B16BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B16C0: 419A0024  beq cr6, 0x822b16e4
	if ctx.cr[6].eq {
	pc = 0x822B16E4; continue 'dispatch;
	}
	// 822B16C4: 894A002F  lbz r10, 0x2f(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(47 as u32) ) } as u64;
	// 822B16C8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B16CC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B16D0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B16D4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B16D8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B16DC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822B16E0: 480000CC  b 0x822b17ac
	pc = 0x822B17AC; continue 'dispatch;
            }
            0x822B16E4 => {
    //   block [0x822B16E4..0x822B1700)
	// 822B16E4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B16E8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B16EC: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 822B16F0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B16F4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822B16F8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B16FC: 40810054  ble 0x822b1750
	if !ctx.cr[0].gt {
	pc = 0x822B1750; continue 'dispatch;
	}
	pc = 0x822B1700; continue 'dispatch;
            }
            0x822B1700 => {
    //   block [0x822B1700..0x822B1720)
	// 822B1700: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B1704: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B1708: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B170C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B1710: 2F07002F  cmpwi cr6, r7, 0x2f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 47, &mut ctx.xer);
	// 822B1714: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 822B1718: 41980008  blt cr6, 0x822b1720
	if ctx.cr[6].lt {
	pc = 0x822B1720; continue 'dispatch;
	}
	// 822B171C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x822B1720; continue 'dispatch;
            }
            0x822B1720 => {
    //   block [0x822B1720..0x822B173C)
	// 822B1720: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B1724: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B1728: 419A0014  beq cr6, 0x822b173c
	if ctx.cr[6].eq {
	pc = 0x822B173C; continue 'dispatch;
	}
	// 822B172C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B1730: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B1734: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B1738: 4800000C  b 0x822b1744
	pc = 0x822B1744; continue 'dispatch;
            }
            0x822B173C => {
    //   block [0x822B173C..0x822B1744)
	// 822B173C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B1740: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B1744; continue 'dispatch;
            }
            0x822B1744 => {
    //   block [0x822B1744..0x822B1750)
	// 822B1744: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B1748: 4199FFB8  bgt cr6, 0x822b1700
	if ctx.cr[6].gt {
	pc = 0x822B1700; continue 'dispatch;
	}
	// 822B174C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x822B1750; continue 'dispatch;
            }
            0x822B1750 => {
    //   block [0x822B1750..0x822B176C)
	// 822B1750: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B1754: 419A0040  beq cr6, 0x822b1794
	if ctx.cr[6].eq {
	pc = 0x822B1794; continue 'dispatch;
	}
	// 822B1758: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B175C: 2F0B002F  cmpwi cr6, r11, 0x2f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 47, &mut ctx.xer);
	// 822B1760: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822B1764: 41990008  bgt cr6, 0x822b176c
	if ctx.cr[6].gt {
	pc = 0x822B176C; continue 'dispatch;
	}
	// 822B1768: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B176C; continue 'dispatch;
            }
            0x822B176C => {
    //   block [0x822B176C..0x822B1794)
	// 822B176C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B1770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1774: 409A0020  bne cr6, 0x822b1794
	if !ctx.cr[6].eq {
	pc = 0x822B1794; continue 'dispatch;
	}
	// 822B1778: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822B177C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822B1780: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822B1784: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1788: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B178C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822B1790: 4800001C  b 0x822b17ac
	pc = 0x822B17AC; continue 'dispatch;
            }
            0x822B1794 => {
    //   block [0x822B1794..0x822B17A8)
	// 822B1794: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B1798: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B179C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B17A0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822B17A4: 48000008  b 0x822b17ac
	pc = 0x822B17AC; continue 'dispatch;
            }
            0x822B17A8 => {
    //   block [0x822B17A8..0x822B17AC)
	// 822B17A8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B17AC; continue 'dispatch;
            }
            0x822B17AC => {
    //   block [0x822B17AC..0x822B17F0)
	// 822B17AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B17B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B17B4: 419A00BC  beq cr6, 0x822b1870
	if ctx.cr[6].eq {
	pc = 0x822B1870; continue 'dispatch;
	}
	// 822B17B8: C1AA02EC  lfs f13, 0x2ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(748 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B17BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B17C0: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B17C4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822B17C8: 41980028  blt cr6, 0x822b17f0
	if ctx.cr[6].lt {
	pc = 0x822B17F0; continue 'dispatch;
	}
	// 822B17CC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 822B17D0: 388B2244  addi r4, r11, 0x2244
	ctx.r[4].s64 = ctx.r[11].s64 + 8772;
	// 822B17D4: 4BFC3C65  bl 0x82275438
	ctx.lr = 0x822B17D8;
	sub_82275438(ctx, base);
	// 822B17D8: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 822B17DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B17E0: 915F007C  stw r10, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 822B17E4: 4BF635F5  bl 0x82214dd8
	ctx.lr = 0x822B17E8;
	sub_82214DD8(ctx, base);
	// 822B17E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822B17EC: 489F7C70  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B17F0 => {
    //   block [0x822B17F0..0x822B1814)
	// 822B17F0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 822B17F4: 388B224C  addi r4, r11, 0x224c
	ctx.r[4].s64 = ctx.r[11].s64 + 8780;
	// 822B17F8: 4BFC3C41  bl 0x82275438
	ctx.lr = 0x822B17FC;
	sub_82275438(ctx, base);
	// 822B17FC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 822B1800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B1804: 915F007C  stw r10, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 822B1808: 4BF635D1  bl 0x82214dd8
	ctx.lr = 0x822B180C;
	sub_82214DD8(ctx, base);
	// 822B180C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822B1810: 489F7C4C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B1814 => {
    //   block [0x822B1814..0x822B185C)
	// 822B1814: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822B1818: 409A0058  bne cr6, 0x822b1870
	if !ctx.cr[6].eq {
	pc = 0x822B1870; continue 'dispatch;
	}
	// 822B181C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B1820: C1BF000C  lfs f13, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B1824: 394B92D4  addi r10, r11, -0x6d2c
	ctx.r[10].s64 = ctx.r[11].s64 + -27948;
	// 822B1828: C00A01B0  lfs f0, 0x1b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B182C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822B1830: 4099002C  ble cr6, 0x822b185c
	if !ctx.cr[6].gt {
	pc = 0x822B185C; continue 'dispatch;
	}
	// 822B1834: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 822B1838: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B183C: 388BFAFC  addi r4, r11, -0x504
	ctx.r[4].s64 = ctx.r[11].s64 + -1284;
	// 822B1840: 4BFC3BF9  bl 0x82275438
	ctx.lr = 0x822B1844;
	sub_82275438(ctx, base);
	// 822B1844: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 822B1848: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B184C: 915F007C  stw r10, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 822B1850: 4BF63589  bl 0x82214dd8
	ctx.lr = 0x822B1854;
	sub_82214DD8(ctx, base);
	// 822B1854: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822B1858: 489F7C04  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B185C => {
    //   block [0x822B185C..0x822B1870)
	// 822B185C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 822B1860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B1864: 388B223C  addi r4, r11, 0x223c
	ctx.r[4].s64 = ctx.r[11].s64 + 8764;
	// 822B1868: 4BFC3BD1  bl 0x82275438
	ctx.lr = 0x822B186C;
	sub_82275438(ctx, base);
	// 822B186C: 93BF007C  stw r29, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	pc = 0x822B1870; continue 'dispatch;
            }
            0x822B1870 => {
    //   block [0x822B1870..0x822B1878)
	// 822B1870: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B1874: 4BF63565  bl 0x82214dd8
	ctx.lr = 0x822B1878;
	sub_82214DD8(ctx, base);
	pc = 0x822B1878; continue 'dispatch;
            }
            0x822B1878 => {
    //   block [0x822B1878..0x822B1880)
	// 822B1878: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822B187C: 489F7BE0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B1880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B1880 size=836
    let mut pc: u32 = 0x822B1880;
    'dispatch: loop {
        match pc {
            0x822B1880 => {
    //   block [0x822B1880..0x822B18B8)
	// 822B1880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B1884: 489F7B89  bl 0x82ca940c
	ctx.lr = 0x822B1888;
	sub_82CA93D0(ctx, base);
	// 822B1888: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B188C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B1890: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822B1894: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 822B1898: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 822B189C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B18A0: 419A0020  beq cr6, 0x822b18c0
	if ctx.cr[6].eq {
	pc = 0x822B18C0; continue 'dispatch;
	}
	// 822B18A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B18A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B18AC: 419A000C  beq cr6, 0x822b18b8
	if ctx.cr[6].eq {
	pc = 0x822B18B8; continue 'dispatch;
	}
	// 822B18B0: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 822B18B4: 48000010  b 0x822b18c4
	pc = 0x822B18C4; continue 'dispatch;
            }
            0x822B18B8 => {
    //   block [0x822B18B8..0x822B18C0)
	// 822B18B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B18BC: 4BEE257D  bl 0x82193e38
	ctx.lr = 0x822B18C0;
	sub_82193E38(ctx, base);
	pc = 0x822B18C0; continue 'dispatch;
            }
            0x822B18C0 => {
    //   block [0x822B18C0..0x822B18C4)
	// 822B18C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x822B18C4; continue 'dispatch;
            }
            0x822B18C4 => {
    //   block [0x822B18C4..0x822B1A6C)
	// 822B18C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B18C8: 4BFC1811  bl 0x822730d8
	ctx.lr = 0x822B18CC;
	sub_822730D8(ctx, base);
	// 822B18CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B18D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B18D4: 409A0198  bne cr6, 0x822b1a6c
	if !ctx.cr[6].eq {
	pc = 0x822B1A6C; continue 'dispatch;
	}
	// 822B18D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B18DC: 4BEC255D  bl 0x82173e38
	ctx.lr = 0x822B18E0;
	sub_82173E38(ctx, base);
	// 822B18E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822B18E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822B18E8: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 822B18EC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B18F0: 812A004C  lwz r9, 0x4c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B18F4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822B18F8: 4E800421  bctrl
	ctx.lr = 0x822B18FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B18FC: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 822B1900: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 822B1904: 38C890F0  addi r6, r8, -0x6f10
	ctx.r[6].s64 = ctx.r[8].s64 + -28432;
	// 822B1908: 3CA08332  lis r5, -0x7cce
	ctx.r[5].s64 = -2093875200;
	// 822B190C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
            }
            0x822B1A6C => {
    //   block [0x822B1A6C..0x822B1BC4)
	// 822B1A6C: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 822B1A70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1A74: 419A0148  beq cr6, 0x822b1bbc
	if ctx.cr[6].eq {
	pc = 0x822B1BBC; continue 'dispatch;
	}
	// 822B1A78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B1A7C: 4BEC23BD  bl 0x82173e38
	ctx.lr = 0x822B1A80;
	sub_82173E38(ctx, base);
	// 822B1A80: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822B1A84: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 822B1A88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B1A8C: 419A00F4  beq cr6, 0x822b1b80
	if ctx.cr[6].eq {
	pc = 0x822B1B80; continue 'dispatch;
	}
	// 822B1A90: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B1A94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1A98: 419A0024  beq cr6, 0x822b1abc
	if ctx.cr[6].eq {
	pc = 0x822B1ABC; continue 'dispatch;
	}
	// 822B1A9C: 894B0063  lbz r10, 0x63(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(99 as u32) ) } as u64;
	// 822B1AA0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B1AA4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B1AA8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B1AAC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1AB0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B1AB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1AB8: 480000CC  b 0x822b1b84
	pc = 0x822B1B84; continue 'dispatch;
	// 822B1ABC: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B1AC0: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B1AC4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 822B1AC8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B1ACC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822B1AD0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B1AD4: 40810054  ble 0x822b1b28
	if !ctx.cr[0].gt {
	pc = 0x822B1B28; continue 'dispatch;
	}
	// 822B1AD8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B1ADC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B1AE0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B1AE4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B1AE8: 2F070063  cmpwi cr6, r7, 0x63
	ctx.cr[6].compare_i32(ctx.r[7].s32, 99, &mut ctx.xer);
	// 822B1AEC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B1AF0: 41980008  blt cr6, 0x822b1af8
	if ctx.cr[6].lt {
	pc = 0x822B1AF8; continue 'dispatch;
	}
	// 822B1AF4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 822B1AF8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B1AFC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B1B00: 419A0014  beq cr6, 0x822b1b14
	if ctx.cr[6].eq {
	pc = 0x822B1B14; continue 'dispatch;
	}
	// 822B1B04: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B1B08: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B1B0C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B1B10: 4800000C  b 0x822b1b1c
	pc = 0x822B1B1C; continue 'dispatch;
	// 822B1B14: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B1B18: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 822B1B1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B1B20: 4199FFB8  bgt cr6, 0x822b1ad8
	if ctx.cr[6].gt {
	pc = 0x822B1AD8; continue 'dispatch;
	}
	// 822B1B24: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822B1B28: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B1B2C: 419A0040  beq cr6, 0x822b1b6c
	if ctx.cr[6].eq {
	pc = 0x822B1B6C; continue 'dispatch;
	}
	// 822B1B30: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B1B34: 2F0B0063  cmpwi cr6, r11, 0x63
	ctx.cr[6].compare_i32(ctx.r[11].s32, 99, &mut ctx.xer);
	// 822B1B38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1B3C: 41990008  bgt cr6, 0x822b1b44
	if ctx.cr[6].gt {
	pc = 0x822B1B44; continue 'dispatch;
	}
	// 822B1B40: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822B1B44: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B1B48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1B4C: 409A0020  bne cr6, 0x822b1b6c
	if !ctx.cr[6].eq {
	pc = 0x822B1B6C; continue 'dispatch;
	}
	// 822B1B50: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822B1B54: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822B1B58: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822B1B5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1B60: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B1B64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1B68: 4800001C  b 0x822b1b84
	pc = 0x822B1B84; continue 'dispatch;
	// 822B1B6C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B1B70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1B74: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B1B78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1B7C: 48000008  b 0x822b1b84
	pc = 0x822B1B84; continue 'dispatch;
	// 822B1B80: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822B1B84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B1B88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1B8C: 419A0030  beq cr6, 0x822b1bbc
	if ctx.cr[6].eq {
	pc = 0x822B1BBC; continue 'dispatch;
	}
	// 822B1B90: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B1B94: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822B1B98: 419A000C  beq cr6, 0x822b1ba4
	if ctx.cr[6].eq {
	pc = 0x822B1BA4; continue 'dispatch;
	}
	// 822B1B9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1BA0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 822B1BA4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822B1BA8: 894B6B6C  lbz r10, 0x6b6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27500 as u32) ) } as u64;
	// 822B1BAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B1BB0: 419A000C  beq cr6, 0x822b1bbc
	if ctx.cr[6].eq {
	pc = 0x822B1BBC; continue 'dispatch;
	}
	// 822B1BB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B1BB8: 4801EFA9  bl 0x822d0b60
	ctx.lr = 0x822B1BBC;
	sub_822D0B60(ctx, base);
	// 822B1BBC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822B1BC0: 489F789C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B1BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B1BC8 size=944
    let mut pc: u32 = 0x822B1BC8;
    'dispatch: loop {
        match pc {
            0x822B1BC8 => {
    //   block [0x822B1BC8..0x822B1C20)
	// 822B1BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B1BCC: 489F7841  bl 0x82ca940c
	ctx.lr = 0x822B1BD0;
	sub_82CA93D0(ctx, base);
	// 822B1BD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B1BD4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822B1BD8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822B1BDC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 822B1BE0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1BE4: 894B0024  lbz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822B1BE8: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 822B1BEC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B1BF0: 419A00F4  beq cr6, 0x822b1ce4
	if ctx.cr[6].eq {
	pc = 0x822B1CE4; continue 'dispatch;
	}
	// 822B1BF4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B1BF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B1BFC: 419A0024  beq cr6, 0x822b1c20
	if ctx.cr[6].eq {
	pc = 0x822B1C20; continue 'dispatch;
	}
	// 822B1C00: 894A0018  lbz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 822B1C04: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B1C08: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B1C0C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B1C10: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1C14: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B1C18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1C1C: 480000CC  b 0x822b1ce8
	pc = 0x822B1CE8; continue 'dispatch;
            }
            0x822B1C20 => {
    //   block [0x822B1C20..0x822B1C3C)
	// 822B1C20: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B1C24: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B1C28: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 822B1C2C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B1C30: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822B1C34: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B1C38: 40810054  ble 0x822b1c8c
	if !ctx.cr[0].gt {
	pc = 0x822B1C8C; continue 'dispatch;
	}
	pc = 0x822B1C3C; continue 'dispatch;
            }
            0x822B1C3C => {
    //   block [0x822B1C3C..0x822B1C5C)
	// 822B1C3C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B1C40: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B1C44: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B1C48: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B1C4C: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 822B1C50: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B1C54: 41980008  blt cr6, 0x822b1c5c
	if ctx.cr[6].lt {
	pc = 0x822B1C5C; continue 'dispatch;
	}
	// 822B1C58: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x822B1C5C; continue 'dispatch;
            }
            0x822B1C5C => {
    //   block [0x822B1C5C..0x822B1C78)
	// 822B1C5C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B1C60: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B1C64: 419A0014  beq cr6, 0x822b1c78
	if ctx.cr[6].eq {
	pc = 0x822B1C78; continue 'dispatch;
	}
	// 822B1C68: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B1C6C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B1C70: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B1C74: 4800000C  b 0x822b1c80
	pc = 0x822B1C80; continue 'dispatch;
            }
            0x822B1C78 => {
    //   block [0x822B1C78..0x822B1C80)
	// 822B1C78: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B1C7C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B1C80; continue 'dispatch;
            }
            0x822B1C80 => {
    //   block [0x822B1C80..0x822B1C8C)
	// 822B1C80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B1C84: 4199FFB8  bgt cr6, 0x822b1c3c
	if ctx.cr[6].gt {
	pc = 0x822B1C3C; continue 'dispatch;
	}
	// 822B1C88: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x822B1C8C; continue 'dispatch;
            }
            0x822B1C8C => {
    //   block [0x822B1C8C..0x822B1CA8)
	// 822B1C8C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B1C90: 419A0040  beq cr6, 0x822b1cd0
	if ctx.cr[6].eq {
	pc = 0x822B1CD0; continue 'dispatch;
	}
	// 822B1C94: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B1C98: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 822B1C9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1CA0: 41990008  bgt cr6, 0x822b1ca8
	if ctx.cr[6].gt {
	pc = 0x822B1CA8; continue 'dispatch;
	}
	// 822B1CA4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B1CA8; continue 'dispatch;
            }
            0x822B1CA8 => {
    //   block [0x822B1CA8..0x822B1CD0)
	// 822B1CA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B1CAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1CB0: 409A0020  bne cr6, 0x822b1cd0
	if !ctx.cr[6].eq {
	pc = 0x822B1CD0; continue 'dispatch;
	}
	// 822B1CB4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822B1CB8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822B1CBC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822B1CC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1CC4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B1CC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1CCC: 4800001C  b 0x822b1ce8
	pc = 0x822B1CE8; continue 'dispatch;
            }
            0x822B1CD0 => {
    //   block [0x822B1CD0..0x822B1CE4)
	// 822B1CD0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B1CD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1CD8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B1CDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1CE0: 48000008  b 0x822b1ce8
	pc = 0x822B1CE8; continue 'dispatch;
            }
            0x822B1CE4 => {
    //   block [0x822B1CE4..0x822B1CE8)
	// 822B1CE4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B1CE8; continue 'dispatch;
            }
            0x822B1CE8 => {
    //   block [0x822B1CE8..0x822B1D44)
	// 822B1CE8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B1CEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1CF0: 419A0280  beq cr6, 0x822b1f70
	if ctx.cr[6].eq {
	pc = 0x822B1F70; continue 'dispatch;
	}
	// 822B1CF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822B1CF8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B1CFC: 388B19B0  addi r4, r11, 0x19b0
	ctx.r[4].s64 = ctx.r[11].s64 + 6576;
	// 822B1D00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B1D04: 4BF7B1CD  bl 0x8222ced0
	ctx.lr = 0x822B1D08;
	sub_8222CED0(ctx, base);
	// 822B1D08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B1D0C: 480FED2D  bl 0x823b0a38
	ctx.lr = 0x822B1D10;
	sub_823B0A38(ctx, base);
	// 822B1D10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822B1D14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B1D18: 482497D1  bl 0x824fb4e8
	ctx.lr = 0x822B1D1C;
	sub_824FB4E8(ctx, base);
	// 822B1D1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B1D20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B1D24: 4BF630B5  bl 0x82214dd8
	ctx.lr = 0x822B1D28;
	sub_82214DD8(ctx, base);
	// 822B1D28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822B1D2C: 419A0018  beq cr6, 0x822b1d44
	if ctx.cr[6].eq {
	pc = 0x822B1D44; continue 'dispatch;
	}
	// 822B1D30: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 822B1D34: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822B1D38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1D3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B1D40: 409A0008  bne cr6, 0x822b1d48
	if !ctx.cr[6].eq {
	pc = 0x822B1D48; continue 'dispatch;
	}
	pc = 0x822B1D44; continue 'dispatch;
            }
            0x822B1D44 => {
    //   block [0x822B1D44..0x822B1D48)
	// 822B1D44: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B1D48; continue 'dispatch;
            }
            0x822B1D48 => {
    //   block [0x822B1D48..0x822B1DB4)
	// 822B1D48: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B1D4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1D50: 419A01D4  beq cr6, 0x822b1f24
	if ctx.cr[6].eq {
	pc = 0x822B1F24; continue 'dispatch;
	}
	// 822B1D54: 817D017C  lwz r11, 0x17c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(380 as u32) ) } as u64;
	// 822B1D58: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B1D5C: 419A0214  beq cr6, 0x822b1f70
	if ctx.cr[6].eq {
	pc = 0x822B1F70; continue 'dispatch;
	}
	// 822B1D60: 93FD017C  stw r31, 0x17c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(380 as u32), ctx.r[31].u32 ) };
	// 822B1D64: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 822B1D68: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B1D6C: 388BC1D4  addi r4, r11, -0x3e2c
	ctx.r[4].s64 = ctx.r[11].s64 + -15916;
	// 822B1D70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B1D74: 4BF7B15D  bl 0x8222ced0
	ctx.lr = 0x822B1D78;
	sub_8222CED0(ctx, base);
	// 822B1D78: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 822B1D7C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822B1D80: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 822B1D84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B1D88: 419A00E8  beq cr6, 0x822b1e70
	if ctx.cr[6].eq {
	pc = 0x822B1E70; continue 'dispatch;
	}
	// 822B1D8C: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B1D90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1D94: 419A0020  beq cr6, 0x822b1db4
	if ctx.cr[6].eq {
	pc = 0x822B1DB4; continue 'dispatch;
	}
	// 822B1D98: 894B0053  lbz r10, 0x53(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(83 as u32) ) } as u64;
	// 822B1D9C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B1DA0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B1DA4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B1DA8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B1DAC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1DB0: 480000C4  b 0x822b1e74
	pc = 0x822B1E74; continue 'dispatch;
            }
            0x822B1DB4 => {
    //   block [0x822B1DB4..0x822B1DD0)
	// 822B1DB4: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B1DB8: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B1DBC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 822B1DC0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B1DC4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B1DC8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B1DCC: 40810054  ble 0x822b1e20
	if !ctx.cr[0].gt {
	pc = 0x822B1E20; continue 'dispatch;
	}
	pc = 0x822B1DD0; continue 'dispatch;
            }
            0x822B1DD0 => {
    //   block [0x822B1DD0..0x822B1DF0)
	// 822B1DD0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B1DD4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B1DD8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B1DDC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B1DE0: 2F070053  cmpwi cr6, r7, 0x53
	ctx.cr[6].compare_i32(ctx.r[7].s32, 83, &mut ctx.xer);
	// 822B1DE4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B1DE8: 41980008  blt cr6, 0x822b1df0
	if ctx.cr[6].lt {
	pc = 0x822B1DF0; continue 'dispatch;
	}
	// 822B1DEC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x822B1DF0; continue 'dispatch;
            }
            0x822B1DF0 => {
    //   block [0x822B1DF0..0x822B1E0C)
	// 822B1DF0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B1DF4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B1DF8: 419A0014  beq cr6, 0x822b1e0c
	if ctx.cr[6].eq {
	pc = 0x822B1E0C; continue 'dispatch;
	}
	// 822B1DFC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B1E00: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B1E04: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B1E08: 4800000C  b 0x822b1e14
	pc = 0x822B1E14; continue 'dispatch;
            }
            0x822B1E0C => {
    //   block [0x822B1E0C..0x822B1E14)
	// 822B1E0C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B1E10: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B1E14; continue 'dispatch;
            }
            0x822B1E14 => {
    //   block [0x822B1E14..0x822B1E20)
	// 822B1E14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B1E18: 4199FFB8  bgt cr6, 0x822b1dd0
	if ctx.cr[6].gt {
	pc = 0x822B1DD0; continue 'dispatch;
	}
	// 822B1E1C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B1E20; continue 'dispatch;
            }
            0x822B1E20 => {
    //   block [0x822B1E20..0x822B1E3C)
	// 822B1E20: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B1E24: 419A003C  beq cr6, 0x822b1e60
	if ctx.cr[6].eq {
	pc = 0x822B1E60; continue 'dispatch;
	}
	// 822B1E28: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B1E2C: 2F0B0053  cmpwi cr6, r11, 0x53
	ctx.cr[6].compare_i32(ctx.r[11].s32, 83, &mut ctx.xer);
	// 822B1E30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1E34: 41990008  bgt cr6, 0x822b1e3c
	if ctx.cr[6].gt {
	pc = 0x822B1E3C; continue 'dispatch;
	}
	// 822B1E38: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B1E3C; continue 'dispatch;
            }
            0x822B1E3C => {
    //   block [0x822B1E3C..0x822B1E60)
	// 822B1E3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B1E40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1E44: 409A001C  bne cr6, 0x822b1e60
	if !ctx.cr[6].eq {
	pc = 0x822B1E60; continue 'dispatch;
	}
	// 822B1E48: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B1E4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B1E50: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822B1E54: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B1E58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1E5C: 48000018  b 0x822b1e74
	pc = 0x822B1E74; continue 'dispatch;
            }
            0x822B1E60 => {
    //   block [0x822B1E60..0x822B1E70)
	// 822B1E60: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B1E64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B1E68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1E6C: 48000008  b 0x822b1e74
	pc = 0x822B1E74; continue 'dispatch;
            }
            0x822B1E70 => {
    //   block [0x822B1E70..0x822B1E74)
	// 822B1E70: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x822B1E74; continue 'dispatch;
            }
            0x822B1E74 => {
    //   block [0x822B1E74..0x822B1ED4)
	// 822B1E74: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822B1E78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B1E7C: 419A0060  beq cr6, 0x822b1edc
	if ctx.cr[6].eq {
	pc = 0x822B1EDC; continue 'dispatch;
	}
	// 822B1E80: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822B1E84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822B1E88: 4BF28529  bl 0x821da3b0
	ctx.lr = 0x822B1E8C;
	sub_821DA3B0(ctx, base);
	// 822B1E8C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 822B1E90: 38EBC1E8  addi r7, r11, -0x3e18
	ctx.r[7].s64 = ctx.r[11].s64 + -15896;
	// 822B1E94: 4BF00665  bl 0x821b24f8
	ctx.lr = 0x822B1E98;
	sub_821B24F8(ctx, base);
	// 822B1E98: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 822B1E9C: 480716A5  bl 0x82323540
	ctx.lr = 0x822B1EA0;
	sub_82323540(ctx, base);
	// 822B1EA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822B1EA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B1EA8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B1EAC: 4BF7B025  bl 0x8222ced0
	ctx.lr = 0x822B1EB0;
	sub_8222CED0(ctx, base);
	// 822B1EB0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822B1EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1EB8: 419A001C  beq cr6, 0x822b1ed4
	if ctx.cr[6].eq {
	pc = 0x822B1ED4; continue 'dispatch;
	}
	// 822B1EBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1EC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B1EC4: 419A0010  beq cr6, 0x822b1ed4
	if ctx.cr[6].eq {
	pc = 0x822B1ED4; continue 'dispatch;
	}
	// 822B1EC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B1ECC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B1ED0: 4BFB32D1  bl 0x822651a0
	ctx.lr = 0x822B1ED4;
	sub_822651A0(ctx, base);
	pc = 0x822B1ED4; continue 'dispatch;
            }
            0x822B1ED4 => {
    //   block [0x822B1ED4..0x822B1EDC)
	// 822B1ED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B1ED8: 4BF62F01  bl 0x82214dd8
	ctx.lr = 0x822B1EDC;
	sub_82214DD8(ctx, base);
	pc = 0x822B1EDC; continue 'dispatch;
            }
            0x822B1EDC => {
    //   block [0x822B1EDC..0x822B1F24)
	// 822B1EDC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822B1EE0: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1EE4: 3BFD0408  addi r31, r29, 0x408
	ctx.r[31].s64 = ctx.r[29].s64 + 1032;
	// 822B1EE8: 38CBC23C  addi r6, r11, -0x3dc4
	ctx.r[6].s64 = ctx.r[11].s64 + -15812;
	// 822B1EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B1EF0: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 822B1EF4: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 822B1EF8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 822B1EFC: 4855540D  bl 0x82807308
	ctx.lr = 0x822B1F00;
	sub_82807308(ctx, base);
	// 822B1F00: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 822B1F04: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B1F08: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B1F10: 48555A89  bl 0x82807998
	ctx.lr = 0x822B1F14;
	sub_82807998(ctx, base);
	// 822B1F14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B1F18: 4BF62EC1  bl 0x82214dd8
	ctx.lr = 0x822B1F1C;
	sub_82214DD8(ctx, base);
	// 822B1F1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822B1F20: 489F753C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B1F24 => {
    //   block [0x822B1F24..0x822B1F54)
	// 822B1F24: 817D041C  lwz r11, 0x41c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1052 as u32) ) } as u64;
	// 822B1F28: 387D0408  addi r3, r29, 0x408
	ctx.r[3].s64 = ctx.r[29].s64 + 1032;
	// 822B1F2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1F30: 419A0024  beq cr6, 0x822b1f54
	if ctx.cr[6].eq {
	pc = 0x822B1F54; continue 'dispatch;
	}
	// 822B1F34: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822B1F38: C1AB0018  lfs f13, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B1F3C: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B1F40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B1F44: C00A9484  lfs f0, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B1F48: ED6D603A  fmadds f11, f13, f0, f12
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 822B1F4C: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 822B1F50: 41990008  bgt cr6, 0x822b1f58
	if ctx.cr[6].gt {
	pc = 0x822B1F58; continue 'dispatch;
	}
	pc = 0x822B1F54; continue 'dispatch;
            }
            0x822B1F54 => {
    //   block [0x822B1F54..0x822B1F58)
	// 822B1F54: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B1F58; continue 'dispatch;
            }
            0x822B1F58 => {
    //   block [0x822B1F58..0x822B1F70)
	// 822B1F58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B1F5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1F60: 419A0010  beq cr6, 0x822b1f70
	if ctx.cr[6].eq {
	pc = 0x822B1F70; continue 'dispatch;
	}
	// 822B1F64: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B1F68: 48555D49  bl 0x82807cb0
	ctx.lr = 0x822B1F6C;
	sub_82807CB0(ctx, base);
	// 822B1F6C: 93DD017C  stw r30, 0x17c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(380 as u32), ctx.r[30].u32 ) };
	pc = 0x822B1F70; continue 'dispatch;
            }
            0x822B1F70 => {
    //   block [0x822B1F70..0x822B1F78)
	// 822B1F70: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822B1F74: 489F74E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B1F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B1F78 size=3404
    let mut pc: u32 = 0x822B1F78;
    'dispatch: loop {
        match pc {
            0x822B1F78 => {
    //   block [0x822B1F78..0x822B1FC4)
	// 822B1F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B1F7C: 489F747D  bl 0x82ca93f8
	ctx.lr = 0x822B1F80;
	sub_82CA93D0(ctx, base);
	// 822B1F80: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 822B1F84: 489FBD49  bl 0x82cadccc
	ctx.lr = 0x822B1F88;
	sub_82CADCA0(ctx, base);
	// 822B1F88: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 822B1F8C: 48D54A41  bl 0x830069cc
	ctx.lr = 0x822B1F90;
	sub_83006760(ctx, base);
	// 822B1F90: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B1F94: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 822B1F98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822B1F9C: 3B190004  addi r24, r25, 4
	ctx.r[24].s64 = ctx.r[25].s64 + 4;
	// 822B1FA0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 822B1FA4: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B1FA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1FAC: 419A0020  beq cr6, 0x822b1fcc
	if ctx.cr[6].eq {
	pc = 0x822B1FCC; continue 'dispatch;
	}
	// 822B1FB0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B1FB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B1FB8: 419A000C  beq cr6, 0x822b1fc4
	if ctx.cr[6].eq {
	pc = 0x822B1FC4; continue 'dispatch;
	}
	// 822B1FBC: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 822B1FC0: 48000010  b 0x822b1fd0
	pc = 0x822B1FD0; continue 'dispatch;
            }
            0x822B1FC4 => {
    //   block [0x822B1FC4..0x822B1FCC)
	// 822B1FC4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822B1FC8: 4BEE1E71  bl 0x82193e38
	ctx.lr = 0x822B1FCC;
	sub_82193E38(ctx, base);
	pc = 0x822B1FCC; continue 'dispatch;
            }
            0x822B1FCC => {
    //   block [0x822B1FCC..0x822B1FD0)
	// 822B1FCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x822B1FD0; continue 'dispatch;
            }
            0x822B1FD0 => {
    //   block [0x822B1FD0..0x822B1FE4)
	// 822B1FD0: 48003391  bl 0x822b5360
	ctx.lr = 0x822B1FD4;
	sub_822B5360(ctx, base);
	// 822B1FD4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B1FD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1FDC: 409A0008  bne cr6, 0x822b1fe4
	if !ctx.cr[6].eq {
	pc = 0x822B1FE4; continue 'dispatch;
	}
	// 822B1FE0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x822B1FE4; continue 'dispatch;
            }
            0x822B1FE4 => {
    //   block [0x822B1FE4..0x822B2038)
	// 822B1FE4: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 822B1FE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B1FEC: 419A0CC0  beq cr6, 0x822b2cac
	if ctx.cr[6].eq {
	pc = 0x822B2CAC; continue 'dispatch;
	}
	// 822B1FF0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822B1FF4: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 822B1FF8: 4BEC1E41  bl 0x82173e38
	ctx.lr = 0x822B1FFC;
	sub_82173E38(ctx, base);
	// 822B1FFC: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822B2000: 556A97FE  rlwinm r10, r11, 0x12, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00003FFFu64;
	// 822B2004: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B2008: 419A00F4  beq cr6, 0x822b20fc
	if ctx.cr[6].eq {
	pc = 0x822B20FC; continue 'dispatch;
	}
	// 822B200C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B2010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B2014: 419A0024  beq cr6, 0x822b2038
	if ctx.cr[6].eq {
	pc = 0x822B2038; continue 'dispatch;
	}
	// 822B2018: 894B006E  lbz r10, 0x6e(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(110 as u32) ) } as u64;
	// 822B201C: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B2020: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B2024: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B2028: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B202C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822B2030: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B2034: 480000CC  b 0x822b2100
	pc = 0x822B2100; continue 'dispatch;
            }
            0x822B2038 => {
    //   block [0x822B2038..0x822B2054)
	// 822B2038: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B203C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B2040: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 822B2044: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B2048: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 822B204C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B2050: 40810054  ble 0x822b20a4
	if !ctx.cr[0].gt {
	pc = 0x822B20A4; continue 'dispatch;
	}
	pc = 0x822B2054; continue 'dispatch;
            }
            0x822B2054 => {
    //   block [0x822B2054..0x822B2074)
	// 822B2054: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B2058: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B205C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822B2060: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B2064: 2F07006E  cmpwi cr6, r7, 0x6e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 110, &mut ctx.xer);
	// 822B2068: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B206C: 41980008  blt cr6, 0x822b2074
	if ctx.cr[6].lt {
	pc = 0x822B2074; continue 'dispatch;
	}
	// 822B2070: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x822B2074; continue 'dispatch;
            }
            0x822B2074 => {
    //   block [0x822B2074..0x822B2090)
	// 822B2074: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B2078: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B207C: 419A0014  beq cr6, 0x822b2090
	if ctx.cr[6].eq {
	pc = 0x822B2090; continue 'dispatch;
	}
	// 822B2080: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B2084: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B2088: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B208C: 4800000C  b 0x822b2098
	pc = 0x822B2098; continue 'dispatch;
            }
            0x822B2090 => {
    //   block [0x822B2090..0x822B2098)
	// 822B2090: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B2094: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B2098; continue 'dispatch;
            }
            0x822B2098 => {
    //   block [0x822B2098..0x822B20A4)
	// 822B2098: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B209C: 4199FFB8  bgt cr6, 0x822b2054
	if ctx.cr[6].gt {
	pc = 0x822B2054; continue 'dispatch;
	}
	// 822B20A0: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	pc = 0x822B20A4; continue 'dispatch;
            }
            0x822B20A4 => {
    //   block [0x822B20A4..0x822B20C0)
	// 822B20A4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B20A8: 419A0040  beq cr6, 0x822b20e8
	if ctx.cr[6].eq {
	pc = 0x822B20E8; continue 'dispatch;
	}
	// 822B20AC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B20B0: 2F0B006E  cmpwi cr6, r11, 0x6e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 110, &mut ctx.xer);
	// 822B20B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B20B8: 41990008  bgt cr6, 0x822b20c0
	if ctx.cr[6].gt {
	pc = 0x822B20C0; continue 'dispatch;
	}
	// 822B20BC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B20C0; continue 'dispatch;
            }
            0x822B20C0 => {
    //   block [0x822B20C0..0x822B20E8)
	// 822B20C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B20C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B20C8: 409A0020  bne cr6, 0x822b20e8
	if !ctx.cr[6].eq {
	pc = 0x822B20E8; continue 'dispatch;
	}
	// 822B20CC: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 822B20D0: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 822B20D4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 822B20D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B20DC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822B20E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B20E4: 4800001C  b 0x822b2100
	pc = 0x822B2100; continue 'dispatch;
            }
            0x822B20E8 => {
    //   block [0x822B20E8..0x822B20FC)
	// 822B20E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B20EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B20F0: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822B20F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B20F8: 48000008  b 0x822b2100
	pc = 0x822B2100; continue 'dispatch;
            }
            0x822B20FC => {
    //   block [0x822B20FC..0x822B2100)
	// 822B20FC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B2100; continue 'dispatch;
            }
            0x822B2100 => {
    //   block [0x822B2100..0x822B21A8)
	// 822B2100: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B2104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B2108: 419A0BA4  beq cr6, 0x822b2cac
	if ctx.cr[6].eq {
	pc = 0x822B2CAC; continue 'dispatch;
	}
	// 822B210C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B2110: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822B2114: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 822B2118: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 822B211C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B2120: 4E800421  bctrl
	ctx.lr = 0x822B2124;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B2124: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822B2128: 4BEC1D11  bl 0x82173e38
	ctx.lr = 0x822B212C;
	sub_82173E38(ctx, base);
	// 822B212C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 822B2130: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822B2134: 8089007C  lwz r4, 0x7c(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 822B2138: 4BFB6AE9  bl 0x82268c20
	ctx.lr = 0x822B213C;
	sub_82268C20(ctx, base);
	// 822B213C: C001007C  lfs f0, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B2140: 3F40820A  lis r26, -0x7df6
	ctx.r[26].s64 = -2113273856;
	// 822B2144: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 822B2148: C1BA9A80  lfs f13, -0x6580(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B214C: C0010078  lfs f0, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B2150: ED60603A  fmadds f11, f0, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 822B2154: EF20582C  fsqrts f25, f11
	ctx.f[25].f64 = ((ctx.f[11].f64).sqrt() as f32) as f64;
	// 822B2158: FF196800  fcmpu cr6, f25, f13
	ctx.cr[6].compare_f64(ctx.f[25].f64, ctx.f[13].f64);
	// 822B215C: 409901A8  ble cr6, 0x822b2304
	if !ctx.cr[6].gt {
	pc = 0x822B2304; continue 'dispatch;
	}
	// 822B2160: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822B2164: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 822B2168: 4BEC1CD1  bl 0x82173e38
	ctx.lr = 0x822B216C;
	sub_82173E38(ctx, base);
	// 822B216C: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 822B2170: 556A7FFE  rlwinm r10, r11, 0xf, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0001FFFFu64;
	// 822B2174: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B2178: 419A00F4  beq cr6, 0x822b226c
	if ctx.cr[6].eq {
	pc = 0x822B226C; continue 'dispatch;
	}
	// 822B217C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B2180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B2184: 419A0024  beq cr6, 0x822b21a8
	if ctx.cr[6].eq {
	pc = 0x822B21A8; continue 'dispatch;
	}
	// 822B2188: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 822B218C: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B2190: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B2194: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B2198: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B219C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B21A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B21A4: 480000CC  b 0x822b2270
	pc = 0x822B2270; continue 'dispatch;
            }
            0x822B21A8 => {
    //   block [0x822B21A8..0x822B21C4)
	// 822B21A8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B21AC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B21B0: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 822B21B4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B21B8: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 822B21BC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B21C0: 40810054  ble 0x822b2214
	if !ctx.cr[0].gt {
	pc = 0x822B2214; continue 'dispatch;
	}
	pc = 0x822B21C4; continue 'dispatch;
            }
            0x822B21C4 => {
    //   block [0x822B21C4..0x822B21E4)
	// 822B21C4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B21C8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B21CC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822B21D0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B21D4: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 822B21D8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B21DC: 41980008  blt cr6, 0x822b21e4
	if ctx.cr[6].lt {
	pc = 0x822B21E4; continue 'dispatch;
	}
	// 822B21E0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x822B21E4; continue 'dispatch;
            }
            0x822B21E4 => {
    //   block [0x822B21E4..0x822B2200)
	// 822B21E4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B21E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B21EC: 419A0014  beq cr6, 0x822b2200
	if ctx.cr[6].eq {
	pc = 0x822B2200; continue 'dispatch;
	}
	// 822B21F0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B21F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B21F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B21FC: 4800000C  b 0x822b2208
	pc = 0x822B2208; continue 'dispatch;
            }
            0x822B2200 => {
    //   block [0x822B2200..0x822B2208)
	// 822B2200: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B2204: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B2208; continue 'dispatch;
            }
            0x822B2208 => {
    //   block [0x822B2208..0x822B2214)
	// 822B2208: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B220C: 4199FFB8  bgt cr6, 0x822b21c4
	if ctx.cr[6].gt {
	pc = 0x822B21C4; continue 'dispatch;
	}
	// 822B2210: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	pc = 0x822B2214; continue 'dispatch;
            }
            0x822B2214 => {
    //   block [0x822B2214..0x822B2230)
	// 822B2214: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B2218: 419A0040  beq cr6, 0x822b2258
	if ctx.cr[6].eq {
	pc = 0x822B2258; continue 'dispatch;
	}
	// 822B221C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B2220: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 822B2224: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B2228: 41990008  bgt cr6, 0x822b2230
	if ctx.cr[6].gt {
	pc = 0x822B2230; continue 'dispatch;
	}
	// 822B222C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B2230; continue 'dispatch;
            }
            0x822B2230 => {
    //   block [0x822B2230..0x822B2258)
	// 822B2230: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B2234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B2238: 409A0020  bne cr6, 0x822b2258
	if !ctx.cr[6].eq {
	pc = 0x822B2258; continue 'dispatch;
	}
	// 822B223C: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 822B2240: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 822B2244: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822B2248: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B224C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B2250: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B2254: 4800001C  b 0x822b2270
	pc = 0x822B2270; continue 'dispatch;
            }
            0x822B2258 => {
    //   block [0x822B2258..0x822B226C)
	// 822B2258: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B225C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B2260: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B2264: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B2268: 48000008  b 0x822b2270
	pc = 0x822B2270; continue 'dispatch;
            }
            0x822B226C => {
    //   block [0x822B226C..0x822B2270)
	// 822B226C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B2270; continue 'dispatch;
            }
            0x822B2270 => {
    //   block [0x822B2270..0x822B22B4)
	// 822B2270: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B2274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B2278: 419A008C  beq cr6, 0x822b2304
	if ctx.cr[6].eq {
	pc = 0x822B2304; continue 'dispatch;
	}
	// 822B227C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B2280: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822B2284: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822B2288: 814B0070  lwz r10, 0x70(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 822B228C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B2290: 4E800421  bctrl
	ctx.lr = 0x822B2294;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B2294: 81210088  lwz r9, 0x88(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 822B2298: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822B229C: 41980018  blt cr6, 0x822b22b4
	if ctx.cr[6].lt {
	pc = 0x822B22B4; continue 'dispatch;
	}
	// 822B22A0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822B22A4: 4BFE6495  bl 0x82298738
	ctx.lr = 0x822B22A8;
	sub_82298738(ctx, base);
	// 822B22A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B22AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B22B0: 409A0008  bne cr6, 0x822b22b8
	if !ctx.cr[6].eq {
	pc = 0x822B22B8; continue 'dispatch;
	}
            }
            0x822B22B4 => {
    //   block [0x822B22B4..0x822B22B8)
	// 822B22B4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B22B8; continue 'dispatch;
            }
            0x822B22B8 => {
    //   block [0x822B22B8..0x822B22EC)
	// 822B22B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B22BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B22C0: 419A002C  beq cr6, 0x822b22ec
	if ctx.cr[6].eq {
	pc = 0x822B22EC; continue 'dispatch;
	}
	// 822B22C4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822B22C8: 48003499  bl 0x822b5760
	ctx.lr = 0x822B22CC;
	sub_822B5760(ctx, base);
	// 822B22CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B22D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B22D4: 409A0018  bne cr6, 0x822b22ec
	if !ctx.cr[6].eq {
	pc = 0x822B22EC; continue 'dispatch;
	}
	// 822B22D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B22DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B22E0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B22E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B22E8: 4E800421  bctrl
	ctx.lr = 0x822B22EC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822B22EC => {
    //   block [0x822B22EC..0x822B2304)
	// 822B22EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822B22F0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822B22F4: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 822B22F8: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 822B22FC: 4BEE1B3D  bl 0x82193e38
	ctx.lr = 0x822B2300;
	sub_82193E38(ctx, base);
	// 822B2300: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	pc = 0x822B2304; continue 'dispatch;
            }
            0x822B2304 => {
    //   block [0x822B2304..0x822B23E4)
	// 822B2304: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822B2308: 4BEC1B31  bl 0x82173e38
	ctx.lr = 0x822B230C;
	sub_82173E38(ctx, base);
	// 822B230C: 4BF554E5  bl 0x822077f0
	ctx.lr = 0x822B2310;
	sub_822077F0(ctx, base);
	// 822B2310: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822B2314: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B2318: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822B231C: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 822B2320: FC010024  fdiv f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 822B2324: 812A0044  lwz r9, 0x44(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 822B2328: FF400018  frsp f26, f0
	ctx.f[26].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822B232C: D3410064  stfs f26, 0x64(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822B2330: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822B2334: 4E800421  bctrl
	ctx.lr = 0x822B2338;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B2338: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 822B233C: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 822B2340: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B2344: D3A10060  stfs f29, 0x60(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822B2348: 388819F8  addi r4, r8, 0x19f8
	ctx.r[4].s64 = ctx.r[8].s64 + 6648;
	// 822B234C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B2350: 4BF7AB81  bl 0x8222ced0
	ctx.lr = 0x822B2354;
	sub_8222CED0(ctx, base);
	// 822B2354: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B2358: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822B235C: 48324125  bl 0x825d6480
	ctx.lr = 0x822B2360;
	sub_825D6480(ctx, base);
	// 822B2360: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B2364: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 822B2368: 4BF62A71  bl 0x82214dd8
	ctx.lr = 0x822B236C;
	sub_82214DD8(ctx, base);
	// 822B236C: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 822B2370: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B2374: 38876514  addi r4, r7, 0x6514
	ctx.r[4].s64 = ctx.r[7].s64 + 25876;
	// 822B2378: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B237C: 4BF7AB55  bl 0x8222ced0
	ctx.lr = 0x822B2380;
	sub_8222CED0(ctx, base);
	// 822B2380: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B2384: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822B2388: 483240F9  bl 0x825d6480
	ctx.lr = 0x822B238C;
	sub_825D6480(ctx, base);
	// 822B238C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B2390: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822B2394: 4BF62A45  bl 0x82214dd8
	ctx.lr = 0x822B2398;
	sub_82214DD8(ctx, base);
	// 822B2398: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822B239C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 822B23A0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 822B23A4: 4BEC1A95  bl 0x82173e38
	ctx.lr = 0x822B23A8;
	sub_82173E38(ctx, base);
	// 822B23A8: 80C30034  lwz r6, 0x34(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 822B23AC: 54C577FE  rlwinm r5, r6, 0xe, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0003FFFFu64;
	// 822B23B0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 822B23B4: 419A00F4  beq cr6, 0x822b24a8
	if ctx.cr[6].eq {
	pc = 0x822B24A8; continue 'dispatch;
	}
	// 822B23B8: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B23BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B23C0: 419A0024  beq cr6, 0x822b23e4
	if ctx.cr[6].eq {
	pc = 0x822B23E4; continue 'dispatch;
	}
	// 822B23C4: 894B0092  lbz r10, 0x92(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(146 as u32) ) } as u64;
	// 822B23C8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B23CC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B23D0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B23D4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B23D8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B23DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B23E0: 480000CC  b 0x822b24ac
	pc = 0x822B24AC; continue 'dispatch;
            }
            0x822B23E4 => {
    //   block [0x822B23E4..0x822B2400)
	// 822B23E4: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B23E8: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B23EC: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 822B23F0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B23F4: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 822B23F8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B23FC: 40810054  ble 0x822b2450
	if !ctx.cr[0].gt {
	pc = 0x822B2450; continue 'dispatch;
	}
	pc = 0x822B2400; continue 'dispatch;
            }
            0x822B2400 => {
    //   block [0x822B2400..0x822B2420)
	// 822B2400: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B2404: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B2408: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822B240C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B2410: 2F070092  cmpwi cr6, r7, 0x92
	ctx.cr[6].compare_i32(ctx.r[7].s32, 146, &mut ctx.xer);
	// 822B2414: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B2418: 41980008  blt cr6, 0x822b2420
	if ctx.cr[6].lt {
	pc = 0x822B2420; continue 'dispatch;
	}
	// 822B241C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x822B2420; continue 'dispatch;
            }
            0x822B2420 => {
    //   block [0x822B2420..0x822B243C)
	// 822B2420: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B2424: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B2428: 419A0014  beq cr6, 0x822b243c
	if ctx.cr[6].eq {
	pc = 0x822B243C; continue 'dispatch;
	}
	// 822B242C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B2430: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B2434: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B2438: 4800000C  b 0x822b2444
	pc = 0x822B2444; continue 'dispatch;
            }
            0x822B243C => {
    //   block [0x822B243C..0x822B2444)
	// 822B243C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B2440: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B2444; continue 'dispatch;
            }
            0x822B2444 => {
    //   block [0x822B2444..0x822B2450)
	// 822B2444: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B2448: 4199FFB8  bgt cr6, 0x822b2400
	if ctx.cr[6].gt {
	pc = 0x822B2400; continue 'dispatch;
	}
	// 822B244C: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	pc = 0x822B2450; continue 'dispatch;
            }
            0x822B2450 => {
    //   block [0x822B2450..0x822B246C)
	// 822B2450: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B2454: 419A0040  beq cr6, 0x822b2494
	if ctx.cr[6].eq {
	pc = 0x822B2494; continue 'dispatch;
	}
	// 822B2458: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B245C: 2F0B0092  cmpwi cr6, r11, 0x92
	ctx.cr[6].compare_i32(ctx.r[11].s32, 146, &mut ctx.xer);
	// 822B2460: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B2464: 41990008  bgt cr6, 0x822b246c
	if ctx.cr[6].gt {
	pc = 0x822B246C; continue 'dispatch;
	}
	// 822B2468: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B246C; continue 'dispatch;
            }
            0x822B246C => {
    //   block [0x822B246C..0x822B2494)
	// 822B246C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B2470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B2474: 409A0020  bne cr6, 0x822b2494
	if !ctx.cr[6].eq {
	pc = 0x822B2494; continue 'dispatch;
	}
	// 822B2478: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 822B247C: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 822B2480: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822B2484: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B2488: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B248C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B2490: 4800001C  b 0x822b24ac
	pc = 0x822B24AC; continue 'dispatch;
            }
            0x822B2494 => {
    //   block [0x822B2494..0x822B24A8)
	// 822B2494: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B2498: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B249C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B24A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B24A4: 48000008  b 0x822b24ac
	pc = 0x822B24AC; continue 'dispatch;
            }
            0x822B24A8 => {
    //   block [0x822B24A8..0x822B24AC)
	// 822B24A8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B24AC; continue 'dispatch;
            }
            0x822B24AC => {
    //   block [0x822B24AC..0x822B2508)
	// 822B24AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B24B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B24B4: 419A0174  beq cr6, 0x822b2628
	if ctx.cr[6].eq {
	pc = 0x822B2628; continue 'dispatch;
	}
	// 822B24B8: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 822B24BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B24C0: 419A0168  beq cr6, 0x822b2628
	if ctx.cr[6].eq {
	pc = 0x822B2628; continue 'dispatch;
	}
	// 822B24C4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822B24C8: 4BEC1971  bl 0x82173e38
	ctx.lr = 0x822B24CC;
	sub_82173E38(ctx, base);
	// 822B24CC: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 822B24D0: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822B24D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B24D8: 419A00F4  beq cr6, 0x822b25cc
	if ctx.cr[6].eq {
	pc = 0x822B25CC; continue 'dispatch;
	}
	// 822B24DC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B24E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B24E4: 419A0024  beq cr6, 0x822b2508
	if ctx.cr[6].eq {
	pc = 0x822B2508; continue 'dispatch;
	}
	// 822B24E8: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822B24EC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B24F0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B24F4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B24F8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B24FC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 822B2500: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B2504: 480000CC  b 0x822b25d0
	pc = 0x822B25D0; continue 'dispatch;
            }
            0x822B2508 => {
    //   block [0x822B2508..0x822B2524)
	// 822B2508: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B250C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B2510: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 822B2514: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B2518: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 822B251C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B2520: 40810054  ble 0x822b2574
	if !ctx.cr[0].gt {
	pc = 0x822B2574; continue 'dispatch;
	}
	pc = 0x822B2524; continue 'dispatch;
            }
            0x822B2524 => {
    //   block [0x822B2524..0x822B2544)
	// 822B2524: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B2528: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B252C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822B2530: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B2534: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 822B2538: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B253C: 41980008  blt cr6, 0x822b2544
	if ctx.cr[6].lt {
	pc = 0x822B2544; continue 'dispatch;
	}
	// 822B2540: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x822B2544; continue 'dispatch;
            }
            0x822B2544 => {
    //   block [0x822B2544..0x822B2560)
	// 822B2544: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B2548: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B254C: 419A0014  beq cr6, 0x822b2560
	if ctx.cr[6].eq {
	pc = 0x822B2560; continue 'dispatch;
	}
	// 822B2550: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B2554: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B2558: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B255C: 4800000C  b 0x822b2568
	pc = 0x822B2568; continue 'dispatch;
            }
            0x822B2560 => {
    //   block [0x822B2560..0x822B2568)
	// 822B2560: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B2564: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B2568; continue 'dispatch;
            }
            0x822B2568 => {
    //   block [0x822B2568..0x822B2574)
	// 822B2568: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B256C: 4199FFB8  bgt cr6, 0x822b2524
	if ctx.cr[6].gt {
	pc = 0x822B2524; continue 'dispatch;
	}
	// 822B2570: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	pc = 0x822B2574; continue 'dispatch;
            }
            0x822B2574 => {
    //   block [0x822B2574..0x822B2590)
	// 822B2574: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B2578: 419A0040  beq cr6, 0x822b25b8
	if ctx.cr[6].eq {
	pc = 0x822B25B8; continue 'dispatch;
	}
	// 822B257C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B2580: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 822B2584: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B2588: 41990008  bgt cr6, 0x822b2590
	if ctx.cr[6].gt {
	pc = 0x822B2590; continue 'dispatch;
	}
	// 822B258C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B2590; continue 'dispatch;
            }
            0x822B2590 => {
    //   block [0x822B2590..0x822B25B8)
	// 822B2590: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B2594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B2598: 409A0020  bne cr6, 0x822b25b8
	if !ctx.cr[6].eq {
	pc = 0x822B25B8; continue 'dispatch;
	}
	// 822B259C: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 822B25A0: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 822B25A4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822B25A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B25AC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 822B25B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B25B4: 4800001C  b 0x822b25d0
	pc = 0x822B25D0; continue 'dispatch;
            }
            0x822B25B8 => {
    //   block [0x822B25B8..0x822B25CC)
	// 822B25B8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B25BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B25C0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 822B25C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B25C8: 48000008  b 0x822b25d0
	pc = 0x822B25D0; continue 'dispatch;
            }
            0x822B25CC => {
    //   block [0x822B25CC..0x822B25D0)
	// 822B25CC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x822B25D0; continue 'dispatch;
            }
            0x822B25D0 => {
    //   block [0x822B25D0..0x822B25F4)
	// 822B25D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B25D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B25D8: 419A0050  beq cr6, 0x822b2628
	if ctx.cr[6].eq {
	pc = 0x822B2628; continue 'dispatch;
	}
	// 822B25DC: 897D001E  lbz r11, 0x1e(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(30 as u32) ) } as u64;
	// 822B25E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B25E4: 419A0010  beq cr6, 0x822b25f4
	if ctx.cr[6].eq {
	pc = 0x822B25F4; continue 'dispatch;
	}
	// 822B25E8: 897D001F  lbz r11, 0x1f(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(31 as u32) ) } as u64;
	// 822B25EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B25F0: 419A0038  beq cr6, 0x822b2628
	if ctx.cr[6].eq {
	pc = 0x822B2628; continue 'dispatch;
	}
	pc = 0x822B25F4; continue 'dispatch;
            }
            0x822B25F4 => {
    //   block [0x822B25F4..0x822B2628)
	// 822B25F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822B25F8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B25FC: 388B1BA4  addi r4, r11, 0x1ba4
	ctx.r[4].s64 = ctx.r[11].s64 + 7076;
	// 822B2600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B2604: 4BF7A8CD  bl 0x8222ced0
	ctx.lr = 0x822B2608;
	sub_8222CED0(ctx, base);
	// 822B2608: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B260C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822B2610: 48323E71  bl 0x825d6480
	ctx.lr = 0x822B2614;
	sub_825D6480(ctx, base);
	// 822B2614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B2618: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 822B261C: 4BF627BD  bl 0x82214dd8
	ctx.lr = 0x822B2620;
	sub_82214DD8(ctx, base);
	// 822B2620: EFBE0772  fmuls f29, f30, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (((ctx.f[30].f64 * ctx.f[29].f64) as f32) as f64);
	// 822B2624: D3A10060  stfs f29, 0x60(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	pc = 0x822B2628; continue 'dispatch;
            }
            0x822B2628 => {
    //   block [0x822B2628..0x822B2CAC)
	// 822B2628: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B262C: EC1FE028  fsubs f0, f31, f28
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[28].f64) as f32) as f64);
	// 822B2630: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 822B2634: 3BAB90F0  addi r29, r11, -0x6f10
	ctx.r[29].s64 = ctx.r[11].s64 + -28432;
	// 822B2638: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822B263C: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 822B2640: 3B6ACFCC  addi r27, r10, -0x3034
	ctx.r[27].s64 = ctx.r[10].s64 + -12340;
	pc = 0x822B2CAC; continue 'dispatch;
            }
            0x822B2CAC => {
    //   block [0x822B2CAC..0x822B2CC4)
	// 822B2CAC: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 822B2CB0: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 822B2CB4: 48D53FB1  bl 0x83006c64
	ctx.lr = 0x822B2CB8;
	sub_830069F8(ctx, base);
	// 822B2CB8: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 822B2CBC: 489FB05D  bl 0x82cadd18
	ctx.lr = 0x822B2CC0;
	sub_82CADCEC(ctx, base);
	// 822B2CC0: 489F6788  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B2CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822B2CC8 size=604
    let mut pc: u32 = 0x822B2CC8;
    'dispatch: loop {
        match pc {
            0x822B2CC8 => {
    //   block [0x822B2CC8..0x822B2F24)
	// 822B2CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B2CCC: 489F6739  bl 0x82ca9404
	ctx.lr = 0x822B2CD0;
	sub_82CA93D0(ctx, base);
	// 822B2CD0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 822B2CD4: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B2F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822B2F28 size=16
    let mut pc: u32 = 0x822B2F28;
    'dispatch: loop {
        match pc {
            0x822B2F28 => {
    //   block [0x822B2F28..0x822B2F38)
	// 822B2F28: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822B2F2C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822B2F30: 49006C54  b 0x832b9b84
	crate::xam::XamInputGetState(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B2F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B2F38 size=1596
    let mut pc: u32 = 0x822B2F38;
    'dispatch: loop {
        match pc {
            0x822B2F38 => {
    //   block [0x822B2F38..0x822B2FC4)
	// 822B2F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B2F3C: 489F64BD  bl 0x82ca93f8
	ctx.lr = 0x822B2F40;
	sub_82CA93D0(ctx, base);
	// 822B2F40: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B2F44: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822B2F48: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 822B2F4C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 822B2F50: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 822B2F54: 816A9650  lwz r11, -0x69b0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822B2F58: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822B2F5C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 822B2F60: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B2F64: 7D0B4BD6  divw r8, r11, r9
	ctx.r[8].s32 = ctx.r[11].s32 / ctx.r[9].s32;
	// 822B2F68: 7CE849D6  mullw r7, r8, r9
	ctx.r[7].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 822B2F6C: 7CC75851  subf. r6, r7, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 822B2F70: 408205FC  bne 0x822b356c
	if !ctx.cr[0].eq {
	pc = 0x822B356C; continue 'dispatch;
	}
	// 822B2F74: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822B2F78: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 822B2F7C: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	// 822B2F80: 7F9AE378  mr r26, r28
	ctx.r[26].u64 = ctx.r[28].u64;
	// 822B2F84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B2F88: 419A0564  beq cr6, 0x822b34ec
	if ctx.cr[6].eq {
	pc = 0x822B34EC; continue 'dispatch;
	}
	// 822B2F8C: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 822B2F90: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822B2F94: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B2F98: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B2F9C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B2FA0: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B2FA4: 48632AD5  bl 0x828e5a78
	ctx.lr = 0x822B2FA8;
	sub_828E5A78(ctx, base);
	// 822B2FA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B2FAC: 419A0018  beq cr6, 0x822b2fc4
	if ctx.cr[6].eq {
	pc = 0x822B2FC4; continue 'dispatch;
	}
	// 822B2FB0: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 822B2FB4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822B2FB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B2FBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B2FC0: 409A0008  bne cr6, 0x822b2fc8
	if !ctx.cr[6].eq {
	pc = 0x822B2FC8; continue 'dispatch;
	}
	pc = 0x822B2FC4; continue 'dispatch;
            }
            0x822B2FC4 => {
    //   block [0x822B2FC4..0x822B2FC8)
	// 822B2FC4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822B2FC8; continue 'dispatch;
            }
            0x822B2FC8 => {
    //   block [0x822B2FC8..0x822B3008)
	// 822B2FC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B2FCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B2FD0: 419A051C  beq cr6, 0x822b34ec
	if ctx.cr[6].eq {
	pc = 0x822B34EC; continue 'dispatch;
	}
	// 822B2FD4: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822B2FD8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B2FDC: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B2FE0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B2FE4: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B2FE8: 4BF791D1  bl 0x8222c1b8
	ctx.lr = 0x822B2FEC;
	sub_8222C1B8(ctx, base);
	// 822B2FEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B2FF0: 419A0018  beq cr6, 0x822b3008
	if ctx.cr[6].eq {
	pc = 0x822B3008; continue 'dispatch;
	}
	// 822B2FF4: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 822B2FF8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822B2FFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B3000: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B3004: 409A0008  bne cr6, 0x822b300c
	if !ctx.cr[6].eq {
	pc = 0x822B300C; continue 'dispatch;
	}
	pc = 0x822B3008; continue 'dispatch;
            }
            0x822B3008 => {
    //   block [0x822B3008..0x822B300C)
	// 822B3008: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822B300C; continue 'dispatch;
            }
            0x822B300C => {
    //   block [0x822B300C..0x822B3040)
	// 822B300C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B3010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B3014: 419A04D8  beq cr6, 0x822b34ec
	if ctx.cr[6].eq {
	pc = 0x822B34EC; continue 'dispatch;
	}
	// 822B3018: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B301C: 2F0B0034  cmpwi cr6, r11, 0x34
	ctx.cr[6].compare_i32(ctx.r[11].s32, 52, &mut ctx.xer);
	// 822B3020: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822B3024: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B3028: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B302C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B3030: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B3034: 409A000C  bne cr6, 0x822b3040
	if !ctx.cr[6].eq {
	pc = 0x822B3040; continue 'dispatch;
	}
	// 822B3038: 4BF79181  bl 0x8222c1b8
	ctx.lr = 0x822B303C;
	sub_8222C1B8(ctx, base);
	// 822B303C: 48000008  b 0x822b3044
	pc = 0x822B3044; continue 'dispatch;
            }
            0x822B3040 => {
    //   block [0x822B3040..0x822B3044)
	// 822B3040: 48632A39  bl 0x828e5a78
	ctx.lr = 0x822B3044;
	sub_828E5A78(ctx, base);
	pc = 0x822B3044; continue 'dispatch;
            }
            0x822B3044 => {
    //   block [0x822B3044..0x822B30B8)
	// 822B3044: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822B3048: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822B304C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B3050: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B3054: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B3058: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B305C: 4BF7915D  bl 0x8222c1b8
	ctx.lr = 0x822B3060;
	sub_8222C1B8(ctx, base);
	// 822B3060: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822B3064: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B3068: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B306C: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B3070: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B3074: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B3078: 48632A01  bl 0x828e5a78
	ctx.lr = 0x822B307C;
	sub_828E5A78(ctx, base);
	// 822B307C: 80BF0028  lwz r5, 0x28(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 822B3080: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 822B3084: 54A4FFFE  rlwinm r4, r5, 0x1f, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x00000001u64;
	// 822B3088: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822B308C: 419A00E8  beq cr6, 0x822b3174
	if ctx.cr[6].eq {
	pc = 0x822B3174; continue 'dispatch;
	}
	// 822B3090: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B3094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B3098: 419A0020  beq cr6, 0x822b30b8
	if ctx.cr[6].eq {
	pc = 0x822B30B8; continue 'dispatch;
	}
	// 822B309C: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822B30A0: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B30A4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B30A8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B30AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B30B0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B30B4: 480000C4  b 0x822b3178
	pc = 0x822B3178; continue 'dispatch;
            }
            0x822B30B8 => {
    //   block [0x822B30B8..0x822B30D4)
	// 822B30B8: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B30BC: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B30C0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 822B30C4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B30C8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B30CC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B30D0: 40810054  ble 0x822b3124
	if !ctx.cr[0].gt {
	pc = 0x822B3124; continue 'dispatch;
	}
	pc = 0x822B30D4; continue 'dispatch;
            }
            0x822B30D4 => {
    //   block [0x822B30D4..0x822B30F4)
	// 822B30D4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B30D8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B30DC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822B30E0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B30E4: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 822B30E8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B30EC: 41980008  blt cr6, 0x822b30f4
	if ctx.cr[6].lt {
	pc = 0x822B30F4; continue 'dispatch;
	}
	// 822B30F0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x822B30F4; continue 'dispatch;
            }
            0x822B30F4 => {
    //   block [0x822B30F4..0x822B3110)
	// 822B30F4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B30F8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B30FC: 419A0014  beq cr6, 0x822b3110
	if ctx.cr[6].eq {
	pc = 0x822B3110; continue 'dispatch;
	}
	// 822B3100: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B3104: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B3108: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B310C: 4800000C  b 0x822b3118
	pc = 0x822B3118; continue 'dispatch;
            }
            0x822B3110 => {
    //   block [0x822B3110..0x822B3118)
	// 822B3110: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B3114: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B3118; continue 'dispatch;
            }
            0x822B3118 => {
    //   block [0x822B3118..0x822B3124)
	// 822B3118: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B311C: 4199FFB8  bgt cr6, 0x822b30d4
	if ctx.cr[6].gt {
	pc = 0x822B30D4; continue 'dispatch;
	}
	// 822B3120: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B3124; continue 'dispatch;
            }
            0x822B3124 => {
    //   block [0x822B3124..0x822B3140)
	// 822B3124: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B3128: 419A003C  beq cr6, 0x822b3164
	if ctx.cr[6].eq {
	pc = 0x822B3164; continue 'dispatch;
	}
	// 822B312C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B3130: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 822B3134: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B3138: 41990008  bgt cr6, 0x822b3140
	if ctx.cr[6].gt {
	pc = 0x822B3140; continue 'dispatch;
	}
	// 822B313C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822B3140; continue 'dispatch;
            }
            0x822B3140 => {
    //   block [0x822B3140..0x822B3164)
	// 822B3140: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B3144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B3148: 409A001C  bne cr6, 0x822b3164
	if !ctx.cr[6].eq {
	pc = 0x822B3164; continue 'dispatch;
	}
	// 822B314C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B3150: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B3154: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822B3158: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B315C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B3160: 48000018  b 0x822b3178
	pc = 0x822B3178; continue 'dispatch;
            }
            0x822B3164 => {
    //   block [0x822B3164..0x822B3174)
	// 822B3164: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B3168: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B316C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B3170: 48000008  b 0x822b3178
	pc = 0x822B3178; continue 'dispatch;
            }
            0x822B3174 => {
    //   block [0x822B3174..0x822B3178)
	// 822B3174: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x822B3178; continue 'dispatch;
            }
            0x822B3178 => {
    //   block [0x822B3178..0x822B31A0)
	// 822B3178: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 822B317C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822B3180: 3BA99490  addi r29, r9, -0x6b70
	ctx.r[29].s64 = ctx.r[9].s64 + -27504;
	// 822B3184: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B3188: C01DFFF4  lfs f0, -0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B318C: 419A0014  beq cr6, 0x822b31a0
	if ctx.cr[6].eq {
	pc = 0x822B31A0; continue 'dispatch;
	}
	// 822B3190: C1AB0088  lfs f13, 0x88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B3194: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822B3198: 40990008  ble cr6, 0x822b31a0
	if !ctx.cr[6].gt {
	pc = 0x822B31A0; continue 'dispatch;
	}
	// 822B319C: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	pc = 0x822B31A0; continue 'dispatch;
            }
            0x822B31A0 => {
    //   block [0x822B31A0..0x822B31DC)
	// 822B31A0: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 822B31A4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 822B31A8: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 822B31AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B31B0: 419A00E8  beq cr6, 0x822b3298
	if ctx.cr[6].eq {
	pc = 0x822B3298; continue 'dispatch;
	}
	// 822B31B4: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B31B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B31BC: 419A0020  beq cr6, 0x822b31dc
	if ctx.cr[6].eq {
	pc = 0x822B31DC; continue 'dispatch;
	}
	// 822B31C0: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822B31C4: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B31C8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B31CC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B31D0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B31D4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B31D8: 480000C4  b 0x822b329c
	pc = 0x822B329C; continue 'dispatch;
            }
            0x822B31DC => {
    //   block [0x822B31DC..0x822B31F8)
	// 822B31DC: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B31E0: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B31E4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 822B31E8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B31EC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B31F0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B31F4: 40810054  ble 0x822b3248
	if !ctx.cr[0].gt {
	pc = 0x822B3248; continue 'dispatch;
	}
	pc = 0x822B31F8; continue 'dispatch;
            }
            0x822B31F8 => {
    //   block [0x822B31F8..0x822B3218)
	// 822B31F8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B31FC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B3200: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822B3204: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B3208: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 822B320C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B3210: 41980008  blt cr6, 0x822b3218
	if ctx.cr[6].lt {
	pc = 0x822B3218; continue 'dispatch;
	}
	// 822B3214: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x822B3218; continue 'dispatch;
            }
            0x822B3218 => {
    //   block [0x822B3218..0x822B3234)
	// 822B3218: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B321C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B3220: 419A0014  beq cr6, 0x822b3234
	if ctx.cr[6].eq {
	pc = 0x822B3234; continue 'dispatch;
	}
	// 822B3224: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B3228: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B322C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B3230: 4800000C  b 0x822b323c
	pc = 0x822B323C; continue 'dispatch;
            }
            0x822B3234 => {
    //   block [0x822B3234..0x822B323C)
	// 822B3234: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B3238: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B323C; continue 'dispatch;
            }
            0x822B323C => {
    //   block [0x822B323C..0x822B3248)
	// 822B323C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B3240: 4199FFB8  bgt cr6, 0x822b31f8
	if ctx.cr[6].gt {
	pc = 0x822B31F8; continue 'dispatch;
	}
	// 822B3244: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B3248; continue 'dispatch;
            }
            0x822B3248 => {
    //   block [0x822B3248..0x822B3264)
	// 822B3248: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B324C: 419A003C  beq cr6, 0x822b3288
	if ctx.cr[6].eq {
	pc = 0x822B3288; continue 'dispatch;
	}
	// 822B3250: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B3254: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 822B3258: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B325C: 41990008  bgt cr6, 0x822b3264
	if ctx.cr[6].gt {
	pc = 0x822B3264; continue 'dispatch;
	}
	// 822B3260: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822B3264; continue 'dispatch;
            }
            0x822B3264 => {
    //   block [0x822B3264..0x822B3288)
	// 822B3264: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B3268: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B326C: 409A001C  bne cr6, 0x822b3288
	if !ctx.cr[6].eq {
	pc = 0x822B3288; continue 'dispatch;
	}
	// 822B3270: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B3274: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B3278: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822B327C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B3280: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B3284: 48000018  b 0x822b329c
	pc = 0x822B329C; continue 'dispatch;
            }
            0x822B3288 => {
    //   block [0x822B3288..0x822B3298)
	// 822B3288: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B328C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B3290: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B3294: 48000008  b 0x822b329c
	pc = 0x822B329C; continue 'dispatch;
            }
            0x822B3298 => {
    //   block [0x822B3298..0x822B329C)
	// 822B3298: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x822B329C; continue 'dispatch;
            }
            0x822B329C => {
    //   block [0x822B329C..0x822B32B8)
	// 822B329C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822B32A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B32A4: 419A0014  beq cr6, 0x822b32b8
	if ctx.cr[6].eq {
	pc = 0x822B32B8; continue 'dispatch;
	}
	// 822B32A8: C1AB0088  lfs f13, 0x88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B32AC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822B32B0: 40990008  ble cr6, 0x822b32b8
	if !ctx.cr[6].gt {
	pc = 0x822B32B8; continue 'dispatch;
	}
	// 822B32B4: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	pc = 0x822B32B8; continue 'dispatch;
            }
            0x822B32B8 => {
    //   block [0x822B32B8..0x822B34EC)
	// 822B32B8: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 822B32BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B32C0: 409A022C  bne cr6, 0x822b34ec
	if !ctx.cr[6].eq {
	pc = 0x822B34EC; continue 'dispatch;
	}
	// 822B32C4: 807B6AB8  lwz r3, 0x6ab8(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822B32C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B32CC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822B32D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B32D4: 4E800421  bctrl
	ctx.lr = 0x822B32D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B32D8: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B32DC: 37C90020  addic. r30, r9, 0x20
	ctx.xer.ca = (ctx.r[9].u32 > (!(32 as u32)));
	ctx.r[30].s64 = ctx.r[9].s64 + 32;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822B32E0: 4182020C  beq 0x822b34ec
	if ctx.cr[0].eq {
	pc = 0x822B34EC; continue 'dispatch;
	}
	// 822B32E4: 809A007C  lwz r4, 0x7c(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(124 as u32) ) } as u64;
	// 822B32E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822B32EC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B32F0: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 822B32F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B32F8: 4E800421  bctrl
	ctx.lr = 0x822B32FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B32FC: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 822B3300: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
            }
            0x822B34EC => {
    //   block [0x822B34EC..0x822B356C)
	// 822B34EC: 89580000  lbz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B34F0: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 822B34F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B34F8: 419A0074  beq cr6, 0x822b356c
	if ctx.cr[6].eq {
	pc = 0x822B356C; continue 'dispatch;
	}
	// 822B34FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B3500: 419A004C  beq cr6, 0x822b354c
	if ctx.cr[6].eq {
	pc = 0x822B354C; continue 'dispatch;
	}
	// 822B3504: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822B3508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B350C: 388B0AF8  addi r4, r11, 0xaf8
	ctx.r[4].s64 = ctx.r[11].s64 + 2808;
	// 822B3510: 48022EF9  bl 0x822d6408
	ctx.lr = 0x822B3514;
	sub_822D6408(ctx, base);
	// 822B3514: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822B3518: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822B351C: 80F80008  lwz r7, 8(r24)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B3520: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 822B3524: 3898000C  addi r4, r24, 0xc
	ctx.r[4].s64 = ctx.r[24].s64 + 12;
	// 822B3528: 816A6B08  lwz r11, 0x6b08(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822B352C: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822B3530: 8069001C  lwz r3, 0x1c(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 822B3534: 4812A17D  bl 0x823dd6b0
	ctx.lr = 0x822B3538;
	sub_823DD6B0(ctx, base);
	// 822B3538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B353C: 4BF132BD  bl 0x821c67f8
	ctx.lr = 0x822B3540;
	sub_821C67F8(ctx, base);
	// 822B3540: 9B380000  stb r25, 0(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 822B3544: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 822B3548: 489F5F00  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
	// 822B354C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822B3550: 38B8000C  addi r5, r24, 0xc
	ctx.r[5].s64 = ctx.r[24].s64 + 12;
	// 822B3554: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822B3558: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822B355C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822B3560: 806A001C  lwz r3, 0x1c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 822B3564: 4BF0A235  bl 0x821bd798
	ctx.lr = 0x822B3568;
	sub_821BD798(ctx, base);
	// 822B3568: 9B380000  stb r25, 0(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
            }
            0x822B356C => {
    //   block [0x822B356C..0x822B3574)
	// 822B356C: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 822B3570: 489F5ED8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B3578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B3578 size=836
    let mut pc: u32 = 0x822B3578;
    'dispatch: loop {
        match pc {
            0x822B3578 => {
    //   block [0x822B3578..0x822B3604)
	// 822B3578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B357C: 489F5E89  bl 0x82ca9404
	ctx.lr = 0x822B3580;
	sub_82CA93D0(ctx, base);
	// 822B3580: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 822B3584: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B3588: 3F80834C  lis r28, -0x7cb4
	ctx.r[28].s64 = -2092171264;
	// 822B358C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B3590: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822B3594: 3BCBBEC4  addi r30, r11, -0x413c
	ctx.r[30].s64 = ctx.r[11].s64 + -16700;
	// 822B3598: 817C2410  lwz r11, 0x2410(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(9232 as u32) ) } as u64;
	// 822B359C: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822B35A0: C01ED5CC  lfs f0, -0x2a34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-10804 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B35A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B35A8: 409A005C  bne cr6, 0x822b3604
	if !ctx.cr[6].eq {
	pc = 0x822B3604; continue 'dispatch;
	}
	// 822B35AC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822B35B0: C1BEF7FC  lfs f13, -0x804(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-2052 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B35B4: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 822B35B8: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822B35BC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822B35C0: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 822B35C4: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
	// 822B35C8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822B35CC: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 822B35D0: 3CC0834C  lis r6, -0x7cb4
	ctx.r[6].s64 = -2092171264;
	pc = 0x822B3604; continue 'dispatch;
            }
            0x822B3604 => {
    //   block [0x822B3604..0x822B38BC)
	// 822B3604: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822B3608: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B360C: 409A0060  bne cr6, 0x822b366c
	if !ctx.cr[6].eq {
	pc = 0x822B366C; continue 'dispatch;
	}
	// 822B3610: C1BE1738  lfs f13, 0x1738(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(5944 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B3614: 3901005C  addi r8, r1, 0x5c
	ctx.r[8].s64 = ctx.r[1].s64 + 92;
	// 822B3618: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 822B361C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 822B3620: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822B3624: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 822B3628: C1BEF8E0  lfs f13, -0x720(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1824 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B362C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 822B3630: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822B3634: 3CC0834C  lis r6, -0x7cb4
	ctx.r[6].s64 = -2092171264;
	// 822B3638: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822B363C: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B38C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B38C0 size=332
    let mut pc: u32 = 0x822B38C0;
    'dispatch: loop {
        match pc {
            0x822B38C0 => {
    //   block [0x822B38C0..0x822B39F8)
	// 822B38C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B38C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B38C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B38CC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B38D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B38D4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822B38D8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B38DC: 4BFFF64D  bl 0x822b2f28
	ctx.lr = 0x822B38E0;
	sub_822B2F28(ctx, base);
	// 822B38E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B38E4: 409A0114  bne cr6, 0x822b39f8
	if !ctx.cr[6].eq {
	pc = 0x822B39F8; continue 'dispatch;
	}
	// 822B38E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B38EC: 4BF6B13D  bl 0x8221ea28
	ctx.lr = 0x822B38F0;
	sub_8221EA28(ctx, base);
	// 822B38F0: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B38F4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 822B38F8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822B38FC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822B3900: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 822B3904: C80B70A0  lfd f0, 0x70a0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(28832 as u32) ) };
	// 822B3908: C9AA70A8  lfd f13, 0x70a8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(28840 as u32) ) };
	// 822B390C: FD4B0028  fsub f10, f11, f0
	ctx.f[10].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 822B3910: FD2A6824  fdiv f9, f10, f13
	ctx.f[9].f64 = ctx.f[10].f64 / ctx.f[13].f64;
	// 822B3914: FC204818  frsp f1, f9
	ctx.f[1].f64 = (ctx.f[9].f64 as f32) as f64;
	// 822B3918: 4BED8E59  bl 0x8218c770
	ctx.lr = 0x822B391C;
	sub_8218C770(ctx, base);
	// 822B391C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 822B3920: C11F0054  lfs f8, 0x54(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822B3924: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 822B3928: C0FF0058  lfs f7, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 822B392C: 38E99490  addi r7, r9, -0x6b70
	ctx.r[7].s64 = ctx.r[9].s64 + -27504;
	// 822B3930: 809F005C  lwz r4, 0x5c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 822B3934: 38C80E68  addi r6, r8, 0xe68
	ctx.r[6].s64 = ctx.r[8].s64 + 3688;
	// 822B3938: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 822B393C: C1A99490  lfs f13, -0x6b70(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B3940: C007FFF4  lfs f0, -0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B3944: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 822B3948: 7C600026  mfcr r3
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[3].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B394C: 546BDF7A  rlwinm r11, r3, 0x1b, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000001Fu64;
	// 822B3950: FF070000  fcmpu cr6, f7, f0
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[0].f64);
	// 822B3954: 546AF77A  rlwinm r10, r3, 0x1e, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00000003u64;
	// 822B3958: C1850DB4  lfs f12, 0xdb4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3508 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B395C: 7D200026  mfcr r9
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[9].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B3960: 5528DF7A  rlwinm r8, r9, 0x1b, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 822B3964: 7D675378  or r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 822B3968: 5525F77A  rlwinm r5, r9, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 822B396C: 7D032B78  or r3, r8, r5
	ctx.r[3].u64 = ctx.r[8].u64 | ctx.r[5].u64;
	// 822B3970: 7CC63C2E  lfsx f6, r6, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 822B3974: FCA6022E  fsel f5, f6, f8, f0
	ctx.f[5].f64 = if ctx.f[6].f64 >= 0.0 { ctx.f[8].f64 } else { ctx.f[0].f64 };
	// 822B3978: 7C861C2E  lfsx f4, r6, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 822B397C: FC6401EE  fsel f3, f4, f7, f0
	ctx.f[3].f64 = if ctx.f[4].f64 >= 0.0 { ctx.f[7].f64 } else { ctx.f[0].f64 };
	// 822B3980: EC456828  fsubs f2, f5, f13
	ctx.f[2].f64 = (((ctx.f[5].f64 - ctx.f[13].f64) as f32) as f64);
	// 822B3984: EC236828  fsubs f1, f3, f13
	ctx.f[1].f64 = (((ctx.f[3].f64 - ctx.f[13].f64) as f32) as f64);
	// 822B3988: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 822B398C: 7D600026  mfcr r11
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[11].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B3990: 556ADF7A  rlwinm r10, r11, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822B3994: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 822B3998: 5569F77A  rlwinm r9, r11, 0x1e, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 822B399C: 7D000026  mfcr r8
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[8].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B39A0: 7D474B78  or r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 822B39A4: 5503F77A  rlwinm r3, r8, 0x1e, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 822B39A8: 5505DF7A  rlwinm r5, r8, 0x1b, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 822B39AC: 7CAB1B78  or r11, r5, r3
	ctx.r[11].u64 = ctx.r[5].u64 | ctx.r[3].u64;
	// 822B39B0: 7C063C2E  lfsx f0, r6, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B39B4: FD602B6E  fsel f11, f0, f13, f5
	ctx.f[11].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[5].f64 };
	// 822B39B8: 7D465C2E  lfsx f10, r6, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822B39BC: FD2A1B6E  fsel f9, f10, f13, f3
	ctx.f[9].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[3].f64 };
	// 822B39C0: ED0B0332  fmuls f8, f11, f12
	ctx.f[8].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 822B39C4: ECE90332  fmuls f7, f9, f12
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 822B39C8: FCC0465E  fctidz f6, f8
	ctx.f[6].s64 = if ctx.f[8].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[8].f64.trunc() as i64 };
	// 822B39CC: D8C10050  stfd f6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[6].u64 ) };
	// 822B39D0: A1410056  lhz r10, 0x56(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 822B39D4: B1440000  sth r10, 0(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 822B39D8: FCA03E5E  fctidz f5, f7
	ctx.f[5].s64 = if ctx.f[7].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[7].f64.trunc() as i64 };
	// 822B39DC: D8A10050  stfd f5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[5].u64 ) };
	// 822B39E0: 813F005C  lwz r9, 0x5c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 822B39E4: A1010056  lhz r8, 0x56(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 822B39E8: B1090002  sth r8, 2(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 822B39EC: 809F005C  lwz r4, 0x5c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 822B39F0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B39F4: 4BEC6925  bl 0x8217a318
	ctx.lr = 0x822B39F8;
	sub_8217A318(ctx, base);
	pc = 0x822B39F8; continue 'dispatch;
            }
            0x822B39F8 => {
    //   block [0x822B39F8..0x822B3A0C)
	// 822B39F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822B39FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B3A00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B3A04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B3A08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B3A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B3A10 size=180
    let mut pc: u32 = 0x822B3A10;
    'dispatch: loop {
        match pc {
            0x822B3A10 => {
    //   block [0x822B3A10..0x822B3A84)
	// 822B3A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B3A14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B3A18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822B3A1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B3A20: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822B3A24: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B3A28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B3A2C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822B3A30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822B3A34: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822B3A38: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822B3A3C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B3A40: 4BEF5281  bl 0x821a8cc0
	ctx.lr = 0x822B3A44;
	sub_821A8CC0(ctx, base);
	// 822B3A44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B3A48: 409A0060  bne cr6, 0x822b3aa8
	if !ctx.cr[6].eq {
	pc = 0x822B3AA8; continue 'dispatch;
	}
	// 822B3A4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B3A50: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B3A54: 4BFFF4D5  bl 0x822b2f28
	ctx.lr = 0x822B3A58;
	sub_822B2F28(ctx, base);
	// 822B3A58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B3A5C: 409A004C  bne cr6, 0x822b3aa8
	if !ctx.cr[6].eq {
	pc = 0x822B3AA8; continue 'dispatch;
	}
	// 822B3A60: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822B3A64: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822B3A68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B3A6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B3A70: 4BED5A39  bl 0x821894a8
	ctx.lr = 0x822B3A74;
	sub_821894A8(ctx, base);
	// 822B3A74: 395F003C  addi r10, r31, 0x3c
	ctx.r[10].s64 = ctx.r[31].s64 + 60;
	// 822B3A78: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 822B3A7C: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 822B3A80: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x822B3A84; continue 'dispatch;
            }
            0x822B3A84 => {
    //   block [0x822B3A84..0x822B3AA8)
	// 822B3A84: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B3A88: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 822B3A8C: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 822B3A90: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 822B3A94: 4200FFF0  bdnz 0x822b3a84
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822B3A84; continue 'dispatch;
	}
	// 822B3A98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822B3A9C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822B3AA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B3AA4: 4BED263D  bl 0x821860e0
	ctx.lr = 0x822B3AA8;
	sub_821860E0(ctx, base);
	pc = 0x822B3AA8; continue 'dispatch;
            }
            0x822B3AA8 => {
    //   block [0x822B3AA8..0x822B3AC4)
	// 822B3AA8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822B3AAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B3AB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B3AB4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822B3AB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822B3ABC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B3AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B3AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B3AC8 size=424
    let mut pc: u32 = 0x822B3AC8;
    'dispatch: loop {
        match pc {
            0x822B3AC8 => {
    //   block [0x822B3AC8..0x822B3B20)
	// 822B3AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B3ACC: 489F5931  bl 0x82ca93fc
	ctx.lr = 0x822B3AD0;
	sub_82CA93D0(ctx, base);
	// 822B3AD0: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 822B3AD4: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 822B3AD8: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 822B3ADC: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B3AE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822B3AE4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 822B3AE8: 4BF6AF41  bl 0x8221ea28
	ctx.lr = 0x822B3AEC;
	sub_8221EA28(ctx, base);
	// 822B3AEC: C9810088  lfd f12, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 822B3AF0: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 822B3AF4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822B3AF8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822B3AFC: 813D000C  lwz r9, 0xc(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B3B00: C80B70A0  lfd f0, 0x70a0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(28832 as u32) ) };
	// 822B3B04: C9AA70A8  lfd f13, 0x70a8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(28840 as u32) ) };
	// 822B3B08: FD4B0028  fsub f10, f11, f0
	ctx.f[10].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 822B3B0C: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B3B10: FFCA6824  fdiv f30, f10, f13
	ctx.f[30].f64 = ctx.f[10].f64 / ctx.f[13].f64;
	// 822B3B14: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822B3B18: 419A0034  beq cr6, 0x822b3b4c
	if ctx.cr[6].eq {
	pc = 0x822B3B4C; continue 'dispatch;
	}
	// 822B3B1C: 3BDD0024  addi r30, r29, 0x24
	ctx.r[30].s64 = ctx.r[29].s64 + 36;
	pc = 0x822B3B20; continue 'dispatch;
            }
            0x822B3B20 => {
    //   block [0x822B3B20..0x822B3B4C)
	// 822B3B20: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B3B24: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822B3B28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822B3B2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B3B30: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B3B34: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B3B38: 4E800421  bctrl
	ctx.lr = 0x822B3B3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B3B3C: 813D000C  lwz r9, 0xc(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B3B40: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 822B3B44: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822B3B48: 409AFFD8  bne cr6, 0x822b3b20
	if !ctx.cr[6].eq {
	pc = 0x822B3B20; continue 'dispatch;
	}
            }
            0x822B3B4C => {
    //   block [0x822B3B4C..0x822B3B7C)
	// 822B3B4C: 83FD0018  lwz r31, 0x18(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 822B3B50: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 822B3B54: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B3B58: 419A00AC  beq cr6, 0x822b3c04
	if ctx.cr[6].eq {
	pc = 0x822B3C04; continue 'dispatch;
	}
	// 822B3B5C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B3B60: FFE0F018  frsp f31, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[30].f64 as f32) as f64;
	// 822B3B64: 3B7D0024  addi r27, r29, 0x24
	ctx.r[27].s64 = ctx.r[29].s64 + 36;
	// 822B3B68: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822B3B6C: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 822B3B70: 3B200009  li r25, 9
	ctx.r[25].s64 = 9;
	// 822B3B74: C3AB9484  lfs f29, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822B3B78: 3B40000A  li r26, 0xa
	ctx.r[26].s64 = 10;
	pc = 0x822B3B7C; continue 'dispatch;
            }
            0x822B3B7C => {
    //   block [0x822B3B7C..0x822B3BD0)
	// 822B3B7C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822B3B80: D3A10080  stfs f29, 0x80(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 822B3B84: D3A10084  stfs f29, 0x84(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 822B3B88: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 822B3B8C: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 822B3B90: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 822B3B94: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 822B3B98: FBCB0000  std r30, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 822B3B9C: FBCB0008  std r30, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u64 ) };
	// 822B3BA0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822B3BA4: FBCB0010  std r30, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u64 ) };
	// 822B3BA8: FBCB0018  std r30, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u64 ) };
	// 822B3BAC: 93CB0020  stw r30, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 822B3BB0: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 822B3BB4: A17F0000  lhz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B3BB8: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 822B3BBC: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 822B3BC0: 9321007C  stw r25, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[25].u32 ) };
	// 822B3BC4: B1610050  sth r11, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u16 ) };
	// 822B3BC8: 419A0008  beq cr6, 0x822b3bd0
	if ctx.cr[6].eq {
	pc = 0x822B3BD0; continue 'dispatch;
	}
	// 822B3BCC: 9341007C  stw r26, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[26].u32 ) };
	pc = 0x822B3BD0; continue 'dispatch;
            }
            0x822B3BD0 => {
    //   block [0x822B3BD0..0x822B3C04)
	// 822B3BD0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822B3BD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B3BD8: 38A00038  li r5, 0x38
	ctx.r[5].s64 = 56;
	// 822B3BDC: 489F58A5  bl 0x82ca9480
	ctx.lr = 0x822B3BE0;
	sub_82CA9480(ctx, base);
	// 822B3BE0: DBC100D0  stfd f30, 0xd0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.f[30].u64 ) };
	// 822B3BE4: 9BC100C8  stb r30, 0xc8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[30].u8 ) };
	// 822B3BE8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 822B3BEC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822B3BF0: 4874B7A9  bl 0x829ff398
	ctx.lr = 0x822B3BF4;
	sub_829FF398(ctx, base);
	// 822B3BF4: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 822B3BF8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822B3BFC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B3C00: 409AFF7C  bne cr6, 0x822b3b7c
	if !ctx.cr[6].eq {
	pc = 0x822B3B7C; continue 'dispatch;
	}
	pc = 0x822B3C04; continue 'dispatch;
            }
            0x822B3C04 => {
    //   block [0x822B3C04..0x822B3C38)
	// 822B3C04: 813D0018  lwz r9, 0x18(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 822B3C08: 38FD0014  addi r7, r29, 0x14
	ctx.r[7].s64 = ctx.r[29].s64 + 20;
	// 822B3C0C: 815D001C  lwz r10, 0x1c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 822B3C10: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B3C14: 419A0048  beq cr6, 0x822b3c5c
	if ctx.cr[6].eq {
	pc = 0x822B3C5C; continue 'dispatch;
	}
	// 822B3C18: 7D0A5050  subf r8, r10, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[10].s64;
	// 822B3C1C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 822B3C20: 7D061670  srawi r6, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 822B3C24: 7F0A5040  cmplw cr6, r10, r10
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B3C28: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B3C2C: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 822B3C30: 419A0028  beq cr6, 0x822b3c58
	if ctx.cr[6].eq {
	pc = 0x822B3C58; continue 'dispatch;
	}
	// 822B3C34: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	pc = 0x822B3C38; continue 'dispatch;
            }
            0x822B3C38 => {
    //   block [0x822B3C38..0x822B3C58)
	// 822B3C38: A0CB0000  lhz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B3C3C: 7CA95A14  add r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 822B3C40: 7CC95B2E  sthx r6, r9, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u16) };
	// 822B3C44: A08B0002  lhz r4, 2(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 822B3C48: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822B3C4C: B0850002  sth r4, 2(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(2 as u32), ctx.r[4].u16 ) };
	// 822B3C50: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B3C54: 409AFFE4  bne cr6, 0x822b3c38
	if !ctx.cr[6].eq {
	pc = 0x822B3C38; continue 'dispatch;
	}
	pc = 0x822B3C58; continue 'dispatch;
            }
            0x822B3C58 => {
    //   block [0x822B3C58..0x822B3C5C)
	// 822B3C58: 91070008  stw r8, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x822B3C5C; continue 'dispatch;
            }
            0x822B3C5C => {
    //   block [0x822B3C5C..0x822B3C70)
	// 822B3C5C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 822B3C60: CBA1FFA8  lfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 822B3C64: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 822B3C68: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 822B3C6C: 489F57E0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B3C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B3C70 size=64
    let mut pc: u32 = 0x822B3C70;
    'dispatch: loop {
        match pc {
            0x822B3C70 => {
    //   block [0x822B3C70..0x822B3CB0)
	// 822B3C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B3C74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B3C78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B3C7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B3C80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B3C84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B3C88: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B3C8C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B3C90: 4E800421  bctrl
	ctx.lr = 0x822B3C94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B3C94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B3C98: 4BFFFE31  bl 0x822b3ac8
	ctx.lr = 0x822B3C9C;
	sub_822B3AC8(ctx, base);
	// 822B3C9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822B3CA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B3CA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B3CA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B3CAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B3CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B3CB0 size=200
    let mut pc: u32 = 0x822B3CB0;
    'dispatch: loop {
        match pc {
            0x822B3CB0 => {
    //   block [0x822B3CB0..0x822B3CEC)
	// 822B3CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B3CB4: 489F5759  bl 0x82ca940c
	ctx.lr = 0x822B3CB8;
	sub_82CA93D0(ctx, base);
	// 822B3CB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B3CBC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822B3CC0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 822B3CC4: 4BF6B595  bl 0x8221f258
	ctx.lr = 0x822B3CC8;
	sub_8221F258(ctx, base);
	// 822B3CC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B3CCC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822B3CD0: 419A001C  beq cr6, 0x822b3cec
	if ctx.cr[6].eq {
	pc = 0x822B3CEC; continue 'dispatch;
	}
	// 822B3CD4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 822B3CD8: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822B3CDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B3CE0: 394B0E0C  addi r10, r11, 0xe0c
	ctx.r[10].s64 = ctx.r[11].s64 + 3596;
	// 822B3CE4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822B3CE8: 48000008  b 0x822b3cf0
	pc = 0x822B3CF0; continue 'dispatch;
            }
            0x822B3CEC => {
    //   block [0x822B3CEC..0x822B3CF0)
	// 822B3CEC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x822B3CF0; continue 'dispatch;
            }
            0x822B3CF0 => {
    //   block [0x822B3CF0..0x822B3D2C)
	// 822B3CF0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822B3CF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822B3CF8: 419A0034  beq cr6, 0x822b3d2c
	if ctx.cr[6].eq {
	pc = 0x822B3D2C; continue 'dispatch;
	}
	// 822B3CFC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 822B3D00: 4BF6B559  bl 0x8221f258
	ctx.lr = 0x822B3D04;
	sub_8221F258(ctx, base);
	// 822B3D04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B3D08: 419A0024  beq cr6, 0x822b3d2c
	if ctx.cr[6].eq {
	pc = 0x822B3D2C; continue 'dispatch;
	}
	// 822B3D0C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 822B3D10: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 822B3D14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B3D18: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 822B3D1C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 822B3D20: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822B3D24: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 822B3D28: 48000008  b 0x822b3d30
	pc = 0x822B3D30; continue 'dispatch;
            }
            0x822B3D2C => {
    //   block [0x822B3D2C..0x822B3D30)
	// 822B3D2C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x822B3D30; continue 'dispatch;
            }
            0x822B3D30 => {
    //   block [0x822B3D30..0x822B3D78)
	// 822B3D30: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822B3D34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822B3D38: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 822B3D3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B3D40: 387D0038  addi r3, r29, 0x38
	ctx.r[3].s64 = ctx.r[29].s64 + 56;
	// 822B3D44: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 822B3D48: C9AA0EF0  lfd f13, 0xef0(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3824 as u32) ) };
	// 822B3D4C: FC000372  fmul f0, f0, f13
	ctx.f[0].f64 = ctx.f[0].f64 * ctx.f[13].f64;
	// 822B3D50: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822B3D54: 7DBF4FAE  stfiwx f13, r31, r9
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 822B3D58: 48041BF1  bl 0x822f5948
	ctx.lr = 0x822B3D5C;
	sub_822F5948(ctx, base);
	// 822B3D5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822B3D60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B3D64: 48000015  bl 0x822b3d78
	ctx.lr = 0x822B3D68;
	sub_822B3D78(ctx, base);
	// 822B3D68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B3D6C: 4BF03DAD  bl 0x821b7b18
	ctx.lr = 0x822B3D70;
	sub_821B7B18(ctx, base);
	// 822B3D70: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822B3D74: 489F56E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B3D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B3D78 size=116
    let mut pc: u32 = 0x822B3D78;
    'dispatch: loop {
        match pc {
            0x822B3D78 => {
    //   block [0x822B3D78..0x822B3DEC)
	// 822B3D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B3D7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B3D80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B3D84: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B3D88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822B3D8C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822B3D90: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 822B3D94: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B3D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B3D9C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 822B3DA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B3DA4: 4BF60AF5  bl 0x82214898
	ctx.lr = 0x822B3DA8;
	sub_82214898(ctx, base);
	// 822B3DA8: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 822B3DAC: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 822B3DB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822B3DB4: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 822B3DB8: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 822B3DBC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822B3DC0: 48018329  bl 0x822cc0e8
	ctx.lr = 0x822B3DC4;
	sub_822CC0E8(ctx, base);
	// 822B3DC4: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 822B3DC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B3DCC: 38C70B7C  addi r6, r7, 0xb7c
	ctx.r[6].s64 = ctx.r[7].s64 + 2940;
	// 822B3DD0: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 822B3DD4: 4BEE0065  bl 0x82193e38
	ctx.lr = 0x822B3DD8;
	sub_82193E38(ctx, base);
	// 822B3DD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B3DDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B3DE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B3DE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B3DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B3DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822B3DF0 size=328
    let mut pc: u32 = 0x822B3DF0;
    'dispatch: loop {
        match pc {
            0x822B3DF0 => {
    //   block [0x822B3DF0..0x822B3E38)
	// 822B3DF0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822B3DF4: 409A0044  bne cr6, 0x822b3e38
	if !ctx.cr[6].eq {
	pc = 0x822B3E38; continue 'dispatch;
	}
	// 822B3DF8: A1632888  lhz r11, 0x2888(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(10376 as u32) ) } as u64;
	// 822B3DFC: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B3E00: 40820090  bne 0x822b3e90
	if !ctx.cr[0].eq {
	pc = 0x822B3E90; continue 'dispatch;
	}
	// 822B3E04: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 822B3E08: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822B3E0C: C00B1278  lfs f0, 0x1278(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4728 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B3E10: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 822B3E14: C00A7468  lfs f0, 0x7468(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(29800 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B3E18: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 822B3E1C: FDA06E5E  fctidz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 822B3E20: D9A1FFF0  stfd f13, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[13].u64 ) };
	// 822B3E24: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 822B3E28: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 822B3E2C: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 822B3E30: 8141FFF4  lwz r10, -0xc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 822B3E34: 48000050  b 0x822b3e84
	pc = 0x822B3E84; continue 'dispatch;
            }
            0x822B3E38 => {
    //   block [0x822B3E38..0x822B3E84)
	// 822B3E38: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B3E3C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822B3E40: 556B0E7C  rlwinm r11, r11, 1, 0x19, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 822B3E44: 394A6F08  addi r10, r10, 0x6f08
	ctx.r[10].s64 = ctx.r[10].s64 + 28424;
	// 822B3E48: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822B3E4C: 556B052F  rlwinm. r11, r11, 0, 0x14, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B3E50: 40820040  bne 0x822b3e90
	if !ctx.cr[0].eq {
	pc = 0x822B3E90; continue 'dispatch;
	}
	// 822B3E54: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 822B3E58: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822B3E5C: C00B1278  lfs f0, 0x1278(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4728 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B3E60: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 822B3E64: C00A7468  lfs f0, 0x7468(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(29800 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B3E68: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 822B3E6C: FDA06E5E  fctidz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 822B3E70: D9A1FFF0  stfd f13, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[13].u64 ) };
	// 822B3E74: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 822B3E78: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 822B3E7C: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 822B3E80: 8141FFF4  lwz r10, -0xc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	pc = 0x822B3E84; continue 'dispatch;
            }
            0x822B3E84 => {
    //   block [0x822B3E84..0x822B3E90)
	// 822B3E84: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822B3E88: 7D6B3378  or r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[6].u64;
	// 822B3E8C: 4800006C  b 0x822b3ef8
	pc = 0x822B3EF8; continue 'dispatch;
            }
            0x822B3E90 => {
    //   block [0x822B3E90..0x822B3EA8)
	// 822B3E90: D021FFF0  stfs f1, -0x10(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 822B3E94: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 822B3E98: 554B0001  rlwinm. r11, r10, 0, 0, 0
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B3E9C: 4182000C  beq 0x822b3ea8
	if ctx.cr[0].eq {
	pc = 0x822B3EA8; continue 'dispatch;
	}
	// 822B3EA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822B3EA4: 48000048  b 0x822b3eec
	pc = 0x822B3EEC; continue 'dispatch;
            }
            0x822B3EA8 => {
    //   block [0x822B3EA8..0x822B3EC8)
	// 822B3EA8: 554B4DFE  srwi r11, r10, 0x17
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(23);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822B3EAC: 2B0B0071  cmplwi cr6, r11, 0x71
	ctx.cr[6].compare_u32(ctx.r[11].u32, 113 as u32, &mut ctx.xer);
	// 822B3EB0: 41980018  blt cr6, 0x822b3ec8
	if ctx.cr[6].lt {
	pc = 0x822B3EC8; continue 'dispatch;
	}
	// 822B3EB4: 554B0150  rlwinm r11, r10, 0, 5, 8
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822B3EB8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822B3EBC: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 822B3EC0: 556AE8FE  srwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822B3EC4: 48000028  b 0x822b3eec
	pc = 0x822B3EEC; continue 'dispatch;
            }
            0x822B3EC8 => {
    //   block [0x822B3EC8..0x822B3EEC)
	// 822B3EC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B3ECC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822B3ED0: 216B0071  subfic r11, r11, 0x71
	ctx.xer.ca = ctx.r[11].u32 <= 113 as u32;
	ctx.r[11].s64 = (113 as i64) - ctx.r[11].s64;
	// 822B3ED4: 554A027E  clrlwi r10, r10, 9
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x007FFFFFu64;
	// 822B3ED8: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 822B3EDC: 7D294030  slw r9, r9, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 822B3EE0: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 822B3EE4: 654A0080  oris r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 | 8388608;
	// 822B3EE8: 7D4A5C30  srw r10, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) >> ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	pc = 0x822B3EEC; continue 'dispatch;
            }
            0x822B3EEC => {
    //   block [0x822B3EEC..0x822B3EF8)
	// 822B3EEC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B3EF0: 514B402E  rlwimi r11, r10, 8, 0, 0x17
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[11].u64 & 0xFFFFFFFF000000FF);
	// 822B3EF4: 556A5D7E  srwi r10, r11, 0x15
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(21);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x822B3EF8; continue 'dispatch;
            }
            0x822B3EF8 => {
    //   block [0x822B3EF8..0x822B3F38)
	// 822B3EF8: 89232942  lbz r9, 0x2942(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(10562 as u32) ) } as u64;
	// 822B3EFC: 91632A2C  stw r11, 0x2a2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10796 as u32), ctx.r[11].u32 ) };
	// 822B3F00: 7D693050  subf r11, r9, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 822B3F04: 81232940  lwz r9, 0x2940(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10560 as u32) ) } as u64;
	// 822B3F08: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822B3F0C: 7D2948F8  nor r9, r9, r9
	ctx.r[9].u64 = !(ctx.r[9].u64 | ctx.r[9].u64);
	// 822B3F10: 556B3528  rlwinm r11, r11, 6, 0x14, 0x14
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 822B3F14: 55293528  rlwinm r9, r9, 6, 0x14, 0x14
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x03FFFFFFu64;
	// 822B3F18: 696B0800  xori r11, r11, 0x800
	ctx.r[11].u64 = ctx.r[11].u64 ^ 2048;
	// 822B3F1C: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 822B3F20: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 822B3F24: 91632A28  stw r11, 0x2a28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10792 as u32), ctx.r[11].u32 ) };
	// 822B3F28: E9630020  ld r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	// 822B3F2C: 616B0300  ori r11, r11, 0x300
	ctx.r[11].u64 = ctx.r[11].u64 | 768;
	// 822B3F30: F9630020  std r11, 0x20(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 822B3F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B3F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B3F38 size=204
    let mut pc: u32 = 0x822B3F38;
    'dispatch: loop {
        match pc {
            0x822B3F38 => {
    //   block [0x822B3F38..0x822B4004)
	// 822B3F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B3F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B3F40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B3F44: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 822B3F48: 39800080  li r12, 0x80
	ctx.r[12].s64 = 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B4008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B4008 size=380
    let mut pc: u32 = 0x822B4008;
    'dispatch: loop {
        match pc {
            0x822B4008 => {
    //   block [0x822B4008..0x822B403C)
	// 822B4008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B400C: 489F53ED  bl 0x82ca93f8
	ctx.lr = 0x822B4010;
	sub_82CA93D0(ctx, base);
	// 822B4010: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B4014: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822B4018: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822B401C: 3B602388  li r27, 0x2388
	ctx.r[27].s64 = 9096;
	// 822B4020: 3BFD2820  addi r31, r29, 0x2820
	ctx.r[31].s64 = ctx.r[29].s64 + 10272;
	// 822B4024: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 822B4028: 807D0030  lwz r3, 0x30(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 822B402C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B4030: 4099000C  ble cr6, 0x822b403c
	if !ctx.cr[6].gt {
	pc = 0x822B403C; continue 'dispatch;
	}
	// 822B4034: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B4038: 4BF34E89  bl 0x821e8ec0
	ctx.lr = 0x822B403C;
	sub_821E8EC0(ctx, base);
	pc = 0x822B403C; continue 'dispatch;
            }
            0x822B403C => {
    //   block [0x822B403C..0x822B40BC)
	// 822B403C: 39602007  li r11, 0x2007
	ctx.r[11].s64 = 8199;
	// 822B4040: 39400A31  li r10, 0xa31
	ctx.r[10].s64 = 2609;
	// 822B4044: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 822B4048: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 822B404C: 813D289C  lwz r9, 0x289c(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(10396 as u32) ) } as u64;
	// 822B4050: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 822B4054: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822B4058: 61080A2F  ori r8, r8, 0xa2f
	ctx.r[8].u64 = ctx.r[8].u64 | 2607;
	// 822B405C: 38C01000  li r6, 0x1000
	ctx.r[6].s64 = 4096;
	// 822B4060: 3CA0C004  lis r5, -0x3ffc
	ctx.r[5].s64 = -1073479680;
	// 822B4064: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 822B4068: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 822B406C: 60A53C00  ori r5, r5, 0x3c00
	ctx.r[5].u64 = ctx.r[5].u64 | 15360;
	// 822B4070: 38800A31  li r4, 0xa31
	ctx.r[4].s64 = 2609;
	// 822B4074: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822B4078: 3F008000  lis r24, -0x8000
	ctx.r[24].s64 = -2147483648;
	// 822B407C: 95430004  stwu r10, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[3].u32 = ea;
	// 822B4080: 3B400008  li r26, 8
	ctx.r[26].s64 = 8;
	// 822B4084: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 822B4088: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 822B408C: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 822B4090: 95030004  stwu r8, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[8].u32) };
	ctx.r[3].u32 = ea;
	// 822B4094: 94E30004  stwu r7, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[7].u32) };
	ctx.r[3].u32 = ea;
	// 822B4098: 94C30004  stwu r6, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[6].u32) };
	ctx.r[3].u32 = ea;
	// 822B409C: 94A30004  stwu r5, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[5].u32) };
	ctx.r[3].u32 = ea;
	// 822B40A0: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 822B40A4: 94830004  stwu r4, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[4].u32) };
	ctx.r[3].u32 = ea;
	// 822B40A8: 97830004  stwu r28, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[28].u32) };
	ctx.r[3].u32 = ea;
	// 822B40AC: 95430004  stwu r10, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[3].u32 = ea;
	// 822B40B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822B40B4: 97440004  stwu r26, 4(r4)
	ea = ctx.r[4].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[26].u32) };
	ctx.r[4].u32 = ea;
	// 822B40B8: 909D0030  stw r4, 0x30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), ctx.r[4].u32 ) };
	pc = 0x822B40BC; continue 'dispatch;
            }
            0x822B40BC => {
    //   block [0x822B40BC..0x822B412C)
	// 822B40BC: 7FCA0074  cntlzd r10, r30
	ctx.r[10].u64 = if ctx.r[30].u64 == 0 { 64 } else { ctx.r[30].u64.leading_zeros() as u64 };
	// 822B40C0: 813D0034  lwz r9, 0x34(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 822B40C4: 79480020  clrldi r8, r10, 0x20
	ctx.r[8].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 822B40C8: 554B2036  slwi r11, r10, 4
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822B40CC: 7FDE4036  sld r30, r30, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[30].u64 = 0;
	} else {
		ctx.r[30].u64 = (ctx.r[30].u64) << ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 822B40D0: 7FC8F0F8  nor r8, r30, r30
	ctx.r[8].u64 = !(ctx.r[30].u64 | ctx.r[30].u64);
	// 822B40D4: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 822B40D8: 7D1C0074  cntlzd r28, r8
	ctx.r[28].u64 = if ctx.r[8].u64 == 0 { 64 } else { ctx.r[8].u64.leading_zeros() as u64 };
	// 822B40DC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822B40E0: 57992036  slwi r25, r28, 4
	ctx.r[25].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 822B40E4: 7F6ADA14  add r27, r10, r27
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 822B40E8: 7D792214  add r11, r25, r4
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[4].u64;
	// 822B40EC: 579A103A  slwi r26, r28, 2
	ctx.r[26].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 822B40F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822B40F4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822B40F8: 41980034  blt cr6, 0x822b412c
	if ctx.cr[6].lt {
	pc = 0x822B412C; continue 'dispatch;
	}
	// 822B40FC: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 822B4100: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 822B4104: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 822B4108: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822B410C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B4110: 4BFDAE71  bl 0x8228ef80
	ctx.lr = 0x822B4114;
	sub_8228EF80(ctx, base);
	// 822B4114: 7B8B0020  clrldi r11, r28, 0x20
	ctx.r[11].u64 = ctx.r[28].u64 & 0x00000000FFFFFFFFu64;
	// 822B4118: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822B411C: 7FF9FA14  add r31, r25, r31
	ctx.r[31].u64 = ctx.r[25].u64 + ctx.r[31].u64;
	// 822B4120: 7F7ADA14  add r27, r26, r27
	ctx.r[27].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 822B4124: 7FDE5836  sld r30, r30, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[30].u64 = 0;
	} else {
		ctx.r[30].u64 = (ctx.r[30].u64) << ((ctx.r[11].u8 & 0x3F) as u32);
	}
	// 822B4128: 48000048  b 0x822b4170
	pc = 0x822B4170; continue 'dispatch;
            }
            0x822B412C => {
    //   block [0x822B412C..0x822B414C)
	// 822B412C: 548B077E  clrlwi r11, r4, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000007u64;
	// 822B4130: 93040004  stw r24, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 822B4134: 395AFFFF  addi r10, r26, -1
	ctx.r[10].s64 = ctx.r[26].s64 + -1;
	// 822B4138: 7C8B2214  add r4, r11, r4
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 822B413C: 554B801E  slwi r11, r10, 0x10
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(16);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822B4140: 7D6BDB78  or r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[27].u64;
	// 822B4144: 7F7ADA14  add r27, r26, r27
	ctx.r[27].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 822B4148: 95640004  stwu r11, 4(r4)
	ea = ctx.r[4].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[4].u32 = ea;
	pc = 0x822B414C; continue 'dispatch;
            }
            0x822B414C => {
    //   block [0x822B414C..0x822B4170)
	// 822B414C: E97F0004  ld r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	// 822B4150: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822B4154: E95F000C  ld r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	// 822B4158: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 822B415C: 7BDE0FA4  sldi r30, r30, 1
	ctx.r[30].u64 = ctx.r[30].u64.wrapping_shl(1);
	ctx.r[30].u32 = ctx.r[30].u64 as u32;
	// 822B4160: F9640004  std r11, 4(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u64 ) };
	// 822B4164: F944000C  std r10, 0xc(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[10].u64 ) };
	// 822B4168: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 822B416C: 4082FFE0  bne 0x822b414c
	if !ctx.cr[0].eq {
	pc = 0x822B414C; continue 'dispatch;
	}
	pc = 0x822B4170; continue 'dispatch;
            }
            0x822B4170 => {
    //   block [0x822B4170..0x822B4184)
	// 822B4170: 2B3E0000  cmpldi cr6, r30, 0
	ctx.cr[6].compare_u64(ctx.r[30].u64, 0, &mut ctx.xer);
	// 822B4174: 409AFF48  bne cr6, 0x822b40bc
	if !ctx.cr[6].eq {
	pc = 0x822B40BC; continue 'dispatch;
	}
	// 822B4178: 909D0030  stw r4, 0x30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), ctx.r[4].u32 ) };
	// 822B417C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822B4180: 489F52C8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B4188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822B4188 size=308
    let mut pc: u32 = 0x822B4188;
    'dispatch: loop {
        match pc {
            0x822B4188 => {
    //   block [0x822B4188..0x822B42BC)
	// 822B4188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B418C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B4190: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B4194: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 822B4198: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B42C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B42C0 size=204
    let mut pc: u32 = 0x822B42C0;
    'dispatch: loop {
        match pc {
            0x822B42C0 => {
    //   block [0x822B42C0..0x822B438C)
	// 822B42C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B42C4: 489F513D  bl 0x82ca9400
	ctx.lr = 0x822B42C8;
	sub_82CA93D0(ctx, base);
	// 822B42C8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B42CC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B42D0: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 822B42D4: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 822B42D8: 3B61005C  addi r27, r1, 0x5c
	ctx.r[27].s64 = ctx.r[1].s64 + 92;
	// 822B42DC: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 822B42E0: C1AB9490  lfs f13, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B42E4: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 822B42E8: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 822B42EC: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822B42F0: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B42F4: 3921005C  addi r9, r1, 0x5c
	ctx.r[9].s64 = ctx.r[1].s64 + 92;
	// 822B42F8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822B42FC: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 822B4300: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 822B4304: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B4390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822B4390 size=1504
    let mut pc: u32 = 0x822B4390;
    'dispatch: loop {
        match pc {
            0x822B4390 => {
    //   block [0x822B4390..0x822B4970)
	// 822B4390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B4394: 489F5065  bl 0x82ca93f8
	ctx.lr = 0x822B4398;
	sub_82CA93D0(ctx, base);
	// 822B4398: DBA1FFA0  stfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[29].u64 ) };
	// 822B439C: DBC1FFA8  stfd f30, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 822B43A0: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 822B43A4: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B4970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B4970 size=120
    let mut pc: u32 = 0x822B4970;
    'dispatch: loop {
        match pc {
            0x822B4970 => {
    //   block [0x822B4970..0x822B49CC)
	// 822B4970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B4974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B4978: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822B497C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B4980: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822B4984: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B4988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B498C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822B4990: 4BF4C4A9  bl 0x82200e38
	ctx.lr = 0x822B4994;
	sub_82200E38(ctx, base);
	// 822B4994: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 822B4998: 419A0034  beq cr6, 0x822b49cc
	if ctx.cr[6].eq {
	pc = 0x822B49CC; continue 'dispatch;
	}
	// 822B499C: D3FF0024  stfs f31, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822B49A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B49A4: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822B49A8: 484ABF81  bl 0x82760928
	ctx.lr = 0x822B49AC;
	sub_82760928(ctx, base);
	// 822B49AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822B49B0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822B49B4: 419A0018  beq cr6, 0x822b49cc
	if ctx.cr[6].eq {
	pc = 0x822B49CC; continue 'dispatch;
	}
	// 822B49B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B49BC: C03F0020  lfs f1, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822B49C0: 4BF4C499  bl 0x82200e58
	ctx.lr = 0x822B49C4;
	sub_82200E58(ctx, base);
	// 822B49C4: D03E001C  stfs f1, 0x1c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 822B49C8: D03E0020  stfs f1, 0x20(r30)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), tmp.u32 ) };
	pc = 0x822B49CC; continue 'dispatch;
            }
            0x822B49CC => {
    //   block [0x822B49CC..0x822B49E8)
	// 822B49CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B49D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B49D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B49D8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822B49DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822B49E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B49E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B49E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B49E8 size=1356
    let mut pc: u32 = 0x822B49E8;
    'dispatch: loop {
        match pc {
            0x822B49E8 => {
    //   block [0x822B49E8..0x822B4A90)
	// 822B49E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B49EC: 489F4A19  bl 0x82ca9404
	ctx.lr = 0x822B49F0;
	sub_82CA93D0(ctx, base);
	// 822B49F0: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 822B49F4: 489F92DD  bl 0x82cadcd0
	ctx.lr = 0x822B49F8;
	sub_82CADCA0(ctx, base);
	// 822B49F8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B49FC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822B4A00: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B4A04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B4A08: 3B8BB650  addi r28, r11, -0x49b0
	ctx.r[28].s64 = ctx.r[11].s64 + -18864;
	// 822B4A0C: 3FA08332  lis r29, -0x7cce
	ctx.r[29].s64 = -2093875200;
	// 822B4A10: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822B4A14: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 822B4A18: C13F002C  lfs f9, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822B4A1C: C81C4AD0  lfd f0, 0x4ad0(r28)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(19152 as u32) ) };
	// 822B4A20: C95D9660  lfd f10, -0x69a0(r29)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(-27040 as u32) ) };
	// 822B4A24: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B4A28: C17CFE88  lfs f11, -0x178(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-376 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822B4A2C: FDA05024  fdiv f13, f0, f10
	ctx.f[13].f64 = ctx.f[0].f64 / ctx.f[10].f64;
	// 822B4A30: C11F000C  lfs f8, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822B4A34: C1899A80  lfs f12, -0x6580(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B4A38: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B4A3C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 822B4A40: C37CDE34  lfs f27, -0x21cc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-8652 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 822B4A44: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B4A48: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B4A4C: 80A60014  lwz r5, 0x14(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 822B4A50: C0E5000C  lfs f7, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 822B4A54: ECC70272  fmuls f6, f7, f9
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[9].f64) as f32) as f64);
	// 822B4A58: ECA602F2  fmuls f5, f6, f11
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[11].f64) as f32) as f64);
	// 822B4A5C: FC85437C  fnmsub f4, f5, f13, f8
	ctx.f[4].f64 = -(ctx.f[5].f64 * ctx.f[13].f64 - ctx.f[8].f64);
	// 822B4A60: FD802018  frsp f12, f4
	ctx.f[12].f64 = (ctx.f[4].f64 as f32) as f64;
	// 822B4A64: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822B4A68: 40990038  ble cr6, 0x822b4aa0
	if !ctx.cr[6].gt {
	pc = 0x822B4AA0; continue 'dispatch;
	}
	// 822B4A6C: C17F0030  lfs f11, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822B4A70: FD2B0372  fmul f9, f11, f13
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[13].f64;
	// 822B4A74: FDA04818  frsp f13, f9
	ctx.f[13].f64 = (ctx.f[9].f64 as f32) as f64;
	// 822B4A78: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822B4A7C: 40980014  bge cr6, 0x822b4a90
	if !ctx.cr[6].lt {
	pc = 0x822B4A90; continue 'dispatch;
	}
	// 822B4A80: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 822B4A84: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822B4A88: D37F0010  stfs f27, 0x10(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822B4A8C: 48000014  b 0x822b4aa0
	pc = 0x822B4AA0; continue 'dispatch;
            }
            0x822B4A90 => {
    //   block [0x822B4A90..0x822B4AA0)
	// 822B4A90: ED8C682A  fadds f12, f12, f13
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 822B4A94: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822B4A98: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822B4A9C: D17F0010  stfs f11, 0x10(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x822B4AA0; continue 'dispatch;
            }
            0x822B4AA0 => {
    //   block [0x822B4AA0..0x822B4B0C)
	// 822B4AA0: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B4AA4: 3FC08332  lis r30, -0x7cce
	ctx.r[30].s64 = -2093875200;
	// 822B4AA8: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B4AAC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822B4AB0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822B4AB4: 40990094  ble cr6, 0x822b4b48
	if !ctx.cr[6].gt {
	pc = 0x822B4B48; continue 'dispatch;
	}
	// 822B4AB8: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822B4ABC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822B4AC0: 409A0088  bne cr6, 0x822b4b48
	if !ctx.cr[6].eq {
	pc = 0x822B4B48; continue 'dispatch;
	}
	// 822B4AC4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B4AC8: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 822B4ACC: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 822B4AD0: 811E9650  lwz r8, -0x69b0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822B4AD4: 7CE95050  subf r7, r9, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 822B4AD8: 80CB0058  lwz r6, 0x58(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B4ADC: 35470001  addic. r10, r7, 1
	ctx.xer.ca = (ctx.r[7].u32 > (!(1 as u32)));
	ctx.r[10].s64 = ctx.r[7].s64 + 1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822B4AE0: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B4AE4: 80AB0078  lwz r5, 0x78(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 822B4AE8: 1D2524A1  mulli r9, r5, 0x24a1
	ctx.r[9].s32 = ((ctx.r[5].s32 as i64 * 9377 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 822B4AEC: 388924DF  addi r4, r9, 0x24df
	ctx.r[4].s64 = ctx.r[9].s64 + 9439;
	// 822B4AF0: 5489983E  rotlwi r9, r4, 0x13
	ctx.r[9].u64 = ((ctx.r[4].u32).rotate_left(19)) as u64;
	// 822B4AF4: 912B0078  stw r9, 0x78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 822B4AF8: 41820014  beq 0x822b4b0c
	if ctx.cr[0].eq {
	pc = 0x822B4B0C; continue 'dispatch;
	}
	// 822B4AFC: 7D695396  divwu r11, r9, r10
	ctx.r[11].u32 = ctx.r[9].u32 / ctx.r[10].u32;
	// 822B4B00: 7D4B51D6  mullw r10, r11, r10
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 822B4B04: 7D6A4850  subf r11, r10, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 822B4B08: 48000008  b 0x822b4b10
	pc = 0x822B4B10; continue 'dispatch;
            }
            0x822B4B0C => {
    //   block [0x822B4B0C..0x822B4B10)
	// 822B4B0C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x822B4B10; continue 'dispatch;
            }
            0x822B4B10 => {
    //   block [0x822B4B10..0x822B4B48)
	// 822B4B10: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 822B4B14: 7D0907B4  extsw r9, r8
	ctx.r[9].s64 = ctx.r[8].s32 as i64;
	// 822B4B18: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822B4B1C: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 822B4B20: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822B4B24: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 822B4B28: 79070020  clrldi r7, r8, 0x20
	ctx.r[7].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 822B4B2C: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 822B4B30: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822B4B34: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 822B4B38: FD2B6ABA  fmadd f9, f11, f10, f13
	ctx.f[9].f64 = ctx.f[11].f64 * ctx.f[10].f64 + ctx.f[13].f64;
	// 822B4B3C: FD00481E  fctiwz f8, f9
	ctx.f[8].s64 = if ctx.f[9].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[9].f64.trunc() as i32 as i64 };
	// 822B4B40: 39800014  li r12, 0x14
	ctx.r[12].s64 = 20;
	// 822B4B44: 7D1F67AE  stfiwx f8, r31, r12
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[12].u32), tmp.u32) };
	pc = 0x822B4B48; continue 'dispatch;
            }
            0x822B4B48 => {
    //   block [0x822B4B48..0x822B4B6C)
	// 822B4B48: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822B4B4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B4B50: 419A001C  beq cr6, 0x822b4b6c
	if ctx.cr[6].eq {
	pc = 0x822B4B6C; continue 'dispatch;
	}
	// 822B4B54: 815E9650  lwz r10, -0x69b0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822B4B58: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822B4B5C: 40980010  bge cr6, 0x822b4b6c
	if !ctx.cr[6].lt {
	pc = 0x822B4B6C; continue 'dispatch;
	}
	// 822B4B60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B4B64: 4869DF15  bl 0x82952a78
	ctx.lr = 0x822B4B68;
	sub_82952A78(ctx, base);
	// 822B4B68: C95D9660  lfd f10, -0x69a0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(-27040 as u32) ) };
	pc = 0x822B4B6C; continue 'dispatch;
            }
            0x822B4B6C => {
    //   block [0x822B4B6C..0x822B4B9C)
	// 822B4B6C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822B4B70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B4B74: 419A0028  beq cr6, 0x822b4b9c
	if ctx.cr[6].eq {
	pc = 0x822B4B9C; continue 'dispatch;
	}
	// 822B4B78: 815E9650  lwz r10, -0x69b0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822B4B7C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822B4B80: 4099001C  ble cr6, 0x822b4b9c
	if !ctx.cr[6].gt {
	pc = 0x822B4B9C; continue 'dispatch;
	}
	// 822B4B84: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B4B88: FDA05024  fdiv f13, f0, f10
	ctx.f[13].f64 = ctx.f[0].f64 / ctx.f[10].f64;
	// 822B4B8C: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B4B90: FD6C6828  fsub f11, f12, f13
	ctx.f[11].f64 = ctx.f[12].f64 - ctx.f[13].f64;
	// 822B4B94: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 822B4B98: D15F000C  stfs f10, 0xc(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x822B4B9C; continue 'dispatch;
            }
            0x822B4B9C => {
    //   block [0x822B4B9C..0x822B4BE4)
	// 822B4B9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B4BA0: FFE0D890  fmr f31, f27
	ctx.f[31].f64 = ctx.f[27].f64;
	// 822B4BA4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822B4BA8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822B4BAC: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 822B4BB0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B4BB4: 419A00F4  beq cr6, 0x822b4ca8
	if ctx.cr[6].eq {
	pc = 0x822B4CA8; continue 'dispatch;
	}
	// 822B4BB8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B4BBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B4BC0: 419A0024  beq cr6, 0x822b4be4
	if ctx.cr[6].eq {
	pc = 0x822B4BE4; continue 'dispatch;
	}
	// 822B4BC4: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822B4BC8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B4BCC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B4BD0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B4BD4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B4BD8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822B4BDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B4BE0: 480000CC  b 0x822b4cac
	pc = 0x822B4CAC; continue 'dispatch;
            }
            0x822B4BE4 => {
    //   block [0x822B4BE4..0x822B4C00)
	// 822B4BE4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B4BE8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B4BEC: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 822B4BF0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B4BF4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822B4BF8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B4BFC: 40810054  ble 0x822b4c50
	if !ctx.cr[0].gt {
	pc = 0x822B4C50; continue 'dispatch;
	}
	pc = 0x822B4C00; continue 'dispatch;
            }
            0x822B4C00 => {
    //   block [0x822B4C00..0x822B4C20)
	// 822B4C00: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B4C04: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B4C08: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B4C0C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B4C10: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 822B4C14: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B4C18: 41980008  blt cr6, 0x822b4c20
	if ctx.cr[6].lt {
	pc = 0x822B4C20; continue 'dispatch;
	}
	// 822B4C1C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x822B4C20; continue 'dispatch;
            }
            0x822B4C20 => {
    //   block [0x822B4C20..0x822B4C3C)
	// 822B4C20: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B4C24: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B4C28: 419A0014  beq cr6, 0x822b4c3c
	if ctx.cr[6].eq {
	pc = 0x822B4C3C; continue 'dispatch;
	}
	// 822B4C2C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B4C30: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B4C34: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B4C38: 4800000C  b 0x822b4c44
	pc = 0x822B4C44; continue 'dispatch;
            }
            0x822B4C3C => {
    //   block [0x822B4C3C..0x822B4C44)
	// 822B4C3C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B4C40: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B4C44; continue 'dispatch;
            }
            0x822B4C44 => {
    //   block [0x822B4C44..0x822B4C50)
	// 822B4C44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B4C48: 4199FFB8  bgt cr6, 0x822b4c00
	if ctx.cr[6].gt {
	pc = 0x822B4C00; continue 'dispatch;
	}
	// 822B4C4C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x822B4C50; continue 'dispatch;
            }
            0x822B4C50 => {
    //   block [0x822B4C50..0x822B4C6C)
	// 822B4C50: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B4C54: 419A0040  beq cr6, 0x822b4c94
	if ctx.cr[6].eq {
	pc = 0x822B4C94; continue 'dispatch;
	}
	// 822B4C58: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B4C5C: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 822B4C60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B4C64: 41990008  bgt cr6, 0x822b4c6c
	if ctx.cr[6].gt {
	pc = 0x822B4C6C; continue 'dispatch;
	}
	// 822B4C68: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x822B4C6C; continue 'dispatch;
            }
            0x822B4C6C => {
    //   block [0x822B4C6C..0x822B4C94)
	// 822B4C6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B4C70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B4C74: 409A0020  bne cr6, 0x822b4c94
	if !ctx.cr[6].eq {
	pc = 0x822B4C94; continue 'dispatch;
	}
	// 822B4C78: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822B4C7C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822B4C80: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822B4C84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B4C88: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822B4C8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B4C90: 4800001C  b 0x822b4cac
	pc = 0x822B4CAC; continue 'dispatch;
            }
            0x822B4C94 => {
    //   block [0x822B4C94..0x822B4CA8)
	// 822B4C94: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B4C98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B4C9C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822B4CA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B4CA4: 48000008  b 0x822b4cac
	pc = 0x822B4CAC; continue 'dispatch;
            }
            0x822B4CA8 => {
    //   block [0x822B4CA8..0x822B4CAC)
	// 822B4CA8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x822B4CAC; continue 'dispatch;
            }
            0x822B4CAC => {
    //   block [0x822B4CAC..0x822B4CF4)
	// 822B4CAC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B4CB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B4CB4: 419A0040  beq cr6, 0x822b4cf4
	if ctx.cr[6].eq {
	pc = 0x822B4CF4; continue 'dispatch;
	}
	// 822B4CB8: 38800016  li r4, 0x16
	ctx.r[4].s64 = 22;
	// 822B4CBC: 4BF8893D  bl 0x8223d5f8
	ctx.lr = 0x822B4CC0;
	sub_8223D5F8(ctx, base);
	// 822B4CC0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B4CC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B4CC8: 419A002C  beq cr6, 0x822b4cf4
	if ctx.cr[6].eq {
	pc = 0x822B4CF4; continue 'dispatch;
	}
	// 822B4CCC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 822B4CD0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B4CD4: 388B7FB8  addi r4, r11, 0x7fb8
	ctx.r[4].s64 = ctx.r[11].s64 + 32696;
	// 822B4CD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B4CDC: 4BF781F5  bl 0x8222ced0
	ctx.lr = 0x822B4CE0;
	sub_8222CED0(ctx, base);
	// 822B4CE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B4CE4: 482EB335  bl 0x825a0018
	ctx.lr = 0x822B4CE8;
	sub_825A0018(ctx, base);
	// 822B4CE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B4CEC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822B4CF0: 4BF600E9  bl 0x82214dd8
	ctx.lr = 0x822B4CF4;
	sub_82214DD8(ctx, base);
	pc = 0x822B4CF4; continue 'dispatch;
            }
            0x822B4CF4 => {
    //   block [0x822B4CF4..0x822B4D3C)
	// 822B4CF4: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B4CF8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 822B4CFC: EDA0F828  fsubs f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 822B4D00: 3BAB0E68  addi r29, r11, 0xe68
	ctx.r[29].s64 = ctx.r[11].s64 + 3688;
	// 822B4D04: FF0DD800  fcmpu cr6, f13, f27
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[27].f64);
	// 822B4D08: 7D600026  mfcr r11
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[11].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B4D0C: 556ADF7A  rlwinm r10, r11, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822B4D10: 5569F77A  rlwinm r9, r11, 0x1e, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 822B4D14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B4D18: 7D484B78  or r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 822B4D1C: 7D9D442E  lfsx f12, r29, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B4D20: FD6CF82E  fsel f11, f12, f0, f31
	ctx.f[11].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[31].f64 };
	// 822B4D24: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822B4D28: C13F0024  lfs f9, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822B4D2C: FD405890  fmr f10, f11
	ctx.f[10].f64 = ctx.f[11].f64;
	// 822B4D30: FF0A4800  fcmpu cr6, f10, f9
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[9].f64);
	// 822B4D34: 40980008  bge cr6, 0x822b4d3c
	if !ctx.cr[6].lt {
	pc = 0x822B4D3C; continue 'dispatch;
	}
	// 822B4D38: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x822B4D3C; continue 'dispatch;
            }
            0x822B4D3C => {
    //   block [0x822B4D3C..0x822B4D6C)
	// 822B4D3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B4D40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B4D44: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 822B4D48: 419A0154  beq cr6, 0x822b4e9c
	if ctx.cr[6].eq {
	pc = 0x822B4E9C; continue 'dispatch;
	}
	// 822B4D4C: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 822B4D50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B4D54: 409A0018  bne cr6, 0x822b4d6c
	if !ctx.cr[6].eq {
	pc = 0x822B4D6C; continue 'dispatch;
	}
	// 822B4D58: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 822B4D5C: 807E6D9C  lwz r3, 0x6d9c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28060 as u32) ) } as u64;
	// 822B4D60: 48748791  bl 0x829fd4f0
	ctx.lr = 0x822B4D64;
	sub_829FD4F0(ctx, base);
	// 822B4D64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B4D68: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	pc = 0x822B4D6C; continue 'dispatch;
            }
            0x822B4D6C => {
    //   block [0x822B4D6C..0x822B4E84)
	// 822B4D6C: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 822B4D70: C01F0040  lfs f0, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B4D74: C3CB169C  lfs f30, 0x169c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5788 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822B4D78: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 822B4D7C: 4BF85215  bl 0x82239f90
	ctx.lr = 0x822B4D80;
	sub_82239F90(ctx, base);
	// 822B4D80: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 822B4D84: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822B4D88: C17F0040  lfs f11, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822B4D8C: C01C01E4  lfs f0, 0x1e4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(484 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B4D90: EC2B0032  fmuls f1, f11, f0
	ctx.f[1].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 822B4D94: C1BC024C  lfs f13, 0x24c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(588 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B4D98: C00AB634  lfs f0, -0x49cc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18892 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B4D9C: EFEC683A  fmadds f31, f12, f0, f13
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 822B4DA0: 4BF851F1  bl 0x82239f90
	ctx.lr = 0x822B4DA4;
	sub_82239F90(ctx, base);
	// 822B4DA4: FD400818  frsp f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 822B4DA8: C13F0040  lfs f9, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822B4DAC: C01C0154  lfs f0, 0x154(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B4DB0: C3BC00E0  lfs f29, 0xe0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(224 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822B4DB4: EC290032  fmuls f1, f9, f0
	ctx.f[1].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 822B4DB8: EF4AFF7A  fmadds f26, f10, f29, f31
	ctx.f[26].f64 = (((ctx.f[10].f64 * ctx.f[29].f64 + ctx.f[31].f64) as f32) as f64);
	// 822B4DBC: 4BF851D5  bl 0x82239f90
	ctx.lr = 0x822B4DC0;
	sub_82239F90(ctx, base);
	// 822B4DC0: FD000818  frsp f8, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].f64 = (ctx.f[1].f64 as f32) as f64;
	// 822B4DC4: C39CDC84  lfs f28, -0x237c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9084 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 822B4DC8: C01C07AC  lfs f0, 0x7ac(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1964 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B4DCC: 38C00032  li r6, 0x32
	ctx.r[6].s64 = 50;
	// 822B4DD0: C1BC01A0  lfs f13, 0x1a0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B4DD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822B4DD8: C3FCDE40  lfs f31, -0x21c0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-8640 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822B4DDC: 807E6D9C  lwz r3, 0x6d9c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28060 as u32) ) } as u64;
	// 822B4DE0: ECE8D73A  fmadds f7, f8, f28, f26
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[28].f64 + ctx.f[26].f64) as f32) as f64);
	// 822B4DE4: EF470032  fmuls f26, f7, f0
	ctx.f[26].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 822B4DE8: EC3AFB7C  fnmsubs f1, f26, f13, f31
	ctx.f[1].f64 = -(((ctx.f[26].f64 * ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 822B4DEC: 487487F5  bl 0x829fd5e0
	ctx.lr = 0x822B4DF0;
	sub_829FD5E0(ctx, base);
	// 822B4DF0: ECDAFF3C  fnmsubs f6, f26, f28, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[6].f64 = -(((ctx.f[26].f64 * ctx.f[28].f64 - ctx.f[31].f64) as f32) as f64);
	// 822B4DF4: 38A00032  li r5, 0x32
	ctx.r[5].s64 = 50;
	// 822B4DF8: 807E6D9C  lwz r3, 0x6d9c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28060 as u32) ) } as u64;
	// 822B4DFC: EC26E82A  fadds f1, f6, f29
	ctx.f[1].f64 = ((ctx.f[6].f64 + ctx.f[29].f64) as f32) as f64;
	// 822B4E00: 48747FF1  bl 0x829fcdf0
	ctx.lr = 0x822B4E04;
	sub_829FCDF0(ctx, base);
	// 822B4E04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B4E08: 488E2071  bl 0x82b96e78
	ctx.lr = 0x822B4E0C;
	sub_82B96E78(ctx, base);
	// 822B4E0C: C0BF0040  lfs f5, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 822B4E10: EC2507B2  fmuls f1, f5, f30
	ctx.f[1].f64 = (((ctx.f[5].f64 * ctx.f[30].f64) as f32) as f64);
	// 822B4E14: 4BF8517D  bl 0x82239f90
	ctx.lr = 0x822B4E18;
	sub_82239F90(ctx, base);
	// 822B4E18: FC800818  frsp f4, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[4].f64 = (ctx.f[1].f64 as f32) as f64;
	// 822B4E1C: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 822B4E20: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822B4E24: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 822B4E28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B4E2C: C009163C  lfs f0, 0x163c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(5692 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B4E30: EC640032  fmuls f3, f4, f0
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 822B4E34: FC401A10  fabs f2, f3
	ctx.f[2].u64 = ctx.f[3].u64 & !0x8000_0000_0000_0000u64;
	// 822B4E38: EC22F828  fsubs f1, f2, f31
	ctx.f[1].f64 = (((ctx.f[2].f64 - ctx.f[31].f64) as f32) as f64);
	// 822B4E3C: FF01D800  fcmpu cr6, f1, f27
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[27].f64);
	// 822B4E40: 7D000026  mfcr r8
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[8].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822B4E44: 5507DF7A  rlwinm r7, r8, 0x1b, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 822B4E48: 5506F77A  rlwinm r6, r8, 0x1e, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 822B4E4C: 7CEB3378  or r11, r7, r6
	ctx.r[11].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 822B4E50: 7C1D5C2E  lfsx f0, r29, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B4E54: FC2017EE  fsel f1, f0, f31, f2
	ctx.f[1].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[2].f64 };
	// 822B4E58: 4894DD31  bl 0x82c02b88
	ctx.lr = 0x822B4E5C;
	sub_82C02B88(ctx, base);
	// 822B4E5C: C19F0040  lfs f12, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B4E60: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822B4E64: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B4E68: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 822B4E6C: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822B4E70: C1AA9040  lfs f13, -0x6fc0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28608 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B4E74: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822B4E78: 4198000C  blt cr6, 0x822b4e84
	if ctx.cr[6].lt {
	pc = 0x822B4E84; continue 'dispatch;
	}
	// 822B4E7C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 822B4E80: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	pc = 0x822B4E84; continue 'dispatch;
            }
            0x822B4E84 => {
    //   block [0x822B4E84..0x822B4E9C)
	// 822B4E84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B4E88: 488E1FF1  bl 0x82b96e78
	ctx.lr = 0x822B4E8C;
	sub_82B96E78(ctx, base);
	// 822B4E8C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822B4E90: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 822B4E94: 489F8E89  bl 0x82cadd1c
	ctx.lr = 0x822B4E98;
	sub_82CADCEC(ctx, base);
	// 822B4E98: 489F45BC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B4E9C => {
    //   block [0x822B4E9C..0x822B4EE4)
	// 822B4E9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B4EA0: 419A0084  beq cr6, 0x822b4f24
	if ctx.cr[6].eq {
	pc = 0x822B4F24; continue 'dispatch;
	}
	// 822B4EA4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B4EA8: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 822B4EAC: 386B4A34  addi r3, r11, 0x4a34
	ctx.r[3].s64 = ctx.r[11].s64 + 18996;
	// 822B4EB0: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 822B4EB4: 4BF3EEA5  bl 0x821f3d58
	ctx.lr = 0x822B4EB8;
	sub_821F3D58(ctx, base);
	// 822B4EB8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822B4EBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822B4EC0: 806A6DA0  lwz r3, 0x6da0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28064 as u32) ) } as u64;
	// 822B4EC4: 4874AF95  bl 0x829ffe58
	ctx.lr = 0x822B4EC8;
	sub_829FFE58(ctx, base);
	// 822B4EC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B4ECC: 419A0018  beq cr6, 0x822b4ee4
	if ctx.cr[6].eq {
	pc = 0x822B4EE4; continue 'dispatch;
	}
	// 822B4ED0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B4ED4: 388B6A34  addi r4, r11, 0x6a34
	ctx.r[4].s64 = ctx.r[11].s64 + 27188;
	// 822B4ED8: 4809F161  bl 0x82354038
	ctx.lr = 0x822B4EDC;
	sub_82354038(ctx, base);
	// 822B4EDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822B4EE0: 48000008  b 0x822b4ee8
	pc = 0x822B4EE8; continue 'dispatch;
            }
            0x822B4EE4 => {
    //   block [0x822B4EE4..0x822B4EE8)
	// 822B4EE4: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	pc = 0x822B4EE8; continue 'dispatch;
            }
            0x822B4EE8 => {
    //   block [0x822B4EE8..0x822B4F24)
	// 822B4EE8: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 822B4EEC: 807E6D9C  lwz r3, 0x6d9c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28060 as u32) ) } as u64;
	// 822B4EF0: 48748601  bl 0x829fd4f0
	ctx.lr = 0x822B4EF4;
	sub_829FD4F0(ctx, base);
	// 822B4EF4: C3FCDE40  lfs f31, -0x21c0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-8640 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822B4EF8: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 822B4EFC: 807E6D9C  lwz r3, 0x6d9c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28060 as u32) ) } as u64;
	// 822B4F00: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822B4F04: 48747EED  bl 0x829fcdf0
	ctx.lr = 0x822B4F08;
	sub_829FCDF0(ctx, base);
	// 822B4F08: D37F0040  stfs f27, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822B4F0C: 38C007D0  li r6, 0x7d0
	ctx.r[6].s64 = 2000;
	// 822B4F10: 807E6D9C  lwz r3, 0x6d9c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28060 as u32) ) } as u64;
	// 822B4F14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822B4F18: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822B4F1C: 487486C5  bl 0x829fd5e0
	ctx.lr = 0x822B4F20;
	sub_829FD5E0(ctx, base);
	// 822B4F20: 9B7F0044  stb r27, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[27].u8 ) };
	pc = 0x822B4F24; continue 'dispatch;
            }
            0x822B4F24 => {
    //   block [0x822B4F24..0x822B4F34)
	// 822B4F24: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822B4F28: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 822B4F2C: 489F8DF1  bl 0x82cadd1c
	ctx.lr = 0x822B4F30;
	sub_82CADCEC(ctx, base);
	// 822B4F30: 489F4524  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B4F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B4F38 size=148
    let mut pc: u32 = 0x822B4F38;
    'dispatch: loop {
        match pc {
            0x822B4F38 => {
    //   block [0x822B4F38..0x822B4FCC)
	// 822B4F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B4F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B4F40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B4F44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B4F48: 4BF01E39  bl 0x821b6d80
	ctx.lr = 0x822B4F4C;
	sub_821B6D80(ctx, base);
	// 822B4F4C: 4BEDD005  bl 0x82191f50
	ctx.lr = 0x822B4F50;
	sub_82191F50(ctx, base);
	// 822B4F50: 48010951  bl 0x822c58a0
	ctx.lr = 0x822B4F54;
	sub_822C58A0(ctx, base);
	// 822B4F54: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822B4F58: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 822B4F5C: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 822B4F60: 3D200240  lis r9, 0x240
	ctx.r[9].s64 = 37748736;
	// 822B4F64: 3BE8AA88  addi r31, r8, -0x5578
	ctx.r[31].s64 = ctx.r[8].s64 + -21880;
	// 822B4F68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822B4F6C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 822B4F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B4F74: 816B6E2C  lwz r11, 0x6e2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28204 as u32) ) } as u64;
	// 822B4F78: 814A1620  lwz r10, 0x1620(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5664 as u32) ) } as u64;
	// 822B4F7C: 3CEBFFD8  addis r7, r11, -0x28
	ctx.r[7].s64 = ctx.r[11].s64 + -2621440;
	// 822B4F80: 7CE4FE70  srawi r4, r7, 0x1f
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[7].s32 >> 31) as i64;
	// 822B4F84: 7C8B3838  and r11, r4, r7
	ctx.r[11].u64 = ctx.r[4].u64 & ctx.r[7].u64;
	// 822B4F88: 7D0B3850  subf r8, r11, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 822B4F8C: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B4F90: 7CE4FE70  srawi r4, r7, 0x1f
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[7].s32 >> 31) as i64;
	// 822B4F94: 7C8B3838  and r11, r4, r7
	ctx.r[11].u64 = ctx.r[4].u64 & ctx.r[7].u64;
	// 822B4F98: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 822B4F9C: 7C885050  subf r4, r8, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B4FA0: 4BECC209  bl 0x821811a8
	ctx.lr = 0x822B4FA4;
	sub_821811A8(ctx, base);
	// 822B4FA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822B4FA8: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 822B4FAC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 822B4FB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822B4FB4: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 822B4FB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822B4FBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B4FC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B4FC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B4FC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B4FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B4FD0 size=172
    let mut pc: u32 = 0x822B4FD0;
    'dispatch: loop {
        match pc {
            0x822B4FD0 => {
    //   block [0x822B4FD0..0x822B5008)
	// 822B4FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B4FD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B4FD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822B4FDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B4FE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B4FE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B4FE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822B4FEC: 48000095  bl 0x822b5080
	ctx.lr = 0x822B4FF0;
	sub_822B5080(ctx, base);
	// 822B4FF0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B4FF4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822B4FF8: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 822B4FFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5000: 40990040  ble cr6, 0x822b5040
	if !ctx.cr[6].gt {
	pc = 0x822B5040; continue 'dispatch;
	}
	// 822B5004: 397F0074  addi r11, r31, 0x74
	ctx.r[11].s64 = ctx.r[31].s64 + 116;
	pc = 0x822B5008; continue 'dispatch;
            }
            0x822B5008 => {
    //   block [0x822B5008..0x822B5040)
	// 822B5008: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B500C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822B5010: 7D3E4A14  add r9, r30, r9
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[9].u64;
	// 822B5014: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 822B5018: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822B501C: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822B5020: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 822B5024: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 822B5028: 990B0018  stb r8, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u8 ) };
	// 822B502C: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 822B5030: 396B004C  addi r11, r11, 0x4c
	ctx.r[11].s64 = ctx.r[11].s64 + 76;
	// 822B5034: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B5038: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B503C: 4198FFCC  blt cr6, 0x822b5008
	if ctx.cr[6].lt {
	pc = 0x822B5008; continue 'dispatch;
	}
	pc = 0x822B5040; continue 'dispatch;
            }
            0x822B5040 => {
    //   block [0x822B5040..0x822B507C)
	// 822B5040: 815F0514  lwz r10, 0x514(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1300 as u32) ) } as u64;
	// 822B5044: 397F0514  addi r11, r31, 0x514
	ctx.r[11].s64 = ctx.r[31].s64 + 1300;
	// 822B5048: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 822B504C: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822B5050: 917F0514  stw r11, 0x514(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1300 as u32), ctx.r[11].u32 ) };
	// 822B5054: 7D49FE70  srawi r9, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 822B5058: 7D285038  and r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 822B505C: 7CE85050  subf r7, r8, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B5060: 90FF0514  stw r7, 0x514(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1300 as u32), ctx.r[7].u32 ) };
	// 822B5064: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B5068: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B506C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B5070: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822B5074: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B5078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B5080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B5080 size=208
    let mut pc: u32 = 0x822B5080;
    'dispatch: loop {
        match pc {
            0x822B5080 => {
    //   block [0x822B5080..0x822B50B4)
	// 822B5080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B5084: 489F4389  bl 0x82ca940c
	ctx.lr = 0x822B5088;
	sub_82CA93D0(ctx, base);
	// 822B5088: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B508C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B5090: 4BF01DA1  bl 0x821b6e30
	ctx.lr = 0x822B5094;
	sub_821B6E30(ctx, base);
	// 822B5094: 3BFF0518  addi r31, r31, 0x518
	ctx.r[31].s64 = ctx.r[31].s64 + 1304;
	// 822B5098: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 822B509C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822B50A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B50A4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 822B50A8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B50AC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822B50B0: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	pc = 0x822B50B4; continue 'dispatch;
            }
            0x822B50B4 => {
    //   block [0x822B50B4..0x822B50C4)
	// 822B50B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B50B8: 419A000C  beq cr6, 0x822b50c4
	if ctx.cr[6].eq {
	pc = 0x822B50C4; continue 'dispatch;
	}
	// 822B50BC: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822B50C0: 419A0008  beq cr6, 0x822b50c8
	if ctx.cr[6].eq {
	pc = 0x822B50C8; continue 'dispatch;
	}
	pc = 0x822B50C4; continue 'dispatch;
            }
            0x822B50C4 => {
    //   block [0x822B50C4..0x822B50C8)
	// 822B50C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B50C8; continue 'dispatch;
            }
            0x822B50C8 => {
    //   block [0x822B50C8..0x822B50E0)
	// 822B50C8: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822B50CC: 419A007C  beq cr6, 0x822b5148
	if ctx.cr[6].eq {
	pc = 0x822B5148; continue 'dispatch;
	}
	// 822B50D0: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 822B50D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B50D8: 409A0008  bne cr6, 0x822b50e0
	if !ctx.cr[6].eq {
	pc = 0x822B50E0; continue 'dispatch;
	}
	// 822B50DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B50E0; continue 'dispatch;
            }
            0x822B50E0 => {
    //   block [0x822B50E0..0x822B50F0)
	// 822B50E0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B50E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B50E8: 409A0008  bne cr6, 0x822b50f0
	if !ctx.cr[6].eq {
	pc = 0x822B50F0; continue 'dispatch;
	}
	// 822B50EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B50F0; continue 'dispatch;
            }
            0x822B50F0 => {
    //   block [0x822B50F0..0x822B5104)
	// 822B50F0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B50F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B50F8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 822B50FC: 409A0008  bne cr6, 0x822b5104
	if !ctx.cr[6].eq {
	pc = 0x822B5104; continue 'dispatch;
	}
	// 822B5100: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B5104; continue 'dispatch;
            }
            0x822B5104 => {
    //   block [0x822B5104..0x822B5134)
	// 822B5104: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B5108: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 822B510C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B5110: 419A0024  beq cr6, 0x822b5134
	if ctx.cr[6].eq {
	pc = 0x822B5134; continue 'dispatch;
	}
	// 822B5114: 488AA9CD  bl 0x82b5fae0
	ctx.lr = 0x822B5118;
	sub_82B5FAE0(ctx, base);
	// 822B5118: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B511C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5120: 409A0014  bne cr6, 0x822b5134
	if !ctx.cr[6].eq {
	pc = 0x822B5134; continue 'dispatch;
	}
	// 822B5124: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822B5128: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822B512C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B5130: 488AC4C1  bl 0x82b615f0
	ctx.lr = 0x822B5134;
	sub_82B615F0(ctx, base);
	pc = 0x822B5134; continue 'dispatch;
            }
            0x822B5134 => {
    //   block [0x822B5134..0x822B5148)
	// 822B5134: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B5138: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 822B513C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B5140: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822B5144: 4BFFFF70  b 0x822b50b4
	pc = 0x822B50B4; continue 'dispatch;
            }
            0x822B5148 => {
    //   block [0x822B5148..0x822B5150)
	// 822B5148: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822B514C: 489F4310  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B5150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B5150 size=420
    let mut pc: u32 = 0x822B5150;
    'dispatch: loop {
        match pc {
            0x822B5150 => {
    //   block [0x822B5150..0x822B519C)
	// 822B5150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B5154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B5158: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B515C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B5160: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 822B5164: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 822B5168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B516C: 419A0084  beq cr6, 0x822b51f0
	if ctx.cr[6].eq {
	pc = 0x822B51F0; continue 'dispatch;
	}
	// 822B5170: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B5174: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B5178: 419A0074  beq cr6, 0x822b51ec
	if ctx.cr[6].eq {
	pc = 0x822B51EC; continue 'dispatch;
	}
	// 822B517C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822B5180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5184: 419A0018  beq cr6, 0x822b519c
	if ctx.cr[6].eq {
	pc = 0x822B519C; continue 'dispatch;
	}
	// 822B5188: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 822B518C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822B5190: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B5194: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B5198: 409A0008  bne cr6, 0x822b51a0
	if !ctx.cr[6].eq {
	pc = 0x822B51A0; continue 'dispatch;
	}
	pc = 0x822B519C; continue 'dispatch;
            }
            0x822B519C => {
    //   block [0x822B519C..0x822B51A0)
	// 822B519C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x822B51A0; continue 'dispatch;
            }
            0x822B51A0 => {
    //   block [0x822B51A0..0x822B51EC)
	// 822B51A0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822B51A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B51A8: 419A013C  beq cr6, 0x822b52e4
	if ctx.cr[6].eq {
	pc = 0x822B52E4; continue 'dispatch;
	}
	// 822B51AC: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822B51B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822B51B4: 552857FE  rlwinm r8, r9, 0xa, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x003FFFFFu64;
	// 822B51B8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822B51BC: 419A0104  beq cr6, 0x822b52c0
	if ctx.cr[6].eq {
	pc = 0x822B52C0; continue 'dispatch;
	}
	// 822B51C0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B51C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B51C8: 419A0030  beq cr6, 0x822b51f8
	if ctx.cr[6].eq {
	pc = 0x822B51F8; continue 'dispatch;
	}
	// 822B51CC: 894A0076  lbz r10, 0x76(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(118 as u32) ) } as u64;
	// 822B51D0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B51D4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B51D8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B51DC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B51E0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B51E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B51E8: 480000DC  b 0x822b52c4
	pc = 0x822B52C4; continue 'dispatch;
            }
            0x822B51EC => {
    //   block [0x822B51EC..0x822B51F0)
	// 822B51EC: 4BEDEC4D  bl 0x82193e38
	ctx.lr = 0x822B51F0;
	sub_82193E38(ctx, base);
	pc = 0x822B51F0; continue 'dispatch;
            }
            0x822B51F0 => {
    //   block [0x822B51F0..0x822B51F8)
	// 822B51F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822B51F4: 4BFFFFA8  b 0x822b519c
	pc = 0x822B519C; continue 'dispatch;
            }
            0x822B51F8 => {
    //   block [0x822B51F8..0x822B5218)
	// 822B51F8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B51FC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822B5200: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B5204: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 822B5208: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B520C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B5210: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B5214: 40810054  ble 0x822b5268
	if !ctx.cr[0].gt {
	pc = 0x822B5268; continue 'dispatch;
	}
	pc = 0x822B5218; continue 'dispatch;
            }
            0x822B5218 => {
    //   block [0x822B5218..0x822B5238)
	// 822B5218: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B521C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B5220: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B5224: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B5228: 2F070076  cmpwi cr6, r7, 0x76
	ctx.cr[6].compare_i32(ctx.r[7].s32, 118, &mut ctx.xer);
	// 822B522C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B5230: 41980008  blt cr6, 0x822b5238
	if ctx.cr[6].lt {
	pc = 0x822B5238; continue 'dispatch;
	}
	// 822B5234: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822B5238; continue 'dispatch;
            }
            0x822B5238 => {
    //   block [0x822B5238..0x822B5254)
	// 822B5238: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B523C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B5240: 419A0014  beq cr6, 0x822b5254
	if ctx.cr[6].eq {
	pc = 0x822B5254; continue 'dispatch;
	}
	// 822B5244: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B5248: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B524C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B5250: 4800000C  b 0x822b525c
	pc = 0x822B525C; continue 'dispatch;
            }
            0x822B5254 => {
    //   block [0x822B5254..0x822B525C)
	// 822B5254: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B5258: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B525C; continue 'dispatch;
            }
            0x822B525C => {
    //   block [0x822B525C..0x822B5268)
	// 822B525C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B5260: 4199FFB8  bgt cr6, 0x822b5218
	if ctx.cr[6].gt {
	pc = 0x822B5218; continue 'dispatch;
	}
	// 822B5264: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B5268; continue 'dispatch;
            }
            0x822B5268 => {
    //   block [0x822B5268..0x822B5284)
	// 822B5268: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B526C: 419A0040  beq cr6, 0x822b52ac
	if ctx.cr[6].eq {
	pc = 0x822B52AC; continue 'dispatch;
	}
	// 822B5270: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B5274: 2F0B0076  cmpwi cr6, r11, 0x76
	ctx.cr[6].compare_i32(ctx.r[11].s32, 118, &mut ctx.xer);
	// 822B5278: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B527C: 41990008  bgt cr6, 0x822b5284
	if ctx.cr[6].gt {
	pc = 0x822B5284; continue 'dispatch;
	}
	// 822B5280: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822B5284; continue 'dispatch;
            }
            0x822B5284 => {
    //   block [0x822B5284..0x822B52AC)
	// 822B5284: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B5288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B528C: 409A0020  bne cr6, 0x822b52ac
	if !ctx.cr[6].eq {
	pc = 0x822B52AC; continue 'dispatch;
	}
	// 822B5290: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B5294: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822B5298: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B529C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B52A0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B52A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B52A8: 4800001C  b 0x822b52c4
	pc = 0x822B52C4; continue 'dispatch;
            }
            0x822B52AC => {
    //   block [0x822B52AC..0x822B52C0)
	// 822B52AC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B52B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B52B4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B52B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B52BC: 48000008  b 0x822b52c4
	pc = 0x822B52C4; continue 'dispatch;
            }
            0x822B52C0 => {
    //   block [0x822B52C0..0x822B52C4)
	// 822B52C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822B52C4; continue 'dispatch;
            }
            0x822B52C4 => {
    //   block [0x822B52C4..0x822B52E4)
	// 822B52C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B52C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B52CC: 419A0018  beq cr6, 0x822b52e4
	if ctx.cr[6].eq {
	pc = 0x822B52E4; continue 'dispatch;
	}
	// 822B52D0: 816A01E4  lwz r11, 0x1e4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(484 as u32) ) } as u64;
	// 822B52D4: 386A01E4  addi r3, r10, 0x1e4
	ctx.r[3].s64 = ctx.r[10].s64 + 484;
	// 822B52D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B52DC: 419A0008  beq cr6, 0x822b52e4
	if ctx.cr[6].eq {
	pc = 0x822B52E4; continue 'dispatch;
	}
	// 822B52E0: 48010749  bl 0x822c5a28
	ctx.lr = 0x822B52E4;
	sub_822C5A28(ctx, base);
	pc = 0x822B52E4; continue 'dispatch;
            }
            0x822B52E4 => {
    //   block [0x822B52E4..0x822B52F4)
	// 822B52E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822B52E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B52EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B52F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B52F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B52F8 size=100
    let mut pc: u32 = 0x822B52F8;
    'dispatch: loop {
        match pc {
            0x822B52F8 => {
    //   block [0x822B52F8..0x822B535C)
	// 822B52F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B52FC: 489F4111  bl 0x82ca940c
	ctx.lr = 0x822B5300;
	sub_82CA93D0(ctx, base);
	// 822B5300: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B5304: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B5308: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 822B530C: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 822B5310: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B5314: C03D9A80  lfs f1, -0x6580(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822B5318: 4BFAB8F1  bl 0x82260c08
	ctx.lr = 0x822B531C;
	sub_82260C08(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B5360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B5360 size=1024
    let mut pc: u32 = 0x822B5360;
    'dispatch: loop {
        match pc {
            0x822B5360 => {
    //   block [0x822B5360..0x822B53B0)
	// 822B5360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B5364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B5368: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B536C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B5370: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822B5374: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822B5378: 556A8FFE  rlwinm r10, r11, 0x11, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	// 822B537C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822B5380: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B5384: 419A00E8  beq cr6, 0x822b546c
	if ctx.cr[6].eq {
	pc = 0x822B546C; continue 'dispatch;
	}
	// 822B5388: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B538C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5390: 419A0020  beq cr6, 0x822b53b0
	if ctx.cr[6].eq {
	pc = 0x822B53B0; continue 'dispatch;
	}
	// 822B5394: 894B006F  lbz r10, 0x6f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(111 as u32) ) } as u64;
	// 822B5398: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B539C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B53A0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B53A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B53A8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B53AC: 480000C4  b 0x822b5470
	pc = 0x822B5470; continue 'dispatch;
            }
            0x822B53B0 => {
    //   block [0x822B53B0..0x822B53CC)
	// 822B53B0: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B53B4: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B53B8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822B53BC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B53C0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B53C4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B53C8: 40810054  ble 0x822b541c
	if !ctx.cr[0].gt {
	pc = 0x822B541C; continue 'dispatch;
	}
	pc = 0x822B53CC; continue 'dispatch;
            }
            0x822B53CC => {
    //   block [0x822B53CC..0x822B53EC)
	// 822B53CC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B53D0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B53D4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B53D8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B53DC: 2F07006F  cmpwi cr6, r7, 0x6f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 111, &mut ctx.xer);
	// 822B53E0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B53E4: 41980008  blt cr6, 0x822b53ec
	if ctx.cr[6].lt {
	pc = 0x822B53EC; continue 'dispatch;
	}
	// 822B53E8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x822B53EC; continue 'dispatch;
            }
            0x822B53EC => {
    //   block [0x822B53EC..0x822B5408)
	// 822B53EC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B53F0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B53F4: 419A0014  beq cr6, 0x822b5408
	if ctx.cr[6].eq {
	pc = 0x822B5408; continue 'dispatch;
	}
	// 822B53F8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B53FC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B5400: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B5404: 4800000C  b 0x822b5410
	pc = 0x822B5410; continue 'dispatch;
            }
            0x822B5408 => {
    //   block [0x822B5408..0x822B5410)
	// 822B5408: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B540C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B5410; continue 'dispatch;
            }
            0x822B5410 => {
    //   block [0x822B5410..0x822B541C)
	// 822B5410: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B5414: 4199FFB8  bgt cr6, 0x822b53cc
	if ctx.cr[6].gt {
	pc = 0x822B53CC; continue 'dispatch;
	}
	// 822B5418: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B541C; continue 'dispatch;
            }
            0x822B541C => {
    //   block [0x822B541C..0x822B5438)
	// 822B541C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B5420: 419A003C  beq cr6, 0x822b545c
	if ctx.cr[6].eq {
	pc = 0x822B545C; continue 'dispatch;
	}
	// 822B5424: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B5428: 2F0B006F  cmpwi cr6, r11, 0x6f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 111, &mut ctx.xer);
	// 822B542C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5430: 41990008  bgt cr6, 0x822b5438
	if ctx.cr[6].gt {
	pc = 0x822B5438; continue 'dispatch;
	}
	// 822B5434: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B5438; continue 'dispatch;
            }
            0x822B5438 => {
    //   block [0x822B5438..0x822B545C)
	// 822B5438: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B543C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5440: 409A001C  bne cr6, 0x822b545c
	if !ctx.cr[6].eq {
	pc = 0x822B545C; continue 'dispatch;
	}
	// 822B5444: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B5448: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B544C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822B5450: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B5454: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B5458: 48000018  b 0x822b5470
	pc = 0x822B5470; continue 'dispatch;
            }
            0x822B545C => {
    //   block [0x822B545C..0x822B546C)
	// 822B545C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B5460: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B5464: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B5468: 48000008  b 0x822b5470
	pc = 0x822B5470; continue 'dispatch;
            }
            0x822B546C => {
    //   block [0x822B546C..0x822B5470)
	// 822B546C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x822B5470; continue 'dispatch;
            }
            0x822B5470 => {
    //   block [0x822B5470..0x822B5488)
	// 822B5470: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822B5474: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B5478: 419A0010  beq cr6, 0x822b5488
	if ctx.cr[6].eq {
	pc = 0x822B5488; continue 'dispatch;
	}
	// 822B547C: 896B006C  lbz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 822B5480: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5484: 409A0298  bne cr6, 0x822b571c
	if !ctx.cr[6].eq {
	pc = 0x822B571C; continue 'dispatch;
	}
	pc = 0x822B5488; continue 'dispatch;
            }
            0x822B5488 => {
    //   block [0x822B5488..0x822B54C4)
	// 822B5488: 81430034  lwz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 822B548C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822B5490: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 822B5494: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B5498: 419A00E8  beq cr6, 0x822b5580
	if ctx.cr[6].eq {
	pc = 0x822B5580; continue 'dispatch;
	}
	// 822B549C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B54A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B54A4: 419A0020  beq cr6, 0x822b54c4
	if ctx.cr[6].eq {
	pc = 0x822B54C4; continue 'dispatch;
	}
	// 822B54A8: 894B009A  lbz r10, 0x9a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(154 as u32) ) } as u64;
	// 822B54AC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B54B0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B54B4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B54B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B54BC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B54C0: 480000C4  b 0x822b5584
	pc = 0x822B5584; continue 'dispatch;
            }
            0x822B54C4 => {
    //   block [0x822B54C4..0x822B54E0)
	// 822B54C4: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B54C8: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B54CC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822B54D0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B54D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B54D8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B54DC: 40810054  ble 0x822b5530
	if !ctx.cr[0].gt {
	pc = 0x822B5530; continue 'dispatch;
	}
	pc = 0x822B54E0; continue 'dispatch;
            }
            0x822B54E0 => {
    //   block [0x822B54E0..0x822B5500)
	// 822B54E0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B54E4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B54E8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B54EC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B54F0: 2F07009A  cmpwi cr6, r7, 0x9a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 154, &mut ctx.xer);
	// 822B54F4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B54F8: 41980008  blt cr6, 0x822b5500
	if ctx.cr[6].lt {
	pc = 0x822B5500; continue 'dispatch;
	}
	// 822B54FC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x822B5500; continue 'dispatch;
            }
            0x822B5500 => {
    //   block [0x822B5500..0x822B551C)
	// 822B5500: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B5504: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B5508: 419A0014  beq cr6, 0x822b551c
	if ctx.cr[6].eq {
	pc = 0x822B551C; continue 'dispatch;
	}
	// 822B550C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B5510: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B5514: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B5518: 4800000C  b 0x822b5524
	pc = 0x822B5524; continue 'dispatch;
            }
            0x822B551C => {
    //   block [0x822B551C..0x822B5524)
	// 822B551C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B5520: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B5524; continue 'dispatch;
            }
            0x822B5524 => {
    //   block [0x822B5524..0x822B5530)
	// 822B5524: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B5528: 4199FFB8  bgt cr6, 0x822b54e0
	if ctx.cr[6].gt {
	pc = 0x822B54E0; continue 'dispatch;
	}
	// 822B552C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B5530; continue 'dispatch;
            }
            0x822B5530 => {
    //   block [0x822B5530..0x822B554C)
	// 822B5530: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B5534: 419A003C  beq cr6, 0x822b5570
	if ctx.cr[6].eq {
	pc = 0x822B5570; continue 'dispatch;
	}
	// 822B5538: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B553C: 2F0B009A  cmpwi cr6, r11, 0x9a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 154, &mut ctx.xer);
	// 822B5540: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5544: 41990008  bgt cr6, 0x822b554c
	if ctx.cr[6].gt {
	pc = 0x822B554C; continue 'dispatch;
	}
	// 822B5548: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B554C; continue 'dispatch;
            }
            0x822B554C => {
    //   block [0x822B554C..0x822B5570)
	// 822B554C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B5550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5554: 409A001C  bne cr6, 0x822b5570
	if !ctx.cr[6].eq {
	pc = 0x822B5570; continue 'dispatch;
	}
	// 822B5558: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B555C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B5560: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822B5564: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B5568: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B556C: 48000018  b 0x822b5584
	pc = 0x822B5584; continue 'dispatch;
            }
            0x822B5570 => {
    //   block [0x822B5570..0x822B5580)
	// 822B5570: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B5574: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B5578: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B557C: 48000008  b 0x822b5584
	pc = 0x822B5584; continue 'dispatch;
            }
            0x822B5580 => {
    //   block [0x822B5580..0x822B5584)
	// 822B5580: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x822B5584; continue 'dispatch;
            }
            0x822B5584 => {
    //   block [0x822B5584..0x822B559C)
	// 822B5584: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822B5588: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B558C: 419A0010  beq cr6, 0x822b559c
	if ctx.cr[6].eq {
	pc = 0x822B559C; continue 'dispatch;
	}
	// 822B5590: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 822B5594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5598: 41990184  bgt cr6, 0x822b571c
	if ctx.cr[6].gt {
	pc = 0x822B571C; continue 'dispatch;
	}
	pc = 0x822B559C; continue 'dispatch;
            }
            0x822B559C => {
    //   block [0x822B559C..0x822B55D8)
	// 822B559C: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 822B55A0: 556A7FFE  rlwinm r10, r11, 0xf, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0001FFFFu64;
	// 822B55A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B55A8: 419A00F0  beq cr6, 0x822b5698
	if ctx.cr[6].eq {
	pc = 0x822B5698; continue 'dispatch;
	}
	// 822B55AC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B55B0: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B55B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B55B8: 419A0020  beq cr6, 0x822b55d8
	if ctx.cr[6].eq {
	pc = 0x822B55D8; continue 'dispatch;
	}
	// 822B55BC: 896B0031  lbz r11, 0x31(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 822B55C0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 822B55C4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822B55C8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B55CC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B55D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B55D4: 480000C8  b 0x822b569c
	pc = 0x822B569C; continue 'dispatch;
            }
            0x822B55D8 => {
    //   block [0x822B55D8..0x822B55F0)
	// 822B55D8: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B55DC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822B55E0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B55E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B55E8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B55EC: 40810054  ble 0x822b5640
	if !ctx.cr[0].gt {
	pc = 0x822B5640; continue 'dispatch;
	}
	pc = 0x822B55F0; continue 'dispatch;
            }
            0x822B55F0 => {
    //   block [0x822B55F0..0x822B5610)
	// 822B55F0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B55F4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B55F8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B55FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B5600: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 822B5604: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B5608: 41980008  blt cr6, 0x822b5610
	if ctx.cr[6].lt {
	pc = 0x822B5610; continue 'dispatch;
	}
	// 822B560C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x822B5610; continue 'dispatch;
            }
            0x822B5610 => {
    //   block [0x822B5610..0x822B562C)
	// 822B5610: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B5614: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B5618: 419A0014  beq cr6, 0x822b562c
	if ctx.cr[6].eq {
	pc = 0x822B562C; continue 'dispatch;
	}
	// 822B561C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B5620: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B5624: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B5628: 4800000C  b 0x822b5634
	pc = 0x822B5634; continue 'dispatch;
            }
            0x822B562C => {
    //   block [0x822B562C..0x822B5634)
	// 822B562C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B5630: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B5634; continue 'dispatch;
            }
            0x822B5634 => {
    //   block [0x822B5634..0x822B5640)
	// 822B5634: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B5638: 4199FFB8  bgt cr6, 0x822b55f0
	if ctx.cr[6].gt {
	pc = 0x822B55F0; continue 'dispatch;
	}
	// 822B563C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B5640; continue 'dispatch;
            }
            0x822B5640 => {
    //   block [0x822B5640..0x822B565C)
	// 822B5640: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B5644: 419A0040  beq cr6, 0x822b5684
	if ctx.cr[6].eq {
	pc = 0x822B5684; continue 'dispatch;
	}
	// 822B5648: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B564C: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 822B5650: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5654: 41990008  bgt cr6, 0x822b565c
	if ctx.cr[6].gt {
	pc = 0x822B565C; continue 'dispatch;
	}
	// 822B5658: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B565C; continue 'dispatch;
            }
            0x822B565C => {
    //   block [0x822B565C..0x822B5684)
	// 822B565C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B5660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5664: 409A0020  bne cr6, 0x822b5684
	if !ctx.cr[6].eq {
	pc = 0x822B5684; continue 'dispatch;
	}
	// 822B5668: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B566C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822B5670: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B5674: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B5678: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B567C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5680: 4800001C  b 0x822b569c
	pc = 0x822B569C; continue 'dispatch;
            }
            0x822B5684 => {
    //   block [0x822B5684..0x822B5698)
	// 822B5684: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B5688: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B568C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B5690: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5694: 48000008  b 0x822b569c
	pc = 0x822B569C; continue 'dispatch;
            }
            0x822B5698 => {
    //   block [0x822B5698..0x822B569C)
	// 822B5698: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B569C; continue 'dispatch;
            }
            0x822B569C => {
    //   block [0x822B569C..0x822B571C)
	// 822B569C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B56A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B56A4: 419A00A4  beq cr6, 0x822b5748
	if ctx.cr[6].eq {
	pc = 0x822B5748; continue 'dispatch;
	}
	// 822B56A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B56AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B56B0: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B56B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B56B8: 4E800421  bctrl
	ctx.lr = 0x822B56BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B56BC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B56C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B56C4: 419A0084  beq cr6, 0x822b5748
	if ctx.cr[6].eq {
	pc = 0x822B5748; continue 'dispatch;
	}
	// 822B56C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B56CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822B56D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B56D4: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 822B56D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B56DC: 4E800421  bctrl
	ctx.lr = 0x822B56E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B56E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B56E4: 4800007D  bl 0x822b5760
	ctx.lr = 0x822B56E8;
	sub_822B5760(ctx, base);
	// 822B56E8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B56EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B56F0: 409A0044  bne cr6, 0x822b5734
	if !ctx.cr[6].eq {
	pc = 0x822B5734; continue 'dispatch;
	}
	// 822B56F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B56F8: 480087A9  bl 0x822bdea0
	ctx.lr = 0x822B56FC;
	sub_822BDEA0(ctx, base);
	// 822B56FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B5700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5704: 409A0030  bne cr6, 0x822b5734
	if !ctx.cr[6].eq {
	pc = 0x822B5734; continue 'dispatch;
	}
	// 822B5708: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822B570C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B5710: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 822B5714: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822B5718: 4BEDE721  bl 0x82193e38
	ctx.lr = 0x822B571C;
	sub_82193E38(ctx, base);
            }
            0x822B571C => {
    //   block [0x822B571C..0x822B5734)
	// 822B571C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822B5720: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B5724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B5728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B572C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B5730: 4E800020  blr
	return;
            }
            0x822B5734 => {
    //   block [0x822B5734..0x822B5748)
	// 822B5734: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822B5738: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B573C: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 822B5740: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822B5744: 4BEDE6F5  bl 0x82193e38
	ctx.lr = 0x822B5748;
	sub_82193E38(ctx, base);
	pc = 0x822B5748; continue 'dispatch;
            }
            0x822B5748 => {
    //   block [0x822B5748..0x822B5760)
	// 822B5748: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822B574C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B5750: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B5754: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B5758: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B575C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B5760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B5760 size=120
    let mut pc: u32 = 0x822B5760;
    'dispatch: loop {
        match pc {
            0x822B5760 => {
    //   block [0x822B5760..0x822B5790)
	// 822B5760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B5764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B5768: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B576C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B5770: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B5774: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B5778: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B577C: 41980014  blt cr6, 0x822b5790
	if ctx.cr[6].lt {
	pc = 0x822B5790; continue 'dispatch;
	}
	// 822B5780: 4BFE2FB9  bl 0x82298738
	ctx.lr = 0x822B5784;
	sub_82298738(ctx, base);
	// 822B5784: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B5788: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B578C: 409A0008  bne cr6, 0x822b5794
	if !ctx.cr[6].eq {
	pc = 0x822B5794; continue 'dispatch;
	}
	pc = 0x822B5790; continue 'dispatch;
            }
            0x822B5790 => {
    //   block [0x822B5790..0x822B5794)
	// 822B5790: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822B5794; continue 'dispatch;
            }
            0x822B5794 => {
    //   block [0x822B5794..0x822B57C0)
	// 822B5794: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B5798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B579C: 419A0024  beq cr6, 0x822b57c0
	if ctx.cr[6].eq {
	pc = 0x822B57C0; continue 'dispatch;
	}
	// 822B57A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B57A4: 4BFE2F95  bl 0x82298738
	ctx.lr = 0x822B57A8;
	sub_82298738(ctx, base);
	// 822B57A8: 4BFF81A9  bl 0x822ad950
	ctx.lr = 0x822B57AC;
	sub_822AD950(ctx, base);
	// 822B57AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822B57B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B57B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B57B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B57BC: 4E800020  blr
	return;
            }
            0x822B57C0 => {
    //   block [0x822B57C0..0x822B57D8)
	// 822B57C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822B57C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822B57C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B57CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B57D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B57D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B57D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B57D8 size=164
    let mut pc: u32 = 0x822B57D8;
    'dispatch: loop {
        match pc {
            0x822B57D8 => {
    //   block [0x822B57D8..0x822B5848)
	// 822B57D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B57DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B57E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B57E4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B57E8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822B57EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B57F0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822B57F4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B57F8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B57FC: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B5800: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B5804: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B5808: 4BF7CF71  bl 0x82232778
	ctx.lr = 0x822B580C;
	sub_82232778(ctx, base);
	// 822B580C: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B5810: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B5814: 419A0050  beq cr6, 0x822b5864
	if ctx.cr[6].eq {
	pc = 0x822B5864; continue 'dispatch;
	}
	// 822B5818: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822B581C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B5820: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B5824: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 822B5828: 4BFBD8B1  bl 0x822730d8
	ctx.lr = 0x822B582C;
	sub_822730D8(ctx, base);
	// 822B582C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B5830: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B5834: 419A0014  beq cr6, 0x822b5848
	if ctx.cr[6].eq {
	pc = 0x822B5848; continue 'dispatch;
	}
	// 822B5838: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822B583C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5840: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B5844: 409A0008  bne cr6, 0x822b584c
	if !ctx.cr[6].eq {
	pc = 0x822B584C; continue 'dispatch;
	}
	pc = 0x822B5848; continue 'dispatch;
            }
            0x822B5848 => {
    //   block [0x822B5848..0x822B584C)
	// 822B5848: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822B584C; continue 'dispatch;
            }
            0x822B584C => {
    //   block [0x822B584C..0x822B5864)
	// 822B584C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B5850: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B5854: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B5858: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B585C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B5860: 4E800020  blr
	return;
            }
            0x822B5864 => {
    //   block [0x822B5864..0x822B587C)
	// 822B5864: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822B5868: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B586C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B5870: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B5874: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B5878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B5880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B5880 size=2668
    let mut pc: u32 = 0x822B5880;
    'dispatch: loop {
        match pc {
            0x822B5880 => {
    //   block [0x822B5880..0x822B58D8)
	// 822B5880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B5884: 489F3B75  bl 0x82ca93f8
	ctx.lr = 0x822B5888;
	sub_82CA93D0(ctx, base);
	// 822B5888: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 822B588C: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 822B5890: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B5894: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822B5898: 3B1B0024  addi r24, r27, 0x24
	ctx.r[24].s64 = ctx.r[27].s64 + 36;
	// 822B589C: 817B0024  lwz r11, 0x24(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 822B58A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B58A4: 419A0034  beq cr6, 0x822b58d8
	if ctx.cr[6].eq {
	pc = 0x822B58D8; continue 'dispatch;
	}
	// 822B58A8: 817B002C  lwz r11, 0x2c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 822B58AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B58B0: 419A0028  beq cr6, 0x822b58d8
	if ctx.cr[6].eq {
	pc = 0x822B58D8; continue 'dispatch;
	}
	// 822B58B4: 817B0034  lwz r11, 0x34(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 822B58B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B58BC: 419A001C  beq cr6, 0x822b58d8
	if ctx.cr[6].eq {
	pc = 0x822B58D8; continue 'dispatch;
	}
	// 822B58C0: 817B0044  lwz r11, 0x44(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(68 as u32) ) } as u64;
	// 822B58C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B58C8: 419A0010  beq cr6, 0x822b58d8
	if ctx.cr[6].eq {
	pc = 0x822B58D8; continue 'dispatch;
	}
	// 822B58CC: 817B004C  lwz r11, 0x4c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B58D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B58D4: 409A0A08  bne cr6, 0x822b62dc
	if !ctx.cr[6].eq {
	pc = 0x822B62DC; continue 'dispatch;
	}
	pc = 0x822B58D8; continue 'dispatch;
            }
            0x822B58D8 => {
    //   block [0x822B58D8..0x822B592C)
	// 822B58D8: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B58DC: 4BF51F15  bl 0x822077f0
	ctx.lr = 0x822B58E0;
	sub_822077F0(ctx, base);
	// 822B58E0: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B58E4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822B58E8: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 822B58EC: 7F9AE378  mr r26, r28
	ctx.r[26].u64 = ctx.r[28].u64;
	// 822B58F0: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 822B58F4: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 822B58F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B58FC: 419A00F4  beq cr6, 0x822b59f0
	if ctx.cr[6].eq {
	pc = 0x822B59F0; continue 'dispatch;
	}
	// 822B5900: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B5904: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5908: 419A0024  beq cr6, 0x822b592c
	if ctx.cr[6].eq {
	pc = 0x822B592C; continue 'dispatch;
	}
	// 822B590C: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 822B5910: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B5914: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B5918: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B591C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B5920: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 822B5924: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5928: 480000CC  b 0x822b59f4
	pc = 0x822B59F4; continue 'dispatch;
            }
            0x822B592C => {
    //   block [0x822B592C..0x822B5948)
	// 822B592C: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B5930: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B5934: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 822B5938: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 822B593C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822B5940: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B5944: 40810054  ble 0x822b5998
	if !ctx.cr[0].gt {
	pc = 0x822B5998; continue 'dispatch;
	}
	pc = 0x822B5948; continue 'dispatch;
            }
            0x822B5948 => {
    //   block [0x822B5948..0x822B5968)
	// 822B5948: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B594C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B5950: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822B5954: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B5958: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 822B595C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B5960: 41980008  blt cr6, 0x822b5968
	if ctx.cr[6].lt {
	pc = 0x822B5968; continue 'dispatch;
	}
	// 822B5964: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x822B5968; continue 'dispatch;
            }
            0x822B5968 => {
    //   block [0x822B5968..0x822B5984)
	// 822B5968: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B596C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B5970: 419A0014  beq cr6, 0x822b5984
	if ctx.cr[6].eq {
	pc = 0x822B5984; continue 'dispatch;
	}
	// 822B5974: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B5978: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B597C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B5980: 4800000C  b 0x822b598c
	pc = 0x822B598C; continue 'dispatch;
            }
            0x822B5984 => {
    //   block [0x822B5984..0x822B598C)
	// 822B5984: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B5988: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B598C; continue 'dispatch;
            }
            0x822B598C => {
    //   block [0x822B598C..0x822B5998)
	// 822B598C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B5990: 4199FFB8  bgt cr6, 0x822b5948
	if ctx.cr[6].gt {
	pc = 0x822B5948; continue 'dispatch;
	}
	// 822B5994: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x822B5998; continue 'dispatch;
            }
            0x822B5998 => {
    //   block [0x822B5998..0x822B59B4)
	// 822B5998: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 822B599C: 419A0040  beq cr6, 0x822b59dc
	if ctx.cr[6].eq {
	pc = 0x822B59DC; continue 'dispatch;
	}
	// 822B59A0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B59A4: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 822B59A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B59AC: 41990008  bgt cr6, 0x822b59b4
	if ctx.cr[6].gt {
	pc = 0x822B59B4; continue 'dispatch;
	}
	// 822B59B0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822B59B4; continue 'dispatch;
            }
            0x822B59B4 => {
    //   block [0x822B59B4..0x822B59DC)
	// 822B59B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B59B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B59BC: 409A0020  bne cr6, 0x822b59dc
	if !ctx.cr[6].eq {
	pc = 0x822B59DC; continue 'dispatch;
	}
	// 822B59C0: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822B59C4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822B59C8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822B59CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B59D0: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 822B59D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B59D8: 4800001C  b 0x822b59f4
	pc = 0x822B59F4; continue 'dispatch;
            }
            0x822B59DC => {
    //   block [0x822B59DC..0x822B59F0)
	// 822B59DC: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 822B59E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B59E4: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 822B59E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B59EC: 48000008  b 0x822b59f4
	pc = 0x822B59F4; continue 'dispatch;
            }
            0x822B59F0 => {
    //   block [0x822B59F0..0x822B59F4)
	// 822B59F0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822B59F4; continue 'dispatch;
            }
            0x822B59F4 => {
    //   block [0x822B59F4..0x822B5A4C)
	// 822B59F4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822B59F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B59FC: 3B2A9490  addi r25, r10, -0x6b70
	ctx.r[25].s64 = ctx.r[10].s64 + -27504;
	// 822B5A00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5A04: C3F9FFF4  lfs f31, -0xc(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822B5A08: 419A0888  beq cr6, 0x822b6290
	if ctx.cr[6].eq {
	pc = 0x822B6290; continue 'dispatch;
	}
	// 822B5A0C: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 822B5A10: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 822B5A14: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 822B5A18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B5A1C: 419A00F4  beq cr6, 0x822b5b10
	if ctx.cr[6].eq {
	pc = 0x822B5B10; continue 'dispatch;
	}
	// 822B5A20: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B5A24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5A28: 419A0024  beq cr6, 0x822b5a4c
	if ctx.cr[6].eq {
	pc = 0x822B5A4C; continue 'dispatch;
	}
	// 822B5A2C: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 822B5A30: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B5A34: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B5A38: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B5A3C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B5A40: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B5A44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5A48: 480000CC  b 0x822b5b14
	pc = 0x822B5B14; continue 'dispatch;
            }
            0x822B5A4C => {
    //   block [0x822B5A4C..0x822B5A68)
	// 822B5A4C: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B5A50: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B5A54: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 822B5A58: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B5A5C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822B5A60: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B5A64: 40810054  ble 0x822b5ab8
	if !ctx.cr[0].gt {
	pc = 0x822B5AB8; continue 'dispatch;
	}
	pc = 0x822B5A68; continue 'dispatch;
            }
            0x822B5A68 => {
    //   block [0x822B5A68..0x822B5A88)
	// 822B5A68: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B5A6C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B5A70: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822B5A74: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B5A78: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 822B5A7C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B5A80: 41980008  blt cr6, 0x822b5a88
	if ctx.cr[6].lt {
	pc = 0x822B5A88; continue 'dispatch;
	}
	// 822B5A84: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x822B5A88; continue 'dispatch;
            }
            0x822B5A88 => {
    //   block [0x822B5A88..0x822B5AA4)
	// 822B5A88: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B5A8C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B5A90: 419A0014  beq cr6, 0x822b5aa4
	if ctx.cr[6].eq {
	pc = 0x822B5AA4; continue 'dispatch;
	}
	// 822B5A94: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B5A98: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B5A9C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B5AA0: 4800000C  b 0x822b5aac
	pc = 0x822B5AAC; continue 'dispatch;
            }
            0x822B5AA4 => {
    //   block [0x822B5AA4..0x822B5AAC)
	// 822B5AA4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B5AA8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B5AAC; continue 'dispatch;
            }
            0x822B5AAC => {
    //   block [0x822B5AAC..0x822B5AB8)
	// 822B5AAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B5AB0: 4199FFB8  bgt cr6, 0x822b5a68
	if ctx.cr[6].gt {
	pc = 0x822B5A68; continue 'dispatch;
	}
	// 822B5AB4: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x822B5AB8; continue 'dispatch;
            }
            0x822B5AB8 => {
    //   block [0x822B5AB8..0x822B5AD4)
	// 822B5AB8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B5ABC: 419A0040  beq cr6, 0x822b5afc
	if ctx.cr[6].eq {
	pc = 0x822B5AFC; continue 'dispatch;
	}
	// 822B5AC0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B5AC4: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 822B5AC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5ACC: 41990008  bgt cr6, 0x822b5ad4
	if ctx.cr[6].gt {
	pc = 0x822B5AD4; continue 'dispatch;
	}
	// 822B5AD0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822B5AD4; continue 'dispatch;
            }
            0x822B5AD4 => {
    //   block [0x822B5AD4..0x822B5AFC)
	// 822B5AD4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B5AD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5ADC: 409A0020  bne cr6, 0x822b5afc
	if !ctx.cr[6].eq {
	pc = 0x822B5AFC; continue 'dispatch;
	}
	// 822B5AE0: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822B5AE4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822B5AE8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822B5AEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B5AF0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B5AF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5AF8: 4800001C  b 0x822b5b14
	pc = 0x822B5B14; continue 'dispatch;
            }
            0x822B5AFC => {
    //   block [0x822B5AFC..0x822B5B10)
	// 822B5AFC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B5B00: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B5B04: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B5B08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5B0C: 48000008  b 0x822b5b14
	pc = 0x822B5B14; continue 'dispatch;
            }
            0x822B5B10 => {
    //   block [0x822B5B10..0x822B5B14)
	// 822B5B10: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822B5B14; continue 'dispatch;
            }
            0x822B5B14 => {
    //   block [0x822B5B14..0x822B5C04)
	// 822B5B14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B5B18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5B1C: 419A06D0  beq cr6, 0x822b61ec
	if ctx.cr[6].eq {
	pc = 0x822B61EC; continue 'dispatch;
	}
	// 822B5B20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822B5B24: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B5B28: 388B0E20  addi r4, r11, 0xe20
	ctx.r[4].s64 = ctx.r[11].s64 + 3616;
	// 822B5B2C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822B5B30: 4BF773A1  bl 0x8222ced0
	ctx.lr = 0x822B5B34;
	sub_8222CED0(ctx, base);
	// 822B5B34: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 822B5B38: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822B5B3C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822B5B40: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 822B5B44: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822B5B48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B5B4C: 4BFCE1E5  bl 0x82283d30
	ctx.lr = 0x822B5B50;
	sub_82283D30(ctx, base);
	// 822B5B50: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822B5B54: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822B5B58: 4BFBD501  bl 0x82273058
	ctx.lr = 0x822B5B5C;
	sub_82273058(ctx, base);
	// 822B5B5C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822B5B60: 4BF5F279  bl 0x82214dd8
	ctx.lr = 0x822B5B64;
	sub_82214DD8(ctx, base);
	// 822B5B64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822B5B68: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B5B6C: 388A0D6C  addi r4, r10, 0xd6c
	ctx.r[4].s64 = ctx.r[10].s64 + 3436;
	// 822B5B70: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 822B5B74: 4BF7735D  bl 0x8222ced0
	ctx.lr = 0x822B5B78;
	sub_8222CED0(ctx, base);
	// 822B5B78: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 822B5B7C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822B5B80: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822B5B84: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 822B5B88: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822B5B8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B5B90: 4BFCE1A1  bl 0x82283d30
	ctx.lr = 0x822B5B94;
	sub_82283D30(ctx, base);
	// 822B5B94: 3BBB002C  addi r29, r27, 0x2c
	ctx.r[29].s64 = ctx.r[27].s64 + 44;
	// 822B5B98: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822B5B9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B5BA0: 4BFBD4B9  bl 0x82273058
	ctx.lr = 0x822B5BA4;
	sub_82273058(ctx, base);
	// 822B5BA4: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 822B5BA8: 4BF5F231  bl 0x82214dd8
	ctx.lr = 0x822B5BAC;
	sub_82214DD8(ctx, base);
	// 822B5BAC: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 822B5BB0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B5BB4: 38892228  addi r4, r9, 0x2228
	ctx.r[4].s64 = ctx.r[9].s64 + 8744;
	// 822B5BB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B5BBC: 4BF77315  bl 0x8222ced0
	ctx.lr = 0x822B5BC0;
	sub_8222CED0(ctx, base);
	// 822B5BC0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B5BC4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 822B5BC8: 810B0028  lwz r8, 0x28(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 822B5BCC: 550737FE  rlwinm r7, r8, 6, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x03FFFFFFu64;
	// 822B5BD0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B5BD4: 419A00F4  beq cr6, 0x822b5cc8
	if ctx.cr[6].eq {
	pc = 0x822B5CC8; continue 'dispatch;
	}
	// 822B5BD8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B5BDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B5BE0: 419A0024  beq cr6, 0x822b5c04
	if ctx.cr[6].eq {
	pc = 0x822B5C04; continue 'dispatch;
	}
	// 822B5BE4: 894A003A  lbz r10, 0x3a(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(58 as u32) ) } as u64;
	// 822B5BE8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B5BEC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B5BF0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B5BF4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B5BF8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B5BFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5C00: 480000CC  b 0x822b5ccc
	pc = 0x822B5CCC; continue 'dispatch;
            }
            0x822B5C04 => {
    //   block [0x822B5C04..0x822B5C20)
	// 822B5C04: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B5C08: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B5C0C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 822B5C10: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B5C14: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822B5C18: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B5C1C: 40810054  ble 0x822b5c70
	if !ctx.cr[0].gt {
	pc = 0x822B5C70; continue 'dispatch;
	}
	pc = 0x822B5C20; continue 'dispatch;
            }
            0x822B5C20 => {
    //   block [0x822B5C20..0x822B5C40)
	// 822B5C20: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B5C24: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B5C28: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822B5C2C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B5C30: 2F07003A  cmpwi cr6, r7, 0x3a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 58, &mut ctx.xer);
	// 822B5C34: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B5C38: 41980008  blt cr6, 0x822b5c40
	if ctx.cr[6].lt {
	pc = 0x822B5C40; continue 'dispatch;
	}
	// 822B5C3C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x822B5C40; continue 'dispatch;
            }
            0x822B5C40 => {
    //   block [0x822B5C40..0x822B5C5C)
	// 822B5C40: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B5C44: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B5C48: 419A0014  beq cr6, 0x822b5c5c
	if ctx.cr[6].eq {
	pc = 0x822B5C5C; continue 'dispatch;
	}
	// 822B5C4C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B5C50: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B5C54: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B5C58: 4800000C  b 0x822b5c64
	pc = 0x822B5C64; continue 'dispatch;
            }
            0x822B5C5C => {
    //   block [0x822B5C5C..0x822B5C64)
	// 822B5C5C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B5C60: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B5C64; continue 'dispatch;
            }
            0x822B5C64 => {
    //   block [0x822B5C64..0x822B5C70)
	// 822B5C64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B5C68: 4199FFB8  bgt cr6, 0x822b5c20
	if ctx.cr[6].gt {
	pc = 0x822B5C20; continue 'dispatch;
	}
	// 822B5C6C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x822B5C70; continue 'dispatch;
            }
            0x822B5C70 => {
    //   block [0x822B5C70..0x822B5C8C)
	// 822B5C70: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B5C74: 419A0040  beq cr6, 0x822b5cb4
	if ctx.cr[6].eq {
	pc = 0x822B5CB4; continue 'dispatch;
	}
	// 822B5C78: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B5C7C: 2F0B003A  cmpwi cr6, r11, 0x3a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 58, &mut ctx.xer);
	// 822B5C80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5C84: 41990008  bgt cr6, 0x822b5c8c
	if ctx.cr[6].gt {
	pc = 0x822B5C8C; continue 'dispatch;
	}
	// 822B5C88: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822B5C8C; continue 'dispatch;
            }
            0x822B5C8C => {
    //   block [0x822B5C8C..0x822B5CB4)
	// 822B5C8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B5C90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5C94: 409A0020  bne cr6, 0x822b5cb4
	if !ctx.cr[6].eq {
	pc = 0x822B5CB4; continue 'dispatch;
	}
	// 822B5C98: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822B5C9C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822B5CA0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822B5CA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B5CA8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B5CAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5CB0: 4800001C  b 0x822b5ccc
	pc = 0x822B5CCC; continue 'dispatch;
            }
            0x822B5CB4 => {
    //   block [0x822B5CB4..0x822B5CC8)
	// 822B5CB4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B5CB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B5CBC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B5CC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B5CC4: 48000008  b 0x822b5ccc
	pc = 0x822B5CCC; continue 'dispatch;
            }
            0x822B5CC8 => {
    //   block [0x822B5CC8..0x822B5CCC)
	// 822B5CC8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822B5CCC; continue 'dispatch;
            }
            0x822B5CCC => {
    //   block [0x822B5CCC..0x822B5CF0)
	// 822B5CCC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B5CD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5CD4: 419A001C  beq cr6, 0x822b5cf0
	if ctx.cr[6].eq {
	pc = 0x822B5CF0; continue 'dispatch;
	}
	// 822B5CD8: 896A0071  lbz r11, 0x71(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(113 as u32) ) } as u64;
	// 822B5CDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B5CE0: 419A0010  beq cr6, 0x822b5cf0
	if ctx.cr[6].eq {
	pc = 0x822B5CF0; continue 'dispatch;
	}
	// 822B5CE4: 388A0034  addi r4, r10, 0x34
	ctx.r[4].s64 = ctx.r[10].s64 + 52;
	// 822B5CE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B5CEC: 4BFAF4B5  bl 0x822651a0
	ctx.lr = 0x822B5CF0;
	sub_822651A0(ctx, base);
	pc = 0x822B5CF0; continue 'dispatch;
            }
            0x822B5CF0 => {
    //   block [0x822B5CF0..0x822B5E9C)
	// 822B5CF0: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 822B5CF4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822B5CF8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822B5CFC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822B5D00: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822B5D04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B5D08: 4BFCE029  bl 0x82283d30
	ctx.lr = 0x822B5D0C;
	sub_82283D30(ctx, base);
	// 822B5D0C: 3BDB0034  addi r30, r27, 0x34
	ctx.r[30].s64 = ctx.r[27].s64 + 52;
	// 822B5D10: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822B5D14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B5D18: 4BFBD341  bl 0x82273058
	ctx.lr = 0x822B5D1C;
	sub_82273058(ctx, base);
	// 822B5D1C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B5D20: 3FE0820A  lis r31, -0x7df6
	ctx.r[31].s64 = -2113273856;
	// 822B5D24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B5D28: 419A0174  beq cr6, 0x822b5e9c
	if ctx.cr[6].eq {
	pc = 0x822B5E9C; continue 'dispatch;
	}
	// 822B5D2C: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822B5D30: 4801D919  bl 0x822d3648
	ctx.lr = 0x822B5D34;
	sub_822D3648(ctx, base);
	// 822B5D34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B5D38: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 822B5D3C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822B5D40: 4BFE2B81  bl 0x822988c0
	ctx.lr = 0x822B5D44;
	sub_822988C0(ctx, base);
	// 822B5D44: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 822B5D48: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822B5E9C; continue 'dispatch;
            }
            0x822B5E9C => {
    //   block [0x822B5E9C..0x822B61EC)
	// 822B5E9C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B5EA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B5EA4: 419A0174  beq cr6, 0x822b6018
	if ctx.cr[6].eq {
	pc = 0x822B6018; continue 'dispatch;
	}
	// 822B5EA8: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822B5EAC: 4801D79D  bl 0x822d3648
	ctx.lr = 0x822B5EB0;
	sub_822D3648(ctx, base);
	// 822B5EB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B5EB4: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 822B5EB8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822B5EBC: 4BFE2A05  bl 0x822988c0
	ctx.lr = 0x822B5EC0;
	sub_822988C0(ctx, base);
	// 822B5EC0: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 822B5EC4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822B61EC; continue 'dispatch;
            }
            0x822B61EC => {
    //   block [0x822B61EC..0x822B6290)
	// 822B61EC: 807B0018  lwz r3, 0x18(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 822B61F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B61F4: 419A0040  beq cr6, 0x822b6234
	if ctx.cr[6].eq {
	pc = 0x822B6234; continue 'dispatch;
	}
	// 822B61F8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 822B61FC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 822B6200: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B6204: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 822B6208: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B620C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822B6210: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B6214: 4082FFE8  bne 0x822b61fc
	if !ctx.cr[0].eq {
	pc = 0x822B61FC; continue 'dispatch;
	}
	// 822B6218: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B621C: 409A0014  bne cr6, 0x822b6230
	if !ctx.cr[6].eq {
	pc = 0x822B6230; continue 'dispatch;
	}
	// 822B6220: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B6224: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6228: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B622C: 4E800421  bctrl
	ctx.lr = 0x822B6230;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B6230: 939B0018  stw r28, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 822B6234: 939B0018  stw r28, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 822B6238: 807B0020  lwz r3, 0x20(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 822B623C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B6240: 419A0040  beq cr6, 0x822b6280
	if ctx.cr[6].eq {
	pc = 0x822B6280; continue 'dispatch;
	}
	// 822B6244: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 822B6248: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 822B624C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B6250: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 822B6254: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B6258: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822B625C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B6260: 4082FFE8  bne 0x822b6248
	if !ctx.cr[0].eq {
	pc = 0x822B6248; continue 'dispatch;
	}
	// 822B6264: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B6268: 409A0014  bne cr6, 0x822b627c
	if !ctx.cr[6].eq {
	pc = 0x822B627C; continue 'dispatch;
	}
	// 822B626C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B6270: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6274: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B6278: 4E800421  bctrl
	ctx.lr = 0x822B627C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B627C: 939B0020  stw r28, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	// 822B6280: 939B0020  stw r28, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	// 822B6284: 387B003C  addi r3, r27, 0x3c
	ctx.r[3].s64 = ctx.r[27].s64 + 60;
	// 822B6288: 4BF01891  bl 0x821b7b18
	ctx.lr = 0x822B628C;
	sub_821B7B18(ctx, base);
	// 822B628C: 939B003C  stw r28, 0x3c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(60 as u32), ctx.r[28].u32 ) };
            }
            0x822B6290 => {
    //   block [0x822B6290..0x822B62DC)
	// 822B6290: D3FB0054  stfs f31, 0x54(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822B6294: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822B6298: 807B002C  lwz r3, 0x2c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 822B629C: D3FB0060  stfs f31, 0x60(r27)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822B62A0: D3FB005C  stfs f31, 0x5c(r27)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 822B62A4: D3FB0058  stfs f31, 0x58(r27)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822B62A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B62AC: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822B62B0: 917B006C  stw r11, 0x6c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 822B62B4: 419A0010  beq cr6, 0x822b62c4
	if ctx.cr[6].eq {
	pc = 0x822B62C4; continue 'dispatch;
	}
	// 822B62B8: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822B62BC: 4801D38D  bl 0x822d3648
	ctx.lr = 0x822B62C0;
	sub_822D3648(ctx, base);
	// 822B62C0: D03B0064  stfs f1, 0x64(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822B62C4: 807B0034  lwz r3, 0x34(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 822B62C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B62CC: 419A0010  beq cr6, 0x822b62dc
	if ctx.cr[6].eq {
	pc = 0x822B62DC; continue 'dispatch;
	}
	// 822B62D0: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822B62D4: 4801D375  bl 0x822d3648
	ctx.lr = 0x822B62D8;
	sub_822D3648(ctx, base);
	// 822B62D8: D03B0068  stfs f1, 0x68(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(104 as u32), tmp.u32 ) };
	pc = 0x822B62DC; continue 'dispatch;
            }
            0x822B62DC => {
    //   block [0x822B62DC..0x822B62EC)
	// 822B62DC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822B62E0: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 822B62E4: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 822B62E8: 489F3160  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B62F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B62F0 size=840
    let mut pc: u32 = 0x822B62F0;
    'dispatch: loop {
        match pc {
            0x822B62F0 => {
    //   block [0x822B62F0..0x822B6334)
	// 822B62F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B62F4: 489F310D  bl 0x82ca9400
	ctx.lr = 0x822B62F8;
	sub_82CA93D0(ctx, base);
	// 822B62F8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 822B62FC: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B6300: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 822B6304: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822B6308: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822B630C: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822B6310: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B6314: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B6318: 892A0034  lbz r9, 0x34(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 822B631C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B6320: 419A0014  beq cr6, 0x822b6334
	if ctx.cr[6].eq {
	pc = 0x822B6334; continue 'dispatch;
	}
	// 822B6324: 894A0035  lbz r10, 0x35(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(53 as u32) ) } as u64;
	// 822B6328: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B632C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B6330: 409A0008  bne cr6, 0x822b6338
	if !ctx.cr[6].eq {
	pc = 0x822B6338; continue 'dispatch;
	}
	pc = 0x822B6334; continue 'dispatch;
            }
            0x822B6334 => {
    //   block [0x822B6334..0x822B6338)
	// 822B6334: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x822B6338; continue 'dispatch;
            }
            0x822B6338 => {
    //   block [0x822B6338..0x822B6350)
	// 822B6338: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822B633C: 806B009C  lwz r3, 0x9c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 822B6340: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822B6344: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B6348: 409A0008  bne cr6, 0x822b6350
	if !ctx.cr[6].eq {
	pc = 0x822B6350; continue 'dispatch;
	}
	// 822B634C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	pc = 0x822B6350; continue 'dispatch;
            }
            0x822B6350 => {
    //   block [0x822B6350..0x822B6388)
	// 822B6350: 4BFADEE1  bl 0x82264230
	ctx.lr = 0x822B6354;
	sub_82264230(ctx, base);
	// 822B6354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B6358: 419A02D4  beq cr6, 0x822b662c
	if ctx.cr[6].eq {
	pc = 0x822B662C; continue 'dispatch;
	}
	// 822B635C: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B6360: 4BF11981  bl 0x821c7ce0
	ctx.lr = 0x822B6364;
	sub_821C7CE0(ctx, base);
	// 822B6364: 4BFE8B15  bl 0x8229ee78
	ctx.lr = 0x822B6368;
	sub_8229EE78(ctx, base);
	// 822B6368: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822B636C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B6370: 419A0018  beq cr6, 0x822b6388
	if ctx.cr[6].eq {
	pc = 0x822B6388; continue 'dispatch;
	}
	// 822B6374: 89430090  lbz r10, 0x90(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 822B6378: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822B637C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B6380: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B6384: 409A0008  bne cr6, 0x822b638c
	if !ctx.cr[6].eq {
	pc = 0x822B638C; continue 'dispatch;
	}
	pc = 0x822B6388; continue 'dispatch;
            }
            0x822B6388 => {
    //   block [0x822B6388..0x822B638C)
	// 822B6388: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x822B638C; continue 'dispatch;
            }
            0x822B638C => {
    //   block [0x822B638C..0x822B63D0)
	// 822B638C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822B6390: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B6394: 419A0298  beq cr6, 0x822b662c
	if ctx.cr[6].eq {
	pc = 0x822B662C; continue 'dispatch;
	}
	// 822B6398: 81430034  lwz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 822B639C: 55491FFE  rlwinm r9, r10, 3, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 822B63A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B63A4: 419A00E8  beq cr6, 0x822b648c
	if ctx.cr[6].eq {
	pc = 0x822B648C; continue 'dispatch;
	}
	// 822B63A8: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B63AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B63B0: 419A0020  beq cr6, 0x822b63d0
	if ctx.cr[6].eq {
	pc = 0x822B63D0; continue 'dispatch;
	}
	// 822B63B4: 894B009D  lbz r10, 0x9d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(157 as u32) ) } as u64;
	// 822B63B8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B63BC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B63C0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B63C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B63C8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B63CC: 480000C4  b 0x822b6490
	pc = 0x822B6490; continue 'dispatch;
            }
            0x822B63D0 => {
    //   block [0x822B63D0..0x822B63EC)
	// 822B63D0: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B63D4: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B63D8: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 822B63DC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B63E0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822B63E4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B63E8: 40810054  ble 0x822b643c
	if !ctx.cr[0].gt {
	pc = 0x822B643C; continue 'dispatch;
	}
	pc = 0x822B63EC; continue 'dispatch;
            }
            0x822B63EC => {
    //   block [0x822B63EC..0x822B640C)
	// 822B63EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B63F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B63F4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B63F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B63FC: 2F07009D  cmpwi cr6, r7, 0x9d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 157, &mut ctx.xer);
	// 822B6400: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B6404: 41980008  blt cr6, 0x822b640c
	if ctx.cr[6].lt {
	pc = 0x822B640C; continue 'dispatch;
	}
	// 822B6408: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x822B640C; continue 'dispatch;
            }
            0x822B640C => {
    //   block [0x822B640C..0x822B6428)
	// 822B640C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B6410: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B6414: 419A0014  beq cr6, 0x822b6428
	if ctx.cr[6].eq {
	pc = 0x822B6428; continue 'dispatch;
	}
	// 822B6418: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B641C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B6420: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B6424: 4800000C  b 0x822b6430
	pc = 0x822B6430; continue 'dispatch;
            }
            0x822B6428 => {
    //   block [0x822B6428..0x822B6430)
	// 822B6428: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B642C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B6430; continue 'dispatch;
            }
            0x822B6430 => {
    //   block [0x822B6430..0x822B643C)
	// 822B6430: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B6434: 4199FFB8  bgt cr6, 0x822b63ec
	if ctx.cr[6].gt {
	pc = 0x822B63EC; continue 'dispatch;
	}
	// 822B6438: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x822B643C; continue 'dispatch;
            }
            0x822B643C => {
    //   block [0x822B643C..0x822B6458)
	// 822B643C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B6440: 419A003C  beq cr6, 0x822b647c
	if ctx.cr[6].eq {
	pc = 0x822B647C; continue 'dispatch;
	}
	// 822B6444: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B6448: 2F0B009D  cmpwi cr6, r11, 0x9d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 157, &mut ctx.xer);
	// 822B644C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B6450: 41990008  bgt cr6, 0x822b6458
	if ctx.cr[6].gt {
	pc = 0x822B6458; continue 'dispatch;
	}
	// 822B6454: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x822B6458; continue 'dispatch;
            }
            0x822B6458 => {
    //   block [0x822B6458..0x822B647C)
	// 822B6458: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B645C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6460: 409A001C  bne cr6, 0x822b647c
	if !ctx.cr[6].eq {
	pc = 0x822B647C; continue 'dispatch;
	}
	// 822B6464: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822B6468: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B646C: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 822B6470: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 822B6474: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6478: 48000018  b 0x822b6490
	pc = 0x822B6490; continue 'dispatch;
            }
            0x822B647C => {
    //   block [0x822B647C..0x822B648C)
	// 822B647C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B6480: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B6484: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6488: 48000008  b 0x822b6490
	pc = 0x822B6490; continue 'dispatch;
            }
            0x822B648C => {
    //   block [0x822B648C..0x822B6490)
	// 822B648C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x822B6490; continue 'dispatch;
            }
            0x822B6490 => {
    //   block [0x822B6490..0x822B64B4)
	// 822B6490: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822B6494: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B6498: 419A0194  beq cr6, 0x822b662c
	if ctx.cr[6].eq {
	pc = 0x822B662C; continue 'dispatch;
	}
	// 822B649C: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B64A0: C1AB0024  lfs f13, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B64A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B64A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822B64AC: 40980008  bge cr6, 0x822b64b4
	if !ctx.cr[6].lt {
	pc = 0x822B64B4; continue 'dispatch;
	}
	// 822B64B0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x822B64B4; continue 'dispatch;
            }
            0x822B64B4 => {
    //   block [0x822B64B4..0x822B64F8)
	// 822B64B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B64B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B64BC: 409A003C  bne cr6, 0x822b64f8
	if !ctx.cr[6].eq {
	pc = 0x822B64F8; continue 'dispatch;
	}
	// 822B64C0: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 822B64C4: 894BEB8F  lbz r10, -0x1471(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5233 as u32) ) } as u64;
	// 822B64C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B64CC: 409A002C  bne cr6, 0x822b64f8
	if !ctx.cr[6].eq {
	pc = 0x822B64F8; continue 'dispatch;
	}
	// 822B64D0: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B64D4: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 822B64D8: 419A0154  beq cr6, 0x822b662c
	if ctx.cr[6].eq {
	pc = 0x822B662C; continue 'dispatch;
	}
	// 822B64DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822B64E0: 4BEBF439  bl 0x82175918
	ctx.lr = 0x822B64E4;
	sub_82175918(ctx, base);
	// 822B64E4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822B64E8: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822B64EC: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 822B64F0: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822B64F4: 489F2F5C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B64F8 => {
    //   block [0x822B64F8..0x822B662C)
	// 822B64F8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B64FC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 822B6500: 409A012C  bne cr6, 0x822b662c
	if !ctx.cr[6].eq {
	pc = 0x822B662C; continue 'dispatch;
	}
	// 822B6504: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 822B6508: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B650C: 388BA790  addi r4, r11, -0x5870
	ctx.r[4].s64 = ctx.r[11].s64 + -22640;
	// 822B6510: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B6514: 4BF769BD  bl 0x8222ced0
	ctx.lr = 0x822B6518;
	sub_8222CED0(ctx, base);
	// 822B6518: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822B651C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B6520: 4BF39D21  bl 0x821f0240
	ctx.lr = 0x822B6524;
	sub_821F0240(ctx, base);
	// 822B6524: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822B6528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B652C: 388A04E8  addi r4, r10, 0x4e8
	ctx.r[4].s64 = ctx.r[10].s64 + 1256;
	// 822B6530: 4BF24491  bl 0x821da9c0
	ctx.lr = 0x822B6534;
	sub_821DA9C0(ctx, base);
	// 822B6534: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B6538: 4BF5E8A1  bl 0x82214dd8
	ctx.lr = 0x822B653C;
	sub_82214DD8(ctx, base);
	// 822B653C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 822B6540: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 822B6544: 38E99484  addi r7, r9, -0x6b7c
	ctx.r[7].s64 = ctx.r[9].s64 + -27516;
	// 822B6548: 38C85FE8  addi r6, r8, 0x5fe8
	ctx.r[6].s64 = ctx.r[8].s64 + 24552;
	// 822B654C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B6550: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B6554: C3E99484  lfs f31, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822B6558: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822B655C: C007000C  lfs f0, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B6560: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822B6564: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822B6568: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822B656C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822B6570: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822B6574: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822B6578: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822B657C: 83E85FE8  lwz r31, 0x5fe8(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24552 as u32) ) } as u64;
	// 822B6580: 83C60004  lwz r30, 4(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6584: 4BF385B5  bl 0x821eeb38
	ctx.lr = 0x822B6588;
	sub_821EEB38(ctx, base);
	// 822B6588: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B658C: 4894D265  bl 0x82c037f0
	ctx.lr = 0x822B6590;
	sub_82C037F0(ctx, base);
	// 822B6590: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822B6594: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B6598: 4BF5E841  bl 0x82214dd8
	ctx.lr = 0x822B659C;
	sub_82214DD8(ctx, base);
	// 822B659C: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822B65A0: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 822B65A4: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 822B65A8: E9410070  ld r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 822B65AC: D3E10098  stfs f31, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 822B65B0: E9010078  ld r8, 0x78(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 822B65B4: 3924A7B4  addi r9, r4, -0x584c
	ctx.r[9].s64 = ctx.r[4].s64 + -22604;
	// 822B65B8: 807B6AB8  lwz r3, 0x6ab8(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822B65BC: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 822B65C0: F8A100A4  std r5, 0xa4(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u64 ) };
	// 822B65C4: F96100AC  std r11, 0xac(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[11].u64 ) };
	// 822B65C8: F94100B4  std r10, 0xb4(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[10].u64 ) };
	// 822B65CC: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 822B65D0: 91210080  stw r9, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 822B65D4: 93A10088  stw r29, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[29].u32 ) };
	// 822B65D8: 93A1008C  stw r29, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	// 822B65DC: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 822B65E0: 93C10094  stw r30, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 822B65E4: 934100A0  stw r26, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[26].u32 ) };
	// 822B65E8: F90100BC  std r8, 0xbc(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[8].u64 ) };
	// 822B65EC: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B65F0: 80C70014  lwz r6, 0x14(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 822B65F4: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 822B65F8: 4E800421  bctrl
	ctx.lr = 0x822B65FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B65FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822B6600: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822B6604: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822B6608: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B660C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B6610: 4BF27CD9  bl 0x821de2e8
	ctx.lr = 0x822B6614;
	sub_821DE2E8(ctx, base);
	// 822B6614: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822B6618: 907C0004  stw r3, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 822B661C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B6620: 392A6A70  addi r9, r10, 0x6a70
	ctx.r[9].s64 = ctx.r[10].s64 + 27248;
	// 822B6624: 91210080  stw r9, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 822B6628: 4BF5E7B1  bl 0x82214dd8
	ctx.lr = 0x822B662C;
	sub_82214DD8(ctx, base);
            }
            0x822B662C => {
    //   block [0x822B662C..0x822B6638)
	// 822B662C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 822B6630: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822B6634: 489F2E1C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B6638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B6638 size=220
    let mut pc: u32 = 0x822B6638;
    'dispatch: loop {
        match pc {
            0x822B6638 => {
    //   block [0x822B6638..0x822B666C)
	// 822B6638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B663C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B6640: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822B6644: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B6648: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822B664C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B6650: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B6654: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822B6658: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822B665C: 897F0040  lbz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 822B6660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6664: 409A0008  bne cr6, 0x822b666c
	if !ctx.cr[6].eq {
	pc = 0x822B666C; continue 'dispatch;
	}
	// 822B6668: 4BEE1C21  bl 0x82198288
	ctx.lr = 0x822B666C;
	sub_82198288(ctx, base);
	pc = 0x822B666C; continue 'dispatch;
            }
            0x822B666C => {
    //   block [0x822B666C..0x822B6684)
	// 822B666C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B6670: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 822B6674: 40980034  bge cr6, 0x822b66a8
	if !ctx.cr[6].lt {
	pc = 0x822B66A8; continue 'dispatch;
	}
	// 822B6678: 394B0011  addi r10, r11, 0x11
	ctx.r[10].s64 = ctx.r[11].s64 + 17;
	// 822B667C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822B6680: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	pc = 0x822B6684; continue 'dispatch;
            }
            0x822B6684 => {
    //   block [0x822B6684..0x822B66A4)
	// 822B6684: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B6688: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822B668C: 41990018  bgt cr6, 0x822b66a4
	if ctx.cr[6].gt {
	pc = 0x822B66A4; continue 'dispatch;
	}
	// 822B6690: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822B6694: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822B6698: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 822B669C: 4198FFE8  blt cr6, 0x822b6684
	if ctx.cr[6].lt {
	pc = 0x822B6684; continue 'dispatch;
	}
	// 822B66A0: 48000008  b 0x822b66a8
	pc = 0x822B66A8; continue 'dispatch;
            }
            0x822B66A4 => {
    //   block [0x822B66A4..0x822B66A8)
	// 822B66A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x822B66A8; continue 'dispatch;
            }
            0x822B66A8 => {
    //   block [0x822B66A8..0x822B6714)
	// 822B66A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B66AC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822B66B0: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 822B66B4: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 822B66B8: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 822B66BC: 38CB0011  addi r6, r11, 0x11
	ctx.r[6].s64 = ctx.r[11].s64 + 17;
	// 822B66C0: C00AD714  lfs f0, -0x28ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10476 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B66C4: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 822B66C8: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B66CC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 822B66D0: 5505103A  slwi r5, r8, 2
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 822B66D4: 54C4103A  slwi r4, r6, 2
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 822B66D8: 7D65FC2E  lfsx f11, r5, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822B66DC: ED5F5828  fsubs f10, f31, f11
	ctx.f[10].f64 = (((ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 822B66E0: FD206018  frsp f9, f12
	ctx.f[9].f64 = (ctx.f[12].f64 as f32) as f64;
	// 822B66E4: 7D04FC2E  lfsx f8, r4, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822B66E8: ECE85828  fsubs f7, f8, f11
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 822B66EC: ECC90032  fmuls f6, f9, f0
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 822B66F0: ECAA3824  fdivs f5, f10, f7
	ctx.f[5].f64 = ((ctx.f[10].f64 / ctx.f[7].f64) as f32) as f64;
	// 822B66F4: EC25303A  fmadds f1, f5, f0, f6
	ctx.f[1].f64 = (((ctx.f[5].f64 * ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64);
	// 822B66F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822B66FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B6700: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B6704: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822B6708: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822B670C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B6710: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B6718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822B6718 size=516
    let mut pc: u32 = 0x822B6718;
    'dispatch: loop {
        match pc {
            0x822B6718 => {
    //   block [0x822B6718..0x822B6740)
	// 822B6718: 81640034  lwz r11, 0x34(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 822B671C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B6720: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B6724: 4198001C  blt cr6, 0x822b6740
	if ctx.cr[6].lt {
	pc = 0x822B6740; continue 'dispatch;
	}
	// 822B6728: 8144003C  lwz r10, 0x3c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 822B672C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822B6730: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 822B6734: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B6738: 7D47482E  lwzx r10, r7, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822B673C: 4800000C  b 0x822b6748
	pc = 0x822B6748; continue 'dispatch;
            }
            0x822B6740 => {
    //   block [0x822B6740..0x822B6748)
	// 822B6740: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822B6744: 814B5760  lwz r10, 0x5760(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22368 as u32) ) } as u64;
	pc = 0x822B6748; continue 'dispatch;
            }
            0x822B6748 => {
    //   block [0x822B6748..0x822B691C)
	// 822B6748: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B674C: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 822B6750: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6754: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 822B6758: 396B0070  addi r11, r11, 0x70
	ctx.r[11].s64 = ctx.r[11].s64 + 112;
	// 822B675C: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822B6760: 38A1FFF0  addi r5, r1, -0x10
	ctx.r[5].s64 = ctx.r[1].s64 + -16;
	// 822B6764: 3C80820A  lis r4, -0x7df6
	ctx.r[4].s64 = -2113273856;
	// 822B6768: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B6920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B6920 size=972
    let mut pc: u32 = 0x822B6920;
    'dispatch: loop {
        match pc {
            0x822B6920 => {
    //   block [0x822B6920..0x822B6948)
	// 822B6920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B6924: 489F2AD9  bl 0x82ca93fc
	ctx.lr = 0x822B6928;
	sub_82CA93D0(ctx, base);
	// 822B6928: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B692C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822B6930: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822B6934: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822B6938: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 822B693C: 7FF9FB78  mr r25, r31
	ctx.r[25].u64 = ctx.r[31].u64;
	// 822B6940: 409A0008  bne cr6, 0x822b6948
	if !ctx.cr[6].eq {
	pc = 0x822B6948; continue 'dispatch;
	}
	// 822B6944: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	pc = 0x822B6948; continue 'dispatch;
            }
            0x822B6948 => {
    //   block [0x822B6948..0x822B69A0)
	// 822B6948: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822B694C: 480003A5  bl 0x822b6cf0
	ctx.lr = 0x822B6950;
	sub_822B6CF0(ctx, base);
	// 822B6950: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B6954: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6958: 419A0380  beq cr6, 0x822b6cd8
	if ctx.cr[6].eq {
	pc = 0x822B6CD8; continue 'dispatch;
	}
	// 822B695C: 817C0034  lwz r11, 0x34(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 822B6960: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 822B6964: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 822B6968: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 822B696C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B6970: 419A00F4  beq cr6, 0x822b6a64
	if ctx.cr[6].eq {
	pc = 0x822B6A64; continue 'dispatch;
	}
	// 822B6974: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B6978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B697C: 419A0024  beq cr6, 0x822b69a0
	if ctx.cr[6].eq {
	pc = 0x822B69A0; continue 'dispatch;
	}
	// 822B6980: 894B009B  lbz r10, 0x9b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(155 as u32) ) } as u64;
	// 822B6984: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B6988: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822B698C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B6990: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6994: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 822B6998: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B699C: 480000CC  b 0x822b6a68
	pc = 0x822B6A68; continue 'dispatch;
            }
            0x822B69A0 => {
    //   block [0x822B69A0..0x822B69BC)
	// 822B69A0: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B69A4: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B69A8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822B69AC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B69B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B69B4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B69B8: 40810054  ble 0x822b6a0c
	if !ctx.cr[0].gt {
	pc = 0x822B6A0C; continue 'dispatch;
	}
	pc = 0x822B69BC; continue 'dispatch;
            }
            0x822B69BC => {
    //   block [0x822B69BC..0x822B69DC)
	// 822B69BC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B69C0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B69C4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B69C8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B69CC: 2F07009B  cmpwi cr6, r7, 0x9b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 155, &mut ctx.xer);
	// 822B69D0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B69D4: 41980008  blt cr6, 0x822b69dc
	if ctx.cr[6].lt {
	pc = 0x822B69DC; continue 'dispatch;
	}
	// 822B69D8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x822B69DC; continue 'dispatch;
            }
            0x822B69DC => {
    //   block [0x822B69DC..0x822B69F8)
	// 822B69DC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B69E0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B69E4: 419A0014  beq cr6, 0x822b69f8
	if ctx.cr[6].eq {
	pc = 0x822B69F8; continue 'dispatch;
	}
	// 822B69E8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B69EC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B69F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B69F4: 4800000C  b 0x822b6a00
	pc = 0x822B6A00; continue 'dispatch;
            }
            0x822B69F8 => {
    //   block [0x822B69F8..0x822B6A00)
	// 822B69F8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B69FC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B6A00; continue 'dispatch;
            }
            0x822B6A00 => {
    //   block [0x822B6A00..0x822B6A0C)
	// 822B6A00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B6A04: 4199FFB8  bgt cr6, 0x822b69bc
	if ctx.cr[6].gt {
	pc = 0x822B69BC; continue 'dispatch;
	}
	// 822B6A08: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B6A0C; continue 'dispatch;
            }
            0x822B6A0C => {
    //   block [0x822B6A0C..0x822B6A28)
	// 822B6A0C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B6A10: 419A0040  beq cr6, 0x822b6a50
	if ctx.cr[6].eq {
	pc = 0x822B6A50; continue 'dispatch;
	}
	// 822B6A14: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B6A18: 2F0B009B  cmpwi cr6, r11, 0x9b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 155, &mut ctx.xer);
	// 822B6A1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B6A20: 41990008  bgt cr6, 0x822b6a28
	if ctx.cr[6].gt {
	pc = 0x822B6A28; continue 'dispatch;
	}
	// 822B6A24: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B6A28; continue 'dispatch;
            }
            0x822B6A28 => {
    //   block [0x822B6A28..0x822B6A50)
	// 822B6A28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B6A2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6A30: 409A0020  bne cr6, 0x822b6a50
	if !ctx.cr[6].eq {
	pc = 0x822B6A50; continue 'dispatch;
	}
	// 822B6A34: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B6A38: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822B6A3C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822B6A40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6A44: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 822B6A48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B6A4C: 4800001C  b 0x822b6a68
	pc = 0x822B6A68; continue 'dispatch;
            }
            0x822B6A50 => {
    //   block [0x822B6A50..0x822B6A64)
	// 822B6A50: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B6A54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6A58: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 822B6A5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B6A60: 48000008  b 0x822b6a68
	pc = 0x822B6A68; continue 'dispatch;
            }
            0x822B6A64 => {
    //   block [0x822B6A64..0x822B6A68)
	// 822B6A64: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B6A68; continue 'dispatch;
            }
            0x822B6A68 => {
    //   block [0x822B6A68..0x822B6AB0)
	// 822B6A68: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B6A6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6A70: 419A0268  beq cr6, 0x822b6cd8
	if ctx.cr[6].eq {
	pc = 0x822B6CD8; continue 'dispatch;
	}
	// 822B6A74: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 822B6A78: 556A8FFE  rlwinm r10, r11, 0x11, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	// 822B6A7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B6A80: 419A00F0  beq cr6, 0x822b6b70
	if ctx.cr[6].eq {
	pc = 0x822B6B70; continue 'dispatch;
	}
	// 822B6A84: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B6A88: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B6A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6A90: 419A0020  beq cr6, 0x822b6ab0
	if ctx.cr[6].eq {
	pc = 0x822B6AB0; continue 'dispatch;
	}
	// 822B6A94: 896B002F  lbz r11, 0x2f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(47 as u32) ) } as u64;
	// 822B6A98: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 822B6A9C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822B6AA0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6AA4: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 822B6AA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B6AAC: 480000C8  b 0x822b6b74
	pc = 0x822B6B74; continue 'dispatch;
            }
            0x822B6AB0 => {
    //   block [0x822B6AB0..0x822B6AC8)
	// 822B6AB0: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B6AB4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822B6AB8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B6ABC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B6AC0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B6AC4: 40810054  ble 0x822b6b18
	if !ctx.cr[0].gt {
	pc = 0x822B6B18; continue 'dispatch;
	}
	pc = 0x822B6AC8; continue 'dispatch;
            }
            0x822B6AC8 => {
    //   block [0x822B6AC8..0x822B6AE8)
	// 822B6AC8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B6ACC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B6AD0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B6AD4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B6AD8: 2F07002F  cmpwi cr6, r7, 0x2f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 47, &mut ctx.xer);
	// 822B6ADC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B6AE0: 41980008  blt cr6, 0x822b6ae8
	if ctx.cr[6].lt {
	pc = 0x822B6AE8; continue 'dispatch;
	}
	// 822B6AE4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x822B6AE8; continue 'dispatch;
            }
            0x822B6AE8 => {
    //   block [0x822B6AE8..0x822B6B04)
	// 822B6AE8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B6AEC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B6AF0: 419A0014  beq cr6, 0x822b6b04
	if ctx.cr[6].eq {
	pc = 0x822B6B04; continue 'dispatch;
	}
	// 822B6AF4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B6AF8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B6AFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B6B00: 4800000C  b 0x822b6b0c
	pc = 0x822B6B0C; continue 'dispatch;
            }
            0x822B6B04 => {
    //   block [0x822B6B04..0x822B6B0C)
	// 822B6B04: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B6B08: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B6B0C; continue 'dispatch;
            }
            0x822B6B0C => {
    //   block [0x822B6B0C..0x822B6B18)
	// 822B6B0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B6B10: 4199FFB8  bgt cr6, 0x822b6ac8
	if ctx.cr[6].gt {
	pc = 0x822B6AC8; continue 'dispatch;
	}
	// 822B6B14: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B6B18; continue 'dispatch;
            }
            0x822B6B18 => {
    //   block [0x822B6B18..0x822B6B34)
	// 822B6B18: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B6B1C: 419A0040  beq cr6, 0x822b6b5c
	if ctx.cr[6].eq {
	pc = 0x822B6B5C; continue 'dispatch;
	}
	// 822B6B20: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B6B24: 2F0B002F  cmpwi cr6, r11, 0x2f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 47, &mut ctx.xer);
	// 822B6B28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B6B2C: 41990008  bgt cr6, 0x822b6b34
	if ctx.cr[6].gt {
	pc = 0x822B6B34; continue 'dispatch;
	}
	// 822B6B30: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B6B34; continue 'dispatch;
            }
            0x822B6B34 => {
    //   block [0x822B6B34..0x822B6B5C)
	// 822B6B34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B6B38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6B3C: 409A0020  bne cr6, 0x822b6b5c
	if !ctx.cr[6].eq {
	pc = 0x822B6B5C; continue 'dispatch;
	}
	// 822B6B40: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B6B44: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822B6B48: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822B6B4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6B50: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 822B6B54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B6B58: 4800001C  b 0x822b6b74
	pc = 0x822B6B74; continue 'dispatch;
            }
            0x822B6B5C => {
    //   block [0x822B6B5C..0x822B6B70)
	// 822B6B5C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B6B60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6B64: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 822B6B68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B6B6C: 48000008  b 0x822b6b74
	pc = 0x822B6B74; continue 'dispatch;
            }
            0x822B6B70 => {
    //   block [0x822B6B70..0x822B6B74)
	// 822B6B70: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822B6B74; continue 'dispatch;
            }
            0x822B6B74 => {
    //   block [0x822B6B74..0x822B6BA4)
	// 822B6B74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B6B78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6B7C: 419A015C  beq cr6, 0x822b6cd8
	if ctx.cr[6].eq {
	pc = 0x822B6CD8; continue 'dispatch;
	}
	// 822B6B80: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 822B6B84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6B88: 419A0150  beq cr6, 0x822b6cd8
	if ctx.cr[6].eq {
	pc = 0x822B6CD8; continue 'dispatch;
	}
	// 822B6B8C: 815A001C  lwz r10, 0x1c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 822B6B90: 3BDA0018  addi r30, r26, 0x18
	ctx.r[30].s64 = ctx.r[26].s64 + 24;
	// 822B6B94: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822B6B98: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822B6B9C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B6BA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B6BA4; continue 'dispatch;
            }
            0x822B6BA4 => {
    //   block [0x822B6BA4..0x822B6BB8)
	// 822B6BA4: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6BA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6BAC: 419A000C  beq cr6, 0x822b6bb8
	if ctx.cr[6].eq {
	pc = 0x822B6BB8; continue 'dispatch;
	}
	// 822B6BB0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822B6BB4: 419A0008  beq cr6, 0x822b6bbc
	if ctx.cr[6].eq {
	pc = 0x822B6BBC; continue 'dispatch;
	}
	pc = 0x822B6BB8; continue 'dispatch;
            }
            0x822B6BB8 => {
    //   block [0x822B6BB8..0x822B6BBC)
	// 822B6BB8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B6BBC; continue 'dispatch;
            }
            0x822B6BBC => {
    //   block [0x822B6BBC..0x822B6BD0)
	// 822B6BBC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822B6BC0: 419A00A0  beq cr6, 0x822b6c60
	if ctx.cr[6].eq {
	pc = 0x822B6C60; continue 'dispatch;
	}
	// 822B6BC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6BC8: 409A0008  bne cr6, 0x822b6bd0
	if !ctx.cr[6].eq {
	pc = 0x822B6BD0; continue 'dispatch;
	}
	// 822B6BCC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B6BD0; continue 'dispatch;
            }
            0x822B6BD0 => {
    //   block [0x822B6BD0..0x822B6BE0)
	// 822B6BD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6BD4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B6BD8: 409A0008  bne cr6, 0x822b6be0
	if !ctx.cr[6].eq {
	pc = 0x822B6BE0; continue 'dispatch;
	}
	// 822B6BDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B6BE0; continue 'dispatch;
            }
            0x822B6BE0 => {
    //   block [0x822B6BE0..0x822B6BF8)
	// 822B6BE0: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822B6BE4: 83EA0010  lwz r31, 0x10(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B6BE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6BEC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 822B6BF0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 822B6BF4: 419A0020  beq cr6, 0x822b6c14
	if ctx.cr[6].eq {
	pc = 0x822B6C14; continue 'dispatch;
	}
	pc = 0x822B6BF8; continue 'dispatch;
            }
            0x822B6BF8 => {
    //   block [0x822B6BF8..0x822B6C14)
	// 822B6BF8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822B6BFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B6C00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822B6C04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822B6C08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822B6C0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B6C10: 4082FFE8  bne 0x822b6bf8
	if !ctx.cr[0].eq {
	pc = 0x822B6BF8; continue 'dispatch;
	}
	pc = 0x822B6C14; continue 'dispatch;
            }
            0x822B6C14 => {
    //   block [0x822B6C14..0x822B6C44)
	// 822B6C14: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822B6C18: 419A002C  beq cr6, 0x822b6c44
	if ctx.cr[6].eq {
	pc = 0x822B6C44; continue 'dispatch;
	}
	// 822B6C1C: 38BD000C  addi r5, r29, 0xc
	ctx.r[5].s64 = ctx.r[29].s64 + 12;
	// 822B6C20: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822B6C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B6C28: 481D0681  bl 0x824872a8
	ctx.lr = 0x822B6C2C;
	sub_824872A8(ctx, base);
	// 822B6C2C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B6C30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6C34: 419A0010  beq cr6, 0x822b6c44
	if ctx.cr[6].eq {
	pc = 0x822B6C44; continue 'dispatch;
	}
	// 822B6C38: 389A003C  addi r4, r26, 0x3c
	ctx.r[4].s64 = ctx.r[26].s64 + 60;
	// 822B6C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B6C40: 481D0961  bl 0x824875a0
	ctx.lr = 0x822B6C44;
	sub_824875A0(ctx, base);
	pc = 0x822B6C44; continue 'dispatch;
            }
            0x822B6C44 => {
    //   block [0x822B6C44..0x822B6C60)
	// 822B6C44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B6C48: 4BF00ED1  bl 0x821b7b18
	ctx.lr = 0x822B6C4C;
	sub_821B7B18(ctx, base);
	// 822B6C4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B6C50: 481861A1  bl 0x8243cdf0
	ctx.lr = 0x822B6C54;
	sub_8243CDF0(ctx, base);
	// 822B6C54: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B6C58: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822B6C5C: 4BFFFF48  b 0x822b6ba4
	pc = 0x822B6BA4; continue 'dispatch;
            }
            0x822B6C60 => {
    //   block [0x822B6C60..0x822B6C98)
	// 822B6C60: 817A0044  lwz r11, 0x44(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(68 as u32) ) } as u64;
	// 822B6C64: 389A003C  addi r4, r26, 0x3c
	ctx.r[4].s64 = ctx.r[26].s64 + 60;
	// 822B6C68: 815A0040  lwz r10, 0x40(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 822B6C6C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822B6C70: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 822B6C74: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822B6C78: 419A0060  beq cr6, 0x822b6cd8
	if ctx.cr[6].eq {
	pc = 0x822B6CD8; continue 'dispatch;
	}
	// 822B6C7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B6C80: 2F190005  cmpwi cr6, r25, 5
	ctx.cr[6].compare_i32(ctx.r[25].s32, 5, &mut ctx.xer);
	// 822B6C84: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 822B6C88: C0CBFFF4  lfs f6, -0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 822B6C8C: 4198000C  blt cr6, 0x822b6c98
	if ctx.cr[6].lt {
	pc = 0x822B6C98; continue 'dispatch;
	}
	// 822B6C90: FC203090  fmr f1, f6
	ctx.f[1].f64 = ctx.f[6].f64;
	// 822B6C94: 48000018  b 0x822b6cac
	pc = 0x822B6CAC; continue 'dispatch;
            }
            0x822B6C98 => {
    //   block [0x822B6C98..0x822B6CAC)
	// 822B6C98: 572A2036  slwi r10, r25, 4
	ctx.r[10].u32 = ctx.r[25].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822B6C9C: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822B6CA0: 7D6ADA14  add r11, r10, r27
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 822B6CA4: 386B00EC  addi r3, r11, 0xec
	ctx.r[3].s64 = ctx.r[11].s64 + 236;
	// 822B6CA8: 4857A391  bl 0x82831038
	ctx.lr = 0x822B6CAC;
	sub_82831038(ctx, base);
	pc = 0x822B6CAC; continue 'dispatch;
            }
            0x822B6CAC => {
    //   block [0x822B6CAC..0x822B6CBC)
	// 822B6CAC: 817A0040  lwz r11, 0x40(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 822B6CB0: 815A0044  lwz r10, 0x44(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(68 as u32) ) } as u64;
	// 822B6CB4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B6CB8: 419A002C  beq cr6, 0x822b6ce4
	if ctx.cr[6].eq {
	pc = 0x822B6CE4; continue 'dispatch;
	}
	pc = 0x822B6CBC; continue 'dispatch;
            }
            0x822B6CBC => {
    //   block [0x822B6CBC..0x822B6CD8)
	// 822B6CBC: D0CB0004  stfs f6, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822B6CC0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 822B6CC4: 815A0044  lwz r10, 0x44(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(68 as u32) ) } as u64;
	// 822B6CC8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B6CCC: 409AFFF0  bne cr6, 0x822b6cbc
	if !ctx.cr[6].eq {
	pc = 0x822B6CBC; continue 'dispatch;
	}
	// 822B6CD0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822B6CD4: 489F2778  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B6CD8 => {
    //   block [0x822B6CD8..0x822B6CE4)
	// 822B6CD8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B6CDC: 394B9490  addi r10, r11, -0x6b70
	ctx.r[10].s64 = ctx.r[11].s64 + -27504;
	// 822B6CE0: C02AFFF4  lfs f1, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x822B6CE4; continue 'dispatch;
            }
            0x822B6CE4 => {
    //   block [0x822B6CE4..0x822B6CEC)
	// 822B6CE4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822B6CE8: 489F2764  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B6CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B6CF0 size=240
    let mut pc: u32 = 0x822B6CF0;
    'dispatch: loop {
        match pc {
            0x822B6CF0 => {
    //   block [0x822B6CF0..0x822B6D54)
	// 822B6CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B6CF4: 489F2715  bl 0x82ca9408
	ctx.lr = 0x822B6CF8;
	sub_82CA93D0(ctx, base);
	// 822B6CF8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822B6CFC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B6D00: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 822B6D04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6D08: 409A00B0  bne cr6, 0x822b6db8
	if !ctx.cr[6].eq {
	pc = 0x822B6DB8; continue 'dispatch;
	}
	// 822B6D0C: 81630044  lwz r11, 0x44(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 822B6D10: 3BA3003C  addi r29, r3, 0x3c
	ctx.r[29].s64 = ctx.r[3].s64 + 60;
	// 822B6D14: 81430040  lwz r10, 0x40(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 822B6D18: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822B6D1C: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 822B6D20: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822B6D24: 409A0094  bne cr6, 0x822b6db8
	if !ctx.cr[6].eq {
	pc = 0x822B6DB8; continue 'dispatch;
	}
	// 822B6D28: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822B6D2C: 3BCB92B0  addi r30, r11, -0x6d50
	ctx.r[30].s64 = ctx.r[11].s64 + -27984;
	// 822B6D30: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B6D34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6D38: 419A0080  beq cr6, 0x822b6db8
	if ctx.cr[6].eq {
	pc = 0x822B6DB8; continue 'dispatch;
	}
	// 822B6D3C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6D40: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 822B6D44: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 822B6D48: 3B8AFFDF  addi r28, r10, -0x21
	ctx.r[28].s64 = ctx.r[10].s64 + -33;
	// 822B6D4C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B6D50: C3E99484  lfs f31, -0x6b7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x822B6D54; continue 'dispatch;
            }
            0x822B6D54 => {
    //   block [0x822B6D54..0x822B6D70)
	// 822B6D54: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B6D58: 419A0050  beq cr6, 0x822b6da8
	if ctx.cr[6].eq {
	pc = 0x822B6DA8; continue 'dispatch;
	}
	// 822B6D5C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B6D60: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822B6D64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6D68: 419A0008  beq cr6, 0x822b6d70
	if ctx.cr[6].eq {
	pc = 0x822B6D70; continue 'dispatch;
	}
	// 822B6D6C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822B6D70; continue 'dispatch;
            }
            0x822B6D70 => {
    //   block [0x822B6D70..0x822B6DA0)
	// 822B6D70: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 822B6D74: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 822B6D78: 4BF3CFE1  bl 0x821f3d58
	ctx.lr = 0x822B6D7C;
	sub_821F3D58(ctx, base);
	// 822B6D7C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 822B6D80: D3E10054  stfs f31, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822B6D84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B6D88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B6D8C: 4858B2D5  bl 0x82842060
	ctx.lr = 0x822B6D90;
	sub_82842060(ctx, base);
	// 822B6D90: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6D94: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B6D98: 409A0008  bne cr6, 0x822b6da0
	if !ctx.cr[6].eq {
	pc = 0x822B6DA0; continue 'dispatch;
	}
	// 822B6D9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B6DA0; continue 'dispatch;
            }
            0x822B6DA0 => {
    //   block [0x822B6DA0..0x822B6DA8)
	// 822B6DA0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B6DA4: 4BFFFFB0  b 0x822b6d54
	pc = 0x822B6D54; continue 'dispatch;
            }
            0x822B6DA8 => {
    //   block [0x822B6DA8..0x822B6DB8)
	// 822B6DA8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822B6DAC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822B6DB0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822B6DB4: 489F26A4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B6DB8 => {
    //   block [0x822B6DB8..0x822B6DE0)
	// 822B6DB8: 81630044  lwz r11, 0x44(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 822B6DBC: 81430040  lwz r10, 0x40(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 822B6DC0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822B6DC4: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 822B6DC8: 7D070034  cntlzw r7, r8
	ctx.r[7].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 822B6DCC: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 822B6DD0: 68C30001  xori r3, r6, 1
	ctx.r[3].u64 = ctx.r[6].u64 ^ 1;
	// 822B6DD4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822B6DD8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822B6DDC: 489F267C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B6DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822B6DE0 size=8
    let mut pc: u32 = 0x822B6DE0;
    'dispatch: loop {
        match pc {
            0x822B6DE0 => {
    //   block [0x822B6DE0..0x822B6DE8)
	// 822B6DE0: 38600012  li r3, 0x12
	ctx.r[3].s64 = 18;
	// 822B6DE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B6DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822B6DE8 size=68
    let mut pc: u32 = 0x822B6DE8;
    'dispatch: loop {
        match pc {
            0x822B6DE8 => {
    //   block [0x822B6DE8..0x822B6DFC)
	// 822B6DE8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 822B6DEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B6DF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B6DF4: 41990008  bgt cr6, 0x822b6dfc
	if ctx.cr[6].gt {
	pc = 0x822B6DFC; continue 'dispatch;
	}
	// 822B6DF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x822B6DFC; continue 'dispatch;
            }
            0x822B6DFC => {
    //   block [0x822B6DFC..0x822B6E2C)
	// 822B6DFC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822B6E00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B6E04: 419A0028  beq cr6, 0x822b6e2c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x822B6E2C);
		return;
	}
	// 822B6E08: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822B6E0C: 40980020  bge cr6, 0x822b6e2c
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x822B6E2C);
		return;
	}
	// 822B6E10: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822B6E14: 81430020  lwz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 822B6E18: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 822B6E1C: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822B6E20: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822B6E24: C02A0010  lfs f1, 0x10(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822B6E28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B6E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B6E38 size=252
    let mut pc: u32 = 0x822B6E38;
    'dispatch: loop {
        match pc {
            0x822B6E38 => {
    //   block [0x822B6E38..0x822B6E74)
	// 822B6E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B6E3C: 489F25D1  bl 0x82ca940c
	ctx.lr = 0x822B6E40;
	sub_82CA93D0(ctx, base);
	// 822B6E40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B6E44: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 822B6E48: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822B6E4C: 817F435C  lwz r11, 0x435c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17244 as u32) ) } as u64;
	// 822B6E50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6E54: 409A00A4  bne cr6, 0x822b6ef8
	if !ctx.cr[6].eq {
	pc = 0x822B6EF8; continue 'dispatch;
	}
	// 822B6E58: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 822B6E5C: 4BF683FD  bl 0x8221f258
	ctx.lr = 0x822B6E60;
	sub_8221F258(ctx, base);
	// 822B6E60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B6E64: 419A0010  beq cr6, 0x822b6e74
	if ctx.cr[6].eq {
	pc = 0x822B6E74; continue 'dispatch;
	}
	// 822B6E68: 487C2C09  bl 0x82a79a70
	ctx.lr = 0x822B6E6C;
	sub_82A79A70(ctx, base);
	// 822B6E6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822B6E70: 48000008  b 0x822b6e78
	pc = 0x822B6E78; continue 'dispatch;
            }
            0x822B6E74 => {
    //   block [0x822B6E74..0x822B6E78)
	// 822B6E74: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x822B6E78; continue 'dispatch;
            }
            0x822B6E78 => {
    //   block [0x822B6E78..0x822B6E88)
	// 822B6E78: 807F435C  lwz r3, 0x435c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17244 as u32) ) } as u64;
	// 822B6E7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B6E80: 419A003C  beq cr6, 0x822b6ebc
	if ctx.cr[6].eq {
	pc = 0x822B6EBC; continue 'dispatch;
	}
	// 822B6E84: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x822B6E88; continue 'dispatch;
            }
            0x822B6E88 => {
    //   block [0x822B6E88..0x822B6EBC)
	// 822B6E88: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 822B6E8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B6E90: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 822B6E94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B6E98: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822B6E9C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B6EA0: 4082FFE8  bne 0x822b6e88
	if !ctx.cr[0].eq {
	pc = 0x822B6E88; continue 'dispatch;
	}
	// 822B6EA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B6EA8: 409A0014  bne cr6, 0x822b6ebc
	if !ctx.cr[6].eq {
	pc = 0x822B6EBC; continue 'dispatch;
	}
	// 822B6EAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B6EB0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B6EB4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B6EB8: 4E800421  bctrl
	ctx.lr = 0x822B6EBC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822B6EBC => {
    //   block [0x822B6EBC..0x822B6EF8)
	// 822B6EBC: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 822B6EC0: 93DF435C  stw r30, 0x435c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(17244 as u32), ctx.r[30].u32 ) };
	// 822B6EC4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 822B6EC8: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 822B6ECC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822B6ED0: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 822B6ED4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822B6ED8: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 822B6EDC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 822B6EE0: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 822B6EE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B6EE8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 822B6EEC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 822B6EF0: 487C38B9  bl 0x82a7a7a8
	ctx.lr = 0x822B6EF4;
	sub_82A7A7A8(ctx, base);
	// 822B6EF4: 817F435C  lwz r11, 0x435c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17244 as u32) ) } as u64;
	pc = 0x822B6EF8; continue 'dispatch;
            }
            0x822B6EF8 => {
    //   block [0x822B6EF8..0x822B6F0C)
	// 822B6EF8: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822B6EFC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822B6F00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6F04: 419A0024  beq cr6, 0x822b6f28
	if ctx.cr[6].eq {
	pc = 0x822B6F28; continue 'dispatch;
	}
	// 822B6F08: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x822B6F0C; continue 'dispatch;
            }
            0x822B6F0C => {
    //   block [0x822B6F0C..0x822B6F28)
	// 822B6F0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822B6F10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B6F14: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822B6F18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822B6F1C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822B6F20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B6F24: 4082FFE8  bne 0x822b6f0c
	if !ctx.cr[0].eq {
	pc = 0x822B6F0C; continue 'dispatch;
	}
	pc = 0x822B6F28; continue 'dispatch;
            }
            0x822B6F28 => {
    //   block [0x822B6F28..0x822B6F34)
	// 822B6F28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B6F2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822B6F30: 489F252C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B6F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B6F38 size=212
    let mut pc: u32 = 0x822B6F38;
    'dispatch: loop {
        match pc {
            0x822B6F38 => {
    //   block [0x822B6F38..0x822B6FBC)
	// 822B6F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B6F3C: 489F24CD  bl 0x82ca9408
	ctx.lr = 0x822B6F40;
	sub_82CA93D0(ctx, base);
	// 822B6F40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B6F44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B6F48: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822B6F4C: 897F0067  lbz r11, 0x67(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(103 as u32) ) } as u64;
	// 822B6F50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B6F54: 409A0068  bne cr6, 0x822b6fbc
	if !ctx.cr[6].eq {
	pc = 0x822B6FBC; continue 'dispatch;
	}
	// 822B6F58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B6F5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B6F60: 997F0067  stb r11, 0x67(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(103 as u32), ctx.r[11].u8 ) };
	// 822B6F64: 4BF67AC5  bl 0x8221ea28
	ctx.lr = 0x822B6F68;
	sub_8221EA28(ctx, base);
	// 822B6F68: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B6F6C: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 822B6F70: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 822B6F74: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 822B6F78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B6F7C: C81D70A0  lfd f0, 0x70a0(r29)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(28832 as u32) ) };
	// 822B6F80: C9BC70A8  lfd f13, 0x70a8(r28)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(28840 as u32) ) };
	// 822B6F84: FD4B0028  fsub f10, f11, f0
	ctx.f[10].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 822B6F88: FD2A6824  fdiv f9, f10, f13
	ctx.f[9].f64 = ctx.f[10].f64 / ctx.f[13].f64;
	// 822B6F8C: D93F0068  stfd f9, 0x68(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.f[9].u64 ) };
	// 822B6F90: 4BF67A99  bl 0x8221ea28
	ctx.lr = 0x822B6F94;
	sub_8221EA28(ctx, base);
	// 822B6F94: C9010058  lfd f8, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822B6F98: FCE0469C  fcfid f7, f8
	ctx.f[7].f64 = (ctx.f[8].s64 as f64);
	// 822B6F9C: C81D70A0  lfd f0, 0x70a0(r29)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(28832 as u32) ) };
	// 822B6FA0: C9BC70A8  lfd f13, 0x70a8(r28)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(28840 as u32) ) };
	// 822B6FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B6FA8: FCC70028  fsub f6, f7, f0
	ctx.f[6].f64 = ctx.f[7].f64 - ctx.f[0].f64;
	// 822B6FAC: FCA66824  fdiv f5, f6, f13
	ctx.f[5].f64 = ctx.f[6].f64 / ctx.f[13].f64;
	// 822B6FB0: D8BF0070  stfd f5, 0x70(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.f[5].u64 ) };
	// 822B6FB4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822B6FB8: 489F24A0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B6FBC => {
    //   block [0x822B6FBC..0x822B700C)
	// 822B6FBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B6FC0: 4BF67A69  bl 0x8221ea28
	ctx.lr = 0x822B6FC4;
	sub_8221EA28(ctx, base);
	// 822B6FC4: C9610058  lfd f11, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822B6FC8: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 822B6FCC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822B6FD0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822B6FD4: C93F0068  lfd f9, 0x68(r31)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	// 822B6FD8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 822B6FDC: C80B70A0  lfd f0, 0x70a0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(28832 as u32) ) };
	// 822B6FE0: C9AA70A8  lfd f13, 0x70a8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(28840 as u32) ) };
	// 822B6FE4: C9890DD0  lfd f12, 0xdd0(r9)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3536 as u32) ) };
	// 822B6FE8: FD0A0028  fsub f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 - ctx.f[0].f64;
	// 822B6FEC: FCE86824  fdiv f7, f8, f13
	ctx.f[7].f64 = ctx.f[8].f64 / ctx.f[13].f64;
	// 822B6FF0: FCC74828  fsub f6, f7, f9
	ctx.f[6].f64 = ctx.f[7].f64 - ctx.f[9].f64;
	// 822B6FF4: FCA60332  fmul f5, f6, f12
	ctx.f[5].f64 = ctx.f[6].f64 * ctx.f[12].f64;
	// 822B6FF8: FC80281E  fctiwz f4, f5
	ctx.f[4].s64 = if ctx.f[5].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[5].f64.trunc() as i32 as i64 };
	// 822B6FFC: D8810058  stfd f4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[4].u64 ) };
	// 822B7000: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822B7004: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822B7008: 489F2450  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B7010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B7010 size=460
    let mut pc: u32 = 0x822B7010;
    'dispatch: loop {
        match pc {
            0x822B7010 => {
    //   block [0x822B7010..0x822B705C)
	// 822B7010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B7014: 489F23E1  bl 0x82ca93f4
	ctx.lr = 0x822B7018;
	sub_82CA93D0(ctx, base);
	// 822B7018: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 822B701C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B7020: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822B7024: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B7028: C1BD00BC  lfs f13, 0xbc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B702C: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B7030: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822B7034: 40990194  ble cr6, 0x822b71c8
	if !ctx.cr[6].gt {
	pc = 0x822B71C8; continue 'dispatch;
	}
	// 822B7038: 813D0018  lwz r9, 0x18(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 822B703C: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 822B7040: 80DD001C  lwz r6, 0x1c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 822B7044: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822B7048: 7D493050  subf r10, r9, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 822B704C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 822B7050: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 822B7054: 7D6A5BD7  divw. r11, r10, r11
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B7058: 4081005C  ble 0x822b70b4
	if !ctx.cr[0].gt {
	pc = 0x822B70B4; continue 'dispatch;
	}
	pc = 0x822B705C; continue 'dispatch;
            }
            0x822B705C => {
    //   block [0x822B705C..0x822B7084)
	// 822B705C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B7060: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B7064: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822B7068: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B706C: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 822B7070: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B7074: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 822B7078: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B707C: 41980008  blt cr6, 0x822b7084
	if ctx.cr[6].lt {
	pc = 0x822B7084; continue 'dispatch;
	}
	// 822B7080: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x822B7084; continue 'dispatch;
            }
            0x822B7084 => {
    //   block [0x822B7084..0x822B70A0)
	// 822B7084: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B7088: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B708C: 419A0014  beq cr6, 0x822b70a0
	if ctx.cr[6].eq {
	pc = 0x822B70A0; continue 'dispatch;
	}
	// 822B7090: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822B7094: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 822B7098: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B709C: 4800000C  b 0x822b70a8
	pc = 0x822B70A8; continue 'dispatch;
            }
            0x822B70A0 => {
    //   block [0x822B70A0..0x822B70A8)
	// 822B70A0: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822B70A4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x822B70A8; continue 'dispatch;
            }
            0x822B70A8 => {
    //   block [0x822B70A8..0x822B70B4)
	// 822B70A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B70AC: 4199FFB0  bgt cr6, 0x822b705c
	if ctx.cr[6].gt {
	pc = 0x822B705C; continue 'dispatch;
	}
	// 822B70B0: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	pc = 0x822B70B4; continue 'dispatch;
            }
            0x822B70B4 => {
    //   block [0x822B70B4..0x822B70D0)
	// 822B70B4: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B70B8: 419A0034  beq cr6, 0x822b70ec
	if ctx.cr[6].eq {
	pc = 0x822B70EC; continue 'dispatch;
	}
	// 822B70BC: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B70C0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 822B70C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B70C8: 41990008  bgt cr6, 0x822b70d0
	if ctx.cr[6].gt {
	pc = 0x822B70D0; continue 'dispatch;
	}
	// 822B70CC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822B70D0; continue 'dispatch;
            }
            0x822B70D0 => {
    //   block [0x822B70D0..0x822B70EC)
	// 822B70D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B70D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B70D8: 409A0014  bne cr6, 0x822b70ec
	if !ctx.cr[6].eq {
	pc = 0x822B70EC; continue 'dispatch;
	}
	// 822B70DC: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822B70E0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822B70E4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822B70E8: 48000008  b 0x822b70f0
	pc = 0x822B70F0; continue 'dispatch;
            }
            0x822B70EC => {
    //   block [0x822B70EC..0x822B70F0)
	// 822B70EC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x822B70F0; continue 'dispatch;
            }
            0x822B70F0 => {
    //   block [0x822B70F0..0x822B7108)
	// 822B70F0: 815D001C  lwz r10, 0x1c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 822B70F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B70F8: 419A0010  beq cr6, 0x822b7108
	if ctx.cr[6].eq {
	pc = 0x822B7108; continue 'dispatch;
	}
	// 822B70FC: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7100: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B7104: 4800000C  b 0x822b7110
	pc = 0x822B7110; continue 'dispatch;
            }
            0x822B7108 => {
    //   block [0x822B7108..0x822B7110)
	// 822B7108: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822B710C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x822B7110; continue 'dispatch;
            }
            0x822B7110 => {
    //   block [0x822B7110..0x822B71A0)
	// 822B7110: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B7114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B7118: 419A00B0  beq cr6, 0x822b71c8
	if ctx.cr[6].eq {
	pc = 0x822B71C8; continue 'dispatch;
	}
	// 822B711C: 897E000D  lbz r11, 0xd(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(13 as u32) ) } as u64;
	// 822B7120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B7124: 419A00A4  beq cr6, 0x822b71c8
	if ctx.cr[6].eq {
	pc = 0x822B71C8; continue 'dispatch;
	}
	// 822B7128: 897E000E  lbz r11, 0xe(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(14 as u32) ) } as u64;
	// 822B712C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B7130: 419A0098  beq cr6, 0x822b71c8
	if ctx.cr[6].eq {
	pc = 0x822B71C8; continue 'dispatch;
	}
	// 822B7134: 3BFD0080  addi r31, r29, 0x80
	ctx.r[31].s64 = ctx.r[29].s64 + 128;
	// 822B7138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B713C: 4BEBCCFD  bl 0x82173e38
	ctx.lr = 0x822B7140;
	sub_82173E38(ctx, base);
	// 822B7140: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B7144: 419A005C  beq cr6, 0x822b71a0
	if ctx.cr[6].eq {
	pc = 0x822B71A0; continue 'dispatch;
	}
	// 822B7148: 837D00D4  lwz r27, 0xd4(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(212 as u32) ) } as u64;
	// 822B714C: C3FD00BC  lfs f31, 0xbc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(188 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822B7150: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822B7154: 48346B3D  bl 0x825fdc90
	ctx.lr = 0x822B7158;
	sub_825FDC90(ctx, base);
	// 822B7158: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822B715C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B7160: 833D00C8  lwz r25, 0xc8(r29)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(200 as u32) ) } as u64;
	// 822B7164: 831D00C4  lwz r24, 0xc4(r29)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(196 as u32) ) } as u64;
	// 822B7168: 4BEBD301  bl 0x82174468
	ctx.lr = 0x822B716C;
	sub_82174468(ctx, base);
	// 822B716C: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 822B7170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B7174: 4BEBCCC5  bl 0x82173e38
	ctx.lr = 0x822B7178;
	sub_82173E38(ctx, base);
	// 822B7178: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B717C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 822B7180: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822B7184: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 822B7188: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 822B718C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822B7190: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 822B7194: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 822B7198: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B719C: 483442E5  bl 0x825fb480
	ctx.lr = 0x822B71A0;
	sub_825FB480(ctx, base);
	pc = 0x822B71A0; continue 'dispatch;
            }
            0x822B71A0 => {
    //   block [0x822B71A0..0x822B71C8)
	// 822B71A0: 9B9E000D  stb r28, 0xd(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(13 as u32), ctx.r[28].u8 ) };
	// 822B71A4: 396000F0  li r11, 0xf0
	ctx.r[11].s64 = 240;
	// 822B71A8: 39400110  li r10, 0x110
	ctx.r[10].s64 = 272;
	// 822B71AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x822B71C8; continue 'dispatch;
            }
            0x822B71C8 => {
    //   block [0x822B71C8..0x822B71DC)
	// 822B71C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B71CC: 4BECFEED  bl 0x821870b8
	ctx.lr = 0x822B71D0;
	sub_821870B8(ctx, base);
	// 822B71D0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822B71D4: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 822B71D8: 489F226C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B71E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B71E0 size=160
    let mut pc: u32 = 0x822B71E0;
    'dispatch: loop {
        match pc {
            0x822B71E0 => {
    //   block [0x822B71E0..0x822B7228)
	// 822B71E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B71E4: 489F2229  bl 0x82ca940c
	ctx.lr = 0x822B71E8;
	sub_82CA93D0(ctx, base);
	// 822B71E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B71EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822B71F0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B71F4: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B71F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B71FC: 4E800421  bctrl
	ctx.lr = 0x822B7200;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B7200: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B7204: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B7208: 419A0070  beq cr6, 0x822b7278
	if ctx.cr[6].eq {
	pc = 0x822B7278; continue 'dispatch;
	}
	// 822B720C: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 822B7210: 3BFD0010  addi r31, r29, 0x10
	ctx.r[31].s64 = ctx.r[29].s64 + 16;
	// 822B7214: 83DD0010  lwz r30, 0x10(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B7218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B721C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822B7220: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 822B7224: 419A0020  beq cr6, 0x822b7244
	if ctx.cr[6].eq {
	pc = 0x822B7244; continue 'dispatch;
	}
            }
            0x822B7228 => {
    //   block [0x822B7228..0x822B7244)
	// 822B7228: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822B722C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B7230: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822B7234: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822B7238: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822B723C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B7240: 4082FFE8  bne 0x822b7228
	if !ctx.cr[0].eq {
	pc = 0x822B7228; continue 'dispatch;
	}
	pc = 0x822B7244; continue 'dispatch;
            }
            0x822B7244 => {
    //   block [0x822B7244..0x822B7278)
	// 822B7244: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B7248: 387D0018  addi r3, r29, 0x18
	ctx.r[3].s64 = ctx.r[29].s64 + 24;
	// 822B724C: 4BEC414D  bl 0x8217b398
	ctx.lr = 0x822B7250;
	sub_8217B398(ctx, base);
	// 822B7250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B7254: 4BF008C5  bl 0x821b7b18
	ctx.lr = 0x822B7258;
	sub_821B7B18(ctx, base);
	// 822B7258: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822B725C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B7260: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822B7264: 48452D75  bl 0x82709fd8
	ctx.lr = 0x822B7268;
	sub_82709FD8(ctx, base);
	// 822B7268: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B726C: 4BFCEF3D  bl 0x822861a8
	ctx.lr = 0x822B7270;
	sub_822861A8(ctx, base);
	// 822B7270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B7274: 4BF008A5  bl 0x821b7b18
	ctx.lr = 0x822B7278;
	sub_821B7B18(ctx, base);
	pc = 0x822B7278; continue 'dispatch;
            }
            0x822B7278 => {
    //   block [0x822B7278..0x822B7280)
	// 822B7278: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822B727C: 489F21E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B7280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B7280 size=316
    let mut pc: u32 = 0x822B7280;
    'dispatch: loop {
        match pc {
            0x822B7280 => {
    //   block [0x822B7280..0x822B72B0)
	// 822B7280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B7284: 489F2181  bl 0x82ca9404
	ctx.lr = 0x822B7288;
	sub_82CA93D0(ctx, base);
	// 822B7288: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 822B728C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B7290: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822B7294: 817E007C  lwz r11, 0x7c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 822B7298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B729C: 419A0014  beq cr6, 0x822b72b0
	if ctx.cr[6].eq {
	pc = 0x822B72B0; continue 'dispatch;
	}
	// 822B72A0: 815E0080  lwz r10, 0x80(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 822B72A4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822B72A8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B72AC: 40820018  bne 0x822b72c4
	if !ctx.cr[0].eq {
	pc = 0x822B72C4; continue 'dispatch;
	}
	pc = 0x822B72B0; continue 'dispatch;
            }
            0x822B72B0 => {
    //   block [0x822B72B0..0x822B72C4)
	// 822B72B0: 387E00B0  addi r3, r30, 0xb0
	ctx.r[3].s64 = ctx.r[30].s64 + 176;
	// 822B72B4: 4BEDCB85  bl 0x82193e38
	ctx.lr = 0x822B72B8;
	sub_82193E38(ctx, base);
	// 822B72B8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822B72BC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822B72C0: 489F2194  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B72C4 => {
    //   block [0x822B72C4..0x822B72D8)
	// 822B72C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B72C8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822B72CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822B72D0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822B72D4: C3EBD5C8  lfs f31, -0x2a38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x822B72D8; continue 'dispatch;
            }
            0x822B72D8 => {
    //   block [0x822B72D8..0x822B72F0)
	// 822B72D8: 817E007C  lwz r11, 0x7c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 822B72DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B72E0: 419A0010  beq cr6, 0x822b72f0
	if ctx.cr[6].eq {
	pc = 0x822B72F0; continue 'dispatch;
	}
	// 822B72E4: 815E0080  lwz r10, 0x80(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 822B72E8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822B72EC: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x822B72F0; continue 'dispatch;
            }
            0x822B72F0 => {
    //   block [0x822B72F0..0x822B7318)
	// 822B72F0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B72F4: 419A00B0  beq cr6, 0x822b73a4
	if ctx.cr[6].eq {
	pc = 0x822B73A4; continue 'dispatch;
	}
	// 822B72F8: 817E007C  lwz r11, 0x7c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 822B72FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B7300: 419A0018  beq cr6, 0x822b7318
	if ctx.cr[6].eq {
	pc = 0x822B7318; continue 'dispatch;
	}
	// 822B7304: 815E0080  lwz r10, 0x80(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 822B7308: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822B730C: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 822B7310: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B7314: 41980008  blt cr6, 0x822b731c
	if ctx.cr[6].lt {
	pc = 0x822B731C; continue 'dispatch;
	}
	pc = 0x822B7318; continue 'dispatch;
            }
            0x822B7318 => {
    //   block [0x822B7318..0x822B731C)
	// 822B7318: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B731C; continue 'dispatch;
            }
            0x822B731C => {
    //   block [0x822B731C..0x822B7358)
	// 822B731C: 7C7C5A14  add r3, r28, r11
	ctx.r[3].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 822B7320: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B7328: 419A0074  beq cr6, 0x822b739c
	if ctx.cr[6].eq {
	pc = 0x822B739C; continue 'dispatch;
	}
	// 822B732C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B7330: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B7334: 419A0064  beq cr6, 0x822b7398
	if ctx.cr[6].eq {
	pc = 0x822B7398; continue 'dispatch;
	}
	// 822B7338: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822B733C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822B7340: 419A0018  beq cr6, 0x822b7358
	if ctx.cr[6].eq {
	pc = 0x822B7358; continue 'dispatch;
	}
	// 822B7344: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 822B7348: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822B734C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B7350: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B7354: 409A0008  bne cr6, 0x822b735c
	if !ctx.cr[6].eq {
	pc = 0x822B735C; continue 'dispatch;
	}
	pc = 0x822B7358; continue 'dispatch;
            }
            0x822B7358 => {
    //   block [0x822B7358..0x822B735C)
	// 822B7358: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822B735C; continue 'dispatch;
            }
            0x822B735C => {
    //   block [0x822B735C..0x822B7384)
	// 822B735C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B7360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B7364: 419A0028  beq cr6, 0x822b738c
	if ctx.cr[6].eq {
	pc = 0x822B738C; continue 'dispatch;
	}
	// 822B7368: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822B736C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B7370: 4BFDE8C1  bl 0x82295c30
	ctx.lr = 0x822B7374;
	sub_82295C30(ctx, base);
	// 822B7374: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822B7378: 419A000C  beq cr6, 0x822b7384
	if ctx.cr[6].eq {
	pc = 0x822B7384; continue 'dispatch;
	}
	// 822B737C: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 822B7380: 4098000C  bge cr6, 0x822b738c
	if !ctx.cr[6].lt {
	pc = 0x822B738C; continue 'dispatch;
	}
	pc = 0x822B7384; continue 'dispatch;
            }
            0x822B7384 => {
    //   block [0x822B7384..0x822B738C)
	// 822B7384: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 822B7388: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	pc = 0x822B738C; continue 'dispatch;
            }
            0x822B738C => {
    //   block [0x822B738C..0x822B7398)
	// 822B738C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822B7390: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 822B7394: 4BFFFF44  b 0x822b72d8
	pc = 0x822B72D8; continue 'dispatch;
            }
            0x822B7398 => {
    //   block [0x822B7398..0x822B739C)
	// 822B7398: 4BEDCAA1  bl 0x82193e38
	ctx.lr = 0x822B739C;
	sub_82193E38(ctx, base);
	pc = 0x822B739C; continue 'dispatch;
            }
            0x822B739C => {
    //   block [0x822B739C..0x822B73A4)
	// 822B739C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822B73A0: 4BFFFFB8  b 0x822b7358
	pc = 0x822B7358; continue 'dispatch;
            }
            0x822B73A4 => {
    //   block [0x822B73A4..0x822B73BC)
	// 822B73A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822B73A8: 387E00B0  addi r3, r30, 0xb0
	ctx.r[3].s64 = ctx.r[30].s64 + 176;
	// 822B73AC: 4BF5D4ED  bl 0x82214898
	ctx.lr = 0x822B73B0;
	sub_82214898(ctx, base);
	// 822B73B0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822B73B4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822B73B8: 489F209C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B73C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B73C0 size=1064
    let mut pc: u32 = 0x822B73C0;
    'dispatch: loop {
        match pc {
            0x822B73C0 => {
    //   block [0x822B73C0..0x822B7428)
	// 822B73C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B73C4: 489F2039  bl 0x82ca93fc
	ctx.lr = 0x822B73C8;
	sub_82CA93D0(ctx, base);
	// 822B73C8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B73CC: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 822B73D0: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 822B73D4: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 822B73D8: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 822B73DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B73E0: 419A0048  beq cr6, 0x822b7428
	if ctx.cr[6].eq {
	pc = 0x822B7428; continue 'dispatch;
	}
	// 822B73E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B73E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B73EC: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 822B73F0: 4803AB51  bl 0x822f1f40
	ctx.lr = 0x822B73F4;
	sub_822F1F40(ctx, base);
	// 822B73F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B73F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822B73FC: 4803A9B5  bl 0x822f1db0
	ctx.lr = 0x822B7400;
	sub_822F1DB0(ctx, base);
	// 822B7400: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822B7404: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822B7408: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 822B740C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 822B7410: 4803AA11  bl 0x822f1e20
	ctx.lr = 0x822B7414;
	sub_822F1E20(ctx, base);
	// 822B7414: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 822B7418: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822B741C: 483C43C5  bl 0x8267b7e0
	ctx.lr = 0x822B7420;
	sub_8267B7E0(ctx, base);
	// 822B7420: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B7424: 4BEBA3ED  bl 0x82171810
	ctx.lr = 0x822B7428;
	sub_82171810(ctx, base);
	pc = 0x822B7428; continue 'dispatch;
            }
            0x822B7428 => {
    //   block [0x822B7428..0x822B744C)
	// 822B7428: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 822B742C: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 822B7430: 48048CF9  bl 0x82300128
	ctx.lr = 0x822B7434;
	sub_82300128(ctx, base);
	// 822B7434: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B7438: 896A0011  lbz r11, 0x11(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(17 as u32) ) } as u64;
	// 822B743C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B7440: 419A000C  beq cr6, 0x822b744c
	if ctx.cr[6].eq {
	pc = 0x822B744C; continue 'dispatch;
	}
	// 822B7444: 837A0008  lwz r27, 8(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B7448: 4800002C  b 0x822b7474
	pc = 0x822B7474; continue 'dispatch;
            }
            0x822B744C => {
    //   block [0x822B744C..0x822B7464)
	// 822B744C: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B7450: 892B0011  lbz r9, 0x11(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 822B7454: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B7458: 419A000C  beq cr6, 0x822b7464
	if ctx.cr[6].eq {
	pc = 0x822B7464; continue 'dispatch;
	}
	// 822B745C: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 822B7460: 48000014  b 0x822b7474
	pc = 0x822B7474; continue 'dispatch;
            }
            0x822B7464 => {
    //   block [0x822B7464..0x822B7474)
	// 822B7464: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 822B7468: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 822B746C: 836B0008  lwz r27, 8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B7470: 409A00FC  bne cr6, 0x822b756c
	if !ctx.cr[6].eq {
	pc = 0x822B756C; continue 'dispatch;
	}
	pc = 0x822B7474; continue 'dispatch;
            }
            0x822B7474 => {
    //   block [0x822B7474..0x822B7488)
	// 822B7474: 897B0011  lbz r11, 0x11(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(17 as u32) ) } as u64;
	// 822B7478: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B747C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B7480: 409A0008  bne cr6, 0x822b7488
	if !ctx.cr[6].eq {
	pc = 0x822B7488; continue 'dispatch;
	}
	// 822B7484: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x822B7488; continue 'dispatch;
            }
            0x822B7488 => {
    //   block [0x822B7488..0x822B74A8)
	// 822B7488: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 822B748C: 3B8B1AA0  addi r28, r11, 0x1aa0
	ctx.r[28].s64 = ctx.r[11].s64 + 6816;
	// 822B7490: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7494: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7498: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 822B749C: 409A000C  bne cr6, 0x822b74a8
	if !ctx.cr[6].eq {
	pc = 0x822B74A8; continue 'dispatch;
	}
	// 822B74A0: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 822B74A4: 4800001C  b 0x822b74c0
	pc = 0x822B74C0; continue 'dispatch;
            }
            0x822B74A8 => {
    //   block [0x822B74A8..0x822B74BC)
	// 822B74A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B74AC: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 822B74B0: 409A000C  bne cr6, 0x822b74bc
	if !ctx.cr[6].eq {
	pc = 0x822B74BC; continue 'dispatch;
	}
	// 822B74B4: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 822B74B8: 48000008  b 0x822b74c0
	pc = 0x822B74C0; continue 'dispatch;
            }
            0x822B74BC => {
    //   block [0x822B74BC..0x822B74C0)
	// 822B74BC: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x822B74C0; continue 'dispatch;
            }
            0x822B74C0 => {
    //   block [0x822B74C0..0x822B74E4)
	// 822B74C0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B74C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B74C8: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 822B74CC: 409A0048  bne cr6, 0x822b7514
	if !ctx.cr[6].eq {
	pc = 0x822B7514; continue 'dispatch;
	}
	// 822B74D0: 897B0011  lbz r11, 0x11(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(17 as u32) ) } as u64;
	// 822B74D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B74D8: 419A000C  beq cr6, 0x822b74e4
	if ctx.cr[6].eq {
	pc = 0x822B74E4; continue 'dispatch;
	}
	// 822B74DC: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 822B74E0: 4800002C  b 0x822b750c
	pc = 0x822B750C; continue 'dispatch;
            }
            0x822B74E4 => {
    //   block [0x822B74E4..0x822B74F8)
	// 822B74E4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B74E8: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 822B74EC: 892B0011  lbz r9, 0x11(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 822B74F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B74F4: 409A0018  bne cr6, 0x822b750c
	if !ctx.cr[6].eq {
	pc = 0x822B750C; continue 'dispatch;
	}
	pc = 0x822B74F8; continue 'dispatch;
            }
            0x822B74F8 => {
    //   block [0x822B74F8..0x822B750C)
	// 822B74F8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B74FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B7500: 892B0011  lbz r9, 0x11(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 822B7504: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B7508: 419AFFF0  beq cr6, 0x822b74f8
	if ctx.cr[6].eq {
	pc = 0x822B74F8; continue 'dispatch;
	}
	pc = 0x822B750C; continue 'dispatch;
            }
            0x822B750C => {
    //   block [0x822B750C..0x822B7514)
	// 822B750C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7510: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x822B7514; continue 'dispatch;
            }
            0x822B7514 => {
    //   block [0x822B7514..0x822B753C)
	// 822B7514: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7518: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B751C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 822B7520: 409A00E8  bne cr6, 0x822b7608
	if !ctx.cr[6].eq {
	pc = 0x822B7608; continue 'dispatch;
	}
	// 822B7524: 897B0011  lbz r11, 0x11(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(17 as u32) ) } as u64;
	// 822B7528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B752C: 419A0010  beq cr6, 0x822b753c
	if ctx.cr[6].eq {
	pc = 0x822B753C; continue 'dispatch;
	}
	// 822B7530: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 822B7534: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822B7538: 480000D0  b 0x822b7608
	pc = 0x822B7608; continue 'dispatch;
            }
            0x822B753C => {
    //   block [0x822B753C..0x822B7550)
	// 822B753C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B7540: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 822B7544: 890B0011  lbz r8, 0x11(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 822B7548: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822B754C: 409A0018  bne cr6, 0x822b7564
	if !ctx.cr[6].eq {
	pc = 0x822B7564; continue 'dispatch;
	}
	pc = 0x822B7550; continue 'dispatch;
            }
            0x822B7550 => {
    //   block [0x822B7550..0x822B7564)
	// 822B7550: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B7554: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B7558: 890B0011  lbz r8, 0x11(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 822B755C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822B7560: 419AFFF0  beq cr6, 0x822b7550
	if ctx.cr[6].eq {
	pc = 0x822B7550; continue 'dispatch;
	}
	pc = 0x822B7564; continue 'dispatch;
            }
            0x822B7564 => {
    //   block [0x822B7564..0x822B756C)
	// 822B7564: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822B7568: 480000A0  b 0x822b7608
	pc = 0x822B7608; continue 'dispatch;
            }
            0x822B756C => {
    //   block [0x822B756C..0x822B758C)
	// 822B756C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822B7570: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B7574: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822B7578: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B757C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822B7580: 409A000C  bne cr6, 0x822b758c
	if !ctx.cr[6].eq {
	pc = 0x822B758C; continue 'dispatch;
	}
	// 822B7584: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822B7588: 4800002C  b 0x822b75b4
	pc = 0x822B75B4; continue 'dispatch;
            }
            0x822B758C => {
    //   block [0x822B758C..0x822B75A0)
	// 822B758C: 895B0011  lbz r10, 0x11(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(17 as u32) ) } as u64;
	// 822B7590: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7594: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B7598: 409A0008  bne cr6, 0x822b75a0
	if !ctx.cr[6].eq {
	pc = 0x822B75A0; continue 'dispatch;
	}
	// 822B759C: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x822B75A0; continue 'dispatch;
            }
            0x822B75A0 => {
    //   block [0x822B75A0..0x822B75B4)
	// 822B75A0: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 822B75A4: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B75A8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822B75AC: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B75B0: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x822B75B4; continue 'dispatch;
            }
            0x822B75B4 => {
    //   block [0x822B75B4..0x822B75D4)
	// 822B75B4: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 822B75B8: 3B8A1AA0  addi r28, r10, 0x1aa0
	ctx.r[28].s64 = ctx.r[10].s64 + 6816;
	// 822B75BC: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B75C0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B75C4: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 822B75C8: 409A000C  bne cr6, 0x822b75d4
	if !ctx.cr[6].eq {
	pc = 0x822B75D4; continue 'dispatch;
	}
	// 822B75CC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822B75D0: 48000020  b 0x822b75f0
	pc = 0x822B75F0; continue 'dispatch;
            }
            0x822B75D4 => {
    //   block [0x822B75D4..0x822B75EC)
	// 822B75D4: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B75D8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B75DC: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 822B75E0: 409A000C  bne cr6, 0x822b75ec
	if !ctx.cr[6].eq {
	pc = 0x822B75EC; continue 'dispatch;
	}
	// 822B75E4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822B75E8: 48000008  b 0x822b75f0
	pc = 0x822B75F0; continue 'dispatch;
            }
            0x822B75EC => {
    //   block [0x822B75EC..0x822B75F0)
	// 822B75EC: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x822B75F0; continue 'dispatch;
            }
            0x822B75F0 => {
    //   block [0x822B75F0..0x822B7608)
	// 822B75F0: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B75F4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822B75F8: 893A0010  lbz r9, 0x10(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B75FC: 890B0010  lbz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B7600: 992B0010  stb r9, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u8 ) };
	// 822B7604: 991A0010  stb r8, 0x10(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(16 as u32), ctx.r[8].u8 ) };
	pc = 0x822B7608; continue 'dispatch;
            }
            0x822B7608 => {
    //   block [0x822B7608..0x822B762C)
	// 822B7608: 897A0010  lbz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B760C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822B7610: 409A0198  bne cr6, 0x822b77a8
	if !ctx.cr[6].eq {
	pc = 0x822B77A8; continue 'dispatch;
	}
	// 822B7614: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7618: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 822B761C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7620: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B7624: 419A0180  beq cr6, 0x822b77a4
	if ctx.cr[6].eq {
	pc = 0x822B77A4; continue 'dispatch;
	}
	// 822B7628: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x822B762C; continue 'dispatch;
            }
            0x822B762C => {
    //   block [0x822B762C..0x822B766C)
	// 822B762C: 897B0010  lbz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B7630: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822B7634: 409A0170  bne cr6, 0x822b77a4
	if !ctx.cr[6].eq {
	pc = 0x822B77A4; continue 'dispatch;
	}
	// 822B7638: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B763C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B7640: 409A00A8  bne cr6, 0x822b76e8
	if !ctx.cr[6].eq {
	pc = 0x822B76E8; continue 'dispatch;
	}
	// 822B7644: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B7648: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B764C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B7650: 409A001C  bne cr6, 0x822b766c
	if !ctx.cr[6].eq {
	pc = 0x822B766C; continue 'dispatch;
	}
	// 822B7654: 9BAB0010  stb r29, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 822B7658: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822B765C: 9BDF0010  stb r30, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 822B7660: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822B7664: 4874B04D  bl 0x82a026b0
	ctx.lr = 0x822B7668;
	sub_82A026B0(ctx, base);
	// 822B7668: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x822B766C; continue 'dispatch;
            }
            0x822B766C => {
    //   block [0x822B766C..0x822B7698)
	// 822B766C: 894B0011  lbz r10, 0x11(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 822B7670: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B7674: 409A00C8  bne cr6, 0x822b773c
	if !ctx.cr[6].eq {
	pc = 0x822B773C; continue 'dispatch;
	}
	// 822B7678: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B767C: 892A0010  lbz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B7680: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 822B7684: 409A0014  bne cr6, 0x822b7698
	if !ctx.cr[6].eq {
	pc = 0x822B7698; continue 'dispatch;
	}
	// 822B7688: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B768C: 892A0010  lbz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B7690: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 822B7694: 419A00A4  beq cr6, 0x822b7738
	if ctx.cr[6].eq {
	pc = 0x822B7738; continue 'dispatch;
	}
	pc = 0x822B7698; continue 'dispatch;
            }
            0x822B7698 => {
    //   block [0x822B7698..0x822B76C4)
	// 822B7698: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B769C: 892A0010  lbz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B76A0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 822B76A4: 409A0020  bne cr6, 0x822b76c4
	if !ctx.cr[6].eq {
	pc = 0x822B76C4; continue 'dispatch;
	}
	// 822B76A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B76AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822B76B0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822B76B4: 9BAA0010  stb r29, 0x10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 822B76B8: 9BCB0010  stb r30, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 822B76BC: 4874B075  bl 0x82a02730
	ctx.lr = 0x822B76C0;
	sub_82A02730(ctx, base);
	// 822B76C0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x822B76C4; continue 'dispatch;
            }
            0x822B76C4 => {
    //   block [0x822B76C4..0x822B76E8)
	// 822B76C4: 895F0010  lbz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B76C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822B76CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822B76D0: 994B0010  stb r10, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 822B76D4: 9BBF0010  stb r29, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 822B76D8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B76DC: 9BA90010  stb r29, 0x10(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 822B76E0: 4874AFD1  bl 0x82a026b0
	ctx.lr = 0x822B76E4;
	sub_82A026B0(ctx, base);
	// 822B76E4: 480000C0  b 0x822b77a4
	pc = 0x822B77A4; continue 'dispatch;
            }
            0x822B76E8 => {
    //   block [0x822B76E8..0x822B770C)
	// 822B76E8: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B76EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B76F0: 409A001C  bne cr6, 0x822b770c
	if !ctx.cr[6].eq {
	pc = 0x822B770C; continue 'dispatch;
	}
	// 822B76F4: 9BAB0010  stb r29, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 822B76F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822B76FC: 9BDF0010  stb r30, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 822B7700: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822B7704: 4874B02D  bl 0x82a02730
	ctx.lr = 0x822B7708;
	sub_82A02730(ctx, base);
	// 822B7708: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822B770C; continue 'dispatch;
            }
            0x822B770C => {
    //   block [0x822B770C..0x822B7738)
	// 822B770C: 894B0011  lbz r10, 0x11(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 822B7710: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B7714: 409A0028  bne cr6, 0x822b773c
	if !ctx.cr[6].eq {
	pc = 0x822B773C; continue 'dispatch;
	}
	// 822B7718: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B771C: 892A0010  lbz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B7720: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 822B7724: 409A0034  bne cr6, 0x822b7758
	if !ctx.cr[6].eq {
	pc = 0x822B7758; continue 'dispatch;
	}
	// 822B7728: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B772C: 892A0010  lbz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B7730: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 822B7734: 409A0024  bne cr6, 0x822b7758
	if !ctx.cr[6].eq {
	pc = 0x822B7758; continue 'dispatch;
	}
	pc = 0x822B7738; continue 'dispatch;
            }
            0x822B7738 => {
    //   block [0x822B7738..0x822B773C)
	// 822B7738: 9BCB0010  stb r30, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	pc = 0x822B773C; continue 'dispatch;
            }
            0x822B773C => {
    //   block [0x822B773C..0x822B7758)
	// 822B773C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7740: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 822B7744: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7748: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B774C: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B7750: 409AFEDC  bne cr6, 0x822b762c
	if !ctx.cr[6].eq {
	pc = 0x822B762C; continue 'dispatch;
	}
	// 822B7754: 48000050  b 0x822b77a4
	pc = 0x822B77A4; continue 'dispatch;
            }
            0x822B7758 => {
    //   block [0x822B7758..0x822B7784)
	// 822B7758: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B775C: 892A0010  lbz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B7760: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 822B7764: 409A0020  bne cr6, 0x822b7784
	if !ctx.cr[6].eq {
	pc = 0x822B7784; continue 'dispatch;
	}
	// 822B7768: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B776C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822B7770: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822B7774: 9BAA0010  stb r29, 0x10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 822B7778: 9BCB0010  stb r30, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 822B777C: 4874AF35  bl 0x82a026b0
	ctx.lr = 0x822B7780;
	sub_82A026B0(ctx, base);
	// 822B7780: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822B7784; continue 'dispatch;
            }
            0x822B7784 => {
    //   block [0x822B7784..0x822B77A4)
	// 822B7784: 895F0010  lbz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822B7788: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822B778C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822B7790: 994B0010  stb r10, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 822B7794: 9BBF0010  stb r29, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 822B7798: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B779C: 9BA90010  stb r29, 0x10(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 822B77A0: 4874AF91  bl 0x82a02730
	ctx.lr = 0x822B77A4;
	sub_82A02730(ctx, base);
	pc = 0x822B77A4; continue 'dispatch;
            }
            0x822B77A4 => {
    //   block [0x822B77A4..0x822B77A8)
	// 822B77A4: 9BBB0010  stb r29, 0x10(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	pc = 0x822B77A8; continue 'dispatch;
            }
            0x822B77A8 => {
    //   block [0x822B77A8..0x822B77D8)
	// 822B77A8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822B77AC: 4BF6458D  bl 0x8221bd38
	ctx.lr = 0x822B77B0;
	sub_8221BD38(ctx, base);
	// 822B77B0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B77B4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822B77B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B77BC: 419A001C  beq cr6, 0x822b77d8
	if ctx.cr[6].eq {
	pc = 0x822B77D8; continue 'dispatch;
	}
	// 822B77C0: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 822B77C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B77C8: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822B77CC: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 822B77D0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822B77D4: 489F1C78  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B77D8 => {
    //   block [0x822B77D8..0x822B77E8)
	// 822B77D8: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 822B77DC: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 822B77E0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822B77E4: 489F1C68  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B77E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822B77E8 size=972
    let mut pc: u32 = 0x822B77E8;
    'dispatch: loop {
        match pc {
            0x822B77E8 => {
    //   block [0x822B77E8..0x822B7BB4)
	// 822B77E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B77EC: 489F1C1D  bl 0x82ca9408
	ctx.lr = 0x822B77F0;
	sub_82CA93D0(ctx, base);
	// 822B77F0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822B77F4: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B7BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B7BB8 size=100
    let mut pc: u32 = 0x822B7BB8;
    'dispatch: loop {
        match pc {
            0x822B7BB8 => {
    //   block [0x822B7BB8..0x822B7C1C)
	// 822B7BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B7BBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B7BC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822B7BC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B7BC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B7BCC: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 822B7BD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B7BD4: 4BF70525  bl 0x822280f8
	ctx.lr = 0x822B7BD8;
	sub_822280F8(ctx, base);
	// 822B7BD8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822B7BDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822B7BE0: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B7BE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822B7BE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822B7BEC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 822B7BF0: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822B7BF4: 4804A305  bl 0x82301ef8
	ctx.lr = 0x822B7BF8;
	sub_82301EF8(ctx, base);
	// 822B7BF8: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 822B7BFC: 4E800421  bctrl
	ctx.lr = 0x822B7C00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B7C00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822B7C04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B7C08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B7C0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B7C10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822B7C14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B7C18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B7C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822B7C20 size=452
    let mut pc: u32 = 0x822B7C20;
    'dispatch: loop {
        match pc {
            0x822B7C20 => {
    //   block [0x822B7C20..0x822B7DE4)
	// 822B7C20: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 822B7C24: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 822B7C28: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 822B7C2C: E9030278  ld r8, 0x278(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(632 as u32) ) };
	// 822B7C30: 39600260  li r11, 0x260
	ctx.r[11].s64 = 608;
	// 822B7C34: E8C301F0  ld r6, 0x1f0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(496 as u32) ) };
	// 822B7C38: E9430270  ld r10, 0x270(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(624 as u32) ) };
	// 822B7C3C: 3881FFD0  addi r4, r1, -0x30
	ctx.r[4].s64 = ctx.r[1].s64 + -48;
	// 822B7C40: E8A301F8  ld r5, 0x1f8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(504 as u32) ) };
	// 822B7C44: 3BE1FFE0  addi r31, r1, -0x20
	ctx.r[31].s64 = ctx.r[1].s64 + -32;
	// 822B7C48: 3BC1FFD0  addi r30, r1, -0x30
	ctx.r[30].s64 = ctx.r[1].s64 + -48;
	// 822B7C4C: D021001C  stfs f1, 0x1c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B7DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B7DE8 size=132
    let mut pc: u32 = 0x822B7DE8;
    'dispatch: loop {
        match pc {
            0x822B7DE8 => {
    //   block [0x822B7DE8..0x822B7E3C)
	// 822B7DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B7DEC: 489F1621  bl 0x82ca940c
	ctx.lr = 0x822B7DF0;
	sub_82CA93D0(ctx, base);
	// 822B7DF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B7DF4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822B7DF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822B7DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B7E00: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 822B7E04: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 822B7E08: 4BF72DD9  bl 0x8222abe0
	ctx.lr = 0x822B7E0C;
	sub_8222ABE0(ctx, base);
	// 822B7E0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822B7E10: 3D60F0F0  lis r11, -0xf10
	ctx.r[11].s64 = -252706816;
	// 822B7E14: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 822B7E18: 616AF0F0  ori r10, r11, 0xf0f0
	ctx.r[10].u64 = ctx.r[11].u64 | 61680;
	// 822B7E1C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 822B7E20: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822B7E24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B7E28: 4BF72DB9  bl 0x8222abe0
	ctx.lr = 0x822B7E2C;
	sub_8222ABE0(ctx, base);
	// 822B7E2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B7E30: 419A000C  beq cr6, 0x822b7e3c
	if ctx.cr[6].eq {
	pc = 0x822B7E3C; continue 'dispatch;
	}
	// 822B7E34: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 822B7E38: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x822B7E3C; continue 'dispatch;
            }
            0x822B7E3C => {
    //   block [0x822B7E3C..0x822B7E5C)
	// 822B7E3C: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 822B7E40: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 822B7E44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B7E48: 4BF72D99  bl 0x8222abe0
	ctx.lr = 0x822B7E4C;
	sub_8222ABE0(ctx, base);
	// 822B7E4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B7E50: 419A000C  beq cr6, 0x822b7e5c
	if ctx.cr[6].eq {
	pc = 0x822B7E5C; continue 'dispatch;
	}
	// 822B7E54: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822B7E58: 48001AA9  bl 0x822b9900
	ctx.lr = 0x822B7E5C;
	sub_822B9900(ctx, base);
	pc = 0x822B7E5C; continue 'dispatch;
            }
            0x822B7E5C => {
    //   block [0x822B7E5C..0x822B7E6C)
	// 822B7E5C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 822B7E60: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822B7E64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B7E68: 489F15F4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B7E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B7E70 size=120
    let mut pc: u32 = 0x822B7E70;
    'dispatch: loop {
        match pc {
            0x822B7E70 => {
    //   block [0x822B7E70..0x822B7ED0)
	// 822B7E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B7E74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B7E78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822B7E7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B7E80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B7E84: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822B7E88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822B7E8C: 3BEBAC08  addi r31, r11, -0x53f8
	ctx.r[31].s64 = ctx.r[11].s64 + -21496;
	// 822B7E90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7E94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B7E98: 419A0038  beq cr6, 0x822b7ed0
	if ctx.cr[6].eq {
	pc = 0x822B7ED0; continue 'dispatch;
	}
	// 822B7E9C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822B7EA0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7EA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822B7EA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B7EAC: 816B6E98  lwz r11, 0x6e98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28312 as u32) ) } as u64;
	// 822B7EB0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822B7EB4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822B7EB8: 4BEC57A1  bl 0x8217d658
	ctx.lr = 0x822B7EBC;
	sub_8217D658(ctx, base);
	// 822B7EBC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 822B7EC0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822B7EC4: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 822B7EC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B7ECC: 4BFCA8ED  bl 0x822827b8
	ctx.lr = 0x822B7ED0;
	sub_822827B8(ctx, base);
	pc = 0x822B7ED0; continue 'dispatch;
            }
            0x822B7ED0 => {
    //   block [0x822B7ED0..0x822B7EE8)
	// 822B7ED0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B7ED4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B7ED8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B7EDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822B7EE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B7EE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B7EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B7EE8 size=88
    let mut pc: u32 = 0x822B7EE8;
    'dispatch: loop {
        match pc {
            0x822B7EE8 => {
    //   block [0x822B7EE8..0x822B7F2C)
	// 822B7EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B7EEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B7EF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B7EF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B7EF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B7EFC: 8064007C  lwz r3, 0x7c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(124 as u32) ) } as u64;
	// 822B7F00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B7F04: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 822B7F08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B7F0C: 4E800421  bctrl
	ctx.lr = 0x822B7F10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B7F10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B7F14: 419A0018  beq cr6, 0x822b7f2c
	if ctx.cr[6].eq {
	pc = 0x822B7F2C; continue 'dispatch;
	}
	// 822B7F18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B7F1C: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 822B7F20: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B7F24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B7F28: 4E800421  bctrl
	ctx.lr = 0x822B7F2C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822B7F2C => {
    //   block [0x822B7F2C..0x822B7F40)
	// 822B7F2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822B7F30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B7F34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B7F38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B7F3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B7F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B7F40 size=204
    let mut pc: u32 = 0x822B7F40;
    'dispatch: loop {
        match pc {
            0x822B7F40 => {
    //   block [0x822B7F40..0x822B7F68)
	// 822B7F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B7F44: 489F14C9  bl 0x82ca940c
	ctx.lr = 0x822B7F48;
	sub_82CA93D0(ctx, base);
	// 822B7F48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B7F4C: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B7F50: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822B7F54: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B7F58: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 822B7F5C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B7F60: 40990008  ble cr6, 0x822b7f68
	if !ctx.cr[6].gt {
	pc = 0x822B7F68; continue 'dispatch;
	}
	// 822B7F64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B7F68; continue 'dispatch;
            }
            0x822B7F68 => {
    //   block [0x822B7F68..0x822B7F7C)
	// 822B7F68: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B7F6C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7F70: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B7F74: 40990008  ble cr6, 0x822b7f7c
	if !ctx.cr[6].gt {
	pc = 0x822B7F7C; continue 'dispatch;
	}
	// 822B7F78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B7F7C; continue 'dispatch;
            }
            0x822B7F7C => {
    //   block [0x822B7F7C..0x822B7F88)
	// 822B7F7C: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822B7F80: 419A0008  beq cr6, 0x822b7f88
	if ctx.cr[6].eq {
	pc = 0x822B7F88; continue 'dispatch;
	}
	// 822B7F84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B7F88; continue 'dispatch;
            }
            0x822B7F88 => {
    //   block [0x822B7F88..0x822B7F9C)
	// 822B7F88: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B7F8C: 419A0078  beq cr6, 0x822b8004
	if ctx.cr[6].eq {
	pc = 0x822B8004; continue 'dispatch;
	}
	// 822B7F90: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B7F94: 41980008  blt cr6, 0x822b7f9c
	if ctx.cr[6].lt {
	pc = 0x822B7F9C; continue 'dispatch;
	}
	// 822B7F98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B7F9C; continue 'dispatch;
            }
            0x822B7F9C => {
    //   block [0x822B7F9C..0x822B7FB4)
	// 822B7F9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B7FA0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B7FA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B7FA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822B7FAC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 822B7FB0: 419A0020  beq cr6, 0x822b7fd0
	if ctx.cr[6].eq {
	pc = 0x822B7FD0; continue 'dispatch;
	}
	pc = 0x822B7FB4; continue 'dispatch;
            }
            0x822B7FB4 => {
    //   block [0x822B7FB4..0x822B7FD0)
	// 822B7FB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822B7FB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B7FBC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822B7FC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822B7FC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822B7FC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B7FCC: 4082FFE8  bne 0x822b7fb4
	if !ctx.cr[0].eq {
	pc = 0x822B7FB4; continue 'dispatch;
	}
	pc = 0x822B7FD0; continue 'dispatch;
            }
            0x822B7FD0 => {
    //   block [0x822B7FD0..0x822B7FFC)
	// 822B7FD0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B7FD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822B7FD8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 822B7FDC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822B7FE0: 4E800421  bctrl
	ctx.lr = 0x822B7FE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B7FE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B7FE8: 4BEFFB31  bl 0x821b7b18
	ctx.lr = 0x822B7FEC;
	sub_821B7B18(ctx, base);
	// 822B7FEC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B7FF0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B7FF4: 41980008  blt cr6, 0x822b7ffc
	if ctx.cr[6].lt {
	pc = 0x822B7FFC; continue 'dispatch;
	}
	// 822B7FF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
            }
            0x822B7FFC => {
    //   block [0x822B7FFC..0x822B8004)
	// 822B7FFC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 822B8000: 4BFFFF68  b 0x822b7f68
	pc = 0x822B7F68; continue 'dispatch;
            }
            0x822B8004 => {
    //   block [0x822B8004..0x822B800C)
	// 822B8004: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822B8008: 489F1454  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B8010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B8010 size=376
    let mut pc: u32 = 0x822B8010;
    'dispatch: loop {
        match pc {
            0x822B8010 => {
    //   block [0x822B8010..0x822B803C)
	// 822B8010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B8014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B8018: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B801C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 822B8020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B8024: 419A0018  beq cr6, 0x822b803c
	if ctx.cr[6].eq {
	pc = 0x822B803C; continue 'dispatch;
	}
	// 822B8028: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 822B802C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822B8030: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B8034: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B8038: 409A0008  bne cr6, 0x822b8040
	if !ctx.cr[6].eq {
	pc = 0x822B8040; continue 'dispatch;
	}
	pc = 0x822B803C; continue 'dispatch;
            }
            0x822B803C => {
    //   block [0x822B803C..0x822B8040)
	// 822B803C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x822B8040; continue 'dispatch;
            }
            0x822B8040 => {
    //   block [0x822B8040..0x822B808C)
	// 822B8040: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822B8044: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B8048: 419A0130  beq cr6, 0x822b8178
	if ctx.cr[6].eq {
	pc = 0x822B8178; continue 'dispatch;
	}
	// 822B804C: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822B8050: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822B8054: 5528EFFE  rlwinm r8, r9, 0x1d, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 822B8058: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822B805C: 419A00F8  beq cr6, 0x822b8154
	if ctx.cr[6].eq {
	pc = 0x822B8154; continue 'dispatch;
	}
	// 822B8060: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822B8064: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822B8068: 419A0024  beq cr6, 0x822b808c
	if ctx.cr[6].eq {
	pc = 0x822B808C; continue 'dispatch;
	}
	// 822B806C: 892A0003  lbz r9, 3(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 822B8070: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B8074: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 822B8078: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822B807C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B8080: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B8084: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B8088: 480000D0  b 0x822b8158
	pc = 0x822B8158; continue 'dispatch;
            }
            0x822B808C => {
    //   block [0x822B808C..0x822B80AC)
	// 822B808C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822B8090: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822B8094: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822B8098: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 822B809C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822B80A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B80A4: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B80A8: 40810054  ble 0x822b80fc
	if !ctx.cr[0].gt {
	pc = 0x822B80FC; continue 'dispatch;
	}
	pc = 0x822B80AC; continue 'dispatch;
            }
            0x822B80AC => {
    //   block [0x822B80AC..0x822B80CC)
	// 822B80AC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B80B0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B80B4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822B80B8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B80BC: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 822B80C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B80C4: 41980008  blt cr6, 0x822b80cc
	if ctx.cr[6].lt {
	pc = 0x822B80CC; continue 'dispatch;
	}
	// 822B80C8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822B80CC; continue 'dispatch;
            }
            0x822B80CC => {
    //   block [0x822B80CC..0x822B80E8)
	// 822B80CC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B80D0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B80D4: 419A0014  beq cr6, 0x822b80e8
	if ctx.cr[6].eq {
	pc = 0x822B80E8; continue 'dispatch;
	}
	// 822B80D8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822B80DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B80E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B80E4: 4800000C  b 0x822b80f0
	pc = 0x822B80F0; continue 'dispatch;
            }
            0x822B80E8 => {
    //   block [0x822B80E8..0x822B80F0)
	// 822B80E8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822B80EC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822B80F0; continue 'dispatch;
            }
            0x822B80F0 => {
    //   block [0x822B80F0..0x822B80FC)
	// 822B80F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B80F4: 4199FFB8  bgt cr6, 0x822b80ac
	if ctx.cr[6].gt {
	pc = 0x822B80AC; continue 'dispatch;
	}
	// 822B80F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822B80FC; continue 'dispatch;
            }
            0x822B80FC => {
    //   block [0x822B80FC..0x822B8118)
	// 822B80FC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B8100: 419A0040  beq cr6, 0x822b8140
	if ctx.cr[6].eq {
	pc = 0x822B8140; continue 'dispatch;
	}
	// 822B8104: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B8108: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 822B810C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B8110: 41990008  bgt cr6, 0x822b8118
	if ctx.cr[6].gt {
	pc = 0x822B8118; continue 'dispatch;
	}
	// 822B8114: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822B8118; continue 'dispatch;
            }
            0x822B8118 => {
    //   block [0x822B8118..0x822B8140)
	// 822B8118: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B811C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B8120: 409A0020  bne cr6, 0x822b8140
	if !ctx.cr[6].eq {
	pc = 0x822B8140; continue 'dispatch;
	}
	// 822B8124: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B8128: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822B812C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B8130: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B8134: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B8138: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B813C: 4800001C  b 0x822b8158
	pc = 0x822B8158; continue 'dispatch;
            }
            0x822B8140 => {
    //   block [0x822B8140..0x822B8154)
	// 822B8140: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822B8144: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B8148: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822B814C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B8150: 48000008  b 0x822b8158
	pc = 0x822B8158; continue 'dispatch;
            }
            0x822B8154 => {
    //   block [0x822B8154..0x822B8158)
	// 822B8154: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822B8158; continue 'dispatch;
            }
            0x822B8158 => {
    //   block [0x822B8158..0x822B8178)
	// 822B8158: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B815C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B8160: 419A0018  beq cr6, 0x822b8178
	if ctx.cr[6].eq {
	pc = 0x822B8178; continue 'dispatch;
	}
	// 822B8164: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B8168: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 822B816C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 822B8170: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822B8174: 4E800421  bctrl
	ctx.lr = 0x822B8178;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x822B8178 => {
    //   block [0x822B8178..0x822B8188)
	// 822B8178: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822B817C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B8180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B8184: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B8188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B8188 size=156
    let mut pc: u32 = 0x822B8188;
    'dispatch: loop {
        match pc {
            0x822B8188 => {
    //   block [0x822B8188..0x822B81E4)
	// 822B8188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B818C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B8190: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B8194: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B8198: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B819C: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 822B81A0: 895F00C4  lbz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822B81A4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B81A8: 419A0068  beq cr6, 0x822b8210
	if ctx.cr[6].eq {
	pc = 0x822B8210; continue 'dispatch;
	}
	// 822B81AC: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 822B81B0: 989F00C4  stb r4, 0xc4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[4].u8 ) };
	// 822B81B4: 616A0100  ori r10, r11, 0x100
	ctx.r[10].u64 = ctx.r[11].u64 | 256;
	// 822B81B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B81BC: 915F0090  stw r10, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 822B81C0: 409A0024  bne cr6, 0x822b81e4
	if !ctx.cr[6].eq {
	pc = 0x822B81E4; continue 'dispatch;
	}
	// 822B81C4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822B81C8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B81CC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822B81D0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B81D4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B81D8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B81DC: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B81E0: 4BF58E39  bl 0x82211018
	ctx.lr = 0x822B81E4;
	sub_82211018(ctx, base);
	pc = 0x822B81E4; continue 'dispatch;
            }
            0x822B81E4 => {
    //   block [0x822B81E4..0x822B8210)
	// 822B81E4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822B81E8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B81EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822B81F0: 394B37A4  addi r10, r11, 0x37a4
	ctx.r[10].s64 = ctx.r[11].s64 + 14244;
	// 822B81F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822B81F8: 4BF4AB61  bl 0x82202d58
	ctx.lr = 0x822B81FC;
	sub_82202D58(ctx, base);
	// 822B81FC: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 822B8200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B8204: 39092B90  addi r8, r9, 0x2b90
	ctx.r[8].s64 = ctx.r[9].s64 + 11152;
	// 822B8208: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 822B820C: 482BB10D  bl 0x82573318
	ctx.lr = 0x822B8210;
	sub_82573318(ctx, base);
	pc = 0x822B8210; continue 'dispatch;
            }
            0x822B8210 => {
    //   block [0x822B8210..0x822B8224)
	// 822B8210: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B8214: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B8218: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B821C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B8220: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B8230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B8230 size=180
    let mut pc: u32 = 0x822B8230;
    'dispatch: loop {
        match pc {
            0x822B8230 => {
    //   block [0x822B8230..0x822B8258)
	// 822B8230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B8234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B8238: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B823C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822B8240: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822B8244: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822B8248: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B824C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B8250: 40990084  ble cr6, 0x822b82d4
	if !ctx.cr[6].gt {
	pc = 0x822B82D4; continue 'dispatch;
	}
	// 822B8254: 39060020  addi r8, r6, 0x20
	ctx.r[8].s64 = ctx.r[6].s64 + 32;
	pc = 0x822B8258; continue 'dispatch;
            }
            0x822B8258 => {
    //   block [0x822B8258..0x822B8274)
	// 822B8258: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 822B825C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B8260: 4BF62931  bl 0x8221ab90
	ctx.lr = 0x822B8264;
	sub_8221AB90(ctx, base);
	// 822B8264: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822B8268: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 822B826C: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 822B8270: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x822B8274; continue 'dispatch;
            }
            0x822B8274 => {
    //   block [0x822B8274..0x822B82AC)
	// 822B8274: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822B8278: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 822B827C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822B8280: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822B8284: 4200FFF0  bdnz 0x822b8274
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822B8274; continue 'dispatch;
	}
	// 822B8288: 81680040  lwz r11, 0x40(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 822B828C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B8290: 419A0030  beq cr6, 0x822b82c0
	if ctx.cr[6].eq {
	pc = 0x822B82C0; continue 'dispatch;
	}
	// 822B8294: 38880050  addi r4, r8, 0x50
	ctx.r[4].s64 = ctx.r[8].s64 + 80;
	// 822B8298: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822B829C: 4BF628F5  bl 0x8221ab90
	ctx.lr = 0x822B82A0;
	sub_8221AB90(ctx, base);
	// 822B82A0: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 822B82A4: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 822B82A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x822B82AC; continue 'dispatch;
            }
            0x822B82AC => {
    //   block [0x822B82AC..0x822B82C0)
	// 822B82AC: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822B82B0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 822B82B4: F9440000  std r10, 0(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 822B82B8: 38840008  addi r4, r4, 8
	ctx.r[4].s64 = ctx.r[4].s64 + 8;
	// 822B82BC: 4200FFF0  bdnz 0x822b82ac
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822B82AC; continue 'dispatch;
	}
	pc = 0x822B82C0; continue 'dispatch;
            }
            0x822B82C0 => {
    //   block [0x822B82C0..0x822B82D4)
	// 822B82C0: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B82C4: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 822B82C8: 390800B0  addi r8, r8, 0xb0
	ctx.r[8].s64 = ctx.r[8].s64 + 176;
	// 822B82CC: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822B82D0: 4198FF88  blt cr6, 0x822b8258
	if ctx.cr[6].lt {
	pc = 0x822B8258; continue 'dispatch;
	}
	pc = 0x822B82D4; continue 'dispatch;
            }
            0x822B82D4 => {
    //   block [0x822B82D4..0x822B82E4)
	// 822B82D4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822B82D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B82DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B82E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B82E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B82E8 size=148
    let mut pc: u32 = 0x822B82E8;
    'dispatch: loop {
        match pc {
            0x822B82E8 => {
    //   block [0x822B82E8..0x822B8348)
	// 822B82E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B82EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B82F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B82F4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822B82F8: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 822B82FC: 388BFB30  addi r4, r11, -0x4d0
	ctx.r[4].s64 = ctx.r[11].s64 + -1232;
	// 822B8300: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B8304: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B8308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B830C: 419A0048  beq cr6, 0x822b8354
	if ctx.cr[6].eq {
	pc = 0x822B8354; continue 'dispatch;
	}
	// 822B8310: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B8314: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822B8318: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 822B831C: 7D091670  srawi r9, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 822B8320: 7CE81670  srawi r8, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 822B8324: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822B8328: 40980020  bge cr6, 0x822b8348
	if !ctx.cr[6].lt {
	pc = 0x822B8348; continue 'dispatch;
	}
	// 822B832C: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 822B8330: 906A0000  stw r3, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 822B8334: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822B8338: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B833C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B8340: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B8344: 4E800020  blr
	return;
            }
            0x822B8348 => {
    //   block [0x822B8348..0x822B8354)
	// 822B8348: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B834C: 40990008  ble cr6, 0x822b8354
	if !ctx.cr[6].gt {
	pc = 0x822B8354; continue 'dispatch;
	}
	// 822B8350: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B8354; continue 'dispatch;
            }
            0x822B8354 => {
    //   block [0x822B8354..0x822B837C)
	// 822B8354: 38C10084  addi r6, r1, 0x84
	ctx.r[6].s64 = ctx.r[1].s64 + 132;
	// 822B8358: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822B835C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822B8360: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 822B8364: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B8368: 487A2659  bl 0x82a5a9c0
	ctx.lr = 0x822B836C;
	sub_82A5A9C0(ctx, base);
	// 822B836C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B8370: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B8374: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B8378: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B8380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B8380 size=600
    let mut pc: u32 = 0x822B8380;
    'dispatch: loop {
        match pc {
            0x822B8380 => {
    //   block [0x822B8380..0x822B83B8)
	// 822B8380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B8384: 489F1085  bl 0x82ca9408
	ctx.lr = 0x822B8388;
	sub_82CA93D0(ctx, base);
	// 822B8388: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822B838C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B8390: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822B8394: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B8398: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 822B839C: 556A067E  clrlwi r10, r11, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 822B83A0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822B83A4: 409A0014  bne cr6, 0x822b83b8
	if !ctx.cr[6].eq {
	pc = 0x822B83B8; continue 'dispatch;
	}
	// 822B83A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822B83AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822B83B0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822B83B4: 489F10A4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B83B8 => {
    //   block [0x822B83B8..0x822B85D8)
	// 822B83B8: 397D0050  addi r11, r29, 0x50
	ctx.r[11].s64 = ctx.r[29].s64 + 80;
	// 822B83BC: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 822B83C0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 822B83C4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 822B83C8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 822B83CC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B85D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B85D8 size=232
    let mut pc: u32 = 0x822B85D8;
    'dispatch: loop {
        match pc {
            0x822B85D8 => {
    //   block [0x822B85D8..0x822B860C)
	// 822B85D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B85DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B85E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B85E4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 822B85E8: 80C70000  lwz r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B85EC: 9087001C  stw r4, 0x1c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 822B85F0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 822B85F4: 419A00BC  beq cr6, 0x822b86b0
	if ctx.cr[6].eq {
	pc = 0x822B86B0; continue 'dispatch;
	}
	// 822B85F8: 81660090  lwz r11, 0x90(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(144 as u32) ) } as u64;
	// 822B85FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B8600: 409A000C  bne cr6, 0x822b860c
	if !ctx.cr[6].eq {
	pc = 0x822B860C; continue 'dispatch;
	}
	// 822B8604: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 822B8608: 4BF72D69  bl 0x8222b370
	ctx.lr = 0x822B860C;
	sub_8222B370(ctx, base);
	pc = 0x822B860C; continue 'dispatch;
            }
            0x822B860C => {
    //   block [0x822B860C..0x822B8638)
	// 822B860C: 81660090  lwz r11, 0x90(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(144 as u32) ) } as u64;
	// 822B8610: 8067001C  lwz r3, 0x1c(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 822B8614: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B8618: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822B861C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822B8620: 99270020  stb r9, 0x20(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[9].u8 ) };
	// 822B8624: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822B8628: A163006C  lhz r11, 0x6c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 822B862C: 616A4000  ori r10, r11, 0x4000
	ctx.r[10].u64 = ctx.r[11].u64 | 16384;
	// 822B8630: 409A0008  bne cr6, 0x822b8638
	if !ctx.cr[6].eq {
	pc = 0x822B8638; continue 'dispatch;
	}
	// 822B8634: 616A8000  ori r10, r11, 0x8000
	ctx.r[10].u64 = ctx.r[11].u64 | 32768;
	pc = 0x822B8638; continue 'dispatch;
            }
            0x822B8638 => {
    //   block [0x822B8638..0x822B8684)
	// 822B8638: B143006C  sth r10, 0x6c(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[10].u16 ) };
	// 822B863C: 48800485  bl 0x82ab8ac0
	ctx.lr = 0x822B8640;
	sub_82AB8AC0(ctx, base);
	// 822B8640: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B8644: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822B8648: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 822B864C: 2169001F  subfic r11, r9, 0x1f
	ctx.xer.ca = ctx.r[9].u32 <= 31 as u32;
	ctx.r[11].s64 = (31 as i64) - ctx.r[9].s64;
	// 822B8650: 390B0009  addi r8, r11, 9
	ctx.r[8].s64 = ctx.r[11].s64 + 9;
	// 822B8654: 91670024  stw r11, 0x24(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 822B8658: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822B865C: 7D6A202E  lwzx r11, r10, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 822B8660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B8664: 409A0020  bne cr6, 0x822b8684
	if !ctx.cr[6].eq {
	pc = 0x822B8684; continue 'dispatch;
	}
	// 822B8668: 7CCA212E  stwx r6, r10, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32), ctx.r[6].u32) };
	// 822B866C: 90C70014  stw r6, 0x14(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 822B8670: 90C70018  stw r6, 0x18(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 822B8674: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822B8678: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B867C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B8680: 4E800020  blr
	return;
            }
            0x822B8684 => {
    //   block [0x822B8684..0x822B86B0)
	// 822B8684: 810B0038  lwz r8, 0x38(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 822B8688: 392B0020  addi r9, r11, 0x20
	ctx.r[9].s64 = ctx.r[11].s64 + 32;
	// 822B868C: 91670014  stw r11, 0x14(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 822B8690: 812B0038  lwz r9, 0x38(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 822B8694: 91270018  stw r9, 0x18(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 822B8698: 90CB0038  stw r6, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[6].u32 ) };
	// 822B869C: 90C80034  stw r6, 0x34(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(52 as u32), ctx.r[6].u32 ) };
	// 822B86A0: 89070020  lbz r8, 0x20(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) } as u64;
	// 822B86A4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822B86A8: 419A0008  beq cr6, 0x822b86b0
	if ctx.cr[6].eq {
	pc = 0x822B86B0; continue 'dispatch;
	}
	// 822B86AC: 7CCA212E  stwx r6, r10, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32), ctx.r[6].u32) };
	pc = 0x822B86B0; continue 'dispatch;
            }
            0x822B86B0 => {
    //   block [0x822B86B0..0x822B86C0)
	// 822B86B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822B86B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B86B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B86BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B86C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B86C0 size=100
    let mut pc: u32 = 0x822B86C0;
    'dispatch: loop {
        match pc {
            0x822B86C0 => {
    //   block [0x822B86C0..0x822B8724)
	// 822B86C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B86C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B86C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822B86CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B86D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B86D4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822B86D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B86DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822B86E0: 806B6AB8  lwz r3, 0x6ab8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822B86E4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B86E8: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822B86EC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822B86F0: 4E800421  bctrl
	ctx.lr = 0x822B86F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B86F4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 822B86F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822B86FC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B8700: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B8704: 80A70000  lwz r5, 0(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B8708: 4BEC2CE1  bl 0x8217b3e8
	ctx.lr = 0x822B870C;
	sub_8217B3E8(ctx, base);
	// 822B870C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B8710: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B8714: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B8718: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822B871C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B8720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B8728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B8728 size=164
    let mut pc: u32 = 0x822B8728;
    'dispatch: loop {
        match pc {
            0x822B8728 => {
    //   block [0x822B8728..0x822B874C)
	// 822B8728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B872C: 489F0CE1  bl 0x82ca940c
	ctx.lr = 0x822B8730;
	sub_82CA93D0(ctx, base);
	// 822B8730: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B8734: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B8738: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B873C: 897F0019  lbz r11, 0x19(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 822B8740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B8744: 409A007C  bne cr6, 0x822b87c0
	if !ctx.cr[6].eq {
	pc = 0x822B87C0; continue 'dispatch;
	}
	// 822B8748: 83C40000  lwz r30, 0(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822B874C; continue 'dispatch;
            }
            0x822B874C => {
    //   block [0x822B874C..0x822B8760)
	// 822B874C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822B8750: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B8754: 409A000C  bne cr6, 0x822b8760
	if !ctx.cr[6].eq {
	pc = 0x822B8760; continue 'dispatch;
	}
	// 822B8758: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822B875C: 4800003C  b 0x822b8798
	pc = 0x822B8798; continue 'dispatch;
            }
            0x822B8760 => {
    //   block [0x822B8760..0x822B8770)
	// 822B8760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B8764: 409A000C  bne cr6, 0x822b8770
	if !ctx.cr[6].eq {
	pc = 0x822B8770; continue 'dispatch;
	}
	// 822B8768: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B876C: 4800002C  b 0x822b8798
	pc = 0x822B8798; continue 'dispatch;
            }
            0x822B8770 => {
    //   block [0x822B8770..0x822B8780)
	// 822B8770: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822B8774: 409A000C  bne cr6, 0x822b8780
	if !ctx.cr[6].eq {
	pc = 0x822B8780; continue 'dispatch;
	}
	// 822B8778: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822B877C: 4800001C  b 0x822b8798
	pc = 0x822B8798; continue 'dispatch;
            }
            0x822B8780 => {
    //   block [0x822B8780..0x822B8798)
	// 822B8780: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B8784: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B8788: 4BFB5071  bl 0x8226d7f8
	ctx.lr = 0x822B878C;
	sub_8226D7F8(ctx, base);
	// 822B878C: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 822B8790: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822B8794: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x822B8798; continue 'dispatch;
            }
            0x822B8798 => {
    //   block [0x822B8798..0x822B87AC)
	// 822B8798: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B879C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B87A0: 419A000C  beq cr6, 0x822b87ac
	if ctx.cr[6].eq {
	pc = 0x822B87AC; continue 'dispatch;
	}
	// 822B87A4: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B87A8: 4800000C  b 0x822b87b4
	pc = 0x822B87B4; continue 'dispatch;
            }
            0x822B87AC => {
    //   block [0x822B87AC..0x822B87B4)
	// 822B87AC: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 822B87B0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822B87B4; continue 'dispatch;
            }
            0x822B87B4 => {
    //   block [0x822B87B4..0x822B87C0)
	// 822B87B4: 897F0019  lbz r11, 0x19(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 822B87B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B87BC: 419AFF90  beq cr6, 0x822b874c
	if ctx.cr[6].eq {
	pc = 0x822B874C; continue 'dispatch;
	}
	pc = 0x822B87C0; continue 'dispatch;
            }
            0x822B87C0 => {
    //   block [0x822B87C0..0x822B87CC)
	// 822B87C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B87C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B87C8: 489F0C94  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B87D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B87D0 size=212
    let mut pc: u32 = 0x822B87D0;
    'dispatch: loop {
        match pc {
            0x822B87D0 => {
    //   block [0x822B87D0..0x822B87FC)
	// 822B87D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B87D4: 489F0C39  bl 0x82ca940c
	ctx.lr = 0x822B87D8;
	sub_82CA93D0(ctx, base);
	// 822B87D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B87DC: 3BE3001C  addi r31, r3, 0x1c
	ctx.r[31].s64 = ctx.r[3].s64 + 28;
	// 822B87E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822B87E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B87E8: 4BFFFF41  bl 0x822b8728
	ctx.lr = 0x822B87EC;
	sub_822B8728(ctx, base);
	// 822B87EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822B87F0: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 822B87F4: 409A0008  bne cr6, 0x822b87fc
	if !ctx.cr[6].eq {
	pc = 0x822B87FC; continue 'dispatch;
	}
	// 822B87F8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B87FC; continue 'dispatch;
            }
            0x822B87FC => {
    //   block [0x822B87FC..0x822B8830)
	// 822B87FC: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B8800: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822B8804: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822B8808: 419A0028  beq cr6, 0x822b8830
	if ctx.cr[6].eq {
	pc = 0x822B8830; continue 'dispatch;
	}
	// 822B880C: 38A3000C  addi r5, r3, 0xc
	ctx.r[5].s64 = ctx.r[3].s64 + 12;
	// 822B8810: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822B8814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B8818: 4851A7C1  bl 0x827d2fd8
	ctx.lr = 0x822B881C;
	sub_827D2FD8(ctx, base);
	// 822B881C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B8820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B8824: 409A000C  bne cr6, 0x822b8830
	if !ctx.cr[6].eq {
	pc = 0x822B8830; continue 'dispatch;
	}
	// 822B8828: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822B882C: 48000010  b 0x822b883c
	pc = 0x822B883C; continue 'dispatch;
            }
            0x822B8830 => {
    //   block [0x822B8830..0x822B883C)
	// 822B8830: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 822B8834: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 822B8838: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	pc = 0x822B883C; continue 'dispatch;
            }
            0x822B883C => {
    //   block [0x822B883C..0x822B885C)
	// 822B883C: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 822B8840: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B8844: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822B8848: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822B884C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B8850: 419A000C  beq cr6, 0x822b885c
	if ctx.cr[6].eq {
	pc = 0x822B885C; continue 'dispatch;
	}
	// 822B8854: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822B8858: 419A0008  beq cr6, 0x822b8860
	if ctx.cr[6].eq {
	pc = 0x822B8860; continue 'dispatch;
	}
	pc = 0x822B885C; continue 'dispatch;
            }
            0x822B885C => {
    //   block [0x822B885C..0x822B8860)
	// 822B885C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B8860; continue 'dispatch;
            }
            0x822B8860 => {
    //   block [0x822B8860..0x822B8878)
	// 822B8860: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822B8864: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822B8868: 419A0030  beq cr6, 0x822b8898
	if ctx.cr[6].eq {
	pc = 0x822B8898; continue 'dispatch;
	}
	// 822B886C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B8870: 409A0008  bne cr6, 0x822b8878
	if !ctx.cr[6].eq {
	pc = 0x822B8878; continue 'dispatch;
	}
	// 822B8874: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B8878; continue 'dispatch;
            }
            0x822B8878 => {
    //   block [0x822B8878..0x822B8888)
	// 822B8878: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B887C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B8880: 409A0008  bne cr6, 0x822b8888
	if !ctx.cr[6].eq {
	pc = 0x822B8888; continue 'dispatch;
	}
	// 822B8884: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822B8888; continue 'dispatch;
            }
            0x822B8888 => {
    //   block [0x822B8888..0x822B8898)
	// 822B8888: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 822B888C: 4BEBB5AD  bl 0x82173e38
	ctx.lr = 0x822B8890;
	sub_82173E38(ctx, base);
	// 822B8890: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822B8894: 489F0BC8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B8898 => {
    //   block [0x822B8898..0x822B88A4)
	// 822B8898: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822B889C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822B88A0: 489F0BBC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B88A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B88A8 size=140
    let mut pc: u32 = 0x822B88A8;
    'dispatch: loop {
        match pc {
            0x822B88A8 => {
    //   block [0x822B88A8..0x822B88E8)
	// 822B88A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B88AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B88B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822B88B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B88B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B88BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B88C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822B88C4: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822B88C8: 419A0050  beq cr6, 0x822b8918
	if ctx.cr[6].eq {
	pc = 0x822B8918; continue 'dispatch;
	}
	// 822B88CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B88D0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B88D4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822B88D8: 419A0040  beq cr6, 0x822b8918
	if ctx.cr[6].eq {
	pc = 0x822B8918; continue 'dispatch;
	}
	// 822B88DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B88E0: 419A0008  beq cr6, 0x822b88e8
	if ctx.cr[6].eq {
	pc = 0x822B88E8; continue 'dispatch;
	}
	// 822B88E4: 4BF0DE85  bl 0x821c6768
	ctx.lr = 0x822B88E8;
	sub_821C6768(ctx, base);
	pc = 0x822B88E8; continue 'dispatch;
            }
            0x822B88E8 => {
    //   block [0x822B88E8..0x822B88FC)
	// 822B88E8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B88EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B88F0: 419A0028  beq cr6, 0x822b8918
	if ctx.cr[6].eq {
	pc = 0x822B8918; continue 'dispatch;
	}
	// 822B88F4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822B88F8: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x822B88FC; continue 'dispatch;
            }
            0x822B88FC => {
    //   block [0x822B88FC..0x822B8918)
	// 822B88FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822B8900: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B8904: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822B8908: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822B890C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822B8910: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822B8914: 4082FFE8  bne 0x822b88fc
	if !ctx.cr[0].eq {
	pc = 0x822B88FC; continue 'dispatch;
	}
	pc = 0x822B8918; continue 'dispatch;
            }
            0x822B8918 => {
    //   block [0x822B8918..0x822B8934)
	// 822B8918: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B891C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B8920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B8924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B8928: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822B892C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B8930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B8938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822B8938 size=216
    let mut pc: u32 = 0x822B8938;
    'dispatch: loop {
        match pc {
            0x822B8938 => {
    //   block [0x822B8938..0x822B8A10)
	// 822B8938: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 822B893C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B8940: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 822B8944: 38C1FFE8  addi r6, r1, -0x18
	ctx.r[6].s64 = ctx.r[1].s64 + -24;
	// 822B8948: 38A1FFEC  addi r5, r1, -0x14
	ctx.r[5].s64 = ctx.r[1].s64 + -20;
	// 822B894C: 3881FFEC  addi r4, r1, -0x14
	ctx.r[4].s64 = ctx.r[1].s64 + -20;
	// 822B8950: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B8954: 3921FFE4  addi r9, r1, -0x1c
	ctx.r[9].s64 = ctx.r[1].s64 + -28;
	// 822B8958: D001FFE0  stfs f0, -0x20(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 822B895C: 3901FFE4  addi r8, r1, -0x1c
	ctx.r[8].s64 = ctx.r[1].s64 + -28;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B8A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822B8A10 size=3552
    let mut pc: u32 = 0x822B8A10;
    'dispatch: loop {
        match pc {
            0x822B8A10 => {
    //   block [0x822B8A10..0x822B97F0)
	// 822B8A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B8A14: 489F09CD  bl 0x82ca93e0
	ctx.lr = 0x822B8A18;
	sub_82CA93D0(ctx, base);
	// 822B8A18: DBC1FF78  stfd f30, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 822B8A1C: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 822B8A20: 3980FF40  li r12, -0xc0
	ctx.r[12].s64 = -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B97F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B97F0 size=156
    let mut pc: u32 = 0x822B97F0;
    'dispatch: loop {
        match pc {
            0x822B97F0 => {
    //   block [0x822B97F0..0x822B9828)
	// 822B97F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B97F4: 489EFC19  bl 0x82ca940c
	ctx.lr = 0x822B97F8;
	sub_82CA93D0(ctx, base);
	// 822B97F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B97FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B9800: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822B9804: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822B9808: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822B980C: 4BF65A4D  bl 0x8221f258
	ctx.lr = 0x822B9810;
	sub_8221F258(ctx, base);
	// 822B9810: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B9814: 419A0014  beq cr6, 0x822b9828
	if ctx.cr[6].eq {
	pc = 0x822B9828; continue 'dispatch;
	}
	// 822B9818: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822B981C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822B9820: 48000071  bl 0x822b9890
	ctx.lr = 0x822B9824;
	sub_822B9890(ctx, base);
	// 822B9824: 48000008  b 0x822b982c
	pc = 0x822B982C; continue 'dispatch;
            }
            0x822B9828 => {
    //   block [0x822B9828..0x822B982C)
	// 822B9828: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822B982C; continue 'dispatch;
            }
            0x822B982C => {
    //   block [0x822B982C..0x822B9878)
	// 822B982C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 822B9830: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B9834: 419A0044  beq cr6, 0x822b9878
	if ctx.cr[6].eq {
	pc = 0x822B9878; continue 'dispatch;
	}
	// 822B9838: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 822B983C: 4BF65A1D  bl 0x8221f258
	ctx.lr = 0x822B9840;
	sub_8221F258(ctx, base);
	// 822B9840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B9844: 419A0034  beq cr6, 0x822b9878
	if ctx.cr[6].eq {
	pc = 0x822B9878; continue 'dispatch;
	}
	// 822B9848: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B984C: 3D208219  lis r9, -0x7de7
	ctx.r[9].s64 = -2112290816;
	// 822B9850: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822B9854: 38E97F98  addi r7, r9, 0x7f98
	ctx.r[7].s64 = ctx.r[9].s64 + 32664;
	// 822B9858: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822B985C: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 822B9860: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 822B9864: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822B9868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B986C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822B9870: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B9874: 489EFBE8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B9878 => {
    //   block [0x822B9878..0x822B988C)
	// 822B9878: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822B987C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B9880: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822B9884: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B9888: 489EFBD4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B9890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B9890 size=108
    let mut pc: u32 = 0x822B9890;
    'dispatch: loop {
        match pc {
            0x822B9890 => {
    //   block [0x822B9890..0x822B98FC)
	// 822B9890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B9894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B9898: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822B989C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B98A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B98A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B98A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822B98AC: 3960FFFE  li r11, -2
	ctx.r[11].s64 = -2;
	// 822B98B0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 822B98B4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 822B98B8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822B98BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822B98C0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822B98C4: 4BF7360D  bl 0x8222ced0
	ctx.lr = 0x822B98C8;
	sub_8222CED0(ctx, base);
	// 822B98C8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B98CC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 822B98D0: 995F000C  stb r10, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	// 822B98D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B98D8: 4BFD5AD9  bl 0x8228f3b0
	ctx.lr = 0x822B98DC;
	sub_8228F3B0(ctx, base);
	// 822B98DC: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 822B98E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B98E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B98E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B98EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B98F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822B98F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B98F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B9900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822B9900 size=276
    let mut pc: u32 = 0x822B9900;
    'dispatch: loop {
        match pc {
            0x822B9900 => {
    //   block [0x822B9900..0x822B9A14)
	// 822B9900: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B9904: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 822B9908: 390B6A70  addi r8, r11, 0x6a70
	ctx.r[8].s64 = ctx.r[11].s64 + 27248;
	// 822B990C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 822B9910: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 822B9914: 38E91624  addi r7, r9, 0x1624
	ctx.r[7].s64 = ctx.r[9].s64 + 5668;
	// 822B9918: 80C40004  lwz r6, 4(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B991C: 39630068  addi r11, r3, 0x68
	ctx.r[11].s64 = ctx.r[3].s64 + 104;
	// 822B9920: 90C30004  stw r6, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 822B9924: 39640068  addi r11, r4, 0x68
	ctx.r[11].s64 = ctx.r[4].s64 + 104;
	// 822B9928: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B9A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B9A18 size=328
    let mut pc: u32 = 0x822B9A18;
    'dispatch: loop {
        match pc {
            0x822B9A18 => {
    //   block [0x822B9A18..0x822B9A50)
	// 822B9A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B9A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B9A20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822B9A24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822B9A28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B9A2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B9A30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822B9A34: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822B9A38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B9A3C: 41980014  blt cr6, 0x822b9a50
	if ctx.cr[6].lt {
	pc = 0x822B9A50; continue 'dispatch;
	}
	// 822B9A40: 4BFDECF9  bl 0x82298738
	ctx.lr = 0x822B9A44;
	sub_82298738(ctx, base);
	// 822B9A44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B9A48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B9A4C: 409A0008  bne cr6, 0x822b9a54
	if !ctx.cr[6].eq {
	pc = 0x822B9A54; continue 'dispatch;
	}
	pc = 0x822B9A50; continue 'dispatch;
            }
            0x822B9A50 => {
    //   block [0x822B9A50..0x822B9A54)
	// 822B9A50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822B9A54; continue 'dispatch;
            }
            0x822B9A54 => {
    //   block [0x822B9A54..0x822B9A94)
	// 822B9A54: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B9A58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B9A5C: 419A00E8  beq cr6, 0x822b9b44
	if ctx.cr[6].eq {
	pc = 0x822B9B44; continue 'dispatch;
	}
	// 822B9A60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822B9A64: 4BFDECD5  bl 0x82298738
	ctx.lr = 0x822B9A68;
	sub_82298738(ctx, base);
	// 822B9A68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822B9A6C: 419A00D8  beq cr6, 0x822b9b44
	if ctx.cr[6].eq {
	pc = 0x822B9B44; continue 'dispatch;
	}
	// 822B9A70: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 822B9A74: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 822B9A78: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 822B9A7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822B9A80: 7D093050  subf r8, r9, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 822B9A84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822B9A88: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 822B9A8C: 7D685BD7  divw. r11, r8, r11
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B9A90: 4081005C  ble 0x822b9aec
	if !ctx.cr[0].gt {
	pc = 0x822B9AEC; continue 'dispatch;
	}
	pc = 0x822B9A94; continue 'dispatch;
            }
            0x822B9A94 => {
    //   block [0x822B9A94..0x822B9ABC)
	// 822B9A94: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B9A98: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B9A9C: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822B9AA0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B9AA4: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 822B9AA8: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B9AAC: 2F070004  cmpwi cr6, r7, 4
	ctx.cr[6].compare_i32(ctx.r[7].s32, 4, &mut ctx.xer);
	// 822B9AB0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822B9AB4: 41980008  blt cr6, 0x822b9abc
	if ctx.cr[6].lt {
	pc = 0x822B9ABC; continue 'dispatch;
	}
	// 822B9AB8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822B9ABC; continue 'dispatch;
            }
            0x822B9ABC => {
    //   block [0x822B9ABC..0x822B9AD8)
	// 822B9ABC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822B9AC0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822B9AC4: 419A0014  beq cr6, 0x822b9ad8
	if ctx.cr[6].eq {
	pc = 0x822B9AD8; continue 'dispatch;
	}
	// 822B9AC8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822B9ACC: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 822B9AD0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822B9AD4: 4800000C  b 0x822b9ae0
	pc = 0x822B9AE0; continue 'dispatch;
            }
            0x822B9AD8 => {
    //   block [0x822B9AD8..0x822B9AE0)
	// 822B9AD8: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822B9ADC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x822B9AE0; continue 'dispatch;
            }
            0x822B9AE0 => {
    //   block [0x822B9AE0..0x822B9AEC)
	// 822B9AE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822B9AE4: 4199FFB0  bgt cr6, 0x822b9a94
	if ctx.cr[6].gt {
	pc = 0x822B9A94; continue 'dispatch;
	}
	// 822B9AE8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x822B9AEC; continue 'dispatch;
            }
            0x822B9AEC => {
    //   block [0x822B9AEC..0x822B9B08)
	// 822B9AEC: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822B9AF0: 419A0034  beq cr6, 0x822b9b24
	if ctx.cr[6].eq {
	pc = 0x822B9B24; continue 'dispatch;
	}
	// 822B9AF4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B9AF8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 822B9AFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822B9B00: 41990008  bgt cr6, 0x822b9b08
	if ctx.cr[6].gt {
	pc = 0x822B9B08; continue 'dispatch;
	}
	// 822B9B04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822B9B08; continue 'dispatch;
            }
            0x822B9B08 => {
    //   block [0x822B9B08..0x822B9B24)
	// 822B9B08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822B9B0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B9B10: 409A0014  bne cr6, 0x822b9b24
	if !ctx.cr[6].eq {
	pc = 0x822B9B24; continue 'dispatch;
	}
	// 822B9B14: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822B9B18: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822B9B1C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B9B20: 48000008  b 0x822b9b28
	pc = 0x822B9B28; continue 'dispatch;
            }
            0x822B9B24 => {
    //   block [0x822B9B24..0x822B9B28)
	// 822B9B24: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x822B9B28; continue 'dispatch;
            }
            0x822B9B28 => {
    //   block [0x822B9B28..0x822B9B44)
	// 822B9B28: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 822B9B2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822B9B30: 419A0014  beq cr6, 0x822b9b44
	if ctx.cr[6].eq {
	pc = 0x822B9B44; continue 'dispatch;
	}
	// 822B9B34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B9B38: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822B9B3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822B9B40: 48000008  b 0x822b9b48
	pc = 0x822B9B48; continue 'dispatch;
            }
            0x822B9B44 => {
    //   block [0x822B9B44..0x822B9B48)
	// 822B9B44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x822B9B48; continue 'dispatch;
            }
            0x822B9B48 => {
    //   block [0x822B9B48..0x822B9B60)
	// 822B9B48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822B9B4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B9B50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822B9B54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822B9B58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822B9B5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B9B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B9B60 size=528
    let mut pc: u32 = 0x822B9B60;
    'dispatch: loop {
        match pc {
            0x822B9B60 => {
    //   block [0x822B9B60..0x822B9B8C)
	// 822B9B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B9B64: 489EF899  bl 0x82ca93fc
	ctx.lr = 0x822B9B68;
	sub_82CA93D0(ctx, base);
	// 822B9B68: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B9B6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822B9B70: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 822B9B74: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822B9B78: 7D7DC850  subf r11, r29, r25
	ctx.r[11].s64 = ctx.r[25].s64 - ctx.r[29].s64;
	// 822B9B7C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 822B9B80: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822B9B84: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 822B9B88: 40990090  ble cr6, 0x822b9c18
	if !ctx.cr[6].gt {
	pc = 0x822B9C18; continue 'dispatch;
	}
	pc = 0x822B9B8C; continue 'dispatch;
            }
            0x822B9B8C => {
    //   block [0x822B9B8C..0x822B9BF8)
	// 822B9B8C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822B9B90: 409900CC  ble cr6, 0x822b9c5c
	if !ctx.cr[6].gt {
	pc = 0x822B9C5C; continue 'dispatch;
	}
	// 822B9B94: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822B9B98: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 822B9B9C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822B9BA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822B9BA4: 487D99A5  bl 0x82a93548
	ctx.lr = 0x822B9BA8;
	sub_82A93548(ctx, base);
	// 822B9BA8: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 822B9BAC: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 822B9BB0: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822B9BB4: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 822B9BB8: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822B9BBC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822B9BC0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822B9BC4: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822B9BC8: 7D3EC850  subf r9, r30, r25
	ctx.r[9].s64 = ctx.r[25].s64 - ctx.r[30].s64;
	// 822B9BCC: 7D1DE050  subf r8, r29, r28
	ctx.r[8].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 822B9BD0: 5527003A  rlwinm r7, r9, 0, 0, 0x1d
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 822B9BD4: 5506003A  rlwinm r6, r8, 0, 0, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 822B9BD8: 7F063800  cmpw cr6, r6, r7
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[7].s32, &mut ctx.xer);
	// 822B9BDC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822B9BE0: 40980018  bge cr6, 0x822b9bf8
	if !ctx.cr[6].lt {
	pc = 0x822B9BF8; continue 'dispatch;
	}
	// 822B9BE4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822B9BE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B9BEC: 4BFFFF75  bl 0x822b9b60
	ctx.lr = 0x822B9BF0;
	sub_822B9B60(ctx, base);
	// 822B9BF0: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 822B9BF4: 48000014  b 0x822b9c08
	pc = 0x822B9C08; continue 'dispatch;
            }
            0x822B9BF8 => {
    //   block [0x822B9BF8..0x822B9C08)
	// 822B9BF8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 822B9BFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822B9C00: 4BFFFF61  bl 0x822b9b60
	ctx.lr = 0x822B9C04;
	sub_822B9B60(ctx, base);
	// 822B9C04: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	pc = 0x822B9C08; continue 'dispatch;
            }
            0x822B9C08 => {
    //   block [0x822B9C08..0x822B9C18)
	// 822B9C08: 7D7DC850  subf r11, r29, r25
	ctx.r[11].s64 = ctx.r[25].s64 - ctx.r[29].s64;
	// 822B9C0C: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822B9C10: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 822B9C14: 4199FF78  bgt cr6, 0x822b9b8c
	if ctx.cr[6].gt {
	pc = 0x822B9B8C; continue 'dispatch;
	}
	pc = 0x822B9C18; continue 'dispatch;
            }
            0x822B9C18 => {
    //   block [0x822B9C18..0x822B9C38)
	// 822B9C18: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822B9C1C: 4099014C  ble cr6, 0x822b9d68
	if !ctx.cr[6].gt {
	pc = 0x822B9D68; continue 'dispatch;
	}
	// 822B9C20: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 822B9C24: 419A0144  beq cr6, 0x822b9d68
	if ctx.cr[6].eq {
	pc = 0x822B9D68; continue 'dispatch;
	}
	// 822B9C28: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 822B9C2C: 7F1FC840  cmplw cr6, r31, r25
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[25].u32, &mut ctx.xer);
	// 822B9C30: 419A0138  beq cr6, 0x822b9d68
	if ctx.cr[6].eq {
	pc = 0x822B9D68; continue 'dispatch;
	}
	// 822B9C34: 3B5F0004  addi r26, r31, 4
	ctx.r[26].s64 = ctx.r[31].s64 + 4;
	pc = 0x822B9C38; continue 'dispatch;
            }
            0x822B9C38 => {
    //   block [0x822B9C38..0x822B9C5C)
	// 822B9C38: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B9C3C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B9C40: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 822B9C44: 4E800421  bctrl
	ctx.lr = 0x822B9C48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B9C48: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B9C4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B9C50: 419A00AC  beq cr6, 0x822b9cfc
	if ctx.cr[6].eq {
	pc = 0x822B9CFC; continue 'dispatch;
	}
	// 822B9C54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B9C58: 480000F4  b 0x822b9d4c
	pc = 0x822B9D4C; continue 'dispatch;
            }
            0x822B9C5C => {
    //   block [0x822B9C5C..0x822B9C88)
	// 822B9C5C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 822B9C60: 4099FFB8  ble cr6, 0x822b9c18
	if !ctx.cr[6].gt {
	pc = 0x822B9C18; continue 'dispatch;
	}
	// 822B9C64: 7F5DC850  subf r26, r29, r25
	ctx.r[26].s64 = ctx.r[25].s64 - ctx.r[29].s64;
	// 822B9C68: 7F5C1670  srawi r28, r26, 2
	ctx.xer.ca = (ctx.r[26].s32 < 0) && ((ctx.r[26].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[26].s32 >> 2) as i64;
	// 822B9C6C: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 822B9C70: 409900F8  ble cr6, 0x822b9d68
	if !ctx.cr[6].gt {
	pc = 0x822B9D68; continue 'dispatch;
	}
	// 822B9C74: 7F8B0E70  srawi r11, r28, 1
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[28].s32 >> 1) as i64;
	// 822B9C78: 7FEB0195  addze. r31, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[31].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822B9C7C: 40810034  ble 0x822b9cb0
	if !ctx.cr[0].gt {
	pc = 0x822B9CB0; continue 'dispatch;
	}
	// 822B9C80: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822B9C84: 7FCBEA14  add r30, r11, r29
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	pc = 0x822B9C88; continue 'dispatch;
            }
            0x822B9C88 => {
    //   block [0x822B9C88..0x822B9CB0)
	// 822B9C88: 3BDEFFFC  addi r30, r30, -4
	ctx.r[30].s64 = ctx.r[30].s64 + -4;
	// 822B9C8C: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 822B9C90: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 822B9C94: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822B9C98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822B9C9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B9CA0: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B9CA4: 487D9D75  bl 0x82a93a18
	ctx.lr = 0x822B9CA8;
	sub_82A93A18(ctx, base);
	// 822B9CA8: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822B9CAC: 4199FFDC  bgt cr6, 0x822b9c88
	if ctx.cr[6].gt {
	pc = 0x822B9C88; continue 'dispatch;
	}
	pc = 0x822B9CB0; continue 'dispatch;
            }
            0x822B9CB0 => {
    //   block [0x822B9CB0..0x822B9CC0)
	// 822B9CB0: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 822B9CB4: 409900B4  ble cr6, 0x822b9d68
	if !ctx.cr[6].gt {
	pc = 0x822B9D68; continue 'dispatch;
	}
	// 822B9CB8: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 822B9CBC: 3BDDFFFC  addi r30, r29, -4
	ctx.r[30].s64 = ctx.r[29].s64 + -4;
	pc = 0x822B9CC0; continue 'dispatch;
            }
            0x822B9CC0 => {
    //   block [0x822B9CC0..0x822B9CFC)
	// 822B9CC0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B9CC4: 395FFFFC  addi r10, r31, -4
	ctx.r[10].s64 = ctx.r[31].s64 + -4;
	// 822B9CC8: 7CDEF82E  lwzx r6, r30, r31
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 822B9CCC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 822B9CD0: 7D451670  srawi r5, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 822B9CD4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822B9CD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822B9CDC: 7D7EF92E  stwx r11, r30, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u32) };
	// 822B9CE0: 487D9D39  bl 0x82a93a18
	ctx.lr = 0x822B9CE4;
	sub_82A93A18(ctx, base);
	// 822B9CE4: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 822B9CE8: 7FFC1670  srawi r28, r31, 2
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[31].s32 >> 2) as i64;
	// 822B9CEC: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 822B9CF0: 4199FFD0  bgt cr6, 0x822b9cc0
	if ctx.cr[6].gt {
	pc = 0x822B9CC0; continue 'dispatch;
	}
	// 822B9CF4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822B9CF8: 489EF754  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822B9CFC => {
    //   block [0x822B9CFC..0x822B9D1C)
	// 822B9CFC: 809AFFF8  lwz r4, -8(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822B9D00: 3BDAFFF8  addi r30, r26, -8
	ctx.r[30].s64 = ctx.r[26].s64 + -8;
	// 822B9D04: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B9D08: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 822B9D0C: 4E800421  bctrl
	ctx.lr = 0x822B9D10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B9D10: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B9D14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B9D18: 419A0040  beq cr6, 0x822b9d58
	if ctx.cr[6].eq {
	pc = 0x822B9D58; continue 'dispatch;
	}
            }
            0x822B9D1C => {
    //   block [0x822B9D1C..0x822B9D4C)
	// 822B9D1C: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 822B9D20: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B9D24: 3BDEFFFC  addi r30, r30, -4
	ctx.r[30].s64 = ctx.r[30].s64 + -4;
	// 822B9D28: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B9D2C: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 822B9D30: 4E800421  bctrl
	ctx.lr = 0x822B9D34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822B9D34: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822B9D38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822B9D3C: 409AFFE0  bne cr6, 0x822b9d1c
	if !ctx.cr[6].eq {
	pc = 0x822B9D1C; continue 'dispatch;
	}
	// 822B9D40: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822B9D44: 419A0014  beq cr6, 0x822b9d58
	if ctx.cr[6].eq {
	pc = 0x822B9D58; continue 'dispatch;
	}
	// 822B9D48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
            }
            0x822B9D4C => {
    //   block [0x822B9D4C..0x822B9D58)
	// 822B9D4C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 822B9D50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822B9D54: 487D9B3D  bl 0x82a93890
	ctx.lr = 0x822B9D58;
	sub_82A93890(ctx, base);
	pc = 0x822B9D58; continue 'dispatch;
            }
            0x822B9D58 => {
    //   block [0x822B9D58..0x822B9D68)
	// 822B9D58: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822B9D5C: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 822B9D60: 7F1FC840  cmplw cr6, r31, r25
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[25].u32, &mut ctx.xer);
	// 822B9D64: 409AFED4  bne cr6, 0x822b9c38
	if !ctx.cr[6].eq {
	pc = 0x822B9C38; continue 'dispatch;
	}
	pc = 0x822B9D68; continue 'dispatch;
            }
            0x822B9D68 => {
    //   block [0x822B9D68..0x822B9D70)
	// 822B9D68: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822B9D6C: 489EF6E0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B9D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822B9D70 size=624
    let mut pc: u32 = 0x822B9D70;
    'dispatch: loop {
        match pc {
            0x822B9D70 => {
    //   block [0x822B9D70..0x822B9E9C)
	// 822B9D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B9D74: 489EF67D  bl 0x82ca93f0
	ctx.lr = 0x822B9D78;
	sub_82CA93D0(ctx, base);
	// 822B9D78: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B9D7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822B9D80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822B9D84: 3BBF0020  addi r29, r31, 0x20
	ctx.r[29].s64 = ctx.r[31].s64 + 32;
	// 822B9D88: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822B9D8C: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B9D90: EB3F0020  ld r25, 0x20(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	// 822B9D94: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B9D98: EB1F0030  ld r24, 0x30(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	// 822B9D9C: EAFF0060  ld r23, 0x60(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	// 822B9DA0: ED800072  fmuls f12, f0, f1
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 822B9DA4: EADF0070  ld r22, 0x70(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	// 822B9DA8: ED6D0072  fmuls f11, f13, f1
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 822B9DAC: D19F0020  stfs f12, 0x20(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822B9DB0: D17F0024  stfs f11, 0x24(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822B9DB4: FB210058  std r25, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u64 ) };
	// 822B9DB8: C13F0030  lfs f9, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822B9DBC: FB010050  std r24, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u64 ) };
	// 822B9DC0: C15F0034  lfs f10, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822B9DC4: ECEA0072  fmuls f7, f10, f1
	ctx.f[7].f64 = (((ctx.f[10].f64 * ctx.f[1].f64) as f32) as f64);
	// 822B9DC8: ED090072  fmuls f8, f9, f1
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[1].f64) as f32) as f64);
	// 822B9DCC: D0FF0034  stfs f7, 0x34(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 822B9DD0: D11F0030  stfs f8, 0x30(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 822B9DD4: C0BF0060  lfs f5, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 822B9DD8: C0DF0064  lfs f6, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 822B9DDC: EC660072  fmuls f3, f6, f1
	ctx.f[3].f64 = (((ctx.f[6].f64 * ctx.f[1].f64) as f32) as f64);
	// 822B9DE0: EC850072  fmuls f4, f5, f1
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[1].f64) as f32) as f64);
	// 822B9DE4: D07F0064  stfs f3, 0x64(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822B9DE8: D09F0060  stfs f4, 0x60(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822B9DEC: C01F0070  lfs f0, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B9DF0: C05F0074  lfs f2, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 822B9DF4: ED8100B2  fmuls f12, f1, f2
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[2].f64) as f32) as f64);
	// 822B9DF8: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 822B9DFC: D1BF0070  stfs f13, 0x70(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822B9E00: D19F0074  stfs f12, 0x74(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822B9E04: E93F01A8  ld r9, 0x1a8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) };
	// 822B9E08: C17F01B0  lfs f11, 0x1b0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822B9E0C: E95F01A0  ld r10, 0x1a0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	// 822B9E10: C1410058  lfs f10, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822B9E14: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 822B9E18: C0E10050  lfs f7, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 822B9E1C: ED015828  fsubs f8, f1, f11
	ctx.f[8].f64 = (((ctx.f[1].f64 - ctx.f[11].f64) as f32) as f64);
	// 822B9E20: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822B9E24: C0C10054  lfs f6, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 822B9E28: C121005C  lfs f9, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822B9E2C: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 822B9E30: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822B9E34: ECAA0232  fmuls f5, f10, f8
	ctx.f[5].f64 = (((ctx.f[10].f64 * ctx.f[8].f64) as f32) as f64);
	// 822B9E38: C141005C  lfs f10, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822B9E3C: EC690232  fmuls f3, f9, f8
	ctx.f[3].f64 = (((ctx.f[9].f64 * ctx.f[8].f64) as f32) as f64);
	// 822B9E40: C09F0150  lfs f4, 0x150(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 822B9E44: EC470232  fmuls f2, f7, f8
	ctx.f[2].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 822B9E48: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822B9E4C: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822B9E50: D03F01B0  stfs f1, 0x1b0(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 822B9E54: ED2D282A  fadds f9, f13, f5
	ctx.f[9].f64 = ((ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64;
	// 822B9E58: D1210060  stfs f9, 0x60(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822B9E5C: ECE3602A  fadds f7, f3, f12
	ctx.f[7].f64 = ((ctx.f[3].f64 + ctx.f[12].f64) as f32) as f64;
	// 822B9E60: D0E10064  stfs f7, 0x64(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822B9E64: EC660232  fmuls f3, f6, f8
	ctx.f[3].f64 = (((ctx.f[6].f64 * ctx.f[8].f64) as f32) as f64);
	// 822B9E68: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822B9E6C: ECAB102A  fadds f5, f11, f2
	ctx.f[5].f64 = ((ctx.f[11].f64 + ctx.f[2].f64) as f32) as f64;
	// 822B9E70: D0A10060  stfs f5, 0x60(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822B9E74: F97F01A0  std r11, 0x1a0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[11].u64 ) };
	// 822B9E78: FF040000  fcmpu cr6, f4, f0
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[0].f64);
	// 822B9E7C: EC43502A  fadds f2, f3, f10
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[10].f64) as f32) as f64;
	// 822B9E80: D0410064  stfs f2, 0x64(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822B9E84: F97F0020  std r11, 0x20(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 822B9E88: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822B9E8C: F97F01A8  std r11, 0x1a8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u64 ) };
	// 822B9E90: F97F0030  std r11, 0x30(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u64 ) };
	// 822B9E94: 41990008  bgt cr6, 0x822b9e9c
	if ctx.cr[6].gt {
	pc = 0x822B9E9C; continue 'dispatch;
	}
	// 822B9E98: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x822B9E9C; continue 'dispatch;
            }
            0x822B9E9C => {
    //   block [0x822B9E9C..0x822B9EE0)
	// 822B9E9C: 3860004F  li r3, 0x4f
	ctx.r[3].s64 = 79;
	// 822B9EA0: 48000141  bl 0x822b9fe0
	ctx.lr = 0x822B9EA4;
	sub_822B9FE0(ctx, base);
	// 822B9EA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822B9EA8: 38600052  li r3, 0x52
	ctx.r[3].s64 = 82;
	// 822B9EAC: 48000135  bl 0x822b9fe0
	ctx.lr = 0x822B9EB0;
	sub_822B9FE0(ctx, base);
	// 822B9EB0: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 822B9EB4: 3B40001C  li r26, 0x1c
	ctx.r[26].s64 = 28;
	// 822B9EB8: 3B8BDED4  addi r28, r11, -0x212c
	ctx.r[28].s64 = ctx.r[11].s64 + -8492;
	// 822B9EBC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 822B9EC0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822B9EC4: 814B133C  lwz r10, 0x133c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4924 as u32) ) } as u64;
	// 822B9EC8: 808B1338  lwz r4, 0x1338(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4920 as u32) ) } as u64;
	// 822B9ECC: 2F0A001C  cmpwi cr6, r10, 0x1c
	ctx.cr[6].compare_i32(ctx.r[10].s32, 28, &mut ctx.xer);
	// 822B9ED0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 822B9ED4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822B9ED8: 41990008  bgt cr6, 0x822b9ee0
	if ctx.cr[6].gt {
	pc = 0x822B9EE0; continue 'dispatch;
	}
	// 822B9EDC: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	pc = 0x822B9EE0; continue 'dispatch;
            }
            0x822B9EE0 => {
    //   block [0x822B9EE0..0x822B9F4C)
	// 822B9EE0: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B9EE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822B9EE8: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 822B9EEC: 795EFFE6  rldicr r30, r10, 0x3f, 0x3f
	ctx.r[30].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 822B9EF0: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 822B9EF4: 41980058  blt cr6, 0x822b9f4c
	if ctx.cr[6].lt {
	pc = 0x822B9F4C; continue 'dispatch;
	}
	// 822B9EF8: 7C8A1670  srawi r10, r4, 2
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[4].s32 >> 2) as i64;
	// 822B9EFC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 822B9F00: 7D0A0194  addze r8, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[8].s64 = tmp.s64;
	// 822B9F04: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 822B9F08: E9491760  ld r10, 0x1760(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(5984 as u32) ) };
	// 822B9F0C: 7FC53C36  srd r5, r30, r7
	if (ctx.r[7].u8 & 0x40) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = (ctx.r[30].u64) >> ((ctx.r[7].u8 & 0x3F) as u32);
	}
	// 822B9F10: 7CA35038  and r3, r5, r10
	ctx.r[3].u64 = ctx.r[5].u64 & ctx.r[10].u64;
	// 822B9F14: 2B230000  cmpldi cr6, r3, 0
	ctx.cr[6].compare_u64(ctx.r[3].u64, 0, &mut ctx.xer);
	// 822B9F18: 419A0034  beq cr6, 0x822b9f4c
	if ctx.cr[6].eq {
	pc = 0x822B9F4C; continue 'dispatch;
	}
	// 822B9F1C: 7D662214  add r11, r6, r4
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[4].u64;
	// 822B9F20: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 822B9F24: 548AF0BE  srwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822B9F28: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 822B9F2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822B9F30: 5528F0BE  srwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B9F34: 7CEA4050  subf r7, r10, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 822B9F38: 78EB0020  clrldi r11, r7, 0x20
	ctx.r[11].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 822B9F3C: 7FC95E34  srad r9, r30, r11
	tmp.u64 = (ctx.r[11].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[30].s64 < 0) && ((ctx.r[30].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[9].s64 = ctx.r[30].s64 >> tmp.u64;
	// 822B9F40: 7D275436  srd r7, r9, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[9].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 822B9F44: 4BF6093D  bl 0x8221a880
	ctx.lr = 0x822B9F48;
	sub_8221A880(ctx, base);
	// 822B9F48: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x822B9F4C; continue 'dispatch;
            }
            0x822B9F4C => {
    //   block [0x822B9F4C..0x822B9F6C)
	// 822B9F4C: 814B0CD0  lwz r10, 0xcd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3280 as u32) ) } as u64;
	// 822B9F50: 808B0CCC  lwz r4, 0xccc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3276 as u32) ) } as u64;
	// 822B9F54: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 822B9F58: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 822B9F5C: 2F0A001C  cmpwi cr6, r10, 0x1c
	ctx.cr[6].compare_i32(ctx.r[10].s32, 28, &mut ctx.xer);
	// 822B9F60: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822B9F64: 41990008  bgt cr6, 0x822b9f6c
	if ctx.cr[6].gt {
	pc = 0x822B9F6C; continue 'dispatch;
	}
	// 822B9F68: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	pc = 0x822B9F6C; continue 'dispatch;
            }
            0x822B9F6C => {
    //   block [0x822B9F6C..0x822B9FC8)
	// 822B9F6C: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822B9F70: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 822B9F74: 41980054  blt cr6, 0x822b9fc8
	if ctx.cr[6].lt {
	pc = 0x822B9FC8; continue 'dispatch;
	}
	// 822B9F78: 7C8B1670  srawi r11, r4, 2
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 2) as i64;
	// 822B9F7C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822B9F80: 7D2B0194  addze r9, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[9].s64 = tmp.s64;
	// 822B9F84: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 822B9F88: E96A1758  ld r11, 0x1758(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(5976 as u32) ) };
	// 822B9F8C: 7FC74436  srd r7, r30, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[30].u64) >> ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 822B9F90: 7CE55838  and r5, r7, r11
	ctx.r[5].u64 = ctx.r[7].u64 & ctx.r[11].u64;
	// 822B9F94: 2B250000  cmpldi cr6, r5, 0
	ctx.cr[6].compare_u64(ctx.r[5].u64, 0, &mut ctx.xer);
	// 822B9F98: 419A0030  beq cr6, 0x822b9fc8
	if ctx.cr[6].eq {
	pc = 0x822B9FC8; continue 'dispatch;
	}
	// 822B9F9C: 7D662214  add r11, r6, r4
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[4].u64;
	// 822B9FA0: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 822B9FA4: 548AF0BE  srwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822B9FA8: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 822B9FAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822B9FB0: 5528F0BE  srwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822B9FB4: 7CEA4050  subf r7, r10, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 822B9FB8: 78EB0020  clrldi r11, r7, 0x20
	ctx.r[11].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 822B9FBC: 7FC95E34  srad r9, r30, r11
	tmp.u64 = (ctx.r[11].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[30].s64 < 0) && ((ctx.r[30].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[9].s64 = ctx.r[30].s64 >> tmp.u64;
	// 822B9FC0: 7D275436  srd r7, r9, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[9].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 822B9FC4: 4BF5AE6D  bl 0x82214e30
	ctx.lr = 0x822B9FC8;
	sub_82214E30(ctx, base);
	pc = 0x822B9FC8; continue 'dispatch;
            }
            0x822B9FC8 => {
    //   block [0x822B9FC8..0x822B9FE0)
	// 822B9FC8: FB3D0000  std r25, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[25].u64 ) };
	// 822B9FCC: FB1F0030  std r24, 0x30(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[24].u64 ) };
	// 822B9FD0: FAFF0060  std r23, 0x60(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[23].u64 ) };
	// 822B9FD4: FADF0070  std r22, 0x70(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[22].u64 ) };
	// 822B9FD8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822B9FDC: 489EF464  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822B9FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822B9FE0 size=208
    let mut pc: u32 = 0x822B9FE0;
    'dispatch: loop {
        match pc {
            0x822B9FE0 => {
    //   block [0x822B9FE0..0x822BA088)
	// 822B9FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822B9FE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822B9FE8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822B9FEC: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 822B9FF0: 546B083C  slwi r11, r3, 1
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822B9FF4: 392ADED4  addi r9, r10, -0x212c
	ctx.r[9].s64 = ctx.r[10].s64 + -8492;
	// 822B9FF8: 7D035A14  add r8, r3, r11
	ctx.r[8].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 822B9FFC: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822BA000: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BA004: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822BA008: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BA00C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BA010: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 822BA014: 4198008C  blt cr6, 0x822ba0a0
	if ctx.cr[6].lt {
	pc = 0x822BA0A0; continue 'dispatch;
	}
	// 822BA018: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 822BA01C: 5488063E  clrlwi r8, r4, 0x18
	ctx.r[8].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 822BA020: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 822BA024: 892A05A1  lbz r9, 0x5a1(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1441 as u32) ) } as u64;
	// 822BA028: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822BA02C: 419A005C  beq cr6, 0x822ba088
	if ctx.cr[6].eq {
	pc = 0x822BA088; continue 'dispatch;
	}
	// 822BA030: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 822BA034: 38EB0080  addi r7, r11, 0x80
	ctx.r[7].s64 = ctx.r[11].s64 + 128;
	// 822BA038: 394916B8  addi r10, r9, 0x16b8
	ctx.r[10].s64 = ctx.r[9].s64 + 5816;
	// 822BA03C: 54E9E8FA  rlwinm r9, r7, 0x1d, 3, 0x1d
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0x00000007u64;
	// 822BA040: 556606FE  clrlwi r6, r11, 0x1b
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822BA044: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822BA048: 550407FE  clrlwi r4, r8, 0x1f
	ctx.r[4].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 822BA04C: 7CA33030  slw r3, r5, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = ((ctx.r[5].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 822BA050: 7D09502E  lwzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822BA054: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 822BA058: 7C863030  slw r6, r4, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = ((ctx.r[4].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 822BA05C: 7D051878  andc r5, r8, r3
	ctx.r[5].u64 = ctx.r[8].u64 & !ctx.r[3].u64;
	// 822BA060: 81670DB4  lwz r11, 0xdb4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3508 as u32) ) } as u64;
	// 822BA064: 7CA43378  or r4, r5, r6
	ctx.r[4].u64 = ctx.r[5].u64 | ctx.r[6].u64;
	// 822BA068: 7C834278  xor r3, r4, r8
	ctx.r[3].u64 = ctx.r[4].u64 ^ ctx.r[8].u64;
	// 822BA06C: 7C89512E  stwx r4, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[4].u32) };
	// 822BA070: 7C6B5B78  or r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[11].u64;
	// 822BA074: 91670DB4  stw r11, 0xdb4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(3508 as u32), ctx.r[11].u32 ) };
	// 822BA078: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822BA07C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BA080: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BA084: 4E800020  blr
	return;
            }
            0x822BA088 => {
    //   block [0x822BA088..0x822BA0A0)
	// 822BA088: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 822BA08C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822BA090: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822BA094: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822BA098: 806A0364  lwz r3, 0x364(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 822BA09C: 4BFB4085  bl 0x8226e120
	ctx.lr = 0x822BA0A0;
	sub_8226E120(ctx, base);
	pc = 0x822BA0A0; continue 'dispatch;
            }
            0x822BA0A0 => {
    //   block [0x822BA0A0..0x822BA0B0)
	// 822BA0A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822BA0A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BA0A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BA0AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BA0B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822BA0B0 size=1320
    let mut pc: u32 = 0x822BA0B0;
    'dispatch: loop {
        match pc {
            0x822BA0B0 => {
    //   block [0x822BA0B0..0x822BA314)
	// 822BA0B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BA0B4: 489EF335  bl 0x82ca93e8
	ctx.lr = 0x822BA0B8;
	sub_82CA93D0(ctx, base);
	// 822BA0B8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BA0BC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822BA0C0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822BA0C4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BA0C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BA0CC: 419A0504  beq cr6, 0x822ba5d0
	if ctx.cr[6].eq {
	pc = 0x822BA5D0; continue 'dispatch;
	}
	// 822BA0D0: 836B0008  lwz r27, 8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BA0D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822BA0D8: 83DC0064  lwz r30, 0x64(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) } as u64;
	// 822BA0DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BA0E0: 817B006C  lwz r11, 0x6c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(108 as u32) ) } as u64;
	// 822BA0E4: 815B0068  lwz r10, 0x68(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(104 as u32) ) } as u64;
	// 822BA0E8: 831B0018  lwz r24, 0x18(r27)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 822BA0EC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822BA0F0: 833B0028  lwz r25, 0x28(r27)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 822BA0F4: 7D362670  srawi r22, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[22].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 822BA0F8: 56DF2036  slwi r31, r22, 4
	ctx.r[31].u32 = ctx.r[22].u32.wrapping_shl(4);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 822BA0FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822BA100: 480004D9  bl 0x822ba5d8
	ctx.lr = 0x822BA104;
	sub_822BA5D8(ctx, base);
	// 822BA104: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822BA108: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822BA10C: 83FC0044  lwz r31, 0x44(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 822BA110: 82FC0054  lwz r23, 0x54(r28)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) } as u64;
	// 822BA114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BA118: 480004C1  bl 0x822ba5d8
	ctx.lr = 0x822BA11C;
	sub_822BA5D8(ctx, base);
	// 822BA11C: 807B0088  lwz r3, 0x88(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(136 as u32) ) } as u64;
	// 822BA120: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822BA124: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822BA128: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 822BA12C: 409901E8  ble cr6, 0x822ba314
	if !ctx.cr[6].gt {
	pc = 0x822BA314; continue 'dispatch;
	}
	// 822BA130: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822BA134: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 822BA138: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 822BA13C: 390B90B0  addi r8, r11, -0x6f50
	ctx.r[8].s64 = ctx.r[11].s64 + -28496;
	// 822BA140: 38EA5070  addi r7, r10, 0x5070
	ctx.r[7].s64 = ctx.r[10].s64 + 20592;
	// 822BA144: 38C990F0  addi r6, r9, -0x6f10
	ctx.r[6].s64 = ctx.r[9].s64 + -28432;
	pc = 0x822BA314; continue 'dispatch;
            }
            0x822BA314 => {
    //   block [0x822BA314..0x822BA5D0)
	// 822BA314: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822BA318: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822BA31C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 822BA320: 390B9130  addi r8, r11, -0x6ed0
	ctx.r[8].s64 = ctx.r[11].s64 + -28368;
	// 822BA324: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822BA328: 2F160004  cmpwi cr6, r22, 4
	ctx.cr[6].compare_i32(ctx.r[22].s32, 4, &mut ctx.xer);
	// 822BA32C: C1AA9490  lfs f13, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822BA330: C0090C24  lfs f0, 0xc24(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x822BA5D0; continue 'dispatch;
            }
            0x822BA5D0 => {
    //   block [0x822BA5D0..0x822BA5D8)
	// 822BA5D0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 822BA5D4: 489EEE64  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BA5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822BA5D8 size=428
    let mut pc: u32 = 0x822BA5D8;
    'dispatch: loop {
        match pc {
            0x822BA5D8 => {
    //   block [0x822BA5D8..0x822BA604)
	// 822BA5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BA5DC: 489EEE31  bl 0x82ca940c
	ctx.lr = 0x822BA5E0;
	sub_82CA93D0(ctx, base);
	// 822BA5E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822BA5E4: 2B050010  cmplwi cr6, r5, 0x10
	ctx.cr[6].compare_u32(ctx.r[5].u32, 16 as u32, &mut ctx.xer);
	// 822BA5E8: 4098002C  bge cr6, 0x822ba614
	if !ctx.cr[6].lt {
	pc = 0x822BA614; continue 'dispatch;
	}
	// 822BA5EC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 822BA5F0: 419A0190  beq cr6, 0x822ba780
	if ctx.cr[6].eq {
	pc = 0x822BA780; continue 'dispatch;
	}
	// 822BA5F4: 7C8A0774  extsb r10, r4
	ctx.r[10].s64 = ctx.r[4].s8 as i64;
	// 822BA5F8: 28050000  cmplwi r5, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822BA5FC: 41820184  beq 0x822ba780
	if ctx.cr[0].eq {
	pc = 0x822BA780; continue 'dispatch;
	}
	// 822BA600: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	pc = 0x822BA604; continue 'dispatch;
            }
            0x822BA604 => {
    //   block [0x822BA604..0x822BA614)
	// 822BA604: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 822BA608: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822BA60C: 4200FFF8  bdnz 0x822ba604
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822BA604; continue 'dispatch;
	}
	// 822BA610: 48000170  b 0x822ba780
	pc = 0x822BA780; continue 'dispatch;
            }
            0x822BA614 => {
    //   block [0x822BA614..0x822BA650)
	// 822BA614: 7D4300D0  neg r10, r3
	ctx.r[10].s64 = -ctx.r[3].s64;
	// 822BA618: 1004030C  vspltisb v0, 4
	for i in 0..16 {
		ctx.v[0].u8[i] = 4 as u8;
	}
	// 822BA61C: 7DA0200C  lvsl v13, 0, r4
	tmp.u32 = ctx.r[4].u32;
	// ctx.v[13] = VectorShiftTableL[(tmp.u32 & 0xF)]
	// 822BA620: 7D492670  srawi r9, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 822BA624: 7C882670  srawi r8, r4, 4
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[4].s32 >> 4) as i64;
	// 822BA628: 554A073F  clrlwi. r10, r10, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822BA62C: 7D80400C  lvsl v12, 0, r8
	tmp.u32 = ctx.r[8].u32;
	// ctx.v[12] = VectorShiftTableL[(tmp.u32 & 0xF)]
	// 822BA630: 5529077E  clrlwi r9, r9, 0x1d
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 822BA634: 100C0104  vslb v0, v12, v0
	ctx.v[0].u8[0] = ctx.v[12].u8[0] << (ctx.v[0].u8[0] & 0x7);
	ctx.v[0].u8[1] = ctx.v[12].u8[1] << (ctx.v[0].u8[1] & 0x7);
	ctx.v[0].u8[2] = ctx.v[12].u8[2] << (ctx.v[0].u8[2] & 0x7);
	ctx.v[0].u8[3] = ctx.v[12].u8[3] << (ctx.v[0].u8[3] & 0x7);
	ctx.v[0].u8[4] = ctx.v[12].u8[4] << (ctx.v[0].u8[4] & 0x7);
	ctx.v[0].u8[5] = ctx.v[12].u8[5] << (ctx.v[0].u8[5] & 0x7);
	ctx.v[0].u8[6] = ctx.v[12].u8[6] << (ctx.v[0].u8[6] & 0x7);
	ctx.v[0].u8[7] = ctx.v[12].u8[7] << (ctx.v[0].u8[7] & 0x7);
	ctx.v[0].u8[8] = ctx.v[12].u8[8] << (ctx.v[0].u8[8] & 0x7);
	ctx.v[0].u8[9] = ctx.v[12].u8[9] << (ctx.v[0].u8[9] & 0x7);
	ctx.v[0].u8[10] = ctx.v[12].u8[10] << (ctx.v[0].u8[10] & 0x7);
	ctx.v[0].u8[11] = ctx.v[12].u8[11] << (ctx.v[0].u8[11] & 0x7);
	ctx.v[0].u8[12] = ctx.v[12].u8[12] << (ctx.v[0].u8[12] & 0x7);
	ctx.v[0].u8[13] = ctx.v[12].u8[13] << (ctx.v[0].u8[13] & 0x7);
	ctx.v[0].u8[14] = ctx.v[12].u8[14] << (ctx.v[0].u8[14] & 0x7);
	ctx.v[0].u8[15] = ctx.v[12].u8[15] << (ctx.v[0].u8[15] & 0x7);
	// 822BA638: 100D0484  vor v0, v13, v0
	for i in 0..16 {
		ctx.v[0].u8[i] = ctx.v[13].u8[i] | ctx.v[0].u8[i];
	}
	// 822BA63C: 1000020C  vspltb v0, v0, 0
	for i in 0..16 {
		ctx.v[0].u8[i] = ctx.v[0].u8[15];
	}
	// 822BA640: 41820010  beq 0x822ba650
	if ctx.cr[0].eq {
	pc = 0x822BA650; continue 'dispatch;
	}
	pc = 0x822BA650; continue 'dispatch;
            }
            0x822BA650 => {
    //   block [0x822BA650..0x822BA780)
	// 822BA650: 54AAE13E  srwi r10, r5, 4
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shr(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822BA654: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822BA658: 40980008  bge cr6, 0x822ba660
	if !ctx.cr[6].lt {
	pc = 0x822BA660; continue 'dispatch;
	}
	// 822BA65C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 822BA660: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 822BA664: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822BA668: 80CAFFCC  lwz r6, -0x34(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-52 as u32) ) } as u64;
	// 822BA66C: 419A0018  beq cr6, 0x822ba684
	if ctx.cr[6].eq {
	pc = 0x822BA684; continue 'dispatch;
	}
	// 822BA670: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x822BA780; continue 'dispatch;
            }
            0x822BA780 => {
    //   block [0x822BA780..0x822BA784)
	// 822BA780: 489EECDC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BA788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BA788 size=68
    let mut pc: u32 = 0x822BA788;
    'dispatch: loop {
        match pc {
            0x822BA788 => {
    //   block [0x822BA788..0x822BA7B8)
	// 822BA788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BA78C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BA790: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BA794: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BA798: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BA79C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822BA7A0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BA7A4: 4BFF8785  bl 0x822b2f28
	ctx.lr = 0x822BA7A8;
	sub_822B2F28(ctx, base);
	// 822BA7A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822BA7AC: 409A000C  bne cr6, 0x822ba7b8
	if !ctx.cr[6].eq {
	pc = 0x822BA7B8; continue 'dispatch;
	}
	// 822BA7B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BA7B4: 4BFF910D  bl 0x822b38c0
	ctx.lr = 0x822BA7B8;
	sub_822B38C0(ctx, base);
	pc = 0x822BA7B8; continue 'dispatch;
            }
            0x822BA7B8 => {
    //   block [0x822BA7B8..0x822BA7CC)
	// 822BA7B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BA7BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BA7C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BA7C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BA7C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BA7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822BA7D0 size=260
    let mut pc: u32 = 0x822BA7D0;
    'dispatch: loop {
        match pc {
            0x822BA7D0 => {
    //   block [0x822BA7D0..0x822BA840)
	// 822BA7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BA7D4: 489EEC35  bl 0x82ca9408
	ctx.lr = 0x822BA7D8;
	sub_82CA93D0(ctx, base);
	// 822BA7D8: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 822BA7DC: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 822BA7E0: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822BA7E4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BA7E8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 822BA7EC: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 822BA7F0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 822BA7F4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822BA7F8: 388A8E60  addi r4, r10, -0x71a0
	ctx.r[4].s64 = ctx.r[10].s64 + -29088;
	// 822BA7FC: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 822BA800: 4BFAD421  bl 0x82267c20
	ctx.lr = 0x822BA804;
	sub_82267C20(ctx, base);
	// 822BA804: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822BA808: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BA80C: 3BABD5C8  addi r29, r11, -0x2a38
	ctx.r[29].s64 = ctx.r[11].s64 + -10808;
	// 822BA810: 3FC08332  lis r30, -0x7cce
	ctx.r[30].s64 = -2093875200;
	// 822BA814: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822BA818: C3CBD5C8  lfs f30, -0x2a38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822BA81C: 419A0060  beq cr6, 0x822ba87c
	if ctx.cr[6].eq {
	pc = 0x822BA87C; continue 'dispatch;
	}
	// 822BA820: C3FE904C  lfs f31, -0x6fb4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-28596 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822BA824: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 822BA828: 419A0018  beq cr6, 0x822ba840
	if ctx.cr[6].eq {
	pc = 0x822BA840; continue 'dispatch;
	}
	// 822BA82C: 4BFA618D  bl 0x822609b8
	ctx.lr = 0x822BA830;
	sub_822609B8(ctx, base);
	// 822BA830: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 822BA834: C02B08D8  lfs f1, 0x8d8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2264 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822BA838: 48BC6A69  bl 0x82e812a0
	ctx.lr = 0x822BA83C;
	sub_82E812A0(ctx, base);
	// 822BA83C: C3FE904C  lfs f31, -0x6fb4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-28596 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x822BA840; continue 'dispatch;
            }
            0x822BA840 => {
    //   block [0x822BA840..0x822BA868)
	// 822BA840: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822BA844: 388B6CB8  addi r4, r11, 0x6cb8
	ctx.r[4].s64 = ctx.r[11].s64 + 27832;
	// 822BA848: 816B6CB8  lwz r11, 0x6cb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27832 as u32) ) } as u64;
	// 822BA84C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BA850: 419A0018  beq cr6, 0x822ba868
	if ctx.cr[6].eq {
	pc = 0x822BA868; continue 'dispatch;
	}
	// 822BA854: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 822BA858: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822BA85C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822BA860: 4BEBFAB1  bl 0x8217a310
	ctx.lr = 0x822BA864;
	sub_8217A310(ctx, base);
	// 822BA864: C3FE904C  lfs f31, -0x6fb4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-28596 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x822BA868; continue 'dispatch;
            }
            0x822BA868 => {
    //   block [0x822BA868..0x822BA87C)
	// 822BA868: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 822BA86C: 419A0010  beq cr6, 0x822ba87c
	if ctx.cr[6].eq {
	pc = 0x822BA87C; continue 'dispatch;
	}
	// 822BA870: 4BFA6149  bl 0x822609b8
	ctx.lr = 0x822BA874;
	sub_822609B8(ctx, base);
	// 822BA874: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822BA878: 48BC6A29  bl 0x82e812a0
	ctx.lr = 0x822BA87C;
	sub_82E812A0(ctx, base);
	pc = 0x822BA87C; continue 'dispatch;
            }
            0x822BA87C => {
    //   block [0x822BA87C..0x822BA8A8)
	// 822BA87C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822BA880: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 822BA884: 4801327D  bl 0x822cdb00
	ctx.lr = 0x822BA888;
	sub_822CDB00(ctx, base);
	// 822BA888: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822BA88C: 419A0034  beq cr6, 0x822ba8c0
	if ctx.cr[6].eq {
	pc = 0x822BA8C0; continue 'dispatch;
	}
	// 822BA890: C01E904C  lfs f0, -0x6fb4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-28596 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BA894: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 822BA898: 409A0010  bne cr6, 0x822ba8a8
	if !ctx.cr[6].eq {
	pc = 0x822BA8A8; continue 'dispatch;
	}
	// 822BA89C: 4BFA611D  bl 0x822609b8
	ctx.lr = 0x822BA8A0;
	sub_822609B8(ctx, base);
	// 822BA8A0: 486B78C9  bl 0x82972168
	ctx.lr = 0x822BA8A4;
	sub_82972168(ctx, base);
	// 822BA8A4: D03E904C  stfs f1, -0x6fb4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-28596 as u32), tmp.u32 ) };
	pc = 0x822BA8A8; continue 'dispatch;
            }
            0x822BA8A8 => {
    //   block [0x822BA8A8..0x822BA8C0)
	// 822BA8A8: 4BFA6111  bl 0x822609b8
	ctx.lr = 0x822BA8AC;
	sub_822609B8(ctx, base);
	// 822BA8AC: C03DBCDC  lfs f1, -0x4324(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17188 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822BA8B0: 48BC69F1  bl 0x82e812a0
	ctx.lr = 0x822BA8B4;
	sub_82E812A0(ctx, base);
	// 822BA8B4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822BA8B8: 806B6CB4  lwz r3, 0x6cb4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27828 as u32) ) } as u64;
	// 822BA8BC: 4800EACD  bl 0x822c9388
	ctx.lr = 0x822BA8C0;
	sub_822C9388(ctx, base);
	pc = 0x822BA8C0; continue 'dispatch;
            }
            0x822BA8C0 => {
    //   block [0x822BA8C0..0x822BA8D4)
	// 822BA8C0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822BA8C4: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822BA8C8: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822BA8CC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822BA8D0: 489EEB88  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BA8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822BA8D8 size=8588
    let mut pc: u32 = 0x822BA8D8;
    'dispatch: loop {
        match pc {
            0x822BA8D8 => {
    //   block [0x822BA8D8..0x822BCA64)
	// 822BA8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BA8DC: 489EEAF5  bl 0x82ca93d0
	ctx.lr = 0x822BA8E0;
	sub_82CA93D0(ctx, base);
	// 822BA8E0: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 822BA8E4: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BCA68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822BCA68 size=1284
    let mut pc: u32 = 0x822BCA68;
    'dispatch: loop {
        match pc {
            0x822BCA68 => {
    //   block [0x822BCA68..0x822BCACC)
	// 822BCA68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BCA6C: 489EC995  bl 0x82ca9400
	ctx.lr = 0x822BCA70;
	sub_82CA93D0(ctx, base);
	// 822BCA70: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 822BCA74: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 822BCA78: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BCA7C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822BCA80: 80DA0004  lwz r6, 4(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BCA84: 8366007C  lwz r27, 0x7c(r6)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(124 as u32) ) } as u64;
	// 822BCA88: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822BCA8C: 419A04D0  beq cr6, 0x822bcf5c
	if ctx.cr[6].eq {
	pc = 0x822BCF5C; continue 'dispatch;
	}
	// 822BCA90: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 822BCA94: 556AF7FE  rlwinm r10, r11, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 822BCA98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BCA9C: 419A00F8  beq cr6, 0x822bcb94
	if ctx.cr[6].eq {
	pc = 0x822BCB94; continue 'dispatch;
	}
	// 822BCAA0: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 822BCAA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BCAA8: 419A0024  beq cr6, 0x822bcacc
	if ctx.cr[6].eq {
	pc = 0x822BCACC; continue 'dispatch;
	}
	// 822BCAAC: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 822BCAB0: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 822BCAB4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822BCAB8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822BCABC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BCAC0: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 822BCAC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BCAC8: 480000D0  b 0x822bcb98
	pc = 0x822BCB98; continue 'dispatch;
            }
            0x822BCACC => {
    //   block [0x822BCACC..0x822BCAEC)
	// 822BCACC: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 822BCAD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822BCAD4: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 822BCAD8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822BCADC: 7D2A2850  subf r9, r10, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 822BCAE0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822BCAE4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BCAE8: 40810054  ble 0x822bcb3c
	if !ctx.cr[0].gt {
	pc = 0x822BCB3C; continue 'dispatch;
	}
	pc = 0x822BCAEC; continue 'dispatch;
            }
            0x822BCAEC => {
    //   block [0x822BCAEC..0x822BCB0C)
	// 822BCAEC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822BCAF0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822BCAF4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822BCAF8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BCAFC: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 822BCB00: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822BCB04: 41980008  blt cr6, 0x822bcb0c
	if ctx.cr[6].lt {
	pc = 0x822BCB0C; continue 'dispatch;
	}
	// 822BCB08: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822BCB0C; continue 'dispatch;
            }
            0x822BCB0C => {
    //   block [0x822BCB0C..0x822BCB28)
	// 822BCB0C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822BCB10: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822BCB14: 419A0014  beq cr6, 0x822bcb28
	if ctx.cr[6].eq {
	pc = 0x822BCB28; continue 'dispatch;
	}
	// 822BCB18: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822BCB1C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822BCB20: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822BCB24: 4800000C  b 0x822bcb30
	pc = 0x822BCB30; continue 'dispatch;
            }
            0x822BCB28 => {
    //   block [0x822BCB28..0x822BCB30)
	// 822BCB28: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822BCB2C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822BCB30; continue 'dispatch;
            }
            0x822BCB30 => {
    //   block [0x822BCB30..0x822BCB3C)
	// 822BCB30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BCB34: 4199FFB8  bgt cr6, 0x822bcaec
	if ctx.cr[6].gt {
	pc = 0x822BCAEC; continue 'dispatch;
	}
	// 822BCB38: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822BCB3C; continue 'dispatch;
            }
            0x822BCB3C => {
    //   block [0x822BCB3C..0x822BCB58)
	// 822BCB3C: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 822BCB40: 419A0040  beq cr6, 0x822bcb80
	if ctx.cr[6].eq {
	pc = 0x822BCB80; continue 'dispatch;
	}
	// 822BCB44: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BCB48: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 822BCB4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BCB50: 41990008  bgt cr6, 0x822bcb58
	if ctx.cr[6].gt {
	pc = 0x822BCB58; continue 'dispatch;
	}
	// 822BCB54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BCB58; continue 'dispatch;
            }
            0x822BCB58 => {
    //   block [0x822BCB58..0x822BCB80)
	// 822BCB58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BCB5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BCB60: 409A0020  bne cr6, 0x822bcb80
	if !ctx.cr[6].eq {
	pc = 0x822BCB80; continue 'dispatch;
	}
	// 822BCB64: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822BCB68: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822BCB6C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822BCB70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BCB74: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 822BCB78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BCB7C: 4800001C  b 0x822bcb98
	pc = 0x822BCB98; continue 'dispatch;
            }
            0x822BCB80 => {
    //   block [0x822BCB80..0x822BCB94)
	// 822BCB80: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 822BCB84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BCB88: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 822BCB8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BCB90: 48000008  b 0x822bcb98
	pc = 0x822BCB98; continue 'dispatch;
            }
            0x822BCB94 => {
    //   block [0x822BCB94..0x822BCB98)
	// 822BCB94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BCB98; continue 'dispatch;
            }
            0x822BCB98 => {
    //   block [0x822BCB98..0x822BCBEC)
	// 822BCB98: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BCB9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BCBA0: 419A03BC  beq cr6, 0x822bcf5c
	if ctx.cr[6].eq {
	pc = 0x822BCF5C; continue 'dispatch;
	}
	// 822BCBA4: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 822BCBA8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822BCBAC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822BCBB0: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 822BCBB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822BCBB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BCBBC: 419A00F8  beq cr6, 0x822bccb4
	if ctx.cr[6].eq {
	pc = 0x822BCCB4; continue 'dispatch;
	}
	// 822BCBC0: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 822BCBC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BCBC8: 419A0024  beq cr6, 0x822bcbec
	if ctx.cr[6].eq {
	pc = 0x822BCBEC; continue 'dispatch;
	}
	// 822BCBCC: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 822BCBD0: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 822BCBD4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822BCBD8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822BCBDC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BCBE0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822BCBE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BCBE8: 480000D0  b 0x822bccb8
	pc = 0x822BCCB8; continue 'dispatch;
            }
            0x822BCBEC => {
    //   block [0x822BCBEC..0x822BCC0C)
	// 822BCBEC: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 822BCBF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822BCBF4: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 822BCBF8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822BCBFC: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822BCC00: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822BCC04: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BCC08: 40810054  ble 0x822bcc5c
	if !ctx.cr[0].gt {
	pc = 0x822BCC5C; continue 'dispatch;
	}
	pc = 0x822BCC0C; continue 'dispatch;
            }
            0x822BCC0C => {
    //   block [0x822BCC0C..0x822BCC2C)
	// 822BCC0C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822BCC10: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822BCC14: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822BCC18: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BCC1C: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 822BCC20: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822BCC24: 41980008  blt cr6, 0x822bcc2c
	if ctx.cr[6].lt {
	pc = 0x822BCC2C; continue 'dispatch;
	}
	// 822BCC28: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822BCC2C; continue 'dispatch;
            }
            0x822BCC2C => {
    //   block [0x822BCC2C..0x822BCC48)
	// 822BCC2C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822BCC30: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822BCC34: 419A0014  beq cr6, 0x822bcc48
	if ctx.cr[6].eq {
	pc = 0x822BCC48; continue 'dispatch;
	}
	// 822BCC38: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822BCC3C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822BCC40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822BCC44: 4800000C  b 0x822bcc50
	pc = 0x822BCC50; continue 'dispatch;
            }
            0x822BCC48 => {
    //   block [0x822BCC48..0x822BCC50)
	// 822BCC48: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822BCC4C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822BCC50; continue 'dispatch;
            }
            0x822BCC50 => {
    //   block [0x822BCC50..0x822BCC5C)
	// 822BCC50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BCC54: 4199FFB8  bgt cr6, 0x822bcc0c
	if ctx.cr[6].gt {
	pc = 0x822BCC0C; continue 'dispatch;
	}
	// 822BCC58: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822BCC5C; continue 'dispatch;
            }
            0x822BCC5C => {
    //   block [0x822BCC5C..0x822BCC78)
	// 822BCC5C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822BCC60: 419A0040  beq cr6, 0x822bcca0
	if ctx.cr[6].eq {
	pc = 0x822BCCA0; continue 'dispatch;
	}
	// 822BCC64: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BCC68: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 822BCC6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BCC70: 41990008  bgt cr6, 0x822bcc78
	if ctx.cr[6].gt {
	pc = 0x822BCC78; continue 'dispatch;
	}
	// 822BCC74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BCC78; continue 'dispatch;
            }
            0x822BCC78 => {
    //   block [0x822BCC78..0x822BCCA0)
	// 822BCC78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BCC7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BCC80: 409A0020  bne cr6, 0x822bcca0
	if !ctx.cr[6].eq {
	pc = 0x822BCCA0; continue 'dispatch;
	}
	// 822BCC84: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822BCC88: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822BCC8C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822BCC90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BCC94: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822BCC98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BCC9C: 4800001C  b 0x822bccb8
	pc = 0x822BCCB8; continue 'dispatch;
            }
            0x822BCCA0 => {
    //   block [0x822BCCA0..0x822BCCB4)
	// 822BCCA0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822BCCA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BCCA8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822BCCAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BCCB0: 48000008  b 0x822bccb8
	pc = 0x822BCCB8; continue 'dispatch;
            }
            0x822BCCB4 => {
    //   block [0x822BCCB4..0x822BCCB8)
	// 822BCCB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BCCB8; continue 'dispatch;
            }
            0x822BCCB8 => {
    //   block [0x822BCCB8..0x822BCD00)
	// 822BCCB8: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BCCBC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822BCCC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BCCC4: 3BCBBF84  addi r30, r11, -0x407c
	ctx.r[30].s64 = ctx.r[11].s64 + -16508;
	// 822BCCC8: 419A0038  beq cr6, 0x822bcd00
	if ctx.cr[6].eq {
	pc = 0x822BCD00; continue 'dispatch;
	}
	// 822BCCCC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822BCCD0: C03F0028  lfs f1, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822BCCD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BCCD8: 4BF57611  bl 0x822142e8
	ctx.lr = 0x822BCCDC;
	sub_822142E8(ctx, base);
	// 822BCCDC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822BCCE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BCCE4: 419A001C  beq cr6, 0x822bcd00
	if ctx.cr[6].eq {
	pc = 0x822BCD00; continue 'dispatch;
	}
	// 822BCCE8: C1BF0068  lfs f13, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822BCCEC: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 822BCCF0: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BCCF4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822BCCF8: 40980008  bge cr6, 0x822bcd00
	if !ctx.cr[6].lt {
	pc = 0x822BCD00; continue 'dispatch;
	}
	// 822BCCFC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x822BCD00; continue 'dispatch;
            }
            0x822BCD00 => {
    //   block [0x822BCD00..0x822BCD38)
	// 822BCD00: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822BCD04: 809A0004  lwz r4, 4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BCD08: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822BCD0C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822BCD10: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 822BCD14: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BCD18: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BCD1C: 4BF75A5D  bl 0x82232778
	ctx.lr = 0x822BCD20;
	sub_82232778(ctx, base);
	// 822BCD20: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822BCD24: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822BCD28: 409A0010  bne cr6, 0x822bcd38
	if !ctx.cr[6].eq {
	pc = 0x822BCD38; continue 'dispatch;
	}
	// 822BCD2C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BCD30: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822BCD34: 5543FFFE  rlwinm r3, r10, 0x1f, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	pc = 0x822BCD38; continue 'dispatch;
            }
            0x822BCD38 => {
    //   block [0x822BCD38..0x822BCD4C)
	// 822BCD38: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822BCD3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BCD40: 419A000C  beq cr6, 0x822bcd4c
	if ctx.cr[6].eq {
	pc = 0x822BCD4C; continue 'dispatch;
	}
	// 822BCD44: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 822BCD48: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x822BCD4C; continue 'dispatch;
            }
            0x822BCD4C => {
    //   block [0x822BCD4C..0x822BCD60)
	// 822BCD4C: 3940001E  li r10, 0x1e
	ctx.r[10].s64 = 30;
	// 822BCD50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BCD54: 419A000C  beq cr6, 0x822bcd60
	if ctx.cr[6].eq {
	pc = 0x822BCD60; continue 'dispatch;
	}
	// 822BCD58: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 822BCD5C: 48000024  b 0x822bcd80
	pc = 0x822BCD80; continue 'dispatch;
            }
            0x822BCD60 => {
    //   block [0x822BCD60..0x822BCD80)
	// 822BCD60: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 822BCD64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BCD68: 419A0018  beq cr6, 0x822bcd80
	if ctx.cr[6].eq {
	pc = 0x822BCD80; continue 'dispatch;
	}
	// 822BCD6C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 822BCD70: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 822BCD74: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 822BCD78: 552B07FA  rlwinm r11, r9, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 822BCD7C: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	pc = 0x822BCD80; continue 'dispatch;
            }
            0x822BCD80 => {
    //   block [0x822BCD80..0x822BCDB4)
	// 822BCD80: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BCD84: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822BCD88: 55280FFE  srwi r8, r9, 0x1f
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(31);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822BCD8C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822BCD90: 409A0024  bne cr6, 0x822bcdb4
	if !ctx.cr[6].eq {
	pc = 0x822BCDB4; continue 'dispatch;
	}
	// 822BCD94: 812B003C  lwz r9, 0x3c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 822BCD98: 5528B7FE  rlwinm r8, r9, 0x16, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000003FFu64;
	// 822BCD9C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822BCDA0: 409A0014  bne cr6, 0x822bcdb4
	if !ctx.cr[6].eq {
	pc = 0x822BCDB4; continue 'dispatch;
	}
	// 822BCDA4: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 822BCDA8: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 822BCDAC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822BCDB0: 419A0008  beq cr6, 0x822bcdb8
	if ctx.cr[6].eq {
	pc = 0x822BCDB8; continue 'dispatch;
	}
	pc = 0x822BCDB4; continue 'dispatch;
            }
            0x822BCDB4 => {
    //   block [0x822BCDB4..0x822BCDB8)
	// 822BCDB4: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	pc = 0x822BCDB8; continue 'dispatch;
            }
            0x822BCDB8 => {
    //   block [0x822BCDB8..0x822BCE00)
	// 822BCDB8: 817A00FC  lwz r11, 0xfc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(252 as u32) ) } as u64;
	// 822BCDBC: 813A00F8  lwz r9, 0xf8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(248 as u32) ) } as u64;
	// 822BCDC0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822BCDC4: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 822BCDC8: 41980194  blt cr6, 0x822bcf5c
	if ctx.cr[6].lt {
	pc = 0x822BCF5C; continue 'dispatch;
	}
	// 822BCDCC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822BCDD0: C3DEF7AC  lfs f30, -0x854(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-2132 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822BCDD4: 57AA063E  clrlwi r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 822BCDD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BCDDC: C3EB0A68  lfs f31, 0xa68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2664 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822BCDE0: 419A002C  beq cr6, 0x822bce0c
	if ctx.cr[6].eq {
	pc = 0x822BCE0C; continue 'dispatch;
	}
	// 822BCDE4: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 822BCDE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BCDEC: 419A0014  beq cr6, 0x822bce00
	if ctx.cr[6].eq {
	pc = 0x822BCE00; continue 'dispatch;
	}
	// 822BCDF0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822BCDF4: C3DED354  lfs f30, -0x2cac(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-11436 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822BCDF8: C3EB0A70  lfs f31, 0xa70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2672 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822BCDFC: 48000010  b 0x822bce0c
	pc = 0x822BCE0C; continue 'dispatch;
            }
            0x822BCE00 => {
    //   block [0x822BCE00..0x822BCE0C)
	// 822BCE00: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822BCE04: C3DEF6CC  lfs f30, -0x934(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-2356 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822BCE08: C3EB0A6C  lfs f31, 0xa6c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2668 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x822BCE0C; continue 'dispatch;
            }
            0x822BCE0C => {
    //   block [0x822BCE0C..0x822BCF5C)
	// 822BCE0C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BCE10: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822BCE14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BCE18: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 822BCE1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822BCE20: 4E800421  bctrl
	ctx.lr = 0x822BCE24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BCE24: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 822BCE28: 3BFA0030  addi r31, r26, 0x30
	ctx.r[31].s64 = ctx.r[26].s64 + 48;
	// 822BCE2C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822BCE30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822BCE34: E9090000  ld r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 822BCE38: F91A0030  std r8, 0x30(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(48 as u32), ctx.r[8].u64 ) };
	// 822BCE3C: E8E90008  ld r7, 8(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 822BCE40: F8FA0038  std r7, 0x38(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[7].u64 ) };
	// 822BCE44: 80DB0000  lwz r6, 0(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BCE48: 80A60040  lwz r5, 0x40(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(64 as u32) ) } as u64;
	// 822BCE4C: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 822BCE50: 4E800421  bctrl
	ctx.lr = 0x822BCE54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BCE54: E95A0038  ld r10, 0x38(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(56 as u32) ) };
	// 822BCE58: E89A0030  ld r4, 0x30(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) };
	// 822BCE5C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822BCE60: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 822BCE64: E91A0050  ld r8, 0x50(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(80 as u32) ) };
	// 822BCE68: E8BA0058  ld r5, 0x58(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(88 as u32) ) };
	// 822BCE6C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 822BCE70: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
            }
            0x822BCF5C => {
    //   block [0x822BCF5C..0x822BCF6C)
	// 822BCF5C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822BCF60: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 822BCF64: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822BCF68: 489EC4E8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BCF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BCF70 size=320
    let mut pc: u32 = 0x822BCF70;
    'dispatch: loop {
        match pc {
            0x822BCF70 => {
    //   block [0x822BCF70..0x822BD0B0)
	// 822BCF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BCF74: 489EC48D  bl 0x82ca9400
	ctx.lr = 0x822BCF78;
	sub_82CA93D0(ctx, base);
	// 822BCF78: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BCF7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BCF80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822BCF84: 4BEB47E5  bl 0x82171768
	ctx.lr = 0x822BCF88;
	sub_82171768(ctx, base);
	// 822BCF88: 397F0040  addi r11, r31, 0x40
	ctx.r[11].s64 = ctx.r[31].s64 + 64;
	// 822BCF8C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822BCF90: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 822BCF94: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 822BCF98: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 822BCF9C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BD0B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822BD0B0 size=224
    let mut pc: u32 = 0x822BD0B0;
    'dispatch: loop {
        match pc {
            0x822BD0B0 => {
    //   block [0x822BD0B0..0x822BD17C)
	// 822BD0B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BD0B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BD0B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BD0BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BD0C0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822BD0C4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822BD0C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BD0CC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822BD0D0: C1AA9490  lfs f13, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822BD0D4: C19F04D4  lfs f12, 0x4d4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822BD0D8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822BD0DC: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 822BD0E0: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BD0E4: 80C70014  lwz r6, 0x14(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 822BD0E8: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BD0EC: C1660004  lfs f11, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822BD0F0: 7CA407B4  extsw r4, r5
	ctx.r[4].s64 = ctx.r[5].s32 as i64;
	// 822BD0F4: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 822BD0F8: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822BD0FC: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 822BD100: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 822BD104: ECE8582A  fadds f7, f8, f11
	ctx.f[7].f64 = ((ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64;
	// 822BD108: EC076828  fsubs f0, f7, f13
	ctx.f[0].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 822BD10C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 822BD110: 4198006C  blt cr6, 0x822bd17c
	if ctx.cr[6].lt {
	pc = 0x822BD17C; continue 'dispatch;
	}
	// 822BD114: C19F04D0  lfs f12, 0x4d0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1232 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822BD118: ED60682A  fadds f11, f0, f13
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 822BD11C: D17F04D4  stfs f11, 0x4d4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1236 as u32), tmp.u32 ) };
	// 822BD120: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 822BD124: 41980058  blt cr6, 0x822bd17c
	if ctx.cr[6].lt {
	pc = 0x822BD17C; continue 'dispatch;
	}
	// 822BD128: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822BD12C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 822BD130: 388B1440  addi r4, r11, 0x1440
	ctx.r[4].s64 = ctx.r[11].s64 + 5184;
	// 822BD134: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BD138: 4BF6FD99  bl 0x8222ced0
	ctx.lr = 0x822BD13C;
	sub_8222CED0(ctx, base);
	// 822BD13C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822BD140: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822BD144: 4BEDF4A5  bl 0x8219c5e8
	ctx.lr = 0x822BD148;
	sub_8219C5E8(ctx, base);
	// 822BD148: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BD14C: 4BF57C8D  bl 0x82214dd8
	ctx.lr = 0x822BD150;
	sub_82214DD8(ctx, base);
	// 822BD150: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822BD154: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BD158: 419A0024  beq cr6, 0x822bd17c
	if ctx.cr[6].eq {
	pc = 0x822BD17C; continue 'dispatch;
	}
	// 822BD15C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 822BD160: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822BD164: 38EBD338  addi r7, r11, -0x2cc8
	ctx.r[7].s64 = ctx.r[11].s64 + -11464;
	// 822BD168: 4BEF5391  bl 0x821b24f8
	ctx.lr = 0x822BD16C;
	sub_821B24F8(ctx, base);
	// 822BD16C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 822BD170: 4BED9A11  bl 0x82196b80
	ctx.lr = 0x822BD174;
	sub_82196B80(ctx, base);
	// 822BD174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BD178: 48219A69  bl 0x824d6be0
	ctx.lr = 0x822BD17C;
	sub_824D6BE0(ctx, base);
	pc = 0x822BD17C; continue 'dispatch;
            }
            0x822BD17C => {
    //   block [0x822BD17C..0x822BD190)
	// 822BD17C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BD180: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BD184: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BD188: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BD18C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BD190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BD190 size=144
    let mut pc: u32 = 0x822BD190;
    'dispatch: loop {
        match pc {
            0x822BD190 => {
    //   block [0x822BD190..0x822BD208)
	// 822BD190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BD194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BD198: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822BD19C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BD1A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BD1A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822BD1A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BD1AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BD1B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BD1B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BD1B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822BD1BC: 4E800421  bctrl
	ctx.lr = 0x822BD1C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BD1C0: 2F03001D  cmpwi cr6, r3, 0x1d
	ctx.cr[6].compare_i32(ctx.r[3].s32, 29, &mut ctx.xer);
	// 822BD1C4: 409A0044  bne cr6, 0x822bd208
	if !ctx.cr[6].eq {
	pc = 0x822BD208; continue 'dispatch;
	}
	// 822BD1C8: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 822BD1CC: 39200060  li r9, 0x60
	ctx.r[9].s64 = 96;
	// 822BD1D0: 395E0020  addi r10, r30, 0x20
	ctx.r[10].s64 = ctx.r[30].s64 + 32;
	// 822BD1D4: 39000070  li r8, 0x70
	ctx.r[8].s64 = 112;
	// 822BD1D8: 38E000A0  li r7, 0xa0
	ctx.r[7].s64 = 160;
            }
            0x822BD208 => {
    //   block [0x822BD208..0x822BD220)
	// 822BD208: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BD20C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BD210: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BD214: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822BD218: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BD21C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BD220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822BD220 size=432
    let mut pc: u32 = 0x822BD220;
    'dispatch: loop {
        match pc {
            0x822BD220 => {
    //   block [0x822BD220..0x822BD278)
	// 822BD220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BD224: 489EC1E9  bl 0x82ca940c
	ctx.lr = 0x822BD228;
	sub_82CA93D0(ctx, base);
	// 822BD228: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 822BD22C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822BD230: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BD234: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 822BD238: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822BD23C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BD240: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822BD244: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822BD248: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822BD24C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BD250: 83C90000  lwz r30, 0(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BD254: 387E0068  addi r3, r30, 0x68
	ctx.r[3].s64 = ctx.r[30].s64 + 104;
	// 822BD258: 817E006C  lwz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 822BD25C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD260: 419A001C  beq cr6, 0x822bd27c
	if ctx.cr[6].eq {
	pc = 0x822BD27C; continue 'dispatch;
	}
	// 822BD264: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BD268: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BD26C: 419A000C  beq cr6, 0x822bd278
	if ctx.cr[6].eq {
	pc = 0x822BD278; continue 'dispatch;
	}
	// 822BD270: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 822BD274: 4800000C  b 0x822bd280
	pc = 0x822BD280; continue 'dispatch;
            }
            0x822BD278 => {
    //   block [0x822BD278..0x822BD27C)
	// 822BD278: 4BED6BC1  bl 0x82193e38
	ctx.lr = 0x822BD27C;
	sub_82193E38(ctx, base);
	pc = 0x822BD27C; continue 'dispatch;
            }
            0x822BD27C => {
    //   block [0x822BD27C..0x822BD280)
	// 822BD27C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x822BD280; continue 'dispatch;
            }
            0x822BD280 => {
    //   block [0x822BD280..0x822BD2B8)
	// 822BD280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BD284: 4BECEEB5  bl 0x8218c138
	ctx.lr = 0x822BD288;
	sub_8218C138(ctx, base);
	// 822BD288: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822BD28C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD290: 409A0028  bne cr6, 0x822bd2b8
	if !ctx.cr[6].eq {
	pc = 0x822BD2B8; continue 'dispatch;
	}
	// 822BD294: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BD298: 486287E1  bl 0x828e5a78
	ctx.lr = 0x822BD29C;
	sub_828E5A78(ctx, base);
	// 822BD29C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822BD2A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BD2A4: 4BECEE95  bl 0x8218c138
	ctx.lr = 0x822BD2A8;
	sub_8218C138(ctx, base);
	// 822BD2A8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822BD2AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822BD2B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD2B4: 419A0008  beq cr6, 0x822bd2bc
	if ctx.cr[6].eq {
	pc = 0x822BD2BC; continue 'dispatch;
	}
	pc = 0x822BD2B8; continue 'dispatch;
            }
            0x822BD2B8 => {
    //   block [0x822BD2B8..0x822BD2BC)
	// 822BD2B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	pc = 0x822BD2BC; continue 'dispatch;
            }
            0x822BD2BC => {
    //   block [0x822BD2BC..0x822BD2F4)
	// 822BD2BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BD2C0: 480130B9  bl 0x822d0378
	ctx.lr = 0x822BD2C4;
	sub_822D0378(ctx, base);
	// 822BD2C4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822BD2C8: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822BD2CC: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD2D0: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD2D4: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 822BD2D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD2DC: 419A0018  beq cr6, 0x822bd2f4
	if ctx.cr[6].eq {
	pc = 0x822BD2F4; continue 'dispatch;
	}
	// 822BD2E0: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD2E4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822BD2E8: 7D2A1670  srawi r10, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 822BD2EC: 2B0A0007  cmplwi cr6, r10, 7
	ctx.cr[6].compare_u32(ctx.r[10].u32, 7 as u32, &mut ctx.xer);
	// 822BD2F0: 41990008  bgt cr6, 0x822bd2f8
	if ctx.cr[6].gt {
	pc = 0x822BD2F8; continue 'dispatch;
	}
	pc = 0x822BD2F4; continue 'dispatch;
            }
            0x822BD2F4 => {
    //   block [0x822BD2F4..0x822BD2F8)
	// 822BD2F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822BD2F8; continue 'dispatch;
            }
            0x822BD2F8 => {
    //   block [0x822BD2F8..0x822BD358)
	// 822BD2F8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822BD2FC: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822BD300: 808A7314  lwz r4, 0x7314(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(29460 as u32) ) } as u64;
	// 822BD304: 480000CD  bl 0x822bd3d0
	ctx.lr = 0x822BD308;
	sub_822BD3D0(ctx, base);
	// 822BD308: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822BD30C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822BD310: 419A0048  beq cr6, 0x822bd358
	if ctx.cr[6].eq {
	pc = 0x822BD358; continue 'dispatch;
	}
	// 822BD314: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BD318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BD31C: EFDF0028  fsubs f30, f31, f0
	ctx.f[30].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 822BD320: 480501D1  bl 0x8230d4f0
	ctx.lr = 0x822BD324;
	sub_8230D4F0(ctx, base);
	// 822BD324: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822BD328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BD32C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822BD330: 480102E9  bl 0x822cd618
	ctx.lr = 0x822BD334;
	sub_822CD618(ctx, base);
	// 822BD334: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822BD338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BD33C: 4801162D  bl 0x822ce968
	ctx.lr = 0x822BD340;
	sub_822CE968(ctx, base);
	// 822BD340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BD344: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822BD348: 4BEBB489  bl 0x821787d0
	ctx.lr = 0x822BD34C;
	sub_821787D0(ctx, base);
	// 822BD34C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BD350: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822BD354: 48011445  bl 0x822ce798
	ctx.lr = 0x822BD358;
	sub_822CE798(ctx, base);
	pc = 0x822BD358; continue 'dispatch;
            }
            0x822BD358 => {
    //   block [0x822BD358..0x822BD390)
	// 822BD358: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 822BD35C: D3FF0024  stfs f31, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822BD360: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BD364: 409A0050  bne cr6, 0x822bd3b4
	if !ctx.cr[6].eq {
	pc = 0x822BD3B4; continue 'dispatch;
	}
	// 822BD368: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822BD36C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822BD370: 806B008C  lwz r3, 0x8c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822BD374: 89430034  lbz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 822BD378: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BD37C: 419A0014  beq cr6, 0x822bd390
	if ctx.cr[6].eq {
	pc = 0x822BD390; continue 'dispatch;
	}
	// 822BD380: 89630036  lbz r11, 0x36(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(54 as u32) ) } as u64;
	// 822BD384: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD388: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BD38C: 409A0008  bne cr6, 0x822bd394
	if !ctx.cr[6].eq {
	pc = 0x822BD394; continue 'dispatch;
	}
	pc = 0x822BD390; continue 'dispatch;
            }
            0x822BD390 => {
    //   block [0x822BD390..0x822BD394)
	// 822BD390: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BD394; continue 'dispatch;
            }
            0x822BD394 => {
    //   block [0x822BD394..0x822BD3B4)
	// 822BD394: 5564063E  clrlwi r4, r11, 0x18
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BD398: 480812D1  bl 0x8233e668
	ctx.lr = 0x822BD39C;
	sub_8233E668(ctx, base);
	// 822BD39C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822BD3A0: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 822BD3A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822BD3A8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822BD3AC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 822BD3B0: 489EC0AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822BD3B4 => {
    //   block [0x822BD3B4..0x822BD3C0)
	// 822BD3B4: 4099000C  ble cr6, 0x822bd3c0
	if !ctx.cr[6].gt {
	pc = 0x822BD3C0; continue 'dispatch;
	}
	// 822BD3B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822BD3BC: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	pc = 0x822BD3C0; continue 'dispatch;
            }
            0x822BD3C0 => {
    //   block [0x822BD3C0..0x822BD3D0)
	// 822BD3C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822BD3C4: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822BD3C8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 822BD3CC: 489EC090  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BD3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BD3D0 size=196
    let mut pc: u32 = 0x822BD3D0;
    'dispatch: loop {
        match pc {
            0x822BD3D0 => {
    //   block [0x822BD3D0..0x822BD430)
	// 822BD3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BD3D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BD3D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BD3DC: 4BFEC885  bl 0x822a9c60
	ctx.lr = 0x822BD3E0;
	sub_822A9C60(ctx, base);
	// 822BD3E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822BD3E4: 419A009C  beq cr6, 0x822bd480
	if ctx.cr[6].eq {
	pc = 0x822BD480; continue 'dispatch;
	}
	// 822BD3E8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BD3EC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BD3F0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822BD3F4: 7D281671  srawi. r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822BD3F8: 41820088  beq 0x822bd480
	if ctx.cr[0].eq {
	pc = 0x822BD480; continue 'dispatch;
	}
	// 822BD3FC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 822BD400: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BD404: 816A6B08  lwz r11, 0x6b08(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822BD408: 810B0020  lwz r8, 0x20(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD40C: 81480020  lwz r10, 0x20(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD410: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 822BD414: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD418: 419A0018  beq cr6, 0x822bd430
	if ctx.cr[6].eq {
	pc = 0x822BD430; continue 'dispatch;
	}
	// 822BD41C: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD420: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822BD424: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 822BD428: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 822BD42C: 41990008  bgt cr6, 0x822bd434
	if ctx.cr[6].gt {
	pc = 0x822BD434; continue 'dispatch;
	}
	pc = 0x822BD430; continue 'dispatch;
            }
            0x822BD430 => {
    //   block [0x822BD430..0x822BD434)
	// 822BD430: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822BD434; continue 'dispatch;
            }
            0x822BD434 => {
    //   block [0x822BD434..0x822BD480)
	// 822BD434: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822BD438: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BD43C: 4BFEC825  bl 0x822a9c60
	ctx.lr = 0x822BD440;
	sub_822A9C60(ctx, base);
	// 822BD440: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822BD444: 419A003C  beq cr6, 0x822bd480
	if ctx.cr[6].eq {
	pc = 0x822BD480; continue 'dispatch;
	}
	// 822BD448: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BD44C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BD450: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822BD454: 7D281671  srawi. r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822BD458: 41820028  beq 0x822bd480
	if ctx.cr[0].eq {
	pc = 0x822BD480; continue 'dispatch;
	}
	// 822BD45C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BD460: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822BD464: 394BFFFD  addi r10, r11, -3
	ctx.r[10].s64 = ctx.r[11].s64 + -3;
	// 822BD468: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 822BD46C: 5523DFFE  rlwinm r3, r9, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 822BD470: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822BD474: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BD478: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BD47C: 4E800020  blr
	return;
            }
            0x822BD480 => {
    //   block [0x822BD480..0x822BD494)
	// 822BD480: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822BD484: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822BD488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BD48C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BD490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BD498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822BD498 size=856
    let mut pc: u32 = 0x822BD498;
    'dispatch: loop {
        match pc {
            0x822BD498 => {
    //   block [0x822BD498..0x822BD4E4)
	// 822BD498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BD49C: 489EBF61  bl 0x82ca93fc
	ctx.lr = 0x822BD4A0;
	sub_82CA93D0(ctx, base);
	// 822BD4A0: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 822BD4A4: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 822BD4A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BD4AC: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 822BD4B0: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 822BD4B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BD4B8: 83DB6B08  lwz r30, 0x6b08(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822BD4BC: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD4C0: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD4C4: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 822BD4C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD4CC: 419A0018  beq cr6, 0x822bd4e4
	if ctx.cr[6].eq {
	pc = 0x822BD4E4; continue 'dispatch;
	}
	// 822BD4D0: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD4D4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822BD4D8: 7D2A1670  srawi r10, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 822BD4DC: 2B0A0007  cmplwi cr6, r10, 7
	ctx.cr[6].compare_u32(ctx.r[10].u32, 7 as u32, &mut ctx.xer);
	// 822BD4E0: 41990008  bgt cr6, 0x822bd4e8
	if ctx.cr[6].gt {
	pc = 0x822BD4E8; continue 'dispatch;
	}
	pc = 0x822BD4E4; continue 'dispatch;
            }
            0x822BD4E4 => {
    //   block [0x822BD4E4..0x822BD4E8)
	// 822BD4E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822BD4E8; continue 'dispatch;
            }
            0x822BD4E8 => {
    //   block [0x822BD4E8..0x822BD528)
	// 822BD4E8: 3FA0834A  lis r29, -0x7cb6
	ctx.r[29].s64 = -2092302336;
	// 822BD4EC: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822BD4F0: 839DBA44  lwz r28, -0x45bc(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17852 as u32) ) } as u64;
	// 822BD4F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822BD4F8: 4BFFFED9  bl 0x822bd3d0
	ctx.lr = 0x822BD4FC;
	sub_822BD3D0(ctx, base);
	// 822BD4FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822BD500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD504: 419A02DC  beq cr6, 0x822bd7e0
	if ctx.cr[6].eq {
	pc = 0x822BD7E0; continue 'dispatch;
	}
	// 822BD508: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822BD50C: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BD510: 3B2B9484  addi r25, r11, -0x6b7c
	ctx.r[25].s64 = ctx.r[11].s64 + -27516;
	// 822BD514: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822BD518: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822BD51C: 4099000C  ble cr6, 0x822bd528
	if !ctx.cr[6].gt {
	pc = 0x822BD528; continue 'dispatch;
	}
	// 822BD520: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 822BD524: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x822BD528; continue 'dispatch;
            }
            0x822BD528 => {
    //   block [0x822BD528..0x822BD53C)
	// 822BD528: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BD52C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822BD530: 4099000C  ble cr6, 0x822bd53c
	if !ctx.cr[6].gt {
	pc = 0x822BD53C; continue 'dispatch;
	}
	// 822BD534: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 822BD538: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x822BD53C; continue 'dispatch;
            }
            0x822BD53C => {
    //   block [0x822BD53C..0x822BD550)
	// 822BD53C: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BD540: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822BD544: 4099000C  ble cr6, 0x822bd550
	if !ctx.cr[6].gt {
	pc = 0x822BD550; continue 'dispatch;
	}
	// 822BD548: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 822BD54C: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x822BD550; continue 'dispatch;
            }
            0x822BD550 => {
    //   block [0x822BD550..0x822BD5A8)
	// 822BD550: 897F0004  lbz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BD554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD558: 419A0288  beq cr6, 0x822bd7e0
	if ctx.cr[6].eq {
	pc = 0x822BD7E0; continue 'dispatch;
	}
	// 822BD55C: 897F0007  lbz r11, 7(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(7 as u32) ) } as u64;
	// 822BD560: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD564: 419A0044  beq cr6, 0x822bd5a8
	if ctx.cr[6].eq {
	pc = 0x822BD5A8; continue 'dispatch;
	}
	// 822BD568: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822BD56C: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 822BD570: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 822BD574: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822BD578: 7D0B1670  srawi r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 822BD57C: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 822BD580: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 822BD584: 409A0024  bne cr6, 0x822bd5a8
	if !ctx.cr[6].eq {
	pc = 0x822BD5A8; continue 'dispatch;
	}
	// 822BD588: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BD58C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822BD590: 41990018  bgt cr6, 0x822bd5a8
	if ctx.cr[6].gt {
	pc = 0x822BD5A8; continue 'dispatch;
	}
	// 822BD594: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822BD598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BD59C: 4852ADF5  bl 0x827e8390
	ctx.lr = 0x822BD5A0;
	sub_827E8390(ctx, base);
	// 822BD5A0: 839DBA44  lwz r28, -0x45bc(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17852 as u32) ) } as u64;
	// 822BD5A4: 83DB6B08  lwz r30, 0x6b08(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27400 as u32) ) } as u64;
	pc = 0x822BD5A8; continue 'dispatch;
            }
            0x822BD5A8 => {
    //   block [0x822BD5A8..0x822BD600)
	// 822BD5A8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD5AC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822BD5B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD5B4: 409A00EC  bne cr6, 0x822bd6a0
	if !ctx.cr[6].eq {
	pc = 0x822BD6A0; continue 'dispatch;
	}
	// 822BD5B8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 822BD5BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD5C0: 897F0005  lbz r11, 5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5 as u32) ) } as u64;
	// 822BD5C4: 419A00CC  beq cr6, 0x822bd690
	if ctx.cr[6].eq {
	pc = 0x822BD690; continue 'dispatch;
	}
	// 822BD5C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD5CC: 409A0048  bne cr6, 0x822bd614
	if !ctx.cr[6].eq {
	pc = 0x822BD614; continue 'dispatch;
	}
	// 822BD5D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BD5D4: 997F0005  stb r11, 5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(5 as u32), ctx.r[11].u8 ) };
	// 822BD5D8: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD5DC: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD5E0: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 822BD5E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD5E8: 419A0018  beq cr6, 0x822bd600
	if ctx.cr[6].eq {
	pc = 0x822BD600; continue 'dispatch;
	}
	// 822BD5EC: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD5F0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822BD5F4: 7D2A1670  srawi r10, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 822BD5F8: 2B0A0009  cmplwi cr6, r10, 9
	ctx.cr[6].compare_u32(ctx.r[10].u32, 9 as u32, &mut ctx.xer);
	// 822BD5FC: 41990008  bgt cr6, 0x822bd604
	if ctx.cr[6].gt {
	pc = 0x822BD604; continue 'dispatch;
	}
	pc = 0x822BD600; continue 'dispatch;
            }
            0x822BD600 => {
    //   block [0x822BD600..0x822BD604)
	// 822BD600: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822BD604; continue 'dispatch;
            }
            0x822BD604 => {
    //   block [0x822BD604..0x822BD614)
	// 822BD604: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822BD608: 806B0024  lwz r3, 0x24(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822BD60C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822BD610: 48141239  bl 0x823fe848
	ctx.lr = 0x822BD614;
	sub_823FE848(ctx, base);
	pc = 0x822BD614; continue 'dispatch;
            }
            0x822BD614 => {
    //   block [0x822BD614..0x822BD630)
	// 822BD614: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822BD618: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 822BD61C: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822BD620: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BD624: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822BD628: 409A0008  bne cr6, 0x822bd630
	if !ctx.cr[6].eq {
	pc = 0x822BD630; continue 'dispatch;
	}
	// 822BD62C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822BD630; continue 'dispatch;
            }
            0x822BD630 => {
    //   block [0x822BD630..0x822BD650)
	// 822BD630: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BD634: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 822BD638: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BD63C: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822BD640: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BD644: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822BD648: 409A0008  bne cr6, 0x822bd650
	if !ctx.cr[6].eq {
	pc = 0x822BD650; continue 'dispatch;
	}
	// 822BD64C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822BD650; continue 'dispatch;
            }
            0x822BD650 => {
    //   block [0x822BD650..0x822BD690)
	// 822BD650: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822BD654: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BD658: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 822BD65C: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 822BD660: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BD664: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BD668: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 822BD66C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822BD670: 4BF1C879  bl 0x821d9ee8
	ctx.lr = 0x822BD674;
	sub_821D9EE8(ctx, base);
	// 822BD674: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BD678: 4852AEE9  bl 0x827e8560
	ctx.lr = 0x822BD67C;
	sub_827E8560(ctx, base);
	// 822BD67C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BD680: 4852AB39  bl 0x827e81b8
	ctx.lr = 0x822BD684;
	sub_827E81B8(ctx, base);
	// 822BD684: 839DBA44  lwz r28, -0x45bc(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17852 as u32) ) } as u64;
	// 822BD688: 83DB6B08  lwz r30, 0x6b08(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822BD68C: 48000070  b 0x822bd6fc
	pc = 0x822BD6FC; continue 'dispatch;
            }
            0x822BD690 => {
    //   block [0x822BD690..0x822BD6A0)
	// 822BD690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD694: 419A0068  beq cr6, 0x822bd6fc
	if ctx.cr[6].eq {
	pc = 0x822BD6FC; continue 'dispatch;
	}
	// 822BD698: 9B5F0005  stb r26, 5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(5 as u32), ctx.r[26].u8 ) };
	// 822BD69C: 48000060  b 0x822bd6fc
	pc = 0x822BD6FC; continue 'dispatch;
            }
            0x822BD6A0 => {
    //   block [0x822BD6A0..0x822BD6C0)
	// 822BD6A0: 897F0006  lbz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 822BD6A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD6A8: 409A0018  bne cr6, 0x822bd6c0
	if !ctx.cr[6].eq {
	pc = 0x822BD6C0; continue 'dispatch;
	}
	// 822BD6AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BD6B0: 4852AB09  bl 0x827e81b8
	ctx.lr = 0x822BD6B4;
	sub_827E81B8(ctx, base);
	// 822BD6B4: 839DBA44  lwz r28, -0x45bc(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17852 as u32) ) } as u64;
	// 822BD6B8: 83DB6B08  lwz r30, 0x6b08(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822BD6BC: 48000040  b 0x822bd6fc
	pc = 0x822BD6FC; continue 'dispatch;
            }
            0x822BD6C0 => {
    //   block [0x822BD6C0..0x822BD6FC)
	// 822BD6C0: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BD6C4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822BD6C8: 41990034  bgt cr6, 0x822bd6fc
	if ctx.cr[6].gt {
	pc = 0x822BD6FC; continue 'dispatch;
	}
	// 822BD6CC: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822BD6D0: 813F002C  lwz r9, 0x2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 822BD6D4: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 822BD6D8: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 822BD6DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822BD6E0: 7D071670  srawi r7, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 822BD6E4: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 822BD6E8: 40980014  bge cr6, 0x822bd6fc
	if !ctx.cr[6].lt {
	pc = 0x822BD6FC; continue 'dispatch;
	}
	// 822BD6EC: C0192A40  lfs f0, 0x2a40(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(10816 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BD6F0: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 822BD6F4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822BD6F8: 9B5F0006  stb r26, 6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[26].u8 ) };
	pc = 0x822BD6FC; continue 'dispatch;
            }
            0x822BD6FC => {
    //   block [0x822BD6FC..0x822BD760)
	// 822BD6FC: 897F0006  lbz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 822BD700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD704: 409A00DC  bne cr6, 0x822bd7e0
	if !ctx.cr[6].eq {
	pc = 0x822BD7E0; continue 'dispatch;
	}
	// 822BD708: 897F0040  lbz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 822BD70C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD710: 419A00D0  beq cr6, 0x822bd7e0
	if ctx.cr[6].eq {
	pc = 0x822BD7E0; continue 'dispatch;
	}
	// 822BD714: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BD718: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822BD71C: 40990068  ble cr6, 0x822bd784
	if !ctx.cr[6].gt {
	pc = 0x822BD784; continue 'dispatch;
	}
	// 822BD720: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 822BD724: C1B92A40  lfs f13, 0x2a40(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(10816 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822BD728: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 822BD72C: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822BD730: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822BD734: 419900AC  bgt cr6, 0x822bd7e0
	if ctx.cr[6].gt {
	pc = 0x822BD7E0; continue 'dispatch;
	}
	// 822BD738: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD73C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD740: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 822BD744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD748: 419A0018  beq cr6, 0x822bd760
	if ctx.cr[6].eq {
	pc = 0x822BD760; continue 'dispatch;
	}
	// 822BD74C: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD750: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822BD754: 7D2A1670  srawi r10, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 822BD758: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 822BD75C: 41990008  bgt cr6, 0x822bd764
	if ctx.cr[6].gt {
	pc = 0x822BD764; continue 'dispatch;
	}
	pc = 0x822BD760; continue 'dispatch;
            }
            0x822BD760 => {
    //   block [0x822BD760..0x822BD764)
	// 822BD760: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822BD764; continue 'dispatch;
            }
            0x822BD764 => {
    //   block [0x822BD764..0x822BD784)
	// 822BD764: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 822BD768: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822BD76C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822BD770: 48584A89  bl 0x828421f8
	ctx.lr = 0x822BD774;
	sub_828421F8(ctx, base);
	// 822BD774: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822BD778: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 822BD77C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 822BD780: 489EBCCC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x822BD784 => {
    //   block [0x822BD784..0x822BD7B8)
	// 822BD784: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BD788: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822BD78C: 40980054  bge cr6, 0x822bd7e0
	if !ctx.cr[6].lt {
	pc = 0x822BD7E0; continue 'dispatch;
	}
	// 822BD790: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD794: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD798: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 822BD79C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD7A0: 419A0018  beq cr6, 0x822bd7b8
	if ctx.cr[6].eq {
	pc = 0x822BD7B8; continue 'dispatch;
	}
	// 822BD7A4: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD7A8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822BD7AC: 7D2A1670  srawi r10, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 822BD7B0: 2B0A0009  cmplwi cr6, r10, 9
	ctx.cr[6].compare_u32(ctx.r[10].u32, 9 as u32, &mut ctx.xer);
	// 822BD7B4: 41990008  bgt cr6, 0x822bd7bc
	if ctx.cr[6].gt {
	pc = 0x822BD7BC; continue 'dispatch;
	}
	pc = 0x822BD7B8; continue 'dispatch;
            }
            0x822BD7B8 => {
    //   block [0x822BD7B8..0x822BD7BC)
	// 822BD7B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822BD7BC; continue 'dispatch;
            }
            0x822BD7BC => {
    //   block [0x822BD7BC..0x822BD7E0)
	// 822BD7BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822BD7C0: 88BF0005  lbz r5, 5(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5 as u32) ) } as u64;
	// 822BD7C4: 806B0024  lwz r3, 0x24(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822BD7C8: 48141081  bl 0x823fe848
	ctx.lr = 0x822BD7CC;
	sub_823FE848(ctx, base);
	// 822BD7CC: 817B6B08  lwz r11, 0x6b08(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27400 as u32) ) } as u64;
	// 822BD7D0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BD7D4: 806B0054  lwz r3, 0x54(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 822BD7D8: 4810E741  bl 0x823cbf18
	ctx.lr = 0x822BD7DC;
	sub_823CBF18(ctx, base);
	// 822BD7DC: 9B5F0040  stb r26, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[26].u8 ) };
	pc = 0x822BD7E0; continue 'dispatch;
            }
            0x822BD7E0 => {
    //   block [0x822BD7E0..0x822BD7F0)
	// 822BD7E0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822BD7E4: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 822BD7E8: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 822BD7EC: 489EBC60  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BD7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822BD7F0 size=260
    let mut pc: u32 = 0x822BD7F0;
    'dispatch: loop {
        match pc {
            0x822BD7F0 => {
    //   block [0x822BD7F0..0x822BD8D8)
	// 822BD7F0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822BD7F4: 81430030  lwz r10, 0x30(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 822BD7F8: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 822BD7FC: C123001C  lfs f9, 0x1c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822BD800: C0C30010  lfs f6, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 822BD804: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 822BD808: ECA64828  fsubs f5, f6, f9
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[9].f64) as f32) as f64);
	// 822BD80C: C1030024  lfs f8, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822BD810: 38C8CB94  addi r6, r8, -0x346c
	ctx.r[6].s64 = ctx.r[8].s64 + -13420;
	// 822BD814: C0830018  lfs f4, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 822BD818: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822BD81C: C0E30020  lfs f7, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 822BD820: C9899660  lfd f12, -0x69a0(r9)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-27040 as u32) ) };
	// 822BD824: EC444028  fsubs f2, f4, f8
	ctx.f[2].f64 = (((ctx.f[4].f64 - ctx.f[8].f64) as f32) as f64);
	// 822BD828: 7C8A5850  subf r4, r10, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822BD82C: C0630014  lfs f3, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 822BD830: C0830028  lfs f4, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 822BD834: EC233828  fsubs f1, f3, f7
	ctx.f[1].f64 = (((ctx.f[3].f64 - ctx.f[7].f64) as f32) as f64);
	// 822BD838: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 822BD83C: C146C738  lfs f10, -0x38c8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-14536 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822BD840: C006C8F0  lfs f0, -0x3710(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-14096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BD844: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 822BD848: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 822BD84C: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BD850: FD606E9C  fcfid f11, f13
	ctx.f[11].f64 = (ctx.f[13].s64 as f64);
	// 822BD854: 38A70E68  addi r5, r7, 0xe68
	ctx.r[5].s64 = ctx.r[7].s64 + 3688;
	// 822BD858: FCCB6024  fdiv f6, f11, f12
	ctx.f[6].f64 = ctx.f[11].f64 / ctx.f[12].f64;
	// 822BD85C: C186C9A0  lfs f12, -0x3660(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-13920 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822BD860: EC640332  fmuls f3, f4, f12
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[12].f64) as f32) as f64);
	// 822BD864: C168CB94  lfs f11, -0x346c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-13420 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822BD868: C1A6C8FC  lfs f13, -0x3704(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-14084 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822BD86C: D0630028  stfs f3, 0x28(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 822BD870: FCC03018  frsp f6, f6
	ctx.f[6].f64 = (ctx.f[6].f64 as f32) as f64;
	// 822BD874: EC8602B2  fmuls f4, f6, f10
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[10].f64) as f32) as f64);
	// 822BD878: FF040000  fcmpu cr6, f4, f0
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[0].f64);
	// 822BD87C: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822BD880: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822BD884: 5548F77A  rlwinm r8, r10, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 822BD888: 7D274378  or r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 822BD88C: 7D453C2E  lfsx f10, r5, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822BD890: FCCA012E  fsel f6, f10, f4, f0
	ctx.f[6].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[4].f64 } else { ctx.f[0].f64 };
	// 822BD894: EC866828  fsubs f4, f6, f13
	ctx.f[4].f64 = (((ctx.f[6].f64 - ctx.f[13].f64) as f32) as f64);
	// 822BD898: FF040000  fcmpu cr6, f4, f0
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[0].f64);
	// 822BD89C: 7CC00026  mfcr r6
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[6].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822BD8A0: 54C4DF7A  rlwinm r4, r6, 0x1b, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 822BD8A4: FF035800  fcmpu cr6, f3, f11
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[11].f64);
	// 822BD8A8: 54CBF77A  rlwinm r11, r6, 0x1e, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 822BD8AC: 7C8A5B78  or r10, r4, r11
	ctx.r[10].u64 = ctx.r[4].u64 | ctx.r[11].u64;
	// 822BD8B0: 7C65542E  lfsx f3, r5, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 822BD8B4: FDA3336E  fsel f13, f3, f13, f6
	ctx.f[13].f64 = if ctx.f[3].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[6].f64 };
	// 822BD8B8: ED454B7A  fmadds f10, f5, f13, f9
	ctx.f[10].f64 = (((ctx.f[5].f64 * ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64);
	// 822BD8BC: D143001C  stfs f10, 0x1c(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 822BD8C0: ED22437A  fmadds f9, f2, f13, f8
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[13].f64 + ctx.f[8].f64) as f32) as f64);
	// 822BD8C4: D1230024  stfs f9, 0x24(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822BD8C8: ED013B7A  fmadds f8, f1, f13, f7
	ctx.f[8].f64 = (((ctx.f[1].f64 * ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64);
	// 822BD8CC: D1030020  stfs f8, 0x20(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822BD8D0: 40980008  bge cr6, 0x822bd8d8
	if !ctx.cr[6].lt {
	pc = 0x822BD8D8; continue 'dispatch;
	}
	// 822BD8D4: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	pc = 0x822BD8D8; continue 'dispatch;
            }
            0x822BD8D8 => {
    //   block [0x822BD8D8..0x822BD8F4)
	// 822BD8D8: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822BD8DC: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 822BD8E0: D183002C  stfs f12, 0x2c(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 822BD8E4: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 822BD8E8: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 822BD8EC: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 822BD8F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BD8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822BD8F8 size=952
    let mut pc: u32 = 0x822BD8F8;
    'dispatch: loop {
        match pc {
            0x822BD8F8 => {
    //   block [0x822BD8F8..0x822BD940)
	// 822BD8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BD8FC: 489EBAF5  bl 0x82ca93f0
	ctx.lr = 0x822BD900;
	sub_82CA93D0(ctx, base);
	// 822BD900: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 822BD904: 489F03D1  bl 0x82cadcd4
	ctx.lr = 0x822BD908;
	sub_82CADCA0(ctx, base);
	// 822BD908: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BD90C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 822BD910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BD914: 3B0BDAC0  addi r24, r11, -0x2540
	ctx.r[24].s64 = ctx.r[11].s64 + -9536;
	// 822BD918: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BD91C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD920: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822BD924: C3AB0C18  lfs f29, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822BD928: 419A0018  beq cr6, 0x822bd940
	if ctx.cr[6].eq {
	pc = 0x822BD940; continue 'dispatch;
	}
	// 822BD92C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BD930: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822BD934: 4E800421  bctrl
	ctx.lr = 0x822BD938;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BD938: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 822BD93C: 48000008  b 0x822bd944
	pc = 0x822BD944; continue 'dispatch;
            }
            0x822BD940 => {
    //   block [0x822BD940..0x822BD944)
	// 822BD940: FF60E890  fmr f27, f29
	ctx.f[27].f64 = ctx.f[29].f64;
	pc = 0x822BD944; continue 'dispatch;
            }
            0x822BD944 => {
    //   block [0x822BD944..0x822BD960)
	// 822BD944: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 822BD948: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 822BD94C: D37F00B4  stfs f27, 0xb4(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822BD950: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 822BD954: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BD958: 40990028  ble cr6, 0x822bd980
	if !ctx.cr[6].gt {
	pc = 0x822BD980; continue 'dispatch;
	}
	// 822BD95C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x822BD960; continue 'dispatch;
            }
            0x822BD960 => {
    //   block [0x822BD960..0x822BD980)
	// 822BD960: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 822BD964: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822BD968: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822BD96C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822BD970: 92E9004C  stw r23, 0x4c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(76 as u32), ctx.r[23].u32 ) };
	// 822BD974: 813F007C  lwz r9, 0x7c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 822BD978: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822BD97C: 4198FFE4  blt cr6, 0x822bd960
	if ctx.cr[6].lt {
	pc = 0x822BD960; continue 'dispatch;
	}
	pc = 0x822BD980; continue 'dispatch;
            }
            0x822BD980 => {
    //   block [0x822BD980..0x822BD9A8)
	// 822BD980: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 822BD984: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 822BD988: 409A0020  bne cr6, 0x822bd9a8
	if !ctx.cr[6].eq {
	pc = 0x822BD9A8; continue 'dispatch;
	}
	// 822BD98C: 92FF00A8  stw r23, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[23].u32 ) };
	// 822BD990: 4BFA3029  bl 0x822609b8
	ctx.lr = 0x822BD994;
	sub_822609B8(ctx, base);
	// 822BD994: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 822BD998: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BD99C: 815F009C  lwz r10, 0x9c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 822BD9A0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822BD9A4: 7C0A5D2E  stfsx f0, r10, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	pc = 0x822BD9A8; continue 'dispatch;
            }
            0x822BD9A8 => {
    //   block [0x822BD9A8..0x822BDA04)
	// 822BD9A8: 4BFA3011  bl 0x822609b8
	ctx.lr = 0x822BD9AC;
	sub_822609B8(ctx, base);
	// 822BD9AC: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 822BD9B0: 815F009C  lwz r10, 0x9c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 822BD9B4: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822BD9B8: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822BD9BC: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BD9C0: 7D89542E  lfsx f12, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822BD9C4: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 822BD9C8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822BD9CC: 40990038  ble cr6, 0x822bda04
	if !ctx.cr[6].gt {
	pc = 0x822BDA04; continue 'dispatch;
	}
	// 822BD9D0: 815F00A4  lwz r10, 0xa4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 822BD9D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822BD9D8: 7D2B5396  divwu r9, r11, r10
	ctx.r[9].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 822BD9DC: 0CCA0000  twi 6, r10, 0
	// 822BD9E0: 7D4951D6  mullw r10, r9, r10
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 822BD9E4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822BD9E8: 917F00A8  stw r11, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 822BD9EC: 4BFA2FCD  bl 0x822609b8
	ctx.lr = 0x822BD9F0;
	sub_822609B8(ctx, base);
	// 822BD9F0: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 822BD9F4: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BD9F8: 815F009C  lwz r10, 0x9c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 822BD9FC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822BDA00: 7C0B552E  stfsx f0, r11, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	pc = 0x822BDA04; continue 'dispatch;
            }
            0x822BDA04 => {
    //   block [0x822BDA04..0x822BDA24)
	// 822BDA04: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822BDA08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BDA0C: 409A0018  bne cr6, 0x822bda24
	if !ctx.cr[6].eq {
	pc = 0x822BDA24; continue 'dispatch;
	}
	// 822BDA10: 4BFA2FA9  bl 0x822609b8
	ctx.lr = 0x822BDA14;
	sub_822609B8(ctx, base);
	// 822BDA14: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BDA18: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 822BDA1C: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822BDA20: 48000254  b 0x822bdc74
	pc = 0x822BDC74; continue 'dispatch;
            }
            0x822BDA24 => {
    //   block [0x822BDA24..0x822BDACC)
	// 822BDA24: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 822BDA28: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BDA2C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 822BDA30: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822BDA34: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822BDA38: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822BDA3C: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822BDA40: 4BFA2F79  bl 0x822609b8
	ctx.lr = 0x822BDA44;
	sub_822609B8(ctx, base);
	// 822BDA44: C3C3004C  lfs f30, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822BDA48: 4BFA2F71  bl 0x822609b8
	ctx.lr = 0x822BDA4C;
	sub_822609B8(ctx, base);
	// 822BDA4C: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822BDA50: C01F0098  lfs f0, 0x98(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BDA54: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822BDA58: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 822BDA5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822BDA60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BDA64: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 822BDA68: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822BDA6C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 822BDA70: C1AB0058  lfs f13, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822BDA74: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 822BDA78: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 822BDA7C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 822BDA80: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 822BDA84: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 822BDA88: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822BDA8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822BDA90: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822BDA94: 48BC9ABD  bl 0x82e87550
	ctx.lr = 0x822BDA98;
	sub_82E87550(ctx, base);
	// 822BDA98: C01F00C0  lfs f0, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BDA9C: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 822BDAA0: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 822BDAA4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822BDAA8: 41980024  blt cr6, 0x822bdacc
	if ctx.cr[6].lt {
	pc = 0x822BDACC; continue 'dispatch;
	}
	// 822BDAAC: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 822BDAB0: 897F0088  lbz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 822BDAB4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822BDAB8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822BDABC: 41820070  beq 0x822bdb2c
	if ctx.cr[0].eq {
	pc = 0x822BDB2C; continue 'dispatch;
	}
	// 822BDAC0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 822BDAC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BDAC8: 48BC9A89  bl 0x82e87550
	ctx.lr = 0x822BDACC;
	sub_82E87550(ctx, base);
	pc = 0x822BDACC; continue 'dispatch;
            }
            0x822BDACC => {
    //   block [0x822BDACC..0x822BDAD0)
	// 822BDACC: 9ADF00C8  stb r22, 0xc8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[22].u8 ) };
	pc = 0x822BDAD0; continue 'dispatch;
            }
            0x822BDAD0 => {
    //   block [0x822BDAD0..0x822BDB00)
	// 822BDAD0: 4BFA2EE9  bl 0x822609b8
	ctx.lr = 0x822BDAD4;
	sub_822609B8(ctx, base);
	// 822BDAD4: 809F008C  lwz r4, 0x8c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 822BDAD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822BDADC: 48BC37F5  bl 0x82e812d0
	ctx.lr = 0x822BDAE0;
	sub_82E812D0(ctx, base);
	// 822BDAE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BDAE4: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 822BDAE8: 486B4681  bl 0x82972168
	ctx.lr = 0x822BDAEC;
	sub_82972168(ctx, base);
	// 822BDAEC: FF01E800  fcmpu cr6, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 822BDAF0: 419A0010  beq cr6, 0x822bdb00
	if ctx.cr[6].eq {
	pc = 0x822BDB00; continue 'dispatch;
	}
	// 822BDAF4: FF1E0800  fcmpu cr6, f30, f1
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[1].f64);
	// 822BDAF8: 40990008  ble cr6, 0x822bdb00
	if !ctx.cr[6].gt {
	pc = 0x822BDB00; continue 'dispatch;
	}
	// 822BDAFC: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	pc = 0x822BDB00; continue 'dispatch;
            }
            0x822BDB00 => {
    //   block [0x822BDB00..0x822BDB2C)
	// 822BDB00: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BDB04: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 822BDB08: 833F0080  lwz r25, 0x80(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822BDB0C: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 822BDB10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BDB14: 419A0020  beq cr6, 0x822bdb34
	if ctx.cr[6].eq {
	pc = 0x822BDB34; continue 'dispatch;
	}
	// 822BDB18: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822BDB1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822BDB20: 4E800421  bctrl
	ctx.lr = 0x822BDB24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BDB24: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 822BDB28: 48000010  b 0x822bdb38
	pc = 0x822BDB38; continue 'dispatch;
            }
            0x822BDB2C => {
    //   block [0x822BDB2C..0x822BDB34)
	// 822BDB2C: 9AFF00C8  stb r23, 0xc8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[23].u8 ) };
	// 822BDB30: 4BFFFFA0  b 0x822bdad0
	pc = 0x822BDAD0; continue 'dispatch;
            }
            0x822BDB34 => {
    //   block [0x822BDB34..0x822BDB38)
	// 822BDB34: FF80E890  fmr f28, f29
	ctx.f[28].f64 = ctx.f[29].f64;
	pc = 0x822BDB38; continue 'dispatch;
            }
            0x822BDB38 => {
    //   block [0x822BDB38..0x822BDB4C)
	// 822BDB38: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822BDB3C: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 822BDB40: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 822BDB44: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822BDB48: 7FCB502E  lwzx r30, r11, r10
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	pc = 0x822BDB4C; continue 'dispatch;
            }
            0x822BDB4C => {
    //   block [0x822BDB4C..0x822BDBE8)
	// 822BDB4C: EC1EF828  fsubs f0, f30, f31
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 822BDB50: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 822BDB54: 409900A8  ble cr6, 0x822bdbfc
	if !ctx.cr[6].gt {
	pc = 0x822BDBFC; continue 'dispatch;
	}
	// 822BDB58: C1BF00B0  lfs f13, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822BDB5C: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 822BDB60: C19E0048  lfs f12, 0x48(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822BDB64: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 822BDB68: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 822BDB6C: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 822BDB70: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 822BDB74: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822BDB78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BDB7C: 419A0080  beq cr6, 0x822bdbfc
	if ctx.cr[6].eq {
	pc = 0x822BDBFC; continue 'dispatch;
	}
	// 822BDB80: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BDB84: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 822BDB88: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 822BDB8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BDB90: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822BDB94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822BDB98: 4E800421  bctrl
	ctx.lr = 0x822BDB9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BDB9C: C3FE0048  lfs f31, 0x48(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822BDBA0: 83BE004C  lwz r29, 0x4c(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 822BDBA4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822BDBA8: 4BFA2E11  bl 0x822609b8
	ctx.lr = 0x822BDBAC;
	sub_822609B8(ctx, base);
	// 822BDBAC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822BDBB0: C0030074  lfs f0, 0x74(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BDBB4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 822BDBB8: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822BDBBC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822BDBC0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822BDBC4: EC0D07FA  fmadds f0, f13, f31, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 822BDBC8: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822BDBCC: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BDBD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BDBD4: 419A0014  beq cr6, 0x822bdbe8
	if ctx.cr[6].eq {
	pc = 0x822BDBE8; continue 'dispatch;
	}
	// 822BDBD8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822BDBDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822BDBE0: 4E800421  bctrl
	ctx.lr = 0x822BDBE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BDBE4: 48000008  b 0x822bdbec
	pc = 0x822BDBEC; continue 'dispatch;
            }
            0x822BDBE8 => {
    //   block [0x822BDBE8..0x822BDBEC)
	// 822BDBE8: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	pc = 0x822BDBEC; continue 'dispatch;
            }
            0x822BDBEC => {
    //   block [0x822BDBEC..0x822BDBFC)
	// 822BDBEC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BDBF0: EFE1D828  fsubs f31, f1, f27
	ctx.f[31].f64 = (((ctx.f[1].f64 - ctx.f[27].f64) as f32) as f64);
	// 822BDBF4: 4182FF58  beq 0x822bdb4c
	if ctx.cr[0].eq {
	pc = 0x822BDB4C; continue 'dispatch;
	}
	// 822BDBF8: 48000008  b 0x822bdc00
	pc = 0x822BDC00; continue 'dispatch;
            }
            0x822BDBFC => {
    //   block [0x822BDBFC..0x822BDC00)
	// 822BDBFC: 7EDBB378  mr r27, r22
	ctx.r[27].u64 = ctx.r[22].u64;
	pc = 0x822BDC00; continue 'dispatch;
            }
            0x822BDC00 => {
    //   block [0x822BDC00..0x822BDC30)
	// 822BDC00: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BDC04: 40820048  bne 0x822bdc4c
	if !ctx.cr[0].eq {
	pc = 0x822BDC4C; continue 'dispatch;
	}
	// 822BDC08: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822BDC0C: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 822BDC10: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822BDC14: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822BDC18: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 822BDC1C: 409A0014  bne cr6, 0x822bdc30
	if !ctx.cr[6].eq {
	pc = 0x822BDC30; continue 'dispatch;
	}
	// 822BDC20: 92FF0080  stw r23, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[23].u32 ) };
	// 822BDC24: 4BFA2D95  bl 0x822609b8
	ctx.lr = 0x822BDC28;
	sub_822609B8(ctx, base);
	// 822BDC28: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BDC2C: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	pc = 0x822BDC30; continue 'dispatch;
            }
            0x822BDC30 => {
    //   block [0x822BDC30..0x822BDC4C)
	// 822BDC30: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 822BDC34: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 822BDC38: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822BDC3C: 40980010  bge cr6, 0x822bdc4c
	if !ctx.cr[6].lt {
	pc = 0x822BDC4C; continue 'dispatch;
	}
	// 822BDC40: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 822BDC44: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822BDC48: 409AFEF0  bne cr6, 0x822bdb38
	if !ctx.cr[6].eq {
	pc = 0x822BDB38; continue 'dispatch;
	}
	pc = 0x822BDC4C; continue 'dispatch;
            }
            0x822BDC4C => {
    //   block [0x822BDC4C..0x822BDC68)
	// 822BDC4C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BDC50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BDC54: 419A0014  beq cr6, 0x822bdc68
	if ctx.cr[6].eq {
	pc = 0x822BDC68; continue 'dispatch;
	}
	// 822BDC58: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822BDC5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822BDC60: 4E800421  bctrl
	ctx.lr = 0x822BDC64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BDC64: 48000008  b 0x822bdc6c
	pc = 0x822BDC6C; continue 'dispatch;
            }
            0x822BDC68 => {
    //   block [0x822BDC68..0x822BDC6C)
	// 822BDC68: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	pc = 0x822BDC6C; continue 'dispatch;
            }
            0x822BDC6C => {
    //   block [0x822BDC6C..0x822BDC74)
	// 822BDC6C: EC01E028  fsubs f0, f1, f28
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[28].f64) as f32) as f64);
	// 822BDC70: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	pc = 0x822BDC74; continue 'dispatch;
            }
            0x822BDC74 => {
    //   block [0x822BDC74..0x822BDC90)
	// 822BDC74: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BDC78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BDC7C: 419A0014  beq cr6, 0x822bdc90
	if ctx.cr[6].eq {
	pc = 0x822BDC90; continue 'dispatch;
	}
	// 822BDC80: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822BDC84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822BDC88: 4E800421  bctrl
	ctx.lr = 0x822BDC8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BDC8C: 48000008  b 0x822bdc94
	pc = 0x822BDC94; continue 'dispatch;
            }
            0x822BDC90 => {
    //   block [0x822BDC90..0x822BDC94)
	// 822BDC90: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	pc = 0x822BDC94; continue 'dispatch;
            }
            0x822BDC94 => {
    //   block [0x822BDC94..0x822BDCB0)
	// 822BDC94: C01F00B4  lfs f0, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BDC98: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 822BDC9C: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 822BDCA0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 822BDCA4: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 822BDCA8: 489F0079  bl 0x82cadd20
	ctx.lr = 0x822BDCAC;
	sub_82CADCEC(ctx, base);
	// 822BDCAC: 489EB794  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BDCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BDCB0 size=92
    let mut pc: u32 = 0x822BDCB0;
    'dispatch: loop {
        match pc {
            0x822BDCB0 => {
    //   block [0x822BDCB0..0x822BDD0C)
	// 822BDCB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BDCB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BDCB8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BDCBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BDCC0: 4BF60D69  bl 0x8221ea28
	ctx.lr = 0x822BDCC4;
	sub_8221EA28(ctx, base);
	// 822BDCC4: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 822BDCC8: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822BDCCC: 390ACCB8  addi r8, r10, -0x3348
	ctx.r[8].s64 = ctx.r[10].s64 + -13128;
	// 822BDCD0: E96ACCB8  ld r11, -0x3348(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-13128 as u32) ) };
	// 822BDCD4: F92ACCB8  std r9, -0x3348(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-13128 as u32), ctx.r[9].u64 ) };
	// 822BDCD8: C9A80010  lfd f13, 0x10(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 822BDCDC: E9480008  ld r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 822BDCE0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822BDCE4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822BDCE8: F9680008  std r11, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 822BDCEC: C8080008  lfd f0, 8(r8)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 822BDCF0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822BDCF4: FDA06824  fdiv f13, f0, f13
	ctx.f[13].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 822BDCF8: FC206818  frsp f1, f13
	ctx.f[1].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822BDCFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822BDD00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BDD04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BDD08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BDD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BDD10 size=96
    let mut pc: u32 = 0x822BDD10;
    'dispatch: loop {
        match pc {
            0x822BDD10 => {
    //   block [0x822BDD10..0x822BDD70)
	// 822BDD10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BDD14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BDD18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822BDD1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BDD20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BDD24: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BDD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822BDD70 size=216
    let mut pc: u32 = 0x822BDD70;
    'dispatch: loop {
        match pc {
            0x822BDD70 => {
    //   block [0x822BDD70..0x822BDE48)
	// 822BDD70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BDD74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BDD78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BDD7C: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BDE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BDE50 size=80
    let mut pc: u32 = 0x822BDE50;
    'dispatch: loop {
        match pc {
            0x822BDE50 => {
    //   block [0x822BDE50..0x822BDEA0)
	// 822BDE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BDE54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BDE58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BDE5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BDE60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BDE64: 4876627D  bl 0x82a240e0
	ctx.lr = 0x822BDE68;
	sub_82A240E0(ctx, base);
	// 822BDE68: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BDE6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822BDE70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BDE74: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 822BDE78: 38ABFFF0  addi r5, r11, -0x10
	ctx.r[5].s64 = ctx.r[11].s64 + -16;
	// 822BDE7C: 4BF6AEAD  bl 0x82228d28
	ctx.lr = 0x822BDE80;
	sub_82228D28(ctx, base);
	// 822BDE80: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BDE84: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 822BDE88: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822BDE8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822BDE90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BDE94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BDE98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BDE9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BDEA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BDEA0 size=132
    let mut pc: u32 = 0x822BDEA0;
    'dispatch: loop {
        match pc {
            0x822BDEA0 => {
    //   block [0x822BDEA0..0x822BDED0)
	// 822BDEA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BDEA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BDEA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BDEAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BDEB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BDEB4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BDEB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BDEBC: 41980014  blt cr6, 0x822bded0
	if ctx.cr[6].lt {
	pc = 0x822BDED0; continue 'dispatch;
	}
	// 822BDEC0: 4BFDA879  bl 0x82298738
	ctx.lr = 0x822BDEC4;
	sub_82298738(ctx, base);
	// 822BDEC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822BDEC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BDECC: 409A0008  bne cr6, 0x822bded4
	if !ctx.cr[6].eq {
	pc = 0x822BDED4; continue 'dispatch;
	}
	pc = 0x822BDED0; continue 'dispatch;
            }
            0x822BDED0 => {
    //   block [0x822BDED0..0x822BDED4)
	// 822BDED0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BDED4; continue 'dispatch;
            }
            0x822BDED4 => {
    //   block [0x822BDED4..0x822BDF0C)
	// 822BDED4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BDED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BDEDC: 419A0030  beq cr6, 0x822bdf0c
	if ctx.cr[6].eq {
	pc = 0x822BDF0C; continue 'dispatch;
	}
	// 822BDEE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BDEE4: 4BFDA855  bl 0x82298738
	ctx.lr = 0x822BDEE8;
	sub_82298738(ctx, base);
	// 822BDEE8: 8963004C  lbz r11, 0x4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 822BDEEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BDEF0: 409A001C  bne cr6, 0x822bdf0c
	if !ctx.cr[6].eq {
	pc = 0x822BDF0C; continue 'dispatch;
	}
	// 822BDEF4: 8863004E  lbz r3, 0x4e(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(78 as u32) ) } as u64;
	// 822BDEF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822BDEFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BDF00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BDF04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BDF08: 4E800020  blr
	return;
            }
            0x822BDF0C => {
    //   block [0x822BDF0C..0x822BDF24)
	// 822BDF0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822BDF10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822BDF14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BDF18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BDF1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BDF20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BDF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BDF28 size=504
    let mut pc: u32 = 0x822BDF28;
    'dispatch: loop {
        match pc {
            0x822BDF28 => {
    //   block [0x822BDF28..0x822BDF5C)
	// 822BDF28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BDF2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BDF30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BDF34: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BDF38: 89630017  lbz r11, 0x17(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(23 as u32) ) } as u64;
	// 822BDF3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BDF40: 419A001C  beq cr6, 0x822bdf5c
	if ctx.cr[6].eq {
	pc = 0x822BDF5C; continue 'dispatch;
	}
	// 822BDF44: 88630016  lbz r3, 0x16(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(22 as u32) ) } as u64;
	// 822BDF48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BDF4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BDF50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BDF54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BDF58: 4E800020  blr
	return;
            }
            0x822BDF5C => {
    //   block [0x822BDF5C..0x822BDFA0)
	// 822BDF5C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BDF60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822BDF64: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 822BDF68: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 822BDF6C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822BDF70: 419A00F8  beq cr6, 0x822be068
	if ctx.cr[6].eq {
	pc = 0x822BE068; continue 'dispatch;
	}
	// 822BDF74: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822BDF78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BDF7C: 419A0024  beq cr6, 0x822bdfa0
	if ctx.cr[6].eq {
	pc = 0x822BDFA0; continue 'dispatch;
	}
	// 822BDF80: 894A0031  lbz r10, 0x31(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(49 as u32) ) } as u64;
	// 822BDF84: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822BDF88: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822BDF8C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822BDF90: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BDF94: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822BDF98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BDF9C: 480000D0  b 0x822be06c
	pc = 0x822BE06C; continue 'dispatch;
            }
            0x822BDFA0 => {
    //   block [0x822BDFA0..0x822BDFC0)
	// 822BDFA0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822BDFA4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822BDFA8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822BDFAC: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 822BDFB0: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822BDFB4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822BDFB8: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BDFBC: 40810054  ble 0x822be010
	if !ctx.cr[0].gt {
	pc = 0x822BE010; continue 'dispatch;
	}
	pc = 0x822BDFC0; continue 'dispatch;
            }
            0x822BDFC0 => {
    //   block [0x822BDFC0..0x822BDFE0)
	// 822BDFC0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822BDFC4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822BDFC8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822BDFCC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BDFD0: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 822BDFD4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822BDFD8: 41980008  blt cr6, 0x822bdfe0
	if ctx.cr[6].lt {
	pc = 0x822BDFE0; continue 'dispatch;
	}
	// 822BDFDC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x822BDFE0; continue 'dispatch;
            }
            0x822BDFE0 => {
    //   block [0x822BDFE0..0x822BDFFC)
	// 822BDFE0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822BDFE4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822BDFE8: 419A0014  beq cr6, 0x822bdffc
	if ctx.cr[6].eq {
	pc = 0x822BDFFC; continue 'dispatch;
	}
	// 822BDFEC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822BDFF0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822BDFF4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822BDFF8: 4800000C  b 0x822be004
	pc = 0x822BE004; continue 'dispatch;
            }
            0x822BDFFC => {
    //   block [0x822BDFFC..0x822BE004)
	// 822BDFFC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822BE000: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822BE004; continue 'dispatch;
            }
            0x822BE004 => {
    //   block [0x822BE004..0x822BE010)
	// 822BE004: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BE008: 4199FFB8  bgt cr6, 0x822bdfc0
	if ctx.cr[6].gt {
	pc = 0x822BDFC0; continue 'dispatch;
	}
	// 822BE00C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822BE010; continue 'dispatch;
            }
            0x822BE010 => {
    //   block [0x822BE010..0x822BE02C)
	// 822BE010: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822BE014: 419A0040  beq cr6, 0x822be054
	if ctx.cr[6].eq {
	pc = 0x822BE054; continue 'dispatch;
	}
	// 822BE018: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE01C: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 822BE020: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BE024: 41990008  bgt cr6, 0x822be02c
	if ctx.cr[6].gt {
	pc = 0x822BE02C; continue 'dispatch;
	}
	// 822BE028: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BE02C; continue 'dispatch;
            }
            0x822BE02C => {
    //   block [0x822BE02C..0x822BE054)
	// 822BE02C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BE030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE034: 409A0020  bne cr6, 0x822be054
	if !ctx.cr[6].eq {
	pc = 0x822BE054; continue 'dispatch;
	}
	// 822BE038: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822BE03C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822BE040: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822BE044: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BE048: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822BE04C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BE050: 4800001C  b 0x822be06c
	pc = 0x822BE06C; continue 'dispatch;
            }
            0x822BE054 => {
    //   block [0x822BE054..0x822BE068)
	// 822BE054: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822BE058: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BE05C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822BE060: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BE064: 48000008  b 0x822be06c
	pc = 0x822BE06C; continue 'dispatch;
            }
            0x822BE068 => {
    //   block [0x822BE068..0x822BE06C)
	// 822BE068: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BE06C; continue 'dispatch;
            }
            0x822BE06C => {
    //   block [0x822BE06C..0x822BE0AC)
	// 822BE06C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BE070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE074: 419A0094  beq cr6, 0x822be108
	if ctx.cr[6].eq {
	pc = 0x822BE108; continue 'dispatch;
	}
	// 822BE078: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE07C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BE080: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 822BE084: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822BE088: 4E800421  bctrl
	ctx.lr = 0x822BE08C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BE08C: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822BE090: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822BE094: 41980018  blt cr6, 0x822be0ac
	if ctx.cr[6].lt {
	pc = 0x822BE0AC; continue 'dispatch;
	}
	// 822BE098: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BE09C: 4BFDA69D  bl 0x82298738
	ctx.lr = 0x822BE0A0;
	sub_82298738(ctx, base);
	// 822BE0A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822BE0A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BE0A8: 409A0008  bne cr6, 0x822be0b0
	if !ctx.cr[6].eq {
	pc = 0x822BE0B0; continue 'dispatch;
	}
            }
            0x822BE0AC => {
    //   block [0x822BE0AC..0x822BE0B0)
	// 822BE0AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BE0B0; continue 'dispatch;
            }
            0x822BE0B0 => {
    //   block [0x822BE0B0..0x822BE0F8)
	// 822BE0B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BE0B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BE0B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE0BC: 419A003C  beq cr6, 0x822be0f8
	if ctx.cr[6].eq {
	pc = 0x822BE0F8; continue 'dispatch;
	}
	// 822BE0C0: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 822BE0C4: 48000635  bl 0x822be6f8
	ctx.lr = 0x822BE0C8;
	sub_822BE6F8(ctx, base);
	// 822BE0C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822BE0CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BE0D0: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 822BE0D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BE0D8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822BE0DC: 4BED5D5D  bl 0x82193e38
	ctx.lr = 0x822BE0E0;
	sub_82193E38(ctx, base);
	// 822BE0E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BE0E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BE0E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BE0EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BE0F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BE0F4: 4E800020  blr
	return;
            }
            0x822BE0F8 => {
    //   block [0x822BE0F8..0x822BE108)
	// 822BE0F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822BE0FC: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 822BE100: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822BE104: 4BED5D35  bl 0x82193e38
	ctx.lr = 0x822BE108;
	sub_82193E38(ctx, base);
	pc = 0x822BE108; continue 'dispatch;
            }
            0x822BE108 => {
    //   block [0x822BE108..0x822BE120)
	// 822BE108: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822BE10C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BE110: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BE114: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BE118: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BE11C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BE120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822BE120 size=196
    let mut pc: u32 = 0x822BE120;
    'dispatch: loop {
        match pc {
            0x822BE120 => {
    //   block [0x822BE120..0x822BE15C)
	// 822BE120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BE124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BE128: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BE12C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BE130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BE134: 4BFD6F7D  bl 0x822950b0
	ctx.lr = 0x822BE138;
	sub_822950B0(ctx, base);
	// 822BE138: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822BE13C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE140: 419A001C  beq cr6, 0x822be15c
	if ctx.cr[6].eq {
	pc = 0x822BE15C; continue 'dispatch;
	}
	// 822BE144: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822BE148: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BE14C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BE150: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BE154: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BE158: 4E800020  blr
	return;
            }
            0x822BE15C => {
    //   block [0x822BE15C..0x822BE198)
	// 822BE15C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 822BE160: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 822BE164: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822BE168: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 822BE16C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BE170: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE174: 4BF6E045  bl 0x8222c1b8
	ctx.lr = 0x822BE178;
	sub_8222C1B8(ctx, base);
	// 822BE178: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822BE17C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822BE180: 419A0018  beq cr6, 0x822be198
	if ctx.cr[6].eq {
	pc = 0x822BE198; continue 'dispatch;
	}
	// 822BE184: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 822BE188: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822BE18C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BE190: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BE194: 409A0008  bne cr6, 0x822be19c
	if !ctx.cr[6].eq {
	pc = 0x822BE19C; continue 'dispatch;
	}
	pc = 0x822BE198; continue 'dispatch;
            }
            0x822BE198 => {
    //   block [0x822BE198..0x822BE19C)
	// 822BE198: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BE19C; continue 'dispatch;
            }
            0x822BE19C => {
    //   block [0x822BE19C..0x822BE1CC)
	// 822BE19C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BE1A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE1A4: 419A0028  beq cr6, 0x822be1cc
	if ctx.cr[6].eq {
	pc = 0x822BE1CC; continue 'dispatch;
	}
	// 822BE1A8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822BE1AC: C03F0050  lfs f1, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822BE1B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BE1B4: 48000035  bl 0x822be1e8
	ctx.lr = 0x822BE1B8;
	sub_822BE1E8(ctx, base);
	// 822BE1B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BE1BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BE1C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BE1C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BE1C8: 4E800020  blr
	return;
            }
            0x822BE1CC => {
    //   block [0x822BE1CC..0x822BE1E4)
	// 822BE1CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822BE1D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BE1D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BE1D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BE1DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BE1E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BE1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BE1E8 size=940
    let mut pc: u32 = 0x822BE1E8;
    'dispatch: loop {
        match pc {
            0x822BE1E8 => {
    //   block [0x822BE1E8..0x822BE25C)
	// 822BE1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BE1EC: 489EB219  bl 0x82ca9404
	ctx.lr = 0x822BE1F0;
	sub_82CA93D0(ctx, base);
	// 822BE1F0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 822BE1F4: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BE1F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822BE1FC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822BE200: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822BE204: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 822BE208: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822BE20C: 897E0029  lbz r11, 0x29(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(41 as u32) ) } as u64;
	// 822BE210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE214: 419A012C  beq cr6, 0x822be340
	if ctx.cr[6].eq {
	pc = 0x822BE340; continue 'dispatch;
	}
	// 822BE218: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BE21C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BE220: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 822BE224: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 822BE228: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822BE22C: 419A00F4  beq cr6, 0x822be320
	if ctx.cr[6].eq {
	pc = 0x822BE320; continue 'dispatch;
	}
	// 822BE230: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822BE234: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BE238: 419A0024  beq cr6, 0x822be25c
	if ctx.cr[6].eq {
	pc = 0x822BE25C; continue 'dispatch;
	}
	// 822BE23C: 894A0083  lbz r10, 0x83(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(131 as u32) ) } as u64;
	// 822BE240: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822BE244: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822BE248: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822BE24C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BE250: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822BE254: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BE258: 480000CC  b 0x822be324
	pc = 0x822BE324; continue 'dispatch;
            }
            0x822BE25C => {
    //   block [0x822BE25C..0x822BE278)
	// 822BE25C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822BE260: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822BE264: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822BE268: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 822BE26C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822BE270: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BE274: 40810054  ble 0x822be2c8
	if !ctx.cr[0].gt {
	pc = 0x822BE2C8; continue 'dispatch;
	}
	pc = 0x822BE278; continue 'dispatch;
            }
            0x822BE278 => {
    //   block [0x822BE278..0x822BE298)
	// 822BE278: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822BE27C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822BE280: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822BE284: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE288: 2F070083  cmpwi cr6, r7, 0x83
	ctx.cr[6].compare_i32(ctx.r[7].s32, 131, &mut ctx.xer);
	// 822BE28C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822BE290: 41980008  blt cr6, 0x822be298
	if ctx.cr[6].lt {
	pc = 0x822BE298; continue 'dispatch;
	}
	// 822BE294: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x822BE298; continue 'dispatch;
            }
            0x822BE298 => {
    //   block [0x822BE298..0x822BE2B4)
	// 822BE298: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822BE29C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822BE2A0: 419A0014  beq cr6, 0x822be2b4
	if ctx.cr[6].eq {
	pc = 0x822BE2B4; continue 'dispatch;
	}
	// 822BE2A4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822BE2A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822BE2AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822BE2B0: 4800000C  b 0x822be2bc
	pc = 0x822BE2BC; continue 'dispatch;
            }
            0x822BE2B4 => {
    //   block [0x822BE2B4..0x822BE2BC)
	// 822BE2B4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822BE2B8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822BE2BC; continue 'dispatch;
            }
            0x822BE2BC => {
    //   block [0x822BE2BC..0x822BE2C8)
	// 822BE2BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BE2C0: 4199FFB8  bgt cr6, 0x822be278
	if ctx.cr[6].gt {
	pc = 0x822BE278; continue 'dispatch;
	}
	// 822BE2C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822BE2C8; continue 'dispatch;
            }
            0x822BE2C8 => {
    //   block [0x822BE2C8..0x822BE2E4)
	// 822BE2C8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 822BE2CC: 419A0040  beq cr6, 0x822be30c
	if ctx.cr[6].eq {
	pc = 0x822BE30C; continue 'dispatch;
	}
	// 822BE2D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE2D4: 2F0B0083  cmpwi cr6, r11, 0x83
	ctx.cr[6].compare_i32(ctx.r[11].s32, 131, &mut ctx.xer);
	// 822BE2D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BE2DC: 41990008  bgt cr6, 0x822be2e4
	if ctx.cr[6].gt {
	pc = 0x822BE2E4; continue 'dispatch;
	}
	// 822BE2E0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822BE2E4; continue 'dispatch;
            }
            0x822BE2E4 => {
    //   block [0x822BE2E4..0x822BE30C)
	// 822BE2E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BE2E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE2EC: 409A0020  bne cr6, 0x822be30c
	if !ctx.cr[6].eq {
	pc = 0x822BE30C; continue 'dispatch;
	}
	// 822BE2F0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822BE2F4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822BE2F8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822BE2FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BE300: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822BE304: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BE308: 4800001C  b 0x822be324
	pc = 0x822BE324; continue 'dispatch;
            }
            0x822BE30C => {
    //   block [0x822BE30C..0x822BE320)
	// 822BE30C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 822BE310: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BE314: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822BE318: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BE31C: 48000008  b 0x822be324
	pc = 0x822BE324; continue 'dispatch;
            }
            0x822BE320 => {
    //   block [0x822BE320..0x822BE324)
	// 822BE320: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822BE324; continue 'dispatch;
            }
            0x822BE324 => {
    //   block [0x822BE324..0x822BE340)
	// 822BE324: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BE328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE32C: 419A0014  beq cr6, 0x822be340
	if ctx.cr[6].eq {
	pc = 0x822BE340; continue 'dispatch;
	}
	// 822BE330: 4831F099  bl 0x825dd3c8
	ctx.lr = 0x822BE334;
	sub_825DD3C8(ctx, base);
	// 822BE334: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822BE338: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE33C: 409A0248  bne cr6, 0x822be584
	if !ctx.cr[6].eq {
	pc = 0x822BE584; continue 'dispatch;
	}
	pc = 0x822BE340; continue 'dispatch;
            }
            0x822BE340 => {
    //   block [0x822BE340..0x822BE584)
	// 822BE340: 809C007C  lwz r4, 0x7c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(124 as u32) ) } as u64;
	// 822BE344: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822BE348: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE34C: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 822BE350: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822BE354: 4E800421  bctrl
	ctx.lr = 0x822BE358;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BE358: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BE35C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822BE360: 8089007C  lwz r4, 0x7c(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 822BE364: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE368: 80E80040  lwz r7, 0x40(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 822BE36C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 822BE370: 4E800421  bctrl
	ctx.lr = 0x822BE374;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BE374: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 822BE378: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 822BE37C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BE380: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            0x822BE584 => {
    //   block [0x822BE584..0x822BE594)
	// 822BE584: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822BE588: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 822BE58C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822BE590: 489EAEC4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BE598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822BE598 size=92
    let mut pc: u32 = 0x822BE598;
    'dispatch: loop {
        match pc {
            0x822BE598 => {
    //   block [0x822BE598..0x822BE5AC)
	// 822BE598: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE59C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BE5A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BE5A4: 41990008  bgt cr6, 0x822be5ac
	if ctx.cr[6].gt {
	pc = 0x822BE5AC; continue 'dispatch;
	}
	// 822BE5A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BE5AC; continue 'dispatch;
            }
            0x822BE5AC => {
    //   block [0x822BE5AC..0x822BE5C8)
	// 822BE5AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BE5B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE5B4: 419A0014  beq cr6, 0x822be5c8
	if ctx.cr[6].eq {
	pc = 0x822BE5C8; continue 'dispatch;
	}
	// 822BE5B8: 89630005  lbz r11, 5(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(5 as u32) ) } as u64;
	// 822BE5BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE5C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BE5C4: 419A0008  beq cr6, 0x822be5cc
	if ctx.cr[6].eq {
	pc = 0x822BE5CC; continue 'dispatch;
	}
	pc = 0x822BE5C8; continue 'dispatch;
            }
            0x822BE5C8 => {
    //   block [0x822BE5C8..0x822BE5CC)
	// 822BE5C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BE5CC; continue 'dispatch;
            }
            0x822BE5CC => {
    //   block [0x822BE5CC..0x822BE5E8)
	// 822BE5CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BE5D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE5D4: 409A0014  bne cr6, 0x822be5e8
	if !ctx.cr[6].eq {
	pc = 0x822BE5E8; continue 'dispatch;
	}
	// 822BE5D8: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BE5DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE5E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BE5E4: 409A0008  bne cr6, 0x822be5ec
	if !ctx.cr[6].eq {
	pc = 0x822BE5EC; continue 'dispatch;
	}
	pc = 0x822BE5E8; continue 'dispatch;
            }
            0x822BE5E8 => {
    //   block [0x822BE5E8..0x822BE5EC)
	// 822BE5E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BE5EC; continue 'dispatch;
            }
            0x822BE5EC => {
    //   block [0x822BE5EC..0x822BE5F4)
	// 822BE5EC: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BE5F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BE5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BE5F8 size=256
    let mut pc: u32 = 0x822BE5F8;
    'dispatch: loop {
        match pc {
            0x822BE5F8 => {
    //   block [0x822BE5F8..0x822BE630)
	// 822BE5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BE5FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BE600: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BE604: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 822BE608: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BE60C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822BE610: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822BE614: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822BE618: 419A0018  beq cr6, 0x822be630
	if ctx.cr[6].eq {
	pc = 0x822BE630; continue 'dispatch;
	}
	// 822BE61C: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 822BE620: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822BE624: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BE628: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BE62C: 409A0008  bne cr6, 0x822be634
	if !ctx.cr[6].eq {
	pc = 0x822BE634; continue 'dispatch;
	}
	pc = 0x822BE630; continue 'dispatch;
            }
            0x822BE630 => {
    //   block [0x822BE630..0x822BE634)
	// 822BE630: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BE634; continue 'dispatch;
            }
            0x822BE634 => {
    //   block [0x822BE634..0x822BE65C)
	// 822BE634: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BE638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE63C: 419A00A0  beq cr6, 0x822be6dc
	if ctx.cr[6].eq {
	pc = 0x822BE6DC; continue 'dispatch;
	}
	// 822BE640: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 822BE644: 419A0018  beq cr6, 0x822be65c
	if ctx.cr[6].eq {
	pc = 0x822BE65C; continue 'dispatch;
	}
	// 822BE648: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 822BE64C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822BE650: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BE654: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BE658: 409A0008  bne cr6, 0x822be660
	if !ctx.cr[6].eq {
	pc = 0x822BE660; continue 'dispatch;
	}
	pc = 0x822BE65C; continue 'dispatch;
            }
            0x822BE65C => {
    //   block [0x822BE65C..0x822BE660)
	// 822BE65C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BE660; continue 'dispatch;
            }
            0x822BE660 => {
    //   block [0x822BE660..0x822BE6DC)
	// 822BE660: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BE664: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE668: 419A0074  beq cr6, 0x822be6dc
	if ctx.cr[6].eq {
	pc = 0x822BE6DC; continue 'dispatch;
	}
	// 822BE66C: 8085007C  lwz r4, 0x7c(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(124 as u32) ) } as u64;
	// 822BE670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BE674: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE678: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 822BE67C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822BE680: 4E800421  bctrl
	ctx.lr = 0x822BE684;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BE684: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 822BE688: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822BE68C: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE690: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 822BE694: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 822BE698: 4E800421  bctrl
	ctx.lr = 0x822BE69C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BE69C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 822BE6A0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822BE6A4: EC1F07F2  fmuls f0, f31, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[31].f64) as f32) as f64);
	// 822BE6A8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822BE6AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
            }
            0x822BE6DC => {
    //   block [0x822BE6DC..0x822BE6F8)
	// 822BE6DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822BE6E0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822BE6E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BE6E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BE6EC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822BE6F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BE6F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BE6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BE6F8 size=84
    let mut pc: u32 = 0x822BE6F8;
    'dispatch: loop {
        match pc {
            0x822BE6F8 => {
    //   block [0x822BE6F8..0x822BE734)
	// 822BE6F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BE6FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BE700: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BE704: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BE708: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822BE70C: 4BFDA02D  bl 0x82298738
	ctx.lr = 0x822BE710;
	sub_82298738(ctx, base);
	// 822BE710: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822BE714: 419A0020  beq cr6, 0x822be734
	if ctx.cr[6].eq {
	pc = 0x822BE734; continue 'dispatch;
	}
	// 822BE718: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822BE71C: 4BF1C945  bl 0x821db060
	ctx.lr = 0x822BE720;
	sub_821DB060(ctx, base);
	// 822BE720: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822BE724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BE728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BE72C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BE730: 4E800020  blr
	return;
            }
            0x822BE734 => {
    //   block [0x822BE734..0x822BE74C)
	// 822BE734: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822BE738: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822BE73C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BE740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BE744: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BE748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BE750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822BE750 size=68
    let mut pc: u32 = 0x822BE750;
    'dispatch: loop {
        match pc {
            0x822BE750 => {
    //   block [0x822BE750..0x822BE78C)
	// 822BE750: 814300D0  lwz r10, 0xd0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 822BE754: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822BE758: 40990034  ble cr6, 0x822be78c
	if !ctx.cr[6].gt {
	pc = 0x822BE78C; continue 'dispatch;
	}
	// 822BE75C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822BE760: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 822BE764: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822BE768: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 822BE76C: C8099660  lfd f0, -0x69a0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-27040 as u32) ) };
	// 822BE770: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822BE774: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 822BE778: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 822BE77C: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BE780: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 822BE784: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 822BE788: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	pc = 0x822BE78C; continue 'dispatch;
            }
            0x822BE78C => {
    //   block [0x822BE78C..0x822BE794)
	// 822BE78C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822BE790: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BE798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BE798 size=116
    let mut pc: u32 = 0x822BE798;
    'dispatch: loop {
        match pc {
            0x822BE798 => {
    //   block [0x822BE798..0x822BE7F4)
	// 822BE798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BE79C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BE7A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BE7A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BE7A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BE7AC: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822BE7B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE7B4: 419A0040  beq cr6, 0x822be7f4
	if ctx.cr[6].eq {
	pc = 0x822BE7F4; continue 'dispatch;
	}
	// 822BE7B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BE7BC: 4BF6026D  bl 0x8221ea28
	ctx.lr = 0x822BE7C0;
	sub_8221EA28(ctx, base);
	// 822BE7C0: 3D60000F  lis r11, 0xf
	ctx.r[11].s64 = 983040;
	// 822BE7C4: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822BE7C8: 616A4240  ori r10, r11, 0x4240
	ctx.r[10].u64 = ctx.r[11].u64 | 16960;
	// 822BE7CC: E91F0010  ld r8, 0x10(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 822BE7D0: E8DF0008  ld r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 822BE7D4: 7CE951D2  mulld r7, r9, r10
	ctx.r[7].s64 = ctx.r[9].s64 * ctx.r[10].s64;
	// 822BE7D8: 7CA743D2  divd r5, r7, r8
	ctx.r[5].s64 = ctx.r[7].s64 / ctx.r[8].s64;
	// 822BE7DC: 7C662850  subf r3, r6, r5
	ctx.r[3].s64 = ctx.r[5].s64 - ctx.r[6].s64;
	// 822BE7E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BE7E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BE7E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BE7EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BE7F0: 4E800020  blr
	return;
            }
            0x822BE7F4 => {
    //   block [0x822BE7F4..0x822BE80C)
	// 822BE7F4: E87F0008  ld r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 822BE7F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BE7FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BE800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BE804: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BE808: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BE810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BE810 size=80
    let mut pc: u32 = 0x822BE810;
    'dispatch: loop {
        match pc {
            0x822BE810 => {
    //   block [0x822BE810..0x822BE860)
	// 822BE810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BE814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BE818: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BE81C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE820: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822BE824: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822BE828: 4E800421  bctrl
	ctx.lr = 0x822BE82C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BE82C: F8610050  std r3, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u64 ) };
	// 822BE830: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822BE834: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 822BE838: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 822BE83C: C8090DA0  lfd f0, 0xda0(r9)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3488 as u32) ) };
	// 822BE840: FD8D0032  fmul f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 822BE844: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 822BE848: D9610050  stfd f11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[11].u64 ) };
	// 822BE84C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822BE850: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822BE854: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BE858: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BE85C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BE860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BE860 size=220
    let mut pc: u32 = 0x822BE860;
    'dispatch: loop {
        match pc {
            0x822BE860 => {
    //   block [0x822BE860..0x822BE8C4)
	// 822BE860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BE864: 489EABA9  bl 0x82ca940c
	ctx.lr = 0x822BE868;
	sub_82CA93D0(ctx, base);
	// 822BE868: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BE86C: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 822BE870: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BE874: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BE878: 419A004C  beq cr6, 0x822be8c4
	if ctx.cr[6].eq {
	pc = 0x822BE8C4; continue 'dispatch;
	}
	// 822BE87C: 807F0208  lwz r3, 0x208(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 822BE880: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 822BE884: 817F020C  lwz r11, 0x20c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 822BE888: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE88C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE890: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BE894: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822BE898: 4E800421  bctrl
	ctx.lr = 0x822BE89C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BE89C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822BE8A0: 809F020C  lwz r4, 0x20c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 822BE8A4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822BE8A8: 811D001C  lwz r8, 0x1c(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 822BE8AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BE8B0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 822BE8B4: 4E800421  bctrl
	ctx.lr = 0x822BE8B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BE8B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822BE8BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BE8C0: 480116A9  bl 0x822cff68
	ctx.lr = 0x822BE8C4;
	sub_822CFF68(ctx, base);
            }
            0x822BE8C4 => {
    //   block [0x822BE8C4..0x822BE900)
	// 822BE8C4: 807F0248  lwz r3, 0x248(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 822BE8C8: 48011441  bl 0x822cfd08
	ctx.lr = 0x822BE8CC;
	sub_822CFD08(ctx, base);
	// 822BE8CC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BE8D0: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 822BE8D4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822BE8D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822BE8DC: 4E800421  bctrl
	ctx.lr = 0x822BE8E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BE8E0: 813F0050  lwz r9, 0x50(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 822BE8E4: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 822BE8E8: 83FF0048  lwz r31, 0x48(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 822BE8EC: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822BE8F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822BE8F4: 7D0BFA14  add r8, r11, r31
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 822BE8F8: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822BE8FC: 419A0038  beq cr6, 0x822be934
	if ctx.cr[6].eq {
	pc = 0x822BE934; continue 'dispatch;
	}
            }
            0x822BE900 => {
    //   block [0x822BE900..0x822BE934)
	// 822BE900: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE904: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822BE908: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE90C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BE910: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822BE914: 4E800421  bctrl
	ctx.lr = 0x822BE918;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BE918: 813E0028  lwz r9, 0x28(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 822BE91C: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BE920: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822BE924: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822BE928: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822BE92C: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822BE930: 409AFFD0  bne cr6, 0x822be900
	if !ctx.cr[6].eq {
	pc = 0x822BE900; continue 'dispatch;
	}
            }
            0x822BE934 => {
    //   block [0x822BE934..0x822BE93C)
	// 822BE934: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 822BE938: 489EAB24  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BE940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822BE940 size=8
    let mut pc: u32 = 0x822BE940;
    'dispatch: loop {
        match pc {
            0x822BE940 => {
    //   block [0x822BE940..0x822BE948)
	// 822BE940: 80630078  lwz r3, 0x78(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 822BE944: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BE948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BE948 size=140
    let mut pc: u32 = 0x822BE948;
    'dispatch: loop {
        match pc {
            0x822BE948 => {
    //   block [0x822BE948..0x822BE9A0)
	// 822BE948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BE94C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BE950: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822BE954: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BE958: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BE95C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822BE960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BE964: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BE968: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE96C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 822BE970: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822BE974: 4E800421  bctrl
	ctx.lr = 0x822BE978;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BE978: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822BE97C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BE980: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822BE984: 419A001C  beq cr6, 0x822be9a0
	if ctx.cr[6].eq {
	pc = 0x822BE9A0; continue 'dispatch;
	}
	// 822BE988: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 822BE98C: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BE990: 80AB003C  lwz r5, 0x3c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 822BE994: 480D2C05  bl 0x82391598
	ctx.lr = 0x822BE998;
	sub_82391598(ctx, base);
	// 822BE998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BE99C: 48000020  b 0x822be9bc
	pc = 0x822BE9BC; continue 'dispatch;
            }
            0x822BE9A0 => {
    //   block [0x822BE9A0..0x822BE9BC)
	// 822BE9A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822BE9A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822BE9A8: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 822BE9AC: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 822BE9B0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822BE9B4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822BE9B8: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x822BE9BC; continue 'dispatch;
            }
            0x822BE9BC => {
    //   block [0x822BE9BC..0x822BE9D4)
	// 822BE9BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BE9C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BE9C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BE9C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822BE9CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BE9D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BE9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BE9D8 size=232
    let mut pc: u32 = 0x822BE9D8;
    'dispatch: loop {
        match pc {
            0x822BE9D8 => {
    //   block [0x822BE9D8..0x822BEA1C)
	// 822BE9D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BE9DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BE9E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BE9E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BE9E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822BE9EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BE9F0: 814B0070  lwz r10, 0x70(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 822BE9F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822BE9F8: 4E800421  bctrl
	ctx.lr = 0x822BE9FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BE9FC: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822BEA00: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822BEA04: 41980018  blt cr6, 0x822bea1c
	if ctx.cr[6].lt {
	pc = 0x822BEA1C; continue 'dispatch;
	}
	// 822BEA08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BEA0C: 4BFD9D2D  bl 0x82298738
	ctx.lr = 0x822BEA10;
	sub_82298738(ctx, base);
	// 822BEA10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822BEA14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BEA18: 409A0008  bne cr6, 0x822bea20
	if !ctx.cr[6].eq {
	pc = 0x822BEA20; continue 'dispatch;
	}
            }
            0x822BEA1C => {
    //   block [0x822BEA1C..0x822BEA20)
	// 822BEA1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BEA20; continue 'dispatch;
            }
            0x822BEA20 => {
    //   block [0x822BEA20..0x822BEA98)
	// 822BEA20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BEA24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BEA28: 419A0070  beq cr6, 0x822bea98
	if ctx.cr[6].eq {
	pc = 0x822BEA98; continue 'dispatch;
	}
	// 822BEA2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BEA30: 480089F9  bl 0x822c7428
	ctx.lr = 0x822BEA34;
	sub_822C7428(ctx, base);
	// 822BEA34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BEA38: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822BEA3C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822BEA40: 4E800421  bctrl
	ctx.lr = 0x822BEA44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BEA44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822BEA48: 419A0050  beq cr6, 0x822bea98
	if ctx.cr[6].eq {
	pc = 0x822BEA98; continue 'dispatch;
	}
	// 822BEA4C: 89630051  lbz r11, 0x51(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(81 as u32) ) } as u64;
	// 822BEA50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BEA54: 419A0044  beq cr6, 0x822bea98
	if ctx.cr[6].eq {
	pc = 0x822BEA98; continue 'dispatch;
	}
	// 822BEA58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BEA5C: 480089CD  bl 0x822c7428
	ctx.lr = 0x822BEA60;
	sub_822C7428(ctx, base);
	// 822BEA60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BEA64: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822BEA68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822BEA6C: 4E800421  bctrl
	ctx.lr = 0x822BEA70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BEA70: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 822BEA74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BEA78: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 822BEA7C: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 822BEA80: 4BED53B9  bl 0x82193e38
	ctx.lr = 0x822BEA84;
	sub_82193E38(ctx, base);
	// 822BEA84: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822BEA88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BEA8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BEA90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BEA94: 4E800020  blr
	return;
            }
            0x822BEA98 => {
    //   block [0x822BEA98..0x822BEAC0)
	// 822BEA98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822BEA9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BEAA0: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 822BEAA4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822BEAA8: 4BED5391  bl 0x82193e38
	ctx.lr = 0x822BEAAC;
	sub_82193E38(ctx, base);
	// 822BEAAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822BEAB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BEAB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BEAB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BEABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BEAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BEAC0 size=184
    let mut pc: u32 = 0x822BEAC0;
    'dispatch: loop {
        match pc {
            0x822BEAC0 => {
    //   block [0x822BEAC0..0x822BEB34)
	// 822BEAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BEAC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BEAC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822BEACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BEAD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BEAD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BEAD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BEADC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BEAE0: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 822BEAE4: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BEAE8: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 822BEAEC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822BEAF0: 4E800421  bctrl
	ctx.lr = 0x822BEAF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BEAF4: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 822BEAF8: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 822BEAFC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822BEB00: 40990034  ble cr6, 0x822beb34
	if !ctx.cr[6].gt {
	pc = 0x822BEB34; continue 'dispatch;
	}
	// 822BEB04: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            0x822BEB34 => {
    //   block [0x822BEB34..0x822BEB78)
	// 822BEB34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BEB38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BEB3C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BEB40: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822BEB44: 4E800421  bctrl
	ctx.lr = 0x822BEB48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BEB48: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 822BEB4C: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 822BEB50: 7CE34214  add r7, r3, r8
	ctx.r[7].u64 = ctx.r[3].u64 + ctx.r[8].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BEB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BEB78 size=304
    let mut pc: u32 = 0x822BEB78;
    'dispatch: loop {
        match pc {
            0x822BEB78 => {
    //   block [0x822BEB78..0x822BEBAC)
	// 822BEB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BEB7C: 489EA87D  bl 0x82ca93f8
	ctx.lr = 0x822BEB80;
	sub_82CA93D0(ctx, base);
	// 822BEB80: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BEB84: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 822BEB88: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822BEB8C: 3B8BE8D8  addi r28, r11, -0x1728
	ctx.r[28].s64 = ctx.r[11].s64 + -5928;
	// 822BEB90: 7F58D378  mr r24, r26
	ctx.r[24].u64 = ctx.r[26].u64;
	// 822BEB94: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BEB98: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BEB9C: 7D684850  subf r11, r8, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822BEBA0: 7D791671  srawi. r25, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[25].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 822BEBA4: 408100FC  ble 0x822beca0
	if !ctx.cr[0].gt {
	pc = 0x822BECA0; continue 'dispatch;
	}
	// 822BEBA8: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	pc = 0x822BEBAC; continue 'dispatch;
            }
            0x822BEBAC => {
    //   block [0x822BEBAC..0x822BEBCC)
	// 822BEBAC: 7FBB402E  lwzx r29, r27, r8
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 822BEBB0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 822BEBB4: 897D0028  lbz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 822BEBB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BEBBC: 419A0090  beq cr6, 0x822bec4c
	if ctx.cr[6].eq {
	pc = 0x822BEC4C; continue 'dispatch;
	}
	// 822BEBC0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822BEBC4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 822BEBC8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x822BEBCC; continue 'dispatch;
            }
            0x822BEBCC => {
    //   block [0x822BEBCC..0x822BEBEC)
	// 822BEBCC: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BEBD0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 822BEBD4: 419A0018  beq cr6, 0x822bebec
	if ctx.cr[6].eq {
	pc = 0x822BEBEC; continue 'dispatch;
	}
	// 822BEBD8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822BEBDC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822BEBE0: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 822BEBE4: 4198FFE8  blt cr6, 0x822bebcc
	if ctx.cr[6].lt {
	pc = 0x822BEBCC; continue 'dispatch;
	}
	// 822BEBE8: 48000008  b 0x822bebf0
	pc = 0x822BEBF0; continue 'dispatch;
            }
            0x822BEBEC => {
    //   block [0x822BEBEC..0x822BEBF0)
	// 822BEBEC: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x822BEBF0; continue 'dispatch;
            }
            0x822BEBF0 => {
    //   block [0x822BEBF0..0x822BEC04)
	// 822BEBF0: 54EB063E  clrlwi r11, r7, 0x18
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822BEBF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BEBF8: 419A0054  beq cr6, 0x822bec4c
	if ctx.cr[6].eq {
	pc = 0x822BEC4C; continue 'dispatch;
	}
	// 822BEBFC: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 822BEC00: 3BC00005  li r30, 5
	ctx.r[30].s64 = 5;
	pc = 0x822BEC04; continue 'dispatch;
            }
            0x822BEC04 => {
    //   block [0x822BEC04..0x822BEC28)
	// 822BEC04: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BEC08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822BEC0C: 419A001C  beq cr6, 0x822bec28
	if ctx.cr[6].eq {
	pc = 0x822BEC28; continue 'dispatch;
	}
	// 822BEC10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BEC14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822BEC18: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BEC1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822BEC20: 4E800421  bctrl
	ctx.lr = 0x822BEC24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BEC24: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
            }
            0x822BEC28 => {
    //   block [0x822BEC28..0x822BEC4C)
	// 822BEC28: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822BEC2C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 822BEC30: 4082FFD4  bne 0x822bec04
	if !ctx.cr[0].eq {
	pc = 0x822BEC04; continue 'dispatch;
	}
	// 822BEC34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822BEC38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822BEC3C: 4892BDC5  bl 0x82beaa00
	ctx.lr = 0x822BEC40;
	sub_82BEAA00(ctx, base);
	// 822BEC40: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BEC44: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BEC48: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	pc = 0x822BEC4C; continue 'dispatch;
            }
            0x822BEC4C => {
    //   block [0x822BEC4C..0x822BEC88)
	// 822BEC4C: 54CB063E  clrlwi r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 822BEC50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BEC54: 419A003C  beq cr6, 0x822bec90
	if ctx.cr[6].eq {
	pc = 0x822BEC90; continue 'dispatch;
	}
	// 822BEC58: 8169FFFC  lwz r11, -4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822BEC5C: 3949FFFC  addi r10, r9, -4
	ctx.r[10].s64 = ctx.r[9].s64 + -4;
	// 822BEC60: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822BEC64: 7D7B412E  stwx r11, r27, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 822BEC68: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BEC6C: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BEC70: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822BEC74: 54E6003A  rlwinm r6, r7, 0, 0, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 822BEC78: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 822BEC7C: 419A000C  beq cr6, 0x822bec88
	if ctx.cr[6].eq {
	pc = 0x822BEC88; continue 'dispatch;
	}
	// 822BEC80: 3929FFFC  addi r9, r9, -4
	ctx.r[9].s64 = ctx.r[9].s64 + -4;
	// 822BEC84: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x822BEC88; continue 'dispatch;
            }
            0x822BEC88 => {
    //   block [0x822BEC88..0x822BEC90)
	// 822BEC88: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 822BEC8C: 4800000C  b 0x822bec98
	pc = 0x822BEC98; continue 'dispatch;
            }
            0x822BEC90 => {
    //   block [0x822BEC90..0x822BEC98)
	// 822BEC90: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 822BEC94: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	pc = 0x822BEC98; continue 'dispatch;
            }
            0x822BEC98 => {
    //   block [0x822BEC98..0x822BECA0)
	// 822BEC98: 7F18C800  cmpw cr6, r24, r25
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[25].s32, &mut ctx.xer);
	// 822BEC9C: 4198FF10  blt cr6, 0x822bebac
	if ctx.cr[6].lt {
	pc = 0x822BEBAC; continue 'dispatch;
	}
	pc = 0x822BECA0; continue 'dispatch;
            }
            0x822BECA0 => {
    //   block [0x822BECA0..0x822BECA8)
	// 822BECA0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822BECA4: 489EA7A4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BECA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BECA8 size=224
    let mut pc: u32 = 0x822BECA8;
    'dispatch: loop {
        match pc {
            0x822BECA8 => {
    //   block [0x822BECA8..0x822BECD8)
	// 822BECA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BECAC: 489EA761  bl 0x82ca940c
	ctx.lr = 0x822BECB0;
	sub_82CA93D0(ctx, base);
	// 822BECB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BECB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822BECB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822BECBC: 388B8D30  addi r4, r11, -0x72d0
	ctx.r[4].s64 = ctx.r[11].s64 + -29392;
	// 822BECC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BECC4: 4BF41AAD  bl 0x82200770
	ctx.lr = 0x822BECC8;
	sub_82200770(ctx, base);
	// 822BECC8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822BECCC: 3BABA9D0  addi r29, r11, -0x5630
	ctx.r[29].s64 = ctx.r[11].s64 + -22064;
	// 822BECD0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BECD4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822BECD8; continue 'dispatch;
            }
            0x822BECD8 => {
    //   block [0x822BECD8..0x822BECEC)
	// 822BECD8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822BECDC: 419A0044  beq cr6, 0x822bed20
	if ctx.cr[6].eq {
	pc = 0x822BED20; continue 'dispatch;
	}
	// 822BECE0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BECE4: 409A0008  bne cr6, 0x822becec
	if !ctx.cr[6].eq {
	pc = 0x822BECEC; continue 'dispatch;
	}
	// 822BECE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822BECEC; continue 'dispatch;
            }
            0x822BECEC => {
    //   block [0x822BECEC..0x822BED00)
	// 822BECEC: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822BECF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822BECF4: 419A000C  beq cr6, 0x822bed00
	if ctx.cr[6].eq {
	pc = 0x822BED00; continue 'dispatch;
	}
	// 822BECF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822BECFC: 48BF0F85  bl 0x82eafc80
	ctx.lr = 0x822BED00;
	sub_82EAFC80(ctx, base);
	pc = 0x822BED00; continue 'dispatch;
            }
            0x822BED00 => {
    //   block [0x822BED00..0x822BED18)
	// 822BED00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BED04: 48BF0F95  bl 0x82eafc98
	ctx.lr = 0x822BED08;
	sub_82EAFC98(ctx, base);
	// 822BED08: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BED0C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822BED10: 409A0008  bne cr6, 0x822bed18
	if !ctx.cr[6].eq {
	pc = 0x822BED18; continue 'dispatch;
	}
	// 822BED14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822BED18; continue 'dispatch;
            }
            0x822BED18 => {
    //   block [0x822BED18..0x822BED20)
	// 822BED18: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BED1C: 4BFFFFBC  b 0x822becd8
	pc = 0x822BECD8; continue 'dispatch;
            }
            0x822BED20 => {
    //   block [0x822BED20..0x822BED38)
	// 822BED20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822BED24: 4BEB41B5  bl 0x82172ed8
	ctx.lr = 0x822BED28;
	sub_82172ED8(ctx, base);
	// 822BED28: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 822BED2C: 3BCBA9DC  addi r30, r11, -0x5624
	ctx.r[30].s64 = ctx.r[11].s64 + -22052;
	// 822BED30: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BED34: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x822BED38; continue 'dispatch;
            }
            0x822BED38 => {
    //   block [0x822BED38..0x822BED58)
	// 822BED38: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822BED3C: 419A0024  beq cr6, 0x822bed60
	if ctx.cr[6].eq {
	pc = 0x822BED60; continue 'dispatch;
	}
	// 822BED40: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 822BED44: 483B348D  bl 0x826721d0
	ctx.lr = 0x822BED48;
	sub_826721D0(ctx, base);
	// 822BED48: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BED4C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822BED50: 409A0008  bne cr6, 0x822bed58
	if !ctx.cr[6].eq {
	pc = 0x822BED58; continue 'dispatch;
	}
	// 822BED54: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x822BED58; continue 'dispatch;
            }
            0x822BED58 => {
    //   block [0x822BED58..0x822BED60)
	// 822BED58: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BED5C: 4BFFFFDC  b 0x822bed38
	pc = 0x822BED38; continue 'dispatch;
            }
            0x822BED60 => {
    //   block [0x822BED60..0x822BED80)
	// 822BED60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BED64: 4801608D  bl 0x822d4df0
	ctx.lr = 0x822BED68;
	sub_822D4DF0(ctx, base);
	// 822BED68: 4BEB92E1  bl 0x82178048
	ctx.lr = 0x822BED6C;
	sub_82178048(ctx, base);
	// 822BED6C: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822BED70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BED74: 419A000C  beq cr6, 0x822bed80
	if ctx.cr[6].eq {
	pc = 0x822BED80; continue 'dispatch;
	}
	// 822BED78: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822BED7C: 48FFABD9  bl 0x832b9954
	ctx.lr = 0x822BED80;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x822BED80; continue 'dispatch;
            }
            0x822BED80 => {
    //   block [0x822BED80..0x822BED88)
	// 822BED80: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822BED84: 489EA6D8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BED88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822BED88 size=1732
    let mut pc: u32 = 0x822BED88;
    'dispatch: loop {
        match pc {
            0x822BED88 => {
    //   block [0x822BED88..0x822BF2D8)
	// 822BED88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BED8C: 489EA661  bl 0x82ca93ec
	ctx.lr = 0x822BED90;
	sub_82CA93D0(ctx, base);
	// 822BED90: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822BED94: 419A06B4  beq cr6, 0x822bf448
	if ctx.cr[6].eq {
	pc = 0x822BF448; continue 'dispatch;
	}
	// 822BED98: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822BED9C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 822BEDA0: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 822BEDA4: 39040004  addi r8, r4, 4
	ctx.r[8].s64 = ctx.r[4].s64 + 4;
	// 822BEDA8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822BEDAC: C00BA938  lfs f0, -0x56c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BEDB0: 2F050004  cmpwi cr6, r5, 4
	ctx.cr[6].compare_i32(ctx.r[5].s32, 4, &mut ctx.xer);
	// 822BEDB4: 41980524  blt cr6, 0x822bf2d8
	if ctx.cr[6].lt {
	pc = 0x822BF2D8; continue 'dispatch;
	}
	// 822BEDB8: 3965FFFC  addi r11, r5, -4
	ctx.r[11].s64 = ctx.r[5].s64 + -4;
	// 822BEDBC: D001FEB4  stfs f0, -0x14c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-332 as u32), tmp.u32 ) };
	// 822BEDC0: 20830008  subfic r4, r3, 8
	ctx.xer.ca = ctx.r[3].u32 <= 8 as u32;
	ctx.r[4].s64 = (8 as i64) - ctx.r[3].s64;
	// 822BEDC4: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822BEDC8: 23E30038  subfic r31, r3, 0x38
	ctx.xer.ca = ctx.r[3].u32 <= 56 as u32;
	ctx.r[31].s64 = (56 as i64) - ctx.r[3].s64;
	// 822BEDCC: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 822BEDD0: 39630058  addi r11, r3, 0x58
	ctx.r[11].s64 = ctx.r[3].s64 + 88;
	// 822BEDD4: 2383FFA8  subfic r28, r3, -0x58
	ctx.xer.ca = ctx.r[3].u32 <= -88 as u32;
	ctx.r[28].s64 = (-88 as i64) - ctx.r[3].s64;
	// 822BEDD8: 57BE103A  slwi r30, r29, 2
	ctx.r[30].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 822BEDDC: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BEDE0: 7D2BE214  add r9, r11, r28
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 822BEDE4: 3B61FF00  addi r27, r1, -0x100
	ctx.r[27].s64 = ctx.r[1].s64 + -256;
	// 822BEDE8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822BEDEC: 3B41FEE0  addi r26, r1, -0x120
	ctx.r[26].s64 = ctx.r[1].s64 + -288;
	// 822BEDF0: 3B21FF60  addi r25, r1, -0xa0
	ctx.r[25].s64 = ctx.r[1].s64 + -160;
	// 822BEDF4: 3B01FF20  addi r24, r1, -0xe0
	ctx.r[24].s64 = ctx.r[1].s64 + -224;
	// 822BEDF8: 3AE1FF80  addi r23, r1, -0x80
	ctx.r[23].s64 = ctx.r[1].s64 + -128;
	pc = 0x822BF2D8; continue 'dispatch;
            }
            0x822BF2D8 => {
    //   block [0x822BF2D8..0x822BF448)
	// 822BF2D8: 7F1E2800  cmpw cr6, r30, r5
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[5].s32, &mut ctx.xer);
	// 822BF2DC: 4098016C  bge cr6, 0x822bf448
	if !ctx.cr[6].lt {
	pc = 0x822BF448; continue 'dispatch;
	}
	// 822BF2E0: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822BF2E4: D001FEB4  stfs f0, -0x14c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-332 as u32), tmp.u32 ) };
	// 822BF2E8: 2123FFD8  subfic r9, r3, -0x28
	ctx.xer.ca = ctx.r[3].u32 <= -40 as u32;
	ctx.r[9].s64 = (-40 as i64) - ctx.r[3].s64;
	// 822BF2EC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 822BF2F0: 7CBE2850  subf r5, r30, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[30].s64;
	// 822BF2F4: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822BF2F8: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822BF2FC: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 822BF300: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BF304: 3BE1FEE0  addi r31, r1, -0x120
	ctx.r[31].s64 = ctx.r[1].s64 + -288;
	// 822BF308: 3BC1FF60  addi r30, r1, -0xa0
	ctx.r[30].s64 = ctx.r[1].s64 + -160;
	// 822BF30C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 822BF310: 3881FF20  addi r4, r1, -0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + -224;
	// 822BF314: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822BF318: 3BA1FF00  addi r29, r1, -0x100
	ctx.r[29].s64 = ctx.r[1].s64 + -256;
	// 822BF31C: 3861FF80  addi r3, r1, -0x80
	ctx.r[3].s64 = ctx.r[1].s64 + -128;
	pc = 0x822BF448; continue 'dispatch;
            }
            0x822BF448 => {
    //   block [0x822BF448..0x822BF44C)
	// 822BF448: 489E9FF4  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BF450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BF450 size=56
    let mut pc: u32 = 0x822BF450;
    'dispatch: loop {
        match pc {
            0x822BF450 => {
    //   block [0x822BF450..0x822BF488)
	// 822BF450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BF454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BF458: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BF45C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 822BF460: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822BF464: 4BF68C95  bl 0x822280f8
	ctx.lr = 0x822BF468;
	sub_822280F8(ctx, base);
	// 822BF468: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822BF46C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BF470: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BF474: 4BEFB48D  bl 0x821ba900
	ctx.lr = 0x822BF478;
	sub_821BA900(ctx, base);
	// 822BF478: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822BF47C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BF480: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BF484: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BF488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BF488 size=164
    let mut pc: u32 = 0x822BF488;
    'dispatch: loop {
        match pc {
            0x822BF488 => {
    //   block [0x822BF488..0x822BF52C)
	// 822BF488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BF48C: 489E9F79  bl 0x82ca9404
	ctx.lr = 0x822BF490;
	sub_82CA93D0(ctx, base);
	// 822BF490: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BF494: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 822BF498: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BF49C: 4BF68C5D  bl 0x822280f8
	ctx.lr = 0x822BF4A0;
	sub_822280F8(ctx, base);
	// 822BF4A0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822BF4A4: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 822BF4A8: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 822BF4AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822BF4B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BF4B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822BF4B8: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 822BF4BC: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 822BF4C0: 83C80004  lwz r30, 4(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BF4C4: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BF4C8: 4BF68C31  bl 0x822280f8
	ctx.lr = 0x822BF4CC;
	sub_822280F8(ctx, base);
	// 822BF4CC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BF4D0: 4BF68091  bl 0x82227560
	ctx.lr = 0x822BF4D4;
	sub_82227560(ctx, base);
	// 822BF4D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822BF4D8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 822BF4DC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822BF4E0: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822BF4E4: 4853318D  bl 0x827f2670
	ctx.lr = 0x822BF4E8;
	sub_827F2670(ctx, base);
	// 822BF4E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822BF4EC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 822BF4F0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822BF4F4: 88610051  lbz r3, 0x51(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 822BF4F8: 48533179  bl 0x827f2670
	ctx.lr = 0x822BF4FC;
	sub_827F2670(ctx, base);
	// 822BF4FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822BF500: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822BF504: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822BF508: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822BF50C: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 822BF510: 4E800421  bctrl
	ctx.lr = 0x822BF514;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BF514: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822BF518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BF51C: 480E3AA5  bl 0x823a2fc0
	ctx.lr = 0x822BF520;
	sub_823A2FC0(ctx, base);
	// 822BF520: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822BF524: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822BF528: 489E9F2C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BF530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BF530 size=208
    let mut pc: u32 = 0x822BF530;
    'dispatch: loop {
        match pc {
            0x822BF530 => {
    //   block [0x822BF530..0x822BF600)
	// 822BF530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BF534: 489E9ED1  bl 0x82ca9404
	ctx.lr = 0x822BF538;
	sub_82CA93D0(ctx, base);
	// 822BF538: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BF53C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 822BF540: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822BF544: 4BF68BB5  bl 0x822280f8
	ctx.lr = 0x822BF548;
	sub_822280F8(ctx, base);
	// 822BF548: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822BF54C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 822BF550: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822BF554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BF558: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822BF55C: 9BEB0000  stb r31, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 822BF560: 83AA0004  lwz r29, 4(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BF564: 838A0000  lwz r28, 0(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BF568: 4BF68B91  bl 0x822280f8
	ctx.lr = 0x822BF56C;
	sub_822280F8(ctx, base);
	// 822BF56C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BF570: 4BF67FF1  bl 0x82227560
	ctx.lr = 0x822BF574;
	sub_82227560(ctx, base);
	// 822BF574: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822BF578: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822BF57C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822BF580: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 822BF584: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822BF588: 48042AF9  bl 0x82302080
	ctx.lr = 0x822BF58C;
	sub_82302080(ctx, base);
	// 822BF58C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822BF590: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822BF594: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822BF598: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822BF59C: 7FA903A6  mtctr r29
	ctx.ctr.u64 = ctx.r[29].u64;
	// 822BF5A0: 4E800421  bctrl
	ctx.lr = 0x822BF5A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BF5A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822BF5A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822BF5AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822BF5B0: 4BED77C1  bl 0x82196d70
	ctx.lr = 0x822BF5B4;
	sub_82196D70(ctx, base);
	// 822BF5B4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 822BF5B8: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BF5BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822BF5C0: 3B890B7C  addi r28, r9, 0xb7c
	ctx.r[28].s64 = ctx.r[9].s64 + 2940;
	// 822BF5C4: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 822BF5C8: 91010068  stw r8, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 822BF5CC: 4BED486D  bl 0x82193e38
	ctx.lr = 0x822BF5D0;
	sub_82193E38(ctx, base);
	// 822BF5D0: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 822BF5D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822BF5D8: 4BEF8541  bl 0x821b7b18
	ctx.lr = 0x822BF5DC;
	sub_821B7B18(ctx, base);
	// 822BF5DC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822BF5E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BF5E4: 484BA4AD  bl 0x82779a90
	ctx.lr = 0x822BF5E8;
	sub_82779A90(ctx, base);
	// 822BF5E8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 822BF5EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822BF5F0: 4BED4849  bl 0x82193e38
	ctx.lr = 0x822BF5F4;
	sub_82193E38(ctx, base);
	// 822BF5F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822BF5F8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822BF5FC: 489E9E58  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BF600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BF600 size=140
    let mut pc: u32 = 0x822BF600;
    'dispatch: loop {
        match pc {
            0x822BF600 => {
    //   block [0x822BF600..0x822BF68C)
	// 822BF600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BF604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BF608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822BF60C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BF610: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BF614: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 822BF618: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BF61C: 4BF68ADD  bl 0x822280f8
	ctx.lr = 0x822BF620;
	sub_822280F8(ctx, base);
	// 822BF620: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822BF624: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822BF628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BF62C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BF630: 4BF68AC9  bl 0x822280f8
	ctx.lr = 0x822BF634;
	sub_822280F8(ctx, base);
	// 822BF634: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BF638: 4BF67F29  bl 0x82227560
	ctx.lr = 0x822BF63C;
	sub_82227560(ctx, base);
	// 822BF63C: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 822BF640: 4E800421  bctrl
	ctx.lr = 0x822BF644;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BF644: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822BF648: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BF64C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822BF650: 7D470034  cntlzw r7, r10
	ctx.r[7].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 822BF654: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822BF658: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 822BF65C: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 822BF660: 68C50001  xori r5, r6, 1
	ctx.r[5].u64 = ctx.r[6].u64 ^ 1;
	// 822BF664: 90A90000  stw r5, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 822BF668: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BF66C: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 822BF670: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 822BF674: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BF678: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BF67C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BF680: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822BF684: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BF688: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BF690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822BF690 size=64
    let mut pc: u32 = 0x822BF690;
    'dispatch: loop {
        match pc {
            0x822BF690 => {
    //   block [0x822BF690..0x822BF6D0)
	// 822BF690: C0030008  lfs f0, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BF694: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 822BF698: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 822BF69C: D9A1FFF0  stfd f13, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[13].u64 ) };
	// 822BF6A0: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 822BF6A4: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 822BF6A8: 7D48FE70  srawi r8, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 822BF6AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822BF6B0: 7D075038  and r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[10].u64;
	// 822BF6B4: 7D475850  subf r10, r7, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 822BF6B8: 216A0010  subfic r11, r10, 0x10
	ctx.xer.ca = ctx.r[10].u32 <= 16 as u32;
	ctx.r[11].s64 = (16 as i64) - ctx.r[10].s64;
	// 822BF6BC: 7D66FE70  srawi r6, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 822BF6C0: 7CCB5838  and r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 & ctx.r[11].u64;
	// 822BF6C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822BF6C8: 91698558  stw r11, -0x7aa8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-31400 as u32), ctx.r[11].u32 ) };
	// 822BF6CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BF6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BF6D0 size=80
    let mut pc: u32 = 0x822BF6D0;
    'dispatch: loop {
        match pc {
            0x822BF6D0 => {
    //   block [0x822BF6D0..0x822BF70C)
	// 822BF6D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BF6D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BF6D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BF6DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BF6E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BF6E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BF6E8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 822BF6EC: 419A0020  beq cr6, 0x822bf70c
	if ctx.cr[6].eq {
	pc = 0x822BF70C; continue 'dispatch;
	}
	// 822BF6F0: 484A14A9  bl 0x82760b98
	ctx.lr = 0x822BF6F4;
	sub_82760B98(ctx, base);
	// 822BF6F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822BF6F8: 419A0014  beq cr6, 0x822bf70c
	if ctx.cr[6].eq {
	pc = 0x822BF70C; continue 'dispatch;
	}
	// 822BF6FC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BF700: 4BF28C49  bl 0x821e8348
	ctx.lr = 0x822BF704;
	sub_821E8348(ctx, base);
	// 822BF704: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822BF708: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x822BF70C; continue 'dispatch;
            }
            0x822BF70C => {
    //   block [0x822BF70C..0x822BF720)
	// 822BF70C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822BF710: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BF714: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BF718: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BF71C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BF720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BF720 size=476
    let mut pc: u32 = 0x822BF720;
    'dispatch: loop {
        match pc {
            0x822BF720 => {
    //   block [0x822BF720..0x822BF75C)
	// 822BF720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BF724: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BF728: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822BF72C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BF730: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BF734: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 822BF738: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822BF73C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822BF740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BF744: 419A0018  beq cr6, 0x822bf75c
	if ctx.cr[6].eq {
	pc = 0x822BF75C; continue 'dispatch;
	}
	// 822BF748: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 822BF74C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 822BF750: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822BF754: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822BF758: 409A0008  bne cr6, 0x822bf760
	if !ctx.cr[6].eq {
	pc = 0x822BF760; continue 'dispatch;
	}
	pc = 0x822BF75C; continue 'dispatch;
            }
            0x822BF75C => {
    //   block [0x822BF75C..0x822BF760)
	// 822BF75C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x822BF760; continue 'dispatch;
            }
            0x822BF760 => {
    //   block [0x822BF760..0x822BF7AC)
	// 822BF760: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 822BF764: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BF768: 419A0160  beq cr6, 0x822bf8c8
	if ctx.cr[6].eq {
	pc = 0x822BF8C8; continue 'dispatch;
	}
	// 822BF76C: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 822BF770: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 822BF774: 55287FFE  rlwinm r8, r9, 0xf, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0001FFFFu64;
	// 822BF778: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822BF77C: 419A00F4  beq cr6, 0x822bf870
	if ctx.cr[6].eq {
	pc = 0x822BF870; continue 'dispatch;
	}
	// 822BF780: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 822BF784: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822BF788: 419A0024  beq cr6, 0x822bf7ac
	if ctx.cr[6].eq {
	pc = 0x822BF7AC; continue 'dispatch;
	}
	// 822BF78C: 894A0031  lbz r10, 0x31(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(49 as u32) ) } as u64;
	// 822BF790: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822BF794: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 822BF798: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822BF79C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BF7A0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822BF7A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BF7A8: 480000CC  b 0x822bf874
	pc = 0x822BF874; continue 'dispatch;
            }
            0x822BF7AC => {
    //   block [0x822BF7AC..0x822BF7C8)
	// 822BF7AC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 822BF7B0: 806B004C  lwz r3, 0x4c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822BF7B4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822BF7B8: 7D6A1850  subf r11, r10, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[10].s64;
	// 822BF7BC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822BF7C0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BF7C4: 40810054  ble 0x822bf818
	if !ctx.cr[0].gt {
	pc = 0x822BF818; continue 'dispatch;
	}
	pc = 0x822BF7C8; continue 'dispatch;
            }
            0x822BF7C8 => {
    //   block [0x822BF7C8..0x822BF7E8)
	// 822BF7C8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822BF7CC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822BF7D0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 822BF7D4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BF7D8: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 822BF7DC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822BF7E0: 41980008  blt cr6, 0x822bf7e8
	if ctx.cr[6].lt {
	pc = 0x822BF7E8; continue 'dispatch;
	}
	// 822BF7E4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x822BF7E8; continue 'dispatch;
            }
            0x822BF7E8 => {
    //   block [0x822BF7E8..0x822BF804)
	// 822BF7E8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 822BF7EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 822BF7F0: 419A0014  beq cr6, 0x822bf804
	if ctx.cr[6].eq {
	pc = 0x822BF804; continue 'dispatch;
	}
	// 822BF7F4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822BF7F8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822BF7FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822BF800: 4800000C  b 0x822bf80c
	pc = 0x822BF80C; continue 'dispatch;
            }
            0x822BF804 => {
    //   block [0x822BF804..0x822BF80C)
	// 822BF804: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 822BF808: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x822BF80C; continue 'dispatch;
            }
            0x822BF80C => {
    //   block [0x822BF80C..0x822BF818)
	// 822BF80C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BF810: 4199FFB8  bgt cr6, 0x822bf7c8
	if ctx.cr[6].gt {
	pc = 0x822BF7C8; continue 'dispatch;
	}
	// 822BF814: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x822BF818; continue 'dispatch;
            }
            0x822BF818 => {
    //   block [0x822BF818..0x822BF834)
	// 822BF818: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 822BF81C: 419A0040  beq cr6, 0x822bf85c
	if ctx.cr[6].eq {
	pc = 0x822BF85C; continue 'dispatch;
	}
	// 822BF820: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BF824: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 822BF828: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BF82C: 41990008  bgt cr6, 0x822bf834
	if ctx.cr[6].gt {
	pc = 0x822BF834; continue 'dispatch;
	}
	// 822BF830: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822BF834; continue 'dispatch;
            }
            0x822BF834 => {
    //   block [0x822BF834..0x822BF85C)
	// 822BF834: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BF838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BF83C: 409A0020  bne cr6, 0x822bf85c
	if !ctx.cr[6].eq {
	pc = 0x822BF85C; continue 'dispatch;
	}
	// 822BF840: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822BF844: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822BF848: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822BF84C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BF850: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822BF854: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BF858: 4800001C  b 0x822bf874
	pc = 0x822BF874; continue 'dispatch;
            }
            0x822BF85C => {
    //   block [0x822BF85C..0x822BF870)
	// 822BF85C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822BF860: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BF864: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822BF868: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822BF86C: 48000008  b 0x822bf874
	pc = 0x822BF874; continue 'dispatch;
            }
            0x822BF870 => {
    //   block [0x822BF870..0x822BF874)
	// 822BF870: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822BF874; continue 'dispatch;
            }
            0x822BF874 => {
    //   block [0x822BF874..0x822BF8C8)
	// 822BF874: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822BF878: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BF87C: 419A004C  beq cr6, 0x822bf8c8
	if ctx.cr[6].eq {
	pc = 0x822BF8C8; continue 'dispatch;
	}
	// 822BF880: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BF884: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 822BF888: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 822BF88C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BF890: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822BF894: 4E800421  bctrl
	ctx.lr = 0x822BF898;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822BF898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BF89C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BF8A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822BF8A4: 4BED74CD  bl 0x82196d70
	ctx.lr = 0x822BF8A8;
	sub_82196D70(ctx, base);
	// 822BF8A8: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BF8AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822BF8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822BF8B4: 392A0B7C  addi r9, r10, 0xb7c
	ctx.r[9].s64 = ctx.r[10].s64 + 2940;
	// 822BF8B8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 822BF8BC: 911E0008  stw r8, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 822BF8C0: 4BED4579  bl 0x82193e38
	ctx.lr = 0x822BF8C4;
	sub_82193E38(ctx, base);
	// 822BF8C4: 4800001C  b 0x822bf8e0
	pc = 0x822BF8E0; continue 'dispatch;
            }
            0x822BF8C8 => {
    //   block [0x822BF8C8..0x822BF8E0)
	// 822BF8C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822BF8CC: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822BF8D0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 822BF8D4: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 822BF8D8: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822BF8DC: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x822BF8E0; continue 'dispatch;
            }
            0x822BF8E0 => {
    //   block [0x822BF8E0..0x822BF8FC)
	// 822BF8E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BF8E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822BF8E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BF8EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BF8F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822BF8F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BF8F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BF900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822BF900 size=180
    let mut pc: u32 = 0x822BF900;
    'dispatch: loop {
        match pc {
            0x822BF900 => {
    //   block [0x822BF900..0x822BF9B4)
	// 822BF900: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BF9B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822BF9B8 size=408
    let mut pc: u32 = 0x822BF9B8;
    'dispatch: loop {
        match pc {
            0x822BF9B8 => {
    //   block [0x822BF9B8..0x822BFB4C)
	// 822BF9B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BF9BC: 489E9A41  bl 0x82ca93fc
	ctx.lr = 0x822BF9C0;
	sub_82CA93D0(ctx, base);
	// 822BF9C0: 81640030  lwz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 822BF9C4: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 822BF9C8: 8126000C  lwz r9, 0xc(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 822BF9CC: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822BF9D0: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 822BF9D4: 7F074800  cmpw cr6, r7, r9
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[9].s32, &mut ctx.xer);
	// 822BF9D8: 409A0174  bne cr6, 0x822bfb4c
	if !ctx.cr[6].eq {
	pc = 0x822BFB4C; continue 'dispatch;
	}
	// 822BF9DC: 81660018  lwz r11, 0x18(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 822BF9E0: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 822BF9E4: 81260014  lwz r9, 0x14(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 822BF9E8: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822BF9EC: 7D6853D7  divw. r11, r8, r10
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822BF9F0: 4081015C  ble 0x822bfb4c
	if !ctx.cr[0].gt {
	pc = 0x822BFB4C; continue 'dispatch;
	}
	// 822BF9F4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 822BF9F8: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 822BF9FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822BFA00: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822BFA04: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822BFA08: C0099484  lfs f0, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BFA0C: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 822BFA10: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 822BFA14: 3BEB9160  addi r31, r11, -0x6ea0
	ctx.r[31].s64 = ctx.r[11].s64 + -28320;
	// 822BFA18: 3B8A9190  addi r28, r10, -0x6e70
	ctx.r[28].s64 = ctx.r[10].s64 + -28272;
	// 822BFA1C: 81660014  lwz r11, 0x14(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 822BFA20: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 822BFA24: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822BFA28: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	pc = 0x822BFB4C; continue 'dispatch;
            }
            0x822BFB4C => {
    //   block [0x822BFB4C..0x822BFB50)
	// 822BFB4C: 489E9900  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BFB50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822BFB50 size=280
    let mut pc: u32 = 0x822BFB50;
    'dispatch: loop {
        match pc {
            0x822BFB50 => {
    //   block [0x822BFB50..0x822BFBE8)
	// 822BFB50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BFB54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BFB58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822BFB5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BFB60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BFB64: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 822BFB68: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 822BFB6C: 3BE30008  addi r31, r3, 8
	ctx.r[31].s64 = ctx.r[3].s64 + 8;
	// 822BFB70: 38EA9490  addi r7, r10, -0x6b70
	ctx.r[7].s64 = ctx.r[10].s64 + -27504;
	// 822BFB74: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 822BFB78: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 822BFB7C: C1AA9490  lfs f13, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822BFB80: 38C90E68  addi r6, r9, 0xe68
	ctx.r[6].s64 = ctx.r[9].s64 + 3688;
	// 822BFB84: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822BFB88: C007FFF4  lfs f0, -0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BFB8C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 822BFB90: 7CA00026  mfcr r5
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[5].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822BFB94: 54A4DF7A  rlwinm r4, r5, 0x1b, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 822BFB98: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 822BFB9C: 54A3F77A  rlwinm r3, r5, 0x1e, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[5].u32 as u64 & 0x00000003u64;
	// 822BFBA0: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 822BFBA4: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 822BFBA8: 7C8A1B78  or r10, r4, r3
	ctx.r[10].u64 = ctx.r[4].u64 | ctx.r[3].u64;
	// 822BFBAC: 7D86542E  lfsx f12, r6, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822BFBB0: FD6C006E  fsel f11, f12, f1, f0
	ctx.f[11].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[1].f64 } else { ctx.f[0].f64 };
	// 822BFBB4: ED4B6828  fsubs f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 822BFBB8: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 822BFBBC: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 822BFBC0: 54E5DF7A  rlwinm r5, r7, 0x1b, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 822BFBC4: 54E4F77A  rlwinm r4, r7, 0x1e, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 822BFBC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BFBCC: 7CA32378  or r3, r5, r4
	ctx.r[3].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 822BFBD0: 7D261C2E  lfsx f9, r6, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822BFBD4: FC095B6E  fsel f0, f9, f13, f11
	ctx.f[0].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[11].f64 };
	// 822BFBD8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822BFBDC: 409A000C  bne cr6, 0x822bfbe8
	if !ctx.cr[6].eq {
	pc = 0x822BFBE8; continue 'dispatch;
	}
	// 822BFBE0: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 822BFBE4: 48000010  b 0x822bfbf4
	pc = 0x822BFBF4; continue 'dispatch;
            }
            0x822BFBE8 => {
    //   block [0x822BFBE8..0x822BFBF4)
	// 822BFBE8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822BFBEC: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822BFBF0: 7D4743D6  divw r10, r7, r8
	ctx.r[10].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	pc = 0x822BFBF4; continue 'dispatch;
            }
            0x822BFBF4 => {
    //   block [0x822BFBF4..0x822BFC20)
	// 822BFBF4: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BFBF8: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 822BFBFC: 7D0B43D6  divw r8, r11, r8
	ctx.r[8].s32 = ctx.r[11].s32 / ctx.r[8].s32;
	// 822BFC00: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822BFC04: 40980028  bge cr6, 0x822bfc2c
	if !ctx.cr[6].lt {
	pc = 0x822BFC2C; continue 'dispatch;
	}
	// 822BFC08: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822BFC0C: 419A0014  beq cr6, 0x822bfc20
	if ctx.cr[6].eq {
	pc = 0x822BFC20; continue 'dispatch;
	}
	// 822BFC10: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822BFC14: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 822BFC18: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 822BFC1C: 4800021D  bl 0x822bfe38
	ctx.lr = 0x822BFC20;
	sub_822BFE38(ctx, base);
	pc = 0x822BFC20; continue 'dispatch;
            }
            0x822BFC20 => {
    //   block [0x822BFC20..0x822BFC2C)
	// 822BFC20: 397E0014  addi r11, r30, 0x14
	ctx.r[11].s64 = ctx.r[30].s64 + 20;
	// 822BFC24: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822BFC28: 48000020  b 0x822bfc48
	pc = 0x822BFC48; continue 'dispatch;
            }
            0x822BFC2C => {
    //   block [0x822BFC2C..0x822BFC48)
	// 822BFC2C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 822BFC30: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 822BFC34: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822BFC38: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 822BFC3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BFC40: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822BFC44: 48787B8D  bl 0x82a477d0
	ctx.lr = 0x822BFC48;
	sub_82A477D0(ctx, base);
	pc = 0x822BFC48; continue 'dispatch;
            }
            0x822BFC48 => {
    //   block [0x822BFC48..0x822BFC68)
	// 822BFC48: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 822BFC4C: 4878774D  bl 0x82a47398
	ctx.lr = 0x822BFC50;
	sub_82A47398(ctx, base);
	// 822BFC50: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822BFC54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BFC58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BFC5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822BFC60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BFC64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BFC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BFC78 size=140
    let mut pc: u32 = 0x822BFC78;
    'dispatch: loop {
        match pc {
            0x822BFC78 => {
    //   block [0x822BFC78..0x822BFD04)
	// 822BFC78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BFC7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BFC80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822BFC84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BFC88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BFC8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822BFC90: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822BFC94: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822BFC98: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 822BFC9C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822BFCA0: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 822BFCA4: 393F0030  addi r9, r31, 0x30
	ctx.r[9].s64 = ctx.r[31].s64 + 48;
	// 822BFCA8: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 822BFCAC: E91E0030  ld r8, 0x30(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	// 822BFCB0: F91F0030  std r8, 0x30(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[8].u64 ) };
	// 822BFCB4: E8FE0038  ld r7, 0x38(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	// 822BFCB8: F8FF0038  std r7, 0x38(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[7].u64 ) };
	// 822BFCBC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 822BFCC0: 4892B0C1  bl 0x82bead80
	ctx.lr = 0x822BFCC4;
	sub_82BEAD80(ctx, base);
	// 822BFCC4: 80DE0014  lwz r6, 0x14(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 822BFCC8: 90DF0014  stw r6, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 822BFCCC: 80BE0018  lwz r5, 0x18(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 822BFCD0: 90BF0018  stw r5, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[5].u32 ) };
	// 822BFCD4: 809E001C  lwz r4, 0x1c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 822BFCD8: 909F001C  stw r4, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 822BFCDC: 807E0020  lwz r3, 0x20(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 822BFCE0: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 822BFCE4: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 822BFCE8: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 822BFCEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822BFCF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BFCF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BFCF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822BFCFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BFD00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BFD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822BFD08 size=300
    let mut pc: u32 = 0x822BFD08;
    'dispatch: loop {
        match pc {
            0x822BFD08 => {
    //   block [0x822BFD08..0x822BFD30)
	// 822BFD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BFD0C: 489E96F5  bl 0x82ca9400
	ctx.lr = 0x822BFD10;
	sub_82CA93D0(ctx, base);
	// 822BFD10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BFD14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822BFD18: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822BFD1C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822BFD20: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822BFD24: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 822BFD28: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 822BFD2C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x822BFD30; continue 'dispatch;
            }
            0x822BFD30 => {
    //   block [0x822BFD30..0x822BFD58)
	// 822BFD30: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BFD34: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 822BFD38: 419A0020  beq cr6, 0x822bfd58
	if ctx.cr[6].eq {
	pc = 0x822BFD58; continue 'dispatch;
	}
	// 822BFD3C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822BFD40: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 822BFD44: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 822BFD48: 4198FFE8  blt cr6, 0x822bfd30
	if ctx.cr[6].lt {
	pc = 0x822BFD30; continue 'dispatch;
	}
	// 822BFD4C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822BFD50: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822BFD54: 489E96FC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x822BFD58 => {
    //   block [0x822BFD58..0x822BFDE4)
	// 822BFD58: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BFD5C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822BFD60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BFD64: 409A0088  bne cr6, 0x822bfdec
	if !ctx.cr[6].eq {
	pc = 0x822BFDEC; continue 'dispatch;
	}
	// 822BFD68: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 822BFD6C: 4BF5F4ED  bl 0x8221f258
	ctx.lr = 0x822BFD70;
	sub_8221F258(ctx, base);
	// 822BFD70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822BFD74: 419A0070  beq cr6, 0x822bfde4
	if ctx.cr[6].eq {
	pc = 0x822BFDE4; continue 'dispatch;
	}
	// 822BFD78: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 822BFD7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 822BFD80: 38E9FF08  addi r7, r9, -0xf8
	ctx.r[7].s64 = ctx.r[9].s64 + -248;
	// 822BFD84: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 822BFD88: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822BFD8C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 822BFD90: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 822BFD94: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822BFD98: 93E30010  stw r31, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 822BFD9C: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 822BFDA0: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BFDA4: 38C89160  addi r6, r8, -0x6ea0
	ctx.r[6].s64 = ctx.r[8].s64 + -28320;
	// 822BFDA8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822BFDAC: 93E30014  stw r31, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	pc = 0x822BFDE4; continue 'dispatch;
            }
            0x822BFDE4 => {
    //   block [0x822BFDE4..0x822BFDEC)
	// 822BFDE4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822BFDE8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x822BFDEC; continue 'dispatch;
            }
            0x822BFDEC => {
    //   block [0x822BFDEC..0x822BFE34)
	// 822BFDEC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 822BFDF0: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BFDF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822BFDF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822BFDFC: 4BFFFE7D  bl 0x822bfc78
	ctx.lr = 0x822BFE00;
	sub_822BFC78(ctx, base);
	// 822BFE00: 897D0029  lbz r11, 0x29(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(41 as u32) ) } as u64;
	// 822BFE04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BFE08: 409A0020  bne cr6, 0x822bfe28
	if !ctx.cr[6].eq {
	pc = 0x822BFE28; continue 'dispatch;
	}
	// 822BFE0C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 822BFE10: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 822BFE14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822BFE18: 386BE8D8  addi r3, r11, -0x1728
	ctx.r[3].s64 = ctx.r[11].s64 + -5928;
	// 822BFE1C: 487841D5  bl 0x82a43ff0
	ctx.lr = 0x822BFE20;
	sub_82A43FF0(ctx, base);
	// 822BFE20: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822BFE24: 995D0029  stb r10, 0x29(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(41 as u32), ctx.r[10].u8 ) };
	// 822BFE28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BFE2C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822BFE30: 489E9620  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BFE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822BFE38 size=220
    let mut pc: u32 = 0x822BFE38;
    'dispatch: loop {
        match pc {
            0x822BFE38 => {
    //   block [0x822BFE38..0x822BFE78)
	// 822BFE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BFE3C: 489E95D1  bl 0x82ca940c
	ctx.lr = 0x822BFE40;
	sub_82CA93D0(ctx, base);
	// 822BFE40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BFE44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822BFE48: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822BFE4C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822BFE50: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BFE54: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BFE58: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822BFE5C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822BFE60: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 822BFE64: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 822BFE68: 7D241E71  srawi. r4, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 822BFE6C: 4082000C  bne 0x822bfe78
	if !ctx.cr[0].eq {
	pc = 0x822BFE78; continue 'dispatch;
	}
	// 822BFE70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822BFE74: 4800000C  b 0x822bfe80
	pc = 0x822BFE80; continue 'dispatch;
            }
            0x822BFE78 => {
    //   block [0x822BFE78..0x822BFE80)
	// 822BFE78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822BFE7C: 48297F9D  bl 0x82557e18
	ctx.lr = 0x822BFE80;
	sub_82557E18(ctx, base);
	pc = 0x822BFE80; continue 'dispatch;
            }
            0x822BFE80 => {
    //   block [0x822BFE80..0x822BFEB4)
	// 822BFE80: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822BFE84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BFE88: 419A0080  beq cr6, 0x822bff08
	if ctx.cr[6].eq {
	pc = 0x822BFF08; continue 'dispatch;
	}
	// 822BFE8C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BFE90: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822BFE94: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 822BFE98: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822BFE9C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BFEA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822BFEA4: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822BFEA8: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 822BFEAC: 419A0058  beq cr6, 0x822bff04
	if ctx.cr[6].eq {
	pc = 0x822BFF04; continue 'dispatch;
	}
	// 822BFEB0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x822BFEB4; continue 'dispatch;
            }
            0x822BFEB4 => {
    //   block [0x822BFEB4..0x822BFED8)
	// 822BFEB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822BFEB8: 419A003C  beq cr6, 0x822bfef4
	if ctx.cr[6].eq {
	pc = 0x822BFEF4; continue 'dispatch;
	}
	// 822BFEBC: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822BFEC0: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822BFEC4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822BFEC8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822BFECC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 822BFED0: 419A0024  beq cr6, 0x822bfef4
	if ctx.cr[6].eq {
	pc = 0x822BFEF4; continue 'dispatch;
	}
	// 822BFED4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	pc = 0x822BFED8; continue 'dispatch;
            }
            0x822BFED8 => {
    //   block [0x822BFED8..0x822BFEF4)
	// 822BFED8: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 822BFEDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822BFEE0: 7CE04828  lwarx r7, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 822BFEE4: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 822BFEE8: 7CE0492D  stwcx. r7, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822BFEEC: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822BFEF0: 4082FFE8  bne 0x822bfed8
	if !ctx.cr[0].eq {
	pc = 0x822BFED8; continue 'dispatch;
	}
	pc = 0x822BFEF4; continue 'dispatch;
            }
            0x822BFEF4 => {
    //   block [0x822BFEF4..0x822BFF04)
	// 822BFEF4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822BFEF8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 822BFEFC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822BFF00: 409AFFB4  bne cr6, 0x822bfeb4
	if !ctx.cr[6].eq {
	pc = 0x822BFEB4; continue 'dispatch;
	}
	pc = 0x822BFF04; continue 'dispatch;
            }
            0x822BFF04 => {
    //   block [0x822BFF04..0x822BFF08)
	// 822BFF04: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x822BFF08; continue 'dispatch;
            }
            0x822BFF08 => {
    //   block [0x822BFF08..0x822BFF14)
	// 822BFF08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822BFF0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822BFF10: 489E954C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822BFF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822BFF18 size=116
    let mut pc: u32 = 0x822BFF18;
    'dispatch: loop {
        match pc {
            0x822BFF18 => {
    //   block [0x822BFF18..0x822BFF6C)
	// 822BFF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822BFF1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822BFF20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822BFF24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822BFF28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822BFF2C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822BFF30: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 822BFF34: 419A0038  beq cr6, 0x822bff6c
	if ctx.cr[6].eq {
	pc = 0x822BFF6C; continue 'dispatch;
	}
	// 822BFF38: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 822BFF3C: 4BF5F31D  bl 0x8221f258
	ctx.lr = 0x822BFF40;
	sub_8221F258(ctx, base);
	// 822BFF40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822BFF44: 419A0028  beq cr6, 0x822bff6c
	if ctx.cr[6].eq {
	pc = 0x822BFF6C; continue 'dispatch;
	}
	// 822BFF48: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822BFF4C: 3D208253  lis r9, -0x7dad
	ctx.r[9].s64 = -2108489728;
	// 822BFF50: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822BFF54: 38E99238  addi r7, r9, -0x6dc8
	ctx.r[7].s64 = ctx.r[9].s64 + -28104;
	// 822BFF58: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 822BFF5C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822BFF60: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 822BFF64: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822BFF68: 48000008  b 0x822bff70
	pc = 0x822BFF70; continue 'dispatch;
            }
            0x822BFF6C => {
    //   block [0x822BFF6C..0x822BFF70)
	// 822BFF6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x822BFF70; continue 'dispatch;
            }
            0x822BFF70 => {
    //   block [0x822BFF70..0x822BFF8C)
	// 822BFF70: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822BFF74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822BFF78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822BFF7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822BFF80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822BFF84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822BFF88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


