pub fn sub_82EA0AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA0AB8 size=364
    let mut pc: u32 = 0x82EA0AB8;
    'dispatch: loop {
        match pc {
            0x82EA0AB8 => {
    //   block [0x82EA0AB8..0x82EA0B20)
	// 82EA0AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA0ABC: 4BE0894D  bl 0x82ca9408
	ctx.lr = 0x82EA0AC0;
	sub_82CA93D0(ctx, base);
	// 82EA0AC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA0AC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA0AC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EA0ACC: 4B3BFEED  bl 0x822609b8
	ctx.lr = 0x82EA0AD0;
	sub_822609B8(ctx, base);
	// 82EA0AD0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0AD4: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0AD8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EA0ADC: 4BFE21C5  bl 0x82e82ca0
	ctx.lr = 0x82EA0AE0;
	sub_82E82CA0(ctx, base);
	// 82EA0AE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0AE4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0AE8: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0AEC: 4BFE0D85  bl 0x82e81870
	ctx.lr = 0x82EA0AF0;
	sub_82E81870(ctx, base);
	// 82EA0AF0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0AF4: 41820128  beq 0x82ea0c1c
	if ctx.cr[0].eq {
	pc = 0x82EA0C1C; continue 'dispatch;
	}
	// 82EA0AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0AFC: 4BFFFB2D  bl 0x82ea0628
	ctx.lr = 0x82EA0B00;
	sub_82EA0628(ctx, base);
	// 82EA0B00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0B04: 41820118  beq 0x82ea0c1c
	if ctx.cr[0].eq {
	pc = 0x82EA0C1C; continue 'dispatch;
	}
	// 82EA0B08: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0B0C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0B10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0B14: 4BFE0D5D  bl 0x82e81870
	ctx.lr = 0x82EA0B18;
	sub_82E81870(ctx, base);
	// 82EA0B18: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82EA0B1C: 480000A8  b 0x82ea0bc4
	pc = 0x82EA0BC4; continue 'dispatch;
            }
            0x82EA0B20 => {
    //   block [0x82EA0B20..0x82EA0B70)
	// 82EA0B20: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0B24: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0B28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0B2C: 4BFE2085  bl 0x82e82bb0
	ctx.lr = 0x82EA0B30;
	sub_82E82BB0(ctx, base);
	// 82EA0B30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0B34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0B38: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EA0B3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0B40: 4E800421  bctrl
	ctx.lr = 0x82EA0B44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA0B44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0B48: 41820040  beq 0x82ea0b88
	if ctx.cr[0].eq {
	pc = 0x82EA0B88; continue 'dispatch;
	}
	// 82EA0B4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0B50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0B54: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA0B58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0B5C: 4E800421  bctrl
	ctx.lr = 0x82EA0B60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA0B60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0B64: 4082000C  bne 0x82ea0b70
	if !ctx.cr[0].eq {
	pc = 0x82EA0B70; continue 'dispatch;
	}
	// 82EA0B68: 9B9F0015  stb r28, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[28].u8 ) };
	// 82EA0B6C: 9B9F0014  stb r28, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[28].u8 ) };
            }
            0x82EA0B70 => {
    //   block [0x82EA0B70..0x82EA0B88)
	// 82EA0B70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0B74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0B78: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA0B7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0B80: 4E800421  bctrl
	ctx.lr = 0x82EA0B84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA0B84: 48000008  b 0x82ea0b8c
	pc = 0x82EA0B8C; continue 'dispatch;
            }
            0x82EA0B88 => {
    //   block [0x82EA0B88..0x82EA0B8C)
	// 82EA0B88: 9B9F0015  stb r28, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[28].u8 ) };
	pc = 0x82EA0B8C; continue 'dispatch;
            }
            0x82EA0B8C => {
    //   block [0x82EA0B8C..0x82EA0BC4)
	// 82EA0B8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EA0B90: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA0B94: 4BFEB145  bl 0x82e8bcd8
	ctx.lr = 0x82EA0B98;
	sub_82E8BCD8(ctx, base);
	// 82EA0B98: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0B9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0BA0: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0BA4: 4BFE1205  bl 0x82e81da8
	ctx.lr = 0x82EA0BA8;
	sub_82E81DA8(ctx, base);
	// 82EA0BA8: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82EA0BAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA0BB0: 419A0020  beq cr6, 0x82ea0bd0
	if ctx.cr[6].eq {
	pc = 0x82EA0BD0; continue 'dispatch;
	}
	// 82EA0BB4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0BB8: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0BBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0BC0: 4BFE0CB1  bl 0x82e81870
	ctx.lr = 0x82EA0BC4;
	sub_82E81870(ctx, base);
	pc = 0x82EA0BC4; continue 'dispatch;
            }
            0x82EA0BC4 => {
    //   block [0x82EA0BC4..0x82EA0BD0)
	// 82EA0BC4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EA0BC8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA0BCC: 419AFF54  beq cr6, 0x82ea0b20
	if ctx.cr[6].eq {
	pc = 0x82EA0B20; continue 'dispatch;
	}
	pc = 0x82EA0BD0; continue 'dispatch;
            }
            0x82EA0BD0 => {
    //   block [0x82EA0BD0..0x82EA0BEC)
	// 82EA0BD0: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA0BD4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA0BD8: 41820014  beq 0x82ea0bec
	if ctx.cr[0].eq {
	pc = 0x82EA0BEC; continue 'dispatch;
	}
	// 82EA0BDC: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82EA0BE0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA0BE4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EA0BE8: 40820008  bne 0x82ea0bf0
	if !ctx.cr[0].eq {
	pc = 0x82EA0BF0; continue 'dispatch;
	}
	pc = 0x82EA0BEC; continue 'dispatch;
            }
            0x82EA0BEC => {
    //   block [0x82EA0BEC..0x82EA0BF0)
	// 82EA0BEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EA0BF0; continue 'dispatch;
            }
            0x82EA0BF0 => {
    //   block [0x82EA0BF0..0x82EA0C1C)
	// 82EA0BF0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0BF4: 41820028  beq 0x82ea0c1c
	if ctx.cr[0].eq {
	pc = 0x82EA0C1C; continue 'dispatch;
	}
	// 82EA0BF8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0BFC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0C00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0C04: 4BFE1F0D  bl 0x82e82b10
	ctx.lr = 0x82EA0C08;
	sub_82E82B10(ctx, base);
	// 82EA0C08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0C10: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA0C14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0C18: 4E800421  bctrl
	ctx.lr = 0x82EA0C1C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA0C1C => {
    //   block [0x82EA0C1C..0x82EA0C24)
	// 82EA0C1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EA0C20: 4BE08838  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA0C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA0C28 size=308
    let mut pc: u32 = 0x82EA0C28;
    'dispatch: loop {
        match pc {
            0x82EA0C28 => {
    //   block [0x82EA0C28..0x82EA0C74)
	// 82EA0C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA0C2C: 4BE087E1  bl 0x82ca940c
	ctx.lr = 0x82EA0C30;
	sub_82CA93D0(ctx, base);
	// 82EA0C30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA0C34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA0C38: 4B3BFD81  bl 0x822609b8
	ctx.lr = 0x82EA0C3C;
	sub_822609B8(ctx, base);
	// 82EA0C3C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0C40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EA0C44: 4BFE0D1D  bl 0x82e81960
	ctx.lr = 0x82EA0C48;
	sub_82E81960(ctx, base);
	// 82EA0C48: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0C4C: 41820108  beq 0x82ea0d54
	if ctx.cr[0].eq {
	pc = 0x82EA0D54; continue 'dispatch;
	}
	// 82EA0C50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0C54: 4BFFF9D5  bl 0x82ea0628
	ctx.lr = 0x82EA0C58;
	sub_82EA0628(ctx, base);
	// 82EA0C58: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0C5C: 418200F8  beq 0x82ea0d54
	if ctx.cr[0].eq {
	pc = 0x82EA0D54; continue 'dispatch;
	}
	// 82EA0C60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EA0C64: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0C68: 4BFE0CF9  bl 0x82e81960
	ctx.lr = 0x82EA0C6C;
	sub_82E81960(ctx, base);
	// 82EA0C6C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82EA0C70: 4800009C  b 0x82ea0d0c
	pc = 0x82EA0D0C; continue 'dispatch;
            }
            0x82EA0C74 => {
    //   block [0x82EA0C74..0x82EA0CC0)
	// 82EA0C74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EA0C78: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0C7C: 4BFE0F35  bl 0x82e81bb0
	ctx.lr = 0x82EA0C80;
	sub_82E81BB0(ctx, base);
	// 82EA0C80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0C88: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA0C8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0C90: 4E800421  bctrl
	ctx.lr = 0x82EA0C94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA0C94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0C98: 41820040  beq 0x82ea0cd8
	if ctx.cr[0].eq {
	pc = 0x82EA0CD8; continue 'dispatch;
	}
	// 82EA0C9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0CA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0CA4: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA0CA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0CAC: 4E800421  bctrl
	ctx.lr = 0x82EA0CB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA0CB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0CB4: 4082000C  bne 0x82ea0cc0
	if !ctx.cr[0].eq {
	pc = 0x82EA0CC0; continue 'dispatch;
	}
	// 82EA0CB8: 9BBF0015  stb r29, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[29].u8 ) };
	// 82EA0CBC: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
            }
            0x82EA0CC0 => {
    //   block [0x82EA0CC0..0x82EA0CD8)
	// 82EA0CC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0CC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0CC8: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA0CCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0CD0: 4E800421  bctrl
	ctx.lr = 0x82EA0CD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA0CD4: 48000008  b 0x82ea0cdc
	pc = 0x82EA0CDC; continue 'dispatch;
            }
            0x82EA0CD8 => {
    //   block [0x82EA0CD8..0x82EA0CDC)
	// 82EA0CD8: 9BBF0015  stb r29, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[29].u8 ) };
	pc = 0x82EA0CDC; continue 'dispatch;
            }
            0x82EA0CDC => {
    //   block [0x82EA0CDC..0x82EA0D0C)
	// 82EA0CDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EA0CE0: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA0CE4: 4BFEAFF5  bl 0x82e8bcd8
	ctx.lr = 0x82EA0CE8;
	sub_82E8BCD8(ctx, base);
	// 82EA0CE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EA0CEC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0CF0: 4BFE1171  bl 0x82e81e60
	ctx.lr = 0x82EA0CF4;
	sub_82E81E60(ctx, base);
	// 82EA0CF4: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82EA0CF8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA0CFC: 419A001C  beq cr6, 0x82ea0d18
	if ctx.cr[6].eq {
	pc = 0x82EA0D18; continue 'dispatch;
	}
	// 82EA0D00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EA0D04: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0D08: 4BFE0C59  bl 0x82e81960
	ctx.lr = 0x82EA0D0C;
	sub_82E81960(ctx, base);
	pc = 0x82EA0D0C; continue 'dispatch;
            }
            0x82EA0D0C => {
    //   block [0x82EA0D0C..0x82EA0D18)
	// 82EA0D0C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EA0D10: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA0D14: 419AFF60  beq cr6, 0x82ea0c74
	if ctx.cr[6].eq {
	pc = 0x82EA0C74; continue 'dispatch;
	}
	pc = 0x82EA0D18; continue 'dispatch;
            }
            0x82EA0D18 => {
    //   block [0x82EA0D18..0x82EA0D34)
	// 82EA0D18: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA0D1C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA0D20: 41820014  beq 0x82ea0d34
	if ctx.cr[0].eq {
	pc = 0x82EA0D34; continue 'dispatch;
	}
	// 82EA0D24: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82EA0D28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA0D2C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EA0D30: 40820008  bne 0x82ea0d38
	if !ctx.cr[0].eq {
	pc = 0x82EA0D38; continue 'dispatch;
	}
	pc = 0x82EA0D34; continue 'dispatch;
            }
            0x82EA0D34 => {
    //   block [0x82EA0D34..0x82EA0D38)
	// 82EA0D34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EA0D38; continue 'dispatch;
            }
            0x82EA0D38 => {
    //   block [0x82EA0D38..0x82EA0D54)
	// 82EA0D38: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0D3C: 41820018  beq 0x82ea0d54
	if ctx.cr[0].eq {
	pc = 0x82EA0D54; continue 'dispatch;
	}
	// 82EA0D40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0D44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0D48: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA0D4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0D50: 4E800421  bctrl
	ctx.lr = 0x82EA0D54;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA0D54 => {
    //   block [0x82EA0D54..0x82EA0D5C)
	// 82EA0D54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA0D58: 4BE08704  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA0D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA0D60 size=364
    let mut pc: u32 = 0x82EA0D60;
    'dispatch: loop {
        match pc {
            0x82EA0D60 => {
    //   block [0x82EA0D60..0x82EA0DC8)
	// 82EA0D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA0D64: 4BE086A5  bl 0x82ca9408
	ctx.lr = 0x82EA0D68;
	sub_82CA93D0(ctx, base);
	// 82EA0D68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA0D6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA0D70: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EA0D74: 4B3BFC45  bl 0x822609b8
	ctx.lr = 0x82EA0D78;
	sub_822609B8(ctx, base);
	// 82EA0D78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0D7C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0D80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EA0D84: 4BFE0EB5  bl 0x82e81c38
	ctx.lr = 0x82EA0D88;
	sub_82E81C38(ctx, base);
	// 82EA0D88: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0D8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0D90: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0D94: 4BFE09C5  bl 0x82e81758
	ctx.lr = 0x82EA0D98;
	sub_82E81758(ctx, base);
	// 82EA0D98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0D9C: 41820128  beq 0x82ea0ec4
	if ctx.cr[0].eq {
	pc = 0x82EA0EC4; continue 'dispatch;
	}
	// 82EA0DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0DA4: 4BFFF885  bl 0x82ea0628
	ctx.lr = 0x82EA0DA8;
	sub_82EA0628(ctx, base);
	// 82EA0DA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0DAC: 41820118  beq 0x82ea0ec4
	if ctx.cr[0].eq {
	pc = 0x82EA0EC4; continue 'dispatch;
	}
	// 82EA0DB0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0DB4: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0DB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0DBC: 4BFE099D  bl 0x82e81758
	ctx.lr = 0x82EA0DC0;
	sub_82E81758(ctx, base);
	// 82EA0DC0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82EA0DC4: 480000A8  b 0x82ea0e6c
	pc = 0x82EA0E6C; continue 'dispatch;
            }
            0x82EA0DC8 => {
    //   block [0x82EA0DC8..0x82EA0E18)
	// 82EA0DC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0DCC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0DD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0DD4: 4BFE0D1D  bl 0x82e81af0
	ctx.lr = 0x82EA0DD8;
	sub_82E81AF0(ctx, base);
	// 82EA0DD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0DE0: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA0DE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0DE8: 4E800421  bctrl
	ctx.lr = 0x82EA0DEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA0DEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0DF0: 41820040  beq 0x82ea0e30
	if ctx.cr[0].eq {
	pc = 0x82EA0E30; continue 'dispatch;
	}
	// 82EA0DF4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0DF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0DFC: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA0E00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0E04: 4E800421  bctrl
	ctx.lr = 0x82EA0E08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA0E08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0E0C: 4082000C  bne 0x82ea0e18
	if !ctx.cr[0].eq {
	pc = 0x82EA0E18; continue 'dispatch;
	}
	// 82EA0E10: 9B9F0015  stb r28, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[28].u8 ) };
	// 82EA0E14: 9B9F0014  stb r28, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[28].u8 ) };
            }
            0x82EA0E18 => {
    //   block [0x82EA0E18..0x82EA0E30)
	// 82EA0E18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0E1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0E20: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA0E24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0E28: 4E800421  bctrl
	ctx.lr = 0x82EA0E2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA0E2C: 48000008  b 0x82ea0e34
	pc = 0x82EA0E34; continue 'dispatch;
            }
            0x82EA0E30 => {
    //   block [0x82EA0E30..0x82EA0E34)
	// 82EA0E30: 9B9F0015  stb r28, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[28].u8 ) };
	pc = 0x82EA0E34; continue 'dispatch;
            }
            0x82EA0E34 => {
    //   block [0x82EA0E34..0x82EA0E6C)
	// 82EA0E34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EA0E38: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA0E3C: 4BFEAE9D  bl 0x82e8bcd8
	ctx.lr = 0x82EA0E40;
	sub_82E8BCD8(ctx, base);
	// 82EA0E40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0E44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0E48: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0E4C: 4BFE0E9D  bl 0x82e81ce8
	ctx.lr = 0x82EA0E50;
	sub_82E81CE8(ctx, base);
	// 82EA0E50: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82EA0E54: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA0E58: 419A0020  beq cr6, 0x82ea0e78
	if ctx.cr[6].eq {
	pc = 0x82EA0E78; continue 'dispatch;
	}
	// 82EA0E5C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0E60: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0E64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0E68: 4BFE08F1  bl 0x82e81758
	ctx.lr = 0x82EA0E6C;
	sub_82E81758(ctx, base);
	pc = 0x82EA0E6C; continue 'dispatch;
            }
            0x82EA0E6C => {
    //   block [0x82EA0E6C..0x82EA0E78)
	// 82EA0E6C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EA0E70: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA0E74: 419AFF54  beq cr6, 0x82ea0dc8
	if ctx.cr[6].eq {
	pc = 0x82EA0DC8; continue 'dispatch;
	}
	pc = 0x82EA0E78; continue 'dispatch;
            }
            0x82EA0E78 => {
    //   block [0x82EA0E78..0x82EA0E94)
	// 82EA0E78: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA0E7C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA0E80: 41820014  beq 0x82ea0e94
	if ctx.cr[0].eq {
	pc = 0x82EA0E94; continue 'dispatch;
	}
	// 82EA0E84: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82EA0E88: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA0E8C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EA0E90: 40820008  bne 0x82ea0e98
	if !ctx.cr[0].eq {
	pc = 0x82EA0E98; continue 'dispatch;
	}
	pc = 0x82EA0E94; continue 'dispatch;
            }
            0x82EA0E94 => {
    //   block [0x82EA0E94..0x82EA0E98)
	// 82EA0E94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EA0E98; continue 'dispatch;
            }
            0x82EA0E98 => {
    //   block [0x82EA0E98..0x82EA0EC4)
	// 82EA0E98: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0E9C: 41820028  beq 0x82ea0ec4
	if ctx.cr[0].eq {
	pc = 0x82EA0EC4; continue 'dispatch;
	}
	// 82EA0EA0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0EA4: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0EA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0EAC: 4BFE0BC5  bl 0x82e81a70
	ctx.lr = 0x82EA0EB0;
	sub_82E81A70(ctx, base);
	// 82EA0EB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0EB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0EB8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA0EBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0EC0: 4E800421  bctrl
	ctx.lr = 0x82EA0EC4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA0EC4 => {
    //   block [0x82EA0EC4..0x82EA0ECC)
	// 82EA0EC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EA0EC8: 4BE08590  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA0ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA0ED0 size=364
    let mut pc: u32 = 0x82EA0ED0;
    'dispatch: loop {
        match pc {
            0x82EA0ED0 => {
    //   block [0x82EA0ED0..0x82EA0F38)
	// 82EA0ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA0ED4: 4BE08535  bl 0x82ca9408
	ctx.lr = 0x82EA0ED8;
	sub_82CA93D0(ctx, base);
	// 82EA0ED8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA0EDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA0EE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EA0EE4: 4B3BFAD5  bl 0x822609b8
	ctx.lr = 0x82EA0EE8;
	sub_822609B8(ctx, base);
	// 82EA0EE8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0EEC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0EF0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EA0EF4: 4BFE1DAD  bl 0x82e82ca0
	ctx.lr = 0x82EA0EF8;
	sub_82E82CA0(ctx, base);
	// 82EA0EF8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0EFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0F00: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0F04: 4BFE096D  bl 0x82e81870
	ctx.lr = 0x82EA0F08;
	sub_82E81870(ctx, base);
	// 82EA0F08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0F0C: 41820128  beq 0x82ea1034
	if ctx.cr[0].eq {
	pc = 0x82EA1034; continue 'dispatch;
	}
	// 82EA0F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0F14: 4BFFF715  bl 0x82ea0628
	ctx.lr = 0x82EA0F18;
	sub_82EA0628(ctx, base);
	// 82EA0F18: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0F1C: 41820118  beq 0x82ea1034
	if ctx.cr[0].eq {
	pc = 0x82EA1034; continue 'dispatch;
	}
	// 82EA0F20: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0F24: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0F28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0F2C: 4BFE0945  bl 0x82e81870
	ctx.lr = 0x82EA0F30;
	sub_82E81870(ctx, base);
	// 82EA0F30: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82EA0F34: 480000A8  b 0x82ea0fdc
	pc = 0x82EA0FDC; continue 'dispatch;
            }
            0x82EA0F38 => {
    //   block [0x82EA0F38..0x82EA0F88)
	// 82EA0F38: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0F3C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0F40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0F44: 4BFE1C6D  bl 0x82e82bb0
	ctx.lr = 0x82EA0F48;
	sub_82E82BB0(ctx, base);
	// 82EA0F48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0F50: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA0F54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0F58: 4E800421  bctrl
	ctx.lr = 0x82EA0F5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA0F5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0F60: 41820040  beq 0x82ea0fa0
	if ctx.cr[0].eq {
	pc = 0x82EA0FA0; continue 'dispatch;
	}
	// 82EA0F64: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0F68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0F6C: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA0F70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0F74: 4E800421  bctrl
	ctx.lr = 0x82EA0F78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA0F78: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA0F7C: 4082000C  bne 0x82ea0f88
	if !ctx.cr[0].eq {
	pc = 0x82EA0F88; continue 'dispatch;
	}
	// 82EA0F80: 9B9F0015  stb r28, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[28].u8 ) };
	// 82EA0F84: 9B9F0014  stb r28, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[28].u8 ) };
            }
            0x82EA0F88 => {
    //   block [0x82EA0F88..0x82EA0FA0)
	// 82EA0F88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA0F8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA0F90: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA0F94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA0F98: 4E800421  bctrl
	ctx.lr = 0x82EA0F9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA0F9C: 48000008  b 0x82ea0fa4
	pc = 0x82EA0FA4; continue 'dispatch;
            }
            0x82EA0FA0 => {
    //   block [0x82EA0FA0..0x82EA0FA4)
	// 82EA0FA0: 9B9F0015  stb r28, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[28].u8 ) };
	pc = 0x82EA0FA4; continue 'dispatch;
            }
            0x82EA0FA4 => {
    //   block [0x82EA0FA4..0x82EA0FDC)
	// 82EA0FA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EA0FA8: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA0FAC: 4BFEAD2D  bl 0x82e8bcd8
	ctx.lr = 0x82EA0FB0;
	sub_82E8BCD8(ctx, base);
	// 82EA0FB0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0FB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0FB8: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0FBC: 4BFE0DED  bl 0x82e81da8
	ctx.lr = 0x82EA0FC0;
	sub_82E81DA8(ctx, base);
	// 82EA0FC0: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82EA0FC4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA0FC8: 419A0020  beq cr6, 0x82ea0fe8
	if ctx.cr[6].eq {
	pc = 0x82EA0FE8; continue 'dispatch;
	}
	// 82EA0FCC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA0FD0: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA0FD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA0FD8: 4BFE0899  bl 0x82e81870
	ctx.lr = 0x82EA0FDC;
	sub_82E81870(ctx, base);
	pc = 0x82EA0FDC; continue 'dispatch;
            }
            0x82EA0FDC => {
    //   block [0x82EA0FDC..0x82EA0FE8)
	// 82EA0FDC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EA0FE0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA0FE4: 419AFF54  beq cr6, 0x82ea0f38
	if ctx.cr[6].eq {
	pc = 0x82EA0F38; continue 'dispatch;
	}
	pc = 0x82EA0FE8; continue 'dispatch;
            }
            0x82EA0FE8 => {
    //   block [0x82EA0FE8..0x82EA1004)
	// 82EA0FE8: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA0FEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA0FF0: 41820014  beq 0x82ea1004
	if ctx.cr[0].eq {
	pc = 0x82EA1004; continue 'dispatch;
	}
	// 82EA0FF4: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82EA0FF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA0FFC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EA1000: 40820008  bne 0x82ea1008
	if !ctx.cr[0].eq {
	pc = 0x82EA1008; continue 'dispatch;
	}
	pc = 0x82EA1004; continue 'dispatch;
            }
            0x82EA1004 => {
    //   block [0x82EA1004..0x82EA1008)
	// 82EA1004: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EA1008; continue 'dispatch;
            }
            0x82EA1008 => {
    //   block [0x82EA1008..0x82EA1034)
	// 82EA1008: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA100C: 41820028  beq 0x82ea1034
	if ctx.cr[0].eq {
	pc = 0x82EA1034; continue 'dispatch;
	}
	// 82EA1010: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA1014: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA1018: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA101C: 4BFE1AF5  bl 0x82e82b10
	ctx.lr = 0x82EA1020;
	sub_82E82B10(ctx, base);
	// 82EA1020: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA1024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1028: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA102C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA1030: 4E800421  bctrl
	ctx.lr = 0x82EA1034;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA1034 => {
    //   block [0x82EA1034..0x82EA103C)
	// 82EA1034: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EA1038: 4BE08420  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA1040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA1040 size=88
    let mut pc: u32 = 0x82EA1040;
    'dispatch: loop {
        match pc {
            0x82EA1040 => {
    //   block [0x82EA1040..0x82EA107C)
	// 82EA1040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA1044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA1048: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EA104C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA1050: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA1054: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA1058: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EA105C: 4BFFF74D  bl 0x82ea07a8
	ctx.lr = 0x82EA1060;
	sub_82EA07A8(ctx, base);
	// 82EA1060: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA1064: 41820018  beq 0x82ea107c
	if ctx.cr[0].eq {
	pc = 0x82EA107C; continue 'dispatch;
	}
	// 82EA1068: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA106C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1070: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA1074: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA1078: 4E800421  bctrl
	ctx.lr = 0x82EA107C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA107C => {
    //   block [0x82EA107C..0x82EA1098)
	// 82EA107C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1080: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA1084: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA1088: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA108C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EA1090: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA1094: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA1098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA1098 size=160
    let mut pc: u32 = 0x82EA1098;
    'dispatch: loop {
        match pc {
            0x82EA1098 => {
    //   block [0x82EA1098..0x82EA10CC)
	// 82EA1098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA109C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA10A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA10A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA10A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA10AC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EA10B0: 419A0064  beq cr6, 0x82ea1114
	if ctx.cr[6].eq {
	pc = 0x82EA1114; continue 'dispatch;
	}
	// 82EA10B4: 4BFF9EC5  bl 0x82e9af78
	ctx.lr = 0x82EA10B8;
	sub_82E9AF78(ctx, base);
	// 82EA10B8: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EA10BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EA10C0: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA10C4: 40810050  ble 0x82ea1114
	if !ctx.cr[0].gt {
	pc = 0x82EA1114; continue 'dispatch;
	}
	// 82EA10C8: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EA10CC; continue 'dispatch;
            }
            0x82EA10CC => {
    //   block [0x82EA10CC..0x82EA10D8)
	// 82EA10CC: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA10D0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EA10D4: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EA10D8; continue 'dispatch;
            }
            0x82EA10D8 => {
    //   block [0x82EA10D8..0x82EA10FC)
	// 82EA10D8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA10DC: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA10E0: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA10E4: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EA10E8: 41820014  beq 0x82ea10fc
	if ctx.cr[0].eq {
	pc = 0x82EA10FC; continue 'dispatch;
	}
	// 82EA10EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EA10F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EA10F4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EA10F8: 419AFFE0  beq cr6, 0x82ea10d8
	if ctx.cr[6].eq {
	pc = 0x82EA10D8; continue 'dispatch;
	}
	pc = 0x82EA10FC; continue 'dispatch;
            }
            0x82EA10FC => {
    //   block [0x82EA10FC..0x82EA1114)
	// 82EA10FC: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA1100: 4182002C  beq 0x82ea112c
	if ctx.cr[0].eq {
	pc = 0x82EA112C; continue 'dispatch;
	}
	// 82EA1104: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EA1108: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EA110C: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EA1110: 4198FFBC  blt cr6, 0x82ea10cc
	if ctx.cr[6].lt {
	pc = 0x82EA10CC; continue 'dispatch;
	}
	pc = 0x82EA1114; continue 'dispatch;
            }
            0x82EA1114 => {
    //   block [0x82EA1114..0x82EA1118)
	// 82EA1114: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EA1118; continue 'dispatch;
            }
            0x82EA1118 => {
    //   block [0x82EA1118..0x82EA112C)
	// 82EA1118: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA111C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA1120: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA1124: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA1128: 4E800020  blr
	return;
            }
            0x82EA112C => {
    //   block [0x82EA112C..0x82EA1138)
	// 82EA112C: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA1130: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EA1134: 4BFFFFE4  b 0x82ea1118
	pc = 0x82EA1118; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA1138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA1138 size=116
    let mut pc: u32 = 0x82EA1138;
    'dispatch: loop {
        match pc {
            0x82EA1138 => {
    //   block [0x82EA1138..0x82EA1180)
	// 82EA1138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA113C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA1140: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA1144: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA1148: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EA114C: 816A75C4  lwz r11, 0x75c4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(30148 as u32) ) } as u64;
	// 82EA1150: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EA1154: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EA1158: 3BE971C0  addi r31, r9, 0x71c0
	ctx.r[31].s64 = ctx.r[9].s64 + 29120;
	// 82EA115C: 40820038  bne 0x82ea1194
	if !ctx.cr[0].eq {
	pc = 0x82EA1194; continue 'dispatch;
	}
	// 82EA1160: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EA1164: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EA1168: 8909DDF0  lbz r8, -0x2210(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8720 as u32) ) } as u64;
	// 82EA116C: 916A75C4  stw r11, 0x75c4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(30148 as u32), ctx.r[11].u32 ) };
	// 82EA1170: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA1174: 4182000C  beq 0x82ea1180
	if ctx.cr[0].eq {
	pc = 0x82EA1180; continue 'dispatch;
	}
	// 82EA1178: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EA117C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA1180; continue 'dispatch;
            }
            0x82EA1180 => {
    //   block [0x82EA1180..0x82EA1194)
	// 82EA1180: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EA1184: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EA1188: 386A87C0  addi r3, r10, -0x7840
	ctx.r[3].s64 = ctx.r[10].s64 + -30784;
	// 82EA118C: 9969DDF0  stb r11, -0x2210(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8720 as u32), ctx.r[11].u8 ) };
	// 82EA1190: 4BE08D91  bl 0x82ca9f20
	ctx.lr = 0x82EA1194;
	sub_82CA9F20(ctx, base);
	pc = 0x82EA1194; continue 'dispatch;
            }
            0x82EA1194 => {
    //   block [0x82EA1194..0x82EA11AC)
	// 82EA1194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1198: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA119C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA11A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA11A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA11A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA11B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA11B0 size=200
    let mut pc: u32 = 0x82EA11B0;
    'dispatch: loop {
        match pc {
            0x82EA11B0 => {
    //   block [0x82EA11B0..0x82EA11E4)
	// 82EA11B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA11B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA11B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA11BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA11C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA11C4: 4BFFFF75  bl 0x82ea1138
	ctx.lr = 0x82EA11C8;
	sub_82EA1138(ctx, base);
	// 82EA11C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EA11CC: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EA11D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EA11D4: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EA11D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA11DC: 40810054  ble 0x82ea1230
	if !ctx.cr[0].gt {
	pc = 0x82EA1230; continue 'dispatch;
	}
	// 82EA11E0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EA11E4; continue 'dispatch;
            }
            0x82EA11E4 => {
    //   block [0x82EA11E4..0x82EA11F0)
	// 82EA11E4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA11E8: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EA11EC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EA11F0; continue 'dispatch;
            }
            0x82EA11F0 => {
    //   block [0x82EA11F0..0x82EA1214)
	// 82EA11F0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA11F4: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA11F8: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA11FC: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EA1200: 41820014  beq 0x82ea1214
	if ctx.cr[0].eq {
	pc = 0x82EA1214; continue 'dispatch;
	}
	// 82EA1204: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EA1208: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EA120C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EA1210: 419AFFE0  beq cr6, 0x82ea11f0
	if ctx.cr[6].eq {
	pc = 0x82EA11F0; continue 'dispatch;
	}
	pc = 0x82EA1214; continue 'dispatch;
            }
            0x82EA1214 => {
    //   block [0x82EA1214..0x82EA1230)
	// 82EA1214: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA1218: 41820028  beq 0x82ea1240
	if ctx.cr[0].eq {
	pc = 0x82EA1240; continue 'dispatch;
	}
	// 82EA121C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EA1220: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EA1224: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EA1228: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EA122C: 4198FFB8  blt cr6, 0x82ea11e4
	if ctx.cr[6].lt {
	pc = 0x82EA11E4; continue 'dispatch;
	}
	pc = 0x82EA1230; continue 'dispatch;
            }
            0x82EA1230 => {
    //   block [0x82EA1230..0x82EA1240)
	// 82EA1230: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EA1234: 409A0018  bne cr6, 0x82ea124c
	if !ctx.cr[6].eq {
	pc = 0x82EA124C; continue 'dispatch;
	}
	// 82EA1238: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EA123C: 48000028  b 0x82ea1264
	pc = 0x82EA1264; continue 'dispatch;
            }
            0x82EA1240 => {
    //   block [0x82EA1240..0x82EA124C)
	// 82EA1240: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA1244: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EA1248: 48000018  b 0x82ea1260
	pc = 0x82EA1260; continue 'dispatch;
            }
            0x82EA124C => {
    //   block [0x82EA124C..0x82EA1260)
	// 82EA124C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA1250: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EA1254: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EA1258: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EA125C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA1260; continue 'dispatch;
            }
            0x82EA1260 => {
    //   block [0x82EA1260..0x82EA1264)
	// 82EA1260: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EA1264; continue 'dispatch;
            }
            0x82EA1264 => {
    //   block [0x82EA1264..0x82EA1278)
	// 82EA1264: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA1268: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA126C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA1270: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA1274: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA1278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA1278 size=400
    let mut pc: u32 = 0x82EA1278;
    'dispatch: loop {
        match pc {
            0x82EA1278 => {
    //   block [0x82EA1278..0x82EA12B8)
	// 82EA1278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA127C: 4BE08191  bl 0x82ca940c
	ctx.lr = 0x82EA1280;
	sub_82CA93D0(ctx, base);
	// 82EA1280: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA1284: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EA1288: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EA128C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EA1290: 419A0030  beq cr6, 0x82ea12c0
	if ctx.cr[6].eq {
	pc = 0x82EA12C0; continue 'dispatch;
	}
	// 82EA1294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1298: 4831ADC9  bl 0x831bc060
	ctx.lr = 0x82EA129C;
	sub_831BC060(ctx, base);
	// 82EA129C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA12A0: 41820020  beq 0x82ea12c0
	if ctx.cr[0].eq {
	pc = 0x82EA12C0; continue 'dispatch;
	}
	// 82EA12A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA12A8: 4831ADB9  bl 0x831bc060
	ctx.lr = 0x82EA12AC;
	sub_831BC060(ctx, base);
	// 82EA12AC: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA12B0: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82EA12B4: 409A000C  bne cr6, 0x82ea12c0
	if !ctx.cr[6].eq {
	pc = 0x82EA12C0; continue 'dispatch;
	}
	pc = 0x82EA12B8; continue 'dispatch;
            }
            0x82EA12B8 => {
    //   block [0x82EA12B8..0x82EA12C0)
	// 82EA12B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA12BC: 4800011C  b 0x82ea13d8
	pc = 0x82EA13D8; continue 'dispatch;
            }
            0x82EA12C0 => {
    //   block [0x82EA12C0..0x82EA1328)
	// 82EA12C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA12C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA12C8: 3BCB9820  addi r30, r11, -0x67e0
	ctx.r[30].s64 = ctx.r[11].s64 + -26592;
	// 82EA12CC: 4831AD95  bl 0x831bc060
	ctx.lr = 0x82EA12D0;
	sub_831BC060(ctx, base);
	// 82EA12D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA12D4: 4BE0B87D  bl 0x82cacb50
	ctx.lr = 0x82EA12D8;
	sub_82CACB50(ctx, base);
	// 82EA12D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA12DC: 4182FFDC  beq 0x82ea12b8
	if ctx.cr[0].eq {
	pc = 0x82EA12B8; continue 'dispatch;
	}
	// 82EA12E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA12E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA12E8: 3BCB9810  addi r30, r11, -0x67f0
	ctx.r[30].s64 = ctx.r[11].s64 + -26608;
	// 82EA12EC: 4831AD75  bl 0x831bc060
	ctx.lr = 0x82EA12F0;
	sub_831BC060(ctx, base);
	// 82EA12F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA12F4: 4BE0B85D  bl 0x82cacb50
	ctx.lr = 0x82EA12F8;
	sub_82CACB50(ctx, base);
	// 82EA12F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA12FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1300: 40820028  bne 0x82ea1328
	if !ctx.cr[0].eq {
	pc = 0x82EA1328; continue 'dispatch;
	}
	// 82EA1304: 4BA6CA05  bl 0x8290dd08
	ctx.lr = 0x82EA1308;
	sub_8290DD08(ctx, base);
	// 82EA1308: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA130C: 4B3BF6AD  bl 0x822609b8
	ctx.lr = 0x82EA1310;
	sub_822609B8(ctx, base);
	// 82EA1310: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EA1314: 4BFDFE55  bl 0x82e81168
	ctx.lr = 0x82EA1318;
	sub_82E81168(ctx, base);
	// 82EA1318: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EA131C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA1320: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EA1324: 480000B4  b 0x82ea13d8
	pc = 0x82EA13D8; continue 'dispatch;
            }
            0x82EA1328 => {
    //   block [0x82EA1328..0x82EA136C)
	// 82EA1328: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA132C: 3BCB9800  addi r30, r11, -0x6800
	ctx.r[30].s64 = ctx.r[11].s64 + -26624;
	// 82EA1330: 4831AD31  bl 0x831bc060
	ctx.lr = 0x82EA1334;
	sub_831BC060(ctx, base);
	// 82EA1334: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA1338: 4BE0B819  bl 0x82cacb50
	ctx.lr = 0x82EA133C;
	sub_82CACB50(ctx, base);
	// 82EA133C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA1340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1344: 40820028  bne 0x82ea136c
	if !ctx.cr[0].eq {
	pc = 0x82EA136C; continue 'dispatch;
	}
	// 82EA1348: 4BA6C9C1  bl 0x8290dd08
	ctx.lr = 0x82EA134C;
	sub_8290DD08(ctx, base);
	// 82EA134C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA1350: 4B3BF669  bl 0x822609b8
	ctx.lr = 0x82EA1354;
	sub_822609B8(ctx, base);
	// 82EA1354: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EA1358: 4BFDFEE1  bl 0x82e81238
	ctx.lr = 0x82EA135C;
	sub_82E81238(ctx, base);
	// 82EA135C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EA1360: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA1364: 917D0018  stw r11, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EA1368: 48000070  b 0x82ea13d8
	pc = 0x82EA13D8; continue 'dispatch;
            }
            0x82EA136C => {
    //   block [0x82EA136C..0x82EA13C0)
	// 82EA136C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA1370: 3BCBA130  addi r30, r11, -0x5ed0
	ctx.r[30].s64 = ctx.r[11].s64 + -24272;
	// 82EA1374: 4831ACED  bl 0x831bc060
	ctx.lr = 0x82EA1378;
	sub_831BC060(ctx, base);
	// 82EA1378: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA137C: 4BE0B7D5  bl 0x82cacb50
	ctx.lr = 0x82EA1380;
	sub_82CACB50(ctx, base);
	// 82EA1380: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA1384: 40820050  bne 0x82ea13d4
	if !ctx.cr[0].eq {
	pc = 0x82EA13D4; continue 'dispatch;
	}
	// 82EA1388: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA138C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1390: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EA1394: 4BFE2C0D  bl 0x82e83fa0
	ctx.lr = 0x82EA1398;
	sub_82E83FA0(ctx, base);
	// 82EA1398: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA139C: 41820038  beq 0x82ea13d4
	if ctx.cr[0].eq {
	pc = 0x82EA13D4; continue 'dispatch;
	}
	// 82EA13A0: 4BFFFCF9  bl 0x82ea1098
	ctx.lr = 0x82EA13A4;
	sub_82EA1098(ctx, base);
	// 82EA13A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA13A8: 40820038  bne 0x82ea13e0
	if !ctx.cr[0].eq {
	pc = 0x82EA13E0; continue 'dispatch;
	}
	// 82EA13AC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EA13B0: 4BFF9BC9  bl 0x82e9af78
	ctx.lr = 0x82EA13B4;
	sub_82E9AF78(ctx, base);
	// 82EA13B4: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EA13B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA13BC: 40990018  ble cr6, 0x82ea13d4
	if !ctx.cr[6].gt {
	pc = 0x82EA13D4; continue 'dispatch;
	}
	pc = 0x82EA13C0; continue 'dispatch;
            }
            0x82EA13C0 => {
    //   block [0x82EA13C0..0x82EA13D4)
	// 82EA13C0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EA13C4: 4BFF9BB5  bl 0x82e9af78
	ctx.lr = 0x82EA13C8;
	sub_82E9AF78(ctx, base);
	// 82EA13C8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EA13CC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EA13D0: 4198FFF0  blt cr6, 0x82ea13c0
	if ctx.cr[6].lt {
	pc = 0x82EA13C0; continue 'dispatch;
	}
	pc = 0x82EA13D4; continue 'dispatch;
            }
            0x82EA13D4 => {
    //   block [0x82EA13D4..0x82EA13D8)
	// 82EA13D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EA13D8; continue 'dispatch;
            }
            0x82EA13D8 => {
    //   block [0x82EA13D8..0x82EA13E0)
	// 82EA13D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA13DC: 4BE08080  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EA13E0 => {
    //   block [0x82EA13E0..0x82EA1408)
	// 82EA13E0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA13E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA13E8: 4E800421  bctrl
	ctx.lr = 0x82EA13EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA13EC: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82EA13F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA13F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EA13F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA13FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA1400: 4E800421  bctrl
	ctx.lr = 0x82EA1404;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA1404: 4BFFFEB4  b 0x82ea12b8
	pc = 0x82EA12B8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA1408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA1408 size=196
    let mut pc: u32 = 0x82EA1408;
    'dispatch: loop {
        match pc {
            0x82EA1408 => {
    //   block [0x82EA1408..0x82EA1440)
	// 82EA1408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA140C: 4BE07FF9  bl 0x82ca9404
	ctx.lr = 0x82EA1410;
	sub_82CA93D0(ctx, base);
	// 82EA1410: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA1414: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA1418: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA141C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EA1420: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EA1424: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EA1428: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EA142C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EA1430: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EA1434: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EA1438: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EA143C: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EA1440; continue 'dispatch;
            }
            0x82EA1440 => {
    //   block [0x82EA1440..0x82EA146C)
	// 82EA1440: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA1444: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA1448: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EA144C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EA1450: 4082FFF0  bne 0x82ea1440
	if !ctx.cr[0].eq {
	pc = 0x82EA1440; continue 'dispatch;
	}
	// 82EA1454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1458: 4BFFFD59  bl 0x82ea11b0
	ctx.lr = 0x82EA145C;
	sub_82EA11B0(ctx, base);
	// 82EA145C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA1460: 4082000C  bne 0x82ea146c
	if !ctx.cr[0].eq {
	pc = 0x82EA146C; continue 'dispatch;
	}
	// 82EA1464: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EA1468: 48000010  b 0x82ea1478
	pc = 0x82EA1478; continue 'dispatch;
            }
            0x82EA146C => {
    //   block [0x82EA146C..0x82EA1478)
	// 82EA146C: 4BFFFCCD  bl 0x82ea1138
	ctx.lr = 0x82EA1470;
	sub_82EA1138(ctx, base);
	// 82EA1470: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EA1474: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EA1478; continue 'dispatch;
            }
            0x82EA1478 => {
    //   block [0x82EA1478..0x82EA149C)
	// 82EA1478: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EA147C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EA1480: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EA1484: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA1488: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EA148C: 409A0010  bne cr6, 0x82ea149c
	if !ctx.cr[6].eq {
	pc = 0x82EA149C; continue 'dispatch;
	}
	// 82EA1490: 4BFDE5C9  bl 0x82e7fa58
	ctx.lr = 0x82EA1494;
	sub_82E7FA58(ctx, base);
	// 82EA1494: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EA1498: 4800000C  b 0x82ea14a4
	pc = 0x82EA14A4; continue 'dispatch;
            }
            0x82EA149C => {
    //   block [0x82EA149C..0x82EA14A4)
	// 82EA149C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EA14A0: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA14A4; continue 'dispatch;
            }
            0x82EA14A4 => {
    //   block [0x82EA14A4..0x82EA14C0)
	// 82EA14A4: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA14A8: 41820018  beq 0x82ea14c0
	if ctx.cr[0].eq {
	pc = 0x82EA14C0; continue 'dispatch;
	}
	// 82EA14AC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA14B0: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EA14B4: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EA14B8: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EA14BC: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA14C0; continue 'dispatch;
            }
            0x82EA14C0 => {
    //   block [0x82EA14C0..0x82EA14CC)
	// 82EA14C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA14C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EA14C8: 4BE07F8C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA14D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA14D0 size=68
    let mut pc: u32 = 0x82EA14D0;
    'dispatch: loop {
        match pc {
            0x82EA14D0 => {
    //   block [0x82EA14D0..0x82EA1514)
	// 82EA14D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA14D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA14D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA14DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA14E0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EA14E4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EA14E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA14EC: 4BFFFF1D  bl 0x82ea1408
	ctx.lr = 0x82EA14F0;
	sub_82EA1408(ctx, base);
	// 82EA14F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA14F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA14F8: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EA14FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA1500: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA1504: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA1508: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA150C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA1510: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA1518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EA1518 size=104
    let mut pc: u32 = 0x82EA1518;
    'dispatch: loop {
        match pc {
            0x82EA1518 => {
    //   block [0x82EA1518..0x82EA1580)
	// 82EA1518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA151C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA1520: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA1524: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA1528: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA152C: 4BFFEF25  bl 0x82ea0450
	ctx.lr = 0x82EA1530;
	sub_82EA0450(ctx, base);
	// 82EA1530: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EA1534: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA1538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA153C: 394BA148  addi r10, r11, -0x5eb8
	ctx.r[10].s64 = ctx.r[11].s64 + -24248;
	// 82EA1540: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EA1544: C0090BEC  lfs f0, 0xbec(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA1548: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EA154C: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EA1550: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA1554: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EA1558: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EA155C: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EA1560: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EA1564: 993F002C  stb r9, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u8 ) };
	// 82EA1568: 997F0034  stb r11, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82EA156C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA1570: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA1574: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA1578: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA157C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA1580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA1580 size=100
    let mut pc: u32 = 0x82EA1580;
    'dispatch: loop {
        match pc {
            0x82EA1580 => {
    //   block [0x82EA1580..0x82EA15C8)
	// 82EA1580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA1584: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA1588: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA158C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA1590: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA1594: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA1598: 396BA148  addi r11, r11, -0x5eb8
	ctx.r[11].s64 = ctx.r[11].s64 + -24248;
	// 82EA159C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA15A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA15A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA15A8: 41820020  beq 0x82ea15c8
	if ctx.cr[0].eq {
	pc = 0x82EA15C8; continue 'dispatch;
	}
	// 82EA15AC: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA15B0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA15B4: 409A0014  bne cr6, 0x82ea15c8
	if !ctx.cr[6].eq {
	pc = 0x82EA15C8; continue 'dispatch;
	}
	// 82EA15B8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA15BC: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA15C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA15C4: 4E800421  bctrl
	ctx.lr = 0x82EA15C8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA15C8 => {
    //   block [0x82EA15C8..0x82EA15E4)
	// 82EA15C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA15CC: 4BFFF1DD  bl 0x82ea07a8
	ctx.lr = 0x82EA15D0;
	sub_82EA07A8(ctx, base);
	// 82EA15D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA15D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA15D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA15DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA15E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA15E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA15E8 size=128
    let mut pc: u32 = 0x82EA15E8;
    'dispatch: loop {
        match pc {
            0x82EA15E8 => {
    //   block [0x82EA15E8..0x82EA162C)
	// 82EA15E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA15EC: 4BE07E21  bl 0x82ca940c
	ctx.lr = 0x82EA15F0;
	sub_82CA93D0(ctx, base);
	// 82EA15F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA15F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA15F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EA15FC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EA1600: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA1604: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA1608: 41820024  beq 0x82ea162c
	if ctx.cr[0].eq {
	pc = 0x82EA162C; continue 'dispatch;
	}
	// 82EA160C: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA1610: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA1614: 409A0018  bne cr6, 0x82ea162c
	if !ctx.cr[6].eq {
	pc = 0x82EA162C; continue 'dispatch;
	}
	// 82EA1618: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA161C: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA1620: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA1624: 4E800421  bctrl
	ctx.lr = 0x82EA1628;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA1628: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
            }
            0x82EA162C => {
    //   block [0x82EA162C..0x82EA1650)
	// 82EA162C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EA1630: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82EA1634: 3D400FFF  lis r10, 0xfff
	ctx.r[10].s64 = 268369920;
	// 82EA1638: 57C32036  slwi r3, r30, 4
	ctx.r[3].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA163C: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82EA1640: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EA1644: 997F002C  stb r11, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	// 82EA1648: 40990008  ble cr6, 0x82ea1650
	if !ctx.cr[6].gt {
	pc = 0x82EA1650; continue 'dispatch;
	}
	// 82EA164C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82EA1650; continue 'dispatch;
            }
            0x82EA1650 => {
    //   block [0x82EA1650..0x82EA1668)
	// 82EA1650: 4B7752D9  bl 0x82616928
	ctx.lr = 0x82EA1654;
	sub_82616928(ctx, base);
	// 82EA1654: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 82EA1658: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 82EA165C: 93BF0024  stw r29, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[29].u32 ) };
	// 82EA1660: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA1664: 4BE07DF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA1668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA1668 size=56
    let mut pc: u32 = 0x82EA1668;
    'dispatch: loop {
        match pc {
            0x82EA1668 => {
    //   block [0x82EA1668..0x82EA16A0)
	// 82EA1668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA166C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA1670: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA1674: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA1678: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA167C: 4BFFEF5D  bl 0x82ea05d8
	ctx.lr = 0x82EA1680;
	sub_82EA05D8(ctx, base);
	// 82EA1680: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EA1684: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EA1688: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EA168C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA1690: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA1694: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA1698: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA169C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA16A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA16A0 size=12
    let mut pc: u32 = 0x82EA16A0;
    'dispatch: loop {
        match pc {
            0x82EA16A0 => {
    //   block [0x82EA16A0..0x82EA16AC)
	// 82EA16A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EA16A4: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EA16A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA16B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EA16B0 size=404
    let mut pc: u32 = 0x82EA16B0;
    'dispatch: loop {
        match pc {
            0x82EA16B0 => {
    //   block [0x82EA16B0..0x82EA16E8)
	// 82EA16B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA16B4: 4BE07D55  bl 0x82ca9408
	ctx.lr = 0x82EA16B8;
	sub_82CA93D0(ctx, base);
	// 82EA16B8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA16BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA16C0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA16C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA16C8: 419A0174  beq cr6, 0x82ea183c
	if ctx.cr[6].eq {
	pc = 0x82EA183C; continue 'dispatch;
	}
	// 82EA16CC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA16D0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EA16D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA16D8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA16DC: 3BABDAC0  addi r29, r11, -0x2540
	ctx.r[29].s64 = ctx.r[11].s64 + -9536;
	// 82EA16E0: 409900A8  ble cr6, 0x82ea1788
	if !ctx.cr[6].gt {
	pc = 0x82EA1788; continue 'dispatch;
	}
	// 82EA16E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82EA16E8; continue 'dispatch;
            }
            0x82EA16E8 => {
    //   block [0x82EA16E8..0x82EA1774)
	// 82EA16E8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA16EC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA16F0: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA16F4: 480321E5  bl 0x82ed38d8
	ctx.lr = 0x82EA16F8;
	sub_82ED38D8(ctx, base);
	// 82EA16F8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA16FC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA1700: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA1704: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA1708: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA170C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EA1710: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA1714: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EA1718: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA171C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EA1720: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA1724: 480321B5  bl 0x82ed38d8
	ctx.lr = 0x82EA1728;
	sub_82ED38D8(ctx, base);
	// 82EA1728: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA172C: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA1730: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA1734: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA1738: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA173C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EA1740: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA1744: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EA1748: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA174C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EA1750: 419A0024  beq cr6, 0x82ea1774
	if ctx.cr[6].eq {
	pc = 0x82EA1774; continue 'dispatch;
	}
	// 82EA1754: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA1758: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EA175C: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 82EA1760: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EA1764: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EA1768: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EA176C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA1770: 4E800421  bctrl
	ctx.lr = 0x82EA1774;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA1774 => {
    //   block [0x82EA1774..0x82EA1788)
	// 82EA1774: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA1778: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EA177C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82EA1780: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA1784: 4198FF64  blt cr6, 0x82ea16e8
	if ctx.cr[6].lt {
	pc = 0x82EA16E8; continue 'dispatch;
	}
	pc = 0x82EA1788; continue 'dispatch;
            }
            0x82EA1788 => {
    //   block [0x82EA1788..0x82EA179C)
	// 82EA1788: 839F0028  lwz r28, 0x28(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA178C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA1790: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA1794: 409800A8  bge cr6, 0x82ea183c
	if !ctx.cr[6].lt {
	pc = 0x82EA183C; continue 'dispatch;
	}
	// 82EA1798: 579E2036  slwi r30, r28, 4
	ctx.r[30].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x82EA179C; continue 'dispatch;
            }
            0x82EA179C => {
    //   block [0x82EA179C..0x82EA1828)
	// 82EA179C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA17A0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA17A4: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA17A8: 48032131  bl 0x82ed38d8
	ctx.lr = 0x82EA17AC;
	sub_82ED38D8(ctx, base);
	// 82EA17AC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA17B0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA17B4: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA17B8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA17BC: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA17C0: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EA17C4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA17C8: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EA17CC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA17D0: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EA17D4: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA17D8: 48032101  bl 0x82ed38d8
	ctx.lr = 0x82EA17DC;
	sub_82ED38D8(ctx, base);
	// 82EA17DC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA17E0: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA17E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA17E8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA17EC: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA17F0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EA17F4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA17F8: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EA17FC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA1800: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EA1804: 419A0024  beq cr6, 0x82ea1828
	if ctx.cr[6].eq {
	pc = 0x82EA1828; continue 'dispatch;
	}
	// 82EA1808: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA180C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EA1810: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EA1814: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 82EA1818: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EA181C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EA1820: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA1824: 4E800421  bctrl
	ctx.lr = 0x82EA1828;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA1828 => {
    //   block [0x82EA1828..0x82EA183C)
	// 82EA1828: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA182C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EA1830: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82EA1834: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA1838: 4198FF64  blt cr6, 0x82ea179c
	if ctx.cr[6].lt {
	pc = 0x82EA179C; continue 'dispatch;
	}
	pc = 0x82EA183C; continue 'dispatch;
            }
            0x82EA183C => {
    //   block [0x82EA183C..0x82EA1844)
	// 82EA183C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EA1840: 4BE07C18  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA1848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EA1848 size=416
    let mut pc: u32 = 0x82EA1848;
    'dispatch: loop {
        match pc {
            0x82EA1848 => {
    //   block [0x82EA1848..0x82EA1860)
	// 82EA1848: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82EA184C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EA1850: 810B0024  lwz r8, 0x24(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA1854: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA1858: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EA185C: 409A000C  bne cr6, 0x82ea1868
	if !ctx.cr[6].eq {
	pc = 0x82EA1868; continue 'dispatch;
	}
	pc = 0x82EA1860; continue 'dispatch;
            }
            0x82EA1860 => {
    //   block [0x82EA1860..0x82EA1868)
	// 82EA1860: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EA1864: 4800017C  b 0x82ea19e0
	pc = 0x82EA19E0; continue 'dispatch;
            }
            0x82EA1868 => {
    //   block [0x82EA1868..0x82EA1880)
	// 82EA1868: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA186C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EA1870: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EA1874: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA1878: 41820054  beq 0x82ea18cc
	if ctx.cr[0].eq {
	pc = 0x82EA18CC; continue 'dispatch;
	}
	// 82EA187C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x82EA1880; continue 'dispatch;
            }
            0x82EA1880 => {
    //   block [0x82EA1880..0x82EA1898)
	// 82EA1880: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA1884: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82EA1888: 409A0010  bne cr6, 0x82ea1898
	if !ctx.cr[6].eq {
	pc = 0x82EA1898; continue 'dispatch;
	}
	// 82EA188C: 83EA0004  lwz r31, 4(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA1890: 7F1F2840  cmplw cr6, r31, r5
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EA1894: 419AFFCC  beq cr6, 0x82ea1860
	if ctx.cr[6].eq {
	pc = 0x82EA1860; continue 'dispatch;
	}
	pc = 0x82EA1898; continue 'dispatch;
            }
            0x82EA1898 => {
    //   block [0x82EA1898..0x82EA18B8)
	// 82EA1898: 8BEB0034  lbz r31, 0x34(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA189C: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA18A0: 40820018  bne 0x82ea18b8
	if !ctx.cr[0].eq {
	pc = 0x82EA18B8; continue 'dispatch;
	}
	// 82EA18A4: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EA18A8: 409A0010  bne cr6, 0x82ea18b8
	if !ctx.cr[6].eq {
	pc = 0x82EA18B8; continue 'dispatch;
	}
	// 82EA18AC: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA18B0: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82EA18B4: 419AFFAC  beq cr6, 0x82ea1860
	if ctx.cr[6].eq {
	pc = 0x82EA1860; continue 'dispatch;
	}
	pc = 0x82EA18B8; continue 'dispatch;
            }
            0x82EA18B8 => {
    //   block [0x82EA18B8..0x82EA18CC)
	// 82EA18B8: 80EB0028  lwz r7, 0x28(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA18BC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EA18C0: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82EA18C4: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EA18C8: 4198FFB8  blt cr6, 0x82ea1880
	if ctx.cr[6].lt {
	pc = 0x82EA1880; continue 'dispatch;
	}
	pc = 0x82EA18CC; continue 'dispatch;
            }
            0x82EA18CC => {
    //   block [0x82EA18CC..0x82EA18E0)
	// 82EA18CC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EA18D0: 40980074  bge cr6, 0x82ea1944
	if !ctx.cr[6].lt {
	pc = 0x82EA1944; continue 'dispatch;
	}
	// 82EA18D4: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA18D8: 552A2036  slwi r10, r9, 4
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA18DC: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	pc = 0x82EA18E0; continue 'dispatch;
            }
            0x82EA18E0 => {
    //   block [0x82EA18E0..0x82EA18F8)
	// 82EA18E0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA18E4: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82EA18E8: 409A0010  bne cr6, 0x82ea18f8
	if !ctx.cr[6].eq {
	pc = 0x82EA18F8; continue 'dispatch;
	}
	// 82EA18EC: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA18F0: 7F062840  cmplw cr6, r6, r5
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EA18F4: 419AFF6C  beq cr6, 0x82ea1860
	if ctx.cr[6].eq {
	pc = 0x82EA1860; continue 'dispatch;
	}
	pc = 0x82EA18F8; continue 'dispatch;
            }
            0x82EA18F8 => {
    //   block [0x82EA18F8..0x82EA1918)
	// 82EA18F8: 88CB0034  lbz r6, 0x34(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA18FC: 28060000  cmplwi r6, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA1900: 40820018  bne 0x82ea1918
	if !ctx.cr[0].eq {
	pc = 0x82EA1918; continue 'dispatch;
	}
	// 82EA1904: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EA1908: 409A0010  bne cr6, 0x82ea1918
	if !ctx.cr[6].eq {
	pc = 0x82EA1918; continue 'dispatch;
	}
	// 82EA190C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA1910: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82EA1914: 419AFF4C  beq cr6, 0x82ea1860
	if ctx.cr[6].eq {
	pc = 0x82EA1860; continue 'dispatch;
	}
	pc = 0x82EA1918; continue 'dispatch;
            }
            0x82EA1918 => {
    //   block [0x82EA1918..0x82EA1928)
	// 82EA1918: C00A0008  lfs f0, 8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA191C: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82EA1920: 40980008  bge cr6, 0x82ea1928
	if !ctx.cr[6].lt {
	pc = 0x82EA1928; continue 'dispatch;
	}
	// 82EA1924: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	pc = 0x82EA1928; continue 'dispatch;
            }
            0x82EA1928 => {
    //   block [0x82EA1928..0x82EA1944)
	// 82EA1928: 80EB0024  lwz r7, 0x24(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA192C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EA1930: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82EA1934: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EA1938: 4198FFA8  blt cr6, 0x82ea18e0
	if ctx.cr[6].lt {
	pc = 0x82EA18E0; continue 'dispatch;
	}
	// 82EA193C: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EA1940: 409A000C  bne cr6, 0x82ea194c
	if !ctx.cr[6].eq {
	pc = 0x82EA194C; continue 'dispatch;
	}
	pc = 0x82EA1944; continue 'dispatch;
            }
            0x82EA1944 => {
    //   block [0x82EA1944..0x82EA194C)
	// 82EA1944: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 82EA1948: 48000008  b 0x82ea1950
	pc = 0x82EA1950; continue 'dispatch;
            }
            0x82EA194C => {
    //   block [0x82EA194C..0x82EA1950)
	// 82EA194C: 38C30001  addi r6, r3, 1
	ctx.r[6].s64 = ctx.r[3].s64 + 1;
	pc = 0x82EA1950; continue 'dispatch;
            }
            0x82EA1950 => {
    //   block [0x82EA1950..0x82EA195C)
	// 82EA1950: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA1954: 41820048  beq 0x82ea199c
	if ctx.cr[0].eq {
	pc = 0x82EA199C; continue 'dispatch;
	}
	// 82EA1958: 55072036  slwi r7, r8, 4
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	pc = 0x82EA195C; continue 'dispatch;
            }
            0x82EA195C => {
    //   block [0x82EA195C..0x82EA199C)
	// 82EA195C: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EA1960: 4099003C  ble cr6, 0x82ea199c
	if !ctx.cr[6].gt {
	pc = 0x82EA199C; continue 'dispatch;
	}
	// 82EA1964: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA1968: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EA196C: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82EA1970: 38E7FFF0  addi r7, r7, -0x10
	ctx.r[7].s64 = ctx.r[7].s64 + -16;
	// 82EA1974: 392AFFF0  addi r9, r10, -0x10
	ctx.r[9].s64 = ctx.r[10].s64 + -16;
	// 82EA1978: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA197C: 906A0000  stw r3, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EA1980: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA1984: 906A0004  stw r3, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82EA1988: 80690008  lwz r3, 8(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA198C: 906A0008  stw r3, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82EA1990: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA1994: 912A000C  stw r9, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EA1998: 4082FFC4  bne 0x82ea195c
	if !ctx.cr[0].eq {
	pc = 0x82EA195C; continue 'dispatch;
	}
	pc = 0x82EA199C; continue 'dispatch;
            }
            0x82EA199C => {
    //   block [0x82EA199C..0x82EA19E0)
	// 82EA199C: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA19A0: 54CA2036  slwi r10, r6, 4
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA19A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA19A8: 7C8A492E  stwx r4, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[4].u32) };
	// 82EA19AC: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA19B0: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EA19B4: 90A90004  stw r5, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82EA19B8: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA19BC: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EA19C0: D0290008  stfs f1, 8(r9)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EA19C4: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA19C8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EA19CC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EA19D0: 992A000C  stb r9, 0xc(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u8 ) };
	// 82EA19D4: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA19D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EA19DC: 914B0024  stw r10, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA19E0; continue 'dispatch;
            }
            0x82EA19E0 => {
    //   block [0x82EA19E0..0x82EA19E8)
	// 82EA19E0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82EA19E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA19E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA19E8 size=88
    let mut pc: u32 = 0x82EA19E8;
    'dispatch: loop {
        match pc {
            0x82EA19E8 => {
    //   block [0x82EA19E8..0x82EA1A24)
	// 82EA19E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA19EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA19F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EA19F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA19F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA19FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA1A00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EA1A04: 4BFFFB7D  bl 0x82ea1580
	ctx.lr = 0x82EA1A08;
	sub_82EA1580(ctx, base);
	// 82EA1A08: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA1A0C: 41820018  beq 0x82ea1a24
	if ctx.cr[0].eq {
	pc = 0x82EA1A24; continue 'dispatch;
	}
	// 82EA1A10: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA1A14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1A18: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA1A1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA1A20: 4E800421  bctrl
	ctx.lr = 0x82EA1A24;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA1A24 => {
    //   block [0x82EA1A24..0x82EA1A40)
	// 82EA1A24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1A28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA1A2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA1A30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA1A34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EA1A38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA1A3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA1A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EA1A40 size=500
    let mut pc: u32 = 0x82EA1A40;
    'dispatch: loop {
        match pc {
            0x82EA1A40 => {
    //   block [0x82EA1A40..0x82EA1A94)
	// 82EA1A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA1A44: 4BE079C9  bl 0x82ca940c
	ctx.lr = 0x82EA1A48;
	sub_82CA93D0(ctx, base);
	// 82EA1A48: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EA1A4C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA1A50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EA1A54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EA1A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1A5C: 4831A605  bl 0x831bc060
	ctx.lr = 0x82EA1A60;
	sub_831BC060(ctx, base);
	// 82EA1A60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA1A64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EA1A68: 396B9C48  addi r11, r11, -0x63b8
	ctx.r[11].s64 = ctx.r[11].s64 + -25528;
	// 82EA1A6C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA1A70: 4BE0B0E1  bl 0x82cacb50
	ctx.lr = 0x82EA1A74;
	sub_82CACB50(ctx, base);
	// 82EA1A74: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA1A78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1A7C: 40820020  bne 0x82ea1a9c
	if !ctx.cr[0].eq {
	pc = 0x82EA1A9C; continue 'dispatch;
	}
	// 82EA1A80: 4BA6C289  bl 0x8290dd08
	ctx.lr = 0x82EA1A84;
	sub_8290DD08(ctx, base);
	// 82EA1A84: 4BE0893D  bl 0x82caa3c0
	ctx.lr = 0x82EA1A88;
	sub_82CAA3C0(ctx, base);
	// 82EA1A88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EA1A8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA1A90: 4BFFFB59  bl 0x82ea15e8
	ctx.lr = 0x82EA1A94;
	sub_82EA15E8(ctx, base);
	pc = 0x82EA1A94; continue 'dispatch;
            }
            0x82EA1A94 => {
    //   block [0x82EA1A94..0x82EA1A9C)
	// 82EA1A94: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA1A98: 48000190  b 0x82ea1c28
	pc = 0x82EA1C28; continue 'dispatch;
            }
            0x82EA1A9C => {
    //   block [0x82EA1A9C..0x82EA1AD4)
	// 82EA1A9C: 4831A5C5  bl 0x831bc060
	ctx.lr = 0x82EA1AA0;
	sub_831BC060(ctx, base);
	// 82EA1AA0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EA1AA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EA1AA8: 396B8360  addi r11, r11, -0x7ca0
	ctx.r[11].s64 = ctx.r[11].s64 + -31904;
	// 82EA1AAC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA1AB0: 4BE0B0A1  bl 0x82cacb50
	ctx.lr = 0x82EA1AB4;
	sub_82CACB50(ctx, base);
	// 82EA1AB4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA1AB8: 40820060  bne 0x82ea1b18
	if !ctx.cr[0].eq {
	pc = 0x82EA1B18; continue 'dispatch;
	}
	// 82EA1ABC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA1AC0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA1AC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA1AC8: 4182000C  beq 0x82ea1ad4
	if ctx.cr[0].eq {
	pc = 0x82EA1AD4; continue 'dispatch;
	}
	// 82EA1ACC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EA1AD0: 4800000C  b 0x82ea1adc
	pc = 0x82EA1ADC; continue 'dispatch;
            }
            0x82EA1AD4 => {
    //   block [0x82EA1AD4..0x82EA1ADC)
	// 82EA1AD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA1AD8: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EA1ADC; continue 'dispatch;
            }
            0x82EA1ADC => {
    //   block [0x82EA1ADC..0x82EA1AFC)
	// 82EA1ADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1AE0: 4BA6C229  bl 0x8290dd08
	ctx.lr = 0x82EA1AE4;
	sub_8290DD08(ctx, base);
	// 82EA1AE4: 4BE0A0CD  bl 0x82cabbb0
	ctx.lr = 0x82EA1AE8;
	sub_82CABBB0(ctx, base);
	// 82EA1AE8: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EA1AEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA1AF0: C01D0030  lfs f0, 0x30(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA1AF4: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA1AF8: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EA1AFC; continue 'dispatch;
            }
            0x82EA1AFC => {
    //   block [0x82EA1AFC..0x82EA1B08)
	// 82EA1AFC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EA1B00: 41980008  blt cr6, 0x82ea1b08
	if ctx.cr[6].lt {
	pc = 0x82EA1B08; continue 'dispatch;
	}
	// 82EA1B04: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EA1B08; continue 'dispatch;
            }
            0x82EA1B08 => {
    //   block [0x82EA1B08..0x82EA1B18)
	// 82EA1B08: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EA1B0C: 409AFFF0  bne cr6, 0x82ea1afc
	if !ctx.cr[6].eq {
	pc = 0x82EA1AFC; continue 'dispatch;
	}
	// 82EA1B10: D01D0030  stfs f0, 0x30(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EA1B14: 4BFFFF80  b 0x82ea1a94
	pc = 0x82EA1A94; continue 'dispatch;
            }
            0x82EA1B18 => {
    //   block [0x82EA1B18..0x82EA1C04)
	// 82EA1B18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1B1C: 4831A545  bl 0x831bc060
	ctx.lr = 0x82EA1B20;
	sub_831BC060(ctx, base);
	// 82EA1B20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA1B24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EA1B28: 396BA198  addi r11, r11, -0x5e68
	ctx.r[11].s64 = ctx.r[11].s64 + -24168;
	// 82EA1B2C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA1B30: 4BE0B021  bl 0x82cacb50
	ctx.lr = 0x82EA1B34;
	sub_82CACB50(ctx, base);
	// 82EA1B34: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA1B38: 408200E4  bne 0x82ea1c1c
	if !ctx.cr[0].eq {
	pc = 0x82EA1C1C; continue 'dispatch;
	}
	// 82EA1B3C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EA1B40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1B44: 3BCB1694  addi r30, r11, 0x1694
	ctx.r[30].s64 = ctx.r[11].s64 + 5780;
	// 82EA1B48: 4BA6C1C1  bl 0x8290dd08
	ctx.lr = 0x82EA1B4C;
	sub_8290DD08(ctx, base);
	// 82EA1B4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA1B50: 4BE0B001  bl 0x82cacb50
	ctx.lr = 0x82EA1B54;
	sub_82CACB50(ctx, base);
	// 82EA1B54: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA1B58: 418200B4  beq 0x82ea1c0c
	if ctx.cr[0].eq {
	pc = 0x82EA1C0C; continue 'dispatch;
	}
	// 82EA1B5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA1B60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1B64: 3BCB0F40  addi r30, r11, 0xf40
	ctx.r[30].s64 = ctx.r[11].s64 + 3904;
	// 82EA1B68: 4BA6C1A1  bl 0x8290dd08
	ctx.lr = 0x82EA1B6C;
	sub_8290DD08(ctx, base);
	// 82EA1B6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA1B70: 4BE0AFE1  bl 0x82cacb50
	ctx.lr = 0x82EA1B74;
	sub_82CACB50(ctx, base);
	// 82EA1B74: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA1B78: 41820094  beq 0x82ea1c0c
	if ctx.cr[0].eq {
	pc = 0x82EA1C0C; continue 'dispatch;
	}
	// 82EA1B7C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EA1B80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1B84: 3BCBD56C  addi r30, r11, -0x2a94
	ctx.r[30].s64 = ctx.r[11].s64 + -10900;
	// 82EA1B88: 4BA6C181  bl 0x8290dd08
	ctx.lr = 0x82EA1B8C;
	sub_8290DD08(ctx, base);
	// 82EA1B8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA1B90: 4BE0AFC1  bl 0x82cacb50
	ctx.lr = 0x82EA1B94;
	sub_82CACB50(ctx, base);
	// 82EA1B94: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA1B98: 41820074  beq 0x82ea1c0c
	if ctx.cr[0].eq {
	pc = 0x82EA1C0C; continue 'dispatch;
	}
	// 82EA1B9C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EA1BA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1BA4: 3BCB1698  addi r30, r11, 0x1698
	ctx.r[30].s64 = ctx.r[11].s64 + 5784;
	// 82EA1BA8: 4BA6C161  bl 0x8290dd08
	ctx.lr = 0x82EA1BAC;
	sub_8290DD08(ctx, base);
	// 82EA1BAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA1BB0: 4BE0AFA1  bl 0x82cacb50
	ctx.lr = 0x82EA1BB4;
	sub_82CACB50(ctx, base);
	// 82EA1BB4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA1BB8: 4182004C  beq 0x82ea1c04
	if ctx.cr[0].eq {
	pc = 0x82EA1C04; continue 'dispatch;
	}
	// 82EA1BBC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EA1BC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1BC4: 3BCB1700  addi r30, r11, 0x1700
	ctx.r[30].s64 = ctx.r[11].s64 + 5888;
	// 82EA1BC8: 4BA6C141  bl 0x8290dd08
	ctx.lr = 0x82EA1BCC;
	sub_8290DD08(ctx, base);
	// 82EA1BCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA1BD0: 4BE0AF81  bl 0x82cacb50
	ctx.lr = 0x82EA1BD4;
	sub_82CACB50(ctx, base);
	// 82EA1BD4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA1BD8: 4182002C  beq 0x82ea1c04
	if ctx.cr[0].eq {
	pc = 0x82EA1C04; continue 'dispatch;
	}
	// 82EA1BDC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EA1BE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1BE4: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82EA1BE8: 4BA6C121  bl 0x8290dd08
	ctx.lr = 0x82EA1BEC;
	sub_8290DD08(ctx, base);
	// 82EA1BEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA1BF0: 4BE0AF61  bl 0x82cacb50
	ctx.lr = 0x82EA1BF4;
	sub_82CACB50(ctx, base);
	// 82EA1BF4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA1BF8: 4182000C  beq 0x82ea1c04
	if ctx.cr[0].eq {
	pc = 0x82EA1C04; continue 'dispatch;
	}
	// 82EA1BFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EA1C00: 48000028  b 0x82ea1c28
	pc = 0x82EA1C28; continue 'dispatch;
            }
            0x82EA1C04 => {
    //   block [0x82EA1C04..0x82EA1C0C)
	// 82EA1C04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EA1C08: 48000008  b 0x82ea1c10
	pc = 0x82EA1C10; continue 'dispatch;
            }
            0x82EA1C0C => {
    //   block [0x82EA1C0C..0x82EA1C10)
	// 82EA1C0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EA1C10; continue 'dispatch;
            }
            0x82EA1C10 => {
    //   block [0x82EA1C10..0x82EA1C1C)
	// 82EA1C10: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA1C14: 997D0034  stb r11, 0x34(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82EA1C18: 48000010  b 0x82ea1c28
	pc = 0x82EA1C28; continue 'dispatch;
            }
            0x82EA1C1C => {
    //   block [0x82EA1C1C..0x82EA1C28)
	// 82EA1C1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EA1C20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA1C24: 4BFFF655  bl 0x82ea1278
	ctx.lr = 0x82EA1C28;
	sub_82EA1278(ctx, base);
	pc = 0x82EA1C28; continue 'dispatch;
            }
            0x82EA1C28 => {
    //   block [0x82EA1C28..0x82EA1C34)
	// 82EA1C28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EA1C2C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EA1C30: 4BE0782C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA1C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EA1C38 size=428
    let mut pc: u32 = 0x82EA1C38;
    'dispatch: loop {
        match pc {
            0x82EA1C38 => {
    //   block [0x82EA1C38..0x82EA1C5C)
	// 82EA1C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA1C3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA1C40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA1C44: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82EA1C48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA1C4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA1C50: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA1C54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA1C58: 409A014C  bne cr6, 0x82ea1da4
	if !ctx.cr[6].eq {
	pc = 0x82EA1DA4; continue 'dispatch;
	}
	pc = 0x82EA1C5C; continue 'dispatch;
            }
            0x82EA1C5C => {
    //   block [0x82EA1C5C..0x82EA1C60)
	// 82EA1C5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EA1C60; continue 'dispatch;
            }
            0x82EA1C60 => {
    //   block [0x82EA1C60..0x82EA1C78)
	// 82EA1C60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA1C64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA1C68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA1C6C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EA1C70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA1C74: 4E800020  blr
	return;
            }
            0x82EA1C78 => {
    //   block [0x82EA1C78..0x82EA1CA8)
	// 82EA1C78: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA1C7C: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA1C80: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA1C84: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA1C88: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA1C8C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA1C90: 48031C49  bl 0x82ed38d8
	ctx.lr = 0x82EA1C94;
	sub_82ED38D8(ctx, base);
	// 82EA1C94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA1C98: 41820090  beq 0x82ea1d28
	if ctx.cr[0].eq {
	pc = 0x82EA1D28; continue 'dispatch;
	}
	// 82EA1C9C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA1CA0: 480328F1  bl 0x82ed4590
	ctx.lr = 0x82EA1CA4;
	sub_82ED4590(ctx, base);
	// 82EA1CA4: 4800007C  b 0x82ea1d20
	pc = 0x82EA1D20; continue 'dispatch;
            }
            0x82EA1CA8 => {
    //   block [0x82EA1CA8..0x82EA1D18)
	// 82EA1CA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA1CAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EA1CB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1CB4: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA1CB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA1CBC: 4E800421  bctrl
	ctx.lr = 0x82EA1CC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA1CC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA1CC4: 41820054  beq 0x82ea1d18
	if ctx.cr[0].eq {
	pc = 0x82EA1D18; continue 'dispatch;
	}
	// 82EA1CC8: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA1CCC: C1A10050  lfs f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA1CD0: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA1CD4: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA1CD8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA1CDC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA1CE0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA1CE4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA1CE8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EA1CEC: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82EA1CF0: 480333D1  bl 0x82ed50c0
	ctx.lr = 0x82EA1CF4;
	sub_82ED50C0(ctx, base);
	// 82EA1CF4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA1CF8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82EA1CFC: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA1D00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA1D04: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA1D08: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EA1D0C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA1D10: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA1D14: 4BFFFB35  bl 0x82ea1848
	ctx.lr = 0x82EA1D18;
	sub_82EA1848(ctx, base);
            }
            0x82EA1D18 => {
    //   block [0x82EA1D18..0x82EA1D20)
	// 82EA1D18: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA1D1C: 480319CD  bl 0x82ed36e8
	ctx.lr = 0x82EA1D20;
	sub_82ED36E8(ctx, base);
	pc = 0x82EA1D20; continue 'dispatch;
            }
            0x82EA1D20 => {
    //   block [0x82EA1D20..0x82EA1D28)
	// 82EA1D20: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EA1D24: 409AFF84  bne cr6, 0x82ea1ca8
	if !ctx.cr[6].eq {
	pc = 0x82EA1CA8; continue 'dispatch;
	}
	pc = 0x82EA1D28; continue 'dispatch;
            }
            0x82EA1D28 => {
    //   block [0x82EA1D28..0x82EA1D64)
	// 82EA1D28: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA1D2C: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA1D30: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA1D34: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA1D38: 894B000C  lbz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA1D3C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA1D40: 40820058  bne 0x82ea1d98
	if !ctx.cr[0].eq {
	pc = 0x82EA1D98; continue 'dispatch;
	}
	// 82EA1D44: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA1D48: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA1D4C: 48031B8D  bl 0x82ed38d8
	ctx.lr = 0x82EA1D50;
	sub_82ED38D8(ctx, base);
	// 82EA1D50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA1D54: 41820044  beq 0x82ea1d98
	if ctx.cr[0].eq {
	pc = 0x82EA1D98; continue 'dispatch;
	}
	// 82EA1D58: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA1D5C: 48032835  bl 0x82ed4590
	ctx.lr = 0x82EA1D60;
	sub_82ED4590(ctx, base);
	// 82EA1D60: 48000030  b 0x82ea1d90
	pc = 0x82EA1D90; continue 'dispatch;
            }
            0x82EA1D64 => {
    //   block [0x82EA1D64..0x82EA1D90)
	// 82EA1D64: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA1D68: 48033359  bl 0x82ed50c0
	ctx.lr = 0x82EA1D6C;
	sub_82ED50C0(ctx, base);
	// 82EA1D6C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA1D70: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA1D74: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA1D78: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA1D7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA1D80: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA1D84: 419A0034  beq cr6, 0x82ea1db8
	if ctx.cr[6].eq {
	pc = 0x82EA1DB8; continue 'dispatch;
	}
	// 82EA1D88: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA1D8C: 4803195D  bl 0x82ed36e8
	ctx.lr = 0x82EA1D90;
	sub_82ED36E8(ctx, base);
	pc = 0x82EA1D90; continue 'dispatch;
            }
            0x82EA1D90 => {
    //   block [0x82EA1D90..0x82EA1D98)
	// 82EA1D90: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EA1D94: 409AFFD0  bne cr6, 0x82ea1d64
	if !ctx.cr[6].eq {
	pc = 0x82EA1D64; continue 'dispatch;
	}
	pc = 0x82EA1D98; continue 'dispatch;
            }
            0x82EA1D98 => {
    //   block [0x82EA1D98..0x82EA1DA4)
	// 82EA1D98: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA1D9C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EA1DA0: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA1DA4; continue 'dispatch;
            }
            0x82EA1DA4 => {
    //   block [0x82EA1DA4..0x82EA1DB8)
	// 82EA1DA4: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA1DA8: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA1DAC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EA1DB0: 4198FEC8  blt cr6, 0x82ea1c78
	if ctx.cr[6].lt {
	pc = 0x82EA1C78; continue 'dispatch;
	}
	// 82EA1DB4: 4BFFFEA8  b 0x82ea1c5c
	pc = 0x82EA1C5C; continue 'dispatch;
            }
            0x82EA1DB8 => {
    //   block [0x82EA1DB8..0x82EA1DE4)
	// 82EA1DB8: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA1DBC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EA1DC0: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA1DC4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA1DC8: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA1DCC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA1DD0: 992B000C  stb r9, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u8 ) };
	// 82EA1DD4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA1DD8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EA1DDC: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EA1DE0: 4BFFFE80  b 0x82ea1c60
	pc = 0x82EA1C60; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA1DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA1DE8 size=104
    let mut pc: u32 = 0x82EA1DE8;
    'dispatch: loop {
        match pc {
            0x82EA1DE8 => {
    //   block [0x82EA1DE8..0x82EA1E28)
	// 82EA1DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA1DEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA1DF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EA1DF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA1DF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA1DFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA1E00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EA1E04: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EA1E08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA1E0C: 409A001C  bne cr6, 0x82ea1e28
	if !ctx.cr[6].eq {
	pc = 0x82EA1E28; continue 'dispatch;
	}
	// 82EA1E10: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA1E14: 388B6D70  addi r4, r11, 0x6d70
	ctx.r[4].s64 = ctx.r[11].s64 + 28016;
	// 82EA1E18: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA1E1C: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA1E20: 4B3C5E01  bl 0x82267c20
	ctx.lr = 0x82EA1E24;
	sub_82267C20(ctx, base);
	// 82EA1E24: 907F008C  stw r3, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	pc = 0x82EA1E28; continue 'dispatch;
            }
            0x82EA1E28 => {
    //   block [0x82EA1E28..0x82EA1E50)
	// 82EA1E28: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA1E2C: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EA1E30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EA1E34: 4BFFAD55  bl 0x82e9cb88
	ctx.lr = 0x82EA1E38;
	sub_82E9CB88(ctx, base);
	// 82EA1E38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA1E3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA1E40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA1E44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EA1E48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA1E4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA1E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA1E50 size=952
    let mut pc: u32 = 0x82EA1E50;
    'dispatch: loop {
        match pc {
            0x82EA1E50 => {
    //   block [0x82EA1E50..0x82EA1EB0)
	// 82EA1E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA1E54: 4BE07585  bl 0x82ca93d8
	ctx.lr = 0x82EA1E58;
	sub_82CA93D0(ctx, base);
	// 82EA1E58: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA1E5C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EA1E60: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 82EA1E64: 7D314B78  mr r17, r9
	ctx.r[17].u64 = ctx.r[9].u64;
	// 82EA1E68: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82EA1E6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA1E70: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 82EA1E74: 9BB50000  stb r29, 0(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82EA1E78: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82EA1E7C: 9BB10000  stb r29, 0(r17)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82EA1E80: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82EA1E84: 93BA0000  stw r29, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82EA1E88: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82EA1E8C: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EA1E90: 7FB2EB78  mr r18, r29
	ctx.r[18].u64 = ctx.r[29].u64;
	// 82EA1E94: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82EA1E98: 7FB7EB78  mr r23, r29
	ctx.r[23].u64 = ctx.r[29].u64;
	// 82EA1E9C: 3A000001  li r16, 1
	ctx.r[16].s64 = 1;
	// 82EA1EA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA1EA4: 409902F0  ble cr6, 0x82ea2194
	if !ctx.cr[6].gt {
	pc = 0x82EA2194; continue 'dispatch;
	}
	// 82EA1EA8: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82EA1EAC: 3A60FFFE  li r19, -2
	ctx.r[19].s64 = -2;
	pc = 0x82EA1EB0; continue 'dispatch;
            }
            0x82EA1EB0 => {
    //   block [0x82EA1EB0..0x82EA1F30)
	// 82EA1EB0: 5549063F  clrlwi. r9, r10, 0x18
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EA1EB4: 408202A4  bne 0x82ea2158
	if !ctx.cr[0].eq {
	pc = 0x82EA2158; continue 'dispatch;
	}
	// 82EA1EB8: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA1EBC: 571C007E  clrlwi r28, r24, 1
	ctx.r[28].u64 = ctx.r[24].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA1EC0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA1EC4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA1EC8: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA1ECC: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EA1ED0: 409A0288  bne cr6, 0x82ea2158
	if !ctx.cr[6].eq {
	pc = 0x82EA2158; continue 'dispatch;
	}
	// 82EA1ED4: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA1ED8: 56DB007E  clrlwi r27, r22, 1
	ctx.r[27].u64 = ctx.r[22].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA1EDC: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA1EE0: 7F08D840  cmplw cr6, r8, r27
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82EA1EE4: 409A0274  bne cr6, 0x82ea2158
	if !ctx.cr[6].eq {
	pc = 0x82EA2158; continue 'dispatch;
	}
	// 82EA1EE8: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA1EEC: 7F08C840  cmplw cr6, r8, r25
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82EA1EF0: 409A0268  bne cr6, 0x82ea2158
	if !ctx.cr[6].eq {
	pc = 0x82EA2158; continue 'dispatch;
	}
	// 82EA1EF4: 89540000  lbz r10, 0(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA1EF8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82EA1EFC: 409A0034  bne cr6, 0x82ea1f30
	if !ctx.cr[6].eq {
	pc = 0x82EA1F30; continue 'dispatch;
	}
	// 82EA1F00: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA1F04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA1F08: 419A0028  beq cr6, 0x82ea1f30
	if ctx.cr[6].eq {
	pc = 0x82EA1F30; continue 'dispatch;
	}
	// 82EA1F0C: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 82EA1F10: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA1F14: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82EA1F18: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82EA1F1C: 38E10051  addi r7, r1, 0x51
	ctx.r[7].s64 = ctx.r[1].s64 + 81;
	// 82EA1F20: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82EA1F24: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82EA1F28: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EA1F2C: 4BFFFF25  bl 0x82ea1e50
	ctx.lr = 0x82EA1F30;
	sub_82EA1E50(ctx, base);
	pc = 0x82EA1F30; continue 'dispatch;
            }
            0x82EA1F30 => {
    //   block [0x82EA1F30..0x82EA1FA8)
	// 82EA1F30: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA1F34: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA1F38: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA1F3C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA1F40: 409A026C  bne cr6, 0x82ea21ac
	if !ctx.cr[6].eq {
	pc = 0x82EA21AC; continue 'dispatch;
	}
	// 82EA1F44: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA1F48: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA1F4C: 93AB000C  stw r29, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EA1F50: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA1F54: 7FBE592E  stwx r29, r30, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), ctx.r[29].u32) };
	// 82EA1F58: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA1F5C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA1F60: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EA1F64: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA1F68: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA1F6C: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EA1F70: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA1F74: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA1F78: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA1F7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA1F80: 419A0100  beq cr6, 0x82ea2080
	if ctx.cr[6].eq {
	pc = 0x82EA2080; continue 'dispatch;
	}
	// 82EA1F84: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA1F88: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EA1F8C: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82EA1F90: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA1F94: 81270080  lwz r9, 0x80(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EA1F98: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA1F9C: 418200DC  beq 0x82ea2078
	if ctx.cr[0].eq {
	pc = 0x82EA2078; continue 'dispatch;
	}
	// 82EA1FA0: 8107007C  lwz r8, 0x7c(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA1FA4: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	pc = 0x82EA1FA8; continue 'dispatch;
            }
            0x82EA1FA8 => {
    //   block [0x82EA1FA8..0x82EA1FD4)
	// 82EA1FA8: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA1FAC: 54C6007E  clrlwi r6, r6, 1
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA1FB0: 7F06E040  cmplw cr6, r6, r28
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EA1FB4: 409A0020  bne cr6, 0x82ea1fd4
	if !ctx.cr[6].eq {
	pc = 0x82EA1FD4; continue 'dispatch;
	}
	// 82EA1FB8: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA1FBC: 54C6007E  clrlwi r6, r6, 1
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA1FC0: 7F06D840  cmplw cr6, r6, r27
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82EA1FC4: 409A0010  bne cr6, 0x82ea1fd4
	if !ctx.cr[6].eq {
	pc = 0x82EA1FD4; continue 'dispatch;
	}
	// 82EA1FC8: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA1FCC: 7F06C840  cmplw cr6, r6, r25
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82EA1FD0: 419A0018  beq cr6, 0x82ea1fe8
	if ctx.cr[6].eq {
	pc = 0x82EA1FE8; continue 'dispatch;
	}
	pc = 0x82EA1FD4; continue 'dispatch;
            }
            0x82EA1FD4 => {
    //   block [0x82EA1FD4..0x82EA1FE8)
	// 82EA1FD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EA1FD8: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 82EA1FDC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA1FE0: 4198FFC8  blt cr6, 0x82ea1fa8
	if ctx.cr[6].lt {
	pc = 0x82EA1FA8; continue 'dispatch;
	}
	// 82EA1FE4: 48000094  b 0x82ea2078
	pc = 0x82EA2078; continue 'dispatch;
            }
            0x82EA1FE8 => {
    //   block [0x82EA1FE8..0x82EA202C)
	// 82EA1FE8: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA1FEC: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA1FF0: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82EA1FF4: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82EA1FF8: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA1FFC: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EA2000: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA2004: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA2008: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA200C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2010: 41820068  beq 0x82ea2078
	if ctx.cr[0].eq {
	pc = 0x82EA2078; continue 'dispatch;
	}
	// 82EA2014: 812B0080  lwz r9, 0x80(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EA2018: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82EA201C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2020: 41820058  beq 0x82ea2078
	if ctx.cr[0].eq {
	pc = 0x82EA2078; continue 'dispatch;
	}
	// 82EA2024: 810B007C  lwz r8, 0x7c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA2028: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x82EA202C; continue 'dispatch;
            }
            0x82EA202C => {
    //   block [0x82EA202C..0x82EA2058)
	// 82EA202C: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2030: 54C6007E  clrlwi r6, r6, 1
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA2034: 7F06E040  cmplw cr6, r6, r28
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EA2038: 409A0020  bne cr6, 0x82ea2058
	if !ctx.cr[6].eq {
	pc = 0x82EA2058; continue 'dispatch;
	}
	// 82EA203C: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2040: 54C6007E  clrlwi r6, r6, 1
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA2044: 7F06D840  cmplw cr6, r6, r27
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82EA2048: 409A0010  bne cr6, 0x82ea2058
	if !ctx.cr[6].eq {
	pc = 0x82EA2058; continue 'dispatch;
	}
	// 82EA204C: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA2050: 7F06C840  cmplw cr6, r6, r25
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82EA2054: 419A0018  beq cr6, 0x82ea206c
	if ctx.cr[6].eq {
	pc = 0x82EA206C; continue 'dispatch;
	}
	pc = 0x82EA2058; continue 'dispatch;
            }
            0x82EA2058 => {
    //   block [0x82EA2058..0x82EA206C)
	// 82EA2058: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EA205C: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82EA2060: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA2064: 4198FFC8  blt cr6, 0x82ea202c
	if ctx.cr[6].lt {
	pc = 0x82EA202C; continue 'dispatch;
	}
	// 82EA2068: 48000010  b 0x82ea2078
	pc = 0x82EA2078; continue 'dispatch;
            }
            0x82EA206C => {
    //   block [0x82EA206C..0x82EA2078)
	// 82EA206C: 1D6A0018  mulli r11, r10, 0x18
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA2070: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82EA2074: 90EB0014  stw r7, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	pc = 0x82EA2078; continue 'dispatch;
            }
            0x82EA2078 => {
    //   block [0x82EA2078..0x82EA2080)
	// 82EA2078: 927A0000  stw r19, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[19].u32 ) };
	// 82EA207C: 48000020  b 0x82ea209c
	pc = 0x82EA209C; continue 'dispatch;
            }
            0x82EA2080 => {
    //   block [0x82EA2080..0x82EA2098)
	// 82EA2080: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA2084: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA2088: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA208C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2090: 40820008  bne 0x82ea2098
	if !ctx.cr[0].eq {
	pc = 0x82EA2098; continue 'dispatch;
	}
	// 82EA2094: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	pc = 0x82EA2098; continue 'dispatch;
            }
            0x82EA2098 => {
    //   block [0x82EA2098..0x82EA209C)
	// 82EA2098: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA209C; continue 'dispatch;
            }
            0x82EA209C => {
    //   block [0x82EA209C..0x82EA20D4)
	// 82EA209C: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA20A0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA20A4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA20A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA20AC: 409A0074  bne cr6, 0x82ea2120
	if !ctx.cr[6].eq {
	pc = 0x82EA2120; continue 'dispatch;
	}
	// 82EA20B0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA20B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA20B8: 41820068  beq 0x82ea2120
	if ctx.cr[0].eq {
	pc = 0x82EA2120; continue 'dispatch;
	}
	// 82EA20BC: 812B0080  lwz r9, 0x80(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EA20C0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82EA20C4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA20C8: 41820058  beq 0x82ea2120
	if ctx.cr[0].eq {
	pc = 0x82EA2120; continue 'dispatch;
	}
	// 82EA20CC: 810B007C  lwz r8, 0x7c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA20D0: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x82EA20D4; continue 'dispatch;
            }
            0x82EA20D4 => {
    //   block [0x82EA20D4..0x82EA2100)
	// 82EA20D4: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA20D8: 54E7007E  clrlwi r7, r7, 1
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA20DC: 7F07E040  cmplw cr6, r7, r28
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EA20E0: 409A0020  bne cr6, 0x82ea2100
	if !ctx.cr[6].eq {
	pc = 0x82EA2100; continue 'dispatch;
	}
	// 82EA20E4: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA20E8: 54E7007E  clrlwi r7, r7, 1
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA20EC: 7F07D840  cmplw cr6, r7, r27
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82EA20F0: 409A0010  bne cr6, 0x82ea2100
	if !ctx.cr[6].eq {
	pc = 0x82EA2100; continue 'dispatch;
	}
	// 82EA20F4: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA20F8: 7F07C840  cmplw cr6, r7, r25
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82EA20FC: 419A0018  beq cr6, 0x82ea2114
	if ctx.cr[6].eq {
	pc = 0x82EA2114; continue 'dispatch;
	}
	pc = 0x82EA2100; continue 'dispatch;
            }
            0x82EA2100 => {
    //   block [0x82EA2100..0x82EA2114)
	// 82EA2100: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EA2104: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82EA2108: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA210C: 4198FFC8  blt cr6, 0x82ea20d4
	if ctx.cr[6].lt {
	pc = 0x82EA20D4; continue 'dispatch;
	}
	// 82EA2110: 48000010  b 0x82ea2120
	pc = 0x82EA2120; continue 'dispatch;
            }
            0x82EA2114 => {
    //   block [0x82EA2114..0x82EA2120)
	// 82EA2114: 1D6A0018  mulli r11, r10, 0x18
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA2118: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82EA211C: 93AB0014  stw r29, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	pc = 0x82EA2120; continue 'dispatch;
            }
            0x82EA2120 => {
    //   block [0x82EA2120..0x82EA2138)
	// 82EA2120: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA2124: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA2128: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA212C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA2130: 409A0008  bne cr6, 0x82ea2138
	if !ctx.cr[6].eq {
	pc = 0x82EA2138; continue 'dispatch;
	}
	// 82EA2134: 9A110000  stb r16, 0(r17)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[16].u8 ) };
	pc = 0x82EA2138; continue 'dispatch;
            }
            0x82EA2138 => {
    //   block [0x82EA2138..0x82EA2158)
	// 82EA2138: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA213C: 7E0A8378  mr r10, r16
	ctx.r[10].u64 = ctx.r[16].u64;
	// 82EA2140: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA2144: 93AB0010  stw r29, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82EA2148: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA214C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA2150: 93AB0014  stw r29, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82EA2154: 4800002C  b 0x82ea2180
	pc = 0x82EA2180; continue 'dispatch;
            }
            0x82EA2158 => {
    //   block [0x82EA2158..0x82EA2178)
	// 82EA2158: 564B063F  clrlwi. r11, r18, 0x18
	ctx.r[11].u64 = ctx.r[18].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA215C: 4082001C  bne 0x82ea2178
	if !ctx.cr[0].eq {
	pc = 0x82EA2178; continue 'dispatch;
	}
	// 82EA2160: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA2164: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA2168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA216C: 419A0014  beq cr6, 0x82ea2180
	if ctx.cr[6].eq {
	pc = 0x82EA2180; continue 'dispatch;
	}
	// 82EA2170: 7E128378  mr r18, r16
	ctx.r[18].u64 = ctx.r[16].u64;
	// 82EA2174: 4800000C  b 0x82ea2180
	pc = 0x82EA2180; continue 'dispatch;
            }
            0x82EA2178 => {
    //   block [0x82EA2178..0x82EA2180)
	// 82EA2178: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EA217C: 409A0024  bne cr6, 0x82ea21a0
	if !ctx.cr[6].eq {
	pc = 0x82EA21A0; continue 'dispatch;
	}
	pc = 0x82EA2180; continue 'dispatch;
            }
            0x82EA2180 => {
    //   block [0x82EA2180..0x82EA2194)
	// 82EA2180: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EA2184: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82EA2188: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 82EA218C: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA2190: 4198FD20  blt cr6, 0x82ea1eb0
	if ctx.cr[6].lt {
	pc = 0x82EA1EB0; continue 'dispatch;
	}
	pc = 0x82EA2194; continue 'dispatch;
            }
            0x82EA2194 => {
    //   block [0x82EA2194..0x82EA21A0)
	// 82EA2194: 564B063F  clrlwi. r11, r18, 0x18
	ctx.r[11].u64 = ctx.r[18].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA2198: 40820008  bne 0x82ea21a0
	if !ctx.cr[0].eq {
	pc = 0x82EA21A0; continue 'dispatch;
	}
	// 82EA219C: 9A150000  stb r16, 0(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[16].u8 ) };
	pc = 0x82EA21A0; continue 'dispatch;
            }
            0x82EA21A0 => {
    //   block [0x82EA21A0..0x82EA21AC)
	// 82EA21A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA21A4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EA21A8: 4BE07280  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EA21AC => {
    //   block [0x82EA21AC..0x82EA21D8)
	// 82EA21AC: 927A0000  stw r19, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[19].u32 ) };
	// 82EA21B0: 1D770018  mulli r11, r23, 0x18
	ctx.r[11].s32 = ((ctx.r[23].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA21B4: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA21B8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA21BC: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA21C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EA21C4: 409A0014  bne cr6, 0x82ea21d8
	if !ctx.cr[6].eq {
	pc = 0x82EA21D8; continue 'dispatch;
	}
	// 82EA21C8: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA21CC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA21D0: 41820008  beq 0x82ea21d8
	if ctx.cr[0].eq {
	pc = 0x82EA21D8; continue 'dispatch;
	}
	// 82EA21D4: 915A0000  stw r10, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA21D8; continue 'dispatch;
            }
            0x82EA21D8 => {
    //   block [0x82EA21D8..0x82EA2208)
	// 82EA21D8: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA21DC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA21E0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA21E4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82EA21E8: 912A000C  stw r9, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EA21EC: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA21F0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA21F4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA21F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA21FC: 409AFFA4  bne cr6, 0x82ea21a0
	if !ctx.cr[6].eq {
	pc = 0x82EA21A0; continue 'dispatch;
	}
	// 82EA2200: 9A110000  stb r16, 0(r17)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[16].u8 ) };
	// 82EA2204: 4BFFFF9C  b 0x82ea21a0
	pc = 0x82EA21A0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA2208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA2208 size=176
    let mut pc: u32 = 0x82EA2208;
    'dispatch: loop {
        match pc {
            0x82EA2208 => {
    //   block [0x82EA2208..0x82EA2238)
	// 82EA2208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA220C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA2210: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA2214: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA2218: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA221C: 3D600AAA  lis r11, 0xaaa
	ctx.r[11].s64 = 178913280;
	// 82EA2220: 1C640018  mulli r3, r4, 0x18
	ctx.r[3].s32 = ((ctx.r[4].s32 as i64 * 24 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82EA2224: 909F0080  stw r4, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[4].u32 ) };
	// 82EA2228: 616BAAAA  ori r11, r11, 0xaaaa
	ctx.r[11].u64 = ctx.r[11].u64 | 43690;
	// 82EA222C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA2230: 40990008  ble cr6, 0x82ea2238
	if !ctx.cr[6].gt {
	pc = 0x82EA2238; continue 'dispatch;
	}
	// 82EA2234: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82EA2238; continue 'dispatch;
            }
            0x82EA2238 => {
    //   block [0x82EA2238..0x82EA2258)
	// 82EA2238: 4B7746F1  bl 0x82616928
	ctx.lr = 0x82EA223C;
	sub_82616928(ctx, base);
	// 82EA223C: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EA2240: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EA2244: 907F007C  stw r3, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 82EA2248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA224C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EA2250: 40990054  ble cr6, 0x82ea22a4
	if !ctx.cr[6].gt {
	pc = 0x82EA22A4; continue 'dispatch;
	}
	// 82EA2254: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82EA2258; continue 'dispatch;
            }
            0x82EA2258 => {
    //   block [0x82EA2258..0x82EA22A4)
	// 82EA2258: 811F007C  lwz r8, 0x7c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA225C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EA2260: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82EA2264: 91480010  stw r10, 0x10(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EA2268: 811F007C  lwz r8, 0x7c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA226C: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82EA2270: 91480014  stw r10, 0x14(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EA2274: 811F007C  lwz r8, 0x7c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA2278: 7D48592E  stwx r10, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 82EA227C: 811F007C  lwz r8, 0x7c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA2280: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82EA2284: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EA2288: 811F007C  lwz r8, 0x7c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA228C: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82EA2290: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82EA2294: 9148000C  stw r10, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EA2298: 811F0080  lwz r8, 0x80(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EA229C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EA22A0: 4198FFB8  blt cr6, 0x82ea2258
	if ctx.cr[6].lt {
	pc = 0x82EA2258; continue 'dispatch;
	}
	pc = 0x82EA22A4; continue 'dispatch;
            }
            0x82EA22A4 => {
    //   block [0x82EA22A4..0x82EA22B8)
	// 82EA22A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA22A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA22AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA22B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA22B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA22B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA22B8 size=96
    let mut pc: u32 = 0x82EA22B8;
    'dispatch: loop {
        match pc {
            0x82EA22B8 => {
    //   block [0x82EA22B8..0x82EA22D4)
	// 82EA22B8: 81030080  lwz r8, 0x80(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EA22BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EA22C0: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA22C4: 4182004C  beq 0x82ea2310
	if ctx.cr[0].eq {
	pc = 0x82EA2310; continue 'dispatch;
	}
	// 82EA22C8: 8123007C  lwz r9, 0x7c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA22CC: 5487007E  clrlwi r7, r4, 1
	ctx.r[7].u64 = ctx.r[4].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA22D0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82EA22D4; continue 'dispatch;
            }
            0x82EA22D4 => {
    //   block [0x82EA22D4..0x82EA2300)
	// 82EA22D4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA22D8: 5484007E  clrlwi r4, r4, 1
	ctx.r[4].u64 = ctx.r[4].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA22DC: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EA22E0: 409A0020  bne cr6, 0x82ea2300
	if !ctx.cr[6].eq {
	pc = 0x82EA2300; continue 'dispatch;
	}
	// 82EA22E4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA22E8: 7C842A78  xor r4, r4, r5
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[5].u64;
	// 82EA22EC: 5484007F  clrlwi. r4, r4, 1
	ctx.r[4].u64 = ctx.r[4].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82EA22F0: 40820010  bne 0x82ea2300
	if !ctx.cr[0].eq {
	pc = 0x82EA2300; continue 'dispatch;
	}
	// 82EA22F4: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA22F8: 7F043040  cmplw cr6, r4, r6
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EA22FC: 419A001C  beq cr6, 0x82ea2318
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82EA2318);
		return;
	}
	pc = 0x82EA2300; continue 'dispatch;
            }
            0x82EA2300 => {
    //   block [0x82EA2300..0x82EA2310)
	// 82EA2300: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EA2304: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82EA2308: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EA230C: 4198FFC8  blt cr6, 0x82ea22d4
	if ctx.cr[6].lt {
	pc = 0x82EA22D4; continue 'dispatch;
	}
	pc = 0x82EA2310; continue 'dispatch;
            }
            0x82EA2310 => {
    //   block [0x82EA2310..0x82EA2318)
	// 82EA2310: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EA2314: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA2328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA2328 size=280
    let mut pc: u32 = 0x82EA2328;
    'dispatch: loop {
        match pc {
            0x82EA2328 => {
    //   block [0x82EA2328..0x82EA2330)
	// 82EA2328: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82EA232C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	pc = 0x82EA2330; continue 'dispatch;
            }
            0x82EA2330 => {
    //   block [0x82EA2330..0x82EA233C)
	// 82EA2330: 80680080  lwz r3, 0x80(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EA2334: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EA2338: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82EA233C; continue 'dispatch;
            }
            0x82EA233C => {
    //   block [0x82EA233C..0x82EA2378)
	// 82EA233C: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EA2340: 409800F4  bge cr6, 0x82ea2434
	if !ctx.cr[6].lt {
	pc = 0x82EA2434; continue 'dispatch;
	}
	// 82EA2344: 8168007C  lwz r11, 0x7c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA2348: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EA234C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2350: 7C9FFA78  xor r31, r4, r31
	ctx.r[31].u64 = ctx.r[4].u64 ^ ctx.r[31].u64;
	// 82EA2354: 57FF007F  clrlwi. r31, r31, 1
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EA2358: 40820020  bne 0x82ea2378
	if !ctx.cr[0].eq {
	pc = 0x82EA2378; continue 'dispatch;
	}
	// 82EA235C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2360: 7FFF2A78  xor r31, r31, r5
	ctx.r[31].u64 = ctx.r[31].u64 ^ ctx.r[5].u64;
	// 82EA2364: 57FF007F  clrlwi. r31, r31, 1
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EA2368: 40820010  bne 0x82ea2378
	if !ctx.cr[0].eq {
	pc = 0x82EA2378; continue 'dispatch;
	}
	// 82EA236C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA2370: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EA2374: 419A0010  beq cr6, 0x82ea2384
	if ctx.cr[6].eq {
	pc = 0x82EA2384; continue 'dispatch;
	}
	pc = 0x82EA2378; continue 'dispatch;
            }
            0x82EA2378 => {
    //   block [0x82EA2378..0x82EA2384)
	// 82EA2378: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EA237C: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 82EA2380: 4BFFFFBC  b 0x82ea233c
	pc = 0x82EA233C; continue 'dispatch;
            }
            0x82EA2384 => {
    //   block [0x82EA2384..0x82EA23AC)
	// 82EA2384: 8168007C  lwz r11, 0x7c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA2388: 1D2A0018  mulli r9, r10, 0x18
	ctx.r[9].s32 = ((ctx.r[10].s32 as i64 * 24 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82EA238C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EA2390: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2394: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2398: 41820014  beq 0x82ea23ac
	if ctx.cr[0].eq {
	pc = 0x82EA23AC; continue 'dispatch;
	}
	// 82EA239C: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EA23A0: 419A0078  beq cr6, 0x82ea2418
	if ctx.cr[6].eq {
	pc = 0x82EA2418; continue 'dispatch;
	}
	// 82EA23A4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA23A8: 4BFFFF88  b 0x82ea2330
	pc = 0x82EA2330; continue 'dispatch;
            }
            0x82EA23AC => {
    //   block [0x82EA23AC..0x82EA23DC)
	// 82EA23AC: 8168007C  lwz r11, 0x7c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA23B0: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA23B4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA23B8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EA23BC: 90EB0010  stw r7, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 82EA23C0: 80670080  lwz r3, 0x80(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EA23C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA23C8: 41820050  beq 0x82ea2418
	if ctx.cr[0].eq {
	pc = 0x82EA2418; continue 'dispatch;
	}
	// 82EA23CC: 8147007C  lwz r10, 0x7c(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA23D0: 54A5007E  clrlwi r5, r5, 1
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA23D4: 5487007E  clrlwi r7, r4, 1
	ctx.r[7].u64 = ctx.r[4].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA23D8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82EA23DC; continue 'dispatch;
            }
            0x82EA23DC => {
    //   block [0x82EA23DC..0x82EA2408)
	// 82EA23DC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA23E0: 5484007E  clrlwi r4, r4, 1
	ctx.r[4].u64 = ctx.r[4].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA23E4: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EA23E8: 409A0020  bne cr6, 0x82ea2408
	if !ctx.cr[6].eq {
	pc = 0x82EA2408; continue 'dispatch;
	}
	// 82EA23EC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA23F0: 5484007E  clrlwi r4, r4, 1
	ctx.r[4].u64 = ctx.r[4].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA23F4: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EA23F8: 409A0010  bne cr6, 0x82ea2408
	if !ctx.cr[6].eq {
	pc = 0x82EA2408; continue 'dispatch;
	}
	// 82EA23FC: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA2400: 7F043040  cmplw cr6, r4, r6
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EA2404: 419A001C  beq cr6, 0x82ea2420
	if ctx.cr[6].eq {
	pc = 0x82EA2420; continue 'dispatch;
	}
	pc = 0x82EA2408; continue 'dispatch;
            }
            0x82EA2408 => {
    //   block [0x82EA2408..0x82EA2418)
	// 82EA2408: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EA240C: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82EA2410: 7F091840  cmplw cr6, r9, r3
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EA2414: 4198FFC8  blt cr6, 0x82ea23dc
	if ctx.cr[6].lt {
	pc = 0x82EA23DC; continue 'dispatch;
	}
	pc = 0x82EA2418; continue 'dispatch;
            }
            0x82EA2418 => {
    //   block [0x82EA2418..0x82EA2420)
	// 82EA2418: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA241C: 4800001C  b 0x82ea2438
	pc = 0x82EA2438; continue 'dispatch;
            }
            0x82EA2420 => {
    //   block [0x82EA2420..0x82EA2434)
	// 82EA2420: 1D690018  mulli r11, r9, 0x18
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA2424: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA2428: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA242C: 910B0014  stw r8, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EA2430: 48000008  b 0x82ea2438
	pc = 0x82EA2438; continue 'dispatch;
            }
            0x82EA2434 => {
    //   block [0x82EA2434..0x82EA2438)
	// 82EA2434: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EA2438; continue 'dispatch;
            }
            0x82EA2438 => {
    //   block [0x82EA2438..0x82EA2440)
	// 82EA2438: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82EA243C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA2440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA2440 size=268
    let mut pc: u32 = 0x82EA2440;
    'dispatch: loop {
        match pc {
            0x82EA2440 => {
    //   block [0x82EA2440..0x82EA246C)
	// 82EA2440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA2444: 4BE06FC9  bl 0x82ca940c
	ctx.lr = 0x82EA2448;
	sub_82CA93D0(ctx, base);
	// 82EA2448: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EA244C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EA2450: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 82EA2454: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 82EA2458: 806B0080  lwz r3, 0x80(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EA245C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2460: 41820074  beq 0x82ea24d4
	if ctx.cr[0].eq {
	pc = 0x82EA24D4; continue 'dispatch;
	}
	// 82EA2464: 549E007E  clrlwi r30, r4, 1
	ctx.r[30].u64 = ctx.r[4].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA2468: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	pc = 0x82EA246C; continue 'dispatch;
            }
            0x82EA246C => {
    //   block [0x82EA246C..0x82EA2488)
	// 82EA246C: 2F07FFFF  cmpwi cr6, r7, -1
	ctx.cr[6].compare_i32(ctx.r[7].s32, -1, &mut ctx.xer);
	// 82EA2470: 409A0018  bne cr6, 0x82ea2488
	if !ctx.cr[6].eq {
	pc = 0x82EA2488; continue 'dispatch;
	}
	// 82EA2474: 814B007C  lwz r10, 0x7c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA2478: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EA247C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA2480: 409A0008  bne cr6, 0x82ea2488
	if !ctx.cr[6].eq {
	pc = 0x82EA2488; continue 'dispatch;
	}
	// 82EA2484: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	pc = 0x82EA2488; continue 'dispatch;
            }
            0x82EA2488 => {
    //   block [0x82EA2488..0x82EA24BC)
	// 82EA2488: 814B007C  lwz r10, 0x7c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA248C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EA2490: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2494: 57BD007E  clrlwi r29, r29, 1
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0x7FFFFFFFu64;
	// 82EA2498: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EA249C: 409A0020  bne cr6, 0x82ea24bc
	if !ctx.cr[6].eq {
	pc = 0x82EA24BC; continue 'dispatch;
	}
	// 82EA24A0: 83AA0004  lwz r29, 4(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA24A4: 7FBD2A78  xor r29, r29, r5
	ctx.r[29].u64 = ctx.r[29].u64 ^ ctx.r[5].u64;
	// 82EA24A8: 57BD007F  clrlwi. r29, r29, 1
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82EA24AC: 40820010  bne 0x82ea24bc
	if !ctx.cr[0].eq {
	pc = 0x82EA24BC; continue 'dispatch;
	}
	// 82EA24B0: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA24B4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EA24B8: 419A0024  beq cr6, 0x82ea24dc
	if ctx.cr[6].eq {
	pc = 0x82EA24DC; continue 'dispatch;
	}
	pc = 0x82EA24BC; continue 'dispatch;
            }
            0x82EA24BC => {
    //   block [0x82EA24BC..0x82EA24D4)
	// 82EA24BC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EA24C0: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 82EA24C4: 7F081840  cmplw cr6, r8, r3
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EA24C8: 4198FFA4  blt cr6, 0x82ea246c
	if ctx.cr[6].lt {
	pc = 0x82EA246C; continue 'dispatch;
	}
	// 82EA24CC: 2F07FFFF  cmpwi cr6, r7, -1
	ctx.cr[6].compare_i32(ctx.r[7].s32, -1, &mut ctx.xer);
	// 82EA24D0: 409A0028  bne cr6, 0x82ea24f8
	if !ctx.cr[6].eq {
	pc = 0x82EA24F8; continue 'dispatch;
	}
	pc = 0x82EA24D4; continue 'dispatch;
            }
            0x82EA24D4 => {
    //   block [0x82EA24D4..0x82EA24DC)
	// 82EA24D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EA24D8: 48000070  b 0x82ea2548
	pc = 0x82EA2548; continue 'dispatch;
            }
            0x82EA24DC => {
    //   block [0x82EA24DC..0x82EA24F8)
	// 82EA24DC: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA24E0: 1D480018  mulli r10, r8, 0x18
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA24E4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA24E8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA24EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EA24F0: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EA24F4: 48000050  b 0x82ea2544
	pc = 0x82EA2544; continue 'dispatch;
            }
            0x82EA24F8 => {
    //   block [0x82EA24F8..0x82EA2544)
	// 82EA24F8: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA24FC: 1D470018  mulli r10, r7, 0x18
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA2500: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EA2504: 7C89512E  stwx r4, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[4].u32) };
	// 82EA2508: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA250C: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EA2510: 90A90004  stw r5, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82EA2514: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA2518: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EA251C: 90C90008  stw r6, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82EA2520: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA2524: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EA2528: 9109000C  stw r8, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EA252C: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA2530: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EA2534: 93E90010  stw r31, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82EA2538: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EA253C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA2540: 93EB0014  stw r31, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	pc = 0x82EA2544; continue 'dispatch;
            }
            0x82EA2544 => {
    //   block [0x82EA2544..0x82EA2548)
	// 82EA2544: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EA2548; continue 'dispatch;
            }
            0x82EA2548 => {
    //   block [0x82EA2548..0x82EA254C)
	// 82EA2548: 4BE06F14  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA2550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA2550 size=68
    let mut pc: u32 = 0x82EA2550;
    'dispatch: loop {
        match pc {
            0x82EA2550 => {
    //   block [0x82EA2550..0x82EA2594)
	// 82EA2550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA2554: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA2558: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA255C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA2560: 548BE8FE  srwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shr(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA2564: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA2568: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82EA256C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82EA2570: 4B7743B9  bl 0x82616928
	ctx.lr = 0x82EA2574;
	sub_82616928(ctx, base);
	// 82EA2574: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EA2578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA257C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA2580: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA2584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA2588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA258C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA2590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA2598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA2598 size=72
    let mut pc: u32 = 0x82EA2598;
    'dispatch: loop {
        match pc {
            0x82EA2598 => {
    //   block [0x82EA2598..0x82EA25E0)
	// 82EA2598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA259C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA25A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA25A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA25A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA25AC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA25B0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA25B4: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA25B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA25BC: 4E800421  bctrl
	ctx.lr = 0x82EA25C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA25C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EA25C4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EA25C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA25CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA25D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA25D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA25D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA25DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA25E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA25E0 size=24
    let mut pc: u32 = 0x82EA25E0;
    'dispatch: loop {
        match pc {
            0x82EA25E0 => {
    //   block [0x82EA25E0..0x82EA25F8)
	// 82EA25E0: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA25E4: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA25E8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA25EC: 4082000C  bne 0x82ea25f8
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82EA25F8);
		return;
	}
	// 82EA25F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EA25F4: 4BE073BC  b 0x82ca99b0
	sub_82CA99B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA2600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA2600 size=72
    let mut pc: u32 = 0x82EA2600;
    'dispatch: loop {
        match pc {
            0x82EA2600 => {
    //   block [0x82EA2600..0x82EA263C)
	// 82EA2600: 548B077E  clrlwi r11, r4, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000007u64;
	// 82EA2604: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EA2608: 212B0007  subfic r9, r11, 7
	ctx.xer.ca = ctx.r[11].u32 <= 7 as u32;
	ctx.r[9].s64 = (7 as i64) - ctx.r[11].s64;
	// 82EA260C: 548BE8FE  srwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shr(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA2610: 54A8063F  clrlwi. r8, r5, 0x18
	ctx.r[8].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EA2614: 7D4A4830  slw r10, r10, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 82EA2618: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA261C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EA2620: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EA2624: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EA2628: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA262C: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 82EA2630: 4182000C  beq 0x82ea263c
	if ctx.cr[0].eq {
	pc = 0x82EA263C; continue 'dispatch;
	}
	// 82EA2634: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EA2638: 48000008  b 0x82ea2640
	pc = 0x82EA2640; continue 'dispatch;
            }
            0x82EA263C => {
    //   block [0x82EA263C..0x82EA2640)
	// 82EA263C: 7D2A5078  andc r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[10].u64;
	pc = 0x82EA2640; continue 'dispatch;
            }
            0x82EA2640 => {
    //   block [0x82EA2640..0x82EA2648)
	// 82EA2640: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EA2644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA2648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA2648 size=36
    let mut pc: u32 = 0x82EA2648;
    'dispatch: loop {
        match pc {
            0x82EA2648 => {
    //   block [0x82EA2648..0x82EA266C)
	// 82EA2648: 548B077E  clrlwi r11, r4, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000007u64;
	// 82EA264C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2650: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EA2654: 216B0007  subfic r11, r11, 7
	ctx.xer.ca = ctx.r[11].u32 <= 7 as u32;
	ctx.r[11].s64 = (7 as i64) - ctx.r[11].s64;
	// 82EA2658: 5488E8FE  srwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shr(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EA265C: 7D4850AE  lbzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA2660: 7D2B5830  slw r11, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 82EA2664: 7D635038  and r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 82EA2668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA2670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA2670 size=188
    let mut pc: u32 = 0x82EA2670;
    'dispatch: loop {
        match pc {
            0x82EA2670 => {
    //   block [0x82EA2670..0x82EA26A4)
	// 82EA2670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA2674: 4BE06D99  bl 0x82ca940c
	ctx.lr = 0x82EA2678;
	sub_82CA93D0(ctx, base);
	// 82EA2678: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA267C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA2680: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EA2684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA2688: 409A001C  bne cr6, 0x82ea26a4
	if !ctx.cr[6].eq {
	pc = 0x82EA26A4; continue 'dispatch;
	}
	// 82EA268C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA2690: 388B6D70  addi r4, r11, 0x6d70
	ctx.r[4].s64 = ctx.r[11].s64 + 28016;
	// 82EA2694: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA2698: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA269C: 4B3C5585  bl 0x82267c20
	ctx.lr = 0x82EA26A0;
	sub_82267C20(ctx, base);
	// 82EA26A0: 907F008C  stw r3, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	pc = 0x82EA26A4; continue 'dispatch;
            }
            0x82EA26A4 => {
    //   block [0x82EA26A4..0x82EA26C4)
	// 82EA26A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EA26A8: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EA26AC: 4BFF9F25  bl 0x82e9c5d0
	ctx.lr = 0x82EA26B0;
	sub_82E9C5D0(ctx, base);
	// 82EA26B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA26B4: 40820070  bne 0x82ea2724
	if !ctx.cr[0].eq {
	pc = 0x82EA2724; continue 'dispatch;
	}
	// 82EA26B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EA26BC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EA26C0: 3BAB9E5C  addi r29, r11, -0x61a4
	ctx.r[29].s64 = ctx.r[11].s64 + -24996;
	pc = 0x82EA26C4; continue 'dispatch;
            }
            0x82EA26C4 => {
    //   block [0x82EA26C4..0x82EA2718)
	// 82EA26C4: 57CB077E  clrlwi r11, r30, 0x1d
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000007u64;
	// 82EA26C8: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EA26CC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EA26D0: 216B0007  subfic r11, r11, 7
	ctx.xer.ca = ctx.r[11].u32 <= 7 as u32;
	ctx.r[11].s64 = (7 as i64) - ctx.r[11].s64;
	// 82EA26D4: 57C8E8FE  srwi r8, r30, 3
	ctx.r[8].u32 = ctx.r[30].u32.wrapping_shr(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EA26D8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA26DC: 7D4850AE  lbzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA26E0: 7D2B5830  slw r11, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 82EA26E4: 7D6B5039  and. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA26E8: 41820030  beq 0x82ea2718
	if ctx.cr[0].eq {
	pc = 0x82EA2718; continue 'dispatch;
	}
	// 82EA26EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA26F0: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EA26F4: 4BFF9FCD  bl 0x82e9c6c0
	ctx.lr = 0x82EA26F8;
	sub_82E9C6C0(ctx, base);
	// 82EA26F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA26FC: 4182001C  beq 0x82ea2718
	if ctx.cr[0].eq {
	pc = 0x82EA2718; continue 'dispatch;
	}
	// 82EA2700: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EA2704: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA2708: 4B3C4E09  bl 0x82267510
	ctx.lr = 0x82EA270C;
	sub_82267510(ctx, base);
	// 82EA270C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2710: 41820008  beq 0x82ea2718
	if ctx.cr[0].eq {
	pc = 0x82EA2718; continue 'dispatch;
	}
	// 82EA2714: 480130F5  bl 0x82eb5808
	ctx.lr = 0x82EA2718;
	sub_82EB5808(ctx, base);
	pc = 0x82EA2718; continue 'dispatch;
            }
            0x82EA2718 => {
    //   block [0x82EA2718..0x82EA2724)
	// 82EA2718: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EA271C: 2B1E0100  cmplwi cr6, r30, 0x100
	ctx.cr[6].compare_u32(ctx.r[30].u32, 256 as u32, &mut ctx.xer);
	// 82EA2720: 4198FFA4  blt cr6, 0x82ea26c4
	if ctx.cr[6].lt {
	pc = 0x82EA26C4; continue 'dispatch;
	}
	pc = 0x82EA2724; continue 'dispatch;
            }
            0x82EA2724 => {
    //   block [0x82EA2724..0x82EA272C)
	// 82EA2724: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA2728: 4BE06D34  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA2730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA2730 size=132
    let mut pc: u32 = 0x82EA2730;
    'dispatch: loop {
        match pc {
            0x82EA2730 => {
    //   block [0x82EA2730..0x82EA274C)
	// 82EA2730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA2734: 4BE06CD9  bl 0x82ca940c
	ctx.lr = 0x82EA2738;
	sub_82CA93D0(ctx, base);
	// 82EA2738: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA273C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EA2740: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EA2744: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EA2748: 3BAB9E5C  addi r29, r11, -0x61a4
	ctx.r[29].s64 = ctx.r[11].s64 + -24996;
	pc = 0x82EA274C; continue 'dispatch;
            }
            0x82EA274C => {
    //   block [0x82EA274C..0x82EA27A0)
	// 82EA274C: 57EB077E  clrlwi r11, r31, 0x1d
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000007u64;
	// 82EA2750: 815E0084  lwz r10, 0x84(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EA2754: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EA2758: 216B0007  subfic r11, r11, 7
	ctx.xer.ca = ctx.r[11].u32 <= 7 as u32;
	ctx.r[11].s64 = (7 as i64) - ctx.r[11].s64;
	// 82EA275C: 57E8E8FE  srwi r8, r31, 3
	ctx.r[8].u32 = ctx.r[31].u32.wrapping_shr(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EA2760: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2764: 7D4850AE  lbzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA2768: 7D2B5830  slw r11, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 82EA276C: 7D6B5039  and. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA2770: 41820030  beq 0x82ea27a0
	if ctx.cr[0].eq {
	pc = 0x82EA27A0; continue 'dispatch;
	}
	// 82EA2774: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EA2778: 807E008C  lwz r3, 0x8c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EA277C: 4BFF9F45  bl 0x82e9c6c0
	ctx.lr = 0x82EA2780;
	sub_82E9C6C0(ctx, base);
	// 82EA2780: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2784: 4182001C  beq 0x82ea27a0
	if ctx.cr[0].eq {
	pc = 0x82EA27A0; continue 'dispatch;
	}
	// 82EA2788: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EA278C: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA2790: 4B3C4D81  bl 0x82267510
	ctx.lr = 0x82EA2794;
	sub_82267510(ctx, base);
	// 82EA2794: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2798: 41820008  beq 0x82ea27a0
	if ctx.cr[0].eq {
	pc = 0x82EA27A0; continue 'dispatch;
	}
	// 82EA279C: 4801306D  bl 0x82eb5808
	ctx.lr = 0x82EA27A0;
	sub_82EB5808(ctx, base);
	pc = 0x82EA27A0; continue 'dispatch;
            }
            0x82EA27A0 => {
    //   block [0x82EA27A0..0x82EA27B4)
	// 82EA27A0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EA27A4: 2B1F0100  cmplwi cr6, r31, 0x100
	ctx.cr[6].compare_u32(ctx.r[31].u32, 256 as u32, &mut ctx.xer);
	// 82EA27A8: 4198FFA4  blt cr6, 0x82ea274c
	if ctx.cr[6].lt {
	pc = 0x82EA274C; continue 'dispatch;
	}
	// 82EA27AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA27B0: 4BE06CAC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA27B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA27B8 size=104
    let mut pc: u32 = 0x82EA27B8;
    'dispatch: loop {
        match pc {
            0x82EA27B8 => {
    //   block [0x82EA27B8..0x82EA27F0)
	// 82EA27B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA27BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA27C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA27C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA27C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA27CC: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EA27D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA27D4: 409A001C  bne cr6, 0x82ea27f0
	if !ctx.cr[6].eq {
	pc = 0x82EA27F0; continue 'dispatch;
	}
	// 82EA27D8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA27DC: 388B6D70  addi r4, r11, 0x6d70
	ctx.r[4].s64 = ctx.r[11].s64 + 28016;
	// 82EA27E0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA27E4: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA27E8: 4B3C5439  bl 0x82267c20
	ctx.lr = 0x82EA27EC;
	sub_82267C20(ctx, base);
	// 82EA27EC: 907F008C  stw r3, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	pc = 0x82EA27F0; continue 'dispatch;
            }
            0x82EA27F0 => {
    //   block [0x82EA27F0..0x82EA280C)
	// 82EA27F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EA27F4: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EA27F8: 4BFF9E49  bl 0x82e9c640
	ctx.lr = 0x82EA27FC;
	sub_82E9C640(ctx, base);
	// 82EA27FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA2800: 4082000C  bne 0x82ea280c
	if !ctx.cr[0].eq {
	pc = 0x82EA280C; continue 'dispatch;
	}
	// 82EA2804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA2808: 4BFFFF29  bl 0x82ea2730
	ctx.lr = 0x82EA280C;
	sub_82EA2730(ctx, base);
	pc = 0x82EA280C; continue 'dispatch;
            }
            0x82EA280C => {
    //   block [0x82EA280C..0x82EA2820)
	// 82EA280C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA2810: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA2814: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA2818: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA281C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA2820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA2820 size=140
    let mut pc: u32 = 0x82EA2820;
    'dispatch: loop {
        match pc {
            0x82EA2820 => {
    //   block [0x82EA2820..0x82EA28AC)
	// 82EA2820: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA2824: 81440028  lwz r10, 0x28(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA2828: 396B77F0  addi r11, r11, 0x77f0
	ctx.r[11].s64 = ctx.r[11].s64 + 30704;
	// 82EA282C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EA2830: 39440024  addi r10, r4, 0x24
	ctx.r[10].s64 = ctx.r[4].s64 + 36;
	// 82EA2834: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA2838: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA283C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EA2840: 39440040  addi r10, r4, 0x40
	ctx.r[10].s64 = ctx.r[4].s64 + 64;
	// 82EA2844: 914B0028  stw r10, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82EA2848: 81440030  lwz r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EA284C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EA2850: 39440044  addi r10, r4, 0x44
	ctx.r[10].s64 = ctx.r[4].s64 + 68;
	// 82EA2854: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82EA2858: 81440034  lwz r10, 0x34(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA285C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EA2860: 39440048  addi r10, r4, 0x48
	ctx.r[10].s64 = ctx.r[4].s64 + 72;
	// 82EA2864: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82EA2868: 81440038  lwz r10, 0x38(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA286C: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EA2870: 3944004C  addi r10, r4, 0x4c
	ctx.r[10].s64 = ctx.r[4].s64 + 76;
	// 82EA2874: 914B0024  stw r10, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82EA2878: 8144003C  lwz r10, 0x3c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA287C: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EA2880: 39440050  addi r10, r4, 0x50
	ctx.r[10].s64 = ctx.r[4].s64 + 80;
	// 82EA2884: 914B002C  stw r10, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82EA2888: 39440054  addi r10, r4, 0x54
	ctx.r[10].s64 = ctx.r[4].s64 + 84;
	// 82EA288C: 914B0030  stw r10, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 82EA2890: 39440058  addi r10, r4, 0x58
	ctx.r[10].s64 = ctx.r[4].s64 + 88;
	// 82EA2894: 914B0034  stw r10, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82EA2898: 3944005C  addi r10, r4, 0x5c
	ctx.r[10].s64 = ctx.r[4].s64 + 92;
	// 82EA289C: 914B0038  stw r10, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82EA28A0: 39440060  addi r10, r4, 0x60
	ctx.r[10].s64 = ctx.r[4].s64 + 96;
	// 82EA28A4: 914B003C  stw r10, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 82EA28A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA28B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA28B0 size=52
    let mut pc: u32 = 0x82EA28B0;
    'dispatch: loop {
        match pc {
            0x82EA28B0 => {
    //   block [0x82EA28B0..0x82EA28E4)
	// 82EA28B0: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA28B4: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA28B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA28BC: 40820028  bne 0x82ea28e4
	if !ctx.cr[0].eq {
		sub_82EA28E4(ctx, base);
		return;
	}
	// 82EA28C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA28C4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EA28C8: 396B9B10  addi r11, r11, -0x64f0
	ctx.r[11].s64 = ctx.r[11].s64 + -25840;
	// 82EA28CC: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EA28D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EA28D4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA28D8: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA28DC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EA28E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA28E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA28E4 size=192
    let mut pc: u32 = 0x82EA28E4;
    'dispatch: loop {
        match pc {
            0x82EA28E4 => {
    //   block [0x82EA28E4..0x82EA2944)
	// 82EA28E4: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA28E8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EA28EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA28F0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EA28F4: 91240014  stw r9, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82EA28F8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA28FC: 91240010  stw r9, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EA2900: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2904: 990B0010  stb r8, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u8 ) };
	// 82EA2908: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EA290C: 409A0054  bne cr6, 0x82ea2960
	if !ctx.cr[6].eq {
	pc = 0x82EA2960; continue 'dispatch;
	}
	// 82EA2910: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA2914: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2918: 4082002C  bne 0x82ea2944
	if !ctx.cr[0].eq {
	pc = 0x82EA2944; continue 'dispatch;
	}
	// 82EA291C: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EA2920: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EA2924: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EA2928: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA292C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EA2930: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA2934: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EA2938: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA293C: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EA2940: 48000044  b 0x82ea2984
	pc = 0x82EA2984; continue 'dispatch;
            }
            0x82EA2944 => {
    //   block [0x82EA2944..0x82EA2960)
	// 82EA2944: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EA2948: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EA294C: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EA2950: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA2954: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EA2958: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EA295C: 48000028  b 0x82ea2984
	pc = 0x82EA2984; continue 'dispatch;
            }
            0x82EA2960 => {
    //   block [0x82EA2960..0x82EA2980)
	// 82EA2960: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA2964: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EA2968: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EA296C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2970: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EA2974: 4182000C  beq 0x82ea2980
	if ctx.cr[0].eq {
	pc = 0x82EA2980; continue 'dispatch;
	}
	// 82EA2978: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EA297C: 48000008  b 0x82ea2984
	pc = 0x82EA2984; continue 'dispatch;
            }
            0x82EA2980 => {
    //   block [0x82EA2980..0x82EA2984)
	// 82EA2980: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA2984; continue 'dispatch;
            }
            0x82EA2984 => {
    //   block [0x82EA2984..0x82EA29A4)
	// 82EA2984: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EA2988: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EA298C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EA2990: 394A9B10  addi r10, r10, -0x64f0
	ctx.r[10].s64 = ctx.r[10].s64 + -25840;
	// 82EA2994: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EA2998: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA299C: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EA29A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA29A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EA29A8 size=944
    let mut pc: u32 = 0x82EA29A8;
    'dispatch: loop {
        match pc {
            0x82EA29A8 => {
    //   block [0x82EA29A8..0x82EA29E4)
	// 82EA29A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA29AC: 4BE06A51  bl 0x82ca93fc
	ctx.lr = 0x82EA29B0;
	sub_82CA93D0(ctx, base);
	// 82EA29B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA29B4: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EA29B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EA29BC: 3B2A7818  addi r25, r10, 0x7818
	ctx.r[25].s64 = ctx.r[10].s64 + 30744;
	// 82EA29C0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EA29C4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82EA29C8: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 82EA29CC: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82EA29D0: 8359FFF4  lwz r26, -0xc(r25)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EA29D4: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA29D8: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA29DC: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA29E0: 48000058  b 0x82ea2a38
	pc = 0x82EA2A38; continue 'dispatch;
            }
            0x82EA29E4 => {
    //   block [0x82EA29E4..0x82EA29FC)
	// 82EA29E4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA29E8: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA29EC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA29F0: 4082000C  bne 0x82ea29fc
	if !ctx.cr[0].eq {
	pc = 0x82EA29FC; continue 'dispatch;
	}
	// 82EA29F4: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82EA29F8: 48000010  b 0x82ea2a08
	pc = 0x82EA2A08; continue 'dispatch;
            }
            0x82EA29FC => {
    //   block [0x82EA29FC..0x82EA2A08)
	// 82EA29FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2A00: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA2A04: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	pc = 0x82EA2A08; continue 'dispatch;
            }
            0x82EA2A08 => {
    //   block [0x82EA2A08..0x82EA2A38)
	// 82EA2A08: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2A0C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EA2A10: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2A14: 7F1D4000  cmpw cr6, r29, r8
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82EA2A18: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82EA2A1C: 80CB0038  lwz r6, 0x38(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA2A20: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA2A24: 7D67302E  lwzx r11, r7, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82EA2A28: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA2A2C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA2A30: 40980030  bge cr6, 0x82ea2a60
	if !ctx.cr[6].lt {
	pc = 0x82EA2A60; continue 'dispatch;
	}
	// 82EA2A34: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82EA2A38; continue 'dispatch;
            }
            0x82EA2A38 => {
    //   block [0x82EA2A38..0x82EA2A60)
	// 82EA2A38: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA2A3C: 409AFFA8  bne cr6, 0x82ea29e4
	if !ctx.cr[6].eq {
	pc = 0x82EA29E4; continue 'dispatch;
	}
	// 82EA2A40: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA2A44: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 82EA2A48: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EA2A4C: 40990020  ble cr6, 0x82ea2a6c
	if !ctx.cr[6].gt {
	pc = 0x82EA2A6C; continue 'dispatch;
	}
	// 82EA2A50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EA2A54: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EA2A58: 997F0020  stb r11, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 82EA2A5C: 48000018  b 0x82ea2a74
	pc = 0x82EA2A74; continue 'dispatch;
            }
            0x82EA2A60 => {
    //   block [0x82EA2A60..0x82EA2A6C)
	// 82EA2A60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EA2A64: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82EA2A68: 480002E8  b 0x82ea2d50
	pc = 0x82EA2D50; continue 'dispatch;
            }
            0x82EA2A6C => {
    //   block [0x82EA2A6C..0x82EA2A74)
	// 82EA2A6C: 9B7F0020  stb r27, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[27].u8 ) };
	// 82EA2A70: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA2A74; continue 'dispatch;
            }
            0x82EA2A74 => {
    //   block [0x82EA2A74..0x82EA2AF0)
	// 82EA2A74: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA2A78: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 82EA2A7C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2A80: 41820070  beq 0x82ea2af0
	if ctx.cr[0].eq {
	pc = 0x82EA2AF0; continue 'dispatch;
	}
	// 82EA2A84: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EA2A88: 41990068  bgt cr6, 0x82ea2af0
	if ctx.cr[6].gt {
	pc = 0x82EA2AF0; continue 'dispatch;
	}
	// 82EA2A8C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA2A90: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA2A94: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2A98: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA2A9C: 912BFFFC  stw r9, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 82EA2AA0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA2AA4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2AA8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA2AAC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA2AB0: 938BFFFC  stw r28, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[28].u32 ) };
	// 82EA2AB4: C0050004  lfs f0, 4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA2AB8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA2ABC: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA2AC0: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA2AC4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA2AC8: D00BFFF4  stfs f0, -0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 82EA2ACC: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA2AD0: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EA2AD4: C005000C  lfs f0, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA2AD8: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EA2ADC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA2AE0: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA2AE4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA2AE8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA2AEC: 936BFFFC  stw r27, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[27].u32 ) };
	pc = 0x82EA2AF0; continue 'dispatch;
            }
            0x82EA2AF0 => {
    //   block [0x82EA2AF0..0x82EA2B00)
	// 82EA2AF0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA2AF4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EA2AF8: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EA2AFC: 40990098  ble cr6, 0x82ea2b94
	if !ctx.cr[6].gt {
	pc = 0x82EA2B94; continue 'dispatch;
	}
	pc = 0x82EA2B00; continue 'dispatch;
            }
            0x82EA2B00 => {
    //   block [0x82EA2B00..0x82EA2B28)
	// 82EA2B00: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2B04: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2B08: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA2B0C: 419A0088  beq cr6, 0x82ea2b94
	if ctx.cr[6].eq {
	pc = 0x82EA2B94; continue 'dispatch;
	}
	// 82EA2B10: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2B14: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA2B18: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2B1C: 4082000C  bne 0x82ea2b28
	if !ctx.cr[0].eq {
	pc = 0x82EA2B28; continue 'dispatch;
	}
	// 82EA2B20: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EA2B24: 4800000C  b 0x82ea2b30
	pc = 0x82EA2B30; continue 'dispatch;
            }
            0x82EA2B28 => {
    //   block [0x82EA2B28..0x82EA2B30)
	// 82EA2B28: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA2B2C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x82EA2B30; continue 'dispatch;
            }
            0x82EA2B30 => {
    //   block [0x82EA2B30..0x82EA2B58)
	// 82EA2B30: 4BFECAF1  bl 0x82e8f620
	ctx.lr = 0x82EA2B34;
	sub_82E8F620(ctx, base);
	// 82EA2B34: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA2B38: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EA2B3C: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EA2B40: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2B44: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA2B48: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2B4C: 4082000C  bne 0x82ea2b58
	if !ctx.cr[0].eq {
	pc = 0x82EA2B58; continue 'dispatch;
	}
	// 82EA2B50: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82EA2B54: 48000010  b 0x82ea2b64
	pc = 0x82EA2B64; continue 'dispatch;
            }
            0x82EA2B58 => {
    //   block [0x82EA2B58..0x82EA2B64)
	// 82EA2B58: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2B5C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA2B60: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x82EA2B64; continue 'dispatch;
            }
            0x82EA2B64 => {
    //   block [0x82EA2B64..0x82EA2B94)
	// 82EA2B64: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2B68: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 82EA2B6C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2B70: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA2B74: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EA2B78: 7F1D4800  cmpw cr6, r29, r9
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82EA2B7C: 80EB0038  lwz r7, 0x38(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA2B80: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA2B84: 7D68382E  lwzx r11, r8, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82EA2B88: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA2B8C: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA2B90: 4199FF70  bgt cr6, 0x82ea2b00
	if ctx.cr[6].gt {
	pc = 0x82EA2B00; continue 'dispatch;
	}
	pc = 0x82EA2B94; continue 'dispatch;
            }
            0x82EA2B94 => {
    //   block [0x82EA2B94..0x82EA2BAC)
	// 82EA2B94: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2B98: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2B9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EA2BA0: 419A01A0  beq cr6, 0x82ea2d40
	if ctx.cr[6].eq {
	pc = 0x82EA2D40; continue 'dispatch;
	}
	// 82EA2BA4: 1CFD000C  mulli r7, r29, 0xc
	ctx.r[7].s32 = ((ctx.r[29].s32 as i64 * 12 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82EA2BA8: 57A8103A  slwi r8, r29, 2
	ctx.r[8].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	pc = 0x82EA2BAC; continue 'dispatch;
            }
            0x82EA2BAC => {
    //   block [0x82EA2BAC..0x82EA2BC4)
	// 82EA2BAC: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2BB0: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA2BB4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2BB8: 4082000C  bne 0x82ea2bc4
	if !ctx.cr[0].eq {
	pc = 0x82EA2BC4; continue 'dispatch;
	}
	// 82EA2BBC: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82EA2BC0: 4800000C  b 0x82ea2bcc
	pc = 0x82EA2BCC; continue 'dispatch;
            }
            0x82EA2BC4 => {
    //   block [0x82EA2BC4..0x82EA2BCC)
	// 82EA2BC4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA2BC8: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	pc = 0x82EA2BCC; continue 'dispatch;
            }
            0x82EA2BCC => {
    //   block [0x82EA2BCC..0x82EA2C10)
	// 82EA2BCC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2BD0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2BD4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA2BD8: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EA2BDC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82EA2BE0: 80CB0038  lwz r6, 0x38(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA2BE4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA2BE8: 7D26482E  lwzx r9, r6, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EA2BEC: 1D290014  mulli r9, r9, 0x14
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 20 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82EA2BF0: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA2BF4: 916AFFFC  stw r11, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 82EA2BF8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2BFC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA2C00: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2C04: 4082000C  bne 0x82ea2c10
	if !ctx.cr[0].eq {
	pc = 0x82EA2C10; continue 'dispatch;
	}
	// 82EA2C08: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82EA2C0C: 48000010  b 0x82ea2c1c
	pc = 0x82EA2C1C; continue 'dispatch;
            }
            0x82EA2C10 => {
    //   block [0x82EA2C10..0x82EA2C1C)
	// 82EA2C10: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2C14: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA2C18: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x82EA2C1C; continue 'dispatch;
            }
            0x82EA2C1C => {
    //   block [0x82EA2C1C..0x82EA2C44)
	// 82EA2C1C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2C20: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2C24: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82EA2C28: 914BFFFC  stw r10, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 82EA2C2C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2C30: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA2C34: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2C38: 4082000C  bne 0x82ea2c44
	if !ctx.cr[0].eq {
	pc = 0x82EA2C44; continue 'dispatch;
	}
	// 82EA2C3C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EA2C40: 48000010  b 0x82ea2c50
	pc = 0x82EA2C50; continue 'dispatch;
            }
            0x82EA2C44 => {
    //   block [0x82EA2C44..0x82EA2C50)
	// 82EA2C44: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2C48: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA2C4C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x82EA2C50; continue 'dispatch;
            }
            0x82EA2C50 => {
    //   block [0x82EA2C50..0x82EA2C68)
	// 82EA2C50: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2C54: 814A0050  lwz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA2C58: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2C5C: 4082000C  bne 0x82ea2c68
	if !ctx.cr[0].eq {
	pc = 0x82EA2C68; continue 'dispatch;
	}
	// 82EA2C60: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82EA2C64: 48000010  b 0x82ea2c74
	pc = 0x82EA2C74; continue 'dispatch;
            }
            0x82EA2C68 => {
    //   block [0x82EA2C68..0x82EA2C74)
	// 82EA2C68: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2C6C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA2C70: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	pc = 0x82EA2C74; continue 'dispatch;
            }
            0x82EA2C74 => {
    //   block [0x82EA2C74..0x82EA2C98)
	// 82EA2C74: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA2C78: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82EA2C7C: 914BFFFC  stw r10, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 82EA2C80: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2C84: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA2C88: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2C8C: 4082000C  bne 0x82ea2c98
	if !ctx.cr[0].eq {
	pc = 0x82EA2C98; continue 'dispatch;
	}
	// 82EA2C90: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EA2C94: 48000010  b 0x82ea2ca4
	pc = 0x82EA2CA4; continue 'dispatch;
            }
            0x82EA2C98 => {
    //   block [0x82EA2C98..0x82EA2CA4)
	// 82EA2C98: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2C9C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA2CA0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x82EA2CA4; continue 'dispatch;
            }
            0x82EA2CA4 => {
    //   block [0x82EA2CA4..0x82EA2CFC)
	// 82EA2CA4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2CA8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2CAC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA2CB0: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EA2CB4: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82EA2CB8: 80AA0038  lwz r5, 0x38(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA2CBC: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA2CC0: 7D46282E  lwzx r10, r6, r5
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82EA2CC4: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA2CC8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EA2CCC: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA2CD0: D00BFFF4  stfs f0, -0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 82EA2CD4: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA2CD8: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EA2CDC: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA2CE0: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EA2CE4: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2CE8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA2CEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2CF0: 4082000C  bne 0x82ea2cfc
	if !ctx.cr[0].eq {
	pc = 0x82EA2CFC; continue 'dispatch;
	}
	// 82EA2CF4: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82EA2CF8: 48000010  b 0x82ea2d08
	pc = 0x82EA2D08; continue 'dispatch;
            }
            0x82EA2CFC => {
    //   block [0x82EA2CFC..0x82EA2D08)
	// 82EA2CFC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2D00: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA2D04: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x82EA2D08; continue 'dispatch;
            }
            0x82EA2D08 => {
    //   block [0x82EA2D08..0x82EA2D40)
	// 82EA2D08: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2D0C: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 82EA2D10: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2D14: 38E7FFF4  addi r7, r7, -0xc
	ctx.r[7].s64 = ctx.r[7].s64 + -12;
	// 82EA2D18: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2D1C: 5546103A  slwi r6, r10, 2
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EA2D20: 80AB0038  lwz r5, 0x38(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA2D24: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA2D28: 7D66282E  lwzx r11, r6, r5
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82EA2D2C: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA2D30: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA2D34: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2D38: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA2D3C: 409AFE70  bne cr6, 0x82ea2bac
	if !ctx.cr[6].eq {
	pc = 0x82EA2BAC; continue 'dispatch;
	}
	pc = 0x82EA2D40; continue 'dispatch;
            }
            0x82EA2D40 => {
    //   block [0x82EA2D40..0x82EA2D50)
	// 82EA2D40: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2D44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA2D48: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82EA2D4C: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82EA2D50; continue 'dispatch;
            }
            0x82EA2D50 => {
    //   block [0x82EA2D50..0x82EA2D58)
	// 82EA2D50: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EA2D54: 4BE066F8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA2D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EA2D58 size=148
    let mut pc: u32 = 0x82EA2D58;
    'dispatch: loop {
        match pc {
            0x82EA2D58 => {
    //   block [0x82EA2D58..0x82EA2D90)
	// 82EA2D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA2D5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA2D60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA2D64: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA2D68: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA2D6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA2D70: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82EA2D74: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2D78: 4182003C  beq 0x82ea2db4
	if ctx.cr[0].eq {
	pc = 0x82EA2DB4; continue 'dispatch;
	}
	// 82EA2D7C: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2D80: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EA2D84: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EA2D88: 814A7808  lwz r10, 0x7808(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(30728 as u32) ) } as u64;
	// 82EA2D8C: 7C09542E  lfsx f0, r9, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EA2D90; continue 'dispatch;
            }
            0x82EA2D90 => {
    //   block [0x82EA2D90..0x82EA2DB4)
	// 82EA2D90: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2D94: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2D98: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EA2D9C: 7DA9542E  lfsx f13, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA2DA0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EA2DA4: 41990010  bgt cr6, 0x82ea2db4
	if ctx.cr[6].gt {
	pc = 0x82EA2DB4; continue 'dispatch;
	}
	// 82EA2DA8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA2DAC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2DB0: 4082FFE0  bne 0x82ea2d90
	if !ctx.cr[0].eq {
	pc = 0x82EA2D90; continue 'dispatch;
	}
	pc = 0x82EA2DB4; continue 'dispatch;
            }
            0x82EA2DB4 => {
    //   block [0x82EA2DB4..0x82EA2DEC)
	// 82EA2DB4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EA2DB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EA2DBC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EA2DC0: 394A9B10  addi r10, r10, -0x64f0
	ctx.r[10].s64 = ctx.r[10].s64 + -25840;
	// 82EA2DC4: 38A10094  addi r5, r1, 0x94
	ctx.r[5].s64 = ctx.r[1].s64 + 148;
	// 82EA2DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA2DCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EA2DD0: 4BFFFAE1  bl 0x82ea28b0
	ctx.lr = 0x82EA2DD4;
	sub_82EA28B0(ctx, base);
	// 82EA2DD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA2DD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA2DDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA2DE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA2DE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA2DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA2DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EA2DF0 size=1192
    let mut pc: u32 = 0x82EA2DF0;
    'dispatch: loop {
        match pc {
            0x82EA2DF0 => {
    //   block [0x82EA2DF0..0x82EA2E6C)
	// 82EA2DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA2DF4: 4BE06615  bl 0x82ca9408
	ctx.lr = 0x82EA2DF8;
	sub_82CA93D0(ctx, base);
	// 82EA2DF8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82EA2DFC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA2E00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA2E04: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EA2E08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EA2E0C: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EA2E10: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA2E14: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2E18: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EA2E1C: 3BCB77F4  addi r30, r11, 0x77f4
	ctx.r[30].s64 = ctx.r[11].s64 + 30708;
	// 82EA2E20: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA2E24: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EA2E28: 917E003C  stw r11, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82EA2E2C: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EA2E30: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EA2E34: 917E0040  stw r11, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EA2E38: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA2E3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2E40: 418200E4  beq 0x82ea2f24
	if ctx.cr[0].eq {
	pc = 0x82EA2F24; continue 'dispatch;
	}
	// 82EA2E44: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2E48: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EA2E4C: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA2E50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2E54: 418200D0  beq 0x82ea2f24
	if ctx.cr[0].eq {
	pc = 0x82EA2F24; continue 'dispatch;
	}
	// 82EA2E58: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA2E5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EA2E60: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2E64: 41820008  beq 0x82ea2e6c
	if ctx.cr[0].eq {
	pc = 0x82EA2E6C; continue 'dispatch;
	}
	// 82EA2E68: 7C6B482E  lwzx r3, r11, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	pc = 0x82EA2E6C; continue 'dispatch;
            }
            0x82EA2E6C => {
    //   block [0x82EA2E6C..0x82EA2E90)
	// 82EA2E6C: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2E70: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EA2E74: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2E78: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EA2E7C: 809D0014  lwz r4, 0x14(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA2E80: 80CB0054  lwz r6, 0x54(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA2E84: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA2E88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA2E8C: 4E800421  bctrl
	ctx.lr = 0x82EA2E90;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA2E90 => {
    //   block [0x82EA2E90..0x82EA2EB8)
	// 82EA2E90: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA2E94: 418203F4  beq 0x82ea3288
	if ctx.cr[0].eq {
	pc = 0x82EA3288; continue 'dispatch;
	}
	// 82EA2E98: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2E9C: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA2EA0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2EA4: 41820014  beq 0x82ea2eb8
	if ctx.cr[0].eq {
	pc = 0x82EA2EB8; continue 'dispatch;
	}
	// 82EA2EA8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2EAC: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA2EB0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA2EB4: 7C0A5D2E  stfsx f0, r10, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	pc = 0x82EA2EB8; continue 'dispatch;
            }
            0x82EA2EB8 => {
    //   block [0x82EA2EB8..0x82EA2F24)
	// 82EA2EB8: 813D0010  lwz r9, 0x10(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2EBC: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 82EA2EC0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2EC4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2EC8: 80DD0008  lwz r6, 8(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA2ECC: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EA2ED0: 809D0014  lwz r4, 0x14(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA2ED4: 80690058  lwz r3, 0x58(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA2ED8: 812B003C  lwz r9, 0x3c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA2EDC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA2EE0: 7D68482E  lwzx r11, r8, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EA2EE4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2EE8: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA2EEC: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2EF0: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA2EF4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82EA2EF8: 4E800421  bctrl
	ctx.lr = 0x82EA2EFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA2EFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA2F00: 41820388  beq 0x82ea3288
	if ctx.cr[0].eq {
	pc = 0x82EA3288; continue 'dispatch;
	}
	// 82EA2F04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2F08: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2F0C: 812B004C  lwz r9, 0x4c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA2F10: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2F14: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA2F18: 40820034  bne 0x82ea2f4c
	if !ctx.cr[0].eq {
	pc = 0x82EA2F4C; continue 'dispatch;
	}
	// 82EA2F1C: FC00F890  fmr f0, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EA2F20: 48000038  b 0x82ea2f58
	pc = 0x82EA2F58; continue 'dispatch;
            }
            0x82EA2F24 => {
    //   block [0x82EA2F24..0x82EA2F4C)
	// 82EA2F24: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2F28: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EA2F2C: 809D0014  lwz r4, 0x14(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA2F30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EA2F34: 806B0054  lwz r3, 0x54(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA2F38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2F3C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2F40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA2F44: 4E800421  bctrl
	ctx.lr = 0x82EA2F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA2F48: 4BFFFF48  b 0x82ea2e90
	pc = 0x82EA2E90; continue 'dispatch;
            }
            0x82EA2F4C => {
    //   block [0x82EA2F4C..0x82EA2F58)
	// 82EA2F4C: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2F50: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EA2F54: 7C084C2E  lfsx f0, r8, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EA2F58; continue 'dispatch;
            }
            0x82EA2F58 => {
    //   block [0x82EA2F58..0x82EA3094)
	// 82EA2F58: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2F5C: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EA2F60: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA2F64: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA2F68: 7DA84C2E  lfsx f13, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA2F6C: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA2F70: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA2F74: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EA2F78: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA2F7C: 7D08502E  lwzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA2F80: 1D080014  mulli r8, r8, 0x14
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * 20 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82EA2F84: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EA2F88: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA2F8C: 557C1838  slwi r28, r11, 3
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82EA2F90: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA2F94: 7D1C5A14  add r8, r28, r11
	ctx.r[8].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82EA2F98: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA2F9C: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82EA2FA0: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2FA4: 7CE70034  cntlzw r7, r7
	ctx.r[7].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 82EA2FA8: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2FAC: 54E7DFFE  rlwinm r7, r7, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 82EA2FB0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EA2FB4: 68E70001  xori r7, r7, 1
	ctx.r[7].u64 = ctx.r[7].u64 ^ 1;
	// 82EA2FB8: 419A00E4  beq cr6, 0x82ea309c
	if ctx.cr[6].eq {
	pc = 0x82EA309C; continue 'dispatch;
	}
	// 82EA2FBC: 54CB003E  slwi r11, r6, 0
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA2FC0: 80FE0014  lwz r7, 0x14(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA2FC4: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2FC8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EA2FCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA2FD0: 396B9B10  addi r11, r11, -0x64f0
	ctx.r[11].s64 = ctx.r[11].s64 + -25840;
	// 82EA2FD4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EA2FD8: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA2FDC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA2FE0: 7D8B3C2E  lfsx f12, r11, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA2FE4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EA2FE8: 409802A0  bge cr6, 0x82ea3288
	if !ctx.cr[6].lt {
	pc = 0x82EA3288; continue 'dispatch;
	}
	// 82EA2FEC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2FF0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EA2FF4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA2FF8: 80CB003C  lwz r6, 0x3c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA2FFC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA3000: 7D46502E  lwzx r10, r6, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA3004: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA3008: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA300C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA3010: 7DAB4D2E  stfsx f13, r11, r9
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82EA3014: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3018: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA301C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA3020: 812B003C  lwz r9, 0x3c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA3024: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA3028: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EA302C: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA3030: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA3034: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA3038: 7C0B3D2E  stfsx f0, r11, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 82EA303C: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3040: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA3044: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA3048: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA304C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EA3050: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EA3054: 4BFE1E2D  bl 0x82e84e80
	ctx.lr = 0x82EA3058;
	sub_82E84E80(ctx, base);
	// 82EA3058: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA305C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3060: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EA3064: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA3068: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA306C: 7D69402E  lwzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82EA3070: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA3074: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA3078: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA307C: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA3080: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA3084: 41820010  beq 0x82ea3094
	if ctx.cr[0].eq {
	pc = 0x82EA3094; continue 'dispatch;
	}
	// 82EA3088: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA308C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA3090: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	pc = 0x82EA3094; continue 'dispatch;
            }
            0x82EA3094 => {
    //   block [0x82EA3094..0x82EA309C)
	// 82EA3094: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EA3098: 480001B8  b 0x82ea3250
	pc = 0x82EA3250; continue 'dispatch;
            }
            0x82EA309C => {
    //   block [0x82EA309C..0x82EA30C8)
	// 82EA309C: 54EB063F  clrlwi. r11, r7, 0x18
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA30A0: 41820124  beq 0x82ea31c4
	if ctx.cr[0].eq {
	pc = 0x82EA31C4; continue 'dispatch;
	}
	// 82EA30A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA30A8: 38EB9B10  addi r7, r11, -0x64f0
	ctx.r[7].s64 = ctx.r[11].s64 + -25840;
	// 82EA30AC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA30B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA30B4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EA30B8: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 82EA30BC: 4082000C  bne 0x82ea30c8
	if !ctx.cr[0].eq {
	pc = 0x82EA30C8; continue 'dispatch;
	}
	// 82EA30C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EA30C4: 480001C8  b 0x82ea328c
	pc = 0x82EA328C; continue 'dispatch;
            }
            0x82EA30C8 => {
    //   block [0x82EA30C8..0x82EA31C4)
	// 82EA30C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA30CC: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA30D0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA30D4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA30D8: 7D8B442E  lfsx f12, r11, r8
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA30DC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EA30E0: 409801A8  bge cr6, 0x82ea3288
	if !ctx.cr[6].lt {
	pc = 0x82EA3288; continue 'dispatch;
	}
	// 82EA30E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA30E8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EA30EC: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA30F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA30F4: 80EB003C  lwz r7, 0x3c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA30F8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA30FC: 7D47502E  lwzx r10, r7, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA3100: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA3104: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA3108: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA310C: 7DAB4D2E  stfsx f13, r11, r9
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82EA3110: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3114: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3118: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA311C: 812B003C  lwz r9, 0x3c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA3120: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA3124: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EA3128: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA312C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA3130: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA3134: 7C0B452E  stfsx f0, r11, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 82EA3138: 4BFE1D49  bl 0x82e84e80
	ctx.lr = 0x82EA313C;
	sub_82E84E80(ctx, base);
	// 82EA313C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3140: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EA3144: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3148: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EA314C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EA3150: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA3154: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA3158: 7D69402E  lwzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82EA315C: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA3160: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA3164: 4BFFFBF5  bl 0x82ea2d58
	ctx.lr = 0x82EA3168;
	sub_82EA2D58(ctx, base);
	// 82EA3168: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA316C: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3170: 7D5C5A14  add r10, r28, r11
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82EA3174: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EA3178: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EA317C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EA3180: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3184: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EA3188: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EA318C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3190: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA3194: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA3198: 7D69402E  lwzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82EA319C: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA31A0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA31A4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA31A8: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA31AC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA31B0: 418200D8  beq 0x82ea3288
	if ctx.cr[0].eq {
	pc = 0x82EA3288; continue 'dispatch;
	}
	// 82EA31B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA31B8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA31BC: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	// 82EA31C0: 480000C8  b 0x82ea3288
	pc = 0x82EA3288; continue 'dispatch;
            }
            0x82EA31C4 => {
    //   block [0x82EA31C4..0x82EA324C)
	// 82EA31C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA31C8: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA31CC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA31D0: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA31D4: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA31D8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA31DC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA31E0: 7DAB4D2E  stfsx f13, r11, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82EA31E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA31E8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA31EC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA31F0: 812B003C  lwz r9, 0x3c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA31F4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA31F8: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EA31FC: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA3200: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA3204: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA3208: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA320C: 7C0A5D2E  stfsx f0, r10, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82EA3210: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3214: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3218: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EA321C: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA3220: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA3224: 7D69402E  lwzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82EA3228: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA322C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA3230: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA3234: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA3238: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA323C: 41820010  beq 0x82ea324c
	if ctx.cr[0].eq {
	pc = 0x82EA324C; continue 'dispatch;
	}
	// 82EA3240: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3244: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA3248: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	pc = 0x82EA324C; continue 'dispatch;
            }
            0x82EA324C => {
    //   block [0x82EA324C..0x82EA3250)
	// 82EA324C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	pc = 0x82EA3250; continue 'dispatch;
            }
            0x82EA3250 => {
    //   block [0x82EA3250..0x82EA3288)
	// 82EA3250: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3254: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3258: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA325C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EA3260: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA3264: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA3268: 7D69402E  lwzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82EA326C: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA3270: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA3274: 4BFFFAE5  bl 0x82ea2d58
	ctx.lr = 0x82EA3278;
	sub_82EA2D58(ctx, base);
	// 82EA3278: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA327C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3280: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82EA3284: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA3288; continue 'dispatch;
            }
            0x82EA3288 => {
    //   block [0x82EA3288..0x82EA328C)
	// 82EA3288: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EA328C; continue 'dispatch;
            }
            0x82EA328C => {
    //   block [0x82EA328C..0x82EA3298)
	// 82EA328C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EA3290: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EA3294: 4BE061C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA3298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EA3298 size=1956
    let mut pc: u32 = 0x82EA3298;
    'dispatch: loop {
        match pc {
            0x82EA3298 => {
    //   block [0x82EA3298..0x82EA334C)
	// 82EA3298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA329C: 4BE06139  bl 0x82ca93d4
	ctx.lr = 0x82EA32A0;
	sub_82CA93D0(ctx, base);
	// 82EA32A0: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 82EA32A4: 4BE0AA2D  bl 0x82cadcd0
	ctx.lr = 0x82EA32A8;
	sub_82CADCA0(ctx, base);
	// 82EA32A8: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA32AC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA32B0: FF400890  fmr f26, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = ctx.f[1].f64;
	// 82EA32B4: 7C8F2378  mr r15, r4
	ctx.r[15].u64 = ctx.r[4].u64;
	// 82EA32B8: FF801090  fmr f28, f2
	ctx.f[28].f64 = ctx.f[2].f64;
	// 82EA32BC: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 82EA32C0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA32C4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EA32C8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EA32CC: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 82EA32D0: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 82EA32D4: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA32D8: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 82EA32DC: 7D344B78  mr r20, r9
	ctx.r[20].u64 = ctx.r[9].u64;
	// 82EA32E0: 7D535378  mr r19, r10
	ctx.r[19].u64 = ctx.r[10].u64;
	// 82EA32E4: 4B3C493D  bl 0x82267c20
	ctx.lr = 0x82EA32E8;
	sub_82267C20(ctx, base);
	// 82EA32E8: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82EA32EC: 41820530  beq 0x82ea381c
	if ctx.cr[0].eq {
	pc = 0x82EA381C; continue 'dispatch;
	}
	// 82EA32F0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EA32F4: 4BFFF52D  bl 0x82ea2820
	ctx.lr = 0x82EA32F8;
	sub_82EA2820(ctx, base);
	// 82EA32F8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA32FC: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA3300: 4182051C  beq 0x82ea381c
	if ctx.cr[0].eq {
	pc = 0x82EA381C; continue 'dispatch;
	}
	// 82EA3304: 81790058  lwz r11, 0x58(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA3308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA330C: 419A0510  beq cr6, 0x82ea381c
	if ctx.cr[6].eq {
	pc = 0x82EA381C; continue 'dispatch;
	}
	// 82EA3310: 81790054  lwz r11, 0x54(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA3314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA3318: 419A0504  beq cr6, 0x82ea381c
	if ctx.cr[6].eq {
	pc = 0x82EA381C; continue 'dispatch;
	}
	// 82EA331C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA3320: 3A0BDAC0  addi r16, r11, -0x2540
	ctx.r[16].s64 = ctx.r[11].s64 + -9536;
	// 82EA3324: 81700008  lwz r11, 8(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA332C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA3330: C3AB0C18  lfs f29, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EA3334: 419A0018  beq cr6, 0x82ea334c
	if ctx.cr[6].eq {
	pc = 0x82EA334C; continue 'dispatch;
	}
	// 82EA3338: 81700008  lwz r11, 8(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA333C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA3340: 4E800421  bctrl
	ctx.lr = 0x82EA3344;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA3344: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 82EA3348: 48000008  b 0x82ea3350
	pc = 0x82EA3350; continue 'dispatch;
            }
            0x82EA334C => {
    //   block [0x82EA334C..0x82EA3350)
	// 82EA334C: FF60E890  fmr f27, f29
	ctx.f[27].f64 = ctx.f[29].f64;
	pc = 0x82EA3350; continue 'dispatch;
            }
            0x82EA3350 => {
    //   block [0x82EA3350..0x82EA3374)
	// 82EA3350: C0130000  lfs f0, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA3354: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA3358: C1B40000  lfs f13, 0(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA335C: EC006EBA  fmadds f0, f0, f26, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EA3360: C3CB0C14  lfs f30, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EA3364: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 82EA3368: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EA336C: 419A0008  beq cr6, 0x82ea3374
	if ctx.cr[6].eq {
	pc = 0x82EA3374; continue 'dispatch;
	}
	// 82EA3370: EFFC0024  fdivs f31, f28, f0
	ctx.f[31].f64 = ((ctx.f[28].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x82EA3374; continue 'dispatch;
            }
            0x82EA3374 => {
    //   block [0x82EA3374..0x82EA33BC)
	// 82EA3374: 896101E7  lbz r11, 0x1e7(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(487 as u32) ) } as u64;
	// 82EA3378: 3A400001  li r18, 1
	ctx.r[18].s64 = 1;
	// 82EA337C: 3A20FFFF  li r17, -1
	ctx.r[17].s64 = -1;
	// 82EA3380: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA3384: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA3388: 3BEB7800  addi r31, r11, 0x7800
	ctx.r[31].s64 = ctx.r[11].s64 + 30720;
	// 82EA338C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA3390: 40820084  bne 0x82ea3414
	if !ctx.cr[0].eq {
	pc = 0x82EA3414; continue 'dispatch;
	}
	// 82EA3394: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3398: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA339C: 4082007C  bne 0x82ea3418
	if !ctx.cr[0].eq {
	pc = 0x82EA3418; continue 'dispatch;
	}
	// 82EA33A0: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA33A4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA33A8: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82EA33AC: 419A0010  beq cr6, 0x82ea33bc
	if ctx.cr[6].eq {
	pc = 0x82EA33BC; continue 'dispatch;
	}
	// 82EA33B0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA33B4: 922A0000  stw r17, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 82EA33B8: 4800005C  b 0x82ea3414
	pc = 0x82EA3414; continue 'dispatch;
            }
            0x82EA33BC => {
    //   block [0x82EA33BC..0x82EA3414)
	// 82EA33BC: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA33C0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA33C4: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82EA33C8: 409A004C  bne cr6, 0x82ea3414
	if !ctx.cr[6].eq {
	pc = 0x82EA3414; continue 'dispatch;
	}
	// 82EA33CC: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA33D0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA33D4: 7F0AB040  cmplw cr6, r10, r22
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82EA33D8: 409A003C  bne cr6, 0x82ea3414
	if !ctx.cr[6].eq {
	pc = 0x82EA3414; continue 'dispatch;
	}
	// 82EA33DC: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA33E0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA33E4: 7F0AA840  cmplw cr6, r10, r21
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82EA33E8: 409A002C  bne cr6, 0x82ea3414
	if !ctx.cr[6].eq {
	pc = 0x82EA3414; continue 'dispatch;
	}
	// 82EA33EC: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA33F0: 81390058  lwz r9, 0x58(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA33F4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA33F8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA33FC: 409A0018  bne cr6, 0x82ea3414
	if !ctx.cr[6].eq {
	pc = 0x82EA3414; continue 'dispatch;
	}
	// 82EA3400: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA3404: 81390054  lwz r9, 0x54(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA3408: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA340C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA3410: 419A0008  beq cr6, 0x82ea3418
	if ctx.cr[6].eq {
	pc = 0x82EA3418; continue 'dispatch;
	}
	pc = 0x82EA3414; continue 'dispatch;
            }
            0x82EA3414 => {
    //   block [0x82EA3414..0x82EA3418)
	// 82EA3414: 9A4B0000  stb r18, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[18].u8 ) };
	pc = 0x82EA3418; continue 'dispatch;
            }
            0x82EA3418 => {
    //   block [0x82EA3418..0x82EA3438)
	// 82EA3418: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA341C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EA3420: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82EA3424: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EA3428: 3B0A9128  addi r24, r10, -0x6ed8
	ctx.r[24].s64 = ctx.r[10].s64 + -28376;
	// 82EA342C: 409A0170  bne cr6, 0x82ea359c
	if !ctx.cr[6].eq {
	pc = 0x82EA359C; continue 'dispatch;
	}
	// 82EA3430: 815FFFF8  lwz r10, -8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA3434: 48000028  b 0x82ea345c
	pc = 0x82EA345C; continue 'dispatch;
            }
            0x82EA3438 => {
    //   block [0x82EA3438..0x82EA345C)
	// 82EA3438: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA343C: 9B8B0010  stb r28, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[28].u8 ) };
	// 82EA3440: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3444: 810A0010  lwz r8, 0x10(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA3448: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA344C: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EA3450: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3454: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EA3458: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA345C; continue 'dispatch;
            }
            0x82EA345C => {
    //   block [0x82EA345C..0x82EA3478)
	// 82EA345C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3460: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA3464: 409AFFD4  bne cr6, 0x82ea3438
	if !ctx.cr[6].eq {
	pc = 0x82EA3438; continue 'dispatch;
	}
	// 82EA3468: 817FFFF4  lwz r11, -0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EA346C: 938A000C  stw r28, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82EA3470: 938A0014  stw r28, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 82EA3474: 48000028  b 0x82ea349c
	pc = 0x82EA349C; continue 'dispatch;
            }
            0x82EA3478 => {
    //   block [0x82EA3478..0x82EA349C)
	// 82EA3478: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA347C: 9B8A0010  stb r28, 0x10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[28].u8 ) };
	// 82EA3480: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3484: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA3488: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA348C: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EA3490: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3494: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EA3498: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA349C; continue 'dispatch;
            }
            0x82EA349C => {
    //   block [0x82EA349C..0x82EA34C4)
	// 82EA349C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA34A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA34A4: 409AFFD4  bne cr6, 0x82ea3478
	if !ctx.cr[6].eq {
	pc = 0x82EA3478; continue 'dispatch;
	}
	// 82EA34A8: 938B000C  stw r28, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82EA34AC: 938B0014  stw r28, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 82EA34B0: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA34B4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA34B8: 40810024  ble 0x82ea34dc
	if !ctx.cr[0].gt {
	pc = 0x82EA34DC; continue 'dispatch;
	}
	// 82EA34BC: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82EA34C0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82EA34C4; continue 'dispatch;
            }
            0x82EA34C4 => {
    //   block [0x82EA34C4..0x82EA34DC)
	// 82EA34C4: 811FFFFC  lwz r8, -4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EA34C8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA34CC: 7D094214  add r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EA34D0: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82EA34D4: 93880004  stw r28, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EA34D8: 4082FFEC  bne 0x82ea34c4
	if !ctx.cr[0].eq {
	pc = 0x82EA34C4; continue 'dispatch;
	}
	pc = 0x82EA34DC; continue 'dispatch;
            }
            0x82EA34DC => {
    //   block [0x82EA34DC..0x82EA34E8)
	// 82EA34DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA34E0: 40990020  ble cr6, 0x82ea3500
	if !ctx.cr[6].gt {
	pc = 0x82EA3500; continue 'dispatch;
	}
	// 82EA34E4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x82EA34E8; continue 'dispatch;
            }
            0x82EA34E8 => {
    //   block [0x82EA34E8..0x82EA3500)
	// 82EA34E8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA34EC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA34F0: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EA34F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82EA34F8: 93890004  stw r28, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EA34FC: 4082FFEC  bne 0x82ea34e8
	if !ctx.cr[0].eq {
	pc = 0x82EA34E8; continue 'dispatch;
	}
	pc = 0x82EA3500; continue 'dispatch;
            }
            0x82EA3500 => {
    //   block [0x82EA3500..0x82EA359C)
	// 82EA3500: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3504: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EA3508: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 82EA350C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA3510: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3514: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EA3518: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA351C: 7FAA5D2E  stfsx f29, r10, r11
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82EA3520: 80790058  lwz r3, 0x58(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA3524: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3528: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA352C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA3530: 4E800421  bctrl
	ctx.lr = 0x82EA3534;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA3534: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA3538: 418202E4  beq 0x82ea381c
	if ctx.cr[0].eq {
	pc = 0x82EA381C; continue 'dispatch;
	}
	// 82EA353C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3540: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA3544: 83DFFFF4  lwz r30, -0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EA3548: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EA354C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA3550: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3554: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA3558: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EA355C: 7C0A5D2E  stfsx f0, r10, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82EA3560: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3564: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA3568: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA356C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA3570: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82EA3574: 83BB0000  lwz r29, 0(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3578: 4BFFF7E1  bl 0x82ea2d58
	ctx.lr = 0x82EA357C;
	sub_82EA2D58(ctx, base);
	// 82EA357C: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EA3580: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA3584: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA3588: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA358C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EA3590: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA3594: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 82EA3598: 48000008  b 0x82ea35a0
	pc = 0x82EA35A0; continue 'dispatch;
            }
            0x82EA359C => {
    //   block [0x82EA359C..0x82EA35A0)
	// 82EA359C: 83DFFFF4  lwz r30, -0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	pc = 0x82EA35A0; continue 'dispatch;
            }
            0x82EA35A0 => {
    //   block [0x82EA35A0..0x82EA35BC)
	// 82EA35A0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA35A4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EA35A8: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA35AC: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82EA35B0: 4182020C  beq 0x82ea37bc
	if ctx.cr[0].eq {
	pc = 0x82EA37BC; continue 'dispatch;
	}
	// 82EA35B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA35B8: 3B4BA1D8  addi r26, r11, -0x5e28
	ctx.r[26].s64 = ctx.r[11].s64 + -24104;
	pc = 0x82EA35BC; continue 'dispatch;
            }
            0x82EA35BC => {
    //   block [0x82EA35BC..0x82EA36BC)
	// 82EA35BC: 83AA0004  lwz r29, 4(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA35C0: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA35C4: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA35C8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA35CC: 419A0264  beq cr6, 0x82ea3830
	if ctx.cr[6].eq {
	pc = 0x82EA3830; continue 'dispatch;
	}
	// 82EA35D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EA35D4: 934100A0  stw r26, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[26].u32 ) };
	// 82EA35D8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82EA35DC: 93A100A4  stw r29, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[29].u32 ) };
	// 82EA35E0: 92C100A8  stw r22, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[22].u32 ) };
	// 82EA35E4: 936100AC  stw r27, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[27].u32 ) };
	// 82EA35E8: 932100B0  stw r25, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[25].u32 ) };
	// 82EA35EC: 92A100B4  stw r21, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[21].u32 ) };
	// 82EA35F0: 4B7717B9  bl 0x82614da8
	ctx.lr = 0x82EA35F4;
	sub_82614DA8(ctx, base);
	// 82EA35F4: 930100A0  stw r24, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[24].u32 ) };
	// 82EA35F8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA35FC: 807FFFF4  lwz r3, -0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EA3600: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA3604: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EA3608: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA360C: 4BFE1875  bl 0x82e84e80
	ctx.lr = 0x82EA3610;
	sub_82E84E80(ctx, base);
	// 82EA3610: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3614: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EA3618: 809FFFF8  lwz r4, -8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA361C: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA3620: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EA3624: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EA3628: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA362C: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EA3630: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3634: 4BFFF725  bl 0x82ea2d58
	ctx.lr = 0x82EA3638;
	sub_82EA2D58(ctx, base);
	// 82EA3638: 83DF0034  lwz r30, 0x34(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA363C: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA3640: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3644: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EA3648: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA364C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3650: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 82EA3654: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EA3658: 93010068  stw r24, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u32 ) };
	// 82EA365C: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EA3660: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82EA3664: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82EA3668: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EA366C: 4198013C  blt cr6, 0x82ea37a8
	if ctx.cr[6].lt {
	pc = 0x82EA37A8; continue 'dispatch;
	}
	// 82EA3670: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA3674: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3678: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA367C: 41980040  blt cr6, 0x82ea36bc
	if ctx.cr[6].lt {
	pc = 0x82EA36BC; continue 'dispatch;
	}
	// 82EA3680: 4B3BD339  bl 0x822609b8
	ctx.lr = 0x82EA3684;
	sub_822609B8(ctx, base);
	// 82EA3684: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA3688: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EA368C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3690: 4BFDDCA1  bl 0x82e81330
	ctx.lr = 0x82EA3694;
	sub_82E81330(ctx, base);
	// 82EA3694: 83DF0034  lwz r30, 0x34(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA3698: C1BD0074  lfs f13, 0x74(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA369C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82EA36A0: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82EA36A4: C8010070  lfd f0, 0x70(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82EA36A8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82EA36AC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82EA36B0: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA36B4: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EA36B8: D01D0074  stfs f0, 0x74(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(116 as u32), tmp.u32 ) };
	pc = 0x82EA36BC; continue 'dispatch;
            }
            0x82EA36BC => {
    //   block [0x82EA36BC..0x82EA36DC)
	// 82EA36BC: 81700008  lwz r11, 8(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA36C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA36C4: 419A0018  beq cr6, 0x82ea36dc
	if ctx.cr[6].eq {
	pc = 0x82EA36DC; continue 'dispatch;
	}
	// 82EA36C8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA36CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA36D0: 4E800421  bctrl
	ctx.lr = 0x82EA36D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA36D4: 83DF0034  lwz r30, 0x34(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA36D8: 48000008  b 0x82ea36e0
	pc = 0x82EA36E0; continue 'dispatch;
            }
            0x82EA36DC => {
    //   block [0x82EA36DC..0x82EA36E0)
	// 82EA36DC: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	pc = 0x82EA36E0; continue 'dispatch;
            }
            0x82EA36E0 => {
    //   block [0x82EA36E0..0x82EA3798)
	// 82EA36E0: EC01D828  fsubs f0, f1, f27
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[27].f64) as f32) as f64);
	// 82EA36E4: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA36E8: C1940000  lfs f12, 0(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA36EC: 7BCA0020  clrldi r10, r30, 0x20
	ctx.r[10].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 82EA36F0: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82EA36F4: 41990288  bgt cr6, 0x82ea397c
	if ctx.cr[6].gt {
	pc = 0x82EA397C; continue 'dispatch;
	}
	// 82EA36F8: F9410078  std r10, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u64 ) };
	// 82EA36FC: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EA3700: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 82EA3704: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 82EA3708: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82EA370C: F9410088  std r10, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u64 ) };
	// 82EA3710: C9A10078  lfd f13, 0x78(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82EA3714: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82EA3718: C9410088  lfd f10, 0x88(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 82EA371C: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 82EA3720: FD606818  frsp f11, f13
	ctx.f[11].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82EA3724: C9A10080  lfd f13, 0x80(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82EA3728: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82EA372C: FD206818  frsp f9, f13
	ctx.f[9].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82EA3730: FDA05018  frsp f13, f10
	ctx.f[13].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82EA3734: ED89033A  fmadds f12, f9, f12, f0
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EA3738: EDBE6824  fdivs f13, f30, f13
	ctx.f[13].f64 = ((ctx.f[30].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EA373C: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EA3740: D1940000  stfs f12, 0(r20)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EA3744: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3748: C1530000  lfs f10, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EA374C: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 82EA3750: ED8B0338  fmsubs f12, f11, f12, f0
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EA3754: FD806210  fabs f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 82EA3758: C9610090  lfd f11, 0x90(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82EA375C: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82EA3760: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82EA3764: ED8B62BA  fmadds f12, f11, f10, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EA3768: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EA376C: D1B30000  stfs f13, 0(r19)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EA3770: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3774: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EA3778: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA377C: C1B30000  lfs f13, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA3780: C1940000  lfs f12, 0(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA3784: EDAD66BA  fmadds f13, f13, f26, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[26].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EA3788: FF0DE800  fcmpu cr6, f13, f29
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[29].f64);
	// 82EA378C: 419A000C  beq cr6, 0x82ea3798
	if ctx.cr[6].eq {
	pc = 0x82EA3798; continue 'dispatch;
	}
	// 82EA3790: ED9C0028  fsubs f12, f28, f0
	ctx.f[12].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EA3794: EFEC6824  fdivs f31, f12, f13
	ctx.f[31].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	pc = 0x82EA3798; continue 'dispatch;
            }
            0x82EA3798 => {
    //   block [0x82EA3798..0x82EA37A8)
	// 82EA3798: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EA379C: FF600890  fmr f27, f1
	ctx.f[27].f64 = ctx.f[1].f64;
	// 82EA37A0: EF9C0028  fsubs f28, f28, f0
	ctx.f[28].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EA37A4: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	pc = 0x82EA37A8; continue 'dispatch;
            }
            0x82EA37A8 => {
    //   block [0x82EA37A8..0x82EA37BC)
	// 82EA37A8: 817FFFF4  lwz r11, -0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EA37AC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA37B0: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA37B4: 4082FE08  bne 0x82ea35bc
	if !ctx.cr[0].eq {
	pc = 0x82EA35BC; continue 'dispatch;
	}
	// 82EA37B8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	pc = 0x82EA37BC; continue 'dispatch;
            }
            0x82EA37BC => {
    //   block [0x82EA37BC..0x82EA3808)
	// 82EA37BC: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA37C0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA37C4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA37C8: 41980040  blt cr6, 0x82ea3808
	if ctx.cr[6].lt {
	pc = 0x82EA3808; continue 'dispatch;
	}
	// 82EA37CC: 4B3BD1ED  bl 0x822609b8
	ctx.lr = 0x82EA37D0;
	sub_822609B8(ctx, base);
	// 82EA37D0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA37D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EA37D8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA37DC: 4BFDDB55  bl 0x82e81330
	ctx.lr = 0x82EA37E0;
	sub_82E81330(ctx, base);
	// 82EA37E0: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA37E4: C1BE0074  lfs f13, 0x74(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA37E8: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 82EA37EC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA37F0: C8010090  lfd f0, 0x90(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82EA37F4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82EA37F8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82EA37FC: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA3800: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA3804: D01E0074  stfs f0, 0x74(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), tmp.u32 ) };
	pc = 0x82EA3808; continue 'dispatch;
            }
            0x82EA3808 => {
    //   block [0x82EA3808..0x82EA381C)
	// 82EA3808: 9A4B0000  stb r18, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[18].u8 ) };
	// 82EA380C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA3810: 922B0000  stw r17, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 82EA3814: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA3818: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82EA381C; continue 'dispatch;
            }
            0x82EA381C => {
    //   block [0x82EA381C..0x82EA3820)
	// 82EA381C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EA3820; continue 'dispatch;
            }
            0x82EA3820 => {
    //   block [0x82EA3820..0x82EA3830)
	// 82EA3820: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 82EA3824: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 82EA3828: 4BE0A4F5  bl 0x82cadd1c
	ctx.lr = 0x82EA382C;
	sub_82CADCEC(ctx, base);
	// 82EA382C: 4BE05BF8  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EA3830 => {
    //   block [0x82EA3830..0x82EA38A4)
	// 82EA3830: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82EA3834: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 82EA3838: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EA383C: 4BFFF16D  bl 0x82ea29a8
	ctx.lr = 0x82EA3840;
	sub_82EA29A8(ctx, base);
	// 82EA3840: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EA3844: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA3848: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EA384C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EA3850: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82EA3854: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82EA3858: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA385C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3860: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA3864: 41980040  blt cr6, 0x82ea38a4
	if ctx.cr[6].lt {
	pc = 0x82EA38A4; continue 'dispatch;
	}
	// 82EA3868: 4B3BD151  bl 0x822609b8
	ctx.lr = 0x82EA386C;
	sub_822609B8(ctx, base);
	// 82EA386C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA3870: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EA3874: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3878: 4BFDDAB9  bl 0x82e81330
	ctx.lr = 0x82EA387C;
	sub_82E81330(ctx, base);
	// 82EA387C: 83DF0034  lwz r30, 0x34(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA3880: C1BD0074  lfs f13, 0x74(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA3884: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82EA3888: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 82EA388C: C8010090  lfd f0, 0x90(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82EA3890: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82EA3894: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82EA3898: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA389C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA38A0: D01D0074  stfs f0, 0x74(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(116 as u32), tmp.u32 ) };
	pc = 0x82EA38A4; continue 'dispatch;
            }
            0x82EA38A4 => {
    //   block [0x82EA38A4..0x82EA38C4)
	// 82EA38A4: 81700008  lwz r11, 8(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA38A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA38AC: 419A0018  beq cr6, 0x82ea38c4
	if ctx.cr[6].eq {
	pc = 0x82EA38C4; continue 'dispatch;
	}
	// 82EA38B0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA38B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA38B8: 4E800421  bctrl
	ctx.lr = 0x82EA38BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA38BC: 83DF0034  lwz r30, 0x34(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA38C0: 48000008  b 0x82ea38c8
	pc = 0x82EA38C8; continue 'dispatch;
            }
            0x82EA38C4 => {
    //   block [0x82EA38C4..0x82EA38C8)
	// 82EA38C4: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	pc = 0x82EA38C8; continue 'dispatch;
            }
            0x82EA38C8 => {
    //   block [0x82EA38C8..0x82EA3964)
	// 82EA38C8: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA38CC: ED81D828  fsubs f12, f1, f27
	ctx.f[12].f64 = (((ctx.f[1].f64 - ctx.f[27].f64) as f32) as f64);
	// 82EA38D0: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EA38D4: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82EA38D8: F9410090  std r10, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u64 ) };
	// 82EA38DC: C8010090  lfd f0, 0x90(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82EA38E0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82EA38E4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82EA38E8: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EA38EC: 419A0078  beq cr6, 0x82ea3964
	if ctx.cr[6].eq {
	pc = 0x82EA3964; continue 'dispatch;
	}
	// 82EA38F0: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82EA38F4: C1B40000  lfs f13, 0(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA38F8: 7BCA0020  clrldi r10, r30, 0x20
	ctx.r[10].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 82EA38FC: EC1E0024  fdivs f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EA3900: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 82EA3904: F9410088  std r10, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u64 ) };
	// 82EA3908: C9610090  lfd f11, 0x90(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82EA390C: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82EA3910: C9410088  lfd f10, 0x88(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 82EA3914: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 82EA3918: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82EA391C: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82EA3920: EDAB637A  fmadds f13, f11, f13, f12
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EA3924: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA3928: D1B40000  stfs f13, 0(r20)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EA392C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3930: C1730000  lfs f11, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA3934: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 82EA3938: EDAA6378  fmsubs f13, f10, f13, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EA393C: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82EA3940: C9810090  lfd f12, 0x90(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82EA3944: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82EA3948: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82EA394C: EDAC6AFA  fmadds f13, f12, f11, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EA3950: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA3954: D0130000  stfs f0, 0(r19)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EA3958: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA395C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EA3960: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA3964; continue 'dispatch;
            }
            0x82EA3964 => {
    //   block [0x82EA3964..0x82EA397C)
	// 82EA3964: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA3968: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA396C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EA3970: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EA3974: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82EA3978: 4BFFFEA8  b 0x82ea3820
	pc = 0x82EA3820; continue 'dispatch;
            }
            0x82EA397C => {
    //   block [0x82EA397C..0x82EA3A3C)
	// 82EA397C: F9410090  std r10, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u64 ) };
	// 82EA3980: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EA3984: F9610088  std r11, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 82EA3988: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82EA398C: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82EA3990: C9A10090  lfd f13, 0x90(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82EA3994: F9410090  std r10, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u64 ) };
	// 82EA3998: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82EA399C: FD606818  frsp f11, f13
	ctx.f[11].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82EA39A0: C9A10088  lfd f13, 0x88(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 82EA39A4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82EA39A8: FD206818  frsp f9, f13
	ctx.f[9].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82EA39AC: ED89033A  fmadds f12, f9, f12, f0
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EA39B0: C9410090  lfd f10, 0x90(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82EA39B4: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 82EA39B8: FDA05018  frsp f13, f10
	ctx.f[13].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82EA39BC: EDBE6824  fdivs f13, f30, f13
	ctx.f[13].f64 = ((ctx.f[30].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EA39C0: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EA39C4: D1940000  stfs f12, 0(r20)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EA39C8: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA39CC: C1530000  lfs f10, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EA39D0: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 82EA39D4: EC0B0338  fmsubs f0, f11, f12, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EA39D8: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EA39DC: C9810090  lfd f12, 0x90(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82EA39E0: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82EA39E4: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82EA39E8: EC0C02BA  fmadds f0, f12, f10, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EA39EC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EA39F0: D0130000  stfs f0, 0(r19)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EA39F4: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA39F8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EA39FC: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA3A00: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA3A04: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82EA3A08: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA3A0C: 92CB0000  stw r22, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 82EA3A10: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA3A14: 92AB0000  stw r21, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 82EA3A18: 81590058  lwz r10, 0x58(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA3A1C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA3A20: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA3A24: 81590054  lwz r10, 0x54(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA3A28: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA3A2C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA3A30: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA3A34: 9B8B0000  stb r28, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 82EA3A38: 4BFFFDE8  b 0x82ea3820
	pc = 0x82EA3820; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA3A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EA3A40 size=816
    let mut pc: u32 = 0x82EA3A40;
    'dispatch: loop {
        match pc {
            0x82EA3A40 => {
    //   block [0x82EA3A40..0x82EA3AD8)
	// 82EA3A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA3A44: 4BE059A9  bl 0x82ca93ec
	ctx.lr = 0x82EA3A48;
	sub_82CA93D0(ctx, base);
	// 82EA3A48: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA3A4C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA3A50: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 82EA3A54: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 82EA3A58: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA3A5C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82EA3A60: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EA3A64: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82EA3A68: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 82EA3A6C: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA3A70: 4B3C41B1  bl 0x82267c20
	ctx.lr = 0x82EA3A74;
	sub_82267C20(ctx, base);
	// 82EA3A74: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82EA3A78: 418202C8  beq 0x82ea3d40
	if ctx.cr[0].eq {
	pc = 0x82EA3D40; continue 'dispatch;
	}
	// 82EA3A7C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82EA3A80: 4BFFEDA1  bl 0x82ea2820
	ctx.lr = 0x82EA3A84;
	sub_82EA2820(ctx, base);
	// 82EA3A84: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA3A88: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EA3A8C: 83D80004  lwz r30, 4(r24)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3A90: 3BEB7800  addi r31, r11, 0x7800
	ctx.r[31].s64 = ctx.r[11].s64 + 30720;
	// 82EA3A94: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EA3A98: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82EA3A9C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA3AA0: 418202A0  beq 0x82ea3d40
	if ctx.cr[0].eq {
	pc = 0x82EA3D40; continue 'dispatch;
	}
	// 82EA3AA4: 81780058  lwz r11, 0x58(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA3AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA3AAC: 419A0294  beq cr6, 0x82ea3d40
	if ctx.cr[6].eq {
	pc = 0x82EA3D40; continue 'dispatch;
	}
	// 82EA3AB0: 81780054  lwz r11, 0x54(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA3AB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA3AB8: 419A0288  beq cr6, 0x82ea3d40
	if ctx.cr[6].eq {
	pc = 0x82EA3D40; continue 'dispatch;
	}
	// 82EA3ABC: 57CBE7FF  rlwinm. r11, r30, 0x1c, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA3AC0: 41820018  beq 0x82ea3ad8
	if ctx.cr[0].eq {
	pc = 0x82EA3AD8; continue 'dispatch;
	}
	// 82EA3AC4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EA3AC8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82EA3ACC: 4B7815DD  bl 0x826250a8
	ctx.lr = 0x82EA3AD0;
	sub_826250A8(ctx, base);
	// 82EA3AD0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA3AD4: 4182026C  beq 0x82ea3d40
	if ctx.cr[0].eq {
	pc = 0x82EA3D40; continue 'dispatch;
	}
	pc = 0x82EA3AD8; continue 'dispatch;
            }
            0x82EA3AD8 => {
    //   block [0x82EA3AD8..0x82EA3AF4)
	// 82EA3AD8: 57CBEFFF  rlwinm. r11, r30, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA3ADC: 41820018  beq 0x82ea3af4
	if ctx.cr[0].eq {
	pc = 0x82EA3AF4; continue 'dispatch;
	}
	// 82EA3AE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EA3AE4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EA3AE8: 4B7711E1  bl 0x82614cc8
	ctx.lr = 0x82EA3AEC;
	sub_82614CC8(ctx, base);
	// 82EA3AEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA3AF0: 41820250  beq 0x82ea3d40
	if ctx.cr[0].eq {
	pc = 0x82EA3D40; continue 'dispatch;
	}
	pc = 0x82EA3AF4; continue 'dispatch;
            }
            0x82EA3AF4 => {
    //   block [0x82EA3AF4..0x82EA3AFC)
	// 82EA3AF4: 815FFFF8  lwz r10, -8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA3AF8: 48000028  b 0x82ea3b20
	pc = 0x82EA3B20; continue 'dispatch;
            }
            0x82EA3AFC => {
    //   block [0x82EA3AFC..0x82EA3B20)
	// 82EA3AFC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3B00: 9B2B0010  stb r25, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[25].u8 ) };
	// 82EA3B04: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3B08: 810A0010  lwz r8, 0x10(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA3B0C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA3B10: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EA3B14: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3B18: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EA3B1C: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA3B20; continue 'dispatch;
            }
            0x82EA3B20 => {
    //   block [0x82EA3B20..0x82EA3B3C)
	// 82EA3B20: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3B24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA3B28: 409AFFD4  bne cr6, 0x82ea3afc
	if !ctx.cr[6].eq {
	pc = 0x82EA3AFC; continue 'dispatch;
	}
	// 82EA3B2C: 817FFFF4  lwz r11, -0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EA3B30: 932A000C  stw r25, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 82EA3B34: 932A0014  stw r25, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[25].u32 ) };
	// 82EA3B38: 48000028  b 0x82ea3b60
	pc = 0x82EA3B60; continue 'dispatch;
            }
            0x82EA3B3C => {
    //   block [0x82EA3B3C..0x82EA3B60)
	// 82EA3B3C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3B40: 9B2A0010  stb r25, 0x10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[25].u8 ) };
	// 82EA3B44: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3B48: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA3B4C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA3B50: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EA3B54: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3B58: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EA3B5C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA3B60; continue 'dispatch;
            }
            0x82EA3B60 => {
    //   block [0x82EA3B60..0x82EA3B88)
	// 82EA3B60: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3B64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA3B68: 409AFFD4  bne cr6, 0x82ea3b3c
	if !ctx.cr[6].eq {
	pc = 0x82EA3B3C; continue 'dispatch;
	}
	// 82EA3B6C: 932B000C  stw r25, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 82EA3B70: 932B0014  stw r25, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[25].u32 ) };
	// 82EA3B74: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA3B78: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA3B7C: 40810024  ble 0x82ea3ba0
	if !ctx.cr[0].gt {
	pc = 0x82EA3BA0; continue 'dispatch;
	}
	// 82EA3B80: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 82EA3B84: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82EA3B88; continue 'dispatch;
            }
            0x82EA3B88 => {
    //   block [0x82EA3B88..0x82EA3BA0)
	// 82EA3B88: 811FFFFC  lwz r8, -4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EA3B8C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA3B90: 7D094214  add r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EA3B94: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82EA3B98: 93280004  stw r25, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82EA3B9C: 4082FFEC  bne 0x82ea3b88
	if !ctx.cr[0].eq {
	pc = 0x82EA3B88; continue 'dispatch;
	}
	pc = 0x82EA3BA0; continue 'dispatch;
            }
            0x82EA3BA0 => {
    //   block [0x82EA3BA0..0x82EA3BAC)
	// 82EA3BA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA3BA4: 40990020  ble cr6, 0x82ea3bc4
	if !ctx.cr[6].gt {
	pc = 0x82EA3BC4; continue 'dispatch;
	}
	// 82EA3BA8: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x82EA3BAC; continue 'dispatch;
            }
            0x82EA3BAC => {
    //   block [0x82EA3BAC..0x82EA3BC4)
	// 82EA3BAC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3BB0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA3BB4: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EA3BB8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82EA3BBC: 93290004  stw r25, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82EA3BC0: 4082FFEC  bne 0x82ea3bac
	if !ctx.cr[0].eq {
	pc = 0x82EA3BAC; continue 'dispatch;
	}
	pc = 0x82EA3BC4; continue 'dispatch;
            }
            0x82EA3BC4 => {
    //   block [0x82EA3BC4..0x82EA3C80)
	// 82EA3BC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA3BC8: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3BCC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EA3BD0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA3BD4: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 82EA3BD8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EA3BDC: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA3BE0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3BE4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82EA3BE8: 7C0A5D2E  stfsx f0, r10, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82EA3BEC: 80780058  lwz r3, 0x58(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA3BF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3BF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3BF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA3BFC: 4E800421  bctrl
	ctx.lr = 0x82EA3C00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA3C00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA3C04: 4182013C  beq 0x82ea3d40
	if ctx.cr[0].eq {
	pc = 0x82EA3D40; continue 'dispatch;
	}
	// 82EA3C08: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3C0C: C1A10050  lfs f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA3C10: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3C14: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EA3C18: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA3C1C: 839F000C  lwz r28, 0xc(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA3C20: 83DFFFF4  lwz r30, -0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EA3C24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EA3C28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA3C2C: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA3C30: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3C34: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA3C38: 7C0B552E  stfsx f0, r11, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82EA3C3C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3C40: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA3C44: 83BB0000  lwz r29, 0(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3C48: 4BFFF111  bl 0x82ea2d58
	ctx.lr = 0x82EA3C4C;
	sub_82EA2D58(ctx, base);
	// 82EA3C4C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EA3C50: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA3C54: 3BAB9128  addi r29, r11, -0x6ed8
	ctx.r[29].s64 = ctx.r[11].s64 + -28376;
	// 82EA3C58: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EA3C5C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA3C60: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3C64: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EA3C68: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82EA3C6C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3C70: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA3C74: 418200B4  beq 0x82ea3d28
	if ctx.cr[0].eq {
	pc = 0x82EA3D28; continue 'dispatch;
	}
	// 82EA3C78: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EA3C7C: 3B4AA1D8  addi r26, r10, -0x5e28
	ctx.r[26].s64 = ctx.r[10].s64 + -24104;
            }
            0x82EA3C80 => {
    //   block [0x82EA3C80..0x82EA3D28)
	// 82EA3C80: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3C84: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3C88: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3C8C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA3C90: 419A00BC  beq cr6, 0x82ea3d4c
	if ctx.cr[6].eq {
	pc = 0x82EA3D4C; continue 'dispatch;
	}
	// 82EA3C94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA3C98: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 82EA3C9C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EA3CA0: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 82EA3CA4: 92E10078  stw r23, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u32 ) };
	// 82EA3CA8: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 82EA3CAC: 93010080  stw r24, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[24].u32 ) };
	// 82EA3CB0: 92C10084  stw r22, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[22].u32 ) };
	// 82EA3CB4: 4B7710F5  bl 0x82614da8
	ctx.lr = 0x82EA3CB8;
	sub_82614DA8(ctx, base);
	// 82EA3CB8: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82EA3CBC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3CC0: 839FFFF4  lwz r28, -0xc(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EA3CC4: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA3CC8: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EA3CCC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA3CD0: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA3CD4: 4BFE11AD  bl 0x82e84e80
	ctx.lr = 0x82EA3CD8;
	sub_82E84E80(ctx, base);
	// 82EA3CD8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3CDC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA3CE0: 809FFFF8  lwz r4, -8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA3CE4: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA3CE8: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EA3CEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EA3CF0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA3CF4: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82EA3CF8: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3CFC: 4BFFF05D  bl 0x82ea2d58
	ctx.lr = 0x82EA3D00;
	sub_82EA2D58(ctx, base);
	// 82EA3D00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3D04: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA3D08: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA3D0C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3D10: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EA3D14: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82EA3D18: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3D1C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA3D20: 4082FF60  bne 0x82ea3c80
	if !ctx.cr[0].eq {
	pc = 0x82EA3C80; continue 'dispatch;
	}
	// 82EA3D24: 839F000C  lwz r28, 0xc(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EA3D28; continue 'dispatch;
            }
            0x82EA3D28 => {
    //   block [0x82EA3D28..0x82EA3D40)
	// 82EA3D28: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EA3D2C: 809F0034  lwz r4, 0x34(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA3D30: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA3D34: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA3D38: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3D3C: 4BFE7F9D  bl 0x82e8bcd8
	ctx.lr = 0x82EA3D40;
	sub_82E8BCD8(ctx, base);
	pc = 0x82EA3D40; continue 'dispatch;
            }
            0x82EA3D40 => {
    //   block [0x82EA3D40..0x82EA3D44)
	// 82EA3D40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EA3D44; continue 'dispatch;
            }
            0x82EA3D44 => {
    //   block [0x82EA3D44..0x82EA3D4C)
	// 82EA3D44: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EA3D48: 4BE056F4  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EA3D4C => {
    //   block [0x82EA3D4C..0x82EA3D70)
	// 82EA3D4C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA3D50: 809F0034  lwz r4, 0x34(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA3D54: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3D58: 4BFE7F81  bl 0x82e8bcd8
	ctx.lr = 0x82EA3D5C;
	sub_82E8BCD8(ctx, base);
	// 82EA3D5C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82EA3D60: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA3D64: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82EA3D68: 4BFFEC41  bl 0x82ea29a8
	ctx.lr = 0x82EA3D6C;
	sub_82EA29A8(ctx, base);
	// 82EA3D6C: 4BFFFFD8  b 0x82ea3d44
	pc = 0x82EA3D44; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA3D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA3D70 size=136
    let mut pc: u32 = 0x82EA3D70;
    'dispatch: loop {
        match pc {
            0x82EA3D70 => {
    //   block [0x82EA3D70..0x82EA3DAC)
	// 82EA3D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA3D74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA3D78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA3D7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA3D80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA3D84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA3D88: 396BA1F0  addi r11, r11, -0x5e10
	ctx.r[11].s64 = ctx.r[11].s64 + -24080;
	// 82EA3D8C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3D90: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA3D94: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA3D98: 41820014  beq 0x82ea3dac
	if ctx.cr[0].eq {
	pc = 0x82EA3DAC; continue 'dispatch;
	}
	// 82EA3D9C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA3DA0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA3DA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA3DA8: 4E800421  bctrl
	ctx.lr = 0x82EA3DAC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA3DAC => {
    //   block [0x82EA3DAC..0x82EA3DD8)
	// 82EA3DAC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3DB0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA3DB4: 41820024  beq 0x82ea3dd8
	if ctx.cr[0].eq {
	pc = 0x82EA3DD8; continue 'dispatch;
	}
	// 82EA3DB8: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA3DBC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA3DC0: 409A0018  bne cr6, 0x82ea3dd8
	if !ctx.cr[6].eq {
	pc = 0x82EA3DD8; continue 'dispatch;
	}
	// 82EA3DC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3DC8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EA3DCC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3DD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA3DD4: 4E800421  bctrl
	ctx.lr = 0x82EA3DD8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA3DD8 => {
    //   block [0x82EA3DD8..0x82EA3DF8)
	// 82EA3DD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EA3DDC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EA3DE0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA3DE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA3DE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA3DEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA3DF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA3DF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA3DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA3DF8 size=88
    let mut pc: u32 = 0x82EA3DF8;
    'dispatch: loop {
        match pc {
            0x82EA3DF8 => {
    //   block [0x82EA3DF8..0x82EA3E34)
	// 82EA3DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA3DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA3E00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EA3E04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA3E08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA3E0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA3E10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EA3E14: 4BFFFF5D  bl 0x82ea3d70
	ctx.lr = 0x82EA3E18;
	sub_82EA3D70(ctx, base);
	// 82EA3E18: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA3E1C: 41820018  beq 0x82ea3e34
	if ctx.cr[0].eq {
	pc = 0x82EA3E34; continue 'dispatch;
	}
	// 82EA3E20: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA3E24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA3E28: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA3E2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA3E30: 4E800421  bctrl
	ctx.lr = 0x82EA3E34;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA3E34 => {
    //   block [0x82EA3E34..0x82EA3E50)
	// 82EA3E34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA3E38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA3E3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA3E40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA3E44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EA3E48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA3E4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA3E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA3E50 size=128
    let mut pc: u32 = 0x82EA3E50;
    'dispatch: loop {
        match pc {
            0x82EA3E50 => {
    //   block [0x82EA3E50..0x82EA3E90)
	// 82EA3E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA3E54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA3E58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA3E5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA3E60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA3E64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA3E68: 396B1C18  addi r11, r11, 0x1c18
	ctx.r[11].s64 = ctx.r[11].s64 + 7192;
	// 82EA3E6C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA3E70: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA3E74: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA3E78: 41820018  beq 0x82ea3e90
	if ctx.cr[0].eq {
	pc = 0x82EA3E90; continue 'dispatch;
	}
	// 82EA3E7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3E80: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EA3E84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3E88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA3E8C: 4E800421  bctrl
	ctx.lr = 0x82EA3E90;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA3E90 => {
    //   block [0x82EA3E90..0x82EA3EB0)
	// 82EA3E90: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA3E94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA3E98: 41820018  beq 0x82ea3eb0
	if ctx.cr[0].eq {
	pc = 0x82EA3EB0; continue 'dispatch;
	}
	// 82EA3E9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3EA0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EA3EA4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA3EA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA3EAC: 4E800421  bctrl
	ctx.lr = 0x82EA3EB0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA3EB0 => {
    //   block [0x82EA3EB0..0x82EA3ED0)
	// 82EA3EB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EA3EB4: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EA3EB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA3EBC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA3EC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA3EC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA3EC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA3ECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA3ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA3ED0 size=88
    let mut pc: u32 = 0x82EA3ED0;
    'dispatch: loop {
        match pc {
            0x82EA3ED0 => {
    //   block [0x82EA3ED0..0x82EA3F0C)
	// 82EA3ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA3ED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA3ED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EA3EDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA3EE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA3EE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA3EE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EA3EEC: 4BFFFF65  bl 0x82ea3e50
	ctx.lr = 0x82EA3EF0;
	sub_82EA3E50(ctx, base);
	// 82EA3EF0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA3EF4: 41820018  beq 0x82ea3f0c
	if ctx.cr[0].eq {
	pc = 0x82EA3F0C; continue 'dispatch;
	}
	// 82EA3EF8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA3EFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA3F00: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA3F04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA3F08: 4E800421  bctrl
	ctx.lr = 0x82EA3F0C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA3F0C => {
    //   block [0x82EA3F0C..0x82EA3F28)
	// 82EA3F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA3F10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA3F14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA3F18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA3F1C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EA3F20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA3F24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA3F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA3F28 size=344
    let mut pc: u32 = 0x82EA3F28;
    'dispatch: loop {
        match pc {
            0x82EA3F28 => {
    //   block [0x82EA3F28..0x82EA3F88)
	// 82EA3F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA3F2C: 4BE054E1  bl 0x82ca940c
	ctx.lr = 0x82EA3F30;
	sub_82CA93D0(ctx, base);
	// 82EA3F30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA3F34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA3F38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA3F3C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EA3F40: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EA3F44: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 82EA3F48: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EA3F4C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EA3F50: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82EA3F54: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA3F58: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82EA3F5C: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82EA3F60: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82EA3F64: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EA3F68: 419A010C  beq cr6, 0x82ea4074
	if ctx.cr[6].eq {
	pc = 0x82EA4074; continue 'dispatch;
	}
	// 82EA3F6C: 3D6007FF  lis r11, 0x7ff
	ctx.r[11].s64 = 134152192;
	// 82EA3F70: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EA3F74: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82EA3F78: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA3F7C: 57AB2834  slwi r11, r29, 5
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA3F80: 40990008  ble cr6, 0x82ea3f88
	if !ctx.cr[6].gt {
	pc = 0x82EA3F88; continue 'dispatch;
	}
	// 82EA3F84: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82EA3F88; continue 'dispatch;
            }
            0x82EA3F88 => {
    //   block [0x82EA3F88..0x82EA3F98)
	// 82EA3F88: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EA3F8C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EA3F90: 41990008  bgt cr6, 0x82ea3f98
	if ctx.cr[6].gt {
	pc = 0x82EA3F98; continue 'dispatch;
	}
	// 82EA3F94: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82EA3F98; continue 'dispatch;
            }
            0x82EA3F98 => {
    //   block [0x82EA3F98..0x82EA3FCC)
	// 82EA3F98: 4B772991  bl 0x82616928
	ctx.lr = 0x82EA3F9C;
	sub_82616928(ctx, base);
	// 82EA3F9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA3FA0: 41820068  beq 0x82ea4008
	if ctx.cr[0].eq {
	pc = 0x82EA4008; continue 'dispatch;
	}
	// 82EA3FA4: 38C30004  addi r6, r3, 4
	ctx.r[6].s64 = ctx.r[3].s64 + 4;
	// 82EA3FA8: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82EA3FAC: 355DFFFF  addic. r10, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA3FB0: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82EA3FB4: 4180004C  blt 0x82ea4000
	if ctx.cr[0].lt {
	pc = 0x82EA4000; continue 'dispatch;
	}
	// 82EA3FB8: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EA3FBC: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82EA3FC0: 3969000C  addi r11, r9, 0xc
	ctx.r[11].s64 = ctx.r[9].s64 + 12;
	// 82EA3FC4: 3908A1F0  addi r8, r8, -0x5e10
	ctx.r[8].s64 = ctx.r[8].s64 + -24080;
	// 82EA3FC8: 38E7A1F4  addi r7, r7, -0x5e0c
	ctx.r[7].s64 = ctx.r[7].s64 + -24076;
	pc = 0x82EA3FCC; continue 'dispatch;
            }
            0x82EA3FCC => {
    //   block [0x82EA3FCC..0x82EA4000)
	// 82EA3FCC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA3FD0: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EA3FD4: 910BFFF8  stw r8, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 82EA3FD8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA3FDC: 93CBFFFC  stw r30, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[30].u32 ) };
	// 82EA3FE0: 39290020  addi r9, r9, 0x20
	ctx.r[9].s64 = ctx.r[9].s64 + 32;
	// 82EA3FE4: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82EA3FE8: 98AB0004  stb r5, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u8 ) };
	// 82EA3FEC: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EA3FF0: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EA3FF4: 9BCB0010  stb r30, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 82EA3FF8: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82EA3FFC: 4080FFD0  bge 0x82ea3fcc
	if !ctx.cr[0].lt {
	pc = 0x82EA3FCC; continue 'dispatch;
	}
	pc = 0x82EA4000; continue 'dispatch;
            }
            0x82EA4000 => {
    //   block [0x82EA4000..0x82EA4008)
	// 82EA4000: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82EA4004: 48000008  b 0x82ea400c
	pc = 0x82EA400C; continue 'dispatch;
            }
            0x82EA4008 => {
    //   block [0x82EA4008..0x82EA400C)
	// 82EA4008: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82EA400C; continue 'dispatch;
            }
            0x82EA400C => {
    //   block [0x82EA400C..0x82EA402C)
	// 82EA400C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EA4010: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EA4014: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EA4018: 93CB0014  stw r30, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82EA401C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA4020: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA4024: 4099003C  ble cr6, 0x82ea4060
	if !ctx.cr[6].gt {
	pc = 0x82EA4060; continue 'dispatch;
	}
	// 82EA4028: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	pc = 0x82EA402C; continue 'dispatch;
            }
            0x82EA402C => {
    //   block [0x82EA402C..0x82EA4060)
	// 82EA402C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA4030: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EA4034: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EA4038: 3909FFE0  addi r8, r9, -0x20
	ctx.r[8].s64 = ctx.r[9].s64 + -32;
	// 82EA403C: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EA4040: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA4044: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EA4048: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82EA404C: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA4050: 91280018  stw r9, 0x18(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EA4054: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA4058: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA405C: 4198FFD0  blt cr6, 0x82ea402c
	if ctx.cr[6].lt {
	pc = 0x82EA402C; continue 'dispatch;
	}
	pc = 0x82EA4060; continue 'dispatch;
            }
            0x82EA4060 => {
    //   block [0x82EA4060..0x82EA4074)
	// 82EA4060: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA4064: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA4068: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA406C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA4070: 93CBFFF8  stw r30, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[30].u32 ) };
	pc = 0x82EA4074; continue 'dispatch;
            }
            0x82EA4074 => {
    //   block [0x82EA4074..0x82EA4080)
	// 82EA4074: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA4078: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA407C: 4BE053E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA4080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA4080 size=180
    let mut pc: u32 = 0x82EA4080;
    'dispatch: loop {
        match pc {
            0x82EA4080 => {
    //   block [0x82EA4080..0x82EA40BC)
	// 82EA4080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA4084: 4BE05381  bl 0x82ca9404
	ctx.lr = 0x82EA4088;
	sub_82CA93D0(ctx, base);
	// 82EA4088: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA408C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EA4090: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA4094: 576B07BD  rlwinm. r11, r27, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA4098: 41820060  beq 0x82ea40f8
	if ctx.cr[0].eq {
	pc = 0x82EA40F8; continue 'dispatch;
	}
	// 82EA409C: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EA40A0: 3B9FFFFC  addi r28, r31, -4
	ctx.r[28].s64 = ctx.r[31].s64 + -4;
	// 82EA40A4: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA40A8: 37CBFFFF  addic. r30, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EA40AC: 7FEAFA14  add r31, r10, r31
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82EA40B0: 41800024  blt 0x82ea40d4
	if ctx.cr[0].lt {
	pc = 0x82EA40D4; continue 'dispatch;
	}
	// 82EA40B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EA40B8: 3BAB9128  addi r29, r11, -0x6ed8
	ctx.r[29].s64 = ctx.r[11].s64 + -28376;
	pc = 0x82EA40BC; continue 'dispatch;
            }
            0x82EA40BC => {
    //   block [0x82EA40BC..0x82EA40D4)
	// 82EA40BC: 3BFFFFE0  addi r31, r31, -0x20
	ctx.r[31].s64 = ctx.r[31].s64 + -32;
	// 82EA40C0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82EA40C4: 4BFFFCAD  bl 0x82ea3d70
	ctx.lr = 0x82EA40C8;
	sub_82EA3D70(ctx, base);
	// 82EA40C8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EA40CC: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82EA40D0: 4080FFEC  bge 0x82ea40bc
	if !ctx.cr[0].lt {
	pc = 0x82EA40BC; continue 'dispatch;
	}
	pc = 0x82EA40D4; continue 'dispatch;
            }
            0x82EA40D4 => {
    //   block [0x82EA40D4..0x82EA40F0)
	// 82EA40D4: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA40D8: 41820018  beq 0x82ea40f0
	if ctx.cr[0].eq {
	pc = 0x82EA40F0; continue 'dispatch;
	}
	// 82EA40DC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA40E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA40E4: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA40E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA40EC: 4E800421  bctrl
	ctx.lr = 0x82EA40F0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA40F0 => {
    //   block [0x82EA40F0..0x82EA40F8)
	// 82EA40F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA40F4: 48000038  b 0x82ea412c
	pc = 0x82EA412C; continue 'dispatch;
            }
            0x82EA40F8 => {
    //   block [0x82EA40F8..0x82EA4128)
	// 82EA40F8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82EA40FC: 4BFFFC75  bl 0x82ea3d70
	ctx.lr = 0x82EA4100;
	sub_82EA3D70(ctx, base);
	// 82EA4100: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EA4104: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EA4108: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA410C: 576A07FF  clrlwi. r10, r27, 0x1f
	ctx.r[10].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA4110: 41820018  beq 0x82ea4128
	if ctx.cr[0].eq {
	pc = 0x82EA4128; continue 'dispatch;
	}
	// 82EA4114: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA4118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA411C: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA4120: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA4124: 4E800421  bctrl
	ctx.lr = 0x82EA4128;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA4128 => {
    //   block [0x82EA4128..0x82EA412C)
	// 82EA4128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82EA412C; continue 'dispatch;
            }
            0x82EA412C => {
    //   block [0x82EA412C..0x82EA4134)
	// 82EA412C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EA4130: 4BE05324  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA4138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA4138 size=384
    let mut pc: u32 = 0x82EA4138;
    'dispatch: loop {
        match pc {
            0x82EA4138 => {
    //   block [0x82EA4138..0x82EA415C)
	// 82EA4138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA413C: 4BE052C5  bl 0x82ca9400
	ctx.lr = 0x82EA4140;
	sub_82CA93D0(ctx, base);
	// 82EA4140: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA4144: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EA4148: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EA414C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EA4150: 409A000C  bne cr6, 0x82ea415c
	if !ctx.cr[6].eq {
	pc = 0x82EA415C; continue 'dispatch;
	}
	// 82EA4154: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EA4158: 48000158  b 0x82ea42b0
	pc = 0x82EA42B0; continue 'dispatch;
            }
            0x82EA415C => {
    //   block [0x82EA415C..0x82EA418C)
	// 82EA415C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA4160: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA4164: 388BA204  addi r4, r11, -0x5dfc
	ctx.r[4].s64 = ctx.r[11].s64 + -24060;
	// 82EA4168: 4BFDFE39  bl 0x82e83fa0
	ctx.lr = 0x82EA416C;
	sub_82E83FA0(ctx, base);
	// 82EA416C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA4170: 4182001C  beq 0x82ea418c
	if ctx.cr[0].eq {
	pc = 0x82EA418C; continue 'dispatch;
	}
	// 82EA4174: 4BE0624D  bl 0x82caa3c0
	ctx.lr = 0x82EA4178;
	sub_82CAA3C0(ctx, base);
	// 82EA4178: 3B600008  li r27, 8
	ctx.r[27].s64 = 8;
	// 82EA417C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA4180: 418200C4  beq 0x82ea4244
	if ctx.cr[0].eq {
	pc = 0x82EA4244; continue 'dispatch;
	}
	// 82EA4184: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EA4188: 480000BC  b 0x82ea4244
	pc = 0x82EA4244; continue 'dispatch;
            }
            0x82EA418C => {
    //   block [0x82EA418C..0x82EA41A8)
	// 82EA418C: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA4190: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EA4194: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EA4198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA419C: 40990040  ble cr6, 0x82ea41dc
	if !ctx.cr[6].gt {
	pc = 0x82EA41DC; continue 'dispatch;
	}
	// 82EA41A0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82EA41A4: 3BCB5F1C  addi r30, r11, 0x5f1c
	ctx.r[30].s64 = ctx.r[11].s64 + 24348;
	pc = 0x82EA41A8; continue 'dispatch;
            }
            0x82EA41A8 => {
    //   block [0x82EA41A8..0x82EA41CC)
	// 82EA41A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EA41AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA41B0: 4BFDFE79  bl 0x82e84028
	ctx.lr = 0x82EA41B4;
	sub_82E84028(ctx, base);
	// 82EA41B4: 48317EAD  bl 0x831bc060
	ctx.lr = 0x82EA41B8;
	sub_831BC060(ctx, base);
	// 82EA41B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA41BC: 4BE08995  bl 0x82cacb50
	ctx.lr = 0x82EA41C0;
	sub_82CACB50(ctx, base);
	// 82EA41C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA41C4: 40820008  bne 0x82ea41cc
	if !ctx.cr[0].eq {
	pc = 0x82EA41CC; continue 'dispatch;
	}
	// 82EA41C8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	pc = 0x82EA41CC; continue 'dispatch;
            }
            0x82EA41CC => {
    //   block [0x82EA41CC..0x82EA41DC)
	// 82EA41CC: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA41D0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EA41D4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA41D8: 4198FFD0  blt cr6, 0x82ea41a8
	if ctx.cr[6].lt {
	pc = 0x82EA41A8; continue 'dispatch;
	}
	pc = 0x82EA41DC; continue 'dispatch;
            }
            0x82EA41DC => {
    //   block [0x82EA41DC..0x82EA41F8)
	// 82EA41DC: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA41E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EA41E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EA41E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA41EC: 4099004C  ble cr6, 0x82ea4238
	if !ctx.cr[6].gt {
	pc = 0x82EA4238; continue 'dispatch;
	}
	// 82EA41F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA41F4: 3BABA1F8  addi r29, r11, -0x5e08
	ctx.r[29].s64 = ctx.r[11].s64 + -24072;
	pc = 0x82EA41F8; continue 'dispatch;
            }
            0x82EA41F8 => {
    //   block [0x82EA41F8..0x82EA421C)
	// 82EA41F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EA41FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA4200: 4BFDFE29  bl 0x82e84028
	ctx.lr = 0x82EA4204;
	sub_82E84028(ctx, base);
	// 82EA4204: 48317E5D  bl 0x831bc060
	ctx.lr = 0x82EA4208;
	sub_831BC060(ctx, base);
	// 82EA4208: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EA420C: 4BE08945  bl 0x82cacb50
	ctx.lr = 0x82EA4210;
	sub_82CACB50(ctx, base);
	// 82EA4210: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA4214: 40820008  bne 0x82ea421c
	if !ctx.cr[0].eq {
	pc = 0x82EA421C; continue 'dispatch;
	}
	// 82EA4218: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	pc = 0x82EA421C; continue 'dispatch;
            }
            0x82EA421C => {
    //   block [0x82EA421C..0x82EA4238)
	// 82EA421C: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA4220: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EA4224: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA4228: 4198FFD0  blt cr6, 0x82ea41f8
	if ctx.cr[6].lt {
	pc = 0x82EA41F8; continue 'dispatch;
	}
	// 82EA422C: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EA4230: 40980008  bge cr6, 0x82ea4238
	if !ctx.cr[6].lt {
	pc = 0x82EA4238; continue 'dispatch;
	}
	// 82EA4234: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	pc = 0x82EA4238; continue 'dispatch;
            }
            0x82EA4238 => {
    //   block [0x82EA4238..0x82EA4244)
	// 82EA4238: 2B1B0008  cmplwi cr6, r27, 8
	ctx.cr[6].compare_u32(ctx.r[27].u32, 8 as u32, &mut ctx.xer);
	// 82EA423C: 40980008  bge cr6, 0x82ea4244
	if !ctx.cr[6].lt {
	pc = 0x82EA4244; continue 'dispatch;
	}
	// 82EA4240: 3B600008  li r27, 8
	ctx.r[27].s64 = 8;
	pc = 0x82EA4244; continue 'dispatch;
            }
            0x82EA4244 => {
    //   block [0x82EA4244..0x82EA4264)
	// 82EA4244: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EA4248: 4B7726E1  bl 0x82616928
	ctx.lr = 0x82EA424C;
	sub_82616928(ctx, base);
	// 82EA424C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA4250: 41820014  beq 0x82ea4264
	if ctx.cr[0].eq {
	pc = 0x82EA4264; continue 'dispatch;
	}
	// 82EA4254: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EA4258: 4BFFFCD1  bl 0x82ea3f28
	ctx.lr = 0x82EA425C;
	sub_82EA3F28(ctx, base);
	// 82EA425C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EA4260: 48000008  b 0x82ea4268
	pc = 0x82EA4268; continue 'dispatch;
            }
            0x82EA4264 => {
    //   block [0x82EA4264..0x82EA4268)
	// 82EA4264: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EA4268; continue 'dispatch;
            }
            0x82EA4268 => {
    //   block [0x82EA4268..0x82EA428C)
	// 82EA4268: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EA426C: 917A0004  stw r11, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EA4270: 4B7726B9  bl 0x82616928
	ctx.lr = 0x82EA4274;
	sub_82616928(ctx, base);
	// 82EA4274: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA4278: 41820014  beq 0x82ea428c
	if ctx.cr[0].eq {
	pc = 0x82EA428C; continue 'dispatch;
	}
	// 82EA427C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EA4280: 4BFFFCA9  bl 0x82ea3f28
	ctx.lr = 0x82EA4284;
	sub_82EA3F28(ctx, base);
	// 82EA4284: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EA4288: 48000008  b 0x82ea4290
	pc = 0x82EA4290; continue 'dispatch;
            }
            0x82EA428C => {
    //   block [0x82EA428C..0x82EA4290)
	// 82EA428C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EA4290; continue 'dispatch;
            }
            0x82EA4290 => {
    //   block [0x82EA4290..0x82EA42B0)
	// 82EA4290: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EA4294: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EA4298: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EA429C: 4BFE110D  bl 0x82e853a8
	ctx.lr = 0x82EA42A0;
	sub_82E853A8(ctx, base);
	// 82EA42A0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EA42A4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EA42A8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EA42AC: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x82EA42B0; continue 'dispatch;
            }
            0x82EA42B0 => {
    //   block [0x82EA42B0..0x82EA42B8)
	// 82EA42B0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EA42B4: 4BE0519C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA42B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA42B8 size=52
    let mut pc: u32 = 0x82EA42B8;
    'dispatch: loop {
        match pc {
            0x82EA42B8 => {
    //   block [0x82EA42B8..0x82EA42EC)
	// 82EA42B8: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA42BC: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA42C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA42C4: 40820028  bne 0x82ea42ec
	if !ctx.cr[0].eq {
		sub_82EA42EC(ctx, base);
		return;
	}
	// 82EA42C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA42CC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EA42D0: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EA42D4: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EA42D8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EA42DC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA42E0: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA42E4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EA42E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA42EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA42EC size=208
    let mut pc: u32 = 0x82EA42EC;
    'dispatch: loop {
        match pc {
            0x82EA42EC => {
    //   block [0x82EA42EC..0x82EA435C)
	// 82EA42EC: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA42F0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EA42F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA42F8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EA42FC: 91240014  stw r9, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82EA4300: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA4304: 91240010  stw r9, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EA4308: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA430C: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EA4310: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA4314: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EA4318: 8925000C  lbz r9, 0xc(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA431C: 992B0010  stb r9, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u8 ) };
	// 82EA4320: 990B001C  stb r8, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[8].u8 ) };
	// 82EA4324: 409A0054  bne cr6, 0x82ea4378
	if !ctx.cr[6].eq {
	pc = 0x82EA4378; continue 'dispatch;
	}
	// 82EA4328: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA432C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA4330: 4082002C  bne 0x82ea435c
	if !ctx.cr[0].eq {
	pc = 0x82EA435C; continue 'dispatch;
	}
	// 82EA4334: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EA4338: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EA433C: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EA4340: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA4344: 91490014  stw r10, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EA4348: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA434C: 91490014  stw r10, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EA4350: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA4354: 91490018  stw r10, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EA4358: 48000044  b 0x82ea439c
	pc = 0x82EA439C; continue 'dispatch;
            }
            0x82EA435C => {
    //   block [0x82EA435C..0x82EA4378)
	// 82EA435C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EA4360: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EA4364: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EA4368: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA436C: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EA4370: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EA4374: 48000028  b 0x82ea439c
	pc = 0x82EA439C; continue 'dispatch;
            }
            0x82EA4378 => {
    //   block [0x82EA4378..0x82EA4398)
	// 82EA4378: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA437C: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EA4380: 916A0014  stw r11, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EA4384: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA4388: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82EA438C: 4182000C  beq 0x82ea4398
	if ctx.cr[0].eq {
	pc = 0x82EA4398; continue 'dispatch;
	}
	// 82EA4390: 91690018  stw r11, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EA4394: 48000008  b 0x82ea439c
	pc = 0x82EA439C; continue 'dispatch;
            }
            0x82EA4398 => {
    //   block [0x82EA4398..0x82EA439C)
	// 82EA4398: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA439C; continue 'dispatch;
            }
            0x82EA439C => {
    //   block [0x82EA439C..0x82EA43BC)
	// 82EA439C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EA43A0: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EA43A4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EA43A8: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EA43AC: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EA43B0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA43B4: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EA43B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA43C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA43C0 size=76
    let mut pc: u32 = 0x82EA43C0;
    'dispatch: loop {
        match pc {
            0x82EA43C0 => {
    //   block [0x82EA43C0..0x82EA43F8)
	// 82EA43C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA43C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA43C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA43CC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EA43D0: 4B772559  bl 0x82616928
	ctx.lr = 0x82EA43D4;
	sub_82616928(ctx, base);
	// 82EA43D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA43D8: 41820020  beq 0x82ea43f8
	if ctx.cr[0].eq {
	pc = 0x82EA43F8; continue 'dispatch;
	}
	// 82EA43DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA43E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EA43E4: 396B1C18  addi r11, r11, 0x1c18
	ctx.r[11].s64 = ctx.r[11].s64 + 7192;
	// 82EA43E8: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EA43EC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA43F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EA43F4: 48000008  b 0x82ea43fc
	pc = 0x82EA43FC; continue 'dispatch;
            }
            0x82EA43F8 => {
    //   block [0x82EA43F8..0x82EA43FC)
	// 82EA43F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EA43FC; continue 'dispatch;
            }
            0x82EA43FC => {
    //   block [0x82EA43FC..0x82EA440C)
	// 82EA43FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA4400: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA4404: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA4408: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA4410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA4410 size=840
    let mut pc: u32 = 0x82EA4410;
    'dispatch: loop {
        match pc {
            0x82EA4410 => {
    //   block [0x82EA4410..0x82EA444C)
	// 82EA4410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA4414: 4BE04FF1  bl 0x82ca9404
	ctx.lr = 0x82EA4418;
	sub_82CA93D0(ctx, base);
	// 82EA4418: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA441C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EA4420: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EA4424: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EA4428: 419A00E0  beq cr6, 0x82ea4508
	if ctx.cr[6].eq {
	pc = 0x82EA4508; continue 'dispatch;
	}
	// 82EA442C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA4430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA4434: 3BCBA204  addi r30, r11, -0x5dfc
	ctx.r[30].s64 = ctx.r[11].s64 + -24060;
	// 82EA4438: 48317C29  bl 0x831bc060
	ctx.lr = 0x82EA443C;
	sub_831BC060(ctx, base);
	// 82EA443C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA4440: 4BE08711  bl 0x82cacb50
	ctx.lr = 0x82EA4444;
	sub_82CACB50(ctx, base);
	// 82EA4444: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA4448: 4082000C  bne 0x82ea4454
	if !ctx.cr[0].eq {
	pc = 0x82EA4454; continue 'dispatch;
	}
	pc = 0x82EA444C; continue 'dispatch;
            }
            0x82EA444C => {
    //   block [0x82EA444C..0x82EA4454)
	// 82EA444C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA4450: 480000BC  b 0x82ea450c
	pc = 0x82EA450C; continue 'dispatch;
            }
            0x82EA4454 => {
    //   block [0x82EA4454..0x82EA44D0)
	// 82EA4454: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82EA4458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA445C: 3BCB5F1C  addi r30, r11, 0x5f1c
	ctx.r[30].s64 = ctx.r[11].s64 + 24348;
	// 82EA4460: 48317C01  bl 0x831bc060
	ctx.lr = 0x82EA4464;
	sub_831BC060(ctx, base);
	// 82EA4464: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA4468: 4BE086E9  bl 0x82cacb50
	ctx.lr = 0x82EA446C;
	sub_82CACB50(ctx, base);
	// 82EA446C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA4470: 40820178  bne 0x82ea45e8
	if !ctx.cr[0].eq {
	pc = 0x82EA45E8; continue 'dispatch;
	}
	// 82EA4474: 83BF000C  lwz r29, 0xc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA4478: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA447C: 4182008C  beq 0x82ea4508
	if ctx.cr[0].eq {
	pc = 0x82EA4508; continue 'dispatch;
	}
	// 82EA4480: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EA4484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA4488: 3BCB4DAC  addi r30, r11, 0x4dac
	ctx.r[30].s64 = ctx.r[11].s64 + 19884;
	// 82EA448C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA4490: 4BFDFA89  bl 0x82e83f18
	ctx.lr = 0x82EA4494;
	sub_82E83F18(ctx, base);
	// 82EA4494: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA4498: 41820070  beq 0x82ea4508
	if ctx.cr[0].eq {
	pc = 0x82EA4508; continue 'dispatch;
	}
	// 82EA449C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA44A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA44A4: 4BFDFA75  bl 0x82e83f18
	ctx.lr = 0x82EA44A8;
	sub_82E83F18(ctx, base);
	// 82EA44A8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EA44AC: 4182FFA0  beq 0x82ea444c
	if ctx.cr[0].eq {
	pc = 0x82EA444C; continue 'dispatch;
	}
	// 82EA44B0: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 82EA44B4: 4B772475  bl 0x82616928
	ctx.lr = 0x82EA44B8;
	sub_82616928(ctx, base);
	// 82EA44B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EA44BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA44C0: 41820010  beq 0x82ea44d0
	if ctx.cr[0].eq {
	pc = 0x82EA44D0; continue 'dispatch;
	}
	// 82EA44C4: 48001835  bl 0x82ea5cf8
	ctx.lr = 0x82EA44C8;
	sub_82EA5CF8(ctx, base);
	// 82EA44C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EA44CC: 48000008  b 0x82ea44d4
	pc = 0x82EA44D4; continue 'dispatch;
            }
            0x82EA44D0 => {
    //   block [0x82EA44D0..0x82EA44D4)
	// 82EA44D0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	pc = 0x82EA44D4; continue 'dispatch;
            }
            0x82EA44D4 => {
    //   block [0x82EA44D4..0x82EA4508)
	// 82EA44D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA44D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA44DC: 48005B9D  bl 0x82eaa078
	ctx.lr = 0x82EA44E0;
	sub_82EAA078(ctx, base);
	// 82EA44E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA44E4: 40820030  bne 0x82ea4514
	if !ctx.cr[0].eq {
	pc = 0x82EA4514; continue 'dispatch;
	}
	// 82EA44E8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EA44EC: 419A001C  beq cr6, 0x82ea4508
	if ctx.cr[6].eq {
	pc = 0x82EA4508; continue 'dispatch;
	}
	// 82EA44F0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA44F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EA44F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA44FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA4500: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA4504: 4E800421  bctrl
	ctx.lr = 0x82EA4508;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA4508 => {
    //   block [0x82EA4508..0x82EA450C)
	// 82EA4508: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EA450C; continue 'dispatch;
            }
            0x82EA450C => {
    //   block [0x82EA450C..0x82EA4514)
	// 82EA450C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EA4510: 4BE04F44  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EA4514 => {
    //   block [0x82EA4514..0x82EA458C)
	// 82EA4514: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA4518: 809B0004  lwz r4, 4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA451C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EA4520: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82EA4524: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EA4528: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82EA452C: 394AA1F0  addi r10, r10, -0x5e10
	ctx.r[10].s64 = ctx.r[10].s64 + -24080;
	// 82EA4530: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82EA4534: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EA4538: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EA453C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EA4540: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EA4544: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EA4548: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82EA454C: 9961006C  stb r11, 0x6c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 82EA4550: 4BFFFD69  bl 0x82ea42b8
	ctx.lr = 0x82EA4554;
	sub_82EA42B8(ctx, base);
	// 82EA4554: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EA4558: 4BFFF819  bl 0x82ea3d70
	ctx.lr = 0x82EA455C;
	sub_82EA3D70(ctx, base);
	// 82EA455C: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA4560: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EA4564: 409A0028  bne cr6, 0x82ea458c
	if !ctx.cr[6].eq {
	pc = 0x82EA458C; continue 'dispatch;
	}
	// 82EA4568: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EA456C: 419AFEE0  beq cr6, 0x82ea444c
	if ctx.cr[6].eq {
	pc = 0x82EA444C; continue 'dispatch;
	}
	// 82EA4570: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA4574: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EA4578: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA457C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA4580: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA4584: 4E800421  bctrl
	ctx.lr = 0x82EA4588;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4588: 4BFFFEC4  b 0x82ea444c
	pc = 0x82EA444C; continue 'dispatch;
            }
            0x82EA458C => {
    //   block [0x82EA458C..0x82EA4594)
	// 82EA458C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EA4590: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82EA4594; continue 'dispatch;
            }
            0x82EA4594 => {
    //   block [0x82EA4594..0x82EA45C4)
	// 82EA4594: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA4598: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EA459C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EA45A0: 409AFFF4  bne cr6, 0x82ea4594
	if !ctx.cr[6].eq {
	pc = 0x82EA4594; continue 'dispatch;
	}
	// 82EA45A4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EA45A8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EA45AC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA45B0: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82EA45B4: 4B772375  bl 0x82616928
	ctx.lr = 0x82EA45B8;
	sub_82616928(ctx, base);
	// 82EA45B8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EA45BC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EA45C0: 7D3D5050  subf r9, r29, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[29].s64;
	pc = 0x82EA45C4; continue 'dispatch;
            }
            0x82EA45C4 => {
    //   block [0x82EA45C4..0x82EA45E8)
	// 82EA45C4: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA45C8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA45CC: 7D0959AE  stbx r8, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u8) };
	// 82EA45D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EA45D4: 4082FFF0  bne 0x82ea45c4
	if !ctx.cr[0].eq {
	pc = 0x82EA45C4; continue 'dispatch;
	}
	// 82EA45D8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EA45DC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA45E0: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82EA45E4: 4BFFFF28  b 0x82ea450c
	pc = 0x82EA450C; continue 'dispatch;
            }
            0x82EA45E8 => {
    //   block [0x82EA45E8..0x82EA4664)
	// 82EA45E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA45EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA45F0: 3BCBA1F8  addi r30, r11, -0x5e08
	ctx.r[30].s64 = ctx.r[11].s64 + -24072;
	// 82EA45F4: 48317A6D  bl 0x831bc060
	ctx.lr = 0x82EA45F8;
	sub_831BC060(ctx, base);
	// 82EA45F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA45FC: 4BE08555  bl 0x82cacb50
	ctx.lr = 0x82EA4600;
	sub_82CACB50(ctx, base);
	// 82EA4600: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA4604: 4082FF04  bne 0x82ea4508
	if !ctx.cr[0].eq {
	pc = 0x82EA4508; continue 'dispatch;
	}
	// 82EA4608: 83BF000C  lwz r29, 0xc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA460C: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA4610: 4182FEF8  beq 0x82ea4508
	if ctx.cr[0].eq {
	pc = 0x82EA4508; continue 'dispatch;
	}
	// 82EA4614: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EA4618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA461C: 3BCB4DAC  addi r30, r11, 0x4dac
	ctx.r[30].s64 = ctx.r[11].s64 + 19884;
	// 82EA4620: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA4624: 4BFDF8F5  bl 0x82e83f18
	ctx.lr = 0x82EA4628;
	sub_82E83F18(ctx, base);
	// 82EA4628: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA462C: 4182FEDC  beq 0x82ea4508
	if ctx.cr[0].eq {
	pc = 0x82EA4508; continue 'dispatch;
	}
	// 82EA4630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA4634: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA4638: 4BFDF8E1  bl 0x82e83f18
	ctx.lr = 0x82EA463C;
	sub_82E83F18(ctx, base);
	// 82EA463C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EA4640: 4182FE0C  beq 0x82ea444c
	if ctx.cr[0].eq {
	pc = 0x82EA444C; continue 'dispatch;
	}
	// 82EA4644: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 82EA4648: 4B7722E1  bl 0x82616928
	ctx.lr = 0x82EA464C;
	sub_82616928(ctx, base);
	// 82EA464C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EA4650: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA4654: 41820010  beq 0x82ea4664
	if ctx.cr[0].eq {
	pc = 0x82EA4664; continue 'dispatch;
	}
	// 82EA4658: 48009DD9  bl 0x82eae430
	ctx.lr = 0x82EA465C;
	sub_82EAE430(ctx, base);
	// 82EA465C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EA4660: 48000008  b 0x82ea4668
	pc = 0x82EA4668; continue 'dispatch;
            }
            0x82EA4664 => {
    //   block [0x82EA4664..0x82EA4668)
	// 82EA4664: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	pc = 0x82EA4668; continue 'dispatch;
            }
            0x82EA4668 => {
    //   block [0x82EA4668..0x82EA4688)
	// 82EA4668: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA466C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA4670: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA4674: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA4678: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA467C: 4E800421  bctrl
	ctx.lr = 0x82EA4680;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4680: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA4684: 40820024  bne 0x82ea46a8
	if !ctx.cr[0].eq {
	pc = 0x82EA46A8; continue 'dispatch;
	}
            }
            0x82EA4688 => {
    //   block [0x82EA4688..0x82EA46A8)
	// 82EA4688: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA468C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EA4690: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA4694: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA4698: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA469C: 4E800421  bctrl
	ctx.lr = 0x82EA46A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA46A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA46A4: 4BFFFE68  b 0x82ea450c
	pc = 0x82EA450C; continue 'dispatch;
            }
            0x82EA46A8 => {
    //   block [0x82EA46A8..0x82EA4704)
	// 82EA46A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA46AC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82EA46B0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EA46B4: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82EA46B8: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82EA46BC: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EA46C0: 394AA1F0  addi r10, r10, -0x5e10
	ctx.r[10].s64 = ctx.r[10].s64 + -24080;
	// 82EA46C4: 809B0008  lwz r4, 8(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA46C8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82EA46CC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EA46D0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EA46D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EA46D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EA46DC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82EA46E0: 9BE1006C  stb r31, 0x6c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u8 ) };
	// 82EA46E4: 4BFFFBD5  bl 0x82ea42b8
	ctx.lr = 0x82EA46E8;
	sub_82EA42B8(ctx, base);
	// 82EA46E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EA46EC: 4BFFF685  bl 0x82ea3d70
	ctx.lr = 0x82EA46F0;
	sub_82EA3D70(ctx, base);
	// 82EA46F0: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA46F4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EA46F8: 419AFF90  beq cr6, 0x82ea4688
	if ctx.cr[6].eq {
	pc = 0x82EA4688; continue 'dispatch;
	}
	// 82EA46FC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EA4700: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82EA4704; continue 'dispatch;
            }
            0x82EA4704 => {
    //   block [0x82EA4704..0x82EA4734)
	// 82EA4704: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA4708: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EA470C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EA4710: 409AFFF4  bne cr6, 0x82ea4704
	if !ctx.cr[6].eq {
	pc = 0x82EA4704; continue 'dispatch;
	}
	// 82EA4714: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EA4718: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EA471C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA4720: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82EA4724: 4B772205  bl 0x82616928
	ctx.lr = 0x82EA4728;
	sub_82616928(ctx, base);
	// 82EA4728: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EA472C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EA4730: 7D3D5050  subf r9, r29, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[29].s64;
	pc = 0x82EA4734; continue 'dispatch;
            }
            0x82EA4734 => {
    //   block [0x82EA4734..0x82EA4758)
	// 82EA4734: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA4738: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA473C: 7D0959AE  stbx r8, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u8) };
	// 82EA4740: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EA4744: 4082FFF0  bne 0x82ea4734
	if !ctx.cr[0].eq {
	pc = 0x82EA4734; continue 'dispatch;
	}
	// 82EA4748: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EA474C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA4750: 939E000C  stw r28, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82EA4754: 4BFFFDB8  b 0x82ea450c
	pc = 0x82EA450C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA4758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA4758 size=5532
    let mut pc: u32 = 0x82EA4758;
    'dispatch: loop {
        match pc {
            0x82EA4758 => {
    //   block [0x82EA4758..0x82EA4AF8)
	// 82EA4758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA475C: 4BE04C81  bl 0x82ca93dc
	ctx.lr = 0x82EA4760;
	sub_82CA93D0(ctx, base);
	// 82EA4760: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA4764: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EA4768: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 82EA476C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EA4770: 419A1578  beq cr6, 0x82ea5ce8
	if ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4774: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA4778: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA477C: 3BCBDAC0  addi r30, r11, -0x2540
	ctx.r[30].s64 = ctx.r[11].s64 + -9536;
	// 82EA4780: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA4784: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 82EA4788: 386BA228  addi r3, r11, -0x5dd8
	ctx.r[3].s64 = ctx.r[11].s64 + -24024;
	// 82EA478C: 3D600500  lis r11, 0x500
	ctx.r[11].s64 = 83886080;
	// 82EA4790: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EA4794: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EA4798: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA479C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA47A0: 4E800421  bctrl
	ctx.lr = 0x82EA47A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA47A4: 2B03000C  cmplwi cr6, r3, 0xc
	ctx.cr[6].compare_u32(ctx.r[3].u32, 12 as u32, &mut ctx.xer);
	// 82EA47A8: 409A1540  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA47AC: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA47B0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA47B4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA47B8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA47BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EA47C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA47C4: 4E800421  bctrl
	ctx.lr = 0x82EA47C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA47C8: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA47CC: 409A151C  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA47D0: 81730004  lwz r11, 4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA47D4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA47D8: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA47DC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA47E0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA47E4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA47E8: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA47EC: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA47F0: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA47F4: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA47F8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA47FC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4800: 386100CC  addi r3, r1, 0xcc
	ctx.r[3].s64 = ctx.r[1].s64 + 204;
	// 82EA4804: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82EA4808: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA480C: 4E800421  bctrl
	ctx.lr = 0x82EA4810;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4810: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4814: 409A14D4  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4818: 81730008  lwz r11, 8(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA481C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4820: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4824: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4828: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA482C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4830: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4834: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4838: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA483C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4840: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4844: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4848: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EA484C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EA4850: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4854: 4E800421  bctrl
	ctx.lr = 0x82EA4858;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4858: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA485C: 409A148C  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4860: 81730010  lwz r11, 0x10(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA4864: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4868: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA486C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4870: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4874: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4878: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA487C: 5168843E  rlwimi r8, r11, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4880: 552B401E  rlwinm r11, r9, 8, 0, 0xf
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4884: 5509C43E  rlwinm r9, r8, 0x18, 0x10, 0x1f
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA4888: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA488C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4890: 38610124  addi r3, r1, 0x124
	ctx.r[3].s64 = ctx.r[1].s64 + 292;
	// 82EA4894: 91610124  stw r11, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 82EA4898: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA489C: 4E800421  bctrl
	ctx.lr = 0x82EA48A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA48A0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA48A4: 409A1444  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA48A8: 81730014  lwz r11, 0x14(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA48AC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA48B0: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA48B4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA48B8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA48BC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA48C0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA48C4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA48C8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA48CC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA48D0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA48D4: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA48D8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EA48DC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EA48E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA48E4: 4E800421  bctrl
	ctx.lr = 0x82EA48E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA48E8: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA48EC: 409A13FC  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA48F0: 81730018  lwz r11, 0x18(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA48F4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA48F8: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA48FC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4900: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4904: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4908: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA490C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4910: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4914: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4918: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA491C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4920: 386100D4  addi r3, r1, 0xd4
	ctx.r[3].s64 = ctx.r[1].s64 + 212;
	// 82EA4924: 916100D4  stw r11, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 82EA4928: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA492C: 4E800421  bctrl
	ctx.lr = 0x82EA4930;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4930: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4934: 409A13B4  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4938: 8173001C  lwz r11, 0x1c(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA493C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4940: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4944: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4948: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA494C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4950: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4954: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4958: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA495C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4960: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4964: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4968: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82EA496C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EA4970: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4974: 4E800421  bctrl
	ctx.lr = 0x82EA4978;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4978: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA497C: 409A136C  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4980: 81730020  lwz r11, 0x20(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA4984: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4988: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA498C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4990: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4994: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4998: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA499C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA49A0: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA49A4: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA49A8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA49AC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA49B0: 3861010C  addi r3, r1, 0x10c
	ctx.r[3].s64 = ctx.r[1].s64 + 268;
	// 82EA49B4: 9161010C  stw r11, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 82EA49B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA49BC: 4E800421  bctrl
	ctx.lr = 0x82EA49C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA49C0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA49C4: 409A1324  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA49C8: 81730024  lwz r11, 0x24(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA49CC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA49D0: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA49D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA49D8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA49DC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA49E0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA49E4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA49E8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA49EC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA49F0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA49F4: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA49F8: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EA49FC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EA4A00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4A04: 4E800421  bctrl
	ctx.lr = 0x82EA4A08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4A08: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4A0C: 409A12DC  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4A10: 8173000C  lwz r11, 0xc(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA4A14: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4A18: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4A1C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4A20: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4A24: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4A28: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4A2C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4A30: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4A34: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4A38: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4A3C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4A40: 386100DC  addi r3, r1, 0xdc
	ctx.r[3].s64 = ctx.r[1].s64 + 220;
	// 82EA4A44: 916100DC  stw r11, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 82EA4A48: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4A4C: 4E800421  bctrl
	ctx.lr = 0x82EA4A50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4A50: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4A54: 409A1294  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4A58: 81730030  lwz r11, 0x30(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EA4A5C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4A60: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4A64: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4A68: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4A6C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4A70: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4A74: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4A78: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4A7C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4A80: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4A84: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4A88: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82EA4A8C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EA4A90: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4A94: 4E800421  bctrl
	ctx.lr = 0x82EA4A98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4A98: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4A9C: 409A124C  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4AA0: 81730034  lwz r11, 0x34(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA4AA4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4AA8: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4AAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4AB0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4AB4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4AB8: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4ABC: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4AC0: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4AC4: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4AC8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4ACC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4AD0: 38610134  addi r3, r1, 0x134
	ctx.r[3].s64 = ctx.r[1].s64 + 308;
	// 82EA4AD4: 91610134  stw r11, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 82EA4AD8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4ADC: 4E800421  bctrl
	ctx.lr = 0x82EA4AE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4AE0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4AE4: 409A1204  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4AE8: 81730020  lwz r11, 0x20(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA4AEC: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 82EA4AF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA4AF4: 40990F48  ble cr6, 0x82ea5a3c
	if !ctx.cr[6].gt {
	pc = 0x82EA5A3C; continue 'dispatch;
	}
            }
            0x82EA4AF8 => {
    //   block [0x82EA4AF8..0x82EA4B10)
	// 82EA4AF8: 81730024  lwz r11, 0x24(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA4AFC: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 82EA4B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA4B04: 40990F28  ble cr6, 0x82ea5a2c
	if !ctx.cr[6].gt {
	pc = 0x82EA5A2C; continue 'dispatch;
	}
	// 82EA4B08: 5636103A  slwi r22, r17, 2
	ctx.r[22].u32 = ctx.r[17].u32.wrapping_shl(2);
	ctx.r[22].u64 = ctx.r[22].u32 as u64;
	// 82EA4B0C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	pc = 0x82EA4B10; continue 'dispatch;
            }
            0x82EA4B10 => {
    //   block [0x82EA4B10..0x82EA4B7C)
	// 82EA4B10: 8173002C  lwz r11, 0x2c(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA4B14: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4B18: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4B1C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4B20: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4B24: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82EA4B28: 7D6BB02E  lwzx r11, r11, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82EA4B2C: 7D6BB82E  lwzx r11, r11, r23
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82EA4B30: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4B34: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4B38: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4B3C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4B40: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4B44: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4B48: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4B4C: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EA4B50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4B54: 4E800421  bctrl
	ctx.lr = 0x82EA4B58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4B58: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4B5C: 409A118C  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4B60: 8173002C  lwz r11, 0x2c(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA4B64: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 82EA4B68: 7D6BB02E  lwzx r11, r11, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82EA4B6C: 7D6BB82E  lwzx r11, r11, r23
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82EA4B70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA4B74: 40990EA4  ble cr6, 0x82ea5a18
	if !ctx.cr[6].gt {
	pc = 0x82EA5A18; continue 'dispatch;
	}
	// 82EA4B78: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
            }
            0x82EA4B7C => {
    //   block [0x82EA4B7C..0x82EA4C78)
	// 82EA4B7C: 81730028  lwz r11, 0x28(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA4B80: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4B84: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4B88: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4B8C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4B90: 386100E4  addi r3, r1, 0xe4
	ctx.r[3].s64 = ctx.r[1].s64 + 228;
	// 82EA4B94: 7D6BB02E  lwzx r11, r11, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82EA4B98: 7D6BB82E  lwzx r11, r11, r23
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82EA4B9C: 7FEBAA14  add r31, r11, r21
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[21].u64;
	// 82EA4BA0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA4BA4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4BA8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4BAC: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4BB0: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4BB4: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4BB8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4BBC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4BC0: 916100E4  stw r11, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82EA4BC4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4BC8: 4E800421  bctrl
	ctx.lr = 0x82EA4BCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4BCC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4BD0: 409A1118  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4BD4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA4BD8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4BDC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4BE0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4BE4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4BE8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4BEC: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4BF0: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4BF4: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4BF8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4BFC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4C00: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4C04: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82EA4C08: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EA4C0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4C10: 4E800421  bctrl
	ctx.lr = 0x82EA4C14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4C14: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4C18: 409A10D0  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4C1C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA4C20: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4C24: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4C28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4C2C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4C30: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4C34: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4C38: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4C3C: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4C40: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4C44: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4C48: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4C4C: 38610114  addi r3, r1, 0x114
	ctx.r[3].s64 = ctx.r[1].s64 + 276;
	// 82EA4C50: 91610114  stw r11, 0x114(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 82EA4C54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4C58: 4E800421  bctrl
	ctx.lr = 0x82EA4C5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4C5C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4C60: 409A1088  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4C64: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA4C68: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EA4C6C: 556B083D  rlwinm. r11, r11, 1, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA4C70: 4182010C  beq 0x82ea4d7c
	if ctx.cr[0].eq {
	pc = 0x82EA4D7C; continue 'dispatch;
	}
	// 82EA4C74: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
            }
            0x82EA4C78 => {
    //   block [0x82EA4C78..0x82EA4D7C)
	// 82EA4C78: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA4C7C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4C80: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4C84: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4C88: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4C8C: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82EA4C90: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EA4C94: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4C98: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4C9C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4CA0: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4CA4: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4CA8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4CAC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4CB0: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82EA4CB4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4CB8: 4E800421  bctrl
	ctx.lr = 0x82EA4CBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4CBC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4CC0: 409A1028  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4CC4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA4CC8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4CCC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4CD0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4CD4: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EA4CD8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4CDC: 386100EC  addi r3, r1, 0xec
	ctx.r[3].s64 = ctx.r[1].s64 + 236;
	// 82EA4CE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA4CE4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4CE8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4CEC: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4CF0: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4CF4: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4CF8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4CFC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4D00: 916100EC  stw r11, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82EA4D04: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4D08: 4E800421  bctrl
	ctx.lr = 0x82EA4D0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4D0C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4D10: 409A0FD8  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4D14: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA4D18: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4D1C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4D20: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4D24: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EA4D28: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4D2C: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 82EA4D30: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA4D34: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4D38: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4D3C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4D40: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4D44: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4D48: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4D4C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4D50: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82EA4D54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4D58: 4E800421  bctrl
	ctx.lr = 0x82EA4D5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4D5C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4D60: 409A0F88  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4D64: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA4D68: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EA4D6C: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 82EA4D70: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA4D74: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA4D78: 4198FF00  blt cr6, 0x82ea4c78
	if ctx.cr[6].lt {
	pc = 0x82EA4C78; continue 'dispatch;
	}
            }
            0x82EA4D7C => {
    //   block [0x82EA4D7C..0x82EA4DD8)
	// 82EA4D7C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA4D80: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4D84: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4D88: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4D8C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4D90: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4D94: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4D98: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4D9C: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4DA0: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4DA4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4DA8: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4DAC: 3861012C  addi r3, r1, 0x12c
	ctx.r[3].s64 = ctx.r[1].s64 + 300;
	// 82EA4DB0: 9161012C  stw r11, 0x12c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 82EA4DB4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4DB8: 4E800421  bctrl
	ctx.lr = 0x82EA4DBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4DBC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4DC0: 409A0F28  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4DC4: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA4DC8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EA4DCC: 556B083D  rlwinm. r11, r11, 1, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA4DD0: 4182010C  beq 0x82ea4edc
	if ctx.cr[0].eq {
	pc = 0x82EA4EDC; continue 'dispatch;
	}
	// 82EA4DD4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
            }
            0x82EA4DD8 => {
    //   block [0x82EA4DD8..0x82EA4EDC)
	// 82EA4DD8: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA4DDC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4DE0: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4DE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4DE8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4DEC: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EA4DF0: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA4DF4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4DF8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4DFC: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4E00: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4E04: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4E08: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4E0C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4E10: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EA4E14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4E18: 4E800421  bctrl
	ctx.lr = 0x82EA4E1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4E1C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4E20: 409A0EC8  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4E24: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA4E28: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4E2C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4E30: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4E34: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82EA4E38: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4E3C: 386100F4  addi r3, r1, 0xf4
	ctx.r[3].s64 = ctx.r[1].s64 + 244;
	// 82EA4E40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA4E44: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4E48: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4E4C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4E50: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4E54: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4E58: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4E5C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4E60: 916100F4  stw r11, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82EA4E64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4E68: 4E800421  bctrl
	ctx.lr = 0x82EA4E6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4E6C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4E70: 409A0E78  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4E74: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA4E78: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4E7C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4E80: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4E84: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82EA4E88: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4E8C: 386100AC  addi r3, r1, 0xac
	ctx.r[3].s64 = ctx.r[1].s64 + 172;
	// 82EA4E90: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA4E94: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4E98: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4E9C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4EA0: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4EA4: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4EA8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4EAC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4EB0: 916100AC  stw r11, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82EA4EB4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4EB8: 4E800421  bctrl
	ctx.lr = 0x82EA4EBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4EBC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4EC0: 409A0E28  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4EC4: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA4EC8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EA4ECC: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 82EA4ED0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA4ED4: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA4ED8: 4198FF00  blt cr6, 0x82ea4dd8
	if ctx.cr[6].lt {
	pc = 0x82EA4DD8; continue 'dispatch;
	}
            }
            0x82EA4EDC => {
    //   block [0x82EA4EDC..0x82EA4F3C)
	// 82EA4EDC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EA4EE0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4EE4: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4EE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4EEC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4EF0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4EF4: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4EF8: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4EFC: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4F00: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4F04: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4F08: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4F0C: 3861011C  addi r3, r1, 0x11c
	ctx.r[3].s64 = ctx.r[1].s64 + 284;
	// 82EA4F10: 9161011C  stw r11, 0x11c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 82EA4F14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4F18: 4E800421  bctrl
	ctx.lr = 0x82EA4F1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4F1C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4F20: 409A0DC8  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4F24: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EA4F28: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EA4F2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA4F30: 4099042C  ble cr6, 0x82ea535c
	if !ctx.cr[6].gt {
	pc = 0x82EA535C; continue 'dispatch;
	}
	// 82EA4F34: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EA4F38: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
            }
            0x82EA4F3C => {
    //   block [0x82EA4F3C..0x82EA535C)
	// 82EA4F3C: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA4F40: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4F44: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4F48: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4F4C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4F50: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 82EA4F54: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EA4F58: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4F5C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4F60: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4F64: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4F68: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4F6C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4F70: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4F74: 916100B4  stw r11, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82EA4F78: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4F7C: 4E800421  bctrl
	ctx.lr = 0x82EA4F80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4F80: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4F84: 409A0D64  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4F88: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA4F8C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4F90: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4F94: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4F98: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EA4F9C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4FA0: 386100FC  addi r3, r1, 0xfc
	ctx.r[3].s64 = ctx.r[1].s64 + 252;
	// 82EA4FA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA4FA8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4FAC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA4FB0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA4FB4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA4FB8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA4FBC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA4FC0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA4FC4: 916100FC  stw r11, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82EA4FC8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA4FCC: 4E800421  bctrl
	ctx.lr = 0x82EA4FD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA4FD0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA4FD4: 409A0D14  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA4FD8: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA4FDC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA4FE0: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA4FE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA4FE8: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EA4FEC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA4FF0: 386100BC  addi r3, r1, 0xbc
	ctx.r[3].s64 = ctx.r[1].s64 + 188;
	// 82EA4FF4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA4FF8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA4FFC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5000: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5004: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5008: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA500C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5010: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5014: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82EA5018: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA501C: 4E800421  bctrl
	ctx.lr = 0x82EA5020;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5020: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5024: 409A0CC4  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5028: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA502C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5030: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5034: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5038: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EA503C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5040: 3861013C  addi r3, r1, 0x13c
	ctx.r[3].s64 = ctx.r[1].s64 + 316;
	// 82EA5044: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA5048: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA504C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5050: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5054: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5058: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA505C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5060: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5064: 9161013C  stw r11, 0x13c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 82EA5068: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA506C: 4E800421  bctrl
	ctx.lr = 0x82EA5070;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5070: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5074: 409A0C74  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5078: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA507C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5080: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5084: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5088: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EA508C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5090: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 82EA5094: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA5098: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA509C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA50A0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA50A4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA50A8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA50AC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA50B0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA50B4: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82EA50B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA50BC: 4E800421  bctrl
	ctx.lr = 0x82EA50C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA50C0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA50C4: 409A0C24  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA50C8: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA50CC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA50D0: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA50D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA50D8: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EA50DC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA50E0: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 82EA50E4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA50E8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA50EC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA50F0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA50F4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA50F8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA50FC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5100: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5104: 91610104  stw r11, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82EA5108: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA510C: 4E800421  bctrl
	ctx.lr = 0x82EA5110;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5110: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5114: 409A0BD4  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5118: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA511C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5120: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5124: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5128: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA512C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EA5130: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EA5134: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5138: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA513C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5140: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5144: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5148: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA514C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5150: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EA5154: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5158: 4E800421  bctrl
	ctx.lr = 0x82EA515C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA515C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5160: 409A0B88  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5164: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA5168: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA516C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5170: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5174: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EA5178: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA517C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EA5180: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA5184: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5188: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA518C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5190: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5194: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5198: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA519C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA51A0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EA51A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA51A8: 4E800421  bctrl
	ctx.lr = 0x82EA51AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA51AC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA51B0: 409A0B38  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA51B4: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA51B8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA51BC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA51C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA51C4: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EA51C8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA51CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EA51D0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA51D4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA51D8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA51DC: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA51E0: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA51E4: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA51E8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA51EC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA51F0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EA51F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA51F8: 4E800421  bctrl
	ctx.lr = 0x82EA51FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA51FC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5200: 409A0AE8  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5204: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA5208: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA520C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5210: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5214: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EA5218: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA521C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EA5220: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA5224: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5228: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA522C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5230: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5234: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5238: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA523C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5240: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EA5244: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5248: 4E800421  bctrl
	ctx.lr = 0x82EA524C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA524C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5250: 409A0A98  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5254: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA5258: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA525C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5260: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5264: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EA5268: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA526C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EA5270: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA5274: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5278: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA527C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5280: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5284: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5288: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA528C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5290: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EA5294: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5298: 4E800421  bctrl
	ctx.lr = 0x82EA529C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA529C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA52A0: 409A0A48  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA52A4: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA52A8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA52AC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA52B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA52B4: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EA52B8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA52BC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EA52C0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA52C4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA52C8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA52CC: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA52D0: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA52D4: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA52D8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA52DC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA52E0: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EA52E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA52E8: 4E800421  bctrl
	ctx.lr = 0x82EA52EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA52EC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA52F0: 409A09F8  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA52F4: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA52F8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA52FC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5300: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5304: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EA5308: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA530C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EA5310: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA5314: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5318: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA531C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5320: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5324: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5328: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA532C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5330: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EA5334: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5338: 4E800421  bctrl
	ctx.lr = 0x82EA533C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA533C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5340: 409A09A8  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5344: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EA5348: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EA534C: 3B7B0018  addi r27, r27, 0x18
	ctx.r[27].s64 = ctx.r[27].s64 + 24;
	// 82EA5350: 3B9C001C  addi r28, r28, 0x1c
	ctx.r[28].s64 = ctx.r[28].s64 + 28;
	// 82EA5354: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA5358: 4198FBE4  blt cr6, 0x82ea4f3c
	if ctx.cr[6].lt {
	pc = 0x82EA4F3C; continue 'dispatch;
	}
            }
            0x82EA535C => {
    //   block [0x82EA535C..0x82EA53B8)
	// 82EA535C: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA5360: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5364: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5368: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA536C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5370: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5374: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5378: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA537C: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5380: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5384: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5388: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA538C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82EA5390: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EA5394: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5398: 4E800421  bctrl
	ctx.lr = 0x82EA539C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA539C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA53A0: 409A0948  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA53A4: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA53A8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EA53AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA53B0: 40990190  ble cr6, 0x82ea5540
	if !ctx.cr[6].gt {
	pc = 0x82EA5540; continue 'dispatch;
	}
	// 82EA53B4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
            }
            0x82EA53B8 => {
    //   block [0x82EA53B8..0x82EA541C)
	// 82EA53B8: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EA53BC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA53C0: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA53C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA53C8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA53CC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82EA53D0: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA53D4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA53D8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA53DC: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA53E0: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA53E4: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA53E8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA53EC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA53F0: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EA53F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA53F8: 4E800421  bctrl
	ctx.lr = 0x82EA53FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA53FC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5400: 409A08E8  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5404: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EA5408: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EA540C: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA5410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA5414: 40990118  ble cr6, 0x82ea552c
	if !ctx.cr[6].gt {
	pc = 0x82EA552C; continue 'dispatch;
	}
	// 82EA5418: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
            }
            0x82EA541C => {
    //   block [0x82EA541C..0x82EA552C)
	// 82EA541C: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA5420: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5424: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5428: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA542C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5430: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82EA5434: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EA5438: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EA543C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5440: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5444: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5448: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA544C: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5450: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5454: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5458: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82EA545C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5460: 4E800421  bctrl
	ctx.lr = 0x82EA5464;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5464: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5468: 409A0880  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA546C: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA5470: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5474: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5478: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA547C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5480: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82EA5484: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EA5488: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EA548C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA5490: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5494: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5498: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA549C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA54A0: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA54A4: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA54A8: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA54AC: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EA54B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA54B4: 4E800421  bctrl
	ctx.lr = 0x82EA54B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA54B8: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA54BC: 409A082C  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA54C0: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA54C4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA54C8: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA54CC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA54D0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA54D4: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EA54D8: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EA54DC: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EA54E0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA54E4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA54E8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA54EC: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA54F0: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA54F4: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA54F8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA54FC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5500: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82EA5504: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5508: 4E800421  bctrl
	ctx.lr = 0x82EA550C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA550C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5510: 409A07D8  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5514: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EA5518: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EA551C: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 82EA5520: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA5524: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA5528: 4198FEF4  blt cr6, 0x82ea541c
	if ctx.cr[6].lt {
	pc = 0x82EA541C; continue 'dispatch;
	}
            }
            0x82EA552C => {
    //   block [0x82EA552C..0x82EA5540)
	// 82EA552C: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA5530: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82EA5534: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EA5538: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA553C: 4198FE7C  blt cr6, 0x82ea53b8
	if ctx.cr[6].lt {
	pc = 0x82EA53B8; continue 'dispatch;
	}
	pc = 0x82EA5540; continue 'dispatch;
            }
            0x82EA5540 => {
    //   block [0x82EA5540..0x82EA559C)
	// 82EA5540: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA5544: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5548: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA554C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5550: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5554: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5558: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA555C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5560: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5564: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5568: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA556C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5570: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82EA5574: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EA5578: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA557C: 4E800421  bctrl
	ctx.lr = 0x82EA5580;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5580: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5584: 409A0764  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5588: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA558C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EA5590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA5594: 40990190  ble cr6, 0x82ea5724
	if !ctx.cr[6].gt {
	pc = 0x82EA5724; continue 'dispatch;
	}
	// 82EA5598: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
            }
            0x82EA559C => {
    //   block [0x82EA559C..0x82EA5600)
	// 82EA559C: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA55A0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA55A4: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA55A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA55AC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA55B0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82EA55B4: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA55B8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA55BC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA55C0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA55C4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA55C8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA55CC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA55D0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA55D4: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82EA55D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA55DC: 4E800421  bctrl
	ctx.lr = 0x82EA55E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA55E0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA55E4: 409A0704  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA55E8: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA55EC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EA55F0: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA55F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA55F8: 40990118  ble cr6, 0x82ea5710
	if !ctx.cr[6].gt {
	pc = 0x82EA5710; continue 'dispatch;
	}
	// 82EA55FC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
            }
            0x82EA5600 => {
    //   block [0x82EA5600..0x82EA5710)
	// 82EA5600: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA5604: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5608: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA560C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5610: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5614: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82EA5618: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA561C: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EA5620: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5624: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5628: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA562C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5630: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5634: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5638: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA563C: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EA5640: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5644: 4E800421  bctrl
	ctx.lr = 0x82EA5648;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5648: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA564C: 409A069C  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5650: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA5654: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5658: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA565C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5660: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5664: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82EA5668: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA566C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EA5670: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA5674: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5678: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA567C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5680: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5684: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5688: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA568C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5690: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82EA5694: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5698: 4E800421  bctrl
	ctx.lr = 0x82EA569C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA569C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA56A0: 409A0648  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA56A4: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA56A8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA56AC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA56B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA56B4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA56B8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82EA56BC: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA56C0: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EA56C4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA56C8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA56CC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA56D0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA56D4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA56D8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA56DC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA56E0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA56E4: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82EA56E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA56EC: 4E800421  bctrl
	ctx.lr = 0x82EA56F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA56F0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA56F4: 409A05F4  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA56F8: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA56FC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EA5700: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 82EA5704: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA5708: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA570C: 4198FEF4  blt cr6, 0x82ea5600
	if ctx.cr[6].lt {
	pc = 0x82EA5600; continue 'dispatch;
	}
            }
            0x82EA5710 => {
    //   block [0x82EA5710..0x82EA5724)
	// 82EA5710: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA5714: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82EA5718: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EA571C: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA5720: 4198FE7C  blt cr6, 0x82ea559c
	if ctx.cr[6].lt {
	pc = 0x82EA559C; continue 'dispatch;
	}
	pc = 0x82EA5724; continue 'dispatch;
            }
            0x82EA5724 => {
    //   block [0x82EA5724..0x82EA5784)
	// 82EA5724: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA5728: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA572C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5730: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5734: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5738: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA573C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5740: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5744: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5748: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA574C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5750: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5754: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82EA5758: 916100D8  stw r11, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 82EA575C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5760: 4E800421  bctrl
	ctx.lr = 0x82EA5764;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5764: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5768: 409A0580  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA576C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA5770: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EA5774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA5778: 40990284  ble cr6, 0x82ea59fc
	if !ctx.cr[6].gt {
	pc = 0x82EA59FC; continue 'dispatch;
	}
	// 82EA577C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EA5780: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
            }
            0x82EA5784 => {
    //   block [0x82EA5784..0x82EA58D4)
	// 82EA5784: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA5788: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA578C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5790: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5794: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5798: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82EA579C: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA57A0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA57A4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA57A8: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA57AC: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA57B0: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA57B4: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA57B8: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA57BC: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 82EA57C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA57C4: 4E800421  bctrl
	ctx.lr = 0x82EA57C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA57C8: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA57CC: 409A051C  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA57D0: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA57D4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA57D8: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA57DC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA57E0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA57E4: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82EA57E8: 7D79582E  lwzx r11, r25, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA57EC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA57F0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA57F4: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA57F8: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA57FC: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5800: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5804: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5808: 916100E8  stw r11, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82EA580C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5810: 4E800421  bctrl
	ctx.lr = 0x82EA5814;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5814: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5818: 409A04D0  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA581C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5820: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5824: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5828: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA582C: 7D795A14  add r11, r25, r11
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 82EA5830: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5834: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82EA5838: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA583C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5840: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5844: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5848: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA584C: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5850: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5854: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5858: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82EA585C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5860: 4E800421  bctrl
	ctx.lr = 0x82EA5864;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5864: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5868: 409A0480  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA586C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5870: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5874: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5878: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA587C: 7D795A14  add r11, r25, r11
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 82EA5880: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5884: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82EA5888: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA588C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5890: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5894: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5898: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA589C: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA58A0: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA58A4: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA58A8: 916100F8  stw r11, 0xf8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82EA58AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA58B0: 4E800421  bctrl
	ctx.lr = 0x82EA58B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA58B4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA58B8: 409A0430  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA58BC: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA58C0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EA58C4: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA58C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA58CC: 40990118  ble cr6, 0x82ea59e4
	if !ctx.cr[6].gt {
	pc = 0x82EA59E4; continue 'dispatch;
	}
	// 82EA58D0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
            }
            0x82EA58D4 => {
    //   block [0x82EA58D4..0x82EA59E4)
	// 82EA58D4: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA58D8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA58DC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA58E0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA58E4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA58E8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82EA58EC: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA58F0: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EA58F4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA58F8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA58FC: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5900: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5904: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5908: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA590C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5910: 91610100  stw r11, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82EA5914: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5918: 4E800421  bctrl
	ctx.lr = 0x82EA591C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA591C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5920: 409A03C8  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5924: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA5928: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA592C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5930: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5934: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5938: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82EA593C: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA5940: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EA5944: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA5948: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA594C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5950: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5954: 5168843E  rlwimi r8, r11, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5958: 552B401E  rlwinm r11, r9, 8, 0, 0xf
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA595C: 5509C43E  rlwinm r9, r8, 0x18, 0x10, 0x1f
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA5960: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5964: 91610108  stw r11, 0x108(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82EA5968: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA596C: 4E800421  bctrl
	ctx.lr = 0x82EA5970;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5970: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5974: 409A0374  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5978: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA597C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5980: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5984: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5988: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA598C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82EA5990: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA5994: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EA5998: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA599C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA59A0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA59A4: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA59A8: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA59AC: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA59B0: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA59B4: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA59B8: 91610110  stw r11, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EA59BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA59C0: 4E800421  bctrl
	ctx.lr = 0x82EA59C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA59C4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA59C8: 409A0320  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA59CC: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA59D0: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EA59D4: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 82EA59D8: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA59DC: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA59E0: 4198FEF4  blt cr6, 0x82ea58d4
	if ctx.cr[6].lt {
	pc = 0x82EA58D4; continue 'dispatch;
	}
            }
            0x82EA59E4 => {
    //   block [0x82EA59E4..0x82EA59FC)
	// 82EA59E4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA59E8: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82EA59EC: 3B39000C  addi r25, r25, 0xc
	ctx.r[25].s64 = ctx.r[25].s64 + 12;
	// 82EA59F0: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EA59F4: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA59F8: 4198FD8C  blt cr6, 0x82ea5784
	if ctx.cr[6].lt {
	pc = 0x82EA5784; continue 'dispatch;
	}
	pc = 0x82EA59FC; continue 'dispatch;
            }
            0x82EA59FC => {
    //   block [0x82EA59FC..0x82EA5A18)
	// 82EA59FC: 8173002C  lwz r11, 0x2c(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA5A00: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 82EA5A04: 3AB50064  addi r21, r21, 0x64
	ctx.r[21].s64 = ctx.r[21].s64 + 100;
	// 82EA5A08: 7D6BB02E  lwzx r11, r11, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82EA5A0C: 7D6BB82E  lwzx r11, r11, r23
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82EA5A10: 7F145840  cmplw cr6, r20, r11
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA5A14: 4198F168  blt cr6, 0x82ea4b7c
	if ctx.cr[6].lt {
	pc = 0x82EA4B7C; continue 'dispatch;
	}
	pc = 0x82EA5A18; continue 'dispatch;
            }
            0x82EA5A18 => {
    //   block [0x82EA5A18..0x82EA5A2C)
	// 82EA5A18: 81730024  lwz r11, 0x24(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA5A1C: 3A520001  addi r18, r18, 1
	ctx.r[18].s64 = ctx.r[18].s64 + 1;
	// 82EA5A20: 3AF70004  addi r23, r23, 4
	ctx.r[23].s64 = ctx.r[23].s64 + 4;
	// 82EA5A24: 7F125840  cmplw cr6, r18, r11
	ctx.cr[6].compare_u32(ctx.r[18].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA5A28: 4198F0E8  blt cr6, 0x82ea4b10
	if ctx.cr[6].lt {
	pc = 0x82EA4B10; continue 'dispatch;
	}
	pc = 0x82EA5A2C; continue 'dispatch;
            }
            0x82EA5A2C => {
    //   block [0x82EA5A2C..0x82EA5A3C)
	// 82EA5A2C: 81730020  lwz r11, 0x20(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA5A30: 3A310001  addi r17, r17, 1
	ctx.r[17].s64 = ctx.r[17].s64 + 1;
	// 82EA5A34: 7F115840  cmplw cr6, r17, r11
	ctx.cr[6].compare_u32(ctx.r[17].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA5A38: 4198F0C0  blt cr6, 0x82ea4af8
	if ctx.cr[6].lt {
	pc = 0x82EA4AF8; continue 'dispatch;
	}
	pc = 0x82EA5A3C; continue 'dispatch;
            }
            0x82EA5A3C => {
    //   block [0x82EA5A3C..0x82EA5A4C)
	// 82EA5A3C: 81730020  lwz r11, 0x20(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA5A40: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 82EA5A44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA5A48: 40990298  ble cr6, 0x82ea5ce0
	if !ctx.cr[6].gt {
	pc = 0x82EA5CE0; continue 'dispatch;
	}
	pc = 0x82EA5A4C; continue 'dispatch;
            }
            0x82EA5A4C => {
    //   block [0x82EA5A4C..0x82EA5A64)
	// 82EA5A4C: 81730024  lwz r11, 0x24(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA5A50: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 82EA5A54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA5A58: 40990278  ble cr6, 0x82ea5cd0
	if !ctx.cr[6].gt {
	pc = 0x82EA5CD0; continue 'dispatch;
	}
	// 82EA5A5C: 5697103A  slwi r23, r20, 2
	ctx.r[23].u32 = ctx.r[20].u32.wrapping_shl(2);
	ctx.r[23].u64 = ctx.r[23].u32 as u64;
	// 82EA5A60: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	pc = 0x82EA5A64; continue 'dispatch;
            }
            0x82EA5A64 => {
    //   block [0x82EA5A64..0x82EA5A80)
	// 82EA5A64: 8173002C  lwz r11, 0x2c(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA5A68: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82EA5A6C: 7D6BB82E  lwzx r11, r11, r23
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82EA5A70: 7D6BC82E  lwzx r11, r11, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 82EA5A74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA5A78: 40990244  ble cr6, 0x82ea5cbc
	if !ctx.cr[6].gt {
	pc = 0x82EA5CBC; continue 'dispatch;
	}
	// 82EA5A7C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	pc = 0x82EA5A80; continue 'dispatch;
            }
            0x82EA5A80 => {
    //   block [0x82EA5A80..0x82EA5AA4)
	// 82EA5A80: 81730028  lwz r11, 0x28(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA5A84: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EA5A88: 7D6BB82E  lwzx r11, r11, r23
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82EA5A8C: 7D6BC82E  lwzx r11, r11, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 82EA5A90: 7F8BC214  add r28, r11, r24
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82EA5A94: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA5A98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA5A9C: 409900FC  ble cr6, 0x82ea5b98
	if !ctx.cr[6].gt {
	pc = 0x82EA5B98; continue 'dispatch;
	}
	// 82EA5AA0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x82EA5AA4; continue 'dispatch;
            }
            0x82EA5AA4 => {
    //   block [0x82EA5AA4..0x82EA5B98)
	// 82EA5AA4: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA5AA8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5AAC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5AB0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5AB4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5AB8: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82EA5ABC: 7FEBD82E  lwzx r31, r11, r27
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EA5AC0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA5AC4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5AC8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5ACC: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5AD0: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5AD4: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5AD8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5ADC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5AE0: 91610118  stw r11, 0x118(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 82EA5AE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5AE8: 4E800421  bctrl
	ctx.lr = 0x82EA5AEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5AEC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5AF0: 409A01F8  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5AF4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA5AF8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5AFC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5B00: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5B04: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5B08: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5B0C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5B10: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5B14: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5B18: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5B1C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5B20: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5B24: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82EA5B28: 91610120  stw r11, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 82EA5B2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5B30: 4E800421  bctrl
	ctx.lr = 0x82EA5B34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5B34: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5B38: 409A01B0  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5B3C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA5B40: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5B44: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5B48: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5B4C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5B50: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5B54: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5B58: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5B5C: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5B60: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5B64: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5B68: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5B6C: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82EA5B70: 91610128  stw r11, 0x128(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 82EA5B74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5B78: 4E800421  bctrl
	ctx.lr = 0x82EA5B7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5B7C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5B80: 409A0168  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5B84: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA5B88: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EA5B8C: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EA5B90: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA5B94: 4198FF10  blt cr6, 0x82ea5aa4
	if ctx.cr[6].lt {
	pc = 0x82EA5AA4; continue 'dispatch;
	}
            }
            0x82EA5B98 => {
    //   block [0x82EA5B98..0x82EA5BAC)
	// 82EA5B98: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA5B9C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EA5BA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA5BA4: 409900FC  ble cr6, 0x82ea5ca0
	if !ctx.cr[6].gt {
	pc = 0x82EA5CA0; continue 'dispatch;
	}
	// 82EA5BA8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x82EA5BAC; continue 'dispatch;
            }
            0x82EA5BAC => {
    //   block [0x82EA5BAC..0x82EA5CA0)
	// 82EA5BAC: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA5BB0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5BB4: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5BB8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5BBC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5BC0: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82EA5BC4: 7FEBD82E  lwzx r31, r11, r27
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EA5BC8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA5BCC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5BD0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5BD4: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5BD8: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5BDC: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5BE0: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5BE4: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5BE8: 91610130  stw r11, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 82EA5BEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5BF0: 4E800421  bctrl
	ctx.lr = 0x82EA5BF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5BF4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5BF8: 409A00F0  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5BFC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA5C00: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5C04: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5C08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5C0C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5C10: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5C14: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5C18: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5C1C: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5C20: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5C24: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5C28: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5C2C: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 82EA5C30: 91610138  stw r11, 0x138(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 82EA5C34: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5C38: 4E800421  bctrl
	ctx.lr = 0x82EA5C3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5C3C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5C40: 409A00A8  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5C44: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA5C48: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EA5C4C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA5C50: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EA5C54: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5C58: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5C5C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA5C60: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA5C64: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA5C68: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA5C6C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EA5C70: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA5C74: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82EA5C78: 91610140  stw r11, 0x140(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82EA5C7C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA5C80: 4E800421  bctrl
	ctx.lr = 0x82EA5C84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5C84: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EA5C88: 409A0060  bne cr6, 0x82ea5ce8
	if !ctx.cr[6].eq {
	pc = 0x82EA5CE8; continue 'dispatch;
	}
	// 82EA5C8C: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA5C90: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EA5C94: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EA5C98: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA5C9C: 4198FF10  blt cr6, 0x82ea5bac
	if ctx.cr[6].lt {
	pc = 0x82EA5BAC; continue 'dispatch;
	}
            }
            0x82EA5CA0 => {
    //   block [0x82EA5CA0..0x82EA5CBC)
	// 82EA5CA0: 8173002C  lwz r11, 0x2c(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA5CA4: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 82EA5CA8: 3B180064  addi r24, r24, 0x64
	ctx.r[24].s64 = ctx.r[24].s64 + 100;
	// 82EA5CAC: 7D6BB82E  lwzx r11, r11, r23
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82EA5CB0: 7D6BC82E  lwzx r11, r11, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 82EA5CB4: 7F165840  cmplw cr6, r22, r11
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA5CB8: 4198FDC8  blt cr6, 0x82ea5a80
	if ctx.cr[6].lt {
	pc = 0x82EA5A80; continue 'dispatch;
	}
	pc = 0x82EA5CBC; continue 'dispatch;
            }
            0x82EA5CBC => {
    //   block [0x82EA5CBC..0x82EA5CD0)
	// 82EA5CBC: 81730024  lwz r11, 0x24(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA5CC0: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 82EA5CC4: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 82EA5CC8: 7F155840  cmplw cr6, r21, r11
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA5CCC: 4198FD98  blt cr6, 0x82ea5a64
	if ctx.cr[6].lt {
	pc = 0x82EA5A64; continue 'dispatch;
	}
	pc = 0x82EA5CD0; continue 'dispatch;
            }
            0x82EA5CD0 => {
    //   block [0x82EA5CD0..0x82EA5CE0)
	// 82EA5CD0: 81730020  lwz r11, 0x20(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA5CD4: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 82EA5CD8: 7F145840  cmplw cr6, r20, r11
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA5CDC: 4198FD70  blt cr6, 0x82ea5a4c
	if ctx.cr[6].lt {
	pc = 0x82EA5A4C; continue 'dispatch;
	}
	pc = 0x82EA5CE0; continue 'dispatch;
            }
            0x82EA5CE0 => {
    //   block [0x82EA5CE0..0x82EA5CE8)
	// 82EA5CE0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA5CE4: 48000008  b 0x82ea5cec
	pc = 0x82EA5CEC; continue 'dispatch;
            }
            0x82EA5CE8 => {
    //   block [0x82EA5CE8..0x82EA5CEC)
	// 82EA5CE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EA5CEC; continue 'dispatch;
            }
            0x82EA5CEC => {
    //   block [0x82EA5CEC..0x82EA5CF4)
	// 82EA5CEC: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82EA5CF0: 4BE0373C  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA5CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EA5CF8 size=316
    let mut pc: u32 = 0x82EA5CF8;
    'dispatch: loop {
        match pc {
            0x82EA5CF8 => {
    //   block [0x82EA5CF8..0x82EA5D54)
	// 82EA5CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA5CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA5D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EA5D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA5D08: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82EA5D0C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA5D10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA5D14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA5D18: 394BA268  addi r10, r11, -0x5d98
	ctx.r[10].s64 = ctx.r[11].s64 + -23960;
	// 82EA5D1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA5D20: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EA5D24: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA5D28: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EA5D2C: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA5D30: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EA5D34: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EA5D38: C1890C14  lfs f12, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA5D3C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EA5D40: 814A0718  lwz r10, 0x718(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA5D44: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA5D48: 4182000C  beq 0x82ea5d54
	if ctx.cr[0].eq {
	pc = 0x82EA5D54; continue 'dispatch;
	}
	// 82EA5D4C: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA5D50: 48000008  b 0x82ea5d58
	pc = 0x82EA5D58; continue 'dispatch;
            }
            0x82EA5D54 => {
    //   block [0x82EA5D54..0x82EA5D58)
	// 82EA5D54: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82EA5D58; continue 'dispatch;
            }
            0x82EA5D58 => {
    //   block [0x82EA5D58..0x82EA5E0C)
	// 82EA5D58: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EA5D5C: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EA5D60: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EA5D64: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EA5D68: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82EA5D6C: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EA5D70: 395F0040  addi r10, r31, 0x40
	ctx.r[10].s64 = ctx.r[31].s64 + 64;
	// 82EA5D74: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EA5D78: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EA5D7C: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EA5D80: C3E80C18  lfs f31, 0xc18(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EA5D84: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82EA5D88: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5D8C: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EA5D90: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EA5D94: D3FF0030  stfs f31, 0x30(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EA5D98: D3FF0034  stfs f31, 0x34(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EA5D9C: 90FF0024  stw r7, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[7].u32 ) };
	// 82EA5DA0: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82EA5DA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA5DA8: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82EA5DAC: 993F0038  stb r9, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u8 ) };
	// 82EA5DB0: 3BCBA254  addi r30, r11, -0x5dac
	ctx.r[30].s64 = ctx.r[11].s64 + -23980;
	// 82EA5DB4: 913F003C  stw r9, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 82EA5DB8: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EA5DBC: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82EA5DC0: 90AA0008  stw r5, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82EA5DC4: 908A000C  stw r4, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82EA5DC8: D18A0010  stfs f12, 0x10(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EA5DCC: D3EA0014  stfs f31, 0x14(r10)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EA5DD0: D3EA0018  stfs f31, 0x18(r10)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EA5DD4: 913F005C  stw r9, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82EA5DD8: 993F0060  stb r9, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[9].u8 ) };
	// 82EA5DDC: 913F0064  stw r9, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82EA5DE0: 4B3BABD9  bl 0x822609b8
	ctx.lr = 0x82EA5DE4;
	sub_822609B8(ctx, base);
	// 82EA5DE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA5DE8: 4BFDB451  bl 0x82e81238
	ctx.lr = 0x82EA5DEC;
	sub_82E81238(ctx, base);
	// 82EA5DEC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EA5DF0: 4180001C  blt 0x82ea5e0c
	if ctx.cr[0].lt {
	pc = 0x82EA5E0C; continue 'dispatch;
	}
	// 82EA5DF4: 4B3BABC5  bl 0x822609b8
	ctx.lr = 0x82EA5DF8;
	sub_822609B8(ctx, base);
	// 82EA5DF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA5DFC: 4BFDB535  bl 0x82e81330
	ctx.lr = 0x82EA5E00;
	sub_82E81330(ctx, base);
	// 82EA5E00: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA5E04: D02B794C  stfs f1, 0x794c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(31052 as u32), tmp.u32 ) };
	// 82EA5E08: 4800000C  b 0x82ea5e14
	pc = 0x82EA5E14; continue 'dispatch;
            }
            0x82EA5E0C => {
    //   block [0x82EA5E0C..0x82EA5E14)
	// 82EA5E0C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EA5E10: D3EB794C  stfs f31, 0x794c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(31052 as u32), tmp.u32 ) };
	pc = 0x82EA5E14; continue 'dispatch;
            }
            0x82EA5E14 => {
    //   block [0x82EA5E14..0x82EA5E34)
	// 82EA5E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA5E18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA5E1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA5E20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA5E24: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82EA5E28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EA5E2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA5E30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA5E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EA5E38 size=392
    let mut pc: u32 = 0x82EA5E38;
    'dispatch: loop {
        match pc {
            0x82EA5E38 => {
    //   block [0x82EA5E38..0x82EA5E60)
	// 82EA5E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA5E3C: 4BE035C1  bl 0x82ca93fc
	ctx.lr = 0x82EA5E40;
	sub_82CA93D0(ctx, base);
	// 82EA5E40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA5E44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA5E48: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EA5E4C: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA5E50: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA5E54: 409A000C  bne cr6, 0x82ea5e60
	if !ctx.cr[6].eq {
	pc = 0x82EA5E60; continue 'dispatch;
	}
	// 82EA5E58: 935F0028  stw r26, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[26].u32 ) };
	// 82EA5E5C: 935F002C  stw r26, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[26].u32 ) };
	pc = 0x82EA5E60; continue 'dispatch;
            }
            0x82EA5E60 => {
    //   block [0x82EA5E60..0x82EA5E84)
	// 82EA5E60: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA5E64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA5E68: 419A010C  beq cr6, 0x82ea5f74
	if ctx.cr[6].eq {
	pc = 0x82EA5F74; continue 'dispatch;
	}
	// 82EA5E6C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA5E70: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	// 82EA5E74: 3F608330  lis r27, -0x7cd0
	ctx.r[27].s64 = -2094006272;
	// 82EA5E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA5E7C: 409900D0  ble cr6, 0x82ea5f4c
	if !ctx.cr[6].gt {
	pc = 0x82EA5F4C; continue 'dispatch;
	}
	// 82EA5E80: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	pc = 0x82EA5E84; continue 'dispatch;
            }
            0x82EA5E84 => {
    //   block [0x82EA5E84..0x82EA5E98)
	// 82EA5E84: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA5E88: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 82EA5E8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA5E90: 40990080  ble cr6, 0x82ea5f10
	if !ctx.cr[6].gt {
	pc = 0x82EA5F10; continue 'dispatch;
	}
	// 82EA5E94: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x82EA5E98; continue 'dispatch;
            }
            0x82EA5E98 => {
    //   block [0x82EA5E98..0x82EA5EF8)
	// 82EA5E98: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA5E9C: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EA5EA0: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA5EA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA5EA8: 40990054  ble cr6, 0x82ea5efc
	if !ctx.cr[6].gt {
	pc = 0x82EA5EFC; continue 'dispatch;
	}
	// 82EA5EAC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA5EB0: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA5EB4: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA5EB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA5EBC: 419A0040  beq cr6, 0x82ea5efc
	if ctx.cr[6].eq {
	pc = 0x82EA5EFC; continue 'dispatch;
	}
	// 82EA5EC0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA5EC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA5EC8: 41820034  beq 0x82ea5efc
	if ctx.cr[0].eq {
	pc = 0x82EA5EFC; continue 'dispatch;
	}
	// 82EA5ECC: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EA5ED0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82EA5ED4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA5ED8: 419A0020  beq cr6, 0x82ea5ef8
	if ctx.cr[6].eq {
	pc = 0x82EA5EF8; continue 'dispatch;
	}
	// 82EA5EDC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA5EE0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA5EE4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82EA5EE8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA5EEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA5EF0: 4E800421  bctrl
	ctx.lr = 0x82EA5EF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5EF4: 48000008  b 0x82ea5efc
	pc = 0x82EA5EFC; continue 'dispatch;
            }
            0x82EA5EF8 => {
    //   block [0x82EA5EF8..0x82EA5EFC)
	// 82EA5EF8: 4B99F8B9  bl 0x828457b0
	ctx.lr = 0x82EA5EFC;
	sub_828457B0(ctx, base);
	pc = 0x82EA5EFC; continue 'dispatch;
            }
            0x82EA5EFC => {
    //   block [0x82EA5EFC..0x82EA5F10)
	// 82EA5EFC: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA5F00: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EA5F04: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EA5F08: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA5F0C: 4198FF8C  blt cr6, 0x82ea5e98
	if ctx.cr[6].lt {
	pc = 0x82EA5E98; continue 'dispatch;
	}
	pc = 0x82EA5F10; continue 'dispatch;
            }
            0x82EA5F10 => {
    //   block [0x82EA5F10..0x82EA5F4C)
	// 82EA5F10: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA5F14: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA5F18: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA5F1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA5F20: 4E800421  bctrl
	ctx.lr = 0x82EA5F24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5F24: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA5F28: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EA5F2C: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA5F30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA5F34: 4E800421  bctrl
	ctx.lr = 0x82EA5F38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5F38: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA5F3C: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82EA5F40: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EA5F44: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA5F48: 4198FF3C  blt cr6, 0x82ea5e84
	if ctx.cr[6].lt {
	pc = 0x82EA5E84; continue 'dispatch;
	}
            }
            0x82EA5F4C => {
    //   block [0x82EA5F4C..0x82EA5F74)
	// 82EA5F4C: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA5F50: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA5F54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA5F58: 4E800421  bctrl
	ctx.lr = 0x82EA5F5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5F5C: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA5F60: 817BDAB4  lwz r11, -0x254c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA5F64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA5F68: 4E800421  bctrl
	ctx.lr = 0x82EA5F6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA5F6C: 935F0028  stw r26, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[26].u32 ) };
	// 82EA5F70: 935F002C  stw r26, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[26].u32 ) };
            }
            0x82EA5F74 => {
    //   block [0x82EA5F74..0x82EA5FC0)
	// 82EA5F74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EA5F78: 9B5F0038  stb r26, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[26].u8 ) };
	// 82EA5F7C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EA5F80: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5F84: C00A0BEC  lfs f0, 0xbec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA5F88: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA5F8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA5F90: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EA5F94: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EA5F98: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EA5F9C: 913F0020  stw r9, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82EA5FA0: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EA5FA4: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EA5FA8: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82EA5FAC: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA5FB0: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EA5FB4: D1BF0034  stfs f13, 0x34(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EA5FB8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EA5FBC: 4BE03490  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA5FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EA5FC0 size=140
    let mut pc: u32 = 0x82EA5FC0;
    'dispatch: loop {
        match pc {
            0x82EA5FC0 => {
    //   block [0x82EA5FC0..0x82EA604C)
	// 82EA5FC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA5FC4: 394BA26C  addi r10, r11, -0x5d94
	ctx.r[10].s64 = ctx.r[11].s64 + -23956;
	// 82EA5FC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA5FCC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA5FD0: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA5FD4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EA5FD8: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EA5FDC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA5FE0: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EA5FE4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA5FE8: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82EA5FEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EA5FF0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EA5FF4: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EA5FF8: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82EA5FFC: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EA6000: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EA6004: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EA6008: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EA600C: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EA6010: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82EA6014: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82EA6018: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82EA601C: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82EA6020: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82EA6024: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EA6028: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EA602C: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82EA6030: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82EA6034: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EA6038: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EA603C: 91630058  stw r11, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EA6040: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EA6044: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EA6048: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA6050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA6050 size=600
    let mut pc: u32 = 0x82EA6050;
    'dispatch: loop {
        match pc {
            0x82EA6050 => {
    //   block [0x82EA6050..0x82EA6088)
	// 82EA6050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA6054: 4BE033B5  bl 0x82ca9408
	ctx.lr = 0x82EA6058;
	sub_82CA93D0(ctx, base);
	// 82EA6058: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA605C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA6060: 3F808330  lis r28, -0x7cd0
	ctx.r[28].s64 = -2094006272;
	// 82EA6064: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA6068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA606C: 419A002C  beq cr6, 0x82ea6098
	if ctx.cr[6].eq {
	pc = 0x82EA6098; continue 'dispatch;
	}
	// 82EA6070: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA6074: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA6078: 41820010  beq 0x82ea6088
	if ctx.cr[0].eq {
	pc = 0x82EA6088; continue 'dispatch;
	}
	// 82EA607C: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA6080: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA6084: 4E800421  bctrl
	ctx.lr = 0x82EA6088;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA6088 => {
    //   block [0x82EA6088..0x82EA6098)
	// 82EA6088: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA608C: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA6090: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA6094: 4E800421  bctrl
	ctx.lr = 0x82EA6098;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA6098 => {
    //   block [0x82EA6098..0x82EA60BC)
	// 82EA6098: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA609C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA60A0: 419A002C  beq cr6, 0x82ea60cc
	if ctx.cr[6].eq {
	pc = 0x82EA60CC; continue 'dispatch;
	}
	// 82EA60A4: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA60A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA60AC: 41820010  beq 0x82ea60bc
	if ctx.cr[0].eq {
	pc = 0x82EA60BC; continue 'dispatch;
	}
	// 82EA60B0: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA60B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA60B8: 4E800421  bctrl
	ctx.lr = 0x82EA60BC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA60BC => {
    //   block [0x82EA60BC..0x82EA60CC)
	// 82EA60BC: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA60C0: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA60C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA60C8: 4E800421  bctrl
	ctx.lr = 0x82EA60CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA60CC => {
    //   block [0x82EA60CC..0x82EA60F0)
	// 82EA60CC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EA60D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA60D4: 419A0034  beq cr6, 0x82ea6108
	if ctx.cr[6].eq {
	pc = 0x82EA6108; continue 'dispatch;
	}
	// 82EA60D8: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA60DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA60E0: 41820010  beq 0x82ea60f0
	if ctx.cr[0].eq {
	pc = 0x82EA60F0; continue 'dispatch;
	}
	// 82EA60E4: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA60E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA60EC: 4E800421  bctrl
	ctx.lr = 0x82EA60F0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA60F0 => {
    //   block [0x82EA60F0..0x82EA6108)
	// 82EA60F0: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA60F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA60F8: 41820010  beq 0x82ea6108
	if ctx.cr[0].eq {
	pc = 0x82EA6108; continue 'dispatch;
	}
	// 82EA60FC: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA6100: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA6104: 4E800421  bctrl
	ctx.lr = 0x82EA6108;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA6108 => {
    //   block [0x82EA6108..0x82EA6124)
	// 82EA6108: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA610C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA6110: 41820078  beq 0x82ea6188
	if ctx.cr[0].eq {
	pc = 0x82EA6188; continue 'dispatch;
	}
	// 82EA6114: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EA6118: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA611C: 419A004C  beq cr6, 0x82ea6168
	if ctx.cr[6].eq {
	pc = 0x82EA6168; continue 'dispatch;
	}
	// 82EA6120: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82EA6124; continue 'dispatch;
            }
            0x82EA6124 => {
    //   block [0x82EA6124..0x82EA6154)
	// 82EA6124: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EA6128: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA612C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA6130: 419A0024  beq cr6, 0x82ea6154
	if ctx.cr[6].eq {
	pc = 0x82EA6154; continue 'dispatch;
	}
	// 82EA6134: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA6138: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA613C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA6140: 419A0014  beq cr6, 0x82ea6154
	if ctx.cr[6].eq {
	pc = 0x82EA6154; continue 'dispatch;
	}
	// 82EA6144: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA6148: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA614C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA6150: 4E800421  bctrl
	ctx.lr = 0x82EA6154;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA6154 => {
    //   block [0x82EA6154..0x82EA6168)
	// 82EA6154: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA6158: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EA615C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EA6160: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA6164: 4198FFC0  blt cr6, 0x82ea6124
	if ctx.cr[6].lt {
	pc = 0x82EA6124; continue 'dispatch;
	}
	pc = 0x82EA6168; continue 'dispatch;
            }
            0x82EA6168 => {
    //   block [0x82EA6168..0x82EA6188)
	// 82EA6168: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA616C: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA6170: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA6174: 4E800421  bctrl
	ctx.lr = 0x82EA6178;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA6178: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EA617C: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA6180: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA6184: 4E800421  bctrl
	ctx.lr = 0x82EA6188;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA6188 => {
    //   block [0x82EA6188..0x82EA61A4)
	// 82EA6188: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA618C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA6190: 41820078  beq 0x82ea6208
	if ctx.cr[0].eq {
	pc = 0x82EA6208; continue 'dispatch;
	}
	// 82EA6194: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EA6198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA619C: 419A004C  beq cr6, 0x82ea61e8
	if ctx.cr[6].eq {
	pc = 0x82EA61E8; continue 'dispatch;
	}
	// 82EA61A0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82EA61A4; continue 'dispatch;
            }
            0x82EA61A4 => {
    //   block [0x82EA61A4..0x82EA61D4)
	// 82EA61A4: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA61A8: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA61AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA61B0: 419A0024  beq cr6, 0x82ea61d4
	if ctx.cr[6].eq {
	pc = 0x82EA61D4; continue 'dispatch;
	}
	// 82EA61B4: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA61B8: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA61BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA61C0: 419A0014  beq cr6, 0x82ea61d4
	if ctx.cr[6].eq {
	pc = 0x82EA61D4; continue 'dispatch;
	}
	// 82EA61C4: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA61C8: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA61CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA61D0: 4E800421  bctrl
	ctx.lr = 0x82EA61D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA61D4 => {
    //   block [0x82EA61D4..0x82EA61E8)
	// 82EA61D4: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA61D8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EA61DC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EA61E0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA61E4: 4198FFC0  blt cr6, 0x82ea61a4
	if ctx.cr[6].lt {
	pc = 0x82EA61A4; continue 'dispatch;
	}
	pc = 0x82EA61E8; continue 'dispatch;
            }
            0x82EA61E8 => {
    //   block [0x82EA61E8..0x82EA6208)
	// 82EA61E8: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA61EC: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA61F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA61F4: 4E800421  bctrl
	ctx.lr = 0x82EA61F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA61F8: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA61FC: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA6200: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA6204: 4E800421  bctrl
	ctx.lr = 0x82EA6208;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA6208 => {
    //   block [0x82EA6208..0x82EA6224)
	// 82EA6208: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA620C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA6210: 41820090  beq 0x82ea62a0
	if ctx.cr[0].eq {
	pc = 0x82EA62A0; continue 'dispatch;
	}
	// 82EA6214: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EA6218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA621C: 419A004C  beq cr6, 0x82ea6268
	if ctx.cr[6].eq {
	pc = 0x82EA6268; continue 'dispatch;
	}
	// 82EA6220: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82EA6224; continue 'dispatch;
            }
            0x82EA6224 => {
    //   block [0x82EA6224..0x82EA6254)
	// 82EA6224: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA6228: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA622C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA6230: 419A0024  beq cr6, 0x82ea6254
	if ctx.cr[6].eq {
	pc = 0x82EA6254; continue 'dispatch;
	}
	// 82EA6234: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA6238: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA623C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA6240: 419A0014  beq cr6, 0x82ea6254
	if ctx.cr[6].eq {
	pc = 0x82EA6254; continue 'dispatch;
	}
	// 82EA6244: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA6248: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA624C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA6250: 4E800421  bctrl
	ctx.lr = 0x82EA6254;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA6254 => {
    //   block [0x82EA6254..0x82EA6268)
	// 82EA6254: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA6258: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EA625C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EA6260: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA6264: 4198FFC0  blt cr6, 0x82ea6224
	if ctx.cr[6].lt {
	pc = 0x82EA6224; continue 'dispatch;
	}
	pc = 0x82EA6268; continue 'dispatch;
            }
            0x82EA6268 => {
    //   block [0x82EA6268..0x82EA6290)
	// 82EA6268: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA626C: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA6270: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA6274: 4E800421  bctrl
	ctx.lr = 0x82EA6278;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA6278: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA627C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA6280: 41820010  beq 0x82ea6290
	if ctx.cr[0].eq {
	pc = 0x82EA6290; continue 'dispatch;
	}
	// 82EA6284: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA6288: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA628C: 4E800421  bctrl
	ctx.lr = 0x82EA6290;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA6290 => {
    //   block [0x82EA6290..0x82EA62A0)
	// 82EA6290: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA6294: 817CDAB4  lwz r11, -0x254c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA6298: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA629C: 4E800421  bctrl
	ctx.lr = 0x82EA62A0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA62A0 => {
    //   block [0x82EA62A0..0x82EA62A8)
	// 82EA62A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EA62A4: 4BE031B4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA62A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA62A8 size=68
    let mut pc: u32 = 0x82EA62A8;
    'dispatch: loop {
        match pc {
            0x82EA62A8 => {
    //   block [0x82EA62A8..0x82EA62EC)
	// 82EA62A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA62AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA62B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA62B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA62B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA62BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA62C0: 396BA26C  addi r11, r11, -0x5d94
	ctx.r[11].s64 = ctx.r[11].s64 + -23956;
	// 82EA62C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA62C8: 4BFFFD89  bl 0x82ea6050
	ctx.lr = 0x82EA62CC;
	sub_82EA6050(ctx, base);
	// 82EA62CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EA62D0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EA62D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA62D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA62DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA62E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA62E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA62E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA62F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA62F0 size=184
    let mut pc: u32 = 0x82EA62F0;
    'dispatch: loop {
        match pc {
            0x82EA62F0 => {
    //   block [0x82EA62F0..0x82EA6328)
	// 82EA62F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA62F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA62F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EA62FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA6300: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA6304: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA6308: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EA630C: 396BA270  addi r11, r11, -0x5d90
	ctx.r[11].s64 = ctx.r[11].s64 + -23952;
	// 82EA6310: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EA6314: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EA6318: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA631C: 419A0030  beq cr6, 0x82ea634c
	if ctx.cr[6].eq {
	pc = 0x82EA634C; continue 'dispatch;
	}
	// 82EA6320: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EA6324: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82EA6328; continue 'dispatch;
            }
            0x82EA6328 => {
    //   block [0x82EA6328..0x82EA634C)
	// 82EA6328: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA632C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EA6330: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EA6334: 409AFFF4  bne cr6, 0x82ea6328
	if !ctx.cr[6].eq {
	pc = 0x82EA6328; continue 'dispatch;
	}
	// 82EA6338: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EA633C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EA6340: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA6344: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82EA6348: 48000008  b 0x82ea6350
	pc = 0x82EA6350; continue 'dispatch;
            }
            0x82EA634C => {
    //   block [0x82EA634C..0x82EA6350)
	// 82EA634C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EA6350; continue 'dispatch;
            }
            0x82EA6350 => {
    //   block [0x82EA6350..0x82EA6368)
	// 82EA6350: 4B7705D9  bl 0x82616928
	ctx.lr = 0x82EA6354;
	sub_82616928(ctx, base);
	// 82EA6354: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EA6358: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EA635C: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EA6360: 419A0024  beq cr6, 0x82ea6384
	if ctx.cr[6].eq {
	pc = 0x82EA6384; continue 'dispatch;
	}
	// 82EA6364: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82EA6368; continue 'dispatch;
            }
            0x82EA6368 => {
    //   block [0x82EA6368..0x82EA6384)
	// 82EA6368: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA636C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EA6370: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA6374: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 82EA6378: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EA637C: 4082FFEC  bne 0x82ea6368
	if !ctx.cr[0].eq {
	pc = 0x82EA6368; continue 'dispatch;
	}
	// 82EA6380: 4800000C  b 0x82ea638c
	pc = 0x82EA638C; continue 'dispatch;
            }
            0x82EA6384 => {
    //   block [0x82EA6384..0x82EA638C)
	// 82EA6384: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EA6388: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	pc = 0x82EA638C; continue 'dispatch;
            }
            0x82EA638C => {
    //   block [0x82EA638C..0x82EA63A8)
	// 82EA638C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EA6390: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EA6394: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA6398: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA639C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EA63A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA63A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA63A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA63A8 size=8
    let mut pc: u32 = 0x82EA63A8;
    'dispatch: loop {
        match pc {
            0x82EA63A8 => {
    //   block [0x82EA63A8..0x82EA63B0)
	// 82EA63A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA63AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA63B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA63B0 size=84
    let mut pc: u32 = 0x82EA63B0;
    'dispatch: loop {
        match pc {
            0x82EA63B0 => {
    //   block [0x82EA63B0..0x82EA6404)
	// 82EA63B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA63B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA63B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA63BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA63C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA63C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA63C8: 396BA270  addi r11, r11, -0x5d90
	ctx.r[11].s64 = ctx.r[11].s64 + -23952;
	// 82EA63CC: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82EA63D0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA63D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA63D8: 816ADAB4  lwz r11, -0x254c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA63DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA63E0: 4E800421  bctrl
	ctx.lr = 0x82EA63E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA63E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EA63E8: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EA63EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA63F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA63F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA63F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA63FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA6400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA6408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA6408 size=108
    let mut pc: u32 = 0x82EA6408;
    'dispatch: loop {
        match pc {
            0x82EA6408 => {
    //   block [0x82EA6408..0x82EA6410)
	// 82EA6408: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EA640C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x82EA6410; continue 'dispatch;
            }
            0x82EA6410 => {
    //   block [0x82EA6410..0x82EA6450)
	// 82EA6410: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6414: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6418: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA641C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA6420: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6424: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6428: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA642C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6430: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA6434: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6438: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA643C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6440: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6444: 409A000C  bne cr6, 0x82ea6450
	if !ctx.cr[6].eq {
	pc = 0x82EA6450; continue 'dispatch;
	}
	// 82EA6448: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EA644C: 4800000C  b 0x82ea6458
	pc = 0x82EA6458; continue 'dispatch;
            }
            0x82EA6450 => {
    //   block [0x82EA6450..0x82EA6458)
	// 82EA6450: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6454: 7D4A2214  add r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	pc = 0x82EA6458; continue 'dispatch;
            }
            0x82EA6458 => {
    //   block [0x82EA6458..0x82EA6474)
	// 82EA6458: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA645C: 3463FFFF  addic. r3, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82EA6460: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6464: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA6468: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA646C: 4082FFA4  bne 0x82ea6410
	if !ctx.cr[0].eq {
	pc = 0x82EA6410; continue 'dispatch;
	}
	// 82EA6470: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA6478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA6478 size=240
    let mut pc: u32 = 0x82EA6478;
    'dispatch: loop {
        match pc {
            0x82EA6478 => {
    //   block [0x82EA6478..0x82EA648C)
	// 82EA6478: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 82EA647C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82EA6480: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82EA6484: 419A0068  beq cr6, 0x82ea64ec
	if ctx.cr[6].eq {
	pc = 0x82EA64EC; continue 'dispatch;
	}
	// 82EA6488: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	pc = 0x82EA648C; continue 'dispatch;
            }
            0x82EA648C => {
    //   block [0x82EA648C..0x82EA64A0)
	// 82EA648C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6490: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6494: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA6498: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA649C: 4800003C  b 0x82ea64d8
	pc = 0x82EA64D8; continue 'dispatch;
            }
            0x82EA64A0 => {
    //   block [0x82EA64A0..0x82EA64D8)
	// 82EA64A0: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA64A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA64A8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82EA64AC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82EA64B0: 517F843E  rlwimi r31, r11, 0x10, 0x10, 0x1f
	ctx.r[31].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[31].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA64B4: 517E801E  rlwimi r30, r11, 0x10, 0, 0xf
	ctx.r[30].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[30].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA64B8: 57EBC43E  rlwinm r11, r31, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 82EA64BC: 57DF401E  rlwinm r31, r30, 8, 0, 0xf
	ctx.r[31].u64 = ctx.r[30].u32 as u64 & 0x00FFFFFFu64;
	// 82EA64C0: 7D6BFB78  or r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[31].u64;
	// 82EA64C4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA64C8: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA64CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA64D0: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA64D4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x82EA64D8; continue 'dispatch;
            }
            0x82EA64D8 => {
    //   block [0x82EA64D8..0x82EA64EC)
	// 82EA64D8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA64DC: 409AFFC4  bne cr6, 0x82ea64a0
	if !ctx.cr[6].eq {
	pc = 0x82EA64A0; continue 'dispatch;
	}
	// 82EA64E0: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EA64E4: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82EA64E8: 4082FFA4  bne 0x82ea648c
	if !ctx.cr[0].eq {
	pc = 0x82EA648C; continue 'dispatch;
	}
	pc = 0x82EA64EC; continue 'dispatch;
            }
            0x82EA64EC => {
    //   block [0x82EA64EC..0x82EA64FC)
	// 82EA64EC: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA64F0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82EA64F4: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA64F8: 419A0064  beq cr6, 0x82ea655c
	if ctx.cr[6].eq {
	pc = 0x82EA655C; continue 'dispatch;
	}
	pc = 0x82EA64FC; continue 'dispatch;
            }
            0x82EA64FC => {
    //   block [0x82EA64FC..0x82EA653C)
	// 82EA64FC: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6500: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6504: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA6508: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA650C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6510: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6514: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA6518: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA651C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA6520: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6524: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6528: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA652C: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6530: 409A000C  bne cr6, 0x82ea653c
	if !ctx.cr[6].eq {
	pc = 0x82EA653C; continue 'dispatch;
	}
	// 82EA6534: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EA6538: 4800000C  b 0x82ea6544
	pc = 0x82EA6544; continue 'dispatch;
            }
            0x82EA653C => {
    //   block [0x82EA653C..0x82EA6544)
	// 82EA653C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6540: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	pc = 0x82EA6544; continue 'dispatch;
            }
            0x82EA6544 => {
    //   block [0x82EA6544..0x82EA655C)
	// 82EA6544: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6548: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82EA654C: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6550: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA6554: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6558: 4082FFA4  bne 0x82ea64fc
	if !ctx.cr[0].eq {
	pc = 0x82EA64FC; continue 'dispatch;
	}
	pc = 0x82EA655C; continue 'dispatch;
            }
            0x82EA655C => {
    //   block [0x82EA655C..0x82EA6568)
	// 82EA655C: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA6560: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82EA6564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA6568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA6568 size=200
    let mut pc: u32 = 0x82EA6568;
    'dispatch: loop {
        match pc {
            0x82EA6568 => {
    //   block [0x82EA6568..0x82EA657C)
	// 82EA6568: 7D4321D6  mullw r10, r3, r4
	ctx.r[10].s32 = ((ctx.r[3].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA656C: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6570: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6574: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA6578: 4800003C  b 0x82ea65b4
	pc = 0x82EA65B4; continue 'dispatch;
            }
            0x82EA657C => {
    //   block [0x82EA657C..0x82EA65B4)
	// 82EA657C: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6580: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6584: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA6588: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EA658C: 5168843E  rlwimi r8, r11, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6590: 5164801E  rlwimi r4, r11, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6594: 550BC43E  rlwinm r11, r8, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA6598: 5488401E  rlwinm r8, r4, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[4].u32 as u64 & 0x00FFFFFFu64;
	// 82EA659C: 7D6B4378  or r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[8].u64;
	// 82EA65A0: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA65A4: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA65A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA65AC: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA65B0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x82EA65B4; continue 'dispatch;
            }
            0x82EA65B4 => {
    //   block [0x82EA65B4..0x82EA65CC)
	// 82EA65B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EA65B8: 409AFFC4  bne cr6, 0x82ea657c
	if !ctx.cr[6].eq {
	pc = 0x82EA657C; continue 'dispatch;
	}
	// 82EA65BC: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA65C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EA65C4: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA65C8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x82EA65CC; continue 'dispatch;
            }
            0x82EA65CC => {
    //   block [0x82EA65CC..0x82EA660C)
	// 82EA65CC: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA65D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA65D4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA65D8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA65DC: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA65E0: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA65E4: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA65E8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA65EC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA65F0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA65F4: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA65F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA65FC: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6600: 409A000C  bne cr6, 0x82ea660c
	if !ctx.cr[6].eq {
	pc = 0x82EA660C; continue 'dispatch;
	}
	// 82EA6604: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EA6608: 4800000C  b 0x82ea6614
	pc = 0x82EA6614; continue 'dispatch;
            }
            0x82EA660C => {
    //   block [0x82EA660C..0x82EA6614)
	// 82EA660C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6610: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	pc = 0x82EA6614; continue 'dispatch;
            }
            0x82EA6614 => {
    //   block [0x82EA6614..0x82EA6630)
	// 82EA6614: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6618: 3463FFFF  addic. r3, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82EA661C: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6620: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA6624: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6628: 4082FFA4  bne 0x82ea65cc
	if !ctx.cr[0].eq {
	pc = 0x82EA65CC; continue 'dispatch;
	}
	// 82EA662C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA6630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EA6630 size=256
    let mut pc: u32 = 0x82EA6630;
    'dispatch: loop {
        match pc {
            0x82EA6630 => {
    //   block [0x82EA6630..0x82EA6648)
	// 82EA6630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA6634: 4BE02DD9  bl 0x82ca940c
	ctx.lr = 0x82EA6638;
	sub_82CA93D0(ctx, base);
	// 82EA6638: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EA663C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EA6640: 419A007C  beq cr6, 0x82ea66bc
	if ctx.cr[6].eq {
	pc = 0x82EA66BC; continue 'dispatch;
	}
	// 82EA6644: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	pc = 0x82EA6648; continue 'dispatch;
            }
            0x82EA6648 => {
    //   block [0x82EA6648..0x82EA6654)
	// 82EA6648: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82EA664C: 419A0068  beq cr6, 0x82ea66b4
	if ctx.cr[6].eq {
	pc = 0x82EA66B4; continue 'dispatch;
	}
	// 82EA6650: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	pc = 0x82EA6654; continue 'dispatch;
            }
            0x82EA6654 => {
    //   block [0x82EA6654..0x82EA6694)
	// 82EA6654: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6658: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA665C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82EA6660: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82EA6664: 517E843E  rlwimi r30, r11, 0x10, 0x10, 0x1f
	ctx.r[30].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[30].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6668: 517D801E  rlwimi r29, r11, 0x10, 0, 0xf
	ctx.r[29].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[29].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA666C: 57CBC43E  rlwinm r11, r30, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82EA6670: 57BE401E  rlwinm r30, r29, 8, 0, 0xf
	ctx.r[30].u64 = ctx.r[29].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6674: 7D6BF378  or r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[30].u64;
	// 82EA6678: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA667C: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6680: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6684: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6688: 409A000C  bne cr6, 0x82ea6694
	if !ctx.cr[6].eq {
	pc = 0x82EA6694; continue 'dispatch;
	}
	// 82EA668C: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82EA6690: 48000010  b 0x82ea66a0
	pc = 0x82EA66A0; continue 'dispatch;
            }
            0x82EA6694 => {
    //   block [0x82EA6694..0x82EA66A0)
	// 82EA6694: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6698: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 82EA669C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA66A0; continue 'dispatch;
            }
            0x82EA66A0 => {
    //   block [0x82EA66A0..0x82EA66B4)
	// 82EA66A0: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA66A4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EA66A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA66AC: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA66B0: 4082FFA4  bne 0x82ea6654
	if !ctx.cr[0].eq {
	pc = 0x82EA6654; continue 'dispatch;
	}
	pc = 0x82EA66B4; continue 'dispatch;
            }
            0x82EA66B4 => {
    //   block [0x82EA66B4..0x82EA66BC)
	// 82EA66B4: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EA66B8: 4082FF90  bne 0x82ea6648
	if !ctx.cr[0].eq {
	pc = 0x82EA6648; continue 'dispatch;
	}
	pc = 0x82EA66BC; continue 'dispatch;
            }
            0x82EA66BC => {
    //   block [0x82EA66BC..0x82EA66CC)
	// 82EA66BC: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA66C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EA66C4: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA66C8: 419A0064  beq cr6, 0x82ea672c
	if ctx.cr[6].eq {
	pc = 0x82EA672C; continue 'dispatch;
	}
	pc = 0x82EA66CC; continue 'dispatch;
            }
            0x82EA66CC => {
    //   block [0x82EA66CC..0x82EA670C)
	// 82EA66CC: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA66D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA66D4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA66D8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA66DC: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA66E0: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA66E4: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA66E8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA66EC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA66F0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA66F4: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA66F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA66FC: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6700: 409A000C  bne cr6, 0x82ea670c
	if !ctx.cr[6].eq {
	pc = 0x82EA670C; continue 'dispatch;
	}
	// 82EA6704: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82EA6708: 48000010  b 0x82ea6718
	pc = 0x82EA6718; continue 'dispatch;
            }
            0x82EA670C => {
    //   block [0x82EA670C..0x82EA6718)
	// 82EA670C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6710: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 82EA6714: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA6718; continue 'dispatch;
            }
            0x82EA6718 => {
    //   block [0x82EA6718..0x82EA672C)
	// 82EA6718: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA671C: 3463FFFF  addic. r3, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82EA6720: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA6724: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6728: 4082FFA4  bne 0x82ea66cc
	if !ctx.cr[0].eq {
	pc = 0x82EA66CC; continue 'dispatch;
	}
	pc = 0x82EA672C; continue 'dispatch;
            }
            0x82EA672C => {
    //   block [0x82EA672C..0x82EA6730)
	// 82EA672C: 4BE02D30  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA6730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA6730 size=3016
    let mut pc: u32 = 0x82EA6730;
    'dispatch: loop {
        match pc {
            0x82EA6730 => {
    //   block [0x82EA6730..0x82EA6778)
	// 82EA6730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA6734: 4BE02CB9  bl 0x82ca93ec
	ctx.lr = 0x82EA6738;
	sub_82CA93D0(ctx, base);
	// 82EA6738: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA673C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA6740: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EA6744: 4BFFF6F5  bl 0x82ea5e38
	ctx.lr = 0x82EA6748;
	sub_82EA5E38(ctx, base);
	// 82EA6748: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 82EA674C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EA6750: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EA6754: 4BE02D2D  bl 0x82ca9480
	ctx.lr = 0x82EA6758;
	sub_82CA9480(ctx, base);
	// 82EA6758: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EA675C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA6760: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EA6764: 388BA23C  addi r4, r11, -0x5dc4
	ctx.r[4].s64 = ctx.r[11].s64 + -24004;
	// 82EA6768: 9AE10074  stb r23, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[23].u8 ) };
	// 82EA676C: 4BE063E5  bl 0x82cacb50
	ctx.lr = 0x82EA6770;
	sub_82CACB50(ctx, base);
	// 82EA6770: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA6774: 4182000C  beq 0x82ea6780
	if ctx.cr[0].eq {
	pc = 0x82EA6780; continue 'dispatch;
	}
	pc = 0x82EA6778; continue 'dispatch;
            }
            0x82EA6778 => {
    //   block [0x82EA6778..0x82EA6780)
	// 82EA6778: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EA677C: 48000B74  b 0x82ea72f0
	pc = 0x82EA72F0; continue 'dispatch;
            }
            0x82EA6780 => {
    //   block [0x82EA6780..0x82EA6A20)
	// 82EA6780: 397B0014  addi r11, r27, 0x14
	ctx.r[11].s64 = ctx.r[27].s64 + 20;
	// 82EA6784: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6788: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EA678C: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA6790: 5149843E  rlwimi r9, r10, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6794: 5148801E  rlwimi r8, r10, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6798: 552AC43E  rlwinm r10, r9, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA679C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA67A0: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82EA67A4: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EA67A8: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 82EA67AC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA67B0: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EA67B4: 409AFFC4  bne cr6, 0x82ea6778
	if !ctx.cr[6].eq {
	pc = 0x82EA6778; continue 'dispatch;
	}
	// 82EA67B8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA67BC: 3ABF0028  addi r21, r31, 0x28
	ctx.r[21].s64 = ctx.r[31].s64 + 40;
	// 82EA67C0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA67C4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA67C8: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA67CC: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA67D0: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA67D4: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA67D8: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 82EA67DC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA67E0: 5569003E  slwi r9, r11, 0
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EA67E4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA67E8: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 82EA67EC: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EA67F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA67F4: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EA67F8: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA67FC: 5149843E  rlwimi r9, r10, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6800: 5148801E  rlwimi r8, r10, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6804: 552AC43E  rlwinm r10, r9, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA6808: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA680C: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82EA6810: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6814: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6818: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA681C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EA6820: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6824: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EA6828: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA682C: 5149843E  rlwimi r9, r10, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6830: 5148801E  rlwimi r8, r10, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6834: 552AC43E  rlwinm r10, r9, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA6838: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA683C: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82EA6840: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6844: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6848: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA684C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EA6850: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6854: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EA6858: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA685C: 5149843E  rlwimi r9, r10, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6860: 5148801E  rlwimi r8, r10, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6864: 552AC43E  rlwinm r10, r9, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA6868: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA686C: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82EA6870: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6874: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6878: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA687C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EA6880: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6884: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EA6888: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA688C: 5149843E  rlwimi r9, r10, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6890: 5148801E  rlwimi r8, r10, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6894: 552AC43E  rlwinm r10, r9, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA6898: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA689C: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82EA68A0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA68A4: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA68A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA68AC: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EA68B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA68B4: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EA68B8: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA68BC: 5149843E  rlwimi r9, r10, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA68C0: 5148801E  rlwimi r8, r10, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA68C4: 552AC43E  rlwinm r10, r9, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA68C8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA68CC: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82EA68D0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EA68D4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA68D8: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA68DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA68E0: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EA68E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA68E8: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA68EC: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82EA68F0: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA68F4: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA68F8: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA68FC: 54C8401E  rlwinm r8, r6, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6900: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EA6904: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82EA6908: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA690C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6910: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA6914: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82EA6918: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA691C: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA6920: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82EA6924: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6928: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA692C: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA6930: 54C8401E  rlwinm r8, r6, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6934: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82EA6938: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA693C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6940: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA6944: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82EA6948: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA694C: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA6950: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82EA6954: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6958: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA695C: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA6960: 54C8401E  rlwinm r8, r6, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6964: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82EA6968: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA696C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6970: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA6974: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82EA6978: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA697C: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA6980: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82EA6984: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6988: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA698C: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA6990: 54C8401E  rlwinm r8, r6, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6994: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82EA6998: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA699C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA69A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA69A4: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 82EA69A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA69AC: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA69B0: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82EA69B4: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA69B8: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA69BC: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA69C0: 54C8401E  rlwinm r8, r6, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82EA69C4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EA69C8: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82EA69CC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA69D0: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA69D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA69D8: 809F0024  lwz r4, 0x24(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA69DC: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA69E0: 993F0038  stb r9, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u8 ) };
	// 82EA69E4: 92FF003C  stw r23, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[23].u32 ) };
	// 82EA69E8: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82EA69EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EA69F0: 4BFFFC41  bl 0x82ea6630
	ctx.lr = 0x82EA69F4;
	sub_82EA6630(ctx, base);
	// 82EA69F4: 3ADF002C  addi r22, r31, 0x2c
	ctx.r[22].s64 = ctx.r[31].s64 + 44;
	// 82EA69F8: 809F0024  lwz r4, 0x24(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA69FC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EA6A00: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA6A04: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 82EA6A08: 4BFFFB61  bl 0x82ea6568
	ctx.lr = 0x82EA6A0C;
	sub_82EA6568(ctx, base);
	// 82EA6A0C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA6A10: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82EA6A14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA6A18: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA6A1C: 40990594  ble cr6, 0x82ea6fb0
	if !ctx.cr[6].gt {
	pc = 0x82EA6FB0; continue 'dispatch;
	}
	pc = 0x82EA6A20; continue 'dispatch;
            }
            0x82EA6A20 => {
    //   block [0x82EA6A20..0x82EA6A38)
	// 82EA6A20: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA6A24: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82EA6A28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA6A2C: 40990570  ble cr6, 0x82ea6f9c
	if !ctx.cr[6].gt {
	pc = 0x82EA6F9C; continue 'dispatch;
	}
	// 82EA6A30: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EA6A34: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	pc = 0x82EA6A38; continue 'dispatch;
            }
            0x82EA6A38 => {
    //   block [0x82EA6A38..0x82EA6A50)
	// 82EA6A38: 81560000  lwz r10, 0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6A3C: 7D46502E  lwzx r10, r6, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA6A40: 7D4A382E  lwzx r10, r10, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82EA6A44: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA6A48: 41820540  beq 0x82ea6f88
	if ctx.cr[0].eq {
	pc = 0x82EA6F88; continue 'dispatch;
	}
	// 82EA6A4C: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	pc = 0x82EA6A50; continue 'dispatch;
            }
            0x82EA6A50 => {
    //   block [0x82EA6A50..0x82EA6B7C)
	// 82EA6A50: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EA6A54: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6A58: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EA6A5C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA6A60: 5164843E  rlwimi r4, r11, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6A64: 5163801E  rlwimi r3, r11, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6A68: 548BC43E  rlwinm r11, r4, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6A6C: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6A70: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82EA6A74: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6A78: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EA6A7C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6A80: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EA6A84: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA6A88: 5164843E  rlwimi r4, r11, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6A8C: 5163801E  rlwimi r3, r11, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6A90: 548BC43E  rlwinm r11, r4, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6A94: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6A98: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82EA6A9C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6AA0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EA6AA4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6AA8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EA6AAC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA6AB0: 5164843E  rlwimi r4, r11, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6AB4: 5163801E  rlwimi r3, r11, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6AB8: 548BC43E  rlwinm r11, r4, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6ABC: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6AC0: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82EA6AC4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6AC8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EA6ACC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6AD0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EA6AD4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA6AD8: 5164843E  rlwimi r4, r11, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6ADC: 5163801E  rlwimi r3, r11, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6AE0: 548BC43E  rlwinm r11, r4, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6AE4: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6AE8: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82EA6AEC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6AF0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EA6AF4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6AF8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EA6AFC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA6B00: 5164843E  rlwimi r4, r11, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6B04: 5163801E  rlwimi r3, r11, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6B08: 548BC43E  rlwinm r11, r4, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6B0C: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6B10: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82EA6B14: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6B18: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EA6B1C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6B20: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EA6B24: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA6B28: 5164843E  rlwimi r4, r11, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6B2C: 5163801E  rlwimi r3, r11, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6B30: 548BC43E  rlwinm r11, r4, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6B34: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6B38: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82EA6B3C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6B40: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EA6B44: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6B48: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EA6B4C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA6B50: 5164843E  rlwimi r4, r11, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6B54: 5163801E  rlwimi r3, r11, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6B58: 5484C43E  rlwinm r4, r4, 0x18, 0x10, 0x1f
	ctx.r[4].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6B5C: 546B401E  rlwinm r11, r3, 8, 0, 0xf
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6B60: 7C8B5B78  or r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 | ctx.r[11].u64;
	// 82EA6B64: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6B68: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA6B6C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EA6B70: 409A000C  bne cr6, 0x82ea6b7c
	if !ctx.cr[6].eq {
	pc = 0x82EA6B7C; continue 'dispatch;
	}
	// 82EA6B74: 92EA0000  stw r23, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EA6B78: 4800000C  b 0x82ea6b84
	pc = 0x82EA6B84; continue 'dispatch;
            }
            0x82EA6B7C => {
    //   block [0x82EA6B7C..0x82EA6B84)
	// 82EA6B7C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EA6B80: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA6B84; continue 'dispatch;
            }
            0x82EA6B84 => {
    //   block [0x82EA6B84..0x82EA6BC0)
	// 82EA6B84: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 82EA6B88: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6B8C: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EA6B90: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EA6B94: 5144843E  rlwimi r4, r10, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6B98: 5143801E  rlwimi r3, r10, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6B9C: 548AC43E  rlwinm r10, r4, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6BA0: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6BA4: 7D4A2378  or r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[4].u64;
	// 82EA6BA8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6BAC: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6BB0: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6BB4: 409A000C  bne cr6, 0x82ea6bc0
	if !ctx.cr[6].eq {
	pc = 0x82EA6BC0; continue 'dispatch;
	}
	// 82EA6BB8: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EA6BBC: 4800000C  b 0x82ea6bc8
	pc = 0x82EA6BC8; continue 'dispatch;
            }
            0x82EA6BC0 => {
    //   block [0x82EA6BC0..0x82EA6BC8)
	// 82EA6BC0: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82EA6BC4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA6BC8; continue 'dispatch;
            }
            0x82EA6BC8 => {
    //   block [0x82EA6BC8..0x82EA6C2C)
	// 82EA6BC8: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EA6BCC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6BD0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EA6BD4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA6BD8: 5164843E  rlwimi r4, r11, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6BDC: 5163801E  rlwimi r3, r11, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6BE0: 548BC43E  rlwinm r11, r4, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6BE4: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6BE8: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82EA6BEC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6BF0: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 82EA6BF4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6BF8: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EA6BFC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EA6C00: 5144843E  rlwimi r4, r10, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6C04: 5143801E  rlwimi r3, r10, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6C08: 548AC43E  rlwinm r10, r4, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6C0C: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6C10: 7D4A2378  or r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[4].u64;
	// 82EA6C14: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6C18: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6C1C: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6C20: 409A000C  bne cr6, 0x82ea6c2c
	if !ctx.cr[6].eq {
	pc = 0x82EA6C2C; continue 'dispatch;
	}
	// 82EA6C24: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EA6C28: 4800000C  b 0x82ea6c34
	pc = 0x82EA6C34; continue 'dispatch;
            }
            0x82EA6C2C => {
    //   block [0x82EA6C2C..0x82EA6C34)
	// 82EA6C2C: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82EA6C30: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA6C34; continue 'dispatch;
            }
            0x82EA6C34 => {
    //   block [0x82EA6C34..0x82EA6C70)
	// 82EA6C34: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA6C38: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6C3C: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EA6C40: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EA6C44: 5144843E  rlwimi r4, r10, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6C48: 5143801E  rlwimi r3, r10, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6C4C: 548AC43E  rlwinm r10, r4, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6C50: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6C54: 7D4A2378  or r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[4].u64;
	// 82EA6C58: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6C5C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6C60: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6C64: 409A000C  bne cr6, 0x82ea6c70
	if !ctx.cr[6].eq {
	pc = 0x82EA6C70; continue 'dispatch;
	}
	// 82EA6C68: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EA6C6C: 4800000C  b 0x82ea6c78
	pc = 0x82EA6C78; continue 'dispatch;
            }
            0x82EA6C70 => {
    //   block [0x82EA6C70..0x82EA6C78)
	// 82EA6C70: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82EA6C74: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA6C78; continue 'dispatch;
            }
            0x82EA6C78 => {
    //   block [0x82EA6C78..0x82EA6CDC)
	// 82EA6C78: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EA6C7C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6C80: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EA6C84: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA6C88: 5164843E  rlwimi r4, r11, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6C8C: 5163801E  rlwimi r3, r11, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6C90: 548BC43E  rlwinm r11, r4, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6C94: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6C98: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82EA6C9C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6CA0: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 82EA6CA4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6CA8: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EA6CAC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EA6CB0: 5144843E  rlwimi r4, r10, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6CB4: 5143801E  rlwimi r3, r10, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6CB8: 548AC43E  rlwinm r10, r4, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6CBC: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6CC0: 7D4A2378  or r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[4].u64;
	// 82EA6CC4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6CC8: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6CCC: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6CD0: 409A000C  bne cr6, 0x82ea6cdc
	if !ctx.cr[6].eq {
	pc = 0x82EA6CDC; continue 'dispatch;
	}
	// 82EA6CD4: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EA6CD8: 4800000C  b 0x82ea6ce4
	pc = 0x82EA6CE4; continue 'dispatch;
            }
            0x82EA6CDC => {
    //   block [0x82EA6CDC..0x82EA6CE4)
	// 82EA6CDC: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82EA6CE0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA6CE4; continue 'dispatch;
            }
            0x82EA6CE4 => {
    //   block [0x82EA6CE4..0x82EA6D20)
	// 82EA6CE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA6CE8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6CEC: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EA6CF0: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EA6CF4: 5144843E  rlwimi r4, r10, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6CF8: 5143801E  rlwimi r3, r10, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6CFC: 548AC43E  rlwinm r10, r4, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6D00: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6D04: 7D4A2378  or r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[4].u64;
	// 82EA6D08: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6D0C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6D10: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6D14: 409A000C  bne cr6, 0x82ea6d20
	if !ctx.cr[6].eq {
	pc = 0x82EA6D20; continue 'dispatch;
	}
	// 82EA6D18: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EA6D1C: 4800000C  b 0x82ea6d28
	pc = 0x82EA6D28; continue 'dispatch;
            }
            0x82EA6D20 => {
    //   block [0x82EA6D20..0x82EA6D28)
	// 82EA6D20: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82EA6D24: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA6D28; continue 'dispatch;
            }
            0x82EA6D28 => {
    //   block [0x82EA6D28..0x82EA6D8C)
	// 82EA6D28: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EA6D2C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6D30: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EA6D34: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA6D38: 5164843E  rlwimi r4, r11, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6D3C: 5163801E  rlwimi r3, r11, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6D40: 548BC43E  rlwinm r11, r4, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6D44: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6D48: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82EA6D4C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6D50: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 82EA6D54: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6D58: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EA6D5C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EA6D60: 5144843E  rlwimi r4, r10, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6D64: 5143801E  rlwimi r3, r10, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6D68: 548AC43E  rlwinm r10, r4, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6D6C: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6D70: 7D4A2378  or r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[4].u64;
	// 82EA6D74: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6D78: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6D7C: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6D80: 409A000C  bne cr6, 0x82ea6d8c
	if !ctx.cr[6].eq {
	pc = 0x82EA6D8C; continue 'dispatch;
	}
	// 82EA6D84: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EA6D88: 4800000C  b 0x82ea6d94
	pc = 0x82EA6D94; continue 'dispatch;
            }
            0x82EA6D8C => {
    //   block [0x82EA6D8C..0x82EA6D94)
	// 82EA6D8C: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82EA6D90: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA6D94; continue 'dispatch;
            }
            0x82EA6D94 => {
    //   block [0x82EA6D94..0x82EA6DD0)
	// 82EA6D94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA6D98: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6D9C: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EA6DA0: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EA6DA4: 5144843E  rlwimi r4, r10, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6DA8: 5143801E  rlwimi r3, r10, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6DAC: 548AC43E  rlwinm r10, r4, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6DB0: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6DB4: 7D4A2378  or r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[4].u64;
	// 82EA6DB8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6DBC: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6DC0: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6DC4: 409A000C  bne cr6, 0x82ea6dd0
	if !ctx.cr[6].eq {
	pc = 0x82EA6DD0; continue 'dispatch;
	}
	// 82EA6DC8: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EA6DCC: 4800000C  b 0x82ea6dd8
	pc = 0x82EA6DD8; continue 'dispatch;
            }
            0x82EA6DD0 => {
    //   block [0x82EA6DD0..0x82EA6DD8)
	// 82EA6DD0: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82EA6DD4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA6DD8; continue 'dispatch;
            }
            0x82EA6DD8 => {
    //   block [0x82EA6DD8..0x82EA6E3C)
	// 82EA6DD8: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EA6DDC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6DE0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EA6DE4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA6DE8: 5164843E  rlwimi r4, r11, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6DEC: 5163801E  rlwimi r3, r11, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6DF0: 548BC43E  rlwinm r11, r4, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6DF4: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6DF8: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82EA6DFC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6E00: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 82EA6E04: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6E08: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EA6E0C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EA6E10: 5144843E  rlwimi r4, r10, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6E14: 5143801E  rlwimi r3, r10, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6E18: 548AC43E  rlwinm r10, r4, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6E1C: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6E20: 7D4A2378  or r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[4].u64;
	// 82EA6E24: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6E28: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6E2C: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6E30: 409A000C  bne cr6, 0x82ea6e3c
	if !ctx.cr[6].eq {
	pc = 0x82EA6E3C; continue 'dispatch;
	}
	// 82EA6E34: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EA6E38: 4800000C  b 0x82ea6e44
	pc = 0x82EA6E44; continue 'dispatch;
            }
            0x82EA6E3C => {
    //   block [0x82EA6E3C..0x82EA6E44)
	// 82EA6E3C: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82EA6E40: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA6E44; continue 'dispatch;
            }
            0x82EA6E44 => {
    //   block [0x82EA6E44..0x82EA6E80)
	// 82EA6E44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA6E48: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6E4C: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EA6E50: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EA6E54: 5144843E  rlwimi r4, r10, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6E58: 5143801E  rlwimi r3, r10, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6E5C: 548AC43E  rlwinm r10, r4, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6E60: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6E64: 7D4A2378  or r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[4].u64;
	// 82EA6E68: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6E6C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6E70: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6E74: 409A000C  bne cr6, 0x82ea6e80
	if !ctx.cr[6].eq {
	pc = 0x82EA6E80; continue 'dispatch;
	}
	// 82EA6E78: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EA6E7C: 4800000C  b 0x82ea6e88
	pc = 0x82EA6E88; continue 'dispatch;
            }
            0x82EA6E80 => {
    //   block [0x82EA6E80..0x82EA6E88)
	// 82EA6E80: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82EA6E84: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA6E88; continue 'dispatch;
            }
            0x82EA6E88 => {
    //   block [0x82EA6E88..0x82EA6EEC)
	// 82EA6E88: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EA6E8C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6E90: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EA6E94: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EA6E98: 5164843E  rlwimi r4, r11, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6E9C: 5163801E  rlwimi r3, r11, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6EA0: 548BC43E  rlwinm r11, r4, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6EA4: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6EA8: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82EA6EAC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA6EB0: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 82EA6EB4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6EB8: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EA6EBC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EA6EC0: 5144843E  rlwimi r4, r10, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6EC4: 5143801E  rlwimi r3, r10, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6EC8: 548AC43E  rlwinm r10, r4, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6ECC: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6ED0: 7D4A2378  or r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[4].u64;
	// 82EA6ED4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6ED8: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6EDC: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6EE0: 409A000C  bne cr6, 0x82ea6eec
	if !ctx.cr[6].eq {
	pc = 0x82EA6EEC; continue 'dispatch;
	}
	// 82EA6EE4: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EA6EE8: 4800000C  b 0x82ea6ef4
	pc = 0x82EA6EF4; continue 'dispatch;
            }
            0x82EA6EEC => {
    //   block [0x82EA6EEC..0x82EA6EF4)
	// 82EA6EEC: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82EA6EF0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA6EF4; continue 'dispatch;
            }
            0x82EA6EF4 => {
    //   block [0x82EA6EF4..0x82EA6F30)
	// 82EA6EF4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA6EF8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6EFC: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EA6F00: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EA6F04: 5144843E  rlwimi r4, r10, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6F08: 5143801E  rlwimi r3, r10, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6F0C: 548AC43E  rlwinm r10, r4, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6F10: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6F14: 7D4A2378  or r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[4].u64;
	// 82EA6F18: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6F1C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6F20: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6F24: 409A000C  bne cr6, 0x82ea6f30
	if !ctx.cr[6].eq {
	pc = 0x82EA6F30; continue 'dispatch;
	}
	// 82EA6F28: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EA6F2C: 4800000C  b 0x82ea6f38
	pc = 0x82EA6F38; continue 'dispatch;
            }
            0x82EA6F30 => {
    //   block [0x82EA6F30..0x82EA6F38)
	// 82EA6F30: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82EA6F34: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA6F38; continue 'dispatch;
            }
            0x82EA6F38 => {
    //   block [0x82EA6F38..0x82EA6F74)
	// 82EA6F38: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA6F3C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6F40: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EA6F44: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EA6F48: 5144843E  rlwimi r4, r10, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA6F4C: 5143801E  rlwimi r3, r10, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA6F50: 548AC43E  rlwinm r10, r4, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EA6F54: 5464401E  rlwinm r4, r3, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82EA6F58: 7D4A2378  or r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[4].u64;
	// 82EA6F5C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA6F60: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA6F64: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EA6F68: 409A000C  bne cr6, 0x82ea6f74
	if !ctx.cr[6].eq {
	pc = 0x82EA6F74; continue 'dispatch;
	}
	// 82EA6F6C: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EA6F70: 4800000C  b 0x82ea6f7c
	pc = 0x82EA6F7C; continue 'dispatch;
            }
            0x82EA6F74 => {
    //   block [0x82EA6F74..0x82EA6F7C)
	// 82EA6F74: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82EA6F78: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EA6F7C; continue 'dispatch;
            }
            0x82EA6F7C => {
    //   block [0x82EA6F7C..0x82EA6F88)
	// 82EA6F7C: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EA6F80: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA6F84: 4082FACC  bne 0x82ea6a50
	if !ctx.cr[0].eq {
	pc = 0x82EA6A50; continue 'dispatch;
	}
	pc = 0x82EA6F88; continue 'dispatch;
            }
            0x82EA6F88 => {
    //   block [0x82EA6F88..0x82EA6F9C)
	// 82EA6F88: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA6F8C: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EA6F90: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EA6F94: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EA6F98: 4198FAA0  blt cr6, 0x82ea6a38
	if ctx.cr[6].lt {
	pc = 0x82EA6A38; continue 'dispatch;
	}
	pc = 0x82EA6F9C; continue 'dispatch;
            }
            0x82EA6F9C => {
    //   block [0x82EA6F9C..0x82EA6FB0)
	// 82EA6F9C: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA6FA0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EA6FA4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EA6FA8: 4198FA78  blt cr6, 0x82ea6a20
	if ctx.cr[6].lt {
	pc = 0x82EA6A20; continue 'dispatch;
	}
	// 82EA6FAC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA6FB0; continue 'dispatch;
            }
            0x82EA6FB0 => {
    //   block [0x82EA6FB0..0x82EA6FC0)
	// 82EA6FB0: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA6FB4: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	// 82EA6FB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA6FBC: 40990330  ble cr6, 0x82ea72ec
	if !ctx.cr[6].gt {
	pc = 0x82EA72EC; continue 'dispatch;
	}
	pc = 0x82EA6FC0; continue 'dispatch;
            }
            0x82EA6FC0 => {
    //   block [0x82EA6FC0..0x82EA6FD8)
	// 82EA6FC0: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA6FC4: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 82EA6FC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA6FCC: 40990310  ble cr6, 0x82ea72dc
	if !ctx.cr[6].gt {
	pc = 0x82EA72DC; continue 'dispatch;
	}
	// 82EA6FD0: 571A103A  slwi r26, r24, 2
	ctx.r[26].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82EA6FD4: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	pc = 0x82EA6FD8; continue 'dispatch;
            }
            0x82EA6FD8 => {
    //   block [0x82EA6FD8..0x82EA6FFC)
	// 82EA6FD8: 81560000  lwz r10, 0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6FDC: 81350000  lwz r9, 0(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA6FE0: 7D5A502E  lwzx r10, r26, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA6FE4: 7D29D02E  lwzx r9, r9, r26
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EA6FE8: 7D4AE82E  lwzx r10, r10, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EA6FEC: 7FC9E82E  lwzx r30, r9, r29
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EA6FF0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA6FF4: 418202D4  beq 0x82ea72c8
	if ctx.cr[0].eq {
	pc = 0x82EA72C8; continue 'dispatch;
	}
	// 82EA6FF8: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	pc = 0x82EA6FFC; continue 'dispatch;
            }
            0x82EA6FFC => {
    //   block [0x82EA6FFC..0x82EA7010)
	// 82EA6FFC: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA7000: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA7004: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA7008: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA700C: 419A0038  beq cr6, 0x82ea7044
	if ctx.cr[6].eq {
	pc = 0x82EA7044; continue 'dispatch;
	}
	pc = 0x82EA7010; continue 'dispatch;
            }
            0x82EA7010 => {
    //   block [0x82EA7010..0x82EA7044)
	// 82EA7010: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7014: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA7018: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82EA701C: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7020: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7024: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA7028: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82EA702C: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82EA7030: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA7034: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA7038: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA703C: 409AFFD4  bne cr6, 0x82ea7010
	if !ctx.cr[6].eq {
	pc = 0x82EA7010; continue 'dispatch;
	}
	// 82EA7040: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA7044; continue 'dispatch;
            }
            0x82EA7044 => {
    //   block [0x82EA7044..0x82EA706C)
	// 82EA7044: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EA7048: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA704C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EA7050: 4BFFF3B9  bl 0x82ea6408
	ctx.lr = 0x82EA7054;
	sub_82EA6408(ctx, base);
	// 82EA7054: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA7058: 1D4B0018  mulli r10, r11, 0x18
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA705C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA7060: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA7064: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA7068: 419A0038  beq cr6, 0x82ea70a0
	if ctx.cr[6].eq {
	pc = 0x82EA70A0; continue 'dispatch;
	}
	pc = 0x82EA706C; continue 'dispatch;
            }
            0x82EA706C => {
    //   block [0x82EA706C..0x82EA70A0)
	// 82EA706C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7070: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA7074: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82EA7078: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA707C: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7080: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA7084: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7088: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82EA708C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA7090: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA7094: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA7098: 409AFFD4  bne cr6, 0x82ea706c
	if !ctx.cr[6].eq {
	pc = 0x82EA706C; continue 'dispatch;
	}
	// 82EA709C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA70A0; continue 'dispatch;
            }
            0x82EA70A0 => {
    //   block [0x82EA70A0..0x82EA70C8)
	// 82EA70A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EA70A4: 807E0024  lwz r3, 0x24(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA70A8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EA70AC: 4BFFF35D  bl 0x82ea6408
	ctx.lr = 0x82EA70B0;
	sub_82EA6408(ctx, base);
	// 82EA70B0: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EA70B4: 1D4B0018  mulli r10, r11, 0x18
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA70B8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA70BC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA70C0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA70C4: 419A0038  beq cr6, 0x82ea70fc
	if ctx.cr[6].eq {
	pc = 0x82EA70FC; continue 'dispatch;
	}
	pc = 0x82EA70C8; continue 'dispatch;
            }
            0x82EA70C8 => {
    //   block [0x82EA70C8..0x82EA70FC)
	// 82EA70C8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA70CC: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA70D0: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82EA70D4: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA70D8: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA70DC: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA70E0: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82EA70E4: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82EA70E8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA70EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA70F0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA70F4: 409AFFD4  bne cr6, 0x82ea70c8
	if !ctx.cr[6].eq {
	pc = 0x82EA70C8; continue 'dispatch;
	}
	// 82EA70F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA70FC; continue 'dispatch;
            }
            0x82EA70FC => {
    //   block [0x82EA70FC..0x82EA7114)
	// 82EA70FC: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EA7100: 1D4A001C  mulli r10, r10, 0x1c
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA7104: 554A003A  rlwinm r10, r10, 0, 0, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82EA7108: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA710C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA7110: 419A0038  beq cr6, 0x82ea7148
	if ctx.cr[6].eq {
	pc = 0x82EA7148; continue 'dispatch;
	}
	pc = 0x82EA7114; continue 'dispatch;
            }
            0x82EA7114 => {
    //   block [0x82EA7114..0x82EA7148)
	// 82EA7114: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7118: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA711C: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82EA7120: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7124: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7128: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA712C: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7130: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82EA7134: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA7138: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA713C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA7140: 409AFFD4  bne cr6, 0x82ea7114
	if !ctx.cr[6].eq {
	pc = 0x82EA7114; continue 'dispatch;
	}
	// 82EA7144: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA7148; continue 'dispatch;
            }
            0x82EA7148 => {
    //   block [0x82EA7148..0x82EA715C)
	// 82EA7148: 815E003C  lwz r10, 0x3c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA714C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA7150: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA7154: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA7158: 419A0038  beq cr6, 0x82ea7190
	if ctx.cr[6].eq {
	pc = 0x82EA7190; continue 'dispatch;
	}
	pc = 0x82EA715C; continue 'dispatch;
            }
            0x82EA715C => {
    //   block [0x82EA715C..0x82EA7190)
	// 82EA715C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7160: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA7164: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82EA7168: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA716C: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7170: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA7174: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7178: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82EA717C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA7180: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA7184: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA7188: 409AFFD4  bne cr6, 0x82ea715c
	if !ctx.cr[6].eq {
	pc = 0x82EA715C; continue 'dispatch;
	}
	// 82EA718C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA7190; continue 'dispatch;
            }
            0x82EA7190 => {
    //   block [0x82EA7190..0x82EA71C0)
	// 82EA7190: 38FE0044  addi r7, r30, 0x44
	ctx.r[7].s64 = ctx.r[30].s64 + 68;
	// 82EA7194: 809E003C  lwz r4, 0x3c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA7198: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EA719C: 807E0040  lwz r3, 0x40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EA71A0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EA71A4: 4BFFF2D5  bl 0x82ea6478
	ctx.lr = 0x82EA71A8;
	sub_82EA6478(ctx, base);
	// 82EA71A8: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA71AC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA71B0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA71B4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA71B8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA71BC: 419A0038  beq cr6, 0x82ea71f4
	if ctx.cr[6].eq {
	pc = 0x82EA71F4; continue 'dispatch;
	}
	pc = 0x82EA71C0; continue 'dispatch;
            }
            0x82EA71C0 => {
    //   block [0x82EA71C0..0x82EA71F4)
	// 82EA71C0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA71C4: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA71C8: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82EA71CC: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA71D0: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA71D4: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA71D8: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82EA71DC: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82EA71E0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA71E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA71E8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA71EC: 409AFFD4  bne cr6, 0x82ea71c0
	if !ctx.cr[6].eq {
	pc = 0x82EA71C0; continue 'dispatch;
	}
	// 82EA71F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA71F4; continue 'dispatch;
            }
            0x82EA71F4 => {
    //   block [0x82EA71F4..0x82EA7224)
	// 82EA71F4: 38FE0050  addi r7, r30, 0x50
	ctx.r[7].s64 = ctx.r[30].s64 + 80;
	// 82EA71F8: 809E0048  lwz r4, 0x48(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA71FC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EA7200: 807E004C  lwz r3, 0x4c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA7204: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EA7208: 4BFFF271  bl 0x82ea6478
	ctx.lr = 0x82EA720C;
	sub_82EA6478(ctx, base);
	// 82EA720C: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA7210: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EA7214: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA7218: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA721C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA7220: 419A0038  beq cr6, 0x82ea7258
	if ctx.cr[6].eq {
	pc = 0x82EA7258; continue 'dispatch;
	}
	pc = 0x82EA7224; continue 'dispatch;
            }
            0x82EA7224 => {
    //   block [0x82EA7224..0x82EA7258)
	// 82EA7224: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7228: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA722C: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82EA7230: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7234: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7238: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA723C: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7240: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82EA7244: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA7248: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA724C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA7250: 409AFFD4  bne cr6, 0x82ea7224
	if !ctx.cr[6].eq {
	pc = 0x82EA7224; continue 'dispatch;
	}
	// 82EA7254: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA7258; continue 'dispatch;
            }
            0x82EA7258 => {
    //   block [0x82EA7258..0x82EA7288)
	// 82EA7258: 38FE005C  addi r7, r30, 0x5c
	ctx.r[7].s64 = ctx.r[30].s64 + 92;
	// 82EA725C: 809E0054  lwz r4, 0x54(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA7260: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EA7264: 807E0058  lwz r3, 0x58(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA7268: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EA726C: 4BFFF20D  bl 0x82ea6478
	ctx.lr = 0x82EA7270;
	sub_82EA6478(ctx, base);
	// 82EA7270: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA7274: 1D4B000C  mulli r10, r11, 0xc
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA7278: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA727C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EA7280: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA7284: 419A0038  beq cr6, 0x82ea72bc
	if ctx.cr[6].eq {
	pc = 0x82EA72BC; continue 'dispatch;
	}
	pc = 0x82EA7288; continue 'dispatch;
            }
            0x82EA7288 => {
    //   block [0x82EA7288..0x82EA72BC)
	// 82EA7288: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA728C: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82EA7290: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82EA7294: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7298: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA729C: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82EA72A0: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82EA72A4: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82EA72A8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EA72AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EA72B0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EA72B4: 409AFFD4  bne cr6, 0x82ea7288
	if !ctx.cr[6].eq {
	pc = 0x82EA7288; continue 'dispatch;
	}
	// 82EA72B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA72BC; continue 'dispatch;
            }
            0x82EA72BC => {
    //   block [0x82EA72BC..0x82EA72C8)
	// 82EA72BC: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82EA72C0: 3BDE0064  addi r30, r30, 0x64
	ctx.r[30].s64 = ctx.r[30].s64 + 100;
	// 82EA72C4: 4082FD38  bne 0x82ea6ffc
	if !ctx.cr[0].eq {
	pc = 0x82EA6FFC; continue 'dispatch;
	}
	pc = 0x82EA72C8; continue 'dispatch;
            }
            0x82EA72C8 => {
    //   block [0x82EA72C8..0x82EA72DC)
	// 82EA72C8: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA72CC: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82EA72D0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EA72D4: 7F195040  cmplw cr6, r25, r10
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EA72D8: 4198FD00  blt cr6, 0x82ea6fd8
	if ctx.cr[6].lt {
	pc = 0x82EA6FD8; continue 'dispatch;
	}
	pc = 0x82EA72DC; continue 'dispatch;
            }
            0x82EA72DC => {
    //   block [0x82EA72DC..0x82EA72EC)
	// 82EA72DC: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA72E0: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82EA72E4: 7F185040  cmplw cr6, r24, r10
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EA72E8: 4198FCD8  blt cr6, 0x82ea6fc0
	if ctx.cr[6].lt {
	pc = 0x82EA6FC0; continue 'dispatch;
	}
	pc = 0x82EA72EC; continue 'dispatch;
            }
            0x82EA72EC => {
    //   block [0x82EA72EC..0x82EA72F0)
	// 82EA72EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EA72F0; continue 'dispatch;
            }
            0x82EA72F0 => {
    //   block [0x82EA72F0..0x82EA72F8)
	// 82EA72F0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82EA72F4: 4BE02148  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA72F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EA72F8 size=7876
    let mut pc: u32 = 0x82EA72F8;
    'dispatch: loop {
        match pc {
            0x82EA72F8 => {
    //   block [0x82EA72F8..0x82EA73E4)
	// 82EA72F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA72FC: 4BE020D5  bl 0x82ca93d0
	ctx.lr = 0x82EA7300;
	sub_82CA93D0(ctx, base);
	// 82EA7300: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 82EA7304: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 82EA7308: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA730C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EA7310: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 82EA7314: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EA7318: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 82EA731C: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 82EA7320: 9301005C  stw r24, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[24].u32 ) };
	// 82EA7324: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EA7328: 9B140038  stb r24, 0x38(r20)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[20].u32.wrapping_add(56 as u32), ctx.r[24].u8 ) };
	// 82EA732C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7330: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7334: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7338: 9B010080  stb r24, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[24].u8 ) };
	// 82EA733C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7340: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA7344: 4E800421  bctrl
	ctx.lr = 0x82EA7348;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7348: 2B03000C  cmplwi cr6, r3, 0xc
	ctx.cr[6].compare_u32(ctx.r[3].u32, 12 as u32, &mut ctx.xer);
	// 82EA734C: 409A1E5C  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7350: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7354: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7358: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82EA735C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7360: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7364: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7368: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA736C: 4E800421  bctrl
	ctx.lr = 0x82EA7370;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7370: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7374: 409A1E34  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7378: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA737C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82EA7380: 9B01008C  stb r24, 0x8c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[24].u8 ) };
	// 82EA7384: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7388: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA738C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7390: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7394: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA7398: 386BA228  addi r3, r11, -0x5dd8
	ctx.r[3].s64 = ctx.r[11].s64 + -24024;
	// 82EA739C: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA73A0: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA73A4: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA73A8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EA73AC: 4BE057A5  bl 0x82cacb50
	ctx.lr = 0x82EA73B0;
	sub_82CACB50(ctx, base);
	// 82EA73B0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EA73B4: 40821DF4  bne 0x82ea91a8
	if !ctx.cr[0].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA73B8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA73BC: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82EA73C0: 419A002C  beq cr6, 0x82ea73ec
	if ctx.cr[6].eq {
	pc = 0x82EA73EC; continue 'dispatch;
	}
	// 82EA73C4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA73C8: 419A001C  beq cr6, 0x82ea73e4
	if ctx.cr[6].eq {
	pc = 0x82EA73E4; continue 'dispatch;
	}
	// 82EA73CC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EA73D0: 419A0014  beq cr6, 0x82ea73e4
	if ctx.cr[6].eq {
	pc = 0x82EA73E4; continue 'dispatch;
	}
	// 82EA73D4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EA73D8: 419A000C  beq cr6, 0x82ea73e4
	if ctx.cr[6].eq {
	pc = 0x82EA73E4; continue 'dispatch;
	}
	// 82EA73DC: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82EA73E0: 409A1DC8  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
            }
            0x82EA73E4 => {
    //   block [0x82EA73E4..0x82EA73EC)
	// 82EA73E4: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82EA73E8: 41980054  blt cr6, 0x82ea743c
	if ctx.cr[6].lt {
	pc = 0x82EA743C; continue 'dispatch;
	}
	pc = 0x82EA73EC; continue 'dispatch;
            }
            0x82EA73EC => {
    //   block [0x82EA73EC..0x82EA743C)
	// 82EA73EC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA73F0: 3BF40004  addi r31, r20, 4
	ctx.r[31].s64 = ctx.r[20].s64 + 4;
	// 82EA73F4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA73F8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA73FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7400: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EA7404: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7408: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA740C: 4E800421  bctrl
	ctx.lr = 0x82EA7410;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7410: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7414: 409A1D94  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7418: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA741C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7420: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA7424: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7428: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA742C: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7430: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7434: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA7438: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
            }
            0x82EA743C => {
    //   block [0x82EA743C..0x82EA76C8)
	// 82EA743C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7440: 3BF40008  addi r31, r20, 8
	ctx.r[31].s64 = ctx.r[20].s64 + 8;
	// 82EA7444: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7448: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA744C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7450: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EA7454: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7458: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA745C: 4E800421  bctrl
	ctx.lr = 0x82EA7460;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7460: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7464: 409A1D44  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7468: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA746C: 3BD40010  addi r30, r20, 0x10
	ctx.r[30].s64 = ctx.r[20].s64 + 16;
	// 82EA7470: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7474: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7478: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA747C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7480: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7484: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7488: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA748C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7490: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA7494: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7498: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA749C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA74A0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA74A4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA74A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA74AC: 4E800421  bctrl
	ctx.lr = 0x82EA74B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA74B0: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA74B4: 409A1CF4  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA74B8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA74BC: 3BF40014  addi r31, r20, 0x14
	ctx.r[31].s64 = ctx.r[20].s64 + 20;
	// 82EA74C0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA74C4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA74C8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA74CC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA74D0: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA74D4: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA74D8: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA74DC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA74E0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA74E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA74E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EA74EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA74F0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA74F4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA74F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA74FC: 4E800421  bctrl
	ctx.lr = 0x82EA7500;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7500: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7504: 409A1CA4  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7508: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA750C: 3BD40018  addi r30, r20, 0x18
	ctx.r[30].s64 = ctx.r[20].s64 + 24;
	// 82EA7510: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7514: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7518: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA751C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7520: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7524: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7528: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA752C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7530: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA7534: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7538: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA753C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA7540: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7544: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7548: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA754C: 4E800421  bctrl
	ctx.lr = 0x82EA7550;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7550: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7554: 409A1C54  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7558: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA755C: 3BF4001C  addi r31, r20, 0x1c
	ctx.r[31].s64 = ctx.r[20].s64 + 28;
	// 82EA7560: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7564: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7568: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA756C: 516A801E  rlwimi r10, r11, 0x10, 0, 0xf
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[10].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7570: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7574: 554B401E  rlwinm r11, r10, 8, 0, 0xf
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7578: 552AC43E  rlwinm r10, r9, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA757C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7580: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA7584: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7588: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EA758C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA7590: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7594: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7598: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA759C: 4E800421  bctrl
	ctx.lr = 0x82EA75A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA75A0: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA75A4: 409A1C04  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA75A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA75AC: 3BB40020  addi r29, r20, 0x20
	ctx.r[29].s64 = ctx.r[20].s64 + 32;
	// 82EA75B0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA75B4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA75B8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA75BC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA75C0: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA75C4: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA75C8: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA75CC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA75D0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA75D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA75D8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EA75DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA75E0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA75E4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA75E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA75EC: 4E800421  bctrl
	ctx.lr = 0x82EA75F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA75F0: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA75F4: 409A1BB4  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA75F8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA75FC: 3B740024  addi r27, r20, 0x24
	ctx.r[27].s64 = ctx.r[20].s64 + 36;
	// 82EA7600: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7604: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7608: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA760C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7610: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7614: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7618: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA761C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7620: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA7624: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7628: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EA762C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA7630: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7634: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7638: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA763C: 4E800421  bctrl
	ctx.lr = 0x82EA7640;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7640: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7644: 409A1B64  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7648: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA764C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7650: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 82EA7654: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7658: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA765C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7660: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7664: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7668: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA766C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA7670: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA7674: 41980054  blt cr6, 0x82ea76c8
	if ctx.cr[6].lt {
	pc = 0x82EA76C8; continue 'dispatch;
	}
	// 82EA7678: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA767C: 3BF4000C  addi r31, r20, 0xc
	ctx.r[31].s64 = ctx.r[20].s64 + 12;
	// 82EA7680: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7684: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7688: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA768C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EA7690: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7694: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA7698: 4E800421  bctrl
	ctx.lr = 0x82EA769C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA769C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA76A0: 409A1B08  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA76A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA76A8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA76AC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA76B0: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA76B4: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA76B8: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA76BC: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA76C0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA76C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
            }
            0x82EA76C8 => {
    //   block [0x82EA76C8..0x82EA76E4)
	// 82EA76C8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA76CC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EA76D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA76D4: C3EB0C18  lfs f31, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EA76D8: 4098000C  bge cr6, 0x82ea76e4
	if !ctx.cr[6].lt {
	pc = 0x82EA76E4; continue 'dispatch;
	}
	// 82EA76DC: D3F40030  stfs f31, 0x30(r20)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EA76E0: 48000054  b 0x82ea7734
	pc = 0x82EA7734; continue 'dispatch;
            }
            0x82EA76E4 => {
    //   block [0x82EA76E4..0x82EA7734)
	// 82EA76E4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA76E8: 3BF40030  addi r31, r20, 0x30
	ctx.r[31].s64 = ctx.r[20].s64 + 48;
	// 82EA76EC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA76F0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA76F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA76F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EA76FC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7700: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA7704: 4E800421  bctrl
	ctx.lr = 0x82EA7708;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7708: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA770C: 409A1A9C  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7710: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7714: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7718: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA771C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7720: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7724: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7728: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA772C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA7730: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
            }
            0x82EA7734 => {
    //   block [0x82EA7734..0x82EA7748)
	// 82EA7734: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA7738: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EA773C: 4098000C  bge cr6, 0x82ea7748
	if !ctx.cr[6].lt {
	pc = 0x82EA7748; continue 'dispatch;
	}
	// 82EA7740: D3F40034  stfs f31, 0x34(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EA7744: 48000054  b 0x82ea7798
	pc = 0x82EA7798; continue 'dispatch;
            }
            0x82EA7748 => {
    //   block [0x82EA7748..0x82EA7798)
	// 82EA7748: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA774C: 3BF40034  addi r31, r20, 0x34
	ctx.r[31].s64 = ctx.r[20].s64 + 52;
	// 82EA7750: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7754: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7758: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA775C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EA7760: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7764: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA7768: 4E800421  bctrl
	ctx.lr = 0x82EA776C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA776C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7770: 409A1A38  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7774: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7778: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA777C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA7780: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7784: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7788: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA778C: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7790: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA7794: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
            }
            0x82EA7798 => {
    //   block [0x82EA7798..0x82EA77B8)
	// 82EA7798: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82EA779C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA77A0: 3A00FFFF  li r16, -1
	ctx.r[16].s64 = -1;
	// 82EA77A4: 6153FFFF  ori r19, r10, 0xffff
	ctx.r[19].u64 = ctx.r[10].u64 | 65535;
	// 82EA77A8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA77AC: 7F0B9840  cmplw cr6, r11, r19
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82EA77B0: 40990008  ble cr6, 0x82ea77b8
	if !ctx.cr[6].gt {
	pc = 0x82EA77B8; continue 'dispatch;
	}
	// 82EA77B4: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	pc = 0x82EA77B8; continue 'dispatch;
            }
            0x82EA77B8 => {
    //   block [0x82EA77B8..0x82EA77D4)
	// 82EA77B8: 4B76F171  bl 0x82616928
	ctx.lr = 0x82EA77BC;
	sub_82616928(ctx, base);
	// 82EA77BC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA77C0: 90740028  stw r3, 0x28(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 82EA77C4: 7F0B9840  cmplw cr6, r11, r19
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82EA77C8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA77CC: 40990008  ble cr6, 0x82ea77d4
	if !ctx.cr[6].gt {
	pc = 0x82EA77D4; continue 'dispatch;
	}
	// 82EA77D0: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	pc = 0x82EA77D4; continue 'dispatch;
            }
            0x82EA77D4 => {
    //   block [0x82EA77D4..0x82EA77F0)
	// 82EA77D4: 4B76F155  bl 0x82616928
	ctx.lr = 0x82EA77D8;
	sub_82616928(ctx, base);
	// 82EA77D8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA77DC: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82EA77E0: 9074002C  stw r3, 0x2c(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 82EA77E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA77E8: 4099005C  ble cr6, 0x82ea7844
	if !ctx.cr[6].gt {
	pc = 0x82EA7844; continue 'dispatch;
	}
	// 82EA77EC: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	pc = 0x82EA77F0; continue 'dispatch;
            }
            0x82EA77F0 => {
    //   block [0x82EA77F0..0x82EA7804)
	// 82EA77F0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA77F4: 7F0B9840  cmplw cr6, r11, r19
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82EA77F8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA77FC: 40990008  ble cr6, 0x82ea7804
	if !ctx.cr[6].gt {
	pc = 0x82EA7804; continue 'dispatch;
	}
	// 82EA7800: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	pc = 0x82EA7804; continue 'dispatch;
            }
            0x82EA7804 => {
    //   block [0x82EA7804..0x82EA7824)
	// 82EA7804: 4B76F125  bl 0x82616928
	ctx.lr = 0x82EA7808;
	sub_82616928(ctx, base);
	// 82EA7808: 81740028  lwz r11, 0x28(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA780C: 7C7F592E  stwx r3, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 82EA7810: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7814: 7F0B9840  cmplw cr6, r11, r19
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82EA7818: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA781C: 40990008  ble cr6, 0x82ea7824
	if !ctx.cr[6].gt {
	pc = 0x82EA7824; continue 'dispatch;
	}
	// 82EA7820: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	pc = 0x82EA7824; continue 'dispatch;
            }
            0x82EA7824 => {
    //   block [0x82EA7824..0x82EA7844)
	// 82EA7824: 4B76F105  bl 0x82616928
	ctx.lr = 0x82EA7828;
	sub_82616928(ctx, base);
	// 82EA7828: 8174002C  lwz r11, 0x2c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA782C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EA7830: 7C7F592E  stwx r3, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 82EA7834: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EA7838: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA783C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA7840: 4198FFB0  blt cr6, 0x82ea77f0
	if ctx.cr[6].lt {
	pc = 0x82EA77F0; continue 'dispatch;
	}
	pc = 0x82EA7844; continue 'dispatch;
            }
            0x82EA7844 => {
    //   block [0x82EA7844..0x82EA7864)
	// 82EA7844: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7848: 7F0EC378  mr r14, r24
	ctx.r[14].u64 = ctx.r[24].u64;
	// 82EA784C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA7850: 40991638  ble cr6, 0x82ea8e88
	if !ctx.cr[6].gt {
	pc = 0x82EA8E88; continue 'dispatch;
	}
	// 82EA7854: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA7858: 3D401555  lis r10, 0x1555
	ctx.r[10].s64 = 357892096;
	// 82EA785C: 61515555  ori r17, r10, 0x5555
	ctx.r[17].u64 = ctx.r[10].u64 | 21845;
	// 82EA7860: C3CB0C14  lfs f30, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x82EA7864; continue 'dispatch;
            }
            0x82EA7864 => {
    //   block [0x82EA7864..0x82EA7878)
	// 82EA7864: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7868: 7F0FC378  mr r15, r24
	ctx.r[15].u64 = ctx.r[24].u64;
	// 82EA786C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA7870: 40991604  ble cr6, 0x82ea8e74
	if !ctx.cr[6].gt {
	pc = 0x82EA8E74; continue 'dispatch;
	}
	// 82EA7874: 55D2103A  slwi r18, r14, 2
	ctx.r[18].u32 = ctx.r[14].u32.wrapping_shl(2);
	ctx.r[18].u64 = ctx.r[18].u32 as u64;
	pc = 0x82EA7878; continue 'dispatch;
            }
            0x82EA7878 => {
    //   block [0x82EA7878..0x82EA7904)
	// 82EA7878: 8174002C  lwz r11, 0x2c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA787C: 55F6103A  slwi r22, r15, 2
	ctx.r[22].u32 = ctx.r[15].u32.wrapping_shl(2);
	ctx.r[22].u64 = ctx.r[22].u32 as u64;
	// 82EA7880: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7884: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7888: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA788C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7890: 7D72582E  lwzx r11, r18, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[18].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA7894: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7898: 7CABB214  add r5, r11, r22
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[22].u64;
	// 82EA789C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA78A0: 4E800421  bctrl
	ctx.lr = 0x82EA78A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA78A4: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA78A8: 409A1900  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA78AC: 8174002C  lwz r11, 0x2c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA78B0: 7D52582E  lwzx r10, r18, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[18].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA78B4: 7D6AB02E  lwzx r11, r10, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82EA78B8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA78BC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA78C0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA78C4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA78C8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA78CC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA78D0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA78D4: 7D6AB12E  stwx r11, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[11].u32) };
	// 82EA78D8: 8174002C  lwz r11, 0x2c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA78DC: 7D72582E  lwzx r11, r18, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[18].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA78E0: 7FEBB02E  lwzx r31, r11, r22
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82EA78E4: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA78E8: 41821578  beq 0x82ea8e60
	if ctx.cr[0].eq {
	pc = 0x82EA8E60; continue 'dispatch;
	}
	// 82EA78EC: 3D60028F  lis r11, 0x28f
	ctx.r[11].s64 = 42926080;
	// 82EA78F0: 616B5C28  ori r11, r11, 0x5c28
	ctx.r[11].u64 = ctx.r[11].u64 | 23592;
	// 82EA78F4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA78F8: 1D7F0064  mulli r11, r31, 0x64
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 100 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EA78FC: 40990008  ble cr6, 0x82ea7904
	if !ctx.cr[6].gt {
	pc = 0x82EA7904; continue 'dispatch;
	}
	// 82EA7900: 7E0B8378  mr r11, r16
	ctx.r[11].u64 = ctx.r[16].u64;
            }
            0x82EA7904 => {
    //   block [0x82EA7904..0x82EA7918)
	// 82EA7904: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EA7908: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82EA790C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EA7910: 40990008  ble cr6, 0x82ea7918
	if !ctx.cr[6].gt {
	pc = 0x82EA7918; continue 'dispatch;
	}
	// 82EA7914: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	pc = 0x82EA7918; continue 'dispatch;
            }
            0x82EA7918 => {
    //   block [0x82EA7918..0x82EA7938)
	// 82EA7918: 4B76F011  bl 0x82616928
	ctx.lr = 0x82EA791C;
	sub_82616928(ctx, base);
	// 82EA791C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EA7920: 419A0030  beq cr6, 0x82ea7950
	if ctx.cr[6].eq {
	pc = 0x82EA7950; continue 'dispatch;
	}
	// 82EA7924: 38A30004  addi r5, r3, 4
	ctx.r[5].s64 = ctx.r[3].s64 + 4;
	// 82EA7928: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82EA792C: 34DFFFFF  addic. r6, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82EA7930: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82EA7934: 41800014  blt 0x82ea7948
	if ctx.cr[0].lt {
	pc = 0x82EA7948; continue 'dispatch;
	}
	pc = 0x82EA7938; continue 'dispatch;
            }
            0x82EA7938 => {
    //   block [0x82EA7938..0x82EA7948)
	// 82EA7938: 4BFFE689  bl 0x82ea5fc0
	ctx.lr = 0x82EA793C;
	sub_82EA5FC0(ctx, base);
	// 82EA793C: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82EA7940: 38630064  addi r3, r3, 0x64
	ctx.r[3].s64 = ctx.r[3].s64 + 100;
	// 82EA7944: 4080FFF4  bge 0x82ea7938
	if !ctx.cr[0].lt {
	pc = 0x82EA7938; continue 'dispatch;
	}
	pc = 0x82EA7948; continue 'dispatch;
            }
            0x82EA7948 => {
    //   block [0x82EA7948..0x82EA7950)
	// 82EA7948: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82EA794C: 48000008  b 0x82ea7954
	pc = 0x82EA7954; continue 'dispatch;
            }
            0x82EA7950 => {
    //   block [0x82EA7950..0x82EA7954)
	// 82EA7950: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x82EA7954; continue 'dispatch;
            }
            0x82EA7954 => {
    //   block [0x82EA7954..0x82EA7978)
	// 82EA7954: 81540028  lwz r10, 0x28(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA7958: 7F17C378  mr r23, r24
	ctx.r[23].u64 = ctx.r[24].u64;
	// 82EA795C: 7D52502E  lwzx r10, r18, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[18].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA7960: 7D6AB12E  stwx r11, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[11].u32) };
	// 82EA7964: 8174002C  lwz r11, 0x2c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA7968: 7D72582E  lwzx r11, r18, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[18].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA796C: 7D6BB02E  lwzx r11, r11, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82EA7970: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA7974: 409914EC  ble cr6, 0x82ea8e60
	if !ctx.cr[6].gt {
	pc = 0x82EA8E60; continue 'dispatch;
	}
	pc = 0x82EA7978; continue 'dispatch;
            }
            0x82EA7978 => {
    //   block [0x82EA7978..0x82EA7AA0)
	// 82EA7978: 81740028  lwz r11, 0x28(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA797C: 1D570064  mulli r10, r23, 0x64
	ctx.r[10].s32 = ((ctx.r[23].s32 as i64 * 100 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA7980: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7984: 7D72582E  lwzx r11, r18, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[18].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA7988: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA798C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7990: 7D6BB02E  lwzx r11, r11, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82EA7994: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA7998: 3BDF0014  addi r30, r31, 0x14
	ctx.r[30].s64 = ctx.r[31].s64 + 20;
	// 82EA799C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EA79A0: 91DF0004  stw r14, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[14].u32 ) };
	// 82EA79A4: 91FF0008  stw r15, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[15].u32 ) };
	// 82EA79A8: 92FF000C  stw r23, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[23].u32 ) };
	// 82EA79AC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA79B0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA79B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA79B8: 4E800421  bctrl
	ctx.lr = 0x82EA79BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA79BC: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA79C0: 409A17E8  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA79C4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA79C8: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 82EA79CC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA79D0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA79D4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA79D8: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA79DC: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA79E0: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA79E4: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA79E8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA79EC: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA79F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA79F4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EA79F8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA79FC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7A00: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7A04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA7A08: 4E800421  bctrl
	ctx.lr = 0x82EA7A0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7A0C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7A10: 409A1798  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7A14: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7A18: 3B7F0018  addi r27, r31, 0x18
	ctx.r[27].s64 = ctx.r[31].s64 + 24;
	// 82EA7A1C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7A20: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7A24: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA7A28: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7A2C: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7A30: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7A34: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7A38: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7A3C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA7A40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7A44: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EA7A48: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA7A4C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7A50: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7A54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA7A58: 4E800421  bctrl
	ctx.lr = 0x82EA7A5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7A5C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7A60: 409A1748  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7A64: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7A68: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7A6C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA7A70: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7A74: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7A78: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7A7C: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7A80: 7D6B5379  or. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA7A84: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA7A88: 418201B0  beq 0x82ea7c38
	if ctx.cr[0].eq {
	pc = 0x82EA7C38; continue 'dispatch;
	}
	// 82EA7A8C: 557E083C  slwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82EA7A90: 7F1E8840  cmplw cr6, r30, r17
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[17].u32, &mut ctx.xer);
	// 82EA7A94: 1C7E000C  mulli r3, r30, 0xc
	ctx.r[3].s32 = ((ctx.r[30].s32 as i64 * 12 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82EA7A98: 40990008  ble cr6, 0x82ea7aa0
	if !ctx.cr[6].gt {
	pc = 0x82EA7AA0; continue 'dispatch;
	}
	// 82EA7A9C: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
            }
            0x82EA7AA0 => {
    //   block [0x82EA7AA0..0x82EA7AB8)
	// 82EA7AA0: 4B76EE89  bl 0x82616928
	ctx.lr = 0x82EA7AA4;
	sub_82616928(ctx, base);
	// 82EA7AA4: 7C6A1B79  or. r10, r3, r3
	ctx.r[10].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA7AA8: 4182002C  beq 0x82ea7ad4
	if ctx.cr[0].eq {
	pc = 0x82EA7AD4; continue 'dispatch;
	}
	// 82EA7AAC: 353EFFFF  addic. r9, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EA7AB0: 41800028  blt 0x82ea7ad8
	if ctx.cr[0].lt {
	pc = 0x82EA7AD8; continue 'dispatch;
	}
	// 82EA7AB4: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	pc = 0x82EA7AB8; continue 'dispatch;
            }
            0x82EA7AB8 => {
    //   block [0x82EA7AB8..0x82EA7AD4)
	// 82EA7AB8: D3EBFFF8  stfs f31, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EA7ABC: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EA7AC0: D3EBFFFC  stfs f31, -4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EA7AC4: D3EB0000  stfs f31, 0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EA7AC8: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EA7ACC: 4080FFEC  bge 0x82ea7ab8
	if !ctx.cr[0].lt {
	pc = 0x82EA7AB8; continue 'dispatch;
	}
	// 82EA7AD0: 48000008  b 0x82ea7ad8
	pc = 0x82EA7AD8; continue 'dispatch;
            }
            0x82EA7AD4 => {
    //   block [0x82EA7AD4..0x82EA7AD8)
	// 82EA7AD4: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	pc = 0x82EA7AD8; continue 'dispatch;
            }
            0x82EA7AD8 => {
    //   block [0x82EA7AD8..0x82EA7AF0)
	// 82EA7AD8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7ADC: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82EA7AE0: 7F0B9840  cmplw cr6, r11, r19
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82EA7AE4: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA7AE8: 40990008  ble cr6, 0x82ea7af0
	if !ctx.cr[6].gt {
	pc = 0x82EA7AF0; continue 'dispatch;
	}
	// 82EA7AEC: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	pc = 0x82EA7AF0; continue 'dispatch;
            }
            0x82EA7AF0 => {
    //   block [0x82EA7AF0..0x82EA7B0C)
	// 82EA7AF0: 4B76EE39  bl 0x82616928
	ctx.lr = 0x82EA7AF4;
	sub_82616928(ctx, base);
	// 82EA7AF4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7AF8: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 82EA7AFC: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 82EA7B00: 556B083D  rlwinm. r11, r11, 1, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA7B04: 4182013C  beq 0x82ea7c40
	if ctx.cr[0].eq {
	pc = 0x82EA7C40; continue 'dispatch;
	}
	// 82EA7B08: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	pc = 0x82EA7B0C; continue 'dispatch;
            }
            0x82EA7B0C => {
    //   block [0x82EA7B0C..0x82EA7C38)
	// 82EA7B0C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7B10: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7B14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EA7B18: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7B1C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7B20: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7B24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA7B28: 4E800421  bctrl
	ctx.lr = 0x82EA7B2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7B2C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7B30: 409A1678  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7B34: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA7B38: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7B3C: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7B40: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EA7B44: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7B48: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA7B4C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7B50: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7B54: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7B58: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7B5C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7B60: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7B64: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA7B68: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7B6C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EA7B70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA7B74: 4E800421  bctrl
	ctx.lr = 0x82EA7B78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7B78: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7B7C: 409A162C  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7B80: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA7B84: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7B88: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7B8C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EA7B90: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7B94: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA7B98: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7B9C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7BA0: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7BA4: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7BA8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7BAC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7BB0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA7BB4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7BB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EA7BBC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA7BC0: 4E800421  bctrl
	ctx.lr = 0x82EA7BC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7BC4: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7BC8: 409A15E0  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7BCC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA7BD0: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA7BD4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EA7BD8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7BDC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA7BE0: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7BE4: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7BE8: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7BEC: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7BF0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA7BF4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EA7BF8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA7BFC: 7C1E5D2E  stfsx f0, r30, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82EA7C00: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA7C04: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA7C08: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA7C0C: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EA7C10: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA7C14: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA7C18: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA7C1C: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82EA7C20: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EA7C24: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7C28: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA7C2C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA7C30: 4198FEDC  blt cr6, 0x82ea7b0c
	if ctx.cr[6].lt {
	pc = 0x82EA7B0C; continue 'dispatch;
	}
	// 82EA7C34: 4800000C  b 0x82ea7c40
	pc = 0x82EA7C40; continue 'dispatch;
            }
            0x82EA7C38 => {
    //   block [0x82EA7C38..0x82EA7C40)
	// 82EA7C38: 931F001C  stw r24, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[24].u32 ) };
	// 82EA7C3C: 931F0020  stw r24, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[24].u32 ) };
	pc = 0x82EA7C40; continue 'dispatch;
            }
            0x82EA7C40 => {
    //   block [0x82EA7C40..0x82EA7CA8)
	// 82EA7C40: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7C44: 3B7F0024  addi r27, r31, 0x24
	ctx.r[27].s64 = ctx.r[31].s64 + 36;
	// 82EA7C48: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7C4C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7C50: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7C54: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EA7C58: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7C5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA7C60: 4E800421  bctrl
	ctx.lr = 0x82EA7C64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7C64: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7C68: 409A1540  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7C6C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7C70: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7C74: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA7C78: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7C7C: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7C80: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7C84: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7C88: 7D6B5379  or. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA7C8C: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA7C90: 418201B0  beq 0x82ea7e40
	if ctx.cr[0].eq {
	pc = 0x82EA7E40; continue 'dispatch;
	}
	// 82EA7C94: 557E083C  slwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82EA7C98: 7F1E8840  cmplw cr6, r30, r17
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[17].u32, &mut ctx.xer);
	// 82EA7C9C: 1C7E000C  mulli r3, r30, 0xc
	ctx.r[3].s32 = ((ctx.r[30].s32 as i64 * 12 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82EA7CA0: 40990008  ble cr6, 0x82ea7ca8
	if !ctx.cr[6].gt {
	pc = 0x82EA7CA8; continue 'dispatch;
	}
	// 82EA7CA4: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
            }
            0x82EA7CA8 => {
    //   block [0x82EA7CA8..0x82EA7CC0)
	// 82EA7CA8: 4B76EC81  bl 0x82616928
	ctx.lr = 0x82EA7CAC;
	sub_82616928(ctx, base);
	// 82EA7CAC: 7C6A1B79  or. r10, r3, r3
	ctx.r[10].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA7CB0: 4182002C  beq 0x82ea7cdc
	if ctx.cr[0].eq {
	pc = 0x82EA7CDC; continue 'dispatch;
	}
	// 82EA7CB4: 353EFFFF  addic. r9, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EA7CB8: 41800028  blt 0x82ea7ce0
	if ctx.cr[0].lt {
	pc = 0x82EA7CE0; continue 'dispatch;
	}
	// 82EA7CBC: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	pc = 0x82EA7CC0; continue 'dispatch;
            }
            0x82EA7CC0 => {
    //   block [0x82EA7CC0..0x82EA7CDC)
	// 82EA7CC0: D3EBFFF8  stfs f31, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EA7CC4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EA7CC8: D3EBFFFC  stfs f31, -4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EA7CCC: D3EB0000  stfs f31, 0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EA7CD0: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EA7CD4: 4080FFEC  bge 0x82ea7cc0
	if !ctx.cr[0].lt {
	pc = 0x82EA7CC0; continue 'dispatch;
	}
	// 82EA7CD8: 48000008  b 0x82ea7ce0
	pc = 0x82EA7CE0; continue 'dispatch;
            }
            0x82EA7CDC => {
    //   block [0x82EA7CDC..0x82EA7CE0)
	// 82EA7CDC: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	pc = 0x82EA7CE0; continue 'dispatch;
            }
            0x82EA7CE0 => {
    //   block [0x82EA7CE0..0x82EA7CF8)
	// 82EA7CE0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7CE4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82EA7CE8: 7F0B9840  cmplw cr6, r11, r19
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82EA7CEC: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA7CF0: 40990008  ble cr6, 0x82ea7cf8
	if !ctx.cr[6].gt {
	pc = 0x82EA7CF8; continue 'dispatch;
	}
	// 82EA7CF4: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	pc = 0x82EA7CF8; continue 'dispatch;
            }
            0x82EA7CF8 => {
    //   block [0x82EA7CF8..0x82EA7D14)
	// 82EA7CF8: 4B76EC31  bl 0x82616928
	ctx.lr = 0x82EA7CFC;
	sub_82616928(ctx, base);
	// 82EA7CFC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7D00: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 82EA7D04: 907F002C  stw r3, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 82EA7D08: 556B083D  rlwinm. r11, r11, 1, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA7D0C: 4182013C  beq 0x82ea7e48
	if ctx.cr[0].eq {
	pc = 0x82EA7E48; continue 'dispatch;
	}
	// 82EA7D10: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	pc = 0x82EA7D14; continue 'dispatch;
            }
            0x82EA7D14 => {
    //   block [0x82EA7D14..0x82EA7E40)
	// 82EA7D14: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7D18: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7D1C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EA7D20: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7D24: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7D28: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7D2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA7D30: 4E800421  bctrl
	ctx.lr = 0x82EA7D34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7D34: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7D38: 409A1470  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7D3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA7D40: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7D44: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7D48: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EA7D4C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7D50: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA7D54: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7D58: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7D5C: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7D60: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7D64: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7D68: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7D6C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA7D70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7D74: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EA7D78: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA7D7C: 4E800421  bctrl
	ctx.lr = 0x82EA7D80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7D80: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7D84: 409A1424  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7D88: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA7D8C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7D90: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7D94: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EA7D98: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7D9C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA7DA0: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7DA4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7DA8: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7DAC: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7DB0: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7DB4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7DB8: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA7DBC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7DC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EA7DC4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA7DC8: 4E800421  bctrl
	ctx.lr = 0x82EA7DCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7DCC: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7DD0: 409A13D8  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7DD4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA7DD8: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA7DDC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EA7DE0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7DE4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA7DE8: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7DEC: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7DF0: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7DF4: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7DF8: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA7DFC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EA7E00: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA7E04: 7C1E5D2E  stfsx f0, r30, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82EA7E08: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA7E0C: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA7E10: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA7E14: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EA7E18: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA7E1C: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA7E20: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA7E24: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82EA7E28: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EA7E2C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7E30: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA7E34: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA7E38: 4198FEDC  blt cr6, 0x82ea7d14
	if ctx.cr[6].lt {
	pc = 0x82EA7D14; continue 'dispatch;
	}
	// 82EA7E3C: 4800000C  b 0x82ea7e48
	pc = 0x82EA7E48; continue 'dispatch;
            }
            0x82EA7E40 => {
    //   block [0x82EA7E40..0x82EA7E48)
	// 82EA7E40: 931F0028  stw r24, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[24].u32 ) };
	// 82EA7E44: 931F002C  stw r24, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[24].u32 ) };
	pc = 0x82EA7E48; continue 'dispatch;
            }
            0x82EA7E48 => {
    //   block [0x82EA7E48..0x82EA7EBC)
	// 82EA7E48: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA7E4C: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82EA7E50: 419805F0  blt cr6, 0x82ea8440
	if ctx.cr[6].lt {
	pc = 0x82EA8440; continue 'dispatch;
	}
	// 82EA7E54: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7E58: 3B5F0030  addi r26, r31, 0x30
	ctx.r[26].s64 = ctx.r[31].s64 + 48;
	// 82EA7E5C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7E60: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7E64: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7E68: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EA7E6C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7E70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA7E74: 4E800421  bctrl
	ctx.lr = 0x82EA7E78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7E78: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7E7C: 409A132C  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7E80: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7E84: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA7E88: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA7E8C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7E90: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7E94: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA7E98: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7E9C: 7D6B5379  or. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA7EA0: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA7EA4: 41820594  beq 0x82ea8438
	if ctx.cr[0].eq {
	pc = 0x82EA8438; continue 'dispatch;
	}
	// 82EA7EA8: 557E083C  slwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82EA7EAC: 7F1E8840  cmplw cr6, r30, r17
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[17].u32, &mut ctx.xer);
	// 82EA7EB0: 1C7E000C  mulli r3, r30, 0xc
	ctx.r[3].s32 = ((ctx.r[30].s32 as i64 * 12 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82EA7EB4: 40990008  ble cr6, 0x82ea7ebc
	if !ctx.cr[6].gt {
	pc = 0x82EA7EBC; continue 'dispatch;
	}
	// 82EA7EB8: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
            }
            0x82EA7EBC => {
    //   block [0x82EA7EBC..0x82EA7ED4)
	// 82EA7EBC: 4B76EA6D  bl 0x82616928
	ctx.lr = 0x82EA7EC0;
	sub_82616928(ctx, base);
	// 82EA7EC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA7EC4: 41820030  beq 0x82ea7ef4
	if ctx.cr[0].eq {
	pc = 0x82EA7EF4; continue 'dispatch;
	}
	// 82EA7EC8: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA7ECC: 41800020  blt 0x82ea7eec
	if ctx.cr[0].lt {
	pc = 0x82EA7EEC; continue 'dispatch;
	}
	// 82EA7ED0: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	pc = 0x82EA7ED4; continue 'dispatch;
            }
            0x82EA7ED4 => {
    //   block [0x82EA7ED4..0x82EA7EEC)
	// 82EA7ED4: D3EBFFF8  stfs f31, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EA7ED8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA7EDC: D3EBFFFC  stfs f31, -4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EA7EE0: D3EB0000  stfs f31, 0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EA7EE4: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EA7EE8: 4080FFEC  bge 0x82ea7ed4
	if !ctx.cr[0].lt {
	pc = 0x82EA7ED4; continue 'dispatch;
	}
	pc = 0x82EA7EEC; continue 'dispatch;
            }
            0x82EA7EEC => {
    //   block [0x82EA7EEC..0x82EA7EF4)
	// 82EA7EEC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EA7EF0: 48000008  b 0x82ea7ef8
	pc = 0x82EA7EF8; continue 'dispatch;
            }
            0x82EA7EF4 => {
    //   block [0x82EA7EF4..0x82EA7EF8)
	// 82EA7EF4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x82EA7EF8; continue 'dispatch;
            }
            0x82EA7EF8 => {
    //   block [0x82EA7EF8..0x82EA7F18)
	// 82EA7EF8: 3D400924  lis r10, 0x924
	ctx.r[10].s64 = 153354240;
	// 82EA7EFC: 83DA0000  lwz r30, 0(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7F00: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82EA7F04: 614A9249  ori r10, r10, 0x9249
	ctx.r[10].u64 = ctx.r[10].u64 | 37449;
	// 82EA7F08: 1C7E001C  mulli r3, r30, 0x1c
	ctx.r[3].s32 = ((ctx.r[30].s32 as i64 * 28 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82EA7F0C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EA7F10: 40990008  ble cr6, 0x82ea7f18
	if !ctx.cr[6].gt {
	pc = 0x82EA7F18; continue 'dispatch;
	}
	// 82EA7F14: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	pc = 0x82EA7F18; continue 'dispatch;
            }
            0x82EA7F18 => {
    //   block [0x82EA7F18..0x82EA7F30)
	// 82EA7F18: 4B76EA11  bl 0x82616928
	ctx.lr = 0x82EA7F1C;
	sub_82616928(ctx, base);
	// 82EA7F1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA7F20: 41820040  beq 0x82ea7f60
	if ctx.cr[0].eq {
	pc = 0x82EA7F60; continue 'dispatch;
	}
	// 82EA7F24: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA7F28: 41800030  blt 0x82ea7f58
	if ctx.cr[0].lt {
	pc = 0x82EA7F58; continue 'dispatch;
	}
	// 82EA7F2C: 39630018  addi r11, r3, 0x18
	ctx.r[11].s64 = ctx.r[3].s64 + 24;
	pc = 0x82EA7F30; continue 'dispatch;
            }
            0x82EA7F30 => {
    //   block [0x82EA7F30..0x82EA7F58)
	// 82EA7F30: 920BFFE8  stw r16, -0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-24 as u32), ctx.r[16].u32 ) };
	// 82EA7F34: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA7F38: 920BFFEC  stw r16, -0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), ctx.r[16].u32 ) };
	// 82EA7F3C: 920BFFF0  stw r16, -0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), ctx.r[16].u32 ) };
	// 82EA7F40: 920BFFF4  stw r16, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[16].u32 ) };
	// 82EA7F44: D3CBFFF8  stfs f30, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EA7F48: D3EBFFFC  stfs f31, -4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EA7F4C: D3EB0000  stfs f31, 0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EA7F50: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 82EA7F54: 4080FFDC  bge 0x82ea7f30
	if !ctx.cr[0].lt {
	pc = 0x82EA7F30; continue 'dispatch;
	}
	pc = 0x82EA7F58; continue 'dispatch;
            }
            0x82EA7F58 => {
    //   block [0x82EA7F58..0x82EA7F60)
	// 82EA7F58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EA7F5C: 48000008  b 0x82ea7f64
	pc = 0x82EA7F64; continue 'dispatch;
            }
            0x82EA7F60 => {
    //   block [0x82EA7F60..0x82EA7F64)
	// 82EA7F60: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x82EA7F64; continue 'dispatch;
            }
            0x82EA7F64 => {
    //   block [0x82EA7F64..0x82EA7F80)
	// 82EA7F64: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7F68: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 82EA7F6C: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82EA7F70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA7F74: 409904CC  ble cr6, 0x82ea8440
	if !ctx.cr[6].gt {
	pc = 0x82EA8440; continue 'dispatch;
	}
	// 82EA7F78: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82EA7F7C: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	pc = 0x82EA7F80; continue 'dispatch;
            }
            0x82EA7F80 => {
    //   block [0x82EA7F80..0x82EA8438)
	// 82EA7F80: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7F84: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7F88: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA7F8C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7F90: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7F94: 7CBD5A14  add r5, r29, r11
	ctx.r[5].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82EA7F98: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7F9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA7FA0: 4E800421  bctrl
	ctx.lr = 0x82EA7FA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7FA4: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA7FA8: 409A1200  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA7FAC: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA7FB0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA7FB4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA7FB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA7FBC: 7D7D502E  lwzx r11, r29, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA7FC0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA7FC4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA7FC8: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA7FCC: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA7FD0: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA7FD4: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA7FD8: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA7FDC: 7D7D512E  stwx r11, r29, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82EA7FE0: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA7FE4: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA7FE8: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82EA7FEC: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA7FF0: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 82EA7FF4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA7FF8: 4E800421  bctrl
	ctx.lr = 0x82EA7FFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA7FFC: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8000: 409A11A8  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8004: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA8008: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA800C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8010: 7D5D5A14  add r10, r29, r11
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82EA8014: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8018: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA801C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA8020: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8024: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8028: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA802C: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA8030: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8034: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA8038: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EA803C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8040: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA8044: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82EA8048: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA804C: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 82EA8050: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA8054: 4E800421  bctrl
	ctx.lr = 0x82EA8058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8058: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA805C: 409A114C  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8060: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA8064: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8068: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA806C: 7D5D5A14  add r10, r29, r11
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82EA8070: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8074: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA8078: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA807C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8080: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8084: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8088: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA808C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8090: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA8094: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EA8098: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA809C: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA80A0: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82EA80A4: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA80A8: 38AB000C  addi r5, r11, 0xc
	ctx.r[5].s64 = ctx.r[11].s64 + 12;
	// 82EA80AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA80B0: 4E800421  bctrl
	ctx.lr = 0x82EA80B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA80B4: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA80B8: 409A10F0  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA80BC: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA80C0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA80C4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA80C8: 7D5D5A14  add r10, r29, r11
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82EA80CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA80D0: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA80D4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA80D8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA80DC: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA80E0: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA80E4: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA80E8: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA80EC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA80F0: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EA80F4: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA80F8: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA80FC: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82EA8100: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8104: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 82EA8108: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA810C: 4E800421  bctrl
	ctx.lr = 0x82EA8110;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8110: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8114: 409A1094  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8118: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA811C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8120: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8124: 7D5D5A14  add r10, r29, r11
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82EA8128: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA812C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA8130: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA8134: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8138: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA813C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8140: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA8144: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8148: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA814C: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EA8150: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8154: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA8158: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82EA815C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8160: 38AB0014  addi r5, r11, 0x14
	ctx.r[5].s64 = ctx.r[11].s64 + 20;
	// 82EA8164: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA8168: 4E800421  bctrl
	ctx.lr = 0x82EA816C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA816C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8170: 409A1038  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8174: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA8178: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA817C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8180: 7D5D5A14  add r10, r29, r11
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82EA8184: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8188: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA818C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA8190: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8194: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8198: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA819C: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA81A0: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA81A4: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA81A8: 916A0014  stw r11, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EA81AC: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA81B0: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA81B4: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA81B8: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA81BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA81C0: 4E800421  bctrl
	ctx.lr = 0x82EA81C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA81C4: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA81C8: 409A0FE0  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA81CC: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA81D0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA81D4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA81D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA81DC: 7D7E502E  lwzx r11, r30, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA81E0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA81E4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA81E8: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA81EC: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA81F0: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA81F4: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA81F8: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA81FC: 7D7E512E  stwx r11, r30, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82EA8200: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8204: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA8208: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA820C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8210: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 82EA8214: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA8218: 4E800421  bctrl
	ctx.lr = 0x82EA821C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA821C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8220: 409A0F88  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8224: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA8228: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA822C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8230: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA8234: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8238: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EA823C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA8240: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8244: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8248: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA824C: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA8250: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8254: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA8258: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EA825C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8260: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA8264: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA8268: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA826C: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 82EA8270: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA8274: 4E800421  bctrl
	ctx.lr = 0x82EA8278;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8278: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA827C: 409A0F2C  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8280: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA8284: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8288: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA828C: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA8290: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8294: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EA8298: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA829C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA82A0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA82A4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA82A8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA82AC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA82B0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA82B4: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EA82B8: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA82BC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA82C0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA82C4: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA82C8: 38AB000C  addi r5, r11, 0xc
	ctx.r[5].s64 = ctx.r[11].s64 + 12;
	// 82EA82CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA82D0: 4E800421  bctrl
	ctx.lr = 0x82EA82D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA82D4: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA82D8: 409A0ED0  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA82DC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA82E0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA82E4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA82E8: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA82EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA82F0: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA82F4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA82F8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA82FC: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8300: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8304: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA8308: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA830C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA8310: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EA8314: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8318: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA831C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA8320: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8324: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 82EA8328: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA832C: 4E800421  bctrl
	ctx.lr = 0x82EA8330;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8330: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8334: 409A0E74  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8338: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA833C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8340: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8344: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA8348: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA834C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EA8350: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA8354: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8358: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA835C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8360: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA8364: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8368: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA836C: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EA8370: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8374: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA8378: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA837C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8380: 38AB0014  addi r5, r11, 0x14
	ctx.r[5].s64 = ctx.r[11].s64 + 20;
	// 82EA8384: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA8388: 4E800421  bctrl
	ctx.lr = 0x82EA838C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA838C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8390: 409A0E18  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8394: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA8398: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA839C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA83A0: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA83A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA83A8: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EA83AC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA83B0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA83B4: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA83B8: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA83BC: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA83C0: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA83C4: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA83C8: 916A0014  stw r11, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EA83CC: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA83D0: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA83D4: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA83D8: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA83DC: 38AB0018  addi r5, r11, 0x18
	ctx.r[5].s64 = ctx.r[11].s64 + 24;
	// 82EA83E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA83E4: 4E800421  bctrl
	ctx.lr = 0x82EA83E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA83E8: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA83EC: 409A0DBC  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA83F0: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA83F4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EA83F8: 3BBD0018  addi r29, r29, 0x18
	ctx.r[29].s64 = ctx.r[29].s64 + 24;
	// 82EA83FC: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA8400: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82EA8404: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA8408: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA840C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8410: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8414: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8418: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA841C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8420: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA8424: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EA8428: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA842C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA8430: 4198FB50  blt cr6, 0x82ea7f80
	if ctx.cr[6].lt {
	pc = 0x82EA7F80; continue 'dispatch;
	}
	// 82EA8434: 4800000C  b 0x82ea8440
	pc = 0x82EA8440; continue 'dispatch;
            }
            0x82EA8438 => {
    //   block [0x82EA8438..0x82EA8440)
	// 82EA8438: 931F0034  stw r24, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[24].u32 ) };
	// 82EA843C: 931F0038  stw r24, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[24].u32 ) };
	pc = 0x82EA8440; continue 'dispatch;
            }
            0x82EA8440 => {
    //   block [0x82EA8440..0x82EA84A4)
	// 82EA8440: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8444: 3B5F003C  addi r26, r31, 0x3c
	ctx.r[26].s64 = ctx.r[31].s64 + 60;
	// 82EA8448: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA844C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8450: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8454: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EA8458: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA845C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA8460: 4E800421  bctrl
	ctx.lr = 0x82EA8464;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8464: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8468: 409A0D40  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA846C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8470: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA8474: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA8478: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA847C: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8480: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8484: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8488: 7D6B5379  or. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA848C: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA8490: 41820260  beq 0x82ea86f0
	if ctx.cr[0].eq {
	pc = 0x82EA86F0; continue 'dispatch;
	}
	// 82EA8494: 7F0B9840  cmplw cr6, r11, r19
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82EA8498: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA849C: 40990008  ble cr6, 0x82ea84a4
	if !ctx.cr[6].gt {
	pc = 0x82EA84A4; continue 'dispatch;
	}
	// 82EA84A0: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
            }
            0x82EA84A4 => {
    //   block [0x82EA84A4..0x82EA84C0)
	// 82EA84A4: 4B76E485  bl 0x82616928
	ctx.lr = 0x82EA84A8;
	sub_82616928(ctx, base);
	// 82EA84A8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA84AC: 907F0044  stw r3, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 82EA84B0: 7F0B9840  cmplw cr6, r11, r19
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82EA84B4: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA84B8: 40990008  ble cr6, 0x82ea84c0
	if !ctx.cr[6].gt {
	pc = 0x82EA84C0; continue 'dispatch;
	}
	// 82EA84BC: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	pc = 0x82EA84C0; continue 'dispatch;
            }
            0x82EA84C0 => {
    //   block [0x82EA84C0..0x82EA84DC)
	// 82EA84C0: 4B76E469  bl 0x82616928
	ctx.lr = 0x82EA84C4;
	sub_82616928(ctx, base);
	// 82EA84C4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA84C8: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 82EA84CC: 907F0040  stw r3, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[3].u32 ) };
	// 82EA84D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA84D4: 40990224  ble cr6, 0x82ea86f8
	if !ctx.cr[6].gt {
	pc = 0x82EA86F8; continue 'dispatch;
	}
	// 82EA84D8: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	pc = 0x82EA84DC; continue 'dispatch;
            }
            0x82EA84DC => {
    //   block [0x82EA84DC..0x82EA8548)
	// 82EA84DC: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA84E0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA84E4: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EA84E8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA84EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA84F0: 7CABF214  add r5, r11, r30
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EA84F4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA84F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA84FC: 4E800421  bctrl
	ctx.lr = 0x82EA8500;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8500: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8504: 409A0CA4  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8508: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EA850C: 7D6AF02E  lwzx r11, r10, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA8510: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA8514: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8518: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA851C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8520: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA8524: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8528: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA852C: 7D6AF12E  stwx r11, r10, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u32) };
	// 82EA8530: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EA8534: 7FABF02E  lwzx r29, r11, r30
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA8538: 7F1D8840  cmplw cr6, r29, r17
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[17].u32, &mut ctx.xer);
	// 82EA853C: 1C7D000C  mulli r3, r29, 0xc
	ctx.r[3].s32 = ((ctx.r[29].s32 as i64 * 12 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82EA8540: 40990008  ble cr6, 0x82ea8548
	if !ctx.cr[6].gt {
	pc = 0x82EA8548; continue 'dispatch;
	}
	// 82EA8544: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
            }
            0x82EA8548 => {
    //   block [0x82EA8548..0x82EA8560)
	// 82EA8548: 4B76E3E1  bl 0x82616928
	ctx.lr = 0x82EA854C;
	sub_82616928(ctx, base);
	// 82EA854C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA8550: 41820030  beq 0x82ea8580
	if ctx.cr[0].eq {
	pc = 0x82EA8580; continue 'dispatch;
	}
	// 82EA8554: 355DFFFF  addic. r10, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA8558: 41800020  blt 0x82ea8578
	if ctx.cr[0].lt {
	pc = 0x82EA8578; continue 'dispatch;
	}
	// 82EA855C: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	pc = 0x82EA8560; continue 'dispatch;
            }
            0x82EA8560 => {
    //   block [0x82EA8560..0x82EA8578)
	// 82EA8560: D3EBFFF8  stfs f31, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EA8564: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA8568: D3EBFFFC  stfs f31, -4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EA856C: D3EB0000  stfs f31, 0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EA8570: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EA8574: 4080FFEC  bge 0x82ea8560
	if !ctx.cr[0].lt {
	pc = 0x82EA8560; continue 'dispatch;
	}
	pc = 0x82EA8578; continue 'dispatch;
            }
            0x82EA8578 => {
    //   block [0x82EA8578..0x82EA8580)
	// 82EA8578: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EA857C: 48000008  b 0x82ea8584
	pc = 0x82EA8584; continue 'dispatch;
            }
            0x82EA8580 => {
    //   block [0x82EA8580..0x82EA8584)
	// 82EA8580: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x82EA8584; continue 'dispatch;
            }
            0x82EA8584 => {
    //   block [0x82EA8584..0x82EA85A4)
	// 82EA8584: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA8588: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 82EA858C: 7D6AF12E  stwx r11, r10, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u32) };
	// 82EA8590: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EA8594: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA8598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA859C: 4099013C  ble cr6, 0x82ea86d8
	if !ctx.cr[6].gt {
	pc = 0x82EA86D8; continue 'dispatch;
	}
	// 82EA85A0: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	pc = 0x82EA85A4; continue 'dispatch;
            }
            0x82EA85A4 => {
    //   block [0x82EA85A4..0x82EA86D8)
	// 82EA85A4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA85A8: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA85AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EA85B0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA85B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA85B8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA85BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA85C0: 4E800421  bctrl
	ctx.lr = 0x82EA85C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA85C4: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA85C8: 409A0BE0  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA85CC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA85D0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA85D4: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA85D8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EA85DC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA85E0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA85E4: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA85E8: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA85EC: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA85F0: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA85F4: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA85F8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA85FC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA8600: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8604: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EA8608: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA860C: 4E800421  bctrl
	ctx.lr = 0x82EA8610;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8610: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8614: 409A0B94  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8618: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA861C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8620: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8624: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EA8628: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA862C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8630: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8634: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8638: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA863C: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8640: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8644: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8648: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA864C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8650: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EA8654: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA8658: 4E800421  bctrl
	ctx.lr = 0x82EA865C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA865C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8660: 409A0B48  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8664: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA8668: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA866C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EA8670: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA8674: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA8678: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA867C: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8680: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8684: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8688: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA868C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EA8690: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA8694: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA8698: 7C0BED2E  stfsx f0, r11, r29
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), tmp.u32) };
	// 82EA869C: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA86A0: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA86A4: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA86A8: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EA86AC: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EA86B0: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA86B4: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA86B8: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA86BC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EA86C0: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82EA86C4: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EA86C8: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EA86CC: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA86D0: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA86D4: 4198FED0  blt cr6, 0x82ea85a4
	if ctx.cr[6].lt {
	pc = 0x82EA85A4; continue 'dispatch;
	}
            }
            0x82EA86D8 => {
    //   block [0x82EA86D8..0x82EA86F0)
	// 82EA86D8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA86DC: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82EA86E0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EA86E4: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA86E8: 4198FDF4  blt cr6, 0x82ea84dc
	if ctx.cr[6].lt {
	pc = 0x82EA84DC; continue 'dispatch;
	}
	// 82EA86EC: 4800000C  b 0x82ea86f8
	pc = 0x82EA86F8; continue 'dispatch;
            }
            0x82EA86F0 => {
    //   block [0x82EA86F0..0x82EA86F8)
	// 82EA86F0: 931F0040  stw r24, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[24].u32 ) };
	// 82EA86F4: 931F0044  stw r24, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[24].u32 ) };
	pc = 0x82EA86F8; continue 'dispatch;
            }
            0x82EA86F8 => {
    //   block [0x82EA86F8..0x82EA875C)
	// 82EA86F8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA86FC: 3B5F0048  addi r26, r31, 0x48
	ctx.r[26].s64 = ctx.r[31].s64 + 72;
	// 82EA8700: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8704: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8708: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA870C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EA8710: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8714: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA8718: 4E800421  bctrl
	ctx.lr = 0x82EA871C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA871C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8720: 409A0A88  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8724: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8728: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA872C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA8730: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8734: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8738: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA873C: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8740: 7D6B5379  or. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA8744: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA8748: 41820274  beq 0x82ea89bc
	if ctx.cr[0].eq {
	pc = 0x82EA89BC; continue 'dispatch;
	}
	// 82EA874C: 7F0B9840  cmplw cr6, r11, r19
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82EA8750: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA8754: 40990008  ble cr6, 0x82ea875c
	if !ctx.cr[6].gt {
	pc = 0x82EA875C; continue 'dispatch;
	}
	// 82EA8758: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
            }
            0x82EA875C => {
    //   block [0x82EA875C..0x82EA8778)
	// 82EA875C: 4B76E1CD  bl 0x82616928
	ctx.lr = 0x82EA8760;
	sub_82616928(ctx, base);
	// 82EA8760: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8764: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EA8768: 7F0B9840  cmplw cr6, r11, r19
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82EA876C: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA8770: 40990008  ble cr6, 0x82ea8778
	if !ctx.cr[6].gt {
	pc = 0x82EA8778; continue 'dispatch;
	}
	// 82EA8774: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	pc = 0x82EA8778; continue 'dispatch;
            }
            0x82EA8778 => {
    //   block [0x82EA8778..0x82EA8794)
	// 82EA8778: 4B76E1B1  bl 0x82616928
	ctx.lr = 0x82EA877C;
	sub_82616928(ctx, base);
	// 82EA877C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8780: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 82EA8784: 907F004C  stw r3, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[3].u32 ) };
	// 82EA8788: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA878C: 40990238  ble cr6, 0x82ea89c4
	if !ctx.cr[6].gt {
	pc = 0x82EA89C4; continue 'dispatch;
	}
	// 82EA8790: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	pc = 0x82EA8794; continue 'dispatch;
            }
            0x82EA8794 => {
    //   block [0x82EA8794..0x82EA8804)
	// 82EA8794: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8798: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA879C: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA87A0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA87A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA87A8: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA87AC: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA87B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA87B4: 4E800421  bctrl
	ctx.lr = 0x82EA87B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA87B8: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA87BC: 409A09EC  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA87C0: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA87C4: 7D7E502E  lwzx r11, r30, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA87C8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA87CC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA87D0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA87D4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA87D8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA87DC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA87E0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA87E4: 7D7E512E  stwx r11, r30, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82EA87E8: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA87EC: 7FBE582E  lwzx r29, r30, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA87F0: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA87F4: 40820010  bne 0x82ea8804
	if !ctx.cr[0].eq {
	pc = 0x82EA8804; continue 'dispatch;
	}
	// 82EA87F8: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA87FC: 7F1E592E  stwx r24, r30, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), ctx.r[24].u32) };
	// 82EA8800: 48000058  b 0x82ea8858
	pc = 0x82EA8858; continue 'dispatch;
            }
            0x82EA8804 => {
    //   block [0x82EA8804..0x82EA8814)
	// 82EA8804: 7F1D8840  cmplw cr6, r29, r17
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[17].u32, &mut ctx.xer);
	// 82EA8808: 1C7D000C  mulli r3, r29, 0xc
	ctx.r[3].s32 = ((ctx.r[29].s32 as i64 * 12 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82EA880C: 40990008  ble cr6, 0x82ea8814
	if !ctx.cr[6].gt {
	pc = 0x82EA8814; continue 'dispatch;
	}
	// 82EA8810: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	pc = 0x82EA8814; continue 'dispatch;
            }
            0x82EA8814 => {
    //   block [0x82EA8814..0x82EA882C)
	// 82EA8814: 4B76E115  bl 0x82616928
	ctx.lr = 0x82EA8818;
	sub_82616928(ctx, base);
	// 82EA8818: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA881C: 41820030  beq 0x82ea884c
	if ctx.cr[0].eq {
	pc = 0x82EA884C; continue 'dispatch;
	}
	// 82EA8820: 355DFFFF  addic. r10, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA8824: 41800020  blt 0x82ea8844
	if ctx.cr[0].lt {
	pc = 0x82EA8844; continue 'dispatch;
	}
	// 82EA8828: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	pc = 0x82EA882C; continue 'dispatch;
            }
            0x82EA882C => {
    //   block [0x82EA882C..0x82EA8844)
	// 82EA882C: D3EBFFF8  stfs f31, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EA8830: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA8834: D3EBFFFC  stfs f31, -4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EA8838: D3EB0000  stfs f31, 0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EA883C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EA8840: 4080FFEC  bge 0x82ea882c
	if !ctx.cr[0].lt {
	pc = 0x82EA882C; continue 'dispatch;
	}
	pc = 0x82EA8844; continue 'dispatch;
            }
            0x82EA8844 => {
    //   block [0x82EA8844..0x82EA884C)
	// 82EA8844: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EA8848: 48000008  b 0x82ea8850
	pc = 0x82EA8850; continue 'dispatch;
            }
            0x82EA884C => {
    //   block [0x82EA884C..0x82EA8850)
	// 82EA884C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x82EA8850; continue 'dispatch;
            }
            0x82EA8850 => {
    //   block [0x82EA8850..0x82EA8858)
	// 82EA8850: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA8854: 7D7E512E  stwx r11, r30, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	pc = 0x82EA8858; continue 'dispatch;
            }
            0x82EA8858 => {
    //   block [0x82EA8858..0x82EA8870)
	// 82EA8858: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA885C: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 82EA8860: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA8864: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA8868: 4099013C  ble cr6, 0x82ea89a4
	if !ctx.cr[6].gt {
	pc = 0x82EA89A4; continue 'dispatch;
	}
	// 82EA886C: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	pc = 0x82EA8870; continue 'dispatch;
            }
            0x82EA8870 => {
    //   block [0x82EA8870..0x82EA89A4)
	// 82EA8870: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8874: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8878: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EA887C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8880: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8884: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8888: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA888C: 4E800421  bctrl
	ctx.lr = 0x82EA8890;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8890: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8894: 409A0914  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8898: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA889C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA88A0: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA88A4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EA88A8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA88AC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA88B0: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA88B4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA88B8: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA88BC: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA88C0: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA88C4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA88C8: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA88CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA88D0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EA88D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA88D8: 4E800421  bctrl
	ctx.lr = 0x82EA88DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA88DC: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA88E0: 409A08C8  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA88E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA88E8: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA88EC: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA88F0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EA88F4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA88F8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA88FC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8900: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8904: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8908: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA890C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8910: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8914: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA8918: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA891C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EA8920: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA8924: 4E800421  bctrl
	ctx.lr = 0x82EA8928;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8928: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA892C: 409A087C  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8930: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA8934: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA8938: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EA893C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA8940: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA8944: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8948: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA894C: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8950: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8954: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA8958: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EA895C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA8960: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA8964: 7C0BED2E  stfsx f0, r11, r29
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), tmp.u32) };
	// 82EA8968: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA896C: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA8970: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA8974: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EA8978: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EA897C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA8980: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA8984: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA8988: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EA898C: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82EA8990: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EA8994: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA8998: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA899C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA89A0: 4198FED0  blt cr6, 0x82ea8870
	if ctx.cr[6].lt {
	pc = 0x82EA8870; continue 'dispatch;
	}
            }
            0x82EA89A4 => {
    //   block [0x82EA89A4..0x82EA89BC)
	// 82EA89A4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA89A8: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82EA89AC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EA89B0: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA89B4: 4198FDE0  blt cr6, 0x82ea8794
	if ctx.cr[6].lt {
	pc = 0x82EA8794; continue 'dispatch;
	}
	// 82EA89B8: 4800000C  b 0x82ea89c4
	pc = 0x82EA89C4; continue 'dispatch;
            }
            0x82EA89BC => {
    //   block [0x82EA89BC..0x82EA89C4)
	// 82EA89BC: 931F004C  stw r24, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[24].u32 ) };
	// 82EA89C0: 931F0050  stw r24, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	pc = 0x82EA89C4; continue 'dispatch;
            }
            0x82EA89C4 => {
    //   block [0x82EA89C4..0x82EA8A28)
	// 82EA89C4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA89C8: 3B1F0054  addi r24, r31, 0x54
	ctx.r[24].s64 = ctx.r[31].s64 + 84;
	// 82EA89CC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA89D0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA89D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA89D8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82EA89DC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA89E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA89E4: 4E800421  bctrl
	ctx.lr = 0x82EA89E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA89E8: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA89EC: 409A07BC  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA89F0: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA89F4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA89F8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA89FC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8A00: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8A04: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8A08: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8A0C: 7D6B5379  or. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA8A10: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA8A14: 418203C8  beq 0x82ea8ddc
	if ctx.cr[0].eq {
	pc = 0x82EA8DDC; continue 'dispatch;
	}
	// 82EA8A18: 7F0B9840  cmplw cr6, r11, r19
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82EA8A1C: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA8A20: 40990008  ble cr6, 0x82ea8a28
	if !ctx.cr[6].gt {
	pc = 0x82EA8A28; continue 'dispatch;
	}
	// 82EA8A24: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
            }
            0x82EA8A28 => {
    //   block [0x82EA8A28..0x82EA8A44)
	// 82EA8A28: 4B76DF01  bl 0x82616928
	ctx.lr = 0x82EA8A2C;
	sub_82616928(ctx, base);
	// 82EA8A2C: 83D80000  lwz r30, 0(r24)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8A30: 907F005C  stw r3, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82EA8A34: 7F1E8840  cmplw cr6, r30, r17
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[17].u32, &mut ctx.xer);
	// 82EA8A38: 1C7E000C  mulli r3, r30, 0xc
	ctx.r[3].s32 = ((ctx.r[30].s32 as i64 * 12 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82EA8A3C: 40990008  ble cr6, 0x82ea8a44
	if !ctx.cr[6].gt {
	pc = 0x82EA8A44; continue 'dispatch;
	}
	// 82EA8A40: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	pc = 0x82EA8A44; continue 'dispatch;
            }
            0x82EA8A44 => {
    //   block [0x82EA8A44..0x82EA8A5C)
	// 82EA8A44: 4B76DEE5  bl 0x82616928
	ctx.lr = 0x82EA8A48;
	sub_82616928(ctx, base);
	// 82EA8A48: 7C6A1B79  or. r10, r3, r3
	ctx.r[10].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA8A4C: 4182002C  beq 0x82ea8a78
	if ctx.cr[0].eq {
	pc = 0x82EA8A78; continue 'dispatch;
	}
	// 82EA8A50: 353EFFFF  addic. r9, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EA8A54: 41800028  blt 0x82ea8a7c
	if ctx.cr[0].lt {
	pc = 0x82EA8A7C; continue 'dispatch;
	}
	// 82EA8A58: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	pc = 0x82EA8A5C; continue 'dispatch;
            }
            0x82EA8A5C => {
    //   block [0x82EA8A5C..0x82EA8A78)
	// 82EA8A5C: D3EBFFF8  stfs f31, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EA8A60: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EA8A64: D3EBFFFC  stfs f31, -4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EA8A68: D3EB0000  stfs f31, 0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EA8A6C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EA8A70: 4080FFEC  bge 0x82ea8a5c
	if !ctx.cr[0].lt {
	pc = 0x82EA8A5C; continue 'dispatch;
	}
	// 82EA8A74: 48000008  b 0x82ea8a7c
	pc = 0x82EA8A7C; continue 'dispatch;
            }
            0x82EA8A78 => {
    //   block [0x82EA8A78..0x82EA8A7C)
	// 82EA8A78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82EA8A7C; continue 'dispatch;
            }
            0x82EA8A7C => {
    //   block [0x82EA8A7C..0x82EA8A94)
	// 82EA8A7C: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8A80: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82EA8A84: 7F0B9840  cmplw cr6, r11, r19
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82EA8A88: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EA8A8C: 40990008  ble cr6, 0x82ea8a94
	if !ctx.cr[6].gt {
	pc = 0x82EA8A94; continue 'dispatch;
	}
	// 82EA8A90: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	pc = 0x82EA8A94; continue 'dispatch;
            }
            0x82EA8A94 => {
    //   block [0x82EA8A94..0x82EA8AB4)
	// 82EA8A94: 4B76DE95  bl 0x82616928
	ctx.lr = 0x82EA8A98;
	sub_82616928(ctx, base);
	// 82EA8A98: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8A9C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EA8AA0: 907F0058  stw r3, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EA8AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA8AA8: 40990344  ble cr6, 0x82ea8dec
	if !ctx.cr[6].gt {
	pc = 0x82EA8DEC; continue 'dispatch;
	}
	// 82EA8AAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EA8AB0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	pc = 0x82EA8AB4; continue 'dispatch;
            }
            0x82EA8AB4 => {
    //   block [0x82EA8AB4..0x82EA8C30)
	// 82EA8AB4: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8AB8: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8ABC: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA8AC0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8AC4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8AC8: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EA8ACC: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8AD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA8AD4: 4E800421  bctrl
	ctx.lr = 0x82EA8AD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8AD8: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8ADC: 409A06CC  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8AE0: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA8AE4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8AE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EA8AEC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8AF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8AF4: 7D7E502E  lwzx r11, r30, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA8AF8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA8AFC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8B00: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8B04: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8B08: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EA8B0C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8B10: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA8B14: 7D7E512E  stwx r11, r30, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82EA8B18: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8B1C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8B20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA8B24: 4E800421  bctrl
	ctx.lr = 0x82EA8B28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8B28: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8B2C: 409A067C  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8B30: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA8B34: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8B38: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8B3C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EA8B40: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA8B44: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8B48: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8B4C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8B50: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8B54: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8B58: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8B5C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8B60: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA8B64: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8B68: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EA8B6C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA8B70: 4E800421  bctrl
	ctx.lr = 0x82EA8B74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8B74: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8B78: 409A0630  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8B7C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA8B80: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8B84: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8B88: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EA8B8C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA8B90: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8B94: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8B98: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8B9C: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8BA0: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8BA4: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8BA8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8BAC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA8BB0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8BB4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EA8BB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA8BBC: 4E800421  bctrl
	ctx.lr = 0x82EA8BC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8BC0: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8BC4: 409A05E4  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8BC8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA8BCC: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA8BD0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA8BD4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA8BD8: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8BDC: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8BE0: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8BE4: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8BE8: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA8BEC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EA8BF0: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA8BF4: 7C1A5D2E  stfsx f0, r26, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82EA8BF8: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA8BFC: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA8C00: 7D7A5A14  add r11, r26, r11
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 82EA8C04: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EA8C08: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA8C0C: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA8C10: 7D7A5A14  add r11, r26, r11
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 82EA8C14: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EA8C18: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA8C1C: 7FBE582E  lwzx r29, r30, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA8C20: 7F1D8840  cmplw cr6, r29, r17
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[17].u32, &mut ctx.xer);
	// 82EA8C24: 1C7D000C  mulli r3, r29, 0xc
	ctx.r[3].s32 = ((ctx.r[29].s32 as i64 * 12 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82EA8C28: 40990008  ble cr6, 0x82ea8c30
	if !ctx.cr[6].gt {
	pc = 0x82EA8C30; continue 'dispatch;
	}
	// 82EA8C2C: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
            }
            0x82EA8C30 => {
    //   block [0x82EA8C30..0x82EA8C48)
	// 82EA8C30: 4B76DCF9  bl 0x82616928
	ctx.lr = 0x82EA8C34;
	sub_82616928(ctx, base);
	// 82EA8C34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA8C38: 41820030  beq 0x82ea8c68
	if ctx.cr[0].eq {
	pc = 0x82EA8C68; continue 'dispatch;
	}
	// 82EA8C3C: 355DFFFF  addic. r10, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA8C40: 41800020  blt 0x82ea8c60
	if ctx.cr[0].lt {
	pc = 0x82EA8C60; continue 'dispatch;
	}
	// 82EA8C44: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	pc = 0x82EA8C48; continue 'dispatch;
            }
            0x82EA8C48 => {
    //   block [0x82EA8C48..0x82EA8C60)
	// 82EA8C48: D3EBFFF8  stfs f31, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EA8C4C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EA8C50: D3EBFFFC  stfs f31, -4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EA8C54: D3EB0000  stfs f31, 0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EA8C58: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EA8C5C: 4080FFEC  bge 0x82ea8c48
	if !ctx.cr[0].lt {
	pc = 0x82EA8C48; continue 'dispatch;
	}
	pc = 0x82EA8C60; continue 'dispatch;
            }
            0x82EA8C60 => {
    //   block [0x82EA8C60..0x82EA8C68)
	// 82EA8C60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EA8C64: 48000008  b 0x82ea8c6c
	pc = 0x82EA8C6C; continue 'dispatch;
            }
            0x82EA8C68 => {
    //   block [0x82EA8C68..0x82EA8C6C)
	// 82EA8C68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EA8C6C; continue 'dispatch;
            }
            0x82EA8C6C => {
    //   block [0x82EA8C6C..0x82EA8C8C)
	// 82EA8C6C: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA8C70: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EA8C74: 7D6AF12E  stwx r11, r10, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u32) };
	// 82EA8C78: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA8C7C: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA8C80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA8C84: 4099013C  ble cr6, 0x82ea8dc0
	if !ctx.cr[6].gt {
	pc = 0x82EA8DC0; continue 'dispatch;
	}
	// 82EA8C88: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82EA8C8C; continue 'dispatch;
            }
            0x82EA8C8C => {
    //   block [0x82EA8C8C..0x82EA8DC0)
	// 82EA8C8C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8C90: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8C94: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EA8C98: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8C9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8CA0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8CA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA8CA8: 4E800421  bctrl
	ctx.lr = 0x82EA8CAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8CAC: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8CB0: 409A04F8  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8CB4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA8CB8: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8CBC: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8CC0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EA8CC4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA8CC8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8CCC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8CD0: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8CD4: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8CD8: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8CDC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8CE0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8CE4: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA8CE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8CEC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EA8CF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA8CF4: 4E800421  bctrl
	ctx.lr = 0x82EA8CF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8CF8: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8CFC: 409A04AC  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8D00: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA8D04: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8D08: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8D0C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EA8D10: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA8D14: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8D18: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8D1C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8D20: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8D24: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8D28: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8D2C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8D30: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA8D34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8D38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EA8D3C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA8D40: 4E800421  bctrl
	ctx.lr = 0x82EA8D44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8D44: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8D48: 409A0460  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8D4C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA8D50: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA8D54: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EA8D58: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA8D5C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA8D60: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8D64: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8D68: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8D6C: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8D70: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA8D74: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EA8D78: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA8D7C: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA8D80: 7C0BED2E  stfsx f0, r11, r29
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), tmp.u32) };
	// 82EA8D84: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA8D88: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA8D8C: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA8D90: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EA8D94: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EA8D98: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA8D9C: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA8DA0: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EA8DA4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EA8DA8: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82EA8DAC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EA8DB0: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA8DB4: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA8DB8: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA8DBC: 4198FED0  blt cr6, 0x82ea8c8c
	if ctx.cr[6].lt {
	pc = 0x82EA8C8C; continue 'dispatch;
	}
            }
            0x82EA8DC0 => {
    //   block [0x82EA8DC0..0x82EA8DDC)
	// 82EA8DC0: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8DC4: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82EA8DC8: 3B5A000C  addi r26, r26, 0xc
	ctx.r[26].s64 = ctx.r[26].s64 + 12;
	// 82EA8DCC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EA8DD0: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA8DD4: 4198FCE0  blt cr6, 0x82ea8ab4
	if ctx.cr[6].lt {
	pc = 0x82EA8AB4; continue 'dispatch;
	}
	// 82EA8DD8: 48000014  b 0x82ea8dec
	pc = 0x82EA8DEC; continue 'dispatch;
            }
            0x82EA8DDC => {
    //   block [0x82EA8DDC..0x82EA8DEC)
	// 82EA8DDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EA8DE0: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EA8DE4: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EA8DE8: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x82EA8DEC; continue 'dispatch;
            }
            0x82EA8DEC => {
    //   block [0x82EA8DEC..0x82EA8E44)
	// 82EA8DEC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA8DF0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA8DF4: 409A0050  bne cr6, 0x82ea8e44
	if !ctx.cr[6].eq {
	pc = 0x82EA8E44; continue 'dispatch;
	}
	// 82EA8DF8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8DFC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8E00: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82EA8E04: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8E08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8E0C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8E10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA8E14: 4E800421  bctrl
	ctx.lr = 0x82EA8E18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8E18: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8E1C: 409A038C  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8E20: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EA8E24: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA8E28: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EA8E2C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8E30: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8E34: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8E38: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8E3C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA8E40: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
            }
            0x82EA8E44 => {
    //   block [0x82EA8E44..0x82EA8E60)
	// 82EA8E44: 8174002C  lwz r11, 0x2c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA8E48: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82EA8E4C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EA8E50: 7D72582E  lwzx r11, r18, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[18].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA8E54: 7D6BB02E  lwzx r11, r11, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82EA8E58: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA8E5C: 4198EB1C  blt cr6, 0x82ea7978
	if ctx.cr[6].lt {
	pc = 0x82EA7978; continue 'dispatch;
	}
	pc = 0x82EA8E60; continue 'dispatch;
            }
            0x82EA8E60 => {
    //   block [0x82EA8E60..0x82EA8E74)
	// 82EA8E60: 3B740024  addi r27, r20, 0x24
	ctx.r[27].s64 = ctx.r[20].s64 + 36;
	// 82EA8E64: 39EF0001  addi r15, r15, 1
	ctx.r[15].s64 = ctx.r[15].s64 + 1;
	// 82EA8E68: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8E6C: 7F0F5840  cmplw cr6, r15, r11
	ctx.cr[6].compare_u32(ctx.r[15].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA8E70: 4198EA08  blt cr6, 0x82ea7878
	if ctx.cr[6].lt {
	pc = 0x82EA7878; continue 'dispatch;
	}
	pc = 0x82EA8E74; continue 'dispatch;
            }
            0x82EA8E74 => {
    //   block [0x82EA8E74..0x82EA8E88)
	// 82EA8E74: 3BB40020  addi r29, r20, 0x20
	ctx.r[29].s64 = ctx.r[20].s64 + 32;
	// 82EA8E78: 39CE0001  addi r14, r14, 1
	ctx.r[14].s64 = ctx.r[14].s64 + 1;
	// 82EA8E7C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8E80: 7F0E5840  cmplw cr6, r14, r11
	ctx.cr[6].compare_u32(ctx.r[14].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA8E84: 4198E9E0  blt cr6, 0x82ea7864
	if ctx.cr[6].lt {
	pc = 0x82EA7864; continue 'dispatch;
	}
	pc = 0x82EA8E88; continue 'dispatch;
            }
            0x82EA8E88 => {
    //   block [0x82EA8E88..0x82EA8E9C)
	// 82EA8E88: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8E8C: 7F16C378  mr r22, r24
	ctx.r[22].u64 = ctx.r[24].u64;
	// 82EA8E90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA8E94: 4099030C  ble cr6, 0x82ea91a0
	if !ctx.cr[6].gt {
	pc = 0x82EA91A0; continue 'dispatch;
	}
	// 82EA8E98: 48000008  b 0x82ea8ea0
	pc = 0x82EA8EA0; continue 'dispatch;
            }
            0x82EA8E9C => {
    //   block [0x82EA8E9C..0x82EA8EA0)
	// 82EA8E9C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	pc = 0x82EA8EA0; continue 'dispatch;
            }
            0x82EA8EA0 => {
    //   block [0x82EA8EA0..0x82EA8EBC)
	// 82EA8EA0: 39740024  addi r11, r20, 0x24
	ctx.r[11].s64 = ctx.r[20].s64 + 36;
	// 82EA8EA4: 7F17C378  mr r23, r24
	ctx.r[23].u64 = ctx.r[24].u64;
	// 82EA8EA8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA8EB0: 409902DC  ble cr6, 0x82ea918c
	if !ctx.cr[6].gt {
	pc = 0x82EA918C; continue 'dispatch;
	}
	// 82EA8EB4: 56D9103A  slwi r25, r22, 2
	ctx.r[25].u32 = ctx.r[22].u32.wrapping_shl(2);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 82EA8EB8: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	pc = 0x82EA8EBC; continue 'dispatch;
            }
            0x82EA8EBC => {
    //   block [0x82EA8EBC..0x82EA8ED8)
	// 82EA8EBC: 8174002C  lwz r11, 0x2c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA8EC0: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EA8EC4: 7D79582E  lwzx r11, r25, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA8EC8: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EA8ECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA8ED0: 409902A4  ble cr6, 0x82ea9174
	if !ctx.cr[6].gt {
	pc = 0x82EA9174; continue 'dispatch;
	}
	// 82EA8ED4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	pc = 0x82EA8ED8; continue 'dispatch;
            }
            0x82EA8ED8 => {
    //   block [0x82EA8ED8..0x82EA8EFC)
	// 82EA8ED8: 81740028  lwz r11, 0x28(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA8EDC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EA8EE0: 7D79582E  lwzx r11, r25, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA8EE4: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EA8EE8: 7FEBD214  add r31, r11, r26
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82EA8EEC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA8EF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA8EF4: 4099012C  ble cr6, 0x82ea9020
	if !ctx.cr[6].gt {
	pc = 0x82EA9020; continue 'dispatch;
	}
	// 82EA8EF8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82EA8EFC; continue 'dispatch;
            }
            0x82EA8EFC => {
    //   block [0x82EA8EFC..0x82EA9020)
	// 82EA8EFC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8F00: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8F04: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EA8F08: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8F0C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8F10: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8F14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA8F18: 4E800421  bctrl
	ctx.lr = 0x82EA8F1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8F1C: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8F20: 409A0288  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8F24: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA8F28: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8F2C: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8F30: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82EA8F34: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA8F38: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8F3C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8F40: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8F44: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8F48: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8F4C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8F50: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8F54: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA8F58: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8F5C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EA8F60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA8F64: 4E800421  bctrl
	ctx.lr = 0x82EA8F68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8F68: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8F6C: 409A023C  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8F70: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EA8F74: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA8F78: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA8F7C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EA8F80: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA8F84: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA8F88: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8F8C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8F90: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8F94: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA8F98: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8F9C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA8FA0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA8FA4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA8FA8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EA8FAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA8FB0: 4E800421  bctrl
	ctx.lr = 0x82EA8FB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA8FB4: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA8FB8: 409A01F0  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA8FBC: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EA8FC0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EA8FC4: 81340028  lwz r9, 0x28(r20)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA8FC8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA8FCC: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EA8FD0: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82EA8FD4: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA8FD8: 5167801E  rlwimi r7, r11, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA8FDC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA8FE0: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EA8FE4: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA8FE8: 54EA401E  rlwinm r10, r7, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82EA8FEC: 80E10064  lwz r7, 0x64(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EA8FF0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA8FF4: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82EA8FF8: 1D4B0064  mulli r10, r11, 0x64
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 100 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA8FFC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EA9000: 7D26482E  lwzx r9, r6, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EA9004: 7D69382E  lwzx r11, r9, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82EA9008: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA900C: 7D68E92E  stwx r11, r8, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[29].u32), ctx.r[11].u32) };
	// 82EA9010: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EA9014: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA9018: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA901C: 4198FEE0  blt cr6, 0x82ea8efc
	if ctx.cr[6].lt {
	pc = 0x82EA8EFC; continue 'dispatch;
	}
            }
            0x82EA9020 => {
    //   block [0x82EA9020..0x82EA9034)
	// 82EA9020: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA9024: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EA9028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA902C: 4099012C  ble cr6, 0x82ea9158
	if !ctx.cr[6].gt {
	pc = 0x82EA9158; continue 'dispatch;
	}
	// 82EA9030: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82EA9034; continue 'dispatch;
            }
            0x82EA9034 => {
    //   block [0x82EA9034..0x82EA9158)
	// 82EA9034: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA9038: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA903C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82EA9040: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA9044: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA9048: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA904C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9050: 4E800421  bctrl
	ctx.lr = 0x82EA9054;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA9054: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA9058: 409A0150  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA905C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EA9060: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA9064: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA9068: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82EA906C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA9070: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA9074: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA9078: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA907C: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA9080: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA9084: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA9088: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA908C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA9090: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA9094: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EA9098: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA909C: 4E800421  bctrl
	ctx.lr = 0x82EA90A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA90A0: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA90A4: 409A0104  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA90A8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EA90AC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EA90B0: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA90B4: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 82EA90B8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA90BC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EA90C0: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA90C4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA90C8: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA90CC: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EA90D0: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EA90D4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EA90D8: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EA90DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EA90E0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EA90E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EA90E8: 4E800421  bctrl
	ctx.lr = 0x82EA90EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA90EC: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EA90F0: 409A00B8  bne cr6, 0x82ea91a8
	if !ctx.cr[6].eq {
	pc = 0x82EA91A8; continue 'dispatch;
	}
	// 82EA90F4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EA90F8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EA90FC: 81340028  lwz r9, 0x28(r20)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA9100: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EA9104: 811F002C  lwz r8, 0x2c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA9108: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82EA910C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EA9110: 5167801E  rlwimi r7, r11, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82EA9114: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EA9118: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EA911C: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EA9120: 54EA401E  rlwinm r10, r7, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82EA9124: 80E1006C  lwz r7, 0x6c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EA9128: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EA912C: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82EA9130: 1D4B0064  mulli r10, r11, 0x64
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 100 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA9134: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EA9138: 7D26482E  lwzx r9, r6, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EA913C: 7D69382E  lwzx r11, r9, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82EA9140: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EA9144: 7D68F12E  stwx r11, r8, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u32) };
	// 82EA9148: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EA914C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA9150: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA9154: 4198FEE0  blt cr6, 0x82ea9034
	if ctx.cr[6].lt {
	pc = 0x82EA9034; continue 'dispatch;
	}
            }
            0x82EA9158 => {
    //   block [0x82EA9158..0x82EA9174)
	// 82EA9158: 8174002C  lwz r11, 0x2c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EA915C: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82EA9160: 3B5A0064  addi r26, r26, 0x64
	ctx.r[26].s64 = ctx.r[26].s64 + 100;
	// 82EA9164: 7D79582E  lwzx r11, r25, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA9168: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EA916C: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA9170: 4198FD68  blt cr6, 0x82ea8ed8
	if ctx.cr[6].lt {
	pc = 0x82EA8ED8; continue 'dispatch;
	}
	pc = 0x82EA9174; continue 'dispatch;
            }
            0x82EA9174 => {
    //   block [0x82EA9174..0x82EA918C)
	// 82EA9174: 39740024  addi r11, r20, 0x24
	ctx.r[11].s64 = ctx.r[20].s64 + 36;
	// 82EA9178: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82EA917C: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EA9180: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA9184: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA9188: 4198FD34  blt cr6, 0x82ea8ebc
	if ctx.cr[6].lt {
	pc = 0x82EA8EBC; continue 'dispatch;
	}
	pc = 0x82EA918C; continue 'dispatch;
            }
            0x82EA918C => {
    //   block [0x82EA918C..0x82EA91A0)
	// 82EA918C: 39740020  addi r11, r20, 0x20
	ctx.r[11].s64 = ctx.r[20].s64 + 32;
	// 82EA9190: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 82EA9194: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EA9198: 7F165840  cmplw cr6, r22, r11
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA919C: 4198FD00  blt cr6, 0x82ea8e9c
	if ctx.cr[6].lt {
	pc = 0x82EA8E9C; continue 'dispatch;
	}
	pc = 0x82EA91A0; continue 'dispatch;
            }
            0x82EA91A0 => {
    //   block [0x82EA91A0..0x82EA91A8)
	// 82EA91A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EA91A4: 48000008  b 0x82ea91ac
	pc = 0x82EA91AC; continue 'dispatch;
            }
            0x82EA91A8 => {
    //   block [0x82EA91A8..0x82EA91AC)
	// 82EA91A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EA91AC; continue 'dispatch;
            }
            0x82EA91AC => {
    //   block [0x82EA91AC..0x82EA91BC)
	// 82EA91AC: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82EA91B0: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 82EA91B4: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 82EA91B8: 4BE00268  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA91C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA91C0 size=156
    let mut pc: u32 = 0x82EA91C0;
    'dispatch: loop {
        match pc {
            0x82EA91C0 => {
    //   block [0x82EA91C0..0x82EA91F4)
	// 82EA91C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA91C4: 4BE00245  bl 0x82ca9408
	ctx.lr = 0x82EA91C8;
	sub_82CA93D0(ctx, base);
	// 82EA91C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA91CC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EA91D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA91D4: 578B07BD  rlwinm. r11, r28, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA91D8: 41820054  beq 0x82ea922c
	if ctx.cr[0].eq {
	pc = 0x82EA922C; continue 'dispatch;
	}
	// 82EA91DC: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EA91E0: 3BBFFFFC  addi r29, r31, -4
	ctx.r[29].s64 = ctx.r[31].s64 + -4;
	// 82EA91E4: 1D4B0064  mulli r10, r11, 0x64
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 100 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EA91E8: 37CBFFFF  addic. r30, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EA91EC: 7FEAFA14  add r31, r10, r31
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82EA91F0: 41800018  blt 0x82ea9208
	if ctx.cr[0].lt {
	pc = 0x82EA9208; continue 'dispatch;
	}
	pc = 0x82EA91F4; continue 'dispatch;
            }
            0x82EA91F4 => {
    //   block [0x82EA91F4..0x82EA9208)
	// 82EA91F4: 3BFFFF9C  addi r31, r31, -0x64
	ctx.r[31].s64 = ctx.r[31].s64 + -100;
	// 82EA91F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA91FC: 4BFFD0AD  bl 0x82ea62a8
	ctx.lr = 0x82EA9200;
	sub_82EA62A8(ctx, base);
	// 82EA9200: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EA9204: 4080FFF0  bge 0x82ea91f4
	if !ctx.cr[0].lt {
	pc = 0x82EA91F4; continue 'dispatch;
	}
	pc = 0x82EA9208; continue 'dispatch;
            }
            0x82EA9208 => {
    //   block [0x82EA9208..0x82EA9224)
	// 82EA9208: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA920C: 41820018  beq 0x82ea9224
	if ctx.cr[0].eq {
	pc = 0x82EA9224; continue 'dispatch;
	}
	// 82EA9210: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA9214: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA9218: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA921C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9220: 4E800421  bctrl
	ctx.lr = 0x82EA9224;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA9224 => {
    //   block [0x82EA9224..0x82EA922C)
	// 82EA9224: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA9228: 4800002C  b 0x82ea9254
	pc = 0x82EA9254; continue 'dispatch;
            }
            0x82EA922C => {
    //   block [0x82EA922C..0x82EA9250)
	// 82EA922C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA9230: 4BFFD079  bl 0x82ea62a8
	ctx.lr = 0x82EA9234;
	sub_82EA62A8(ctx, base);
	// 82EA9234: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA9238: 41820018  beq 0x82ea9250
	if ctx.cr[0].eq {
	pc = 0x82EA9250; continue 'dispatch;
	}
	// 82EA923C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA9240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EA9244: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EA9248: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA924C: 4E800421  bctrl
	ctx.lr = 0x82EA9250;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA9250 => {
    //   block [0x82EA9250..0x82EA9254)
	// 82EA9250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82EA9254; continue 'dispatch;
            }
            0x82EA9254 => {
    //   block [0x82EA9254..0x82EA925C)
	// 82EA9254: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EA9258: 4BE00200  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA9260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EA9260 size=68
    let mut pc: u32 = 0x82EA9260;
    'dispatch: loop {
        match pc {
            0x82EA9260 => {
    //   block [0x82EA9260..0x82EA92A4)
	// 82EA9260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA9264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EA9268: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EA926C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA9270: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EA9274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA9278: 396BA268  addi r11, r11, -0x5d98
	ctx.r[11].s64 = ctx.r[11].s64 + -23960;
	// 82EA927C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA9280: 4BFFCBB9  bl 0x82ea5e38
	ctx.lr = 0x82EA9284;
	sub_82EA5E38(ctx, base);
	// 82EA9284: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EA9288: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EA928C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EA9290: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EA9294: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EA9298: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EA929C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EA92A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EA92A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EA92A8 size=3444
    let mut pc: u32 = 0x82EA92A8;
    'dispatch: loop {
        match pc {
            0x82EA92A8 => {
    //   block [0x82EA92A8..0x82EA930C)
	// 82EA92A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EA92AC: 4BE00135  bl 0x82ca93e0
	ctx.lr = 0x82EA92B0;
	sub_82CA93D0(ctx, base);
	// 82EA92B0: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 82EA92B4: 4BE04A19  bl 0x82cadccc
	ctx.lr = 0x82EA92B8;
	sub_82CADCA0(ctx, base);
	// 82EA92B8: 9421FD70  stwu r1, -0x290(r1)
	ea = ctx.r[1].u32.wrapping_add(-656 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EA92BC: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EA92C0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA92C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EA92C8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EA92CC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EA92D0: 3AABDAC0  addi r21, r11, -0x2540
	ctx.r[21].s64 = ctx.r[11].s64 + -9536;
	// 82EA92D4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EA92D8: C34A0A7C  lfs f26, 0xa7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2684 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EA92DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EA92E0: C3290C14  lfs f25, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EA92E4: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 82EA92E8: C3680BFC  lfs f27, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EA92EC: 3E808334  lis r20, -0x7ccc
	ctx.r[20].s64 = -2093744128;
	// 82EA92F0: 3A6BDBFC  addi r19, r11, -0x2404
	ctx.r[19].s64 = ctx.r[11].s64 + -9220;
	// 82EA92F4: 41820304  beq 0x82ea95f8
	if ctx.cr[0].eq {
	pc = 0x82EA95F8; continue 'dispatch;
	}
	// 82EA92F8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA92FC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EA9300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9304: 40990174  ble cr6, 0x82ea9478
	if !ctx.cr[6].gt {
	pc = 0x82EA9478; continue 'dispatch;
	}
	// 82EA9308: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82EA930C; continue 'dispatch;
            }
            0x82EA930C => {
    //   block [0x82EA930C..0x82EA9344)
	// 82EA930C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EA9310: 81550048  lwz r10, 0x48(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9314: 7FDC5A14  add r30, r28, r11
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82EA9318: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA931C: 3BBE000C  addi r29, r30, 0xc
	ctx.r[29].s64 = ctx.r[30].s64 + 12;
	// 82EA9320: 419A0024  beq cr6, 0x82ea9344
	if ctx.cr[6].eq {
	pc = 0x82EA9344; continue 'dispatch;
	}
	// 82EA9324: 38E000C8  li r7, 0xc8
	ctx.r[7].s64 = 200;
	// 82EA9328: 38C00064  li r6, 0x64
	ctx.r[6].s64 = 100;
	// 82EA932C: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82EA9330: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EA9334: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EA9338: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA933C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9340: 4E800421  bctrl
	ctx.lr = 0x82EA9344;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA9344 => {
    //   block [0x82EA9344..0x82EA93D0)
	// 82EA9344: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9348: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EA934C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9350: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EA9354: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA9358: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA935C: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9360: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA9364: C17D0008  lfs f11, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA9368: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA936C: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EA9370: EFE006F2  fmuls f31, f0, f27
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA9374: D3E101A0  stfs f31, 0x1a0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82EA9378: EFCD06F2  fmuls f30, f13, f27
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA937C: D3C101A4  stfs f30, 0x1a4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 82EA9380: EFAC06F2  fmuls f29, f12, f27
	ctx.f[29].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA9384: D3A101A8  stfs f29, 0x1a8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82EA9388: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA938C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9390: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EA9394: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EA9398: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA939C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA93A0: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EA93A4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EA93A8: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA93AC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA93B0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EA93B4: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EA93B8: 4B3D5EB1  bl 0x8227f268
	ctx.lr = 0x82EA93BC;
	sub_8227F268(ctx, base);
	// 82EA93BC: 81740718  lwz r11, 0x718(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA93C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA93C4: 4182000C  beq 0x82ea93d0
	if ctx.cr[0].eq {
	pc = 0x82EA93D0; continue 'dispatch;
	}
	// 82EA93C8: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA93CC: 48000008  b 0x82ea93d4
	pc = 0x82EA93D4; continue 'dispatch;
            }
            0x82EA93D0 => {
    //   block [0x82EA93D0..0x82EA93D4)
	// 82EA93D0: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	pc = 0x82EA93D4; continue 'dispatch;
            }
            0x82EA93D4 => {
    //   block [0x82EA93D4..0x82EA9464)
	// 82EA93D4: C1530008  lfs f10, 8(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EA93D8: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 82EA93DC: C1130000  lfs f8, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EA93E0: FCE05090  fmr f7, f10
	ctx.f[7].f64 = ctx.f[10].f64;
	// 82EA93E4: FCA04090  fmr f5, f8
	ctx.f[5].f64 = ctx.f[8].f64;
	// 82EA93E8: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA93EC: C1730004  lfs f11, 4(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA93F0: 81750048  lwz r11, 0x48(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA93F4: ED2C02F2  fmuls f9, f12, f11
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EA93F8: C1610060  lfs f11, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA93FC: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9404: C0D30004  lfs f6, 4(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EA9408: ECEB01F2  fmuls f7, f11, f7
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[7].f64) as f32) as f64);
	// 82EA940C: ECAD0172  fmuls f5, f13, f5
	ctx.f[5].f64 = (((ctx.f[13].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EA9410: EDAD4AB8  fmsubs f13, f13, f10, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EA9414: ED8C3A38  fmsubs f12, f12, f8, f7
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[8].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EA9418: ED6B29B8  fmsubs f11, f11, f6, f5
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[6].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EA941C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9420: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9424: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9428: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EA942C: D1A10120  stfs f13, 0x120(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82EA9430: EDACF02A  fadds f13, f12, f30
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EA9434: D1A10124  stfs f13, 0x124(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EA9438: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EA943C: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EA9440: 419A0024  beq cr6, 0x82ea9464
	if ctx.cr[6].eq {
	pc = 0x82EA9464; continue 'dispatch;
	}
	// 82EA9444: 38E000C8  li r7, 0xc8
	ctx.r[7].s64 = 200;
	// 82EA9448: 38C000C8  li r6, 0xc8
	ctx.r[6].s64 = 200;
	// 82EA944C: 38A000C8  li r5, 0xc8
	ctx.r[5].s64 = 200;
	// 82EA9450: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82EA9454: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EA9458: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA945C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9460: 4E800421  bctrl
	ctx.lr = 0x82EA9464;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA9464 => {
    //   block [0x82EA9464..0x82EA9478)
	// 82EA9464: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EA9468: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EA946C: 3B9C0018  addi r28, r28, 0x18
	ctx.r[28].s64 = ctx.r[28].s64 + 24;
	// 82EA9470: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA9474: 4198FE98  blt cr6, 0x82ea930c
	if ctx.cr[6].lt {
	pc = 0x82EA930C; continue 'dispatch;
	}
	pc = 0x82EA9478; continue 'dispatch;
            }
            0x82EA9478 => {
    //   block [0x82EA9478..0x82EA948C)
	// 82EA9478: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA947C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EA9480: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9484: 40990174  ble cr6, 0x82ea95f8
	if !ctx.cr[6].gt {
	pc = 0x82EA95F8; continue 'dispatch;
	}
	// 82EA9488: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82EA948C; continue 'dispatch;
            }
            0x82EA948C => {
    //   block [0x82EA948C..0x82EA94C4)
	// 82EA948C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EA9490: 81550048  lwz r10, 0x48(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9494: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EA9498: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA949C: 3BBE000C  addi r29, r30, 0xc
	ctx.r[29].s64 = ctx.r[30].s64 + 12;
	// 82EA94A0: 419A0024  beq cr6, 0x82ea94c4
	if ctx.cr[6].eq {
	pc = 0x82EA94C4; continue 'dispatch;
	}
	// 82EA94A4: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 82EA94A8: 38C000C8  li r6, 0xc8
	ctx.r[6].s64 = 200;
	// 82EA94AC: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82EA94B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EA94B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EA94B8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA94BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA94C0: 4E800421  bctrl
	ctx.lr = 0x82EA94C4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA94C4 => {
    //   block [0x82EA94C4..0x82EA9550)
	// 82EA94C4: C1BD0000  lfs f13, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA94C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EA94CC: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA94D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EA94D4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA94D8: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA94DC: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA94E0: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA94E4: C17D0008  lfs f11, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA94E8: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA94EC: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EA94F0: EFE006F2  fmuls f31, f0, f27
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA94F4: D3E10180  stfs f31, 0x180(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82EA94F8: EFCD06F2  fmuls f30, f13, f27
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA94FC: D3C10184  stfs f30, 0x184(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EA9500: EFAC06F2  fmuls f29, f12, f27
	ctx.f[29].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA9504: D3A10188  stfs f29, 0x188(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EA9508: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA950C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9510: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EA9514: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EA9518: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA951C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9520: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EA9524: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EA9528: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA952C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9530: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EA9534: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EA9538: 4B3D5D31  bl 0x8227f268
	ctx.lr = 0x82EA953C;
	sub_8227F268(ctx, base);
	// 82EA953C: 81740718  lwz r11, 0x718(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA9540: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA9544: 4182000C  beq 0x82ea9550
	if ctx.cr[0].eq {
	pc = 0x82EA9550; continue 'dispatch;
	}
	// 82EA9548: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA954C: 48000008  b 0x82ea9554
	pc = 0x82EA9554; continue 'dispatch;
            }
            0x82EA9550 => {
    //   block [0x82EA9550..0x82EA9554)
	// 82EA9550: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	pc = 0x82EA9554; continue 'dispatch;
            }
            0x82EA9554 => {
    //   block [0x82EA9554..0x82EA95E4)
	// 82EA9554: C1530008  lfs f10, 8(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EA9558: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 82EA955C: C1130000  lfs f8, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EA9560: FCE05090  fmr f7, f10
	ctx.f[7].f64 = ctx.f[10].f64;
	// 82EA9564: FCA04090  fmr f5, f8
	ctx.f[5].f64 = ctx.f[8].f64;
	// 82EA9568: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA956C: C1730004  lfs f11, 4(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA9570: 81750048  lwz r11, 0x48(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9574: ED2C02F2  fmuls f9, f12, f11
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EA9578: C1610060  lfs f11, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA957C: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9580: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9584: C0D30004  lfs f6, 4(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EA9588: ECEB01F2  fmuls f7, f11, f7
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[7].f64) as f32) as f64);
	// 82EA958C: ECAD0172  fmuls f5, f13, f5
	ctx.f[5].f64 = (((ctx.f[13].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EA9590: EDAD4AB8  fmsubs f13, f13, f10, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EA9594: ED8C3A38  fmsubs f12, f12, f8, f7
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[8].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EA9598: ED6B29B8  fmsubs f11, f11, f6, f5
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[6].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EA959C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA95A0: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA95A4: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA95A8: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EA95AC: D1A100F0  stfs f13, 0xf0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EA95B0: EDACF02A  fadds f13, f12, f30
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EA95B4: D1A100F4  stfs f13, 0xf4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EA95B8: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EA95BC: D00100F8  stfs f0, 0xf8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EA95C0: 419A0024  beq cr6, 0x82ea95e4
	if ctx.cr[6].eq {
	pc = 0x82EA95E4; continue 'dispatch;
	}
	// 82EA95C4: 38E000C8  li r7, 0xc8
	ctx.r[7].s64 = 200;
	// 82EA95C8: 38C000C8  li r6, 0xc8
	ctx.r[6].s64 = 200;
	// 82EA95CC: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 82EA95D0: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82EA95D4: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82EA95D8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA95DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA95E0: 4E800421  bctrl
	ctx.lr = 0x82EA95E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA95E4 => {
    //   block [0x82EA95E4..0x82EA95F8)
	// 82EA95E4: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EA95E8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EA95EC: 3B9C0018  addi r28, r28, 0x18
	ctx.r[28].s64 = ctx.r[28].s64 + 24;
	// 82EA95F0: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA95F4: 4198FE98  blt cr6, 0x82ea948c
	if ctx.cr[6].lt {
	pc = 0x82EA948C; continue 'dispatch;
	}
	pc = 0x82EA95F8; continue 'dispatch;
            }
            0x82EA95F8 => {
    //   block [0x82EA95F8..0x82EA9614)
	// 82EA95F8: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA95FC: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EA9600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9604: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA9608: C38B0BF8  lfs f28, 0xbf8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EA960C: 409901C4  ble cr6, 0x82ea97d0
	if !ctx.cr[6].gt {
	pc = 0x82EA97D0; continue 'dispatch;
	}
	// 82EA9610: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82EA9614; continue 'dispatch;
            }
            0x82EA9614 => {
    //   block [0x82EA9614..0x82EA9640)
	// 82EA9614: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EA9618: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EA961C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EA9620: 4198019C  blt cr6, 0x82ea97bc
	if ctx.cr[6].lt {
	pc = 0x82EA97BC; continue 'dispatch;
	}
	// 82EA9624: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA9628: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82EA962C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA9630: 7FAAE02E  lwzx r29, r10, r28
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EA9634: 40990188  ble cr6, 0x82ea97bc
	if !ctx.cr[6].gt {
	pc = 0x82EA97BC; continue 'dispatch;
	}
	// 82EA9638: 5659063E  clrlwi r25, r18, 0x18
	ctx.r[25].u64 = ctx.r[18].u32 as u64 & 0x000000FFu64;
	// 82EA963C: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	pc = 0x82EA9640; continue 'dispatch;
            }
            0x82EA9640 => {
    //   block [0x82EA9640..0x82EA9678)
	// 82EA9640: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EA9644: 81550048  lwz r10, 0x48(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9648: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA964C: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EA9650: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EA9654: 419A0024  beq cr6, 0x82ea9678
	if ctx.cr[6].eq {
	pc = 0x82EA9678; continue 'dispatch;
	}
	// 82EA9658: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 82EA965C: 38C00064  li r6, 0x64
	ctx.r[6].s64 = 100;
	// 82EA9660: 38A000C8  li r5, 0xc8
	ctx.r[5].s64 = 200;
	// 82EA9664: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA9668: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA966C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9670: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9674: 4E800421  bctrl
	ctx.lr = 0x82EA9678;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA9678 => {
    //   block [0x82EA9678..0x82EA970C)
	// 82EA9678: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82EA967C: 419A0124  beq cr6, 0x82ea97a0
	if ctx.cr[6].eq {
	pc = 0x82EA97A0; continue 'dispatch;
	}
	// 82EA9680: C1BD0000  lfs f13, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9684: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EA9688: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA968C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EA9690: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA9694: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9698: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA969C: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA96A0: C17D0008  lfs f11, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA96A4: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA96A8: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EA96AC: EFE006F2  fmuls f31, f0, f27
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA96B0: D3E101C0  stfs f31, 0x1c0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EA96B4: EFCD06F2  fmuls f30, f13, f27
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA96B8: D3C101C4  stfs f30, 0x1c4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82EA96BC: EFAC06F2  fmuls f29, f12, f27
	ctx.f[29].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA96C0: D3A101C8  stfs f29, 0x1c8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 82EA96C4: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA96C8: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA96CC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EA96D0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EA96D4: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA96D8: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA96DC: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EA96E0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EA96E4: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA96E8: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA96EC: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EA96F0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EA96F4: 4B3D5B75  bl 0x8227f268
	ctx.lr = 0x82EA96F8;
	sub_8227F268(ctx, base);
	// 82EA96F8: 81740718  lwz r11, 0x718(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA96FC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA9700: 4182000C  beq 0x82ea970c
	if ctx.cr[0].eq {
	pc = 0x82EA970C; continue 'dispatch;
	}
	// 82EA9704: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9708: 48000008  b 0x82ea9710
	pc = 0x82EA9710; continue 'dispatch;
            }
            0x82EA970C => {
    //   block [0x82EA970C..0x82EA9710)
	// 82EA970C: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	pc = 0x82EA9710; continue 'dispatch;
            }
            0x82EA9710 => {
    //   block [0x82EA9710..0x82EA97A0)
	// 82EA9710: C1530004  lfs f10, 4(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EA9714: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EA9718: FCA05090  fmr f5, f10
	ctx.f[5].f64 = ctx.f[10].f64;
	// 82EA971C: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9720: C1730008  lfs f11, 8(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA9724: 81750048  lwz r11, 0x48(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9728: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA972C: ED2C02F2  fmuls f9, f12, f11
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EA9730: C0F30000  lfs f7, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EA9734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9738: C1610060  lfs f11, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA973C: ECED01F2  fmuls f7, f13, f7
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[7].f64) as f32) as f64);
	// 82EA9740: C1130008  lfs f8, 8(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EA9744: C0D30000  lfs f6, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EA9748: ECAB0172  fmuls f5, f11, f5
	ctx.f[5].f64 = (((ctx.f[11].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EA974C: EDAD4AB8  fmsubs f13, f13, f10, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EA9750: ED6B3A38  fmsubs f11, f11, f8, f7
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[8].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EA9754: ED8C29B8  fmsubs f12, f12, f6, f5
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[6].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EA9758: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA975C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9760: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9764: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EA9768: D1A10140  stfs f13, 0x140(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 82EA976C: EDABF02A  fadds f13, f11, f30
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EA9770: D1A10144  stfs f13, 0x144(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82EA9774: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EA9778: D0010148  stfs f0, 0x148(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82EA977C: 419A0024  beq cr6, 0x82ea97a0
	if ctx.cr[6].eq {
	pc = 0x82EA97A0; continue 'dispatch;
	}
	// 82EA9780: 38E000FF  li r7, 0xff
	ctx.r[7].s64 = 255;
	// 82EA9784: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 82EA9788: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EA978C: 38810140  addi r4, r1, 0x140
	ctx.r[4].s64 = ctx.r[1].s64 + 320;
	// 82EA9790: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 82EA9794: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9798: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA979C: 4E800421  bctrl
	ctx.lr = 0x82EA97A0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA97A0 => {
    //   block [0x82EA97A0..0x82EA97BC)
	// 82EA97A0: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EA97A4: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EA97A8: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EA97AC: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 82EA97B0: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EA97B4: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA97B8: 4198FE88  blt cr6, 0x82ea9640
	if ctx.cr[6].lt {
	pc = 0x82EA9640; continue 'dispatch;
	}
	pc = 0x82EA97BC; continue 'dispatch;
            }
            0x82EA97BC => {
    //   block [0x82EA97BC..0x82EA97D0)
	// 82EA97BC: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EA97C0: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82EA97C4: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EA97C8: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA97CC: 4198FE48  blt cr6, 0x82ea9614
	if ctx.cr[6].lt {
	pc = 0x82EA9614; continue 'dispatch;
	}
	pc = 0x82EA97D0; continue 'dispatch;
            }
            0x82EA97D0 => {
    //   block [0x82EA97D0..0x82EA97E4)
	// 82EA97D0: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA97D4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EA97D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA97DC: 409901C4  ble cr6, 0x82ea99a0
	if !ctx.cr[6].gt {
	pc = 0x82EA99A0; continue 'dispatch;
	}
	// 82EA97E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82EA97E4; continue 'dispatch;
            }
            0x82EA97E4 => {
    //   block [0x82EA97E4..0x82EA9810)
	// 82EA97E4: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA97E8: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EA97EC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EA97F0: 4198019C  blt cr6, 0x82ea998c
	if ctx.cr[6].lt {
	pc = 0x82EA998C; continue 'dispatch;
	}
	// 82EA97F4: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA97F8: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82EA97FC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA9800: 7FBC502E  lwzx r29, r28, r10
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EA9804: 40990188  ble cr6, 0x82ea998c
	if !ctx.cr[6].gt {
	pc = 0x82EA998C; continue 'dispatch;
	}
	// 82EA9808: 5659063E  clrlwi r25, r18, 0x18
	ctx.r[25].u64 = ctx.r[18].u32 as u64 & 0x000000FFu64;
	// 82EA980C: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	pc = 0x82EA9810; continue 'dispatch;
            }
            0x82EA9810 => {
    //   block [0x82EA9810..0x82EA9848)
	// 82EA9810: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EA9814: 81550048  lwz r10, 0x48(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9818: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA981C: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA9820: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EA9824: 419A0024  beq cr6, 0x82ea9848
	if ctx.cr[6].eq {
	pc = 0x82EA9848; continue 'dispatch;
	}
	// 82EA9828: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 82EA982C: 38C00064  li r6, 0x64
	ctx.r[6].s64 = 100;
	// 82EA9830: 38A000C8  li r5, 0xc8
	ctx.r[5].s64 = 200;
	// 82EA9834: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA9838: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EA983C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9840: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9844: 4E800421  bctrl
	ctx.lr = 0x82EA9848;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA9848 => {
    //   block [0x82EA9848..0x82EA98DC)
	// 82EA9848: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82EA984C: 419A0124  beq cr6, 0x82ea9970
	if ctx.cr[6].eq {
	pc = 0x82EA9970; continue 'dispatch;
	}
	// 82EA9850: C1BD0000  lfs f13, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9854: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EA9858: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA985C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EA9860: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA9864: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9868: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA986C: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA9870: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA9874: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9878: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EA987C: EFE006F2  fmuls f31, f0, f27
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA9880: D3E10100  stfs f31, 0x100(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EA9884: EFCD06F2  fmuls f30, f13, f27
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA9888: D3C10104  stfs f30, 0x104(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EA988C: EFAC06F2  fmuls f29, f12, f27
	ctx.f[29].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA9890: D3A10108  stfs f29, 0x108(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EA9894: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9898: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA989C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EA98A0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EA98A4: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA98A8: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA98AC: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EA98B0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EA98B4: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA98B8: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA98BC: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EA98C0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EA98C4: 4B3D59A5  bl 0x8227f268
	ctx.lr = 0x82EA98C8;
	sub_8227F268(ctx, base);
	// 82EA98C8: 81740718  lwz r11, 0x718(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA98CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA98D0: 4182000C  beq 0x82ea98dc
	if ctx.cr[0].eq {
	pc = 0x82EA98DC; continue 'dispatch;
	}
	// 82EA98D4: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA98D8: 48000008  b 0x82ea98e0
	pc = 0x82EA98E0; continue 'dispatch;
            }
            0x82EA98DC => {
    //   block [0x82EA98DC..0x82EA98E0)
	// 82EA98DC: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	pc = 0x82EA98E0; continue 'dispatch;
            }
            0x82EA98E0 => {
    //   block [0x82EA98E0..0x82EA9970)
	// 82EA98E0: C1530004  lfs f10, 4(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EA98E4: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EA98E8: FCA05090  fmr f5, f10
	ctx.f[5].f64 = ctx.f[10].f64;
	// 82EA98EC: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA98F0: C1730008  lfs f11, 8(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA98F4: 81750048  lwz r11, 0x48(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA98F8: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA98FC: ED2C02F2  fmuls f9, f12, f11
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EA9900: C0F30000  lfs f7, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EA9904: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9908: C1610060  lfs f11, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA990C: ECED01F2  fmuls f7, f13, f7
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[7].f64) as f32) as f64);
	// 82EA9910: C1130008  lfs f8, 8(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EA9914: C0D30000  lfs f6, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EA9918: ECAB0172  fmuls f5, f11, f5
	ctx.f[5].f64 = (((ctx.f[11].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EA991C: EDAD4AB8  fmsubs f13, f13, f10, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EA9920: ED6B3A38  fmsubs f11, f11, f8, f7
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[8].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EA9924: ED8C29B8  fmsubs f12, f12, f6, f5
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[6].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EA9928: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA992C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9930: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9934: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EA9938: D1A10160  stfs f13, 0x160(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 82EA993C: EDABF02A  fadds f13, f11, f30
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EA9940: D1A10164  stfs f13, 0x164(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82EA9944: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EA9948: D0010168  stfs f0, 0x168(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 82EA994C: 419A0024  beq cr6, 0x82ea9970
	if ctx.cr[6].eq {
	pc = 0x82EA9970; continue 'dispatch;
	}
	// 82EA9950: 38E000FF  li r7, 0xff
	ctx.r[7].s64 = 255;
	// 82EA9954: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 82EA9958: 38A000C8  li r5, 0xc8
	ctx.r[5].s64 = 200;
	// 82EA995C: 38810160  addi r4, r1, 0x160
	ctx.r[4].s64 = ctx.r[1].s64 + 352;
	// 82EA9960: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82EA9964: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9968: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA996C: 4E800421  bctrl
	ctx.lr = 0x82EA9970;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA9970 => {
    //   block [0x82EA9970..0x82EA998C)
	// 82EA9970: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EA9974: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EA9978: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EA997C: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 82EA9980: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EA9984: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA9988: 4198FE88  blt cr6, 0x82ea9810
	if ctx.cr[6].lt {
	pc = 0x82EA9810; continue 'dispatch;
	}
	pc = 0x82EA998C; continue 'dispatch;
            }
            0x82EA998C => {
    //   block [0x82EA998C..0x82EA99A0)
	// 82EA998C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9990: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82EA9994: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EA9998: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA999C: 4198FE48  blt cr6, 0x82ea97e4
	if ctx.cr[6].lt {
	pc = 0x82EA97E4; continue 'dispatch;
	}
	pc = 0x82EA99A0; continue 'dispatch;
            }
            0x82EA99A0 => {
    //   block [0x82EA99A0..0x82EA99CC)
	// 82EA99A0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EA99A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EA99A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA99AC: 418203E4  beq 0x82ea9d90
	if ctx.cr[0].eq {
	pc = 0x82EA9D90; continue 'dispatch;
	}
	// 82EA99B0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EA99B4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EA99B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EA99BC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EA99C0: 3F408330  lis r26, -0x7cd0
	ctx.r[26].s64 = -2094006272;
	// 82EA99C4: C3C80C18  lfs f30, 0xc18(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EA99C8: C3A90C3C  lfs f29, 0xc3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3132 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	pc = 0x82EA99CC; continue 'dispatch;
            }
            0x82EA99CC => {
    //   block [0x82EA99CC..0x82EA99E0)
	// 82EA99CC: 81340718  lwz r9, 0x718(r20)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA99D0: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA99D4: 4182000C  beq 0x82ea99e0
	if ctx.cr[0].eq {
	pc = 0x82EA99E0; continue 'dispatch;
	}
	// 82EA99D8: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA99DC: 48000008  b 0x82ea99e4
	pc = 0x82EA99E4; continue 'dispatch;
            }
            0x82EA99E0 => {
    //   block [0x82EA99E0..0x82EA99E4)
	// 82EA99E0: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	pc = 0x82EA99E4; continue 'dispatch;
            }
            0x82EA99E4 => {
    //   block [0x82EA99E4..0x82EA9AE0)
	// 82EA99E4: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82EA99E8: 3B8A0001  addi r28, r10, 1
	ctx.r[28].s64 = ctx.r[10].s64 + 1;
	// 82EA99EC: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EA99F0: 7C9B5214  add r4, r27, r10
	ctx.r[4].u64 = ctx.r[27].u64 + ctx.r[10].u64;
	// 82EA99F4: 81550048  lwz r10, 0x48(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA99F8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82EA99FC: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EA9A00: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82EA9A04: 7B8B0020  clrldi r11, r28, 0x20
	ctx.r[11].u64 = ctx.r[28].u64 & 0x00000000FFFFFFFFu64;
	// 82EA9A08: 3BC4000C  addi r30, r4, 0xc
	ctx.r[30].s64 = ctx.r[4].s64 + 12;
	// 82EA9A0C: C1640004  lfs f11, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA9A10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA9A14: C1440000  lfs f10, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EA9A18: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82EA9A1C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82EA9A20: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9A24: D1410080  stfs f10, 0x80(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EA9A28: C9410050  lfd f10, 0x50(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82EA9A2C: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 82EA9A30: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EA9A34: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82EA9A38: ED4A0772  fmuls f10, f10, f29
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EA9A3C: ED8A6024  fdivs f12, f10, f12
	ctx.f[12].f64 = ((ctx.f[10].f64 / ctx.f[12].f64) as f32) as f64;
	// 82EA9A40: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9A44: EDAB002A  fadds f13, f11, f0
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EA9A48: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EA9A4C: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9A50: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EA9A54: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9A58: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9A5C: D1810090  stfs f12, 0x90(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EA9A60: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EA9A64: D1A10098  stfs f13, 0x98(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EA9A68: 419A0078  beq cr6, 0x82ea9ae0
	if ctx.cr[6].eq {
	pc = 0x82EA9AE0; continue 'dispatch;
	}
	// 82EA9A6C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EA9A70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EA9A74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EA9A78: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EA9A7C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9A80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9A84: 4E800421  bctrl
	ctx.lr = 0x82EA9A88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA9A88: 81750048  lwz r11, 0x48(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9A90: 419A0050  beq cr6, 0x82ea9ae0
	if ctx.cr[6].eq {
	pc = 0x82EA9AE0; continue 'dispatch;
	}
	// 82EA9A94: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EA9A98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EA9A9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EA9AA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EA9AA4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82EA9AA8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9AAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9AB0: 4E800421  bctrl
	ctx.lr = 0x82EA9AB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA9AB4: 81750048  lwz r11, 0x48(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9AB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9ABC: 419A0024  beq cr6, 0x82ea9ae0
	if ctx.cr[6].eq {
	pc = 0x82EA9AE0; continue 'dispatch;
	}
	// 82EA9AC0: 38E000C8  li r7, 0xc8
	ctx.r[7].s64 = 200;
	// 82EA9AC4: 38C000C8  li r6, 0xc8
	ctx.r[6].s64 = 200;
	// 82EA9AC8: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82EA9ACC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82EA9AD0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EA9AD4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9AD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9ADC: 4E800421  bctrl
	ctx.lr = 0x82EA9AE0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA9AE0 => {
    //   block [0x82EA9AE0..0x82EA9B54)
	// 82EA9AE0: C1A10080  lfs f13, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9AE4: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA9AE8: C0010090  lfs f0, 0x90(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9AEC: 81540718  lwz r10, 0x718(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA9AF0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA9AF4: C1810084  lfs f12, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9AF8: C1A10094  lfs f13, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9AFC: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82EA9B00: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EA9B04: C1610088  lfs f11, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA9B08: C1810098  lfs f12, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9B0C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA9B10: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EA9B14: ED6006F2  fmuls f11, f0, f27
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA9B18: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EA9B1C: EDAD06F2  fmuls f13, f13, f27
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA9B20: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EA9B24: ED8C06F2  fmuls f12, f12, f27
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA9B28: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EA9B2C: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EA9B30: D14100D0  stfs f10, 0xd0(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EA9B34: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9B38: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EA9B3C: C12B0018  lfs f9, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EA9B40: D12100D8  stfs f9, 0xd8(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EA9B44: D3C100D4  stfs f30, 0xd4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EA9B48: 4182000C  beq 0x82ea9b54
	if ctx.cr[0].eq {
	pc = 0x82EA9B54; continue 'dispatch;
	}
	// 82EA9B4C: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9B50: 48000008  b 0x82ea9b58
	pc = 0x82EA9B58; continue 'dispatch;
            }
            0x82EA9B54 => {
    //   block [0x82EA9B54..0x82EA9B58)
	// 82EA9B54: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	pc = 0x82EA9B58; continue 'dispatch;
            }
            0x82EA9B58 => {
    //   block [0x82EA9B58..0x82EA9BAC)
	// 82EA9B58: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 82EA9B5C: 81750048  lwz r11, 0x48(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9B60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9B64: ED4002B2  fmuls f10, f0, f10
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EA9B68: ED0007B2  fmuls f8, f0, f30
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EA9B6C: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9B70: ED6A582A  fadds f11, f10, f11
	ctx.f[11].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EA9B74: D16100B0  stfs f11, 0xb0(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EA9B78: EDA8682A  fadds f13, f8, f13
	ctx.f[13].f64 = ((ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA9B7C: D1A100B4  stfs f13, 0xb4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EA9B80: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EA9B84: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EA9B88: 419A0024  beq cr6, 0x82ea9bac
	if ctx.cr[6].eq {
	pc = 0x82EA9BAC; continue 'dispatch;
	}
	// 82EA9B8C: 38E000FF  li r7, 0xff
	ctx.r[7].s64 = 255;
	// 82EA9B90: 38C00064  li r6, 0x64
	ctx.r[6].s64 = 100;
	// 82EA9B94: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82EA9B98: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82EA9B9C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EA9BA0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9BA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9BA8: 4E800421  bctrl
	ctx.lr = 0x82EA9BAC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA9BAC => {
    //   block [0x82EA9BAC..0x82EA9C38)
	// 82EA9BAC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EA9BB0: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82EA9BB4: C02B0014  lfs f1, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EA9BB8: 4B3B6D89  bl 0x82260940
	ctx.lr = 0x82EA9BBC;
	sub_82260940(ctx, base);
	// 82EA9BBC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EA9BC0: C1BADE38  lfs f13, -0x21c8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-8648 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9BC4: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82EA9BC8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82EA9BCC: EFE06824  fdivs f31, f0, f13
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EA9BD0: 4BFDC199  bl 0x82e85d68
	ctx.lr = 0x82EA9BD4;
	sub_82E85D68(ctx, base);
	// 82EA9BD4: C00100A0  lfs f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9BD8: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 82EA9BDC: D0010110  stfs f0, 0x110(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82EA9BE0: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 82EA9BE4: C00100A8  lfs f0, 0xa8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9BE8: D0010118  stfs f0, 0x118(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82EA9BEC: C00100A4  lfs f0, 0xa4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9BF0: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EA9BF4: D0010114  stfs f0, 0x114(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82EA9BF8: 4BFDC0A9  bl 0x82e85ca0
	ctx.lr = 0x82EA9BFC;
	sub_82E85CA0(ctx, base);
	// 82EA9BFC: C00100A0  lfs f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9C00: D0010130  stfs f0, 0x130(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82EA9C04: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 82EA9C08: C00100A8  lfs f0, 0xa8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9C0C: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82EA9C10: D0010138  stfs f0, 0x138(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82EA9C14: C00100A4  lfs f0, 0xa4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9C18: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EA9C1C: D0010134  stfs f0, 0x134(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 82EA9C20: 4BFDC081  bl 0x82e85ca0
	ctx.lr = 0x82EA9C24;
	sub_82E85CA0(ctx, base);
	// 82EA9C24: 81740718  lwz r11, 0x718(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA9C28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA9C2C: 4182000C  beq 0x82ea9c38
	if ctx.cr[0].eq {
	pc = 0x82EA9C38; continue 'dispatch;
	}
	// 82EA9C30: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9C34: 48000008  b 0x82ea9c3c
	pc = 0x82EA9C3C; continue 'dispatch;
            }
            0x82EA9C38 => {
    //   block [0x82EA9C38..0x82EA9C3C)
	// 82EA9C38: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	pc = 0x82EA9C3C; continue 'dispatch;
            }
            0x82EA9C3C => {
    //   block [0x82EA9C3C..0x82EA9C90)
	// 82EA9C3C: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 82EA9C40: C1A10150  lfs f13, 0x150(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(336 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9C44: C1810154  lfs f12, 0x154(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9C48: 81740718  lwz r11, 0x718(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA9C4C: C1610158  lfs f11, 0x158(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(344 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA9C50: C1410074  lfs f10, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EA9C54: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA9C58: C1210078  lfs f9, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EA9C5C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9C60: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9C64: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9C68: C1610070  lfs f11, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA9C6C: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EA9C70: D1A100C0  stfs f13, 0xc0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EA9C74: EDAC502A  fadds f13, f12, f10
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EA9C78: D1A100C4  stfs f13, 0xc4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EA9C7C: EC00482A  fadds f0, f0, f9
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EA9C80: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EA9C84: 4182000C  beq 0x82ea9c90
	if ctx.cr[0].eq {
	pc = 0x82EA9C90; continue 'dispatch;
	}
	// 82EA9C88: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9C8C: 48000008  b 0x82ea9c94
	pc = 0x82EA9C94; continue 'dispatch;
            }
            0x82EA9C90 => {
    //   block [0x82EA9C90..0x82EA9C94)
	// 82EA9C90: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	pc = 0x82EA9C94; continue 'dispatch;
            }
            0x82EA9C94 => {
    //   block [0x82EA9C94..0x82EA9D78)
	// 82EA9C94: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 82EA9C98: C1A10170  lfs f13, 0x170(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9C9C: C1810174  lfs f12, 0x174(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9CA0: 81750048  lwz r11, 0x48(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9CA4: C1010178  lfs f8, 0x178(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EA9CA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9CAC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9CB0: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9CB4: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9CB8: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EA9CBC: D1A100E0  stfs f13, 0xe0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EA9CC0: EDAC502A  fadds f13, f12, f10
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EA9CC4: D1A100E4  stfs f13, 0xe4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EA9CC8: EC00482A  fadds f0, f0, f9
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EA9CCC: D00100E8  stfs f0, 0xe8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EA9CD0: 419A00A8  beq cr6, 0x82ea9d78
	if ctx.cr[6].eq {
	pc = 0x82EA9D78; continue 'dispatch;
	}
	// 82EA9CD4: 38E000FF  li r7, 0xff
	ctx.r[7].s64 = 255;
	// 82EA9CD8: 38C00064  li r6, 0x64
	ctx.r[6].s64 = 100;
	// 82EA9CDC: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82EA9CE0: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82EA9CE4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EA9CE8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9CEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9CF0: 4E800421  bctrl
	ctx.lr = 0x82EA9CF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA9CF4: 81750048  lwz r11, 0x48(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9CF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9CFC: 419A007C  beq cr6, 0x82ea9d78
	if ctx.cr[6].eq {
	pc = 0x82EA9D78; continue 'dispatch;
	}
	// 82EA9D00: 38E000FF  li r7, 0xff
	ctx.r[7].s64 = 255;
	// 82EA9D04: 38C00064  li r6, 0x64
	ctx.r[6].s64 = 100;
	// 82EA9D08: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82EA9D0C: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82EA9D10: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EA9D14: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9D18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9D1C: 4E800421  bctrl
	ctx.lr = 0x82EA9D20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA9D20: 81750048  lwz r11, 0x48(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9D24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9D28: 419A0050  beq cr6, 0x82ea9d78
	if ctx.cr[6].eq {
	pc = 0x82EA9D78; continue 'dispatch;
	}
	// 82EA9D2C: 38E000FF  li r7, 0xff
	ctx.r[7].s64 = 255;
	// 82EA9D30: 38C00064  li r6, 0x64
	ctx.r[6].s64 = 100;
	// 82EA9D34: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82EA9D38: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82EA9D3C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82EA9D40: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9D44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9D48: 4E800421  bctrl
	ctx.lr = 0x82EA9D4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EA9D4C: 81750048  lwz r11, 0x48(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9D50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9D54: 419A0024  beq cr6, 0x82ea9d78
	if ctx.cr[6].eq {
	pc = 0x82EA9D78; continue 'dispatch;
	}
	// 82EA9D58: 38E000FF  li r7, 0xff
	ctx.r[7].s64 = 255;
	// 82EA9D5C: 38C00064  li r6, 0x64
	ctx.r[6].s64 = 100;
	// 82EA9D60: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82EA9D64: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82EA9D68: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82EA9D6C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9D70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9D74: 4E800421  bctrl
	ctx.lr = 0x82EA9D78;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA9D78 => {
    //   block [0x82EA9D78..0x82EA9D90)
	// 82EA9D78: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EA9D7C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82EA9D80: 3B7B0018  addi r27, r27, 0x18
	ctx.r[27].s64 = ctx.r[27].s64 + 24;
	// 82EA9D84: 3BBD001C  addi r29, r29, 0x1c
	ctx.r[29].s64 = ctx.r[29].s64 + 28;
	// 82EA9D88: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA9D8C: 4198FC40  blt cr6, 0x82ea99cc
	if ctx.cr[6].lt {
	pc = 0x82EA99CC; continue 'dispatch;
	}
	pc = 0x82EA9D90; continue 'dispatch;
            }
            0x82EA9D90 => {
    //   block [0x82EA9D90..0x82EA9DB4)
	// 82EA9D90: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA9D94: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82EA9D98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9D9C: 40990270  ble cr6, 0x82eaa00c
	if !ctx.cr[6].gt {
	pc = 0x82EAA00C; continue 'dispatch;
	}
	// 82EA9DA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EA9DA4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EA9DA8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EA9DAC: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EA9DB0: C38B0B24  lfs f28, 0xb24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	pc = 0x82EA9DB4; continue 'dispatch;
            }
            0x82EA9DB4 => {
    //   block [0x82EA9DB4..0x82EA9DEC)
	// 82EA9DB4: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA9DB8: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA9DBC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EA9DC0: 41980234  blt cr6, 0x82ea9ff4
	if ctx.cr[6].lt {
	pc = 0x82EA9FF4; continue 'dispatch;
	}
	// 82EA9DC4: 813F005C  lwz r9, 0x5c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA9DC8: 3B39001E  addi r25, r25, 0x1e
	ctx.r[25].s64 = ctx.r[25].s64 + 30;
	// 82EA9DCC: 81740718  lwz r11, 0x718(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA9DD0: 815F0060  lwz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EA9DD4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA9DD8: 7D4ABA14  add r10, r10, r23
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[23].u64;
	// 82EA9DDC: 7FC9E02E  lwzx r30, r9, r28
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EA9DE0: 4182000C  beq 0x82ea9dec
	if ctx.cr[0].eq {
	pc = 0x82EA9DEC; continue 'dispatch;
	}
	// 82EA9DE4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9DE8: 48000008  b 0x82ea9df0
	pc = 0x82EA9DF0; continue 'dispatch;
            }
            0x82EA9DEC => {
    //   block [0x82EA9DEC..0x82EA9DF0)
	// 82EA9DEC: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	pc = 0x82EA9DF0; continue 'dispatch;
            }
            0x82EA9DF0 => {
    //   block [0x82EA9DF0..0x82EA9E5C)
	// 82EA9DF0: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 82EA9DF4: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9DF8: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9DFC: 81750048  lwz r11, 0x48(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9E00: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA9E04: C15E0008  lfs f10, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EA9E08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9E0C: C13E0004  lfs f9, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EA9E10: C11E0000  lfs f8, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EA9E14: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9E18: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9E1C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EA9E20: EDA9682A  fadds f13, f9, f13
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA9E24: D1A10194  stfs f13, 0x194(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 82EA9E28: ED8A602A  fadds f12, f10, f12
	ctx.f[12].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EA9E2C: D1810198  stfs f12, 0x198(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82EA9E30: EC00402A  fadds f0, f0, f8
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82EA9E34: D0010190  stfs f0, 0x190(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82EA9E38: 419A0024  beq cr6, 0x82ea9e5c
	if ctx.cr[6].eq {
	pc = 0x82EA9E5C; continue 'dispatch;
	}
	// 82EA9E3C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EA9E40: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 82EA9E44: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 82EA9E48: 38810190  addi r4, r1, 0x190
	ctx.r[4].s64 = ctx.r[1].s64 + 400;
	// 82EA9E4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EA9E50: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9E54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9E58: 4E800421  bctrl
	ctx.lr = 0x82EA9E5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA9E5C => {
    //   block [0x82EA9E5C..0x82EA9E78)
	// 82EA9E5C: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA9E60: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82EA9E64: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA9E68: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EA9E6C: 40990188  ble cr6, 0x82ea9ff4
	if !ctx.cr[6].gt {
	pc = 0x82EA9FF4; continue 'dispatch;
	}
	// 82EA9E70: 5658063E  clrlwi r24, r18, 0x18
	ctx.r[24].u64 = ctx.r[18].u32 as u64 & 0x000000FFu64;
	// 82EA9E74: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	pc = 0x82EA9E78; continue 'dispatch;
            }
            0x82EA9E78 => {
    //   block [0x82EA9E78..0x82EA9EB0)
	// 82EA9E78: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EA9E7C: 81550048  lwz r10, 0x48(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9E80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EA9E84: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EA9E88: 7FABDA14  add r29, r11, r27
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EA9E8C: 419A0024  beq cr6, 0x82ea9eb0
	if ctx.cr[6].eq {
	pc = 0x82EA9EB0; continue 'dispatch;
	}
	// 82EA9E90: 5727063E  clrlwi r7, r25, 0x18
	ctx.r[7].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 82EA9E94: 38C00032  li r6, 0x32
	ctx.r[6].s64 = 50;
	// 82EA9E98: 38A00032  li r5, 0x32
	ctx.r[5].s64 = 50;
	// 82EA9E9C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EA9EA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EA9EA4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9EA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9EAC: 4E800421  bctrl
	ctx.lr = 0x82EA9EB0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA9EB0 => {
    //   block [0x82EA9EB0..0x82EA9F44)
	// 82EA9EB0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82EA9EB4: 419A0124  beq cr6, 0x82ea9fd8
	if ctx.cr[6].eq {
	pc = 0x82EA9FD8; continue 'dispatch;
	}
	// 82EA9EB8: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9EBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EA9EC0: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9EC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EA9EC8: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA9ECC: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9ED0: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9ED4: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EA9ED8: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA9EDC: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9EE0: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EA9EE4: EFE006F2  fmuls f31, f0, f27
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA9EE8: D3E101D0  stfs f31, 0x1d0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 82EA9EEC: EFCD06F2  fmuls f30, f13, f27
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA9EF0: D3C101D4  stfs f30, 0x1d4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 82EA9EF4: EFAC06F2  fmuls f29, f12, f27
	ctx.f[29].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EA9EF8: D3A101D8  stfs f29, 0x1d8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 82EA9EFC: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9F00: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9F04: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EA9F08: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EA9F0C: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9F10: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9F14: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EA9F18: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EA9F1C: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9F20: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9F24: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EA9F28: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EA9F2C: 4B3D533D  bl 0x8227f268
	ctx.lr = 0x82EA9F30;
	sub_8227F268(ctx, base);
	// 82EA9F30: 81740718  lwz r11, 0x718(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EA9F34: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EA9F38: 4182000C  beq 0x82ea9f44
	if ctx.cr[0].eq {
	pc = 0x82EA9F44; continue 'dispatch;
	}
	// 82EA9F3C: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EA9F40: 48000008  b 0x82ea9f48
	pc = 0x82EA9F48; continue 'dispatch;
            }
            0x82EA9F44 => {
    //   block [0x82EA9F44..0x82EA9F48)
	// 82EA9F44: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	pc = 0x82EA9F48; continue 'dispatch;
            }
            0x82EA9F48 => {
    //   block [0x82EA9F48..0x82EA9FD8)
	// 82EA9F48: C1530004  lfs f10, 4(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EA9F4C: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EA9F50: FCA05090  fmr f5, f10
	ctx.f[5].f64 = ctx.f[10].f64;
	// 82EA9F54: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EA9F58: C1730008  lfs f11, 8(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA9F5C: 81750048  lwz r11, 0x48(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EA9F60: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EA9F64: ED2C02F2  fmuls f9, f12, f11
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EA9F68: C0F30000  lfs f7, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EA9F6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EA9F70: C1610060  lfs f11, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EA9F74: ECED01F2  fmuls f7, f13, f7
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[7].f64) as f32) as f64);
	// 82EA9F78: C1130008  lfs f8, 8(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EA9F7C: C0D30000  lfs f6, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EA9F80: ECAB0172  fmuls f5, f11, f5
	ctx.f[5].f64 = (((ctx.f[11].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EA9F84: EDAD4AB8  fmsubs f13, f13, f10, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EA9F88: ED6B3A38  fmsubs f11, f11, f8, f7
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[8].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EA9F8C: ED8C29B8  fmsubs f12, f12, f6, f5
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[6].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EA9F90: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9F94: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9F98: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EA9F9C: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EA9FA0: D1A101B0  stfs f13, 0x1b0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 82EA9FA4: EDABF02A  fadds f13, f11, f30
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EA9FA8: D1A101B4  stfs f13, 0x1b4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 82EA9FAC: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EA9FB0: D00101B8  stfs f0, 0x1b8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 82EA9FB4: 419A0024  beq cr6, 0x82ea9fd8
	if ctx.cr[6].eq {
	pc = 0x82EA9FD8; continue 'dispatch;
	}
	// 82EA9FB8: 38E000FF  li r7, 0xff
	ctx.r[7].s64 = 255;
	// 82EA9FBC: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 82EA9FC0: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82EA9FC4: 388101B0  addi r4, r1, 0x1b0
	ctx.r[4].s64 = ctx.r[1].s64 + 432;
	// 82EA9FC8: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 82EA9FCC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EA9FD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EA9FD4: 4E800421  bctrl
	ctx.lr = 0x82EA9FD8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EA9FD8 => {
    //   block [0x82EA9FD8..0x82EA9FF4)
	// 82EA9FD8: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EA9FDC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EA9FE0: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82EA9FE4: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 82EA9FE8: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EA9FEC: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EA9FF0: 4198FE88  blt cr6, 0x82ea9e78
	if ctx.cr[6].lt {
	pc = 0x82EA9E78; continue 'dispatch;
	}
	pc = 0x82EA9FF4; continue 'dispatch;
            }
            0x82EA9FF4 => {
    //   block [0x82EA9FF4..0x82EAA00C)
	// 82EA9FF4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EA9FF8: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 82EA9FFC: 3AF7000C  addi r23, r23, 0xc
	ctx.r[23].s64 = ctx.r[23].s64 + 12;
	// 82EAA000: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EAA004: 7F165840  cmplw cr6, r22, r11
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAA008: 4198FDAC  blt cr6, 0x82ea9db4
	if ctx.cr[6].lt {
	pc = 0x82EA9DB4; continue 'dispatch;
	}
	pc = 0x82EAA00C; continue 'dispatch;
            }
            0x82EAA00C => {
    //   block [0x82EAA00C..0x82EAA01C)
	// 82EAA00C: 38210290  addi r1, r1, 0x290
	ctx.r[1].s64 = ctx.r[1].s64 + 656;
	// 82EAA010: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 82EAA014: 4BE03D05  bl 0x82cadd18
	ctx.lr = 0x82EAA018;
	sub_82CADCEC(ctx, base);
	// 82EAA018: 4BDFF418  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAA020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAA020 size=88
    let mut pc: u32 = 0x82EAA020;
    'dispatch: loop {
        match pc {
            0x82EAA020 => {
    //   block [0x82EAA020..0x82EAA05C)
	// 82EAA020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAA024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAA028: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAA02C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAA030: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAA034: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAA038: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAA03C: 4BFFC375  bl 0x82ea63b0
	ctx.lr = 0x82EAA040;
	sub_82EA63B0(ctx, base);
	// 82EAA040: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA044: 41820018  beq 0x82eaa05c
	if ctx.cr[0].eq {
	pc = 0x82EAA05C; continue 'dispatch;
	}
	// 82EAA048: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAA04C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAA050: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAA054: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAA058: 4E800421  bctrl
	ctx.lr = 0x82EAA05C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAA05C => {
    //   block [0x82EAA05C..0x82EAA078)
	// 82EAA05C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAA060: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAA064: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAA068: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAA06C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAA070: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAA074: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAA078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAA078 size=124
    let mut pc: u32 = 0x82EAA078;
    'dispatch: loop {
        match pc {
            0x82EAA078 => {
    //   block [0x82EAA078..0x82EAA0BC)
	// 82EAA078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAA07C: 4BDFF391  bl 0x82ca940c
	ctx.lr = 0x82EAA080;
	sub_82CA93D0(ctx, base);
	// 82EAA080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAA084: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EAA088: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EAA08C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAA090: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EAA094: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAA098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAA09C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAA0A0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAA0A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAA0A8: 4E800421  bctrl
	ctx.lr = 0x82EAA0AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAA0AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA0B0: 4082000C  bne 0x82eaa0bc
	if !ctx.cr[0].eq {
	pc = 0x82EAA0BC; continue 'dispatch;
	}
	// 82EAA0B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EAA0B8: 48000034  b 0x82eaa0ec
	pc = 0x82EAA0EC; continue 'dispatch;
            }
            0x82EAA0BC => {
    //   block [0x82EAA0BC..0x82EAA0EC)
	// 82EAA0BC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EAA0C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAA0C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EAA0C8: 4BFFD231  bl 0x82ea72f8
	ctx.lr = 0x82EAA0CC;
	sub_82EA72F8(ctx, base);
	// 82EAA0CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAA0D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EAA0D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EAA0D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAA0DC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAA0E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAA0E4: 4E800421  bctrl
	ctx.lr = 0x82EAA0E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAA0E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
            }
            0x82EAA0EC => {
    //   block [0x82EAA0EC..0x82EAA0F4)
	// 82EAA0EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAA0F0: 4BDFF36C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAA0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAA0F8 size=88
    let mut pc: u32 = 0x82EAA0F8;
    'dispatch: loop {
        match pc {
            0x82EAA0F8 => {
    //   block [0x82EAA0F8..0x82EAA134)
	// 82EAA0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAA0FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAA100: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAA104: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAA108: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAA10C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAA110: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAA114: 4BFFF14D  bl 0x82ea9260
	ctx.lr = 0x82EAA118;
	sub_82EA9260(ctx, base);
	// 82EAA118: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA11C: 41820018  beq 0x82eaa134
	if ctx.cr[0].eq {
	pc = 0x82EAA134; continue 'dispatch;
	}
	// 82EAA120: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAA124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAA128: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAA12C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAA130: 4E800421  bctrl
	ctx.lr = 0x82EAA134;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAA134 => {
    //   block [0x82EAA134..0x82EAA150)
	// 82EAA134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAA138: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAA13C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAA140: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAA144: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAA148: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAA14C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAA150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAA150 size=232
    let mut pc: u32 = 0x82EAA150;
    'dispatch: loop {
        match pc {
            0x82EAA150 => {
    //   block [0x82EAA150..0x82EAA1A8)
	// 82EAA150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAA154: 4BDFF2A1  bl 0x82ca93f4
	ctx.lr = 0x82EAA158;
	sub_82CA93D0(ctx, base);
	// 82EAA158: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAA15C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EAA160: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82EAA164: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82EAA168: 815C002C  lwz r10, 0x2c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EAA16C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAA170: 418200C0  beq 0x82eaa230
	if ctx.cr[0].eq {
	pc = 0x82EAA230; continue 'dispatch;
	}
	// 82EAA174: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EAA178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAA17C: 419A00B4  beq cr6, 0x82eaa230
	if ctx.cr[6].eq {
	pc = 0x82EAA230; continue 'dispatch;
	}
	// 82EAA180: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EAA184: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAA188: 419A00A8  beq cr6, 0x82eaa230
	if ctx.cr[6].eq {
	pc = 0x82EAA230; continue 'dispatch;
	}
	// 82EAA18C: 813C0024  lwz r9, 0x24(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EAA190: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 82EAA194: 419A009C  beq cr6, 0x82eaa230
	if ctx.cr[6].eq {
	pc = 0x82EAA230; continue 'dispatch;
	}
	// 82EAA198: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EAA19C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAA1A0: 419A0090  beq cr6, 0x82eaa230
	if ctx.cr[6].eq {
	pc = 0x82EAA230; continue 'dispatch;
	}
	// 82EAA1A4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x82EAA1A8; continue 'dispatch;
            }
            0x82EAA1A8 => {
    //   block [0x82EAA1A8..0x82EAA1BC)
	// 82EAA1A8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EAA1AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EAA1B0: 419A006C  beq cr6, 0x82eaa21c
	if ctx.cr[6].eq {
	pc = 0x82EAA21C; continue 'dispatch;
	}
	// 82EAA1B4: 7D7B502E  lwzx r11, r27, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EAA1B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82EAA1BC; continue 'dispatch;
            }
            0x82EAA1BC => {
    //   block [0x82EAA1BC..0x82EAA1D0)
	// 82EAA1BC: 7D3F582E  lwzx r9, r31, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAA1C0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EAA1C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EAA1C8: 40990040  ble cr6, 0x82eaa208
	if !ctx.cr[6].gt {
	pc = 0x82EAA208; continue 'dispatch;
	}
	// 82EAA1CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82EAA1D0; continue 'dispatch;
            }
            0x82EAA1D0 => {
    //   block [0x82EAA1D0..0x82EAA208)
	// 82EAA1D0: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EAA1D4: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82EAA1D8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EAA1DC: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAA1E0: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82EAA1E4: 7C6BEA14  add r3, r11, r29
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EAA1E8: 4BFFF0C1  bl 0x82ea92a8
	ctx.lr = 0x82EAA1EC;
	sub_82EA92A8(ctx, base);
	// 82EAA1EC: 815C002C  lwz r10, 0x2c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EAA1F0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EAA1F4: 3BBD0064  addi r29, r29, 0x64
	ctx.r[29].s64 = ctx.r[29].s64 + 100;
	// 82EAA1F8: 7D7B502E  lwzx r11, r27, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EAA1FC: 7D2BF82E  lwzx r9, r11, r31
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82EAA200: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EAA204: 4198FFCC  blt cr6, 0x82eaa1d0
	if ctx.cr[6].lt {
	pc = 0x82EAA1D0; continue 'dispatch;
	}
	pc = 0x82EAA208; continue 'dispatch;
            }
            0x82EAA208 => {
    //   block [0x82EAA208..0x82EAA21C)
	// 82EAA208: 813C0024  lwz r9, 0x24(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EAA20C: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EAA210: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EAA214: 7F1A4840  cmplw cr6, r26, r9
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EAA218: 4198FFA4  blt cr6, 0x82eaa1bc
	if ctx.cr[6].lt {
	pc = 0x82EAA1BC; continue 'dispatch;
	}
	pc = 0x82EAA21C; continue 'dispatch;
            }
            0x82EAA21C => {
    //   block [0x82EAA21C..0x82EAA230)
	// 82EAA21C: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EAA220: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82EAA224: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EAA228: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAA22C: 4198FF7C  blt cr6, 0x82eaa1a8
	if ctx.cr[6].lt {
	pc = 0x82EAA1A8; continue 'dispatch;
	}
	pc = 0x82EAA230; continue 'dispatch;
            }
            0x82EAA230 => {
    //   block [0x82EAA230..0x82EAA238)
	// 82EAA230: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EAA234: 4BDFF210  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAA238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAA238 size=116
    let mut pc: u32 = 0x82EAA238;
    'dispatch: loop {
        match pc {
            0x82EAA238 => {
    //   block [0x82EAA238..0x82EAA280)
	// 82EAA238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAA23C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAA240: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAA244: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAA248: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EAA24C: 816A7D54  lwz r11, 0x7d54(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32084 as u32) ) } as u64;
	// 82EAA250: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EAA254: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EAA258: 3BE97950  addi r31, r9, 0x7950
	ctx.r[31].s64 = ctx.r[9].s64 + 31056;
	// 82EAA25C: 40820038  bne 0x82eaa294
	if !ctx.cr[0].eq {
	pc = 0x82EAA294; continue 'dispatch;
	}
	// 82EAA260: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EAA264: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EAA268: 8909DE3C  lbz r8, -0x21c4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8644 as u32) ) } as u64;
	// 82EAA26C: 916A7D54  stw r11, 0x7d54(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32084 as u32), ctx.r[11].u32 ) };
	// 82EAA270: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAA274: 4182000C  beq 0x82eaa280
	if ctx.cr[0].eq {
	pc = 0x82EAA280; continue 'dispatch;
	}
	// 82EAA278: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAA27C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EAA280; continue 'dispatch;
            }
            0x82EAA280 => {
    //   block [0x82EAA280..0x82EAA294)
	// 82EAA280: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAA284: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EAA288: 386A8820  addi r3, r10, -0x77e0
	ctx.r[3].s64 = ctx.r[10].s64 + -30688;
	// 82EAA28C: 9969DE3C  stb r11, -0x21c4(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8644 as u32), ctx.r[11].u8 ) };
	// 82EAA290: 4BDFFC91  bl 0x82ca9f20
	ctx.lr = 0x82EAA294;
	sub_82CA9F20(ctx, base);
	pc = 0x82EAA294; continue 'dispatch;
            }
            0x82EAA294 => {
    //   block [0x82EAA294..0x82EAA2AC)
	// 82EAA294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAA298: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAA29C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAA2A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAA2A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAA2A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAA2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAA2B0 size=200
    let mut pc: u32 = 0x82EAA2B0;
    'dispatch: loop {
        match pc {
            0x82EAA2B0 => {
    //   block [0x82EAA2B0..0x82EAA2E4)
	// 82EAA2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAA2B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAA2B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAA2BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAA2C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAA2C4: 4BFFFF75  bl 0x82eaa238
	ctx.lr = 0x82EAA2C8;
	sub_82EAA238(ctx, base);
	// 82EAA2C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EAA2CC: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EAA2D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EAA2D4: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EAA2D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EAA2DC: 40810054  ble 0x82eaa330
	if !ctx.cr[0].gt {
	pc = 0x82EAA330; continue 'dispatch;
	}
	// 82EAA2E0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EAA2E4; continue 'dispatch;
            }
            0x82EAA2E4 => {
    //   block [0x82EAA2E4..0x82EAA2F0)
	// 82EAA2E4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAA2E8: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EAA2EC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EAA2F0; continue 'dispatch;
            }
            0x82EAA2F0 => {
    //   block [0x82EAA2F0..0x82EAA314)
	// 82EAA2F0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAA2F4: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAA2F8: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EAA2FC: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EAA300: 41820014  beq 0x82eaa314
	if ctx.cr[0].eq {
	pc = 0x82EAA314; continue 'dispatch;
	}
	// 82EAA304: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EAA308: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EAA30C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EAA310: 419AFFE0  beq cr6, 0x82eaa2f0
	if ctx.cr[6].eq {
	pc = 0x82EAA2F0; continue 'dispatch;
	}
	pc = 0x82EAA314; continue 'dispatch;
            }
            0x82EAA314 => {
    //   block [0x82EAA314..0x82EAA330)
	// 82EAA314: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EAA318: 41820028  beq 0x82eaa340
	if ctx.cr[0].eq {
	pc = 0x82EAA340; continue 'dispatch;
	}
	// 82EAA31C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EAA320: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EAA324: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EAA328: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EAA32C: 4198FFB8  blt cr6, 0x82eaa2e4
	if ctx.cr[6].lt {
	pc = 0x82EAA2E4; continue 'dispatch;
	}
	pc = 0x82EAA330; continue 'dispatch;
            }
            0x82EAA330 => {
    //   block [0x82EAA330..0x82EAA340)
	// 82EAA330: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EAA334: 409A0018  bne cr6, 0x82eaa34c
	if !ctx.cr[6].eq {
	pc = 0x82EAA34C; continue 'dispatch;
	}
	// 82EAA338: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EAA33C: 48000028  b 0x82eaa364
	pc = 0x82EAA364; continue 'dispatch;
            }
            0x82EAA340 => {
    //   block [0x82EAA340..0x82EAA34C)
	// 82EAA340: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EAA344: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EAA348: 48000018  b 0x82eaa360
	pc = 0x82EAA360; continue 'dispatch;
            }
            0x82EAA34C => {
    //   block [0x82EAA34C..0x82EAA360)
	// 82EAA34C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EAA350: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EAA354: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EAA358: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EAA35C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EAA360; continue 'dispatch;
            }
            0x82EAA360 => {
    //   block [0x82EAA360..0x82EAA364)
	// 82EAA360: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EAA364; continue 'dispatch;
            }
            0x82EAA364 => {
    //   block [0x82EAA364..0x82EAA378)
	// 82EAA364: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAA368: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAA36C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAA370: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAA374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAA378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAA378 size=196
    let mut pc: u32 = 0x82EAA378;
    'dispatch: loop {
        match pc {
            0x82EAA378 => {
    //   block [0x82EAA378..0x82EAA3B0)
	// 82EAA378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAA37C: 4BDFF089  bl 0x82ca9404
	ctx.lr = 0x82EAA380;
	sub_82CA93D0(ctx, base);
	// 82EAA380: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAA384: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAA388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAA38C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EAA390: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EAA394: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EAA398: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EAA39C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EAA3A0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EAA3A4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EAA3A8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EAA3AC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EAA3B0; continue 'dispatch;
            }
            0x82EAA3B0 => {
    //   block [0x82EAA3B0..0x82EAA3DC)
	// 82EAA3B0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAA3B4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAA3B8: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EAA3BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EAA3C0: 4082FFF0  bne 0x82eaa3b0
	if !ctx.cr[0].eq {
	pc = 0x82EAA3B0; continue 'dispatch;
	}
	// 82EAA3C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAA3C8: 4BFFFEE9  bl 0x82eaa2b0
	ctx.lr = 0x82EAA3CC;
	sub_82EAA2B0(ctx, base);
	// 82EAA3CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA3D0: 4082000C  bne 0x82eaa3dc
	if !ctx.cr[0].eq {
	pc = 0x82EAA3DC; continue 'dispatch;
	}
	// 82EAA3D4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EAA3D8: 48000010  b 0x82eaa3e8
	pc = 0x82EAA3E8; continue 'dispatch;
            }
            0x82EAA3DC => {
    //   block [0x82EAA3DC..0x82EAA3E8)
	// 82EAA3DC: 4BFFFE5D  bl 0x82eaa238
	ctx.lr = 0x82EAA3E0;
	sub_82EAA238(ctx, base);
	// 82EAA3E0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EAA3E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EAA3E8; continue 'dispatch;
            }
            0x82EAA3E8 => {
    //   block [0x82EAA3E8..0x82EAA40C)
	// 82EAA3E8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EAA3EC: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EAA3F0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EAA3F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAA3F8: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EAA3FC: 409A0010  bne cr6, 0x82eaa40c
	if !ctx.cr[6].eq {
	pc = 0x82EAA40C; continue 'dispatch;
	}
	// 82EAA400: 4BFD5659  bl 0x82e7fa58
	ctx.lr = 0x82EAA404;
	sub_82E7FA58(ctx, base);
	// 82EAA404: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EAA408: 4800000C  b 0x82eaa414
	pc = 0x82EAA414; continue 'dispatch;
            }
            0x82EAA40C => {
    //   block [0x82EAA40C..0x82EAA414)
	// 82EAA40C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAA410: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EAA414; continue 'dispatch;
            }
            0x82EAA414 => {
    //   block [0x82EAA414..0x82EAA430)
	// 82EAA414: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA418: 41820018  beq 0x82eaa430
	if ctx.cr[0].eq {
	pc = 0x82EAA430; continue 'dispatch;
	}
	// 82EAA41C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAA420: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EAA424: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EAA428: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EAA42C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EAA430; continue 'dispatch;
            }
            0x82EAA430 => {
    //   block [0x82EAA430..0x82EAA43C)
	// 82EAA430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAA434: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EAA438: 4BDFF01C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAA440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAA440 size=72
    let mut pc: u32 = 0x82EAA440;
    'dispatch: loop {
        match pc {
            0x82EAA440 => {
    //   block [0x82EAA440..0x82EAA488)
	// 82EAA440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAA444: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAA448: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAA44C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAA450: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EAA454: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EAA458: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAA45C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAA460: 4BFFFF19  bl 0x82eaa378
	ctx.lr = 0x82EAA464;
	sub_82EAA378(ctx, base);
	// 82EAA464: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAA468: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAA46C: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EAA470: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAA474: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAA478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAA47C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAA480: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAA484: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAA488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EAA488 size=2040
    let mut pc: u32 = 0x82EAA488;
    'dispatch: loop {
        match pc {
            0x82EAA488 => {
    //   block [0x82EAA488..0x82EAA4E8)
	// 82EAA488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAA48C: 4BDFEF45  bl 0x82ca93d0
	ctx.lr = 0x82EAA490;
	sub_82CA93D0(ctx, base);
	// 82EAA490: DBA1FF50  stfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.f[29].u64 ) };
	// 82EAA494: DBC1FF58  stfd f30, -0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 82EAA498: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 82EAA49C: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAA4A0: 7CAF2B78  mr r15, r5
	ctx.r[15].u64 = ctx.r[5].u64;
	// 82EAA4A4: 906101A4  stw r3, 0x1a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), ctx.r[3].u32 ) };
	// 82EAA4A8: 7C902378  mr r16, r4
	ctx.r[16].u64 = ctx.r[4].u64;
	// 82EAA4AC: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 82EAA4B0: 2B0F0001  cmplwi cr6, r15, 1
	ctx.cr[6].compare_u32(ctx.r[15].u32, 1 as u32, &mut ctx.xer);
	// 82EAA4B4: 419807B8  blt cr6, 0x82eaac6c
	if ctx.cr[6].lt {
	pc = 0x82EAAC6C; continue 'dispatch;
	}
	// 82EAA4B8: 419A0770  beq cr6, 0x82eaac28
	if ctx.cr[6].eq {
	pc = 0x82EAAC28; continue 'dispatch;
	}
	// 82EAA4BC: C1B00004  lfs f13, 4(r16)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EAA4C0: 2B0F0001  cmplwi cr6, r15, 1
	ctx.cr[6].compare_u32(ctx.r[15].u32, 1 as u32, &mut ctx.xer);
	// 82EAA4C4: C0100000  lfs f0, 0(r16)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAA4C8: FFA06890  fmr f29, f13
	ctx.f[29].f64 = ctx.f[13].f64;
	// 82EAA4CC: C1900008  lfs f12, 8(r16)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EAA4D0: FD200090  fmr f9, f0
	ctx.f[9].f64 = ctx.f[0].f64;
	// 82EAA4D4: FD006090  fmr f8, f12
	ctx.f[8].f64 = ctx.f[12].f64;
	// 82EAA4D8: FFC06890  fmr f30, f13
	ctx.f[30].f64 = ctx.f[13].f64;
	// 82EAA4DC: 4099006C  ble cr6, 0x82eaa548
	if !ctx.cr[6].gt {
	pc = 0x82EAA548; continue 'dispatch;
	}
	// 82EAA4E0: 39700014  addi r11, r16, 0x14
	ctx.r[11].s64 = ctx.r[16].s64 + 20;
	// 82EAA4E4: 394FFFFF  addi r10, r15, -1
	ctx.r[10].s64 = ctx.r[15].s64 + -1;
	pc = 0x82EAA4E8; continue 'dispatch;
            }
            0x82EAA4E8 => {
    //   block [0x82EAA4E8..0x82EAA4F8)
	// 82EAA4E8: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EAA4EC: FF096800  fcmpu cr6, f9, f13
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[13].f64);
	// 82EAA4F0: 40990008  ble cr6, 0x82eaa4f8
	if !ctx.cr[6].gt {
	pc = 0x82EAA4F8; continue 'dispatch;
	}
	// 82EAA4F4: FD206890  fmr f9, f13
	ctx.f[9].f64 = ctx.f[13].f64;
	pc = 0x82EAA4F8; continue 'dispatch;
            }
            0x82EAA4F8 => {
    //   block [0x82EAA4F8..0x82EAA504)
	// 82EAA4F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EAA4FC: 40980008  bge cr6, 0x82eaa504
	if !ctx.cr[6].lt {
	pc = 0x82EAA504; continue 'dispatch;
	}
	// 82EAA500: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EAA504; continue 'dispatch;
            }
            0x82EAA504 => {
    //   block [0x82EAA504..0x82EAA514)
	// 82EAA504: C1ABFFFC  lfs f13, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EAA508: FF1D6800  fcmpu cr6, f29, f13
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[13].f64);
	// 82EAA50C: 40990008  ble cr6, 0x82eaa514
	if !ctx.cr[6].gt {
	pc = 0x82EAA514; continue 'dispatch;
	}
	// 82EAA510: FFA06890  fmr f29, f13
	ctx.f[29].f64 = ctx.f[13].f64;
	pc = 0x82EAA514; continue 'dispatch;
            }
            0x82EAA514 => {
    //   block [0x82EAA514..0x82EAA520)
	// 82EAA514: FF1E6800  fcmpu cr6, f30, f13
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[13].f64);
	// 82EAA518: 40980008  bge cr6, 0x82eaa520
	if !ctx.cr[6].lt {
	pc = 0x82EAA520; continue 'dispatch;
	}
	// 82EAA51C: FFC06890  fmr f30, f13
	ctx.f[30].f64 = ctx.f[13].f64;
	pc = 0x82EAA520; continue 'dispatch;
            }
            0x82EAA520 => {
    //   block [0x82EAA520..0x82EAA530)
	// 82EAA520: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EAA524: FF086800  fcmpu cr6, f8, f13
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[13].f64);
	// 82EAA528: 40990008  ble cr6, 0x82eaa530
	if !ctx.cr[6].gt {
	pc = 0x82EAA530; continue 'dispatch;
	}
	// 82EAA52C: FD006890  fmr f8, f13
	ctx.f[8].f64 = ctx.f[13].f64;
	pc = 0x82EAA530; continue 'dispatch;
            }
            0x82EAA530 => {
    //   block [0x82EAA530..0x82EAA53C)
	// 82EAA530: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EAA534: 40980008  bge cr6, 0x82eaa53c
	if !ctx.cr[6].lt {
	pc = 0x82EAA53C; continue 'dispatch;
	}
	// 82EAA538: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	pc = 0x82EAA53C; continue 'dispatch;
            }
            0x82EAA53C => {
    //   block [0x82EAA53C..0x82EAA548)
	// 82EAA53C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAA540: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EAA544: 4082FFA4  bne 0x82eaa4e8
	if !ctx.cr[0].eq {
	pc = 0x82EAA4E8; continue 'dispatch;
	}
	pc = 0x82EAA548; continue 'dispatch;
            }
            0x82EAA548 => {
    //   block [0x82EAA548..0x82EAA590)
	// 82EAA548: C1A3000C  lfs f13, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EAA54C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EAA550: ED296828  fsubs f9, f9, f13
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EAA554: C1430010  lfs f10, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EAA558: C0E30008  lfs f7, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EAA55C: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82EAA560: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EAA564: C16B0C14  lfs f11, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EAA568: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82EAA56C: ED6B3824  fdivs f11, f11, f7
	ctx.f[11].f64 = ((ctx.f[11].f64 / ctx.f[7].f64) as f32) as f64;
	// 82EAA570: ED295028  fsubs f9, f9, f10
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EAA574: ED2902F2  fmuls f9, f9, f11
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EAA578: FD20481E  fctiwz f9, f9
	ctx.f[9].s64 = if ctx.f[9].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[9].f64.trunc() as i32 as i64 };
	// 82EAA57C: 7D2057AE  stfiwx f9, 0, r10
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82EAA580: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAA584: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA588: 41980008  blt cr6, 0x82eaa590
	if ctx.cr[6].lt {
	pc = 0x82EAA590; continue 'dispatch;
	}
	// 82EAA58C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82EAA590; continue 'dispatch;
            }
            0x82EAA590 => {
    //   block [0x82EAA590..0x82EAA5C0)
	// 82EAA590: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EAA594: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82EAA598: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EAA59C: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 82EAA5A0: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EAA5A4: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EAA5A8: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82EAA5AC: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82EAA5B0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAA5B4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAA5B8: 40980008  bge cr6, 0x82eaa5c0
	if !ctx.cr[6].lt {
	pc = 0x82EAA5C0; continue 'dispatch;
	}
	// 82EAA5BC: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	pc = 0x82EAA5C0; continue 'dispatch;
            }
            0x82EAA5C0 => {
    //   block [0x82EAA5C0..0x82EAA5F4)
	// 82EAA5C0: ED486828  fsubs f10, f8, f13
	ctx.f[10].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EAA5C4: C0030018  lfs f0, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAA5C8: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 82EAA5CC: 90A100AC  stw r5, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[5].u32 ) };
	// 82EAA5D0: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 82EAA5D4: ED4A0028  fsubs f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EAA5D8: ED4A02F2  fmuls f10, f10, f11
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EAA5DC: FD40501E  fctiwz f10, f10
	ctx.f[10].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 82EAA5E0: 7D405FAE  stfiwx f10, 0, r11
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EAA5E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAA5E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA5EC: 41980008  blt cr6, 0x82eaa5f4
	if ctx.cr[6].lt {
	pc = 0x82EAA5F4; continue 'dispatch;
	}
	// 82EAA5F0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EAA5F4; continue 'dispatch;
            }
            0x82EAA5F4 => {
    //   block [0x82EAA5F4..0x82EAA628)
	// 82EAA5F4: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EAA5F8: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82EAA5FC: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EAA600: 90C100A8  stw r6, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[6].u32 ) };
	// 82EAA604: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 82EAA608: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EAA60C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EAA610: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82EAA614: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82EAA618: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAA61C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAA620: 40980008  bge cr6, 0x82eaa628
	if !ctx.cr[6].lt {
	pc = 0x82EAA628; continue 'dispatch;
	}
	// 82EAA624: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	pc = 0x82EAA628; continue 'dispatch;
            }
            0x82EAA628 => {
    //   block [0x82EAA628..0x82EAA684)
	// 82EAA628: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EAA62C: 90E1009C  stw r7, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[7].u32 ) };
	// 82EAA630: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82EAA634: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EAA638: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAA63C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EAA640: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82EAA644: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EAA648: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAA64C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EAA650: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EAA654: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EAA658: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EAA65C: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EAA660: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EAA664: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EAA668: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EAA66C: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EAA670: 419905FC  bgt cr6, 0x82eaac6c
	if ctx.cr[6].gt {
	pc = 0x82EAAC6C; continue 'dispatch;
	}
	// 82EAA674: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EAA678: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAA67C: 3ACBAFB4  addi r22, r11, -0x504c
	ctx.r[22].s64 = ctx.r[11].s64 + -20556;
	// 82EAA680: C3EA0BEC  lfs f31, 0xbec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EAA684; continue 'dispatch;
            }
            0x82EAA684 => {
    //   block [0x82EAA684..0x82EAA69C)
	// 82EAA684: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EAA688: 4199058C  bgt cr6, 0x82eaac14
	if ctx.cr[6].gt {
	pc = 0x82EAAC14; continue 'dispatch;
	}
	// 82EAA68C: 7D663850  subf r11, r6, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 82EAA690: 5511103A  slwi r17, r8, 2
	ctx.r[17].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[17].u64 = ctx.r[17].u32 as u64;
	// 82EAA694: 54D3103A  slwi r19, r6, 2
	ctx.r[19].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[19].u64 = ctx.r[19].u32 as u64;
	// 82EAA698: 39CB0001  addi r14, r11, 1
	ctx.r[14].s64 = ctx.r[11].s64 + 1;
	pc = 0x82EAA69C; continue 'dispatch;
            }
            0x82EAA69C => {
    //   block [0x82EAA69C..0x82EAA6C4)
	// 82EAA69C: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EAA6A0: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EAA6A4: 7D6B882E  lwzx r11, r11, r17
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 82EAA6A8: 7D51502E  lwzx r10, r17, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EAA6AC: 7D6B982E  lwzx r11, r11, r19
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 82EAA6B0: 7D4A982E  lwzx r10, r10, r19
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 82EAA6B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAA6B8: 41820550  beq 0x82eaac08
	if ctx.cr[0].eq {
	pc = 0x82EAAC08; continue 'dispatch;
	}
	// 82EAA6BC: 3AAA0010  addi r21, r10, 0x10
	ctx.r[21].s64 = ctx.r[10].s64 + 16;
	// 82EAA6C0: 7D725B78  mr r18, r11
	ctx.r[18].u64 = ctx.r[11].u64;
	pc = 0x82EAA6C4; continue 'dispatch;
            }
            0x82EAA6C4 => {
    //   block [0x82EAA6C4..0x82EAA6F4)
	// 82EAA6C4: C0150004  lfs f0, 4(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAA6C8: 3BF5FFF0  addi r31, r21, -0x10
	ctx.r[31].s64 = ctx.r[21].s64 + -16;
	// 82EAA6CC: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EAA6D0: 41980518  blt cr6, 0x82eaabe8
	if ctx.cr[6].lt {
	pc = 0x82EAABE8; continue 'dispatch;
	}
	// 82EAA6D4: C0150000  lfs f0, 0(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAA6D8: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 82EAA6DC: 4199050C  bgt cr6, 0x82eaabe8
	if ctx.cr[6].gt {
	pc = 0x82EAABE8; continue 'dispatch;
	}
	// 82EAA6E0: 378FFFFF  addic. r28, r15, -1
	ctx.xer.ca = (ctx.r[15].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[15].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82EAA6E4: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	// 82EAA6E8: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 82EAA6EC: 4182005C  beq 0x82eaa748
	if ctx.cr[0].eq {
	pc = 0x82EAA748; continue 'dispatch;
	}
	// 82EAA6F0: 7E1D8378  mr r29, r16
	ctx.r[29].u64 = ctx.r[16].u64;
	pc = 0x82EAA6F4; continue 'dispatch;
            }
            0x82EAA6F4 => {
    //   block [0x82EAA6F4..0x82EAA724)
	// 82EAA6F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAA6F8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EAA6FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAA700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAA704: 4B3BD9DD  bl 0x822680e0
	ctx.lr = 0x82EAA708;
	sub_822680E0(ctx, base);
	// 82EAA708: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA70C: 40820018  bne 0x82eaa724
	if !ctx.cr[0].eq {
	pc = 0x82EAA724; continue 'dispatch;
	}
	// 82EAA710: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EAA714: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82EAA718: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EAA71C: 4198FFD8  blt cr6, 0x82eaa6f4
	if ctx.cr[6].lt {
	pc = 0x82EAA6F4; continue 'dispatch;
	}
	// 82EAA720: 48000028  b 0x82eaa748
	pc = 0x82EAA748; continue 'dispatch;
            }
            0x82EAA724 => {
    //   block [0x82EAA724..0x82EAA748)
	// 82EAA724: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 82EAA728: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82EAA72C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAA730: 92C100D0  stw r22, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[22].u32 ) };
	// 82EAA734: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82EAA738: 92E100D4  stw r23, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[23].u32 ) };
	// 82EAA73C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EAA740: 4BFD5431  bl 0x82e7fb70
	ctx.lr = 0x82EAA744;
	sub_82E7FB70(ctx, base);
	// 82EAA744: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	pc = 0x82EAA748; continue 'dispatch;
            }
            0x82EAA748 => {
    //   block [0x82EAA748..0x82EAA768)
	// 82EAA748: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA74C: 4082049C  bne 0x82eaabe8
	if !ctx.cr[0].eq {
	pc = 0x82EAABE8; continue 'dispatch;
	}
	// 82EAA750: 83BF0024  lwz r29, 0x24(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EAA754: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 82EAA758: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAA75C: 41820070  beq 0x82eaa7cc
	if ctx.cr[0].eq {
	pc = 0x82EAA7CC; continue 'dispatch;
	}
	// 82EAA760: 80FF0028  lwz r7, 0x28(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EAA764: 38C7000C  addi r6, r7, 0xc
	ctx.r[6].s64 = ctx.r[7].s64 + 12;
	pc = 0x82EAA768; continue 'dispatch;
            }
            0x82EAA768 => {
    //   block [0x82EAA768..0x82EAA7A8)
	// 82EAA768: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 82EAA76C: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82EAA770: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82EAA774: 4B3DE155  bl 0x822888c8
	ctx.lr = 0x82EAA778;
	sub_822888C8(ctx, base);
	// 82EAA778: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA77C: 4082002C  bne 0x82eaa7a8
	if !ctx.cr[0].eq {
	pc = 0x82EAA7A8; continue 'dispatch;
	}
	// 82EAA780: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82EAA784: 4B3DE145  bl 0x822888c8
	ctx.lr = 0x82EAA788;
	sub_822888C8(ctx, base);
	// 82EAA788: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA78C: 4082001C  bne 0x82eaa7a8
	if !ctx.cr[0].eq {
	pc = 0x82EAA7A8; continue 'dispatch;
	}
	// 82EAA790: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EAA794: 38E70018  addi r7, r7, 0x18
	ctx.r[7].s64 = ctx.r[7].s64 + 24;
	// 82EAA798: 38C60018  addi r6, r6, 0x18
	ctx.r[6].s64 = ctx.r[6].s64 + 24;
	// 82EAA79C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82EAA7A0: 4198FFC8  blt cr6, 0x82eaa768
	if ctx.cr[6].lt {
	pc = 0x82EAA768; continue 'dispatch;
	}
	// 82EAA7A4: 48000028  b 0x82eaa7cc
	pc = 0x82EAA7CC; continue 'dispatch;
            }
            0x82EAA7A8 => {
    //   block [0x82EAA7A8..0x82EAA7CC)
	// 82EAA7A8: 38C100D8  addi r6, r1, 0xd8
	ctx.r[6].s64 = ctx.r[1].s64 + 216;
	// 82EAA7AC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82EAA7B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAA7B4: 92C100D8  stw r22, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[22].u32 ) };
	// 82EAA7B8: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82EAA7BC: 92E100DC  stw r23, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[23].u32 ) };
	// 82EAA7C0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EAA7C4: 4BFD53AD  bl 0x82e7fb70
	ctx.lr = 0x82EAA7C8;
	sub_82E7FB70(ctx, base);
	// 82EAA7C8: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	pc = 0x82EAA7CC; continue 'dispatch;
            }
            0x82EAA7CC => {
    //   block [0x82EAA7CC..0x82EAA7EC)
	// 82EAA7CC: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA7D0: 40820418  bne 0x82eaabe8
	if !ctx.cr[0].eq {
	pc = 0x82EAABE8; continue 'dispatch;
	}
	// 82EAA7D4: 83BF0030  lwz r29, 0x30(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EAA7D8: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 82EAA7DC: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAA7E0: 41820070  beq 0x82eaa850
	if ctx.cr[0].eq {
	pc = 0x82EAA850; continue 'dispatch;
	}
	// 82EAA7E4: 80FF0034  lwz r7, 0x34(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EAA7E8: 38C7000C  addi r6, r7, 0xc
	ctx.r[6].s64 = ctx.r[7].s64 + 12;
	pc = 0x82EAA7EC; continue 'dispatch;
            }
            0x82EAA7EC => {
    //   block [0x82EAA7EC..0x82EAA82C)
	// 82EAA7EC: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 82EAA7F0: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82EAA7F4: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82EAA7F8: 4B3DE0D1  bl 0x822888c8
	ctx.lr = 0x82EAA7FC;
	sub_822888C8(ctx, base);
	// 82EAA7FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA800: 4082002C  bne 0x82eaa82c
	if !ctx.cr[0].eq {
	pc = 0x82EAA82C; continue 'dispatch;
	}
	// 82EAA804: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82EAA808: 4B3DE0C1  bl 0x822888c8
	ctx.lr = 0x82EAA80C;
	sub_822888C8(ctx, base);
	// 82EAA80C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA810: 4082001C  bne 0x82eaa82c
	if !ctx.cr[0].eq {
	pc = 0x82EAA82C; continue 'dispatch;
	}
	// 82EAA814: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EAA818: 38E70018  addi r7, r7, 0x18
	ctx.r[7].s64 = ctx.r[7].s64 + 24;
	// 82EAA81C: 38C60018  addi r6, r6, 0x18
	ctx.r[6].s64 = ctx.r[6].s64 + 24;
	// 82EAA820: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82EAA824: 4198FFC8  blt cr6, 0x82eaa7ec
	if ctx.cr[6].lt {
	pc = 0x82EAA7EC; continue 'dispatch;
	}
	// 82EAA828: 48000028  b 0x82eaa850
	pc = 0x82EAA850; continue 'dispatch;
            }
            0x82EAA82C => {
    //   block [0x82EAA82C..0x82EAA850)
	// 82EAA82C: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 82EAA830: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82EAA834: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAA838: 92C100C0  stw r22, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[22].u32 ) };
	// 82EAA83C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82EAA840: 92E100C4  stw r23, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[23].u32 ) };
	// 82EAA844: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EAA848: 4BFD5329  bl 0x82e7fb70
	ctx.lr = 0x82EAA84C;
	sub_82E7FB70(ctx, base);
	// 82EAA84C: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	pc = 0x82EAA850; continue 'dispatch;
            }
            0x82EAA850 => {
    //   block [0x82EAA850..0x82EAA86C)
	// 82EAA850: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA854: 40820394  bne 0x82eaabe8
	if !ctx.cr[0].eq {
	pc = 0x82EAABE8; continue 'dispatch;
	}
	// 82EAA858: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EAA85C: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82EAA860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAA864: 40990098  ble cr6, 0x82eaa8fc
	if !ctx.cr[6].gt {
	pc = 0x82EAA8FC; continue 'dispatch;
	}
	// 82EAA868: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	pc = 0x82EAA86C; continue 'dispatch;
            }
            0x82EAA86C => {
    //   block [0x82EAA86C..0x82EAA890)
	// 82EAA86C: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EAA870: 7FDD582E  lwzx r30, r29, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAA874: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAA878: 41820070  beq 0x82eaa8e8
	if ctx.cr[0].eq {
	pc = 0x82EAA8E8; continue 'dispatch;
	}
	// 82EAA87C: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 82EAA880: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EAA884: 419A005C  beq cr6, 0x82eaa8e0
	if ctx.cr[6].eq {
	pc = 0x82EAA8E0; continue 'dispatch;
	}
	// 82EAA888: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EAA88C: 7CEBE82E  lwzx r7, r11, r29
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	pc = 0x82EAA890; continue 'dispatch;
            }
            0x82EAA890 => {
    //   block [0x82EAA890..0x82EAA8BC)
	// 82EAA890: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 82EAA894: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82EAA898: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82EAA89C: 4B3DE02D  bl 0x822888c8
	ctx.lr = 0x82EAA8A0;
	sub_822888C8(ctx, base);
	// 82EAA8A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA8A4: 40820018  bne 0x82eaa8bc
	if !ctx.cr[0].eq {
	pc = 0x82EAA8BC; continue 'dispatch;
	}
	// 82EAA8A8: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EAA8AC: 38E7000C  addi r7, r7, 0xc
	ctx.r[7].s64 = ctx.r[7].s64 + 12;
	// 82EAA8B0: 7F06F040  cmplw cr6, r6, r30
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EAA8B4: 4198FFDC  blt cr6, 0x82eaa890
	if ctx.cr[6].lt {
	pc = 0x82EAA890; continue 'dispatch;
	}
	// 82EAA8B8: 48000028  b 0x82eaa8e0
	pc = 0x82EAA8E0; continue 'dispatch;
            }
            0x82EAA8BC => {
    //   block [0x82EAA8BC..0x82EAA8E0)
	// 82EAA8BC: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 82EAA8C0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82EAA8C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAA8C8: 92C100B0  stw r22, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[22].u32 ) };
	// 82EAA8CC: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82EAA8D0: 92E100B4  stw r23, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[23].u32 ) };
	// 82EAA8D4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EAA8D8: 4BFD5299  bl 0x82e7fb70
	ctx.lr = 0x82EAA8DC;
	sub_82E7FB70(ctx, base);
	// 82EAA8DC: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	pc = 0x82EAA8E0; continue 'dispatch;
            }
            0x82EAA8E0 => {
    //   block [0x82EAA8E0..0x82EAA8E8)
	// 82EAA8E0: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA8E4: 40820018  bne 0x82eaa8fc
	if !ctx.cr[0].eq {
	pc = 0x82EAA8FC; continue 'dispatch;
	}
	pc = 0x82EAA8E8; continue 'dispatch;
            }
            0x82EAA8E8 => {
    //   block [0x82EAA8E8..0x82EAA8FC)
	// 82EAA8E8: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EAA8EC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EAA8F0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EAA8F4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAA8F8: 4198FF74  blt cr6, 0x82eaa86c
	if ctx.cr[6].lt {
	pc = 0x82EAA86C; continue 'dispatch;
	}
	pc = 0x82EAA8FC; continue 'dispatch;
            }
            0x82EAA8FC => {
    //   block [0x82EAA8FC..0x82EAA92C)
	// 82EAA8FC: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA900: 408202E8  bne 0x82eaabe8
	if !ctx.cr[0].eq {
	pc = 0x82EAABE8; continue 'dispatch;
	}
	// 82EAA904: C0100000  lfs f0, 0(r16)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAA908: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82EAA90C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EAA910: 2B0F0001  cmplwi cr6, r15, 1
	ctx.cr[6].compare_u32(ctx.r[15].u32, 1 as u32, &mut ctx.xer);
	// 82EAA914: C0100004  lfs f0, 4(r16)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAA918: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EAA91C: C0100008  lfs f0, 8(r16)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAA920: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAA924: 409902C4  ble cr6, 0x82eaabe8
	if !ctx.cr[6].gt {
	pc = 0x82EAABE8; continue 'dispatch;
	}
	// 82EAA928: 3B500014  addi r26, r16, 0x14
	ctx.r[26].s64 = ctx.r[16].s64 + 20;
	pc = 0x82EAA92C; continue 'dispatch;
            }
            0x82EAA92C => {
    //   block [0x82EAA92C..0x82EAA958)
	// 82EAA92C: C01AFFF8  lfs f0, -8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAA930: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 82EAA934: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EAA938: C01AFFFC  lfs f0, -4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAA93C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EAA940: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAA944: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EAA948: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EAA94C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAA950: 4099008C  ble cr6, 0x82eaa9dc
	if !ctx.cr[6].gt {
	pc = 0x82EAA9DC; continue 'dispatch;
	}
	// 82EAA954: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	pc = 0x82EAA958; continue 'dispatch;
            }
            0x82EAA958 => {
    //   block [0x82EAA958..0x82EAA9B8)
	// 82EAA958: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EAA95C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EAA960: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82EAA964: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EAA968: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EAA96C: 38C5000C  addi r6, r5, 0xc
	ctx.r[6].s64 = ctx.r[5].s64 + 12;
	// 82EAA970: 4B3DE7A9  bl 0x82289118
	ctx.lr = 0x82EAA974;
	sub_82289118(ctx, base);
	// 82EAA974: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA978: 40820040  bne 0x82eaa9b8
	if !ctx.cr[0].eq {
	pc = 0x82EAA9B8; continue 'dispatch;
	}
	// 82EAA97C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EAA980: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EAA984: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EAA988: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EAA98C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EAA990: 38C5000C  addi r6, r5, 0xc
	ctx.r[6].s64 = ctx.r[5].s64 + 12;
	// 82EAA994: 4B3DE785  bl 0x82289118
	ctx.lr = 0x82EAA998;
	sub_82289118(ctx, base);
	// 82EAA998: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA99C: 4082001C  bne 0x82eaa9b8
	if !ctx.cr[0].eq {
	pc = 0x82EAA9B8; continue 'dispatch;
	}
	// 82EAA9A0: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EAA9A4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EAA9A8: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 82EAA9AC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAA9B0: 4198FFA8  blt cr6, 0x82eaa958
	if ctx.cr[6].lt {
	pc = 0x82EAA958; continue 'dispatch;
	}
	// 82EAA9B4: 48000028  b 0x82eaa9dc
	pc = 0x82EAA9DC; continue 'dispatch;
            }
            0x82EAA9B8 => {
    //   block [0x82EAA9B8..0x82EAA9DC)
	// 82EAA9B8: 38C100B8  addi r6, r1, 0xb8
	ctx.r[6].s64 = ctx.r[1].s64 + 184;
	// 82EAA9BC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82EAA9C0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAA9C4: 92C100B8  stw r22, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[22].u32 ) };
	// 82EAA9C8: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82EAA9CC: 92E100BC  stw r23, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[23].u32 ) };
	// 82EAA9D0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EAA9D4: 4BFD519D  bl 0x82e7fb70
	ctx.lr = 0x82EAA9D8;
	sub_82E7FB70(ctx, base);
	// 82EAA9D8: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	pc = 0x82EAA9DC; continue 'dispatch;
            }
            0x82EAA9DC => {
    //   block [0x82EAA9DC..0x82EAA9F8)
	// 82EAA9DC: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAA9E0: 40820208  bne 0x82eaabe8
	if !ctx.cr[0].eq {
	pc = 0x82EAABE8; continue 'dispatch;
	}
	// 82EAA9E4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EAA9E8: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 82EAA9EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAA9F0: 4099008C  ble cr6, 0x82eaaa7c
	if !ctx.cr[6].gt {
	pc = 0x82EAAA7C; continue 'dispatch;
	}
	// 82EAA9F4: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	pc = 0x82EAA9F8; continue 'dispatch;
            }
            0x82EAA9F8 => {
    //   block [0x82EAA9F8..0x82EAAA58)
	// 82EAA9F8: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EAA9FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EAAA00: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82EAAA04: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EAAA08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EAAA0C: 38C5000C  addi r6, r5, 0xc
	ctx.r[6].s64 = ctx.r[5].s64 + 12;
	// 82EAAA10: 4B3DE709  bl 0x82289118
	ctx.lr = 0x82EAAA14;
	sub_82289118(ctx, base);
	// 82EAAA14: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAAA18: 40820040  bne 0x82eaaa58
	if !ctx.cr[0].eq {
	pc = 0x82EAAA58; continue 'dispatch;
	}
	// 82EAAA1C: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EAAA20: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EAAA24: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EAAA28: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EAAA2C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EAAA30: 38C5000C  addi r6, r5, 0xc
	ctx.r[6].s64 = ctx.r[5].s64 + 12;
	// 82EAAA34: 4B3DE6E5  bl 0x82289118
	ctx.lr = 0x82EAAA38;
	sub_82289118(ctx, base);
	// 82EAAA38: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAAA3C: 4082001C  bne 0x82eaaa58
	if !ctx.cr[0].eq {
	pc = 0x82EAAA58; continue 'dispatch;
	}
	// 82EAAA40: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EAAA44: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EAAA48: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 82EAAA4C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAAA50: 4198FFA8  blt cr6, 0x82eaa9f8
	if ctx.cr[6].lt {
	pc = 0x82EAA9F8; continue 'dispatch;
	}
	// 82EAAA54: 48000028  b 0x82eaaa7c
	pc = 0x82EAAA7C; continue 'dispatch;
            }
            0x82EAAA58 => {
    //   block [0x82EAAA58..0x82EAAA7C)
	// 82EAAA58: 38C100C8  addi r6, r1, 0xc8
	ctx.r[6].s64 = ctx.r[1].s64 + 200;
	// 82EAAA5C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82EAAA60: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAAA64: 92C100C8  stw r22, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[22].u32 ) };
	// 82EAAA68: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82EAAA6C: 92E100CC  stw r23, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[23].u32 ) };
	// 82EAAA70: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EAAA74: 4BFD50FD  bl 0x82e7fb70
	ctx.lr = 0x82EAAA78;
	sub_82E7FB70(ctx, base);
	// 82EAAA78: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	pc = 0x82EAAA7C; continue 'dispatch;
            }
            0x82EAAA7C => {
    //   block [0x82EAAA7C..0x82EAAA98)
	// 82EAAA7C: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAAA80: 40820168  bne 0x82eaabe8
	if !ctx.cr[0].eq {
	pc = 0x82EAABE8; continue 'dispatch;
	}
	// 82EAAA84: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EAAA88: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 82EAAA8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAAA90: 40990128  ble cr6, 0x82eaabb8
	if !ctx.cr[6].gt {
	pc = 0x82EAABB8; continue 'dispatch;
	}
	// 82EAAA94: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	pc = 0x82EAAA98; continue 'dispatch;
            }
            0x82EAAA98 => {
    //   block [0x82EAAA98..0x82EAAAE0)
	// 82EAAA98: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EAAA9C: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAAAA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAAAA4: 419A0100  beq cr6, 0x82eaaba4
	if ctx.cr[6].eq {
	pc = 0x82EAABA4; continue 'dispatch;
	}
	// 82EAAAA8: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EAAAAC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82EAAAB0: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAAAB4: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAAAB8: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EAAABC: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAAAC0: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EAAAC4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAAAC8: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EAAACC: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EAAAD0: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAAAD4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAAAD8: 409900C4  ble cr6, 0x82eaab9c
	if !ctx.cr[6].gt {
	pc = 0x82EAAB9C; continue 'dispatch;
	}
	// 82EAAADC: 3BA0000C  li r29, 0xc
	ctx.r[29].s64 = 12;
	pc = 0x82EAAAE0; continue 'dispatch;
            }
            0x82EAAAE0 => {
    //   block [0x82EAAAE0..0x82EAAB78)
	// 82EAAAE0: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EAAAE4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EAAAE8: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 82EAAAEC: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EAAAF0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82EAAAF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EAAAF8: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAAAFC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EAAB00: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAAB04: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EAAB08: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAAB0C: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EAAB10: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAAB14: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EAAB18: 4B3DE601  bl 0x82289118
	ctx.lr = 0x82EAAB1C;
	sub_82289118(ctx, base);
	// 82EAAB1C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAAB20: 40820058  bne 0x82eaab78
	if !ctx.cr[0].eq {
	pc = 0x82EAAB78; continue 'dispatch;
	}
	// 82EAAB24: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EAAB28: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 82EAAB2C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EAAB30: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EAAB34: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EAAB38: 4B3DE5E1  bl 0x82289118
	ctx.lr = 0x82EAAB3C;
	sub_82289118(ctx, base);
	// 82EAAB3C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAAB40: 40820038  bne 0x82eaab78
	if !ctx.cr[0].eq {
	pc = 0x82EAAB78; continue 'dispatch;
	}
	// 82EAAB44: C0010090  lfs f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAAB48: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EAAB4C: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EAAB50: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82EAAB54: C0010094  lfs f0, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAAB58: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EAAB5C: C0010098  lfs f0, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAAB60: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EAAB64: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EAAB68: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAAB6C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAAB70: 4198FF70  blt cr6, 0x82eaaae0
	if ctx.cr[6].lt {
	pc = 0x82EAAAE0; continue 'dispatch;
	}
	// 82EAAB74: 48000028  b 0x82eaab9c
	pc = 0x82EAAB9C; continue 'dispatch;
            }
            0x82EAAB78 => {
    //   block [0x82EAAB78..0x82EAAB9C)
	// 82EAAB78: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82EAAB7C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82EAAB80: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAAB84: 92C100A0  stw r22, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[22].u32 ) };
	// 82EAAB88: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82EAAB8C: 92E100A4  stw r23, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[23].u32 ) };
	// 82EAAB90: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EAAB94: 4BFD4FDD  bl 0x82e7fb70
	ctx.lr = 0x82EAAB98;
	sub_82E7FB70(ctx, base);
	// 82EAAB98: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	pc = 0x82EAAB9C; continue 'dispatch;
            }
            0x82EAAB9C => {
    //   block [0x82EAAB9C..0x82EAABA4)
	// 82EAAB9C: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAABA0: 40820018  bne 0x82eaabb8
	if !ctx.cr[0].eq {
	pc = 0x82EAABB8; continue 'dispatch;
	}
	pc = 0x82EAABA4; continue 'dispatch;
            }
            0x82EAABA4 => {
    //   block [0x82EAABA4..0x82EAABB8)
	// 82EAABA4: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EAABA8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EAABAC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EAABB0: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAABB4: 4198FEE4  blt cr6, 0x82eaaa98
	if ctx.cr[6].lt {
	pc = 0x82EAAA98; continue 'dispatch;
	}
	pc = 0x82EAABB8; continue 'dispatch;
            }
            0x82EAABB8 => {
    //   block [0x82EAABB8..0x82EAABE8)
	// 82EAABB8: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAABBC: 4082002C  bne 0x82eaabe8
	if !ctx.cr[0].eq {
	pc = 0x82EAABE8; continue 'dispatch;
	}
	// 82EAABC0: C0010068  lfs f0, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAABC4: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82EAABC8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EAABCC: 3B5A000C  addi r26, r26, 0xc
	ctx.r[26].s64 = ctx.r[26].s64 + 12;
	// 82EAABD0: C001006C  lfs f0, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAABD4: 7F197840  cmplw cr6, r25, r15
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[15].u32, &mut ctx.xer);
	// 82EAABD8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EAABDC: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAABE0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAABE4: 4198FD48  blt cr6, 0x82eaa92c
	if ctx.cr[6].lt {
	pc = 0x82EAA92C; continue 'dispatch;
	}
	pc = 0x82EAABE8; continue 'dispatch;
            }
            0x82EAABE8 => {
    //   block [0x82EAABE8..0x82EAAC08)
	// 82EAABE8: 3652FFFF  addic. r18, r18, -1
	ctx.xer.ca = (ctx.r[18].u32 > (!(-1 as u32)));
	ctx.r[18].s64 = ctx.r[18].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[18].s32, 0, &mut ctx.xer);
	// 82EAABEC: 3AB50064  addi r21, r21, 0x64
	ctx.r[21].s64 = ctx.r[21].s64 + 100;
	// 82EAABF0: 4082FAD4  bne 0x82eaa6c4
	if !ctx.cr[0].eq {
	pc = 0x82EAA6C4; continue 'dispatch;
	}
	// 82EAABF4: 80E1009C  lwz r7, 0x9c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EAABF8: 80C100A8  lwz r6, 0xa8(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EAABFC: 80A100AC  lwz r5, 0xac(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EAAC00: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAAC04: 806101A4  lwz r3, 0x1a4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	pc = 0x82EAAC08; continue 'dispatch;
            }
            0x82EAAC08 => {
    //   block [0x82EAAC08..0x82EAAC14)
	// 82EAAC08: 35CEFFFF  addic. r14, r14, -1
	ctx.xer.ca = (ctx.r[14].u32 > (!(-1 as u32)));
	ctx.r[14].s64 = ctx.r[14].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[14].s32, 0, &mut ctx.xer);
	// 82EAAC0C: 3A730004  addi r19, r19, 4
	ctx.r[19].s64 = ctx.r[19].s64 + 4;
	// 82EAAC10: 4082FA8C  bne 0x82eaa69c
	if !ctx.cr[0].eq {
	pc = 0x82EAA69C; continue 'dispatch;
	}
	pc = 0x82EAAC14; continue 'dispatch;
            }
            0x82EAAC14 => {
    //   block [0x82EAAC14..0x82EAAC28)
	// 82EAAC14: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EAAC18: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EAAC1C: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82EAAC20: 4099FA64  ble cr6, 0x82eaa684
	if !ctx.cr[6].gt {
	pc = 0x82EAA684; continue 'dispatch;
	}
	// 82EAAC24: 48000048  b 0x82eaac6c
	pc = 0x82EAAC6C; continue 'dispatch;
            }
            0x82EAAC28 => {
    //   block [0x82EAAC28..0x82EAAC6C)
	// 82EAAC28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAAC2C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EAAC30: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82EAAC34: 4B3BD34D  bl 0x82267f80
	ctx.lr = 0x82EAAC38;
	sub_82267F80(ctx, base);
	// 82EAAC38: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EAAC3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAAC40: 4182002C  beq 0x82eaac6c
	if ctx.cr[0].eq {
	pc = 0x82EAAC6C; continue 'dispatch;
	}
	// 82EAAC44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAAC48: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82EAAC4C: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EAAC50: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAAC54: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82EAAC58: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EAAC5C: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EAAC60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAAC64: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EAAC68: 4BFD4F09  bl 0x82e7fb70
	ctx.lr = 0x82EAAC6C;
	sub_82E7FB70(ctx, base);
	pc = 0x82EAAC6C; continue 'dispatch;
            }
            0x82EAAC6C => {
    //   block [0x82EAAC6C..0x82EAAC80)
	// 82EAAC6C: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82EAAC70: CBA1FF50  lfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-176 as u32) ) };
	// 82EAAC74: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 82EAAC78: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 82EAAC7C: 4BDFE7A4  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAAC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAAC80 size=116
    let mut pc: u32 = 0x82EAAC80;
    'dispatch: loop {
        match pc {
            0x82EAAC80 => {
    //   block [0x82EAAC80..0x82EAACA4)
	// 82EAAC80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAAC84: 4BDFE789  bl 0x82ca940c
	ctx.lr = 0x82EAAC88;
	sub_82CA93D0(ctx, base);
	// 82EAAC88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAAC8C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAAC90: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EAAC94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EAAC98: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EAAC9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAACA0: 40990040  ble cr6, 0x82eaace0
	if !ctx.cr[6].gt {
	pc = 0x82EAACE0; continue 'dispatch;
	}
	pc = 0x82EAACA4; continue 'dispatch;
            }
            0x82EAACA4 => {
    //   block [0x82EAACA4..0x82EAACE0)
	// 82EAACA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAACA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAACAC: 4BFD937D  bl 0x82e84028
	ctx.lr = 0x82EAACB0;
	sub_82E84028(ctx, base);
	// 82EAACB0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAACB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EAACB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EAACBC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAACC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAACC4: 4E800421  bctrl
	ctx.lr = 0x82EAACC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAACC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAACCC: 41820020  beq 0x82eaacec
	if ctx.cr[0].eq {
	pc = 0x82EAACEC; continue 'dispatch;
	}
	// 82EAACD0: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EAACD4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EAACD8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAACDC: 4198FFC8  blt cr6, 0x82eaaca4
	if ctx.cr[6].lt {
	pc = 0x82EAACA4; continue 'dispatch;
	}
            }
            0x82EAACE0 => {
    //   block [0x82EAACE0..0x82EAACE4)
	// 82EAACE0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EAACE4; continue 'dispatch;
            }
            0x82EAACE4 => {
    //   block [0x82EAACE4..0x82EAACEC)
	// 82EAACE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAACE8: 4BDFE774  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EAACEC => {
    //   block [0x82EAACEC..0x82EAACF4)
	// 82EAACEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EAACF0: 4BFFFFF4  b 0x82eaace4
	pc = 0x82EAACE4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAACF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAACF8 size=120
    let mut pc: u32 = 0x82EAACF8;
    'dispatch: loop {
        match pc {
            0x82EAACF8 => {
    //   block [0x82EAACF8..0x82EAAD18)
	// 82EAACF8: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAACFC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EAAD00: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 82EAAD04: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAAD08: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAAD0C: 409A000C  bne cr6, 0x82eaad18
	if !ctx.cr[6].eq {
	pc = 0x82EAAD18; continue 'dispatch;
	}
	// 82EAAD10: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAAD14: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82EAAD18; continue 'dispatch;
            }
            0x82EAAD18 => {
    //   block [0x82EAAD18..0x82EAAD2C)
	// 82EAAD18: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAAD1C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAAD20: 409A000C  bne cr6, 0x82eaad2c
	if !ctx.cr[6].eq {
	pc = 0x82EAAD2C; continue 'dispatch;
	}
	// 82EAAD24: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAAD28: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x82EAAD2C; continue 'dispatch;
            }
            0x82EAAD2C => {
    //   block [0x82EAAD2C..0x82EAAD40)
	// 82EAAD2C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAAD30: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAAD34: 4182000C  beq 0x82eaad40
	if ctx.cr[0].eq {
	pc = 0x82EAAD40; continue 'dispatch;
	}
	// 82EAAD38: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAAD3C: 912A001C  stw r9, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	pc = 0x82EAAD40; continue 'dispatch;
            }
            0x82EAAD40 => {
    //   block [0x82EAAD40..0x82EAAD54)
	// 82EAAD40: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAAD44: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAAD48: 4182000C  beq 0x82eaad54
	if ctx.cr[0].eq {
	pc = 0x82EAAD54; continue 'dispatch;
	}
	// 82EAAD4C: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAAD50: 912A0018  stw r9, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	pc = 0x82EAAD54; continue 'dispatch;
            }
            0x82EAAD54 => {
    //   block [0x82EAAD54..0x82EAAD70)
	// 82EAAD54: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAAD58: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82EAAD5C: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAAD60: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAAD64: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 82EAAD68: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EAAD6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAAD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAAD70 size=120
    let mut pc: u32 = 0x82EAAD70;
    'dispatch: loop {
        match pc {
            0x82EAAD70 => {
    //   block [0x82EAAD70..0x82EAAD90)
	// 82EAAD70: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAAD74: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EAAD78: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82EAAD7C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAAD80: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAAD84: 409A000C  bne cr6, 0x82eaad90
	if !ctx.cr[6].eq {
	pc = 0x82EAAD90; continue 'dispatch;
	}
	// 82EAAD88: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAAD8C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82EAAD90; continue 'dispatch;
            }
            0x82EAAD90 => {
    //   block [0x82EAAD90..0x82EAADA4)
	// 82EAAD90: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAAD94: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAAD98: 409A000C  bne cr6, 0x82eaada4
	if !ctx.cr[6].eq {
	pc = 0x82EAADA4; continue 'dispatch;
	}
	// 82EAAD9C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAADA0: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x82EAADA4; continue 'dispatch;
            }
            0x82EAADA4 => {
    //   block [0x82EAADA4..0x82EAADB8)
	// 82EAADA4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAADA8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAADAC: 4182000C  beq 0x82eaadb8
	if ctx.cr[0].eq {
	pc = 0x82EAADB8; continue 'dispatch;
	}
	// 82EAADB0: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAADB4: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82EAADB8; continue 'dispatch;
            }
            0x82EAADB8 => {
    //   block [0x82EAADB8..0x82EAADCC)
	// 82EAADB8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAADBC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAADC0: 4182000C  beq 0x82eaadcc
	if ctx.cr[0].eq {
	pc = 0x82EAADCC; continue 'dispatch;
	}
	// 82EAADC4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAADC8: 912A000C  stw r9, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	pc = 0x82EAADCC; continue 'dispatch;
            }
            0x82EAADCC => {
    //   block [0x82EAADCC..0x82EAADE8)
	// 82EAADCC: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAADD0: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EAADD4: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAADD8: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAADDC: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 82EAADE0: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EAADE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAADE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAADE8 size=52
    let mut pc: u32 = 0x82EAADE8;
    'dispatch: loop {
        match pc {
            0x82EAADE8 => {
    //   block [0x82EAADE8..0x82EAAE1C)
	// 82EAADE8: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAADEC: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAADF0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAADF4: 40820028  bne 0x82eaae1c
	if !ctx.cr[0].eq {
		sub_82EAAE1C(ctx, base);
		return;
	}
	// 82EAADF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAADFC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EAAE00: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EAAE04: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EAAE08: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EAAE0C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAAE10: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EAAE14: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EAAE18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAAE1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAAE1C size=200
    let mut pc: u32 = 0x82EAAE1C;
    'dispatch: loop {
        match pc {
            0x82EAAE1C => {
    //   block [0x82EAAE1C..0x82EAAE84)
	// 82EAAE1C: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAAE20: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EAAE24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAAE28: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EAAE2C: 91240014  stw r9, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82EAAE30: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAAE34: 91240010  stw r9, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EAAE38: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAAE3C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EAAE40: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAAE44: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EAAE48: 990B0014  stb r8, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 82EAAE4C: 409A0054  bne cr6, 0x82eaaea0
	if !ctx.cr[6].eq {
	pc = 0x82EAAEA0; continue 'dispatch;
	}
	// 82EAAE50: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAAE54: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAAE58: 4082002C  bne 0x82eaae84
	if !ctx.cr[0].eq {
	pc = 0x82EAAE84; continue 'dispatch;
	}
	// 82EAAE5C: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EAAE60: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EAAE64: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EAAE68: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAAE6C: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EAAE70: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAAE74: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EAAE78: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAAE7C: 91490010  stw r10, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EAAE80: 48000044  b 0x82eaaec4
	pc = 0x82EAAEC4; continue 'dispatch;
            }
            0x82EAAE84 => {
    //   block [0x82EAAE84..0x82EAAEA0)
	// 82EAAE84: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EAAE88: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EAAE8C: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EAAE90: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAAE94: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAAE98: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EAAE9C: 48000028  b 0x82eaaec4
	pc = 0x82EAAEC4; continue 'dispatch;
            }
            0x82EAAEA0 => {
    //   block [0x82EAAEA0..0x82EAAEC0)
	// 82EAAEA0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAAEA4: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EAAEA8: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EAAEAC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAAEB0: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EAAEB4: 4182000C  beq 0x82eaaec0
	if ctx.cr[0].eq {
	pc = 0x82EAAEC0; continue 'dispatch;
	}
	// 82EAAEB8: 91690010  stw r11, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAAEBC: 48000008  b 0x82eaaec4
	pc = 0x82EAAEC4; continue 'dispatch;
            }
            0x82EAAEC0 => {
    //   block [0x82EAAEC0..0x82EAAEC4)
	// 82EAAEC0: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EAAEC4; continue 'dispatch;
            }
            0x82EAAEC4 => {
    //   block [0x82EAAEC4..0x82EAAEE4)
	// 82EAAEC4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EAAEC8: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EAAECC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EAAED0: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EAAED4: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EAAED8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EAAEDC: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EAAEE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAAEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAAEE8 size=52
    let mut pc: u32 = 0x82EAAEE8;
    'dispatch: loop {
        match pc {
            0x82EAAEE8 => {
    //   block [0x82EAAEE8..0x82EAAF1C)
	// 82EAAEE8: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAAEEC: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAAEF0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAAEF4: 40820028  bne 0x82eaaf1c
	if !ctx.cr[0].eq {
		sub_82EAAF1C(ctx, base);
		return;
	}
	// 82EAAEF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAAEFC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EAAF00: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EAAF04: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EAAF08: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EAAF0C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAAF10: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EAAF14: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EAAF18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAAF1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAAF1C size=192
    let mut pc: u32 = 0x82EAAF1C;
    'dispatch: loop {
        match pc {
            0x82EAAF1C => {
    //   block [0x82EAAF1C..0x82EAAF7C)
	// 82EAAF1C: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAAF20: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EAAF24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAAF28: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EAAF2C: 91240014  stw r9, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82EAAF30: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAAF34: 91240010  stw r9, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EAAF38: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAAF3C: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EAAF40: 990B0014  stb r8, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 82EAAF44: 409A0054  bne cr6, 0x82eaaf98
	if !ctx.cr[6].eq {
	pc = 0x82EAAF98; continue 'dispatch;
	}
	// 82EAAF48: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAAF4C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAAF50: 4082002C  bne 0x82eaaf7c
	if !ctx.cr[0].eq {
	pc = 0x82EAAF7C; continue 'dispatch;
	}
	// 82EAAF54: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EAAF58: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EAAF5C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EAAF60: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAAF64: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EAAF68: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAAF6C: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EAAF70: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAAF74: 91490010  stw r10, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EAAF78: 48000044  b 0x82eaafbc
	pc = 0x82EAAFBC; continue 'dispatch;
            }
            0x82EAAF7C => {
    //   block [0x82EAAF7C..0x82EAAF98)
	// 82EAAF7C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EAAF80: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EAAF84: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EAAF88: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAAF8C: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAAF90: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EAAF94: 48000028  b 0x82eaafbc
	pc = 0x82EAAFBC; continue 'dispatch;
            }
            0x82EAAF98 => {
    //   block [0x82EAAF98..0x82EAAFB8)
	// 82EAAF98: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAAF9C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EAAFA0: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EAAFA4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAAFA8: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EAAFAC: 4182000C  beq 0x82eaafb8
	if ctx.cr[0].eq {
	pc = 0x82EAAFB8; continue 'dispatch;
	}
	// 82EAAFB0: 91690010  stw r11, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAAFB4: 48000008  b 0x82eaafbc
	pc = 0x82EAAFBC; continue 'dispatch;
            }
            0x82EAAFB8 => {
    //   block [0x82EAAFB8..0x82EAAFBC)
	// 82EAAFB8: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EAAFBC; continue 'dispatch;
            }
            0x82EAAFBC => {
    //   block [0x82EAAFBC..0x82EAAFDC)
	// 82EAAFBC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EAAFC0: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EAAFC4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EAAFC8: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EAAFCC: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EAAFD0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EAAFD4: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EAAFD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAAFE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAAFE0 size=140
    let mut pc: u32 = 0x82EAAFE0;
    'dispatch: loop {
        match pc {
            0x82EAAFE0 => {
    //   block [0x82EAAFE0..0x82EAB06C)
	// 82EAAFE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAAFE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAAFE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAAFEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAAFF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAAFF4: 4BFFB2FD  bl 0x82ea62f0
	ctx.lr = 0x82EAAFF8;
	sub_82EA62F0(ctx, base);
	// 82EAAFF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAAFFC: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82EAB000: 394BA2B0  addi r10, r11, -0x5d50
	ctx.r[10].s64 = ctx.r[11].s64 + -23888;
	// 82EAB004: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAB008: 38E001F4  li r7, 0x1f4
	ctx.r[7].s64 = 500;
	// 82EAB00C: 392BAFB4  addi r9, r11, -0x504c
	ctx.r[9].s64 = ctx.r[11].s64 + -20556;
	// 82EAB010: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAB014: 911F0020  stw r8, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 82EAB018: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EAB01C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EAB020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAB024: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EAB028: 90FF0024  stw r7, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[7].u32 ) };
	// 82EAB02C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EAB030: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EAB034: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAB038: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EAB03C: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EAB040: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EAB044: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82EAB048: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82EAB04C: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82EAB050: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82EAB054: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82EAB058: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAB05C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAB060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAB064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAB068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAB070 size=12
    let mut pc: u32 = 0x82EAB070;
    'dispatch: loop {
        match pc {
            0x82EAB070 => {
    //   block [0x82EAB070..0x82EAB07C)
	// 82EAB070: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAB074: 386B8570  addi r3, r11, -0x7a90
	ctx.r[3].s64 = ctx.r[11].s64 + -31376;
	// 82EAB078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAB080 size=188
    let mut pc: u32 = 0x82EAB080;
    'dispatch: loop {
        match pc {
            0x82EAB080 => {
    //   block [0x82EAB080..0x82EAB0C4)
	// 82EAB080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAB084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAB088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAB08C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAB090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAB094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAB098: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAB09C: 4182005C  beq 0x82eab0f8
	if ctx.cr[0].eq {
	pc = 0x82EAB0F8; continue 'dispatch;
	}
	// 82EAB0A0: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EAB0A4: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82EAB0A8: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EAB0AC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAB0B0: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82EAB0B4: 41800020  blt 0x82eab0d4
	if ctx.cr[0].lt {
	pc = 0x82EAB0D4; continue 'dispatch;
	}
	// 82EAB0B8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EAB0BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82EAB0C0: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x82EAB0C4; continue 'dispatch;
            }
            0x82EAB0C4 => {
    //   block [0x82EAB0C4..0x82EAB0D4)
	// 82EAB0C4: 394AFFF0  addi r10, r10, -0x10
	ctx.r[10].s64 = ctx.r[10].s64 + -16;
	// 82EAB0C8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAB0CC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EAB0D0: 4080FFF4  bge 0x82eab0c4
	if !ctx.cr[0].lt {
	pc = 0x82EAB0C4; continue 'dispatch;
	}
	pc = 0x82EAB0D4; continue 'dispatch;
            }
            0x82EAB0D4 => {
    //   block [0x82EAB0D4..0x82EAB0F0)
	// 82EAB0D4: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAB0D8: 41820018  beq 0x82eab0f0
	if ctx.cr[0].eq {
	pc = 0x82EAB0F0; continue 'dispatch;
	}
	// 82EAB0DC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAB0E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAB0E4: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAB0E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAB0EC: 4E800421  bctrl
	ctx.lr = 0x82EAB0F0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAB0F0 => {
    //   block [0x82EAB0F0..0x82EAB0F8)
	// 82EAB0F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAB0F4: 48000030  b 0x82eab124
	pc = 0x82EAB124; continue 'dispatch;
            }
            0x82EAB0F8 => {
    //   block [0x82EAB0F8..0x82EAB120)
	// 82EAB0F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EAB0FC: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAB100: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EAB104: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EAB108: 41820018  beq 0x82eab120
	if ctx.cr[0].eq {
	pc = 0x82EAB120; continue 'dispatch;
	}
	// 82EAB10C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAB110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAB114: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAB118: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAB11C: 4E800421  bctrl
	ctx.lr = 0x82EAB120;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAB120 => {
    //   block [0x82EAB120..0x82EAB124)
	// 82EAB120: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82EAB124; continue 'dispatch;
            }
            0x82EAB124 => {
    //   block [0x82EAB124..0x82EAB13C)
	// 82EAB124: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAB128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAB12C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAB130: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAB134: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAB138: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAB140 size=104
    let mut pc: u32 = 0x82EAB140;
    'dispatch: loop {
        match pc {
            0x82EAB140 => {
    //   block [0x82EAB140..0x82EAB19C)
	// 82EAB140: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EAB144: 894B0048  lbz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EAB148: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAB14C: 41820070  beq 0x82eab1bc
	if ctx.cr[0].eq {
		sub_82EAB1A8(ctx, base);
		return;
	}
	// 82EAB150: 812B003C  lwz r9, 0x3c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EAB154: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EAB158: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAB15C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EAB160: 41980048  blt cr6, 0x82eab1a8
	if ctx.cr[6].lt {
		sub_82EAB1A8(ctx, base);
		return;
	}
	// 82EAB164: 810B001C  lwz r8, 0x1c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAB168: 55492036  slwi r9, r10, 4
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EAB16C: 80EB0034  lwz r7, 0x34(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EAB170: 7C694214  add r3, r9, r8
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EAB174: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB178: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EAB17C: 409A002C  bne cr6, 0x82eab1a8
	if !ctx.cr[6].eq {
		sub_82EAB1A8(ctx, base);
		return;
	}
	// 82EAB180: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAB184: 409A0018  bne cr6, 0x82eab19c
	if !ctx.cr[6].eq {
	pc = 0x82EAB19C; continue 'dispatch;
	}
	// 82EAB188: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EAB18C: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EAB190: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EAB194: 992B0048  stb r9, 0x48(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[9].u8 ) };
	// 82EAB198: 48000008  b 0x82eab1a0
	pc = 0x82EAB1A0; continue 'dispatch;
            }
            0x82EAB19C => {
    //   block [0x82EAB19C..0x82EAB1A0)
	// 82EAB19C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	pc = 0x82EAB1A0; continue 'dispatch;
            }
            0x82EAB1A0 => {
    //   block [0x82EAB1A0..0x82EAB1A8)
	// 82EAB1A0: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82EAB1A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAB1A8 size=76
    let mut pc: u32 = 0x82EAB1A8;
    'dispatch: loop {
        match pc {
            0x82EAB1A8 => {
    //   block [0x82EAB1A8..0x82EAB1F4)
	// 82EAB1A8: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EAB1AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EAB1B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EAB1B4: 992B0048  stb r9, 0x48(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[9].u8 ) };
	// 82EAB1B8: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82EAB1BC: 812B003C  lwz r9, 0x3c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EAB1C0: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EAB1C4: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAB1C8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EAB1CC: 41990028  bgt cr6, 0x82eab1f4
	if ctx.cr[6].gt {
		sub_82EAB1F4(ctx, base);
		return;
	}
	// 82EAB1D0: 810B001C  lwz r8, 0x1c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAB1D4: 55492036  slwi r9, r10, 4
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EAB1D8: 80EB0034  lwz r7, 0x34(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EAB1DC: 7C694214  add r3, r9, r8
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82EAB1E0: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB1E4: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EAB1E8: 409A000C  bne cr6, 0x82eab1f4
	if !ctx.cr[6].eq {
		sub_82EAB1F4(ctx, base);
		return;
	}
	// 82EAB1EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EAB1F0: 4BFFFFB0  b 0x82eab1a0
	sub_82EAB140(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB1F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAB1F4 size=8
    let mut pc: u32 = 0x82EAB1F4;
    'dispatch: loop {
        match pc {
            0x82EAB1F4 => {
    //   block [0x82EAB1F4..0x82EAB1FC)
	// 82EAB1F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EAB1F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAB200 size=64
    let mut pc: u32 = 0x82EAB200;
    'dispatch: loop {
        match pc {
            0x82EAB200 => {
    //   block [0x82EAB200..0x82EAB240)
	// 82EAB200: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAB204: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAB208: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB20C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EAB210: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAB214: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB218: 7F054040  cmplw cr6, r5, r8
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EAB21C: 40990024  ble cr6, 0x82eab240
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x82EAB240);
		return;
	}
	// 82EAB220: 810BFFF4  lwz r8, -0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EAB224: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EAB228: 40990018  ble cr6, 0x82eab240
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x82EAB240);
		return;
	}
	// 82EAB22C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAB230: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EAB234: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EAB238: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAB23C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAB268 size=88
    let mut pc: u32 = 0x82EAB268;
    'dispatch: loop {
        match pc {
            0x82EAB268 => {
    //   block [0x82EAB268..0x82EAB298)
	// 82EAB268: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB26C: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAB270: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAB274: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EAB278: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAB27C: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EAB280: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB284: 4099003C  ble cr6, 0x82eab2c0
	if !ctx.cr[6].gt {
		sub_82EAB2C0(ctx, base);
		return;
	}
	// 82EAB288: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EAB28C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82EAB290: 41980008  blt cr6, 0x82eab298
	if ctx.cr[6].lt {
	pc = 0x82EAB298; continue 'dispatch;
	}
	// 82EAB294: 3966FFFF  addi r11, r6, -1
	ctx.r[11].s64 = ctx.r[6].s64 + -1;
	pc = 0x82EAB298; continue 'dispatch;
            }
            0x82EAB298 => {
    //   block [0x82EAB298..0x82EAB2C0)
	// 82EAB298: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAB29C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EAB2A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB2A4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EAB2A8: 40990018  ble cr6, 0x82eab2c0
	if !ctx.cr[6].gt {
		sub_82EAB2C0(ctx, base);
		return;
	}
	// 82EAB2AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAB2B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EAB2B4: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EAB2B8: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAB2BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAB2C0 size=52
    let mut pc: u32 = 0x82EAB2C0;
    'dispatch: loop {
        match pc {
            0x82EAB2C0 => {
    //   block [0x82EAB2C0..0x82EAB2D8)
	// 82EAB2C0: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAB2C4: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAB2C8: 4098002C  bge cr6, 0x82eab2f4
	if !ctx.cr[6].lt {
		sub_82EAB2F4(ctx, base);
		return;
	}
	// 82EAB2CC: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EAB2D0: 40980008  bge cr6, 0x82eab2d8
	if !ctx.cr[6].lt {
	pc = 0x82EAB2D8; continue 'dispatch;
	}
	// 82EAB2D4: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	pc = 0x82EAB2D8; continue 'dispatch;
            }
            0x82EAB2D8 => {
    //   block [0x82EAB2D8..0x82EAB2F4)
	// 82EAB2D8: 54CB2036  slwi r11, r6, 4
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAB2DC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EAB2E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB2E4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EAB2E8: 4098000C  bge cr6, 0x82eab2f4
	if !ctx.cr[6].lt {
		sub_82EAB2F4(ctx, base);
		return;
	}
	// 82EAB2EC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EAB2F0: 4BFFFFC0  b 0x82eab2b0
	sub_82EAB268(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB2F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAB2F4 size=8
    let mut pc: u32 = 0x82EAB2F4;
    'dispatch: loop {
        match pc {
            0x82EAB2F4 => {
    //   block [0x82EAB2F4..0x82EAB2FC)
	// 82EAB2F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EAB2F8: 4BFFFFB8  b 0x82eab2b0
	sub_82EAB268(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAB300 size=340
    let mut pc: u32 = 0x82EAB300;
    'dispatch: loop {
        match pc {
            0x82EAB300 => {
    //   block [0x82EAB300..0x82EAB360)
	// 82EAB300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAB304: 4BDFE109  bl 0x82ca940c
	ctx.lr = 0x82EAB308;
	sub_82CA93D0(ctx, base);
	// 82EAB308: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAB30C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAB310: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAB314: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EAB318: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EAB31C: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 82EAB320: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EAB324: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EAB328: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82EAB32C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAB330: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82EAB334: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82EAB338: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82EAB33C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EAB340: 419A0108  beq cr6, 0x82eab448
	if ctx.cr[6].eq {
	pc = 0x82EAB448; continue 'dispatch;
	}
	// 82EAB344: 3D600666  lis r11, 0x666
	ctx.r[11].s64 = 107347968;
	// 82EAB348: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EAB34C: 616B6666  ori r11, r11, 0x6666
	ctx.r[11].u64 = ctx.r[11].u64 | 26214;
	// 82EAB350: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAB354: 1D7D0028  mulli r11, r29, 0x28
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 40 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EAB358: 40990008  ble cr6, 0x82eab360
	if !ctx.cr[6].gt {
	pc = 0x82EAB360; continue 'dispatch;
	}
	// 82EAB35C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82EAB360; continue 'dispatch;
            }
            0x82EAB360 => {
    //   block [0x82EAB360..0x82EAB370)
	// 82EAB360: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EAB364: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAB368: 41990008  bgt cr6, 0x82eab370
	if ctx.cr[6].gt {
	pc = 0x82EAB370; continue 'dispatch;
	}
	// 82EAB36C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82EAB370; continue 'dispatch;
            }
            0x82EAB370 => {
    //   block [0x82EAB370..0x82EAB39C)
	// 82EAB370: 4B76B5B9  bl 0x82616928
	ctx.lr = 0x82EAB374;
	sub_82616928(ctx, base);
	// 82EAB374: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAB378: 41820064  beq 0x82eab3dc
	if ctx.cr[0].eq {
	pc = 0x82EAB3DC; continue 'dispatch;
	}
	// 82EAB37C: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 82EAB380: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82EAB384: 355DFFFF  addic. r10, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAB388: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EAB38C: 41800048  blt 0x82eab3d4
	if ctx.cr[0].lt {
	pc = 0x82EAB3D4; continue 'dispatch;
	}
	// 82EAB390: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EAB394: 3969000C  addi r11, r9, 0xc
	ctx.r[11].s64 = ctx.r[9].s64 + 12;
	// 82EAB398: 3908A2A0  addi r8, r8, -0x5d60
	ctx.r[8].s64 = ctx.r[8].s64 + -23904;
	pc = 0x82EAB39C; continue 'dispatch;
            }
            0x82EAB39C => {
    //   block [0x82EAB39C..0x82EAB3D4)
	// 82EAB39C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EAB3A0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAB3A4: 93CBFFF8  stw r30, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[30].u32 ) };
	// 82EAB3A8: 39290028  addi r9, r9, 0x28
	ctx.r[9].s64 = ctx.r[9].s64 + 40;
	// 82EAB3AC: 93CBFFFC  stw r30, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[30].u32 ) };
	// 82EAB3B0: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82EAB3B4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82EAB3B8: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EAB3BC: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EAB3C0: 93CB0010  stw r30, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82EAB3C4: 93CB0014  stw r30, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82EAB3C8: 9BCB0018  stb r30, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82EAB3CC: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 82EAB3D0: 4080FFCC  bge 0x82eab39c
	if !ctx.cr[0].lt {
	pc = 0x82EAB39C; continue 'dispatch;
	}
	pc = 0x82EAB3D4; continue 'dispatch;
            }
            0x82EAB3D4 => {
    //   block [0x82EAB3D4..0x82EAB3DC)
	// 82EAB3D4: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82EAB3D8: 48000008  b 0x82eab3e0
	pc = 0x82EAB3E0; continue 'dispatch;
            }
            0x82EAB3DC => {
    //   block [0x82EAB3DC..0x82EAB3E0)
	// 82EAB3DC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82EAB3E0; continue 'dispatch;
            }
            0x82EAB3E0 => {
    //   block [0x82EAB3E0..0x82EAB400)
	// 82EAB3E0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EAB3E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EAB3E8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAB3EC: 93CB001C  stw r30, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82EAB3F0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAB3F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAB3F8: 4099003C  ble cr6, 0x82eab434
	if !ctx.cr[6].gt {
	pc = 0x82EAB434; continue 'dispatch;
	}
	// 82EAB3FC: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	pc = 0x82EAB400; continue 'dispatch;
            }
            0x82EAB400 => {
    //   block [0x82EAB400..0x82EAB434)
	// 82EAB400: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB404: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EAB408: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EAB40C: 3909FFD8  addi r8, r9, -0x28
	ctx.r[8].s64 = ctx.r[9].s64 + -40;
	// 82EAB410: 9109001C  stw r8, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 82EAB414: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB418: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EAB41C: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 82EAB420: 8109001C  lwz r8, 0x1c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAB424: 91280020  stw r9, 0x20(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82EAB428: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAB42C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EAB430: 4198FFD0  blt cr6, 0x82eab400
	if ctx.cr[6].lt {
	pc = 0x82EAB400; continue 'dispatch;
	}
	pc = 0x82EAB434; continue 'dispatch;
            }
            0x82EAB434 => {
    //   block [0x82EAB434..0x82EAB448)
	// 82EAB434: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAB438: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB43C: 1D6B0028  mulli r11, r11, 0x28
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 40 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EAB440: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EAB444: 93CBFFF8  stw r30, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[30].u32 ) };
	pc = 0x82EAB448; continue 'dispatch;
            }
            0x82EAB448 => {
    //   block [0x82EAB448..0x82EAB454)
	// 82EAB448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAB44C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAB450: 4BDFE00C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAB458 size=52
    let mut pc: u32 = 0x82EAB458;
    'dispatch: loop {
        match pc {
            0x82EAB458 => {
    //   block [0x82EAB458..0x82EAB48C)
	// 82EAB458: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAB45C: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB460: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAB464: 40820028  bne 0x82eab48c
	if !ctx.cr[0].eq {
		sub_82EAB48C(ctx, base);
		return;
	}
	// 82EAB468: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAB46C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EAB470: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EAB474: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EAB478: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EAB47C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAB480: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EAB484: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EAB488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB48C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAB48C size=216
    let mut pc: u32 = 0x82EAB48C;
    'dispatch: loop {
        match pc {
            0x82EAB48C => {
    //   block [0x82EAB48C..0x82EAB504)
	// 82EAB48C: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAB490: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EAB494: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAB498: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EAB49C: 91240014  stw r9, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82EAB4A0: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAB4A4: 91240010  stw r9, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EAB4A8: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAB4AC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EAB4B0: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB4B4: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EAB4B8: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAB4BC: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EAB4C0: 81250010  lwz r9, 0x10(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAB4C4: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82EAB4C8: 990B0020  stb r8, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[8].u8 ) };
	// 82EAB4CC: 409A0054  bne cr6, 0x82eab520
	if !ctx.cr[6].eq {
	pc = 0x82EAB520; continue 'dispatch;
	}
	// 82EAB4D0: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAB4D4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAB4D8: 4082002C  bne 0x82eab504
	if !ctx.cr[0].eq {
	pc = 0x82EAB504; continue 'dispatch;
	}
	// 82EAB4DC: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EAB4E0: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EAB4E4: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82EAB4E8: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAB4EC: 91490018  stw r10, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EAB4F0: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAB4F4: 91490018  stw r10, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EAB4F8: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAB4FC: 9149001C  stw r10, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82EAB500: 48000044  b 0x82eab544
	pc = 0x82EAB544; continue 'dispatch;
            }
            0x82EAB504 => {
    //   block [0x82EAB504..0x82EAB520)
	// 82EAB504: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EAB508: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EAB50C: 912B001C  stw r9, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82EAB510: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAB514: 916A001C  stw r11, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EAB518: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EAB51C: 48000028  b 0x82eab544
	pc = 0x82EAB544; continue 'dispatch;
            }
            0x82EAB520 => {
    //   block [0x82EAB520..0x82EAB540)
	// 82EAB520: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAB524: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82EAB528: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EAB52C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAB530: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EAB534: 4182000C  beq 0x82eab540
	if ctx.cr[0].eq {
	pc = 0x82EAB540; continue 'dispatch;
	}
	// 82EAB538: 9169001C  stw r11, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EAB53C: 48000008  b 0x82eab544
	pc = 0x82EAB544; continue 'dispatch;
            }
            0x82EAB540 => {
    //   block [0x82EAB540..0x82EAB544)
	// 82EAB540: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EAB544; continue 'dispatch;
            }
            0x82EAB544 => {
    //   block [0x82EAB544..0x82EAB564)
	// 82EAB544: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EAB548: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EAB54C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EAB550: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EAB554: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EAB558: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EAB55C: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EAB560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAB568 size=136
    let mut pc: u32 = 0x82EAB568;
    'dispatch: loop {
        match pc {
            0x82EAB568 => {
    //   block [0x82EAB568..0x82EAB5CC)
	// 82EAB568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAB56C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAB570: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAB574: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAB578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAB57C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAB580: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 82EAB584: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAB588: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAB58C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAB590: 40990040  ble cr6, 0x82eab5d0
	if !ctx.cr[6].gt {
	pc = 0x82EAB5D0; continue 'dispatch;
	}
	// 82EAB594: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB598: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAB59C: 41820034  beq 0x82eab5d0
	if ctx.cr[0].eq {
	pc = 0x82EAB5D0; continue 'dispatch;
	}
	// 82EAB5A0: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EAB5A4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82EAB5A8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAB5AC: 419A0020  beq cr6, 0x82eab5cc
	if ctx.cr[6].eq {
	pc = 0x82EAB5CC; continue 'dispatch;
	}
	// 82EAB5B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAB5B4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EAB5B8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82EAB5BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAB5C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAB5C4: 4E800421  bctrl
	ctx.lr = 0x82EAB5C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAB5C8: 48000008  b 0x82eab5d0
	pc = 0x82EAB5D0; continue 'dispatch;
            }
            0x82EAB5CC => {
    //   block [0x82EAB5CC..0x82EAB5D0)
	// 82EAB5CC: 4B99A1E5  bl 0x828457b0
	ctx.lr = 0x82EAB5D0;
	sub_828457B0(ctx, base);
	pc = 0x82EAB5D0; continue 'dispatch;
            }
            0x82EAB5D0 => {
    //   block [0x82EAB5D0..0x82EAB5F0)
	// 82EAB5D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EAB5D4: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EAB5D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAB5DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAB5E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAB5E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAB5E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAB5EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAB5F0 size=88
    let mut pc: u32 = 0x82EAB5F0;
    'dispatch: loop {
        match pc {
            0x82EAB5F0 => {
    //   block [0x82EAB5F0..0x82EAB62C)
	// 82EAB5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAB5F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAB5F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAB5FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAB600: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAB604: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAB608: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAB60C: 4BFFFF5D  bl 0x82eab568
	ctx.lr = 0x82EAB610;
	sub_82EAB568(ctx, base);
	// 82EAB610: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAB614: 41820018  beq 0x82eab62c
	if ctx.cr[0].eq {
	pc = 0x82EAB62C; continue 'dispatch;
	}
	// 82EAB618: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAB61C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAB620: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAB624: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAB628: 4E800421  bctrl
	ctx.lr = 0x82EAB62C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAB62C => {
    //   block [0x82EAB62C..0x82EAB648)
	// 82EAB62C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAB630: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAB634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAB638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAB63C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAB640: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAB644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAB648 size=320
    let mut pc: u32 = 0x82EAB648;
    'dispatch: loop {
        match pc {
            0x82EAB648 => {
    //   block [0x82EAB648..0x82EAB6A8)
	// 82EAB648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAB64C: 4BDFDDBD  bl 0x82ca9408
	ctx.lr = 0x82EAB650;
	sub_82CA93D0(ctx, base);
	// 82EAB650: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAB654: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAB658: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAB65C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EAB660: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAB664: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 82EAB668: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EAB66C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EAB670: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82EAB674: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAB678: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82EAB67C: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82EAB680: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EAB684: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EAB688: 419A00F4  beq cr6, 0x82eab77c
	if ctx.cr[6].eq {
	pc = 0x82EAB77C; continue 'dispatch;
	}
	// 82EAB68C: 3D600AAA  lis r11, 0xaaa
	ctx.r[11].s64 = 178913280;
	// 82EAB690: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 82EAB694: 616BAAAA  ori r11, r11, 0xaaaa
	ctx.r[11].u64 = ctx.r[11].u64 | 43690;
	// 82EAB698: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAB69C: 1D7E0018  mulli r11, r30, 0x18
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EAB6A0: 40990008  ble cr6, 0x82eab6a8
	if !ctx.cr[6].gt {
	pc = 0x82EAB6A8; continue 'dispatch;
	}
	// 82EAB6A4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82EAB6A8; continue 'dispatch;
            }
            0x82EAB6A8 => {
    //   block [0x82EAB6A8..0x82EAB6BC)
	// 82EAB6A8: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EAB6AC: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82EAB6B0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAB6B4: 40990008  ble cr6, 0x82eab6bc
	if !ctx.cr[6].gt {
	pc = 0x82EAB6BC; continue 'dispatch;
	}
	// 82EAB6B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x82EAB6BC; continue 'dispatch;
            }
            0x82EAB6BC => {
    //   block [0x82EAB6BC..0x82EAB6E4)
	// 82EAB6BC: 4B76B26D  bl 0x82616928
	ctx.lr = 0x82EAB6C0;
	sub_82616928(ctx, base);
	// 82EAB6C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAB6C4: 4182004C  beq 0x82eab710
	if ctx.cr[0].eq {
	pc = 0x82EAB710; continue 'dispatch;
	}
	// 82EAB6C8: 39030004  addi r8, r3, 4
	ctx.r[8].s64 = ctx.r[3].s64 + 4;
	// 82EAB6CC: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82EAB6D0: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAB6D4: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82EAB6D8: 41800030  blt 0x82eab708
	if ctx.cr[0].lt {
	pc = 0x82EAB708; continue 'dispatch;
	}
	// 82EAB6DC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EAB6E0: 3929A2A4  addi r9, r9, -0x5d5c
	ctx.r[9].s64 = ctx.r[9].s64 + -23900;
	pc = 0x82EAB6E4; continue 'dispatch;
            }
            0x82EAB6E4 => {
    //   block [0x82EAB6E4..0x82EAB708)
	// 82EAB6E4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EAB6E8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAB6EC: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EAB6F0: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82EAB6F4: 93AB000C  stw r29, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EAB6F8: 93AB0010  stw r29, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82EAB6FC: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82EAB700: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82EAB704: 4080FFE0  bge 0x82eab6e4
	if !ctx.cr[0].lt {
	pc = 0x82EAB6E4; continue 'dispatch;
	}
	pc = 0x82EAB708; continue 'dispatch;
            }
            0x82EAB708 => {
    //   block [0x82EAB708..0x82EAB710)
	// 82EAB708: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82EAB70C: 48000008  b 0x82eab714
	pc = 0x82EAB714; continue 'dispatch;
            }
            0x82EAB710 => {
    //   block [0x82EAB710..0x82EAB714)
	// 82EAB710: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82EAB714; continue 'dispatch;
            }
            0x82EAB714 => {
    //   block [0x82EAB714..0x82EAB734)
	// 82EAB714: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EAB718: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EAB71C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAB720: 93AB000C  stw r29, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EAB724: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAB728: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAB72C: 4099003C  ble cr6, 0x82eab768
	if !ctx.cr[6].gt {
	pc = 0x82EAB768; continue 'dispatch;
	}
	// 82EAB730: 39600018  li r11, 0x18
	ctx.r[11].s64 = 24;
	pc = 0x82EAB734; continue 'dispatch;
            }
            0x82EAB734 => {
    //   block [0x82EAB734..0x82EAB768)
	// 82EAB734: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB738: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EAB73C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EAB740: 3909FFE8  addi r8, r9, -0x18
	ctx.r[8].s64 = ctx.r[9].s64 + -24;
	// 82EAB744: 9109000C  stw r8, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EAB748: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB74C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EAB750: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82EAB754: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAB758: 91280010  stw r9, 0x10(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EAB75C: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAB760: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EAB764: 4198FFD0  blt cr6, 0x82eab734
	if ctx.cr[6].lt {
	pc = 0x82EAB734; continue 'dispatch;
	}
	pc = 0x82EAB768; continue 'dispatch;
            }
            0x82EAB768 => {
    //   block [0x82EAB768..0x82EAB77C)
	// 82EAB768: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAB76C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB770: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EAB774: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EAB778: 93ABFFF8  stw r29, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[29].u32 ) };
	pc = 0x82EAB77C; continue 'dispatch;
            }
            0x82EAB77C => {
    //   block [0x82EAB77C..0x82EAB788)
	// 82EAB77C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAB780: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EAB784: 4BDFDCD4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAB788 size=324
    let mut pc: u32 = 0x82EAB788;
    'dispatch: loop {
        match pc {
            0x82EAB788 => {
    //   block [0x82EAB788..0x82EAB7E8)
	// 82EAB788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAB78C: 4BDFDC81  bl 0x82ca940c
	ctx.lr = 0x82EAB790;
	sub_82CA93D0(ctx, base);
	// 82EAB790: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAB794: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAB798: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAB79C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EAB7A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EAB7A4: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 82EAB7A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EAB7AC: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EAB7B0: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82EAB7B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAB7B8: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82EAB7BC: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82EAB7C0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82EAB7C4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EAB7C8: 419A00F8  beq cr6, 0x82eab8c0
	if ctx.cr[6].eq {
	pc = 0x82EAB8C0; continue 'dispatch;
	}
	// 82EAB7CC: 3D600AAA  lis r11, 0xaaa
	ctx.r[11].s64 = 178913280;
	// 82EAB7D0: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EAB7D4: 616BAAAA  ori r11, r11, 0xaaaa
	ctx.r[11].u64 = ctx.r[11].u64 | 43690;
	// 82EAB7D8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAB7DC: 1D7D0018  mulli r11, r29, 0x18
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EAB7E0: 40990008  ble cr6, 0x82eab7e8
	if !ctx.cr[6].gt {
	pc = 0x82EAB7E8; continue 'dispatch;
	}
	// 82EAB7E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82EAB7E8; continue 'dispatch;
            }
            0x82EAB7E8 => {
    //   block [0x82EAB7E8..0x82EAB7F8)
	// 82EAB7E8: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EAB7EC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAB7F0: 41990008  bgt cr6, 0x82eab7f8
	if ctx.cr[6].gt {
	pc = 0x82EAB7F8; continue 'dispatch;
	}
	// 82EAB7F4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82EAB7F8; continue 'dispatch;
            }
            0x82EAB7F8 => {
    //   block [0x82EAB7F8..0x82EAB828)
	// 82EAB7F8: 4B76B131  bl 0x82616928
	ctx.lr = 0x82EAB7FC;
	sub_82616928(ctx, base);
	// 82EAB7FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAB800: 41820054  beq 0x82eab854
	if ctx.cr[0].eq {
	pc = 0x82EAB854; continue 'dispatch;
	}
	// 82EAB804: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 82EAB808: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82EAB80C: 355DFFFF  addic. r10, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAB810: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82EAB814: 41800038  blt 0x82eab84c
	if ctx.cr[0].lt {
	pc = 0x82EAB84C; continue 'dispatch;
	}
	// 82EAB818: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EAB81C: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EAB820: 3929AFB4  addi r9, r9, -0x504c
	ctx.r[9].s64 = ctx.r[9].s64 + -20556;
	// 82EAB824: 3908A2A8  addi r8, r8, -0x5d58
	ctx.r[8].s64 = ctx.r[8].s64 + -23896;
	pc = 0x82EAB828; continue 'dispatch;
            }
            0x82EAB828 => {
    //   block [0x82EAB828..0x82EAB84C)
	// 82EAB828: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EAB82C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAB830: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EAB834: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EAB838: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EAB83C: 93CB0010  stw r30, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82EAB840: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82EAB844: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82EAB848: 4080FFE0  bge 0x82eab828
	if !ctx.cr[0].lt {
	pc = 0x82EAB828; continue 'dispatch;
	}
	pc = 0x82EAB84C; continue 'dispatch;
            }
            0x82EAB84C => {
    //   block [0x82EAB84C..0x82EAB854)
	// 82EAB84C: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82EAB850: 48000008  b 0x82eab858
	pc = 0x82EAB858; continue 'dispatch;
            }
            0x82EAB854 => {
    //   block [0x82EAB854..0x82EAB858)
	// 82EAB854: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82EAB858; continue 'dispatch;
            }
            0x82EAB858 => {
    //   block [0x82EAB858..0x82EAB878)
	// 82EAB858: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EAB85C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EAB860: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAB864: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EAB868: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAB86C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAB870: 4099003C  ble cr6, 0x82eab8ac
	if !ctx.cr[6].gt {
	pc = 0x82EAB8AC; continue 'dispatch;
	}
	// 82EAB874: 39600018  li r11, 0x18
	ctx.r[11].s64 = 24;
	pc = 0x82EAB878; continue 'dispatch;
            }
            0x82EAB878 => {
    //   block [0x82EAB878..0x82EAB8AC)
	// 82EAB878: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB87C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EAB880: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EAB884: 3909FFE8  addi r8, r9, -0x18
	ctx.r[8].s64 = ctx.r[9].s64 + -24;
	// 82EAB888: 9109000C  stw r8, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82EAB88C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB890: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EAB894: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82EAB898: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAB89C: 91280010  stw r9, 0x10(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EAB8A0: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAB8A4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EAB8A8: 4198FFD0  blt cr6, 0x82eab878
	if ctx.cr[6].lt {
	pc = 0x82EAB878; continue 'dispatch;
	}
	pc = 0x82EAB8AC; continue 'dispatch;
            }
            0x82EAB8AC => {
    //   block [0x82EAB8AC..0x82EAB8C0)
	// 82EAB8AC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAB8B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAB8B4: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EAB8B8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EAB8BC: 93CBFFF8  stw r30, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[30].u32 ) };
	pc = 0x82EAB8C0; continue 'dispatch;
            }
            0x82EAB8C0 => {
    //   block [0x82EAB8C0..0x82EAB8CC)
	// 82EAB8C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAB8C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAB8C8: 4BDFDB94  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB8D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAB8D0 size=184
    let mut pc: u32 = 0x82EAB8D0;
    'dispatch: loop {
        match pc {
            0x82EAB8D0 => {
    //   block [0x82EAB8D0..0x82EAB910)
	// 82EAB8D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAB8D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAB8D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAB8DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAB8E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAB8E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAB8E8: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAB8EC: 41820058  beq 0x82eab944
	if ctx.cr[0].eq {
	pc = 0x82EAB944; continue 'dispatch;
	}
	// 82EAB8F0: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EAB8F4: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82EAB8F8: 1D4B0028  mulli r10, r11, 0x28
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 40 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EAB8FC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAB900: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82EAB904: 4180001C  blt 0x82eab920
	if ctx.cr[0].lt {
	pc = 0x82EAB920; continue 'dispatch;
	}
	// 82EAB908: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EAB90C: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x82EAB910; continue 'dispatch;
            }
            0x82EAB910 => {
    //   block [0x82EAB910..0x82EAB920)
	// 82EAB910: 394AFFD8  addi r10, r10, -0x28
	ctx.r[10].s64 = ctx.r[10].s64 + -40;
	// 82EAB914: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAB918: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EAB91C: 4080FFF4  bge 0x82eab910
	if !ctx.cr[0].lt {
	pc = 0x82EAB910; continue 'dispatch;
	}
	pc = 0x82EAB920; continue 'dispatch;
            }
            0x82EAB920 => {
    //   block [0x82EAB920..0x82EAB93C)
	// 82EAB920: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAB924: 41820018  beq 0x82eab93c
	if ctx.cr[0].eq {
	pc = 0x82EAB93C; continue 'dispatch;
	}
	// 82EAB928: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAB92C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAB930: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAB934: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAB938: 4E800421  bctrl
	ctx.lr = 0x82EAB93C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAB93C => {
    //   block [0x82EAB93C..0x82EAB944)
	// 82EAB93C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAB940: 48000030  b 0x82eab970
	pc = 0x82EAB970; continue 'dispatch;
            }
            0x82EAB944 => {
    //   block [0x82EAB944..0x82EAB96C)
	// 82EAB944: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EAB948: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAB94C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EAB950: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAB954: 41820018  beq 0x82eab96c
	if ctx.cr[0].eq {
	pc = 0x82EAB96C; continue 'dispatch;
	}
	// 82EAB958: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAB95C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAB960: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAB964: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAB968: 4E800421  bctrl
	ctx.lr = 0x82EAB96C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAB96C => {
    //   block [0x82EAB96C..0x82EAB970)
	// 82EAB96C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82EAB970; continue 'dispatch;
            }
            0x82EAB970 => {
    //   block [0x82EAB970..0x82EAB988)
	// 82EAB970: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAB974: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAB978: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAB97C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAB980: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAB984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAB988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAB988 size=192
    let mut pc: u32 = 0x82EAB988;
    'dispatch: loop {
        match pc {
            0x82EAB988 => {
    //   block [0x82EAB988..0x82EAB9C8)
	// 82EAB988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAB98C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAB990: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAB994: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAB998: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAB99C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAB9A0: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAB9A4: 4182005C  beq 0x82eaba00
	if ctx.cr[0].eq {
	pc = 0x82EABA00; continue 'dispatch;
	}
	// 82EAB9A8: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EAB9AC: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82EAB9B0: 1D4B0024  mulli r10, r11, 0x24
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 36 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EAB9B4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAB9B8: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82EAB9BC: 41800020  blt 0x82eab9dc
	if ctx.cr[0].lt {
	pc = 0x82EAB9DC; continue 'dispatch;
	}
	// 82EAB9C0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EAB9C4: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x82EAB9C8; continue 'dispatch;
            }
            0x82EAB9C8 => {
    //   block [0x82EAB9C8..0x82EAB9DC)
	// 82EAB9C8: 394AFFDC  addi r10, r10, -0x24
	ctx.r[10].s64 = ctx.r[10].s64 + -36;
	// 82EAB9CC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAB9D0: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EAB9D4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EAB9D8: 4080FFF0  bge 0x82eab9c8
	if !ctx.cr[0].lt {
	pc = 0x82EAB9C8; continue 'dispatch;
	}
	pc = 0x82EAB9DC; continue 'dispatch;
            }
            0x82EAB9DC => {
    //   block [0x82EAB9DC..0x82EAB9F8)
	// 82EAB9DC: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAB9E0: 41820018  beq 0x82eab9f8
	if ctx.cr[0].eq {
	pc = 0x82EAB9F8; continue 'dispatch;
	}
	// 82EAB9E4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAB9E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAB9EC: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAB9F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAB9F4: 4E800421  bctrl
	ctx.lr = 0x82EAB9F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAB9F8 => {
    //   block [0x82EAB9F8..0x82EABA00)
	// 82EAB9F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAB9FC: 48000034  b 0x82eaba30
	pc = 0x82EABA30; continue 'dispatch;
            }
            0x82EABA00 => {
    //   block [0x82EABA00..0x82EABA2C)
	// 82EABA00: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EABA04: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EABA08: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EABA0C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EABA10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EABA14: 41820018  beq 0x82eaba2c
	if ctx.cr[0].eq {
	pc = 0x82EABA2C; continue 'dispatch;
	}
	// 82EABA18: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EABA1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EABA20: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EABA24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EABA28: 4E800421  bctrl
	ctx.lr = 0x82EABA2C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EABA2C => {
    //   block [0x82EABA2C..0x82EABA30)
	// 82EABA2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82EABA30; continue 'dispatch;
            }
            0x82EABA30 => {
    //   block [0x82EABA30..0x82EABA48)
	// 82EABA30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EABA34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EABA38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EABA3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EABA40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EABA44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EABA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EABA48 size=184
    let mut pc: u32 = 0x82EABA48;
    'dispatch: loop {
        match pc {
            0x82EABA48 => {
    //   block [0x82EABA48..0x82EABA88)
	// 82EABA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EABA4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EABA50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EABA54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EABA58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EABA5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EABA60: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EABA64: 41820058  beq 0x82eababc
	if ctx.cr[0].eq {
	pc = 0x82EABABC; continue 'dispatch;
	}
	// 82EABA68: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EABA6C: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82EABA70: 1D4B0018  mulli r10, r11, 0x18
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EABA74: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EABA78: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82EABA7C: 4180001C  blt 0x82eaba98
	if ctx.cr[0].lt {
	pc = 0x82EABA98; continue 'dispatch;
	}
	// 82EABA80: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EABA84: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x82EABA88; continue 'dispatch;
            }
            0x82EABA88 => {
    //   block [0x82EABA88..0x82EABA98)
	// 82EABA88: 394AFFE8  addi r10, r10, -0x18
	ctx.r[10].s64 = ctx.r[10].s64 + -24;
	// 82EABA8C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EABA90: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EABA94: 4080FFF4  bge 0x82eaba88
	if !ctx.cr[0].lt {
	pc = 0x82EABA88; continue 'dispatch;
	}
	pc = 0x82EABA98; continue 'dispatch;
            }
            0x82EABA98 => {
    //   block [0x82EABA98..0x82EABAB4)
	// 82EABA98: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EABA9C: 41820018  beq 0x82eabab4
	if ctx.cr[0].eq {
	pc = 0x82EABAB4; continue 'dispatch;
	}
	// 82EABAA0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EABAA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EABAA8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EABAAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EABAB0: 4E800421  bctrl
	ctx.lr = 0x82EABAB4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EABAB4 => {
    //   block [0x82EABAB4..0x82EABABC)
	// 82EABAB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EABAB8: 48000030  b 0x82eabae8
	pc = 0x82EABAE8; continue 'dispatch;
            }
            0x82EABABC => {
    //   block [0x82EABABC..0x82EABAE4)
	// 82EABABC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EABAC0: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EABAC4: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EABAC8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EABACC: 41820018  beq 0x82eabae4
	if ctx.cr[0].eq {
	pc = 0x82EABAE4; continue 'dispatch;
	}
	// 82EABAD0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EABAD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EABAD8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EABADC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EABAE0: 4E800421  bctrl
	ctx.lr = 0x82EABAE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EABAE4 => {
    //   block [0x82EABAE4..0x82EABAE8)
	// 82EABAE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82EABAE8; continue 'dispatch;
            }
            0x82EABAE8 => {
    //   block [0x82EABAE8..0x82EABB00)
	// 82EABAE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EABAEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EABAF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EABAF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EABAF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EABAFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EABB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EABB00 size=192
    let mut pc: u32 = 0x82EABB00;
    'dispatch: loop {
        match pc {
            0x82EABB00 => {
    //   block [0x82EABB00..0x82EABB40)
	// 82EABB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EABB04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EABB08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EABB0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EABB10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EABB14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EABB18: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EABB1C: 4182005C  beq 0x82eabb78
	if ctx.cr[0].eq {
	pc = 0x82EABB78; continue 'dispatch;
	}
	// 82EABB20: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EABB24: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82EABB28: 1D4B0018  mulli r10, r11, 0x18
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EABB2C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EABB30: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82EABB34: 41800020  blt 0x82eabb54
	if ctx.cr[0].lt {
	pc = 0x82EABB54; continue 'dispatch;
	}
	// 82EABB38: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EABB3C: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x82EABB40; continue 'dispatch;
            }
            0x82EABB40 => {
    //   block [0x82EABB40..0x82EABB54)
	// 82EABB40: 394AFFE8  addi r10, r10, -0x18
	ctx.r[10].s64 = ctx.r[10].s64 + -24;
	// 82EABB44: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EABB48: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EABB4C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EABB50: 4080FFF0  bge 0x82eabb40
	if !ctx.cr[0].lt {
	pc = 0x82EABB40; continue 'dispatch;
	}
	pc = 0x82EABB54; continue 'dispatch;
            }
            0x82EABB54 => {
    //   block [0x82EABB54..0x82EABB70)
	// 82EABB54: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EABB58: 41820018  beq 0x82eabb70
	if ctx.cr[0].eq {
	pc = 0x82EABB70; continue 'dispatch;
	}
	// 82EABB5C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EABB60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EABB64: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EABB68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EABB6C: 4E800421  bctrl
	ctx.lr = 0x82EABB70;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EABB70 => {
    //   block [0x82EABB70..0x82EABB78)
	// 82EABB70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EABB74: 48000034  b 0x82eabba8
	pc = 0x82EABBA8; continue 'dispatch;
            }
            0x82EABB78 => {
    //   block [0x82EABB78..0x82EABBA4)
	// 82EABB78: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EABB7C: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EABB80: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EABB84: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EABB88: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EABB8C: 41820018  beq 0x82eabba4
	if ctx.cr[0].eq {
	pc = 0x82EABBA4; continue 'dispatch;
	}
	// 82EABB90: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EABB94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EABB98: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EABB9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EABBA0: 4E800421  bctrl
	ctx.lr = 0x82EABBA4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EABBA4 => {
    //   block [0x82EABBA4..0x82EABBA8)
	// 82EABBA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82EABBA8; continue 'dispatch;
            }
            0x82EABBA8 => {
    //   block [0x82EABBA8..0x82EABBC0)
	// 82EABBA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EABBAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EABBB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EABBB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EABBB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EABBBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EABBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EABBC0 size=72
    let mut pc: u32 = 0x82EABBC0;
    'dispatch: loop {
        match pc {
            0x82EABBC0 => {
    //   block [0x82EABBC0..0x82EABBF0)
	// 82EABBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EABBC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EABBC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EABBCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EABBD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EABBD4: 3860004C  li r3, 0x4c
	ctx.r[3].s64 = 76;
	// 82EABBD8: 4B76AD51  bl 0x82616928
	ctx.lr = 0x82EABBDC;
	sub_82616928(ctx, base);
	// 82EABBDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABBE0: 41820010  beq 0x82eabbf0
	if ctx.cr[0].eq {
	pc = 0x82EABBF0; continue 'dispatch;
	}
	// 82EABBE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EABBE8: 4BFFF3F9  bl 0x82eaafe0
	ctx.lr = 0x82EABBEC;
	sub_82EAAFE0(ctx, base);
	// 82EABBEC: 48000008  b 0x82eabbf4
	pc = 0x82EABBF4; continue 'dispatch;
            }
            0x82EABBF0 => {
    //   block [0x82EABBF0..0x82EABBF4)
	// 82EABBF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EABBF4; continue 'dispatch;
            }
            0x82EABBF4 => {
    //   block [0x82EABBF4..0x82EABC08)
	// 82EABBF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EABBF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EABBFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EABC00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EABC04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EABC08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EABC08 size=424
    let mut pc: u32 = 0x82EABC08;
    'dispatch: loop {
        match pc {
            0x82EABC08 => {
    //   block [0x82EABC08..0x82EABC40)
	// 82EABC08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EABC0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EABC10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EABC14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EABC18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EABC1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EABC20: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EABC24: 394AA2B0  addi r10, r10, -0x5d50
	ctx.r[10].s64 = ctx.r[10].s64 + -23888;
	// 82EABC28: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EABC2C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABC30: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EABC34: 41820058  beq 0x82eabc8c
	if ctx.cr[0].eq {
	pc = 0x82EABC8C; continue 'dispatch;
	}
	// 82EABC38: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EABC3C: 48000028  b 0x82eabc64
	pc = 0x82EABC64; continue 'dispatch;
            }
            0x82EABC40 => {
    //   block [0x82EABC40..0x82EABC60)
	// 82EABC40: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EABC44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABC48: 41820018  beq 0x82eabc60
	if ctx.cr[0].eq {
	pc = 0x82EABC60; continue 'dispatch;
	}
	// 82EABC4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABC50: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EABC54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABC58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EABC5C: 4E800421  bctrl
	ctx.lr = 0x82EABC60;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EABC60 => {
    //   block [0x82EABC60..0x82EABC64)
	// 82EABC60: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EABC64; continue 'dispatch;
            }
            0x82EABC64 => {
    //   block [0x82EABC64..0x82EABC8C)
	// 82EABC64: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABC68: 4082FFD8  bne 0x82eabc40
	if !ctx.cr[0].eq {
	pc = 0x82EABC40; continue 'dispatch;
	}
	// 82EABC6C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EABC70: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABC74: 41820018  beq 0x82eabc8c
	if ctx.cr[0].eq {
	pc = 0x82EABC8C; continue 'dispatch;
	}
	// 82EABC78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABC7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EABC80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABC84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EABC88: 4E800421  bctrl
	ctx.lr = 0x82EABC8C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EABC8C => {
    //   block [0x82EABC8C..0x82EABCA0)
	// 82EABC8C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EABC90: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABC94: 41820058  beq 0x82eabcec
	if ctx.cr[0].eq {
	pc = 0x82EABCEC; continue 'dispatch;
	}
	// 82EABC98: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EABC9C: 48000028  b 0x82eabcc4
	pc = 0x82EABCC4; continue 'dispatch;
            }
            0x82EABCA0 => {
    //   block [0x82EABCA0..0x82EABCC0)
	// 82EABCA0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EABCA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABCA8: 41820018  beq 0x82eabcc0
	if ctx.cr[0].eq {
	pc = 0x82EABCC0; continue 'dispatch;
	}
	// 82EABCAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABCB0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EABCB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABCB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EABCBC: 4E800421  bctrl
	ctx.lr = 0x82EABCC0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EABCC0 => {
    //   block [0x82EABCC0..0x82EABCC4)
	// 82EABCC0: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EABCC4; continue 'dispatch;
            }
            0x82EABCC4 => {
    //   block [0x82EABCC4..0x82EABCEC)
	// 82EABCC4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABCC8: 4082FFD8  bne 0x82eabca0
	if !ctx.cr[0].eq {
	pc = 0x82EABCA0; continue 'dispatch;
	}
	// 82EABCCC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EABCD0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABCD4: 41820018  beq 0x82eabcec
	if ctx.cr[0].eq {
	pc = 0x82EABCEC; continue 'dispatch;
	}
	// 82EABCD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABCDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EABCE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABCE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EABCE8: 4E800421  bctrl
	ctx.lr = 0x82EABCEC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EABCEC => {
    //   block [0x82EABCEC..0x82EABD0C)
	// 82EABCEC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EABCF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABCF4: 41820018  beq 0x82eabd0c
	if ctx.cr[0].eq {
	pc = 0x82EABD0C; continue 'dispatch;
	}
	// 82EABCF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABCFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EABD00: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABD04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EABD08: 4E800421  bctrl
	ctx.lr = 0x82EABD0C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EABD0C => {
    //   block [0x82EABD0C..0x82EABD2C)
	// 82EABD0C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EABD10: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABD14: 41820018  beq 0x82eabd2c
	if ctx.cr[0].eq {
	pc = 0x82EABD2C; continue 'dispatch;
	}
	// 82EABD18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABD1C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EABD20: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABD24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EABD28: 4E800421  bctrl
	ctx.lr = 0x82EABD2C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EABD2C => {
    //   block [0x82EABD2C..0x82EABD40)
	// 82EABD2C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EABD30: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABD34: 4182000C  beq 0x82eabd40
	if ctx.cr[0].eq {
	pc = 0x82EABD40; continue 'dispatch;
	}
	// 82EABD38: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82EABD3C: 4BFFF345  bl 0x82eab080
	ctx.lr = 0x82EABD40;
	sub_82EAB080(ctx, base);
	pc = 0x82EABD40; continue 'dispatch;
            }
            0x82EABD40 => {
    //   block [0x82EABD40..0x82EABD60)
	// 82EABD40: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EABD44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABD48: 41820018  beq 0x82eabd60
	if ctx.cr[0].eq {
	pc = 0x82EABD60; continue 'dispatch;
	}
	// 82EABD4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABD50: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EABD54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABD58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EABD5C: 4E800421  bctrl
	ctx.lr = 0x82EABD60;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EABD60 => {
    //   block [0x82EABD60..0x82EABD80)
	// 82EABD60: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EABD64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABD68: 41820018  beq 0x82eabd80
	if ctx.cr[0].eq {
	pc = 0x82EABD80; continue 'dispatch;
	}
	// 82EABD6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABD70: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EABD74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EABD78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EABD7C: 4E800421  bctrl
	ctx.lr = 0x82EABD80;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EABD80 => {
    //   block [0x82EABD80..0x82EABDB0)
	// 82EABD80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EABD84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EABD88: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EABD8C: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82EABD90: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EABD94: 4BFFA61D  bl 0x82ea63b0
	ctx.lr = 0x82EABD98;
	sub_82EA63B0(ctx, base);
	// 82EABD98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EABD9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EABDA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EABDA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EABDA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EABDAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EABDB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EABDB0 size=712
    let mut pc: u32 = 0x82EABDB0;
    'dispatch: loop {
        match pc {
            0x82EABDB0 => {
    //   block [0x82EABDB0..0x82EABDF0)
	// 82EABDB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EABDB4: 4BDFD641  bl 0x82ca93f4
	ctx.lr = 0x82EABDB8;
	sub_82CA93D0(ctx, base);
	// 82EABDB8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EABDBC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82EABDC0: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EABDC4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82EABDC8: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 82EABDCC: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 82EABDD0: 817A0020  lwz r11, 0x20(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EABDD4: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 82EABDD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EABDDC: 409900D4  ble cr6, 0x82eabeb0
	if !ctx.cr[6].gt {
	pc = 0x82EABEB0; continue 'dispatch;
	}
	// 82EABDE0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EABDE4: 3B8BA308  addi r28, r11, -0x5cf8
	ctx.r[28].s64 = ctx.r[11].s64 + -23800;
	// 82EABDE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EABDEC: 3B6BA2F8  addi r27, r11, -0x5d08
	ctx.r[27].s64 = ctx.r[11].s64 + -23816;
	pc = 0x82EABDF0; continue 'dispatch;
            }
            0x82EABDF0 => {
    //   block [0x82EABDF0..0x82EABE2C)
	// 82EABDF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EABDF4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EABDF8: 4BFD8231  bl 0x82e84028
	ctx.lr = 0x82EABDFC;
	sub_82E84028(ctx, base);
	// 82EABDFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EABE00: 48310261  bl 0x831bc060
	ctx.lr = 0x82EABE04;
	sub_831BC060(ctx, base);
	// 82EABE04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABE08: 41820040  beq 0x82eabe48
	if ctx.cr[0].eq {
	pc = 0x82EABE48; continue 'dispatch;
	}
	// 82EABE0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EABE10: 48310251  bl 0x831bc060
	ctx.lr = 0x82EABE14;
	sub_831BC060(ctx, base);
	// 82EABE14: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EABE18: 4BE00D39  bl 0x82cacb50
	ctx.lr = 0x82EABE1C;
	sub_82CACB50(ctx, base);
	// 82EABE1C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EABE20: 4082000C  bne 0x82eabe2c
	if !ctx.cr[0].eq {
	pc = 0x82EABE2C; continue 'dispatch;
	}
	// 82EABE24: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EABE28: 48000020  b 0x82eabe48
	pc = 0x82EABE48; continue 'dispatch;
            }
            0x82EABE2C => {
    //   block [0x82EABE2C..0x82EABE48)
	// 82EABE2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EABE30: 48310231  bl 0x831bc060
	ctx.lr = 0x82EABE34;
	sub_831BC060(ctx, base);
	// 82EABE34: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EABE38: 4BE00D19  bl 0x82cacb50
	ctx.lr = 0x82EABE3C;
	sub_82CACB50(ctx, base);
	// 82EABE3C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EABE40: 40820008  bne 0x82eabe48
	if !ctx.cr[0].eq {
	pc = 0x82EABE48; continue 'dispatch;
	}
	// 82EABE44: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	pc = 0x82EABE48; continue 'dispatch;
            }
            0x82EABE48 => {
    //   block [0x82EABE48..0x82EABE7C)
	// 82EABE48: 817A0020  lwz r11, 0x20(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EABE4C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EABE50: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EABE54: 4198FF9C  blt cr6, 0x82eabdf0
	if ctx.cr[6].lt {
	pc = 0x82EABDF0; continue 'dispatch;
	}
	// 82EABE58: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EABE5C: 419A0028  beq cr6, 0x82eabe84
	if ctx.cr[6].eq {
	pc = 0x82EABE84; continue 'dispatch;
	}
	// 82EABE60: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EABE64: 4B76AAC5  bl 0x82616928
	ctx.lr = 0x82EABE68;
	sub_82616928(ctx, base);
	// 82EABE68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABE6C: 41820010  beq 0x82eabe7c
	if ctx.cr[0].eq {
	pc = 0x82EABE7C; continue 'dispatch;
	}
	// 82EABE70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EABE74: 4BFE13BD  bl 0x82e8d230
	ctx.lr = 0x82EABE78;
	sub_82E8D230(ctx, base);
	// 82EABE78: 48000008  b 0x82eabe80
	pc = 0x82EABE80; continue 'dispatch;
            }
            0x82EABE7C => {
    //   block [0x82EABE7C..0x82EABE80)
	// 82EABE7C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	pc = 0x82EABE80; continue 'dispatch;
            }
            0x82EABE80 => {
    //   block [0x82EABE80..0x82EABE84)
	// 82EABE80: 90780008  stw r3, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x82EABE84; continue 'dispatch;
            }
            0x82EABE84 => {
    //   block [0x82EABE84..0x82EABEA8)
	// 82EABE84: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82EABE88: 419A0028  beq cr6, 0x82eabeb0
	if ctx.cr[6].eq {
	pc = 0x82EABEB0; continue 'dispatch;
	}
	// 82EABE8C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EABE90: 4B76AA99  bl 0x82616928
	ctx.lr = 0x82EABE94;
	sub_82616928(ctx, base);
	// 82EABE94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABE98: 41820010  beq 0x82eabea8
	if ctx.cr[0].eq {
	pc = 0x82EABEA8; continue 'dispatch;
	}
	// 82EABE9C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EABEA0: 4BFE1391  bl 0x82e8d230
	ctx.lr = 0x82EABEA4;
	sub_82E8D230(ctx, base);
	// 82EABEA4: 48000008  b 0x82eabeac
	pc = 0x82EABEAC; continue 'dispatch;
            }
            0x82EABEA8 => {
    //   block [0x82EABEA8..0x82EABEAC)
	// 82EABEA8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	pc = 0x82EABEAC; continue 'dispatch;
            }
            0x82EABEAC => {
    //   block [0x82EABEAC..0x82EABEB0)
	// 82EABEAC: 9078000C  stw r3, 0xc(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	pc = 0x82EABEB0; continue 'dispatch;
            }
            0x82EABEB0 => {
    //   block [0x82EABEB0..0x82EABECC)
	// 82EABEB0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EABEB4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82EABEB8: 4BFDA121  bl 0x82e85fd8
	ctx.lr = 0x82EABEBC;
	sub_82E85FD8(ctx, base);
	// 82EABEBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EABEC0: 4082000C  bne 0x82eabecc
	if !ctx.cr[0].eq {
	pc = 0x82EABECC; continue 'dispatch;
	}
	// 82EABEC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EABEC8: 480001A8  b 0x82eac070
	pc = 0x82EAC070; continue 'dispatch;
            }
            0x82EABECC => {
    //   block [0x82EABECC..0x82EABEF4)
	// 82EABECC: 81780014  lwz r11, 0x14(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EABED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EABED4: 409A0044  bne cr6, 0x82eabf18
	if !ctx.cr[6].eq {
	pc = 0x82EABF18; continue 'dispatch;
	}
	// 82EABED8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EABEDC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EABEE0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EABEE4: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 82EABEE8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82EABEEC: 41990008  bgt cr6, 0x82eabef4
	if ctx.cr[6].gt {
	pc = 0x82EABEF4; continue 'dispatch;
	}
	// 82EABEF0: 3BE0000A  li r31, 0xa
	ctx.r[31].s64 = 10;
	pc = 0x82EABEF4; continue 'dispatch;
            }
            0x82EABEF4 => {
    //   block [0x82EABEF4..0x82EABF10)
	// 82EABEF4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EABEF8: 4B76AA31  bl 0x82616928
	ctx.lr = 0x82EABEFC;
	sub_82616928(ctx, base);
	// 82EABEFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABF00: 41820010  beq 0x82eabf10
	if ctx.cr[0].eq {
	pc = 0x82EABF10; continue 'dispatch;
	}
	// 82EABF04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EABF08: 4BFFF3F9  bl 0x82eab300
	ctx.lr = 0x82EABF0C;
	sub_82EAB300(ctx, base);
	// 82EABF0C: 48000008  b 0x82eabf14
	pc = 0x82EABF14; continue 'dispatch;
            }
            0x82EABF10 => {
    //   block [0x82EABF10..0x82EABF14)
	// 82EABF10: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	pc = 0x82EABF14; continue 'dispatch;
            }
            0x82EABF14 => {
    //   block [0x82EABF14..0x82EABF18)
	// 82EABF14: 90780014  stw r3, 0x14(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	pc = 0x82EABF18; continue 'dispatch;
            }
            0x82EABF18 => {
    //   block [0x82EABF18..0x82EABF38)
	// 82EABF18: 81780020  lwz r11, 0x20(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EABF1C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EABF20: 409A00A4  bne cr6, 0x82eabfc4
	if !ctx.cr[6].eq {
	pc = 0x82EABFC4; continue 'dispatch;
	}
	// 82EABF24: 81780014  lwz r11, 0x14(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EABF28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABF2C: 4182000C  beq 0x82eabf38
	if ctx.cr[0].eq {
	pc = 0x82EABF38; continue 'dispatch;
	}
	// 82EABF30: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EABF34: 48000008  b 0x82eabf3c
	pc = 0x82EABF3C; continue 'dispatch;
            }
            0x82EABF38 => {
    //   block [0x82EABF38..0x82EABF3C)
	// 82EABF38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EABF3C; continue 'dispatch;
            }
            0x82EABF3C => {
    //   block [0x82EABF3C..0x82EABF60)
	// 82EABF3C: 557F103A  slwi r31, r11, 2
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82EABF40: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 82EABF44: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EABF48: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82EABF4C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EABF50: 93F80020  stw r31, 0x20(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 82EABF54: 57EB2036  slwi r11, r31, 4
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EABF58: 40990008  ble cr6, 0x82eabf60
	if !ctx.cr[6].gt {
	pc = 0x82EABF60; continue 'dispatch;
	}
	// 82EABF5C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82EABF60; continue 'dispatch;
            }
            0x82EABF60 => {
    //   block [0x82EABF60..0x82EABF70)
	// 82EABF60: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EABF64: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EABF68: 41990008  bgt cr6, 0x82eabf70
	if ctx.cr[6].gt {
	pc = 0x82EABF70; continue 'dispatch;
	}
	// 82EABF6C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82EABF70; continue 'dispatch;
            }
            0x82EABF70 => {
    //   block [0x82EABF70..0x82EABF98)
	// 82EABF70: 4B76A9B9  bl 0x82616928
	ctx.lr = 0x82EABF74;
	sub_82616928(ctx, base);
	// 82EABF74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABF78: 41820044  beq 0x82eabfbc
	if ctx.cr[0].eq {
	pc = 0x82EABFBC; continue 'dispatch;
	}
	// 82EABF7C: 39030004  addi r8, r3, 4
	ctx.r[8].s64 = ctx.r[3].s64 + 4;
	// 82EABF80: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82EABF84: 355FFFFF  addic. r10, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EABF88: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82EABF8C: 41800028  blt 0x82eabfb4
	if ctx.cr[0].lt {
	pc = 0x82EABFB4; continue 'dispatch;
	}
	// 82EABF90: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EABF94: 3929AFB4  addi r9, r9, -0x504c
	ctx.r[9].s64 = ctx.r[9].s64 + -20556;
	pc = 0x82EABF98; continue 'dispatch;
            }
            0x82EABF98 => {
    //   block [0x82EABF98..0x82EABFB4)
	// 82EABF98: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EABF9C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EABFA0: 92EB0004  stw r23, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 82EABFA4: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EABFA8: 92EB000C  stw r23, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[23].u32 ) };
	// 82EABFAC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82EABFB0: 4080FFE8  bge 0x82eabf98
	if !ctx.cr[0].lt {
	pc = 0x82EABF98; continue 'dispatch;
	}
	pc = 0x82EABFB4; continue 'dispatch;
            }
            0x82EABFB4 => {
    //   block [0x82EABFB4..0x82EABFBC)
	// 82EABFB4: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82EABFB8: 48000008  b 0x82eabfc0
	pc = 0x82EABFC0; continue 'dispatch;
            }
            0x82EABFBC => {
    //   block [0x82EABFBC..0x82EABFC0)
	// 82EABFBC: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x82EABFC0; continue 'dispatch;
            }
            0x82EABFC0 => {
    //   block [0x82EABFC0..0x82EABFC4)
	// 82EABFC0: 9178001C  stw r11, 0x1c(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	pc = 0x82EABFC4; continue 'dispatch;
            }
            0x82EABFC4 => {
    //   block [0x82EABFC4..0x82EAC004)
	// 82EABFC4: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EABFC8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABFCC: 418200A0  beq 0x82eac06c
	if ctx.cr[0].eq {
	pc = 0x82EAC06C; continue 'dispatch;
	}
	// 82EABFD0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EABFD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EABFD8: 419A0094  beq cr6, 0x82eac06c
	if ctx.cr[6].eq {
	pc = 0x82EAC06C; continue 'dispatch;
	}
	// 82EABFDC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EABFE0: 4B76A949  bl 0x82616928
	ctx.lr = 0x82EABFE4;
	sub_82616928(ctx, base);
	// 82EABFE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EABFE8: 4182001C  beq 0x82eac004
	if ctx.cr[0].eq {
	pc = 0x82EAC004; continue 'dispatch;
	}
	// 82EABFEC: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EABFF0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EABFF4: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82EABFF8: 4BFFF651  bl 0x82eab648
	ctx.lr = 0x82EABFFC;
	sub_82EAB648(ctx, base);
	// 82EABFFC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EAC000: 48000008  b 0x82eac008
	pc = 0x82EAC008; continue 'dispatch;
            }
            0x82EAC004 => {
    //   block [0x82EAC004..0x82EAC008)
	// 82EAC004: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x82EAC008; continue 'dispatch;
            }
            0x82EAC008 => {
    //   block [0x82EAC008..0x82EAC030)
	// 82EAC008: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EAC00C: 91780018  stw r11, 0x18(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EAC010: 4B76A919  bl 0x82616928
	ctx.lr = 0x82EAC014;
	sub_82616928(ctx, base);
	// 82EAC014: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC018: 41820018  beq 0x82eac030
	if ctx.cr[0].eq {
	pc = 0x82EAC030; continue 'dispatch;
	}
	// 82EAC01C: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAC020: 808B0018  lwz r4, 0x18(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAC024: 4BFFF765  bl 0x82eab788
	ctx.lr = 0x82EAC028;
	sub_82EAB788(ctx, base);
	// 82EAC028: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82EAC02C: 48000008  b 0x82eac034
	pc = 0x82EAC034; continue 'dispatch;
            }
            0x82EAC030 => {
    //   block [0x82EAC030..0x82EAC034)
	// 82EAC030: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	pc = 0x82EAC034; continue 'dispatch;
            }
            0x82EAC034 => {
    //   block [0x82EAC034..0x82EAC06C)
	// 82EAC034: 81780020  lwz r11, 0x20(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EAC038: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EAC03C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EAC040: 80980018  lwz r4, 0x18(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAC044: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EAC048: 91380030  stw r9, 0x30(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 82EAC04C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EAC050: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82EAC054: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAC058: 92E1005C  stw r23, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[23].u32 ) };
	// 82EAC05C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EAC060: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EAC064: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAC068: 4BFFED81  bl 0x82eaade8
	ctx.lr = 0x82EAC06C;
	sub_82EAADE8(ctx, base);
	pc = 0x82EAC06C; continue 'dispatch;
            }
            0x82EAC06C => {
    //   block [0x82EAC06C..0x82EAC070)
	// 82EAC06C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EAC070; continue 'dispatch;
            }
            0x82EAC070 => {
    //   block [0x82EAC070..0x82EAC078)
	// 82EAC070: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EAC074: 4BDFD3D0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAC078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAC078 size=312
    let mut pc: u32 = 0x82EAC078;
    'dispatch: loop {
        match pc {
            0x82EAC078 => {
    //   block [0x82EAC078..0x82EAC0F4)
	// 82EAC078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAC07C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAC080: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAC084: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAC088: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC08C: 41820104  beq 0x82eac190
	if ctx.cr[0].eq {
	pc = 0x82EAC190; continue 'dispatch;
	}
	// 82EAC090: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAC094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAC098: 419A00F8  beq cr6, 0x82eac190
	if ctx.cr[6].eq {
	pc = 0x82EAC190; continue 'dispatch;
	}
	// 82EAC09C: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAC0A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC0A4: 418200EC  beq 0x82eac190
	if ctx.cr[0].eq {
	pc = 0x82EAC190; continue 'dispatch;
	}
	// 82EAC0A8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAC0AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAC0B0: 419A00E0  beq cr6, 0x82eac190
	if ctx.cr[6].eq {
	pc = 0x82EAC190; continue 'dispatch;
	}
	// 82EAC0B4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EAC0B8: 90830034  stw r4, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[4].u32 ) };
	// 82EAC0BC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAC0C0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAC0C4: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC0C8: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82EAC0CC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAC0D0: 91230044  stw r9, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[9].u32 ) };
	// 82EAC0D4: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82EAC0D8: 80E30034  lwz r7, 0x34(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EAC0DC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC0E0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC0E4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EAC0E8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82EAC0EC: 40990048  ble cr6, 0x82eac134
	if !ctx.cr[6].gt {
	pc = 0x82EAC134; continue 'dispatch;
	}
	// 82EAC0F0: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x82EAC0F4; continue 'dispatch;
            }
            0x82EAC0F4 => {
    //   block [0x82EAC0F4..0x82EAC11C)
	// 82EAC0F4: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EAC0F8: 5529F87E  srwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EAC0FC: 55282036  slwi r8, r9, 4
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EAC100: 7D083214  add r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 82EAC104: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC108: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EAC10C: 419A0024  beq cr6, 0x82eac130
	if ctx.cr[6].eq {
	pc = 0x82EAC130; continue 'dispatch;
	}
	// 82EAC110: 4098000C  bge cr6, 0x82eac11c
	if !ctx.cr[6].lt {
	pc = 0x82EAC11C; continue 'dispatch;
	}
	// 82EAC114: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82EAC118: 48000008  b 0x82eac120
	pc = 0x82EAC120; continue 'dispatch;
            }
            0x82EAC11C => {
    //   block [0x82EAC11C..0x82EAC120)
	// 82EAC11C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82EAC120; continue 'dispatch;
            }
            0x82EAC120 => {
    //   block [0x82EAC120..0x82EAC130)
	// 82EAC120: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EAC124: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82EAC128: 4199FFCC  bgt cr6, 0x82eac0f4
	if ctx.cr[6].gt {
	pc = 0x82EAC0F4; continue 'dispatch;
	}
	// 82EAC12C: 48000008  b 0x82eac134
	pc = 0x82EAC134; continue 'dispatch;
            }
            0x82EAC130 => {
    //   block [0x82EAC130..0x82EAC134)
	// 82EAC130: 91230044  stw r9, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[9].u32 ) };
	pc = 0x82EAC134; continue 'dispatch;
            }
            0x82EAC134 => {
    //   block [0x82EAC134..0x82EAC160)
	// 82EAC134: 81230044  lwz r9, 0x44(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EAC138: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 82EAC13C: 409A003C  bne cr6, 0x82eac178
	if !ctx.cr[6].eq {
	pc = 0x82EAC178; continue 'dispatch;
	}
	// 82EAC140: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAC144: 55682036  slwi r8, r11, 4
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EAC148: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82EAC14C: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC150: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EAC154: 409A000C  bne cr6, 0x82eac160
	if !ctx.cr[6].eq {
	pc = 0x82EAC160; continue 'dispatch;
	}
	// 82EAC158: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EAC15C: 4800001C  b 0x82eac178
	pc = 0x82EAC178; continue 'dispatch;
            }
            0x82EAC160 => {
    //   block [0x82EAC160..0x82EAC178)
	// 82EAC160: 554B2036  slwi r11, r10, 4
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAC164: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EAC168: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC16C: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EAC170: 409A0020  bne cr6, 0x82eac190
	if !ctx.cr[6].eq {
	pc = 0x82EAC190; continue 'dispatch;
	}
	// 82EAC174: 91430044  stw r10, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	pc = 0x82EAC178; continue 'dispatch;
            }
            0x82EAC178 => {
    //   block [0x82EAC178..0x82EAC190)
	// 82EAC178: 81630044  lwz r11, 0x44(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EAC17C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EAC180: 99430048  stb r10, 0x48(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[10].u8 ) };
	// 82EAC184: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EAC188: 4BFFEFB9  bl 0x82eab140
	ctx.lr = 0x82EAC18C;
	sub_82EAB140(ctx, base);
	// 82EAC18C: 48000008  b 0x82eac194
	pc = 0x82EAC194; continue 'dispatch;
            }
            0x82EAC190 => {
    //   block [0x82EAC190..0x82EAC194)
	// 82EAC190: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EAC194; continue 'dispatch;
            }
            0x82EAC194 => {
    //   block [0x82EAC194..0x82EAC1B0)
	// 82EAC194: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EAC198: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EAC19C: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAC1A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAC1A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAC1A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAC1AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAC1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAC1B0 size=252
    let mut pc: u32 = 0x82EAC1B0;
    'dispatch: loop {
        match pc {
            0x82EAC1B0 => {
    //   block [0x82EAC1B0..0x82EAC1E4)
	// 82EAC1B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAC1B4: 4BDFD24D  bl 0x82ca9400
	ctx.lr = 0x82EAC1B8;
	sub_82CA93D0(ctx, base);
	// 82EAC1B8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EAC1BC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAC1C0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EAC1C4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EAC1C8: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82EAC1CC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82EAC1D0: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82EAC1D4: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAC1D8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC1DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC1E0: 418200B4  beq 0x82eac294
	if ctx.cr[0].eq {
	pc = 0x82EAC294; continue 'dispatch;
	}
	pc = 0x82EAC1E4; continue 'dispatch;
            }
            0x82EAC1E4 => {
    //   block [0x82EAC1E4..0x82EAC1FC)
	// 82EAC1E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC1E8: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82EAC1EC: 419A0010  beq cr6, 0x82eac1fc
	if ctx.cr[6].eq {
	pc = 0x82EAC1FC; continue 'dispatch;
	}
	// 82EAC1F0: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAC1F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC1F8: 4082FFEC  bne 0x82eac1e4
	if !ctx.cr[0].eq {
	pc = 0x82EAC1E4; continue 'dispatch;
	}
	pc = 0x82EAC1FC; continue 'dispatch;
            }
            0x82EAC1FC => {
    //   block [0x82EAC1FC..0x82EAC228)
	// 82EAC1FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAC200: 419A0094  beq cr6, 0x82eac294
	if ctx.cr[6].eq {
	pc = 0x82EAC294; continue 'dispatch;
	}
	// 82EAC204: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EAC208: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAC20C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAC210: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EAC214: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 82EAC218: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EAC21C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EAC220: 4BFFFE59  bl 0x82eac078
	ctx.lr = 0x82EAC224;
	sub_82EAC078(ctx, base);
	// 82EAC224: 48000068  b 0x82eac28c
	pc = 0x82EAC28C; continue 'dispatch;
            }
            0x82EAC228 => {
    //   block [0x82EAC228..0x82EAC240)
	// 82EAC228: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC22C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82EAC230: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC234: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAC238: 4099004C  ble cr6, 0x82eac284
	if !ctx.cr[6].gt {
	pc = 0x82EAC284; continue 'dispatch;
	}
	// 82EAC23C: 3BC0000C  li r30, 0xc
	ctx.r[30].s64 = 12;
	pc = 0x82EAC240; continue 'dispatch;
            }
            0x82EAC240 => {
    //   block [0x82EAC240..0x82EAC284)
	// 82EAC240: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC244: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EAC248: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EAC24C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EAC250: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EAC254: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC258: 7CCBF214  add r6, r11, r30
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EAC25C: 38A6FFF4  addi r5, r6, -0xc
	ctx.r[5].s64 = ctx.r[6].s64 + -12;
	// 82EAC260: 4B3DD191  bl 0x822893f0
	ctx.lr = 0x82EAC264;
	sub_822893F0(ctx, base);
	// 82EAC264: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAC268: 4082003C  bne 0x82eac2a4
	if !ctx.cr[0].eq {
	pc = 0x82EAC2A4; continue 'dispatch;
	}
	// 82EAC26C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC270: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EAC274: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82EAC278: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC27C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAC280: 4198FFC0  blt cr6, 0x82eac240
	if ctx.cr[6].lt {
	pc = 0x82EAC240; continue 'dispatch;
	}
	pc = 0x82EAC284; continue 'dispatch;
            }
            0x82EAC284 => {
    //   block [0x82EAC284..0x82EAC28C)
	// 82EAC284: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EAC288: 4BFFEEB9  bl 0x82eab140
	ctx.lr = 0x82EAC28C;
	sub_82EAB140(ctx, base);
	pc = 0x82EAC28C; continue 'dispatch;
            }
            0x82EAC28C => {
    //   block [0x82EAC28C..0x82EAC294)
	// 82EAC28C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EAC290: 4082FF98  bne 0x82eac228
	if !ctx.cr[0].eq {
	pc = 0x82EAC228; continue 'dispatch;
	}
	pc = 0x82EAC294; continue 'dispatch;
            }
            0x82EAC294 => {
    //   block [0x82EAC294..0x82EAC298)
	// 82EAC294: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EAC298; continue 'dispatch;
            }
            0x82EAC298 => {
    //   block [0x82EAC298..0x82EAC2A4)
	// 82EAC298: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EAC29C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EAC2A0: 4BDFD1B0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EAC2A4 => {
    //   block [0x82EAC2A4..0x82EAC2AC)
	// 82EAC2A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EAC2A8: 4BFFFFF0  b 0x82eac298
	pc = 0x82EAC298; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAC2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EAC2B0 size=332
    let mut pc: u32 = 0x82EAC2B0;
    'dispatch: loop {
        match pc {
            0x82EAC2B0 => {
    //   block [0x82EAC2B0..0x82EAC2E4)
	// 82EAC2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAC2B4: 4BDFD149  bl 0x82ca93fc
	ctx.lr = 0x82EAC2B8;
	sub_82CA93D0(ctx, base);
	// 82EAC2B8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82EAC2BC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAC2C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EAC2C4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EAC2C8: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82EAC2CC: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82EAC2D0: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 82EAC2D4: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAC2D8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC2DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC2E0: 41820024  beq 0x82eac304
	if ctx.cr[0].eq {
	pc = 0x82EAC304; continue 'dispatch;
	}
	pc = 0x82EAC2E4; continue 'dispatch;
            }
            0x82EAC2E4 => {
    //   block [0x82EAC2E4..0x82EAC2FC)
	// 82EAC2E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC2E8: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82EAC2EC: 419A0010  beq cr6, 0x82eac2fc
	if ctx.cr[6].eq {
	pc = 0x82EAC2FC; continue 'dispatch;
	}
	// 82EAC2F0: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAC2F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC2F8: 4082FFEC  bne 0x82eac2e4
	if !ctx.cr[0].eq {
	pc = 0x82EAC2E4; continue 'dispatch;
	}
	pc = 0x82EAC2FC; continue 'dispatch;
            }
            0x82EAC2FC => {
    //   block [0x82EAC2FC..0x82EAC304)
	// 82EAC2FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAC300: 409A0024  bne cr6, 0x82eac324
	if !ctx.cr[6].eq {
	pc = 0x82EAC324; continue 'dispatch;
	}
	pc = 0x82EAC304; continue 'dispatch;
            }
            0x82EAC304 => {
    //   block [0x82EAC304..0x82EAC324)
	// 82EAC304: C0070000  lfs f0, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAC308: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAC30C: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EAC310: C0070004  lfs f0, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAC314: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EAC318: C0070008  lfs f0, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAC31C: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EAC320: 480000D0  b 0x82eac3f0
	pc = 0x82EAC3F0; continue 'dispatch;
            }
            0x82EAC324 => {
    //   block [0x82EAC324..0x82EAC364)
	// 82EAC324: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EAC328: C0070000  lfs f0, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAC32C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EAC330: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAC334: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EAC338: C0070004  lfs f0, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAC33C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EAC340: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82EAC344: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EAC348: C0070008  lfs f0, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAC34C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAC350: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82EAC354: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAC358: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EAC35C: 4BFFFD1D  bl 0x82eac078
	ctx.lr = 0x82EAC360;
	sub_82EAC078(ctx, base);
	// 82EAC360: 48000084  b 0x82eac3e4
	pc = 0x82EAC3E4; continue 'dispatch;
            }
            0x82EAC364 => {
    //   block [0x82EAC364..0x82EAC37C)
	// 82EAC364: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC368: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82EAC36C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC370: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAC374: 40990068  ble cr6, 0x82eac3dc
	if !ctx.cr[6].gt {
	pc = 0x82EAC3DC; continue 'dispatch;
	}
	// 82EAC378: 3BC0000C  li r30, 0xc
	ctx.r[30].s64 = 12;
	pc = 0x82EAC37C; continue 'dispatch;
            }
            0x82EAC37C => {
    //   block [0x82EAC37C..0x82EAC3C4)
	// 82EAC37C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC380: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82EAC384: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EAC388: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EAC38C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EAC390: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC394: 7CCBF214  add r6, r11, r30
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EAC398: 38A6FFF4  addi r5, r6, -0xc
	ctx.r[5].s64 = ctx.r[6].s64 + -12;
	// 82EAC39C: 4B3DD055  bl 0x822893f0
	ctx.lr = 0x82EAC3A0;
	sub_822893F0(ctx, base);
	// 82EAC3A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAC3A4: 41820020  beq 0x82eac3c4
	if ctx.cr[0].eq {
	pc = 0x82EAC3C4; continue 'dispatch;
	}
	// 82EAC3A8: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAC3AC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EAC3B0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EAC3B4: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAC3B8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EAC3BC: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAC3C0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	pc = 0x82EAC3C4; continue 'dispatch;
            }
            0x82EAC3C4 => {
    //   block [0x82EAC3C4..0x82EAC3DC)
	// 82EAC3C4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC3C8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EAC3CC: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82EAC3D0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC3D4: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAC3D8: 4198FFA4  blt cr6, 0x82eac37c
	if ctx.cr[6].lt {
	pc = 0x82EAC37C; continue 'dispatch;
	}
	pc = 0x82EAC3DC; continue 'dispatch;
            }
            0x82EAC3DC => {
    //   block [0x82EAC3DC..0x82EAC3E4)
	// 82EAC3DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EAC3E0: 4BFFED61  bl 0x82eab140
	ctx.lr = 0x82EAC3E4;
	sub_82EAB140(ctx, base);
	pc = 0x82EAC3E4; continue 'dispatch;
            }
            0x82EAC3E4 => {
    //   block [0x82EAC3E4..0x82EAC3F0)
	// 82EAC3E4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EAC3E8: 4082FF7C  bne 0x82eac364
	if !ctx.cr[0].eq {
	pc = 0x82EAC364; continue 'dispatch;
	}
	// 82EAC3EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x82EAC3F0; continue 'dispatch;
            }
            0x82EAC3F0 => {
    //   block [0x82EAC3F0..0x82EAC3FC)
	// 82EAC3F0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EAC3F4: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82EAC3F8: 4BDFD054  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAC400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EAC400 size=548
    let mut pc: u32 = 0x82EAC400;
    'dispatch: loop {
        match pc {
            0x82EAC400 => {
    //   block [0x82EAC400..0x82EAC42C)
	// 82EAC400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAC404: 4BDFD009  bl 0x82ca940c
	ctx.lr = 0x82EAC408;
	sub_82CA93D0(ctx, base);
	// 82EAC408: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAC40C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EAC410: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAC414: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EAC418: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82EAC41C: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAC420: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC424: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC428: 418201E8  beq 0x82eac610
	if ctx.cr[0].eq {
	pc = 0x82EAC610; continue 'dispatch;
	}
	pc = 0x82EAC42C; continue 'dispatch;
            }
            0x82EAC42C => {
    //   block [0x82EAC42C..0x82EAC444)
	// 82EAC42C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC430: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EAC434: 419A0010  beq cr6, 0x82eac444
	if ctx.cr[6].eq {
	pc = 0x82EAC444; continue 'dispatch;
	}
	// 82EAC438: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAC43C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC440: 4082FFEC  bne 0x82eac42c
	if !ctx.cr[0].eq {
	pc = 0x82EAC42C; continue 'dispatch;
	}
	pc = 0x82EAC444; continue 'dispatch;
            }
            0x82EAC444 => {
    //   block [0x82EAC444..0x82EAC46C)
	// 82EAC444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAC448: 419A01C8  beq cr6, 0x82eac610
	if ctx.cr[6].eq {
	pc = 0x82EAC610; continue 'dispatch;
	}
	// 82EAC44C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EAC450: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAC454: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAC458: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EAC45C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EAC460: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EAC464: 4BFFFC15  bl 0x82eac078
	ctx.lr = 0x82EAC468;
	sub_82EAC078(ctx, base);
	// 82EAC468: 480001A0  b 0x82eac608
	pc = 0x82EAC608; continue 'dispatch;
            }
            0x82EAC46C => {
    //   block [0x82EAC46C..0x82EAC498)
	// 82EAC46C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC470: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC474: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC478: 2B080002  cmplwi cr6, r8, 2
	ctx.cr[6].compare_u32(ctx.r[8].u32, 2 as u32, &mut ctx.xer);
	// 82EAC47C: 41980184  blt cr6, 0x82eac600
	if ctx.cr[6].lt {
	pc = 0x82EAC600; continue 'dispatch;
	}
	// 82EAC480: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EAC484: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EAC488: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 82EAC48C: 4099016C  ble cr6, 0x82eac5f8
	if !ctx.cr[6].gt {
	pc = 0x82EAC5F8; continue 'dispatch;
	}
	// 82EAC490: C11F0008  lfs f8, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EAC494: 394B0014  addi r10, r11, 0x14
	ctx.r[10].s64 = ctx.r[11].s64 + 20;
	pc = 0x82EAC498; continue 'dispatch;
            }
            0x82EAC498 => {
    //   block [0x82EAC498..0x82EAC4B0)
	// 82EAC498: C12B0008  lfs f9, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EAC49C: C14A0000  lfs f10, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EAC4A0: FF095000  fcmpu cr6, f9, f10
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[10].f64);
	// 82EAC4A4: 4098000C  bge cr6, 0x82eac4b0
	if !ctx.cr[6].lt {
	pc = 0x82EAC4B0; continue 'dispatch;
	}
	// 82EAC4A8: FCE04890  fmr f7, f9
	ctx.f[7].f64 = ctx.f[9].f64;
	// 82EAC4AC: 48000008  b 0x82eac4b4
	pc = 0x82EAC4B4; continue 'dispatch;
            }
            0x82EAC4B0 => {
    //   block [0x82EAC4B0..0x82EAC4B4)
	// 82EAC4B0: FCE05090  fmr f7, f10
	ctx.f[7].f64 = ctx.f[10].f64;
	pc = 0x82EAC4B4; continue 'dispatch;
            }
            0x82EAC4B4 => {
    //   block [0x82EAC4B4..0x82EAC4CC)
	// 82EAC4B4: FF083800  fcmpu cr6, f8, f7
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[7].f64);
	// 82EAC4B8: 4198012C  blt cr6, 0x82eac5e4
	if ctx.cr[6].lt {
	pc = 0x82EAC5E4; continue 'dispatch;
	}
	// 82EAC4BC: FF095000  fcmpu cr6, f9, f10
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[10].f64);
	// 82EAC4C0: 4099000C  ble cr6, 0x82eac4cc
	if !ctx.cr[6].gt {
	pc = 0x82EAC4CC; continue 'dispatch;
	}
	// 82EAC4C4: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82EAC4C8: 48000008  b 0x82eac4d0
	pc = 0x82EAC4D0; continue 'dispatch;
            }
            0x82EAC4CC => {
    //   block [0x82EAC4CC..0x82EAC4D0)
	// 82EAC4CC: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	pc = 0x82EAC4D0; continue 'dispatch;
            }
            0x82EAC4D0 => {
    //   block [0x82EAC4D0..0x82EAC4F0)
	// 82EAC4D0: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 82EAC4D4: 41990110  bgt cr6, 0x82eac5e4
	if ctx.cr[6].gt {
	pc = 0x82EAC5E4; continue 'dispatch;
	}
	// 82EAC4D8: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAC4DC: C18AFFF8  lfs f12, -8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EAC4E0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EAC4E4: 4099000C  ble cr6, 0x82eac4f0
	if !ctx.cr[6].gt {
	pc = 0x82EAC4F0; continue 'dispatch;
	}
	// 82EAC4E8: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EAC4EC: 48000008  b 0x82eac4f4
	pc = 0x82EAC4F4; continue 'dispatch;
            }
            0x82EAC4F0 => {
    //   block [0x82EAC4F0..0x82EAC4F4)
	// 82EAC4F0: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82EAC4F4; continue 'dispatch;
            }
            0x82EAC4F4 => {
    //   block [0x82EAC4F4..0x82EAC534)
	// 82EAC4F4: C17F0000  lfs f11, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EAC4F8: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 82EAC4FC: 419900E8  bgt cr6, 0x82eac5e4
	if ctx.cr[6].gt {
	pc = 0x82EAC5E4; continue 'dispatch;
	}
	// 82EAC500: FF095000  fcmpu cr6, f9, f10
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[10].f64);
	// 82EAC504: 419A008C  beq cr6, 0x82eac590
	if ctx.cr[6].eq {
	pc = 0x82EAC590; continue 'dispatch;
	}
	// 82EAC508: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EAC50C: 419A0028  beq cr6, 0x82eac534
	if ctx.cr[6].eq {
	pc = 0x82EAC534; continue 'dispatch;
	}
	// 82EAC510: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EAC514: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EAC518: ED286828  fsubs f9, f8, f13
	ctx.f[9].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EAC51C: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EAC520: ED890332  fmuls f12, f9, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EAC524: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EAC528: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EAC52C: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82EAC530: 419900B4  bgt cr6, 0x82eac5e4
	if ctx.cr[6].gt {
	pc = 0x82EAC5E4; continue 'dispatch;
	}
	pc = 0x82EAC534; continue 'dispatch;
            }
            0x82EAC534 => {
    //   block [0x82EAC534..0x82EAC578)
	// 82EAC534: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82EAC538: 409A0040  bne cr6, 0x82eac578
	if !ctx.cr[6].eq {
	pc = 0x82EAC578; continue 'dispatch;
	}
	// 82EAC53C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EAC540: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAC544: ECC86828  fsubs f6, f8, f13
	ctx.f[6].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EAC548: C18AFFFC  lfs f12, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EAC54C: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EAC550: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EAC554: C17F0004  lfs f11, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EAC558: C13E000C  lfs f9, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EAC55C: ED8C01B2  fmuls f12, f12, f6
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[6].f64) as f32) as f64);
	// 82EAC560: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EAC564: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EAC568: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EAC56C: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EAC570: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82EAC574: 419800A8  blt cr6, 0x82eac61c
	if ctx.cr[6].lt {
	pc = 0x82EAC61C; continue 'dispatch;
	}
	pc = 0x82EAC578; continue 'dispatch;
            }
            0x82EAC578 => {
    //   block [0x82EAC578..0x82EAC590)
	// 82EAC578: FF083800  fcmpu cr6, f8, f7
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[7].f64);
	// 82EAC57C: 40990068  ble cr6, 0x82eac5e4
	if !ctx.cr[6].gt {
	pc = 0x82EAC5E4; continue 'dispatch;
	}
	// 82EAC580: 54EB063E  clrlwi r11, r7, 0x18
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82EAC584: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EAC588: 5567DFFE  rlwinm r7, r11, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EAC58C: 48000058  b 0x82eac5e4
	pc = 0x82EAC5E4; continue 'dispatch;
            }
            0x82EAC590 => {
    //   block [0x82EAC590..0x82EAC5A0)
	// 82EAC590: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EAC594: 4098000C  bge cr6, 0x82eac5a0
	if !ctx.cr[6].lt {
	pc = 0x82EAC5A0; continue 'dispatch;
	}
	// 82EAC598: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EAC59C: 48000008  b 0x82eac5a4
	pc = 0x82EAC5A4; continue 'dispatch;
            }
            0x82EAC5A0 => {
    //   block [0x82EAC5A0..0x82EAC5A4)
	// 82EAC5A0: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82EAC5A4; continue 'dispatch;
            }
            0x82EAC5A4 => {
    //   block [0x82EAC5A4..0x82EAC5E4)
	// 82EAC5A4: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 82EAC5A8: 4198003C  blt cr6, 0x82eac5e4
	if ctx.cr[6].lt {
	pc = 0x82EAC5E4; continue 'dispatch;
	}
	// 82EAC5AC: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EAC5B0: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EAC5B4: C14AFFFC  lfs f10, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EAC5B8: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EAC5BC: ED4A6828  fsubs f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EAC5C0: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EAC5C4: C13E000C  lfs f9, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EAC5C8: ED6A02F2  fmuls f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EAC5CC: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EAC5D0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EAC5D4: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EAC5D8: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EAC5DC: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82EAC5E0: 4198003C  blt cr6, 0x82eac61c
	if ctx.cr[6].lt {
	pc = 0x82EAC61C; continue 'dispatch;
	}
	pc = 0x82EAC5E4; continue 'dispatch;
            }
            0x82EAC5E4 => {
    //   block [0x82EAC5E4..0x82EAC5F8)
	// 82EAC5E4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EAC5E8: 396AFFF8  addi r11, r10, -8
	ctx.r[11].s64 = ctx.r[10].s64 + -8;
	// 82EAC5EC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EAC5F0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EAC5F4: 4198FEA4  blt cr6, 0x82eac498
	if ctx.cr[6].lt {
	pc = 0x82EAC498; continue 'dispatch;
	}
	pc = 0x82EAC5F8; continue 'dispatch;
            }
            0x82EAC5F8 => {
    //   block [0x82EAC5F8..0x82EAC600)
	// 82EAC5F8: 54EB063F  clrlwi. r11, r7, 0x18
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAC5FC: 40820020  bne 0x82eac61c
	if !ctx.cr[0].eq {
	pc = 0x82EAC61C; continue 'dispatch;
	}
	pc = 0x82EAC600; continue 'dispatch;
            }
            0x82EAC600 => {
    //   block [0x82EAC600..0x82EAC608)
	// 82EAC600: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EAC604: 4BFFEB3D  bl 0x82eab140
	ctx.lr = 0x82EAC608;
	sub_82EAB140(ctx, base);
	pc = 0x82EAC608; continue 'dispatch;
            }
            0x82EAC608 => {
    //   block [0x82EAC608..0x82EAC610)
	// 82EAC608: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC60C: 4082FE60  bne 0x82eac46c
	if !ctx.cr[0].eq {
	pc = 0x82EAC46C; continue 'dispatch;
	}
	pc = 0x82EAC610; continue 'dispatch;
            }
            0x82EAC610 => {
    //   block [0x82EAC610..0x82EAC614)
	// 82EAC610: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EAC614; continue 'dispatch;
            }
            0x82EAC614 => {
    //   block [0x82EAC614..0x82EAC61C)
	// 82EAC614: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EAC618: 4BDFCE44  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EAC61C => {
    //   block [0x82EAC61C..0x82EAC624)
	// 82EAC61C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EAC620: 4BFFFFF4  b 0x82eac614
	pc = 0x82EAC614; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAC628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAC628 size=252
    let mut pc: u32 = 0x82EAC628;
    'dispatch: loop {
        match pc {
            0x82EAC628 => {
    //   block [0x82EAC628..0x82EAC6B0)
	// 82EAC628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAC62C: 4BDFCDE1  bl 0x82ca940c
	ctx.lr = 0x82EAC630;
	sub_82CA93D0(ctx, base);
	// 82EAC630: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAC634: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EAC638: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 82EAC63C: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAC640: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC644: 418200D4  beq 0x82eac718
	if ctx.cr[0].eq {
	pc = 0x82EAC718; continue 'dispatch;
	}
	// 82EAC648: 548B003E  slwi r11, r4, 0
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAC64C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAC650: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAC654: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAC658: 419A00C0  beq cr6, 0x82eac718
	if ctx.cr[6].eq {
	pc = 0x82EAC718; continue 'dispatch;
	}
	// 82EAC65C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAC660: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAC664: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EAC668: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 82EAC66C: 392BAFB4  addi r9, r11, -0x504c
	ctx.r[9].s64 = ctx.r[11].s64 + -20556;
	// 82EAC670: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EAC674: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82EAC678: 9121007C  stw r9, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 82EAC67C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EAC680: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EAC684: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAC688: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82EAC68C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAC690: 419A0028  beq cr6, 0x82eac6b8
	if ctx.cr[6].eq {
	pc = 0x82EAC6B8; continue 'dispatch;
	}
	// 82EAC694: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EAC698: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC69C: 41820014  beq 0x82eac6b0
	if ctx.cr[0].eq {
	pc = 0x82EAC6B0; continue 'dispatch;
	}
	// 82EAC6A0: 83EB001C  lwz r31, 0x1c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAC6A4: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC6A8: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82EAC6AC: 4082000C  bne 0x82eac6b8
	if !ctx.cr[0].eq {
	pc = 0x82EAC6B8; continue 'dispatch;
	}
	pc = 0x82EAC6B0; continue 'dispatch;
            }
            0x82EAC6B0 => {
    //   block [0x82EAC6B0..0x82EAC6B8)
	// 82EAC6B0: 83EA000C  lwz r31, 0xc(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC6B4: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	pc = 0x82EAC6B8; continue 'dispatch;
            }
            0x82EAC6B8 => {
    //   block [0x82EAC6B8..0x82EAC704)
	// 82EAC6B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAC6BC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82EAC6C0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EAC6C4: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EAC6C8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EAC6CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EAC6D0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EAC6D4: 4BFFED85  bl 0x82eab458
	ctx.lr = 0x82EAC6D8;
	sub_82EAB458(ctx, base);
	// 82EAC6D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EAC6DC: 419A0028  beq cr6, 0x82eac704
	if ctx.cr[6].eq {
	pc = 0x82EAC704; continue 'dispatch;
	}
	// 82EAC6E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAC6E4: 809E0030  lwz r4, 0x30(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EAC6E8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EAC6EC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82EAC6F0: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EAC6F4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EAC6F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EAC6FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EAC700: 4BFFE7E9  bl 0x82eaaee8
	ctx.lr = 0x82EAC704;
	sub_82EAAEE8(ctx, base);
	pc = 0x82EAC704; continue 'dispatch;
            }
            0x82EAC704 => {
    //   block [0x82EAC704..0x82EAC718)
	// 82EAC704: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EAC708: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EAC70C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EAC710: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82EAC714: 48000008  b 0x82eac71c
	pc = 0x82EAC71C; continue 'dispatch;
            }
            0x82EAC718 => {
    //   block [0x82EAC718..0x82EAC71C)
	// 82EAC718: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EAC71C; continue 'dispatch;
            }
            0x82EAC71C => {
    //   block [0x82EAC71C..0x82EAC724)
	// 82EAC71C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EAC720: 4BDFCD3C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAC728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAC728 size=584
    let mut pc: u32 = 0x82EAC728;
    'dispatch: loop {
        match pc {
            0x82EAC728 => {
    //   block [0x82EAC728..0x82EAC75C)
	// 82EAC728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAC72C: 4BDFCCE1  bl 0x82ca940c
	ctx.lr = 0x82EAC730;
	sub_82CA93D0(ctx, base);
	// 82EAC730: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAC734: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EAC738: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EAC73C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAC740: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC744: 41820034  beq 0x82eac778
	if ctx.cr[0].eq {
	pc = 0x82EAC778; continue 'dispatch;
	}
	// 82EAC748: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EAC74C: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC750: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EAC754: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EAC758: 48000014  b 0x82eac76c
	pc = 0x82EAC76C; continue 'dispatch;
            }
            0x82EAC75C => {
    //   block [0x82EAC75C..0x82EAC76C)
	// 82EAC75C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC760: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAC764: 419A0020  beq cr6, 0x82eac784
	if ctx.cr[6].eq {
	pc = 0x82EAC784; continue 'dispatch;
	}
	// 82EAC768: 83FF001C  lwz r31, 0x1c(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x82EAC76C; continue 'dispatch;
            }
            0x82EAC76C => {
    //   block [0x82EAC76C..0x82EAC778)
	// 82EAC76C: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC770: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82EAC774: 4082FFE8  bne 0x82eac75c
	if !ctx.cr[0].eq {
	pc = 0x82EAC75C; continue 'dispatch;
	}
	pc = 0x82EAC778; continue 'dispatch;
            }
            0x82EAC778 => {
    //   block [0x82EAC778..0x82EAC77C)
	// 82EAC778: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EAC77C; continue 'dispatch;
            }
            0x82EAC77C => {
    //   block [0x82EAC77C..0x82EAC784)
	// 82EAC77C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EAC780: 4BDFCCDC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EAC784 => {
    //   block [0x82EAC784..0x82EAC7A8)
	// 82EAC784: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAC788: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAC78C: 419A0044  beq cr6, 0x82eac7d0
	if ctx.cr[6].eq {
	pc = 0x82EAC7D0; continue 'dispatch;
	}
	// 82EAC790: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAC794: 807E0030  lwz r3, 0x30(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EAC798: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EAC79C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EAC7A0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC7A4: 48000014  b 0x82eac7b8
	pc = 0x82EAC7B8; continue 'dispatch;
            }
            0x82EAC7A8 => {
    //   block [0x82EAC7A8..0x82EAC7B8)
	// 82EAC7A8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC7AC: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82EAC7B0: 419A0018  beq cr6, 0x82eac7c8
	if ctx.cr[6].eq {
	pc = 0x82EAC7C8; continue 'dispatch;
	}
	// 82EAC7B4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	pc = 0x82EAC7B8; continue 'dispatch;
            }
            0x82EAC7B8 => {
    //   block [0x82EAC7B8..0x82EAC7C8)
	// 82EAC7B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC7BC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAC7C0: 4082FFE8  bne 0x82eac7a8
	if !ctx.cr[0].eq {
	pc = 0x82EAC7A8; continue 'dispatch;
	}
	// 82EAC7C4: 4800000C  b 0x82eac7d0
	pc = 0x82EAC7D0; continue 'dispatch;
            }
            0x82EAC7C8 => {
    //   block [0x82EAC7C8..0x82EAC7D0)
	// 82EAC7C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EAC7CC: 4BFFE5A5  bl 0x82eaad70
	ctx.lr = 0x82EAC7D0;
	sub_82EAAD70(ctx, base);
	pc = 0x82EAC7D0; continue 'dispatch;
            }
            0x82EAC7D0 => {
    //   block [0x82EAC7D0..0x82EAC7F0)
	// 82EAC7D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC7D4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAC7D8: 419A0184  beq cr6, 0x82eac95c
	if ctx.cr[6].eq {
	pc = 0x82EAC95C; continue 'dispatch;
	}
	// 82EAC7DC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EAC7E0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC7E4: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAC7E8: 419900AC  bgt cr6, 0x82eac894
	if ctx.cr[6].gt {
	pc = 0x82EAC894; continue 'dispatch;
	}
	// 82EAC7EC: 54C72036  slwi r7, r6, 4
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	pc = 0x82EAC7F0; continue 'dispatch;
            }
            0x82EAC7F0 => {
    //   block [0x82EAC7F0..0x82EAC814)
	// 82EAC7F0: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAC7F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EAC7F8: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82EAC7FC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC800: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EAC804: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC808: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC80C: 41820074  beq 0x82eac880
	if ctx.cr[0].eq {
	pc = 0x82EAC880; continue 'dispatch;
	}
	// 82EAC810: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82EAC814; continue 'dispatch;
            }
            0x82EAC814 => {
    //   block [0x82EAC814..0x82EAC838)
	// 82EAC814: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAC818: 7F05E840  cmplw cr6, r5, r29
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82EAC81C: 419A001C  beq cr6, 0x82eac838
	if ctx.cr[6].eq {
	pc = 0x82EAC838; continue 'dispatch;
	}
	// 82EAC820: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC824: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EAC828: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82EAC82C: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EAC830: 4198FFE4  blt cr6, 0x82eac814
	if ctx.cr[6].lt {
	pc = 0x82EAC814; continue 'dispatch;
	}
	// 82EAC834: 4800004C  b 0x82eac880
	pc = 0x82EAC880; continue 'dispatch;
            }
            0x82EAC838 => {
    //   block [0x82EAC838..0x82EAC848)
	// 82EAC838: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 82EAC83C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EAC840: 40980034  bge cr6, 0x82eac874
	if !ctx.cr[6].lt {
	pc = 0x82EAC874; continue 'dispatch;
	}
	// 82EAC844: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	pc = 0x82EAC848; continue 'dispatch;
            }
            0x82EAC848 => {
    //   block [0x82EAC848..0x82EAC874)
	// 82EAC848: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC84C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EAC850: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82EAC854: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82EAC858: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAC85C: 90AAFFF8  stw r5, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[5].u32 ) };
	// 82EAC860: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC864: 90AAFFFC  stw r5, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[5].u32 ) };
	// 82EAC868: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC86C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAC870: 4198FFD8  blt cr6, 0x82eac848
	if ctx.cr[6].lt {
	pc = 0x82EAC848; continue 'dispatch;
	}
	pc = 0x82EAC874; continue 'dispatch;
            }
            0x82EAC874 => {
    //   block [0x82EAC874..0x82EAC880)
	// 82EAC874: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC878: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82EAC87C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x82EAC880; continue 'dispatch;
            }
            0x82EAC880 => {
    //   block [0x82EAC880..0x82EAC894)
	// 82EAC880: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC884: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EAC888: 38E70010  addi r7, r7, 0x10
	ctx.r[7].s64 = ctx.r[7].s64 + 16;
	// 82EAC88C: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAC890: 4099FF60  ble cr6, 0x82eac7f0
	if !ctx.cr[6].gt {
	pc = 0x82EAC7F0; continue 'dispatch;
	}
	pc = 0x82EAC894; continue 'dispatch;
            }
            0x82EAC894 => {
    //   block [0x82EAC894..0x82EAC8AC)
	// 82EAC894: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAC898: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC89C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC8A0: 418200BC  beq 0x82eac95c
	if ctx.cr[0].eq {
	pc = 0x82EAC95C; continue 'dispatch;
	}
	// 82EAC8A4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC8A8: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EAC8AC; continue 'dispatch;
            }
            0x82EAC8AC => {
    //   block [0x82EAC8AC..0x82EAC8DC)
	// 82EAC8AC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC8B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EAC8B4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EAC8B8: 419A0024  beq cr6, 0x82eac8dc
	if ctx.cr[6].eq {
	pc = 0x82EAC8DC; continue 'dispatch;
	}
	// 82EAC8BC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC8C0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82EAC8C4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EAC8C8: 419A0050  beq cr6, 0x82eac918
	if ctx.cr[6].eq {
	pc = 0x82EAC918; continue 'dispatch;
	}
	// 82EAC8CC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAC8D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC8D4: 4082FFD8  bne 0x82eac8ac
	if !ctx.cr[0].eq {
	pc = 0x82EAC8AC; continue 'dispatch;
	}
	// 82EAC8D8: 48000084  b 0x82eac95c
	pc = 0x82EAC95C; continue 'dispatch;
            }
            0x82EAC8DC => {
    //   block [0x82EAC8DC..0x82EAC918)
	// 82EAC8DC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EAC8E0: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EAC8E4: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EAC8E8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EAC8EC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAC8F0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC8F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EAC8F8: 41820064  beq 0x82eac95c
	if ctx.cr[0].eq {
	pc = 0x82EAC95C; continue 'dispatch;
	}
	// 82EAC8FC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC900: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EAC904: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EAC908: 409A0054  bne cr6, 0x82eac95c
	if !ctx.cr[6].eq {
	pc = 0x82EAC95C; continue 'dispatch;
	}
	// 82EAC90C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC910: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EAC914: 4800003C  b 0x82eac950
	pc = 0x82EAC950; continue 'dispatch;
            }
            0x82EAC918 => {
    //   block [0x82EAC918..0x82EAC950)
	// 82EAC918: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EAC91C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EAC920: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EAC924: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EAC928: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAC92C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAC930: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EAC934: 41820028  beq 0x82eac95c
	if ctx.cr[0].eq {
	pc = 0x82EAC95C; continue 'dispatch;
	}
	// 82EAC938: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC93C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82EAC940: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EAC944: 409A0018  bne cr6, 0x82eac95c
	if !ctx.cr[6].eq {
	pc = 0x82EAC95C; continue 'dispatch;
	}
	// 82EAC948: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAC94C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x82EAC950; continue 'dispatch;
            }
            0x82EAC950 => {
    //   block [0x82EAC950..0x82EAC95C)
	// 82EAC950: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EAC954: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAC958: 4BFFE419  bl 0x82eaad70
	ctx.lr = 0x82EAC95C;
	sub_82EAAD70(ctx, base);
	pc = 0x82EAC95C; continue 'dispatch;
            }
            0x82EAC95C => {
    //   block [0x82EAC95C..0x82EAC970)
	// 82EAC95C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EAC960: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAC964: 4BFFE395  bl 0x82eaacf8
	ctx.lr = 0x82EAC968;
	sub_82EAACF8(ctx, base);
	// 82EAC968: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAC96C: 4BFFFE10  b 0x82eac77c
	pc = 0x82EAC77C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAC970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAC970 size=316
    let mut pc: u32 = 0x82EAC970;
    'dispatch: loop {
        match pc {
            0x82EAC970 => {
    //   block [0x82EAC970..0x82EAC994)
	// 82EAC970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAC974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAC978: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAC97C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAC980: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAC984: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EAC988: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EAC98C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAC990: 48000028  b 0x82eac9b8
	pc = 0x82EAC9B8; continue 'dispatch;
            }
            0x82EAC994 => {
    //   block [0x82EAC994..0x82EAC9B8)
	// 82EAC994: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC998: 9BEA0014  stb r31, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[31].u8 ) };
	// 82EAC99C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC9A0: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAC9A4: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAC9A8: 910A0010  stw r8, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82EAC9AC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC9B0: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EAC9B4: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82EAC9B8; continue 'dispatch;
            }
            0x82EAC9B8 => {
    //   block [0x82EAC9B8..0x82EACA14)
	// 82EAC9B8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAC9BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAC9C0: 409AFFD4  bne cr6, 0x82eac994
	if !ctx.cr[6].eq {
	pc = 0x82EAC994; continue 'dispatch;
	}
	// 82EAC9C4: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82EAC9C8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EAC9CC: 93EB0014  stw r31, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82EAC9D0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EAC9D4: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EAC9D8: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EAC9DC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EAC9E0: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAC9E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EAC9E8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82EAC9EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EAC9F0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82EAC9F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EAC9F8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAC9FC: 4BFFE3ED  bl 0x82eaade8
	ctx.lr = 0x82EACA00;
	sub_82EAADE8(ctx, base);
	// 82EACA00: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EACA04: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACA08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EACA0C: 41820020  beq 0x82eaca2c
	if ctx.cr[0].eq {
	pc = 0x82EACA2C; continue 'dispatch;
	}
	// 82EACA10: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	pc = 0x82EACA14; continue 'dispatch;
            }
            0x82EACA14 => {
    //   block [0x82EACA14..0x82EACA2C)
	// 82EACA14: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EACA18: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EACA1C: 93EB0014  stw r31, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82EACA20: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EACA24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EACA28: 4082FFEC  bne 0x82eaca14
	if !ctx.cr[0].eq {
	pc = 0x82EACA14; continue 'dispatch;
	}
	pc = 0x82EACA2C; continue 'dispatch;
            }
            0x82EACA2C => {
    //   block [0x82EACA2C..0x82EACA34)
	// 82EACA2C: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EACA30: 48000028  b 0x82eaca58
	pc = 0x82EACA58; continue 'dispatch;
            }
            0x82EACA34 => {
    //   block [0x82EACA34..0x82EACA58)
	// 82EACA34: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACA38: 9BEA0014  stb r31, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[31].u8 ) };
	// 82EACA3C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACA40: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EACA44: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EACA48: 910A0010  stw r8, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82EACA4C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACA50: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EACA54: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82EACA58; continue 'dispatch;
            }
            0x82EACA58 => {
    //   block [0x82EACA58..0x82EACA78)
	// 82EACA58: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACA5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EACA60: 409AFFD4  bne cr6, 0x82eaca34
	if !ctx.cr[6].eq {
	pc = 0x82EACA34; continue 'dispatch;
	}
	// 82EACA64: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82EACA68: 93EB0014  stw r31, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82EACA6C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EACA70: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACA74: 48000018  b 0x82eaca8c
	pc = 0x82EACA8C; continue 'dispatch;
            }
            0x82EACA78 => {
    //   block [0x82EACA78..0x82EACA8C)
	// 82EACA78: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EACA7C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EACA80: 93EB0010  stw r31, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82EACA84: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 82EACA88: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x82EACA8C; continue 'dispatch;
            }
            0x82EACA8C => {
    //   block [0x82EACA8C..0x82EACAAC)
	// 82EACA8C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EACA90: 4082FFE8  bne 0x82eaca78
	if !ctx.cr[0].eq {
	pc = 0x82EACA78; continue 'dispatch;
	}
	// 82EACA94: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EACA98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EACA9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EACAA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EACAA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EACAA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EACAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EACAB0 size=420
    let mut pc: u32 = 0x82EACAB0;
    'dispatch: loop {
        match pc {
            0x82EACAB0 => {
    //   block [0x82EACAB0..0x82EACAFC)
	// 82EACAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EACAB4: 4BDFC941  bl 0x82ca93f4
	ctx.lr = 0x82EACAB8;
	sub_82CA93D0(ctx, base);
	// 82EACAB8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EACABC: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82EACAC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EACAC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EACAC8: 3B0BAFB4  addi r24, r11, -0x504c
	ctx.r[24].s64 = ctx.r[11].s64 + -20556;
	// 82EACACC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EACAD0: 83B70004  lwz r29, 4(r23)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACAD4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EACAD8: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 82EACADC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82EACAE0: 4BFFE721  bl 0x82eab200
	ctx.lr = 0x82EACAE4;
	sub_82EAB200(ctx, base);
	// 82EACAE4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EACAE8: 40820014  bne 0x82eacafc
	if !ctx.cr[0].eq {
	pc = 0x82EACAFC; continue 'dispatch;
	}
	// 82EACAEC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EACAF0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EACAF4: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EACAF8: 48000154  b 0x82eacc4c
	pc = 0x82EACC4C; continue 'dispatch;
            }
            0x82EACAFC => {
    //   block [0x82EACAFC..0x82EACB14)
	// 82EACAFC: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 82EACB00: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82EACB04: 409A0010  bne cr6, 0x82eacb14
	if !ctx.cr[6].eq {
	pc = 0x82EACB14; continue 'dispatch;
	}
	// 82EACB08: 839D0008  lwz r28, 8(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACB0C: 3B5FFFFF  addi r26, r31, -1
	ctx.r[26].s64 = ctx.r[31].s64 + -1;
	// 82EACB10: 48000058  b 0x82eacb68
	pc = 0x82EACB68; continue 'dispatch;
            }
            0x82EACB14 => {
    //   block [0x82EACB14..0x82EACB20)
	// 82EACB14: 835D000C  lwz r26, 0xc(r29)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EACB18: 3B9F0001  addi r28, r31, 1
	ctx.r[28].s64 = ctx.r[31].s64 + 1;
	// 82EACB1C: 4800004C  b 0x82eacb68
	pc = 0x82EACB68; continue 'dispatch;
            }
            0x82EACB20 => {
    //   block [0x82EACB20..0x82EACB5C)
	// 82EACB20: 7D7AE214  add r11, r26, r28
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[28].u64;
	// 82EACB24: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 82EACB28: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EACB2C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82EACB30: 557BF87E  srwi r27, r11, 1
	ctx.r[27].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82EACB34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EACB38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EACB3C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82EACB40: 4BFFE729  bl 0x82eab268
	ctx.lr = 0x82EACB44;
	sub_82EAB268(ctx, base);
	// 82EACB44: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EACB48: 41820030  beq 0x82eacb78
	if ctx.cr[0].eq {
	pc = 0x82EACB78; continue 'dispatch;
	}
	// 82EACB4C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82EACB50: 409A000C  bne cr6, 0x82eacb5c
	if !ctx.cr[6].eq {
	pc = 0x82EACB5C; continue 'dispatch;
	}
	// 82EACB54: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 82EACB58: 48000010  b 0x82eacb68
	pc = 0x82EACB68; continue 'dispatch;
            }
            0x82EACB5C => {
    //   block [0x82EACB5C..0x82EACB68)
	// 82EACB5C: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EACB60: 409A0008  bne cr6, 0x82eacb68
	if !ctx.cr[6].eq {
	pc = 0x82EACB68; continue 'dispatch;
	}
	// 82EACB64: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	pc = 0x82EACB68; continue 'dispatch;
            }
            0x82EACB68 => {
    //   block [0x82EACB68..0x82EACB78)
	// 82EACB68: 7D7CD050  subf r11, r28, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[28].s64;
	// 82EACB6C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EACB70: 4199FFB0  bgt cr6, 0x82eacb20
	if ctx.cr[6].gt {
	pc = 0x82EACB20; continue 'dispatch;
	}
	// 82EACB74: 48000010  b 0x82eacb84
	pc = 0x82EACB84; continue 'dispatch;
            }
            0x82EACB78 => {
    //   block [0x82EACB78..0x82EACB84)
	// 82EACB78: 7F79DB78  mr r25, r27
	ctx.r[25].u64 = ctx.r[27].u64;
	// 82EACB7C: 2F1BFFFF  cmpwi cr6, r27, -1
	ctx.cr[6].compare_i32(ctx.r[27].s32, -1, &mut ctx.xer);
	// 82EACB80: 409A0058  bne cr6, 0x82eacbd8
	if !ctx.cr[6].eq {
	pc = 0x82EACBD8; continue 'dispatch;
	}
	pc = 0x82EACB84; continue 'dispatch;
            }
            0x82EACB84 => {
    //   block [0x82EACB84..0x82EACBB0)
	// 82EACB84: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EACB88: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 82EACB8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EACB90: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82EACB94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EACB98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EACB9C: 4BFFE6CD  bl 0x82eab268
	ctx.lr = 0x82EACBA0;
	sub_82EAB268(ctx, base);
	// 82EACBA0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EACBA4: 4082000C  bne 0x82eacbb0
	if !ctx.cr[0].eq {
	pc = 0x82EACBB0; continue 'dispatch;
	}
	// 82EACBA8: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	// 82EACBAC: 4800002C  b 0x82eacbd8
	pc = 0x82EACBD8; continue 'dispatch;
            }
            0x82EACBB0 => {
    //   block [0x82EACBB0..0x82EACBD8)
	// 82EACBB0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82EACBB4: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 82EACBB8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EACBBC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82EACBC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EACBC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EACBC8: 4BFFE6A1  bl 0x82eab268
	ctx.lr = 0x82EACBCC;
	sub_82EAB268(ctx, base);
	// 82EACBCC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EACBD0: 40820008  bne 0x82eacbd8
	if !ctx.cr[0].eq {
	pc = 0x82EACBD8; continue 'dispatch;
	}
	// 82EACBD4: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	pc = 0x82EACBD8; continue 'dispatch;
            }
            0x82EACBD8 => {
    //   block [0x82EACBD8..0x82EACC0C)
	// 82EACBD8: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EACBDC: 57EA2036  slwi r10, r31, 4
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EACBE0: 7F19F840  cmplw cr6, r25, r31
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82EACBE4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EACBE8: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EACBEC: 838B0004  lwz r28, 4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACBF0: 836B000C  lwz r27, 0xc(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EACBF4: 40990018  ble cr6, 0x82eacc0c
	if !ctx.cr[6].gt {
	pc = 0x82EACC0C; continue 'dispatch;
	}
	// 82EACBF8: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EACBFC: 7D3FC850  subf r9, r31, r25
	ctx.r[9].s64 = ctx.r[25].s64 - ctx.r[31].s64;
	// 82EACC00: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EACC04: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 82EACC08: 48000018  b 0x82eacc20
	pc = 0x82EACC20; continue 'dispatch;
            }
            0x82EACC0C => {
    //   block [0x82EACC0C..0x82EACC20)
	// 82EACC0C: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EACC10: 572B2036  slwi r11, r25, 4
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EACC14: 7D39F850  subf r9, r25, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[25].s64;
	// 82EACC18: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EACC1C: 38640010  addi r3, r4, 0x10
	ctx.r[3].s64 = ctx.r[4].s64 + 16;
	pc = 0x82EACC20; continue 'dispatch;
            }
            0x82EACC20 => {
    //   block [0x82EACC20..0x82EACC4C)
	// 82EACC20: 55252036  slwi r5, r9, 4
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82EACC24: 4BE03F0D  bl 0x82cb0b30
	ctx.lr = 0x82EACC28;
	sub_82CB0B30(ctx, base);
	// 82EACC28: 813E001C  lwz r9, 0x1c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EACC2C: 572B2036  slwi r11, r25, 4
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EACC30: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EACC34: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EACC38: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EACC3C: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82EACC40: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EACC44: 936B000C  stw r27, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 82EACC48: 91570000  stw r10, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EACC4C; continue 'dispatch;
            }
            0x82EACC4C => {
    //   block [0x82EACC4C..0x82EACC54)
	// 82EACC4C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EACC50: 4BDFC7F4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EACC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EACC58 size=292
    let mut pc: u32 = 0x82EACC58;
    'dispatch: loop {
        match pc {
            0x82EACC58 => {
    //   block [0x82EACC58..0x82EACC94)
	// 82EACC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EACC5C: 4BDFC7B1  bl 0x82ca940c
	ctx.lr = 0x82EACC60;
	sub_82CA93D0(ctx, base);
	// 82EACC60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EACC64: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EACC68: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EACC6C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EACC70: 390BAFB4  addi r8, r11, -0x504c
	ctx.r[8].s64 = ctx.r[11].s64 + -20556;
	// 82EACC74: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EACC78: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 82EACC7C: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACC80: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EACC84: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82EACC88: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82EACC8C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EACC90: 418200D4  beq 0x82eacd64
	if ctx.cr[0].eq {
	pc = 0x82EACD64; continue 'dispatch;
	}
	pc = 0x82EACC94; continue 'dispatch;
            }
            0x82EACC94 => {
    //   block [0x82EACC94..0x82EACCB0)
	// 82EACC94: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACC98: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACC9C: 7D274850  subf r9, r7, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82EACCA0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EACCA4: 4098000C  bge cr6, 0x82eaccb0
	if !ctx.cr[6].lt {
	pc = 0x82EACCB0; continue 'dispatch;
	}
	// 82EACCA8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82EACCAC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x82EACCB0; continue 'dispatch;
            }
            0x82EACCB0 => {
    //   block [0x82EACCB0..0x82EACD1C)
	// 82EACCB0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EACCB4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EACCB8: 4082FFDC  bne 0x82eacc94
	if !ctx.cr[0].eq {
	pc = 0x82EACC94; continue 'dispatch;
	}
	// 82EACCBC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82EACCC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EACCC4: 419A00A0  beq cr6, 0x82eacd64
	if ctx.cr[6].eq {
	pc = 0x82EACD64; continue 'dispatch;
	}
	// 82EACCC8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACCCC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACCD0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACCD4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EACCD8: 557EF87E  srwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82EACCDC: 93C9000C  stw r30, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EACCE0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACCE4: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EACCE8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACCEC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACCF0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACCF4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EACCF8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EACCFC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACD00: 409A0028  bne cr6, 0x82eacd28
	if !ctx.cr[6].eq {
	pc = 0x82EACD28; continue 'dispatch;
	}
	// 82EACD04: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EACD08: 409A0014  bne cr6, 0x82eacd1c
	if !ctx.cr[6].eq {
	pc = 0x82EACD1C; continue 'dispatch;
	}
	// 82EACD0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EACD10: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EACD14: 4BFFE05D  bl 0x82eaad70
	ctx.lr = 0x82EACD18;
	sub_82EAAD70(ctx, base);
	// 82EACD18: 4800004C  b 0x82eacd64
	pc = 0x82EACD64; continue 'dispatch;
            }
            0x82EACD1C => {
    //   block [0x82EACD1C..0x82EACD28)
	// 82EACD1C: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82EACD20: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EACD24: 48000040  b 0x82eacd64
	pc = 0x82EACD64; continue 'dispatch;
            }
            0x82EACD28 => {
    //   block [0x82EACD28..0x82EACD5C)
	// 82EACD28: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EACD2C: 419A0030  beq cr6, 0x82eacd5c
	if ctx.cr[6].eq {
	pc = 0x82EACD5C; continue 'dispatch;
	}
	// 82EACD30: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EACD34: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EACD38: 80830018  lwz r4, 0x18(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EACD3C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EACD40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EACD44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EACD48: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82EACD4C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EACD50: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82EACD54: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EACD58: 4BFFE091  bl 0x82eaade8
	ctx.lr = 0x82EACD5C;
	sub_82EAADE8(ctx, base);
	pc = 0x82EACD5C; continue 'dispatch;
            }
            0x82EACD5C => {
    //   block [0x82EACD5C..0x82EACD64)
	// 82EACD5C: 397EFFFF  addi r11, r30, -1
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	// 82EACD60: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EACD64; continue 'dispatch;
            }
            0x82EACD64 => {
    //   block [0x82EACD64..0x82EACD7C)
	// 82EACD64: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EACD68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EACD6C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EACD70: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EACD74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EACD78: 4BDFC6E4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EACD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EACD80 size=1060
    let mut pc: u32 = 0x82EACD80;
    'dispatch: loop {
        match pc {
            0x82EACD80 => {
    //   block [0x82EACD80..0x82EACDD4)
	// 82EACD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EACD84: 4BDFC679  bl 0x82ca93fc
	ctx.lr = 0x82EACD88;
	sub_82CA93D0(ctx, base);
	// 82EACD88: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EACD8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EACD90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EACD94: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EACD98: 3B4BAFB4  addi r26, r11, -0x504c
	ctx.r[26].s64 = ctx.r[11].s64 + -20556;
	// 82EACD9C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EACDA0: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EACDA4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82EACDA8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EACDAC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82EACDB0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EACDB4: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82EACDB8: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82EACDBC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACDC0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82EACDC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EACDC8: 41820078  beq 0x82eace40
	if ctx.cr[0].eq {
	pc = 0x82EACE40; continue 'dispatch;
	}
	// 82EACDCC: 80D90004  lwz r6, 4(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACDD0: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82EACDD4; continue 'dispatch;
            }
            0x82EACDD4 => {
    //   block [0x82EACDD4..0x82EACDF8)
	// 82EACDD4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACDD8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACDDC: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EACDE0: 40980018  bge cr6, 0x82eacdf8
	if !ctx.cr[6].lt {
	pc = 0x82EACDF8; continue 'dispatch;
	}
	// 82EACDE4: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82EACDE8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82EACDEC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82EACDF0: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 82EACDF4: 48000028  b 0x82eace1c
	pc = 0x82EACE1C; continue 'dispatch;
            }
            0x82EACDF8 => {
    //   block [0x82EACDF8..0x82EACE10)
	// 82EACDF8: 8086000C  lwz r4, 0xc(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EACDFC: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82EACE00: 4099001C  ble cr6, 0x82eace1c
	if !ctx.cr[6].gt {
	pc = 0x82EACE1C; continue 'dispatch;
	}
	// 82EACE04: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EACE08: 409A0008  bne cr6, 0x82eace10
	if !ctx.cr[6].eq {
	pc = 0x82EACE10; continue 'dispatch;
	}
	// 82EACE0C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	pc = 0x82EACE10; continue 'dispatch;
            }
            0x82EACE10 => {
    //   block [0x82EACE10..0x82EACE1C)
	// 82EACE10: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82EACE14: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82EACE18: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	pc = 0x82EACE1C; continue 'dispatch;
            }
            0x82EACE1C => {
    //   block [0x82EACE1C..0x82EACE40)
	// 82EACE1C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EACE20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EACE24: 4082FFB0  bne 0x82eacdd4
	if !ctx.cr[0].eq {
	pc = 0x82EACDD4; continue 'dispatch;
	}
	// 82EACE28: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82EACE2C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EACE30: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82EACE34: 409A0024  bne cr6, 0x82eace58
	if !ctx.cr[6].eq {
	pc = 0x82EACE58; continue 'dispatch;
	}
	// 82EACE38: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EACE3C: 409A001C  bne cr6, 0x82eace58
	if !ctx.cr[6].eq {
	pc = 0x82EACE58; continue 'dispatch;
	}
	pc = 0x82EACE40; continue 'dispatch;
            }
            0x82EACE40 => {
    //   block [0x82EACE40..0x82EACE44)
	// 82EACE40: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82EACE44; continue 'dispatch;
            }
            0x82EACE44 => {
    //   block [0x82EACE44..0x82EACE58)
	// 82EACE44: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EACE48: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EACE4C: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EACE50: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EACE54: 4BDFC5F8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EACE58 => {
    //   block [0x82EACE58..0x82EACE90)
	// 82EACE58: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EACE5C: 419A005C  beq cr6, 0x82eaceb8
	if ctx.cr[6].eq {
	pc = 0x82EACEB8; continue 'dispatch;
	}
	// 82EACE60: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EACE64: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACE68: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EACE6C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EACE70: 409A0048  bne cr6, 0x82eaceb8
	if !ctx.cr[6].eq {
	pc = 0x82EACEB8; continue 'dispatch;
	}
	// 82EACE74: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EACE78: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACE7C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EACE80: 409A0010  bne cr6, 0x82eace90
	if !ctx.cr[6].eq {
	pc = 0x82EACE90; continue 'dispatch;
	}
	// 82EACE84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EACE88: 4BFFDEE9  bl 0x82eaad70
	ctx.lr = 0x82EACE8C;
	sub_82EAAD70(ctx, base);
	// 82EACE8C: 48000010  b 0x82eace9c
	pc = 0x82EACE9C; continue 'dispatch;
            }
            0x82EACE90 => {
    //   block [0x82EACE90..0x82EACE9C)
	// 82EACE90: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACE94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EACE98: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82EACE9C; continue 'dispatch;
            }
            0x82EACE9C => {
    //   block [0x82EACE9C..0x82EACEB8)
	// 82EACE9C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACEA0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EACEA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EACEA8: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EACEAC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACEB0: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EACEB4: 4BFFFF90  b 0x82eace44
	pc = 0x82EACE44; continue 'dispatch;
            }
            0x82EACEB8 => {
    //   block [0x82EACEB8..0x82EACEEC)
	// 82EACEB8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EACEBC: 419A0058  beq cr6, 0x82eacf14
	if ctx.cr[6].eq {
	pc = 0x82EACF14; continue 'dispatch;
	}
	// 82EACEC0: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACEC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EACEC8: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EACECC: 409A0048  bne cr6, 0x82eacf14
	if !ctx.cr[6].eq {
	pc = 0x82EACF14; continue 'dispatch;
	}
	// 82EACED0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACED4: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACED8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EACEDC: 409A0010  bne cr6, 0x82eaceec
	if !ctx.cr[6].eq {
	pc = 0x82EACEEC; continue 'dispatch;
	}
	// 82EACEE0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EACEE4: 4BFFDE8D  bl 0x82eaad70
	ctx.lr = 0x82EACEE8;
	sub_82EAAD70(ctx, base);
	// 82EACEE8: 48000010  b 0x82eacef8
	pc = 0x82EACEF8; continue 'dispatch;
            }
            0x82EACEEC => {
    //   block [0x82EACEEC..0x82EACEF8)
	// 82EACEEC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACEF0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EACEF4: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EACEF8; continue 'dispatch;
            }
            0x82EACEF8 => {
    //   block [0x82EACEF8..0x82EACF14)
	// 82EACEF8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACEFC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACF00: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82EACF04: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EACF08: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACF0C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACF10: 4BFFFF34  b 0x82eace44
	pc = 0x82EACE44; continue 'dispatch;
            }
            0x82EACF14 => {
    //   block [0x82EACF14..0x82EACF4C)
	// 82EACF14: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EACF18: 40990178  ble cr6, 0x82ead090
	if !ctx.cr[6].gt {
	pc = 0x82EAD090; continue 'dispatch;
	}
	// 82EACF1C: 83BC0004  lwz r29, 4(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACF20: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACF24: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 82EACF28: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 82EACF2C: 2B1E0002  cmplwi cr6, r30, 2
	ctx.cr[6].compare_u32(ctx.r[30].u32, 2 as u32, &mut ctx.xer);
	// 82EACF30: 4098001C  bge cr6, 0x82eacf4c
	if !ctx.cr[6].lt {
	pc = 0x82EACF4C; continue 'dispatch;
	}
	// 82EACF34: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EACF38: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82EACF3C: 839C0010  lwz r28, 0x10(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EACF40: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82EACF44: 4BFFDE2D  bl 0x82eaad70
	ctx.lr = 0x82EACF48;
	sub_82EAAD70(ctx, base);
	// 82EACF48: 48000014  b 0x82eacf5c
	pc = 0x82EACF5C; continue 'dispatch;
            }
            0x82EACF4C => {
    //   block [0x82EACF4C..0x82EACF5C)
	// 82EACF4C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACF50: 57DEF87E  srwi r30, r30, 1
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shr(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82EACF54: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EACF58: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82EACF5C; continue 'dispatch;
            }
            0x82EACF5C => {
    //   block [0x82EACF5C..0x82EACF74)
	// 82EACF5C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EACF60: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 82EACF64: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EACF68: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EACF6C: 354A0001  addic. r10, r10, 1
	ctx.xer.ca = (ctx.r[10].u32 > (!(1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EACF70: 4182009C  beq 0x82ead00c
	if ctx.cr[0].eq {
	pc = 0x82EAD00C; continue 'dispatch;
	}
	pc = 0x82EACF74; continue 'dispatch;
            }
            0x82EACF74 => {
    //   block [0x82EACF74..0x82EACF7C)
	// 82EACF74: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACF78: 48000014  b 0x82eacf8c
	pc = 0x82EACF8C; continue 'dispatch;
            }
            0x82EACF7C => {
    //   block [0x82EACF7C..0x82EACF8C)
	// 82EACF7C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EACF80: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EACF84: 419A0014  beq cr6, 0x82eacf98
	if ctx.cr[6].eq {
	pc = 0x82EACF98; continue 'dispatch;
	}
	// 82EACF88: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x82EACF8C; continue 'dispatch;
            }
            0x82EACF8C => {
    //   block [0x82EACF8C..0x82EACF98)
	// 82EACF8C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EACF90: 4082FFEC  bne 0x82eacf7c
	if !ctx.cr[0].eq {
	pc = 0x82EACF7C; continue 'dispatch;
	}
	// 82EACF94: 48000060  b 0x82eacff4
	pc = 0x82EACFF4; continue 'dispatch;
            }
            0x82EACF98 => {
    //   block [0x82EACF98..0x82EACFF4)
	// 82EACF98: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EACF9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EACFA0: 419A0098  beq cr6, 0x82ead038
	if ctx.cr[6].eq {
	pc = 0x82EAD038; continue 'dispatch;
	}
	// 82EACFA4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACFA8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82EACFAC: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82EACFB0: 3BAAFFFF  addi r29, r10, -1
	ctx.r[29].s64 = ctx.r[10].s64 + -1;
	// 82EACFB4: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EACFB8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EACFBC: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82EACFC0: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EACFC4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EACFC8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EACFCC: 7D1E5050  subf r8, r30, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 82EACFD0: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EACFD4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EACFD8: 55082036  slwi r8, r8, 4
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EACFDC: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 82EACFE0: 554B2036  slwi r11, r10, 4
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EACFE4: 54E52036  slwi r5, r7, 4
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82EACFE8: 7C884A14  add r4, r8, r9
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82EACFEC: 7C6B4A14  add r3, r11, r9
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EACFF0: 4BE03B41  bl 0x82cb0b30
	ctx.lr = 0x82EACFF4;
	sub_82CB0B30(ctx, base);
	pc = 0x82EACFF4; continue 'dispatch;
            }
            0x82EACFF4 => {
    //   block [0x82EACFF4..0x82EAD00C)
	// 82EACFF4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EACFF8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EACFFC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAD000: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EAD004: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAD008: 4198FF6C  blt cr6, 0x82eacf74
	if ctx.cr[6].lt {
	pc = 0x82EACF74; continue 'dispatch;
	}
	pc = 0x82EAD00C; continue 'dispatch;
            }
            0x82EAD00C => {
    //   block [0x82EAD00C..0x82EAD038)
	// 82EAD00C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD010: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAD014: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EAD018: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAD01C: 409AFE24  bne cr6, 0x82eace40
	if !ctx.cr[6].eq {
	pc = 0x82EACE40; continue 'dispatch;
	}
	// 82EAD020: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAD024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAD028: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EAD02C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAD030: 4E800421  bctrl
	ctx.lr = 0x82EAD034;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAD034: 4BFFFE0C  b 0x82eace40
	pc = 0x82EACE40; continue 'dispatch;
            }
            0x82EAD038 => {
    //   block [0x82EAD038..0x82EAD054)
	// 82EAD038: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD03C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82EAD040: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EAD044: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAD048: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EAD04C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EAD050: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	pc = 0x82EAD054; continue 'dispatch;
            }
            0x82EAD054 => {
    //   block [0x82EAD054..0x82EAD090)
	// 82EAD054: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EAD058: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAD05C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EAD060: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82EAD064: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EAD068: 4BFFDD81  bl 0x82eaade8
	ctx.lr = 0x82EAD06C;
	sub_82EAADE8(ctx, base);
	// 82EAD06C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAD070: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD074: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EAD078: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EAD07C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAD080: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82EAD084: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAD088: 4BFFFCF9  bl 0x82eacd80
	ctx.lr = 0x82EAD08C;
	sub_82EACD80(ctx, base);
	// 82EAD08C: 4BFFFDB8  b 0x82eace44
	pc = 0x82EACE44; continue 'dispatch;
            }
            0x82EAD090 => {
    //   block [0x82EAD090..0x82EAD0C0)
	// 82EAD090: 839D0008  lwz r28, 8(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD094: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD098: 7D6BE050  subf r11, r11, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 82EAD09C: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 82EAD0A0: 2B1E0002  cmplwi cr6, r30, 2
	ctx.cr[6].compare_u32(ctx.r[30].u32, 2 as u32, &mut ctx.xer);
	// 82EAD0A4: 4098001C  bge cr6, 0x82ead0c0
	if !ctx.cr[6].lt {
	pc = 0x82EAD0C0; continue 'dispatch;
	}
	// 82EAD0A8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EAD0AC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82EAD0B0: 83BD0010  lwz r29, 0x10(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD0B4: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82EAD0B8: 4BFFDCB9  bl 0x82eaad70
	ctx.lr = 0x82EAD0BC;
	sub_82EAAD70(ctx, base);
	// 82EAD0BC: 48000014  b 0x82ead0d0
	pc = 0x82EAD0D0; continue 'dispatch;
            }
            0x82EAD0C0 => {
    //   block [0x82EAD0C0..0x82EAD0D0)
	// 82EAD0C0: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD0C4: 57DEF87E  srwi r30, r30, 1
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shr(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82EAD0C8: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82EAD0CC: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EAD0D0; continue 'dispatch;
            }
            0x82EAD0D0 => {
    //   block [0x82EAD0D0..0x82EAD0E8)
	// 82EAD0D0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD0D4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EAD0D8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EAD0DC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAD0E0: 354A0001  addic. r10, r10, 1
	ctx.xer.ca = (ctx.r[10].u32 > (!(1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAD0E4: 4182FF28  beq 0x82ead00c
	if ctx.cr[0].eq {
	pc = 0x82EAD00C; continue 'dispatch;
	}
	pc = 0x82EAD0E8; continue 'dispatch;
            }
            0x82EAD0E8 => {
    //   block [0x82EAD0E8..0x82EAD0F0)
	// 82EAD0E8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD0EC: 48000014  b 0x82ead100
	pc = 0x82EAD100; continue 'dispatch;
            }
            0x82EAD0F0 => {
    //   block [0x82EAD0F0..0x82EAD100)
	// 82EAD0F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD0F4: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAD0F8: 419A0014  beq cr6, 0x82ead10c
	if ctx.cr[6].eq {
	pc = 0x82EAD10C; continue 'dispatch;
	}
	// 82EAD0FC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x82EAD100; continue 'dispatch;
            }
            0x82EAD100 => {
    //   block [0x82EAD100..0x82EAD10C)
	// 82EAD100: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD104: 4082FFEC  bne 0x82ead0f0
	if !ctx.cr[0].eq {
	pc = 0x82EAD0F0; continue 'dispatch;
	}
	// 82EAD108: 48000060  b 0x82ead168
	pc = 0x82EAD168; continue 'dispatch;
            }
            0x82EAD10C => {
    //   block [0x82EAD10C..0x82EAD168)
	// 82EAD10C: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD110: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAD114: 419A0070  beq cr6, 0x82ead184
	if ctx.cr[6].eq {
	pc = 0x82EAD184; continue 'dispatch;
	}
	// 82EAD118: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD11C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD120: 7D3E4850  subf r9, r30, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[30].s64;
	// 82EAD124: 3B8A0001  addi r28, r10, 1
	ctx.r[28].s64 = ctx.r[10].s64 + 1;
	// 82EAD128: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EAD12C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD130: 7D5E5050  subf r10, r30, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 82EAD134: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EAD138: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD13C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD140: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82EAD144: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAD148: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EAD14C: 55082036  slwi r8, r8, 4
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EAD150: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 82EAD154: 554B2036  slwi r11, r10, 4
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAD158: 54E52036  slwi r5, r7, 4
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82EAD15C: 7C884A14  add r4, r8, r9
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82EAD160: 7C6B4A14  add r3, r11, r9
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EAD164: 4BE039CD  bl 0x82cb0b30
	ctx.lr = 0x82EAD168;
	sub_82CB0B30(ctx, base);
	pc = 0x82EAD168; continue 'dispatch;
            }
            0x82EAD168 => {
    //   block [0x82EAD168..0x82EAD184)
	// 82EAD168: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD16C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EAD170: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAD174: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EAD178: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAD17C: 4198FF6C  blt cr6, 0x82ead0e8
	if ctx.cr[6].lt {
	pc = 0x82EAD0E8; continue 'dispatch;
	}
	// 82EAD180: 4BFFFE8C  b 0x82ead00c
	pc = 0x82EAD00C; continue 'dispatch;
            }
            0x82EAD184 => {
    //   block [0x82EAD184..0x82EAD1A4)
	// 82EAD184: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD188: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82EAD18C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EAD190: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAD194: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82EAD198: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EAD19C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAD1A0: 4BFFFEB4  b 0x82ead054
	pc = 0x82EAD054; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAD1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAD1A8 size=268
    let mut pc: u32 = 0x82EAD1A8;
    'dispatch: loop {
        match pc {
            0x82EAD1A8 => {
    //   block [0x82EAD1A8..0x82EAD1E8)
	// 82EAD1A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAD1AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAD1B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAD1B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAD1B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAD1BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAD1C0: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82EAD1C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAD1C8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EAD1CC: 392BAFB4  addi r9, r11, -0x504c
	ctx.r[9].s64 = ctx.r[11].s64 + -20556;
	// 82EAD1D0: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAD1D4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82EAD1D8: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD1DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD1E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAD1E4: 41820048  beq 0x82ead22c
	if ctx.cr[0].eq {
	pc = 0x82EAD22C; continue 'dispatch;
	}
	pc = 0x82EAD1E8; continue 'dispatch;
            }
            0x82EAD1E8 => {
    //   block [0x82EAD1E8..0x82EAD204)
	// 82EAD1E8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD1EC: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAD1F0: 41990014  bgt cr6, 0x82ead204
	if ctx.cr[6].gt {
	pc = 0x82EAD204; continue 'dispatch;
	}
	// 82EAD1F4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD1F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD1FC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAD200: 4082FFE8  bne 0x82ead1e8
	if !ctx.cr[0].eq {
	pc = 0x82EAD1E8; continue 'dispatch;
	}
	pc = 0x82EAD204; continue 'dispatch;
            }
            0x82EAD204 => {
    //   block [0x82EAD204..0x82EAD22C)
	// 82EAD204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAD208: 419A0024  beq cr6, 0x82ead22c
	if ctx.cr[6].eq {
	pc = 0x82EAD22C; continue 'dispatch;
	}
	// 82EAD20C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD210: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82EAD214: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EAD218: 409A0014  bne cr6, 0x82ead22c
	if !ctx.cr[6].eq {
	pc = 0x82EAD22C; continue 'dispatch;
	}
	// 82EAD21C: 550A003E  slwi r10, r8, 0
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EAD220: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82EAD224: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EAD228: 48000038  b 0x82ead260
	pc = 0x82EAD260; continue 'dispatch;
            }
            0x82EAD22C => {
    //   block [0x82EAD22C..0x82EAD260)
	// 82EAD22C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EAD230: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82EAD234: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EAD238: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EAD23C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EAD240: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82EAD244: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EAD248: 4BFFDBA1  bl 0x82eaade8
	ctx.lr = 0x82EAD24C;
	sub_82EAADE8(ctx, base);
	// 82EAD24C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EAD250: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82EAD254: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD258: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAD25C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	pc = 0x82EAD260; continue 'dispatch;
            }
            0x82EAD260 => {
    //   block [0x82EAD260..0x82EAD29C)
	// 82EAD260: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD264: 57C9063F  clrlwi. r9, r30, 0x18
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EAD268: 41820034  beq 0x82ead29c
	if ctx.cr[0].eq {
	pc = 0x82EAD29C; continue 'dispatch;
	}
	// 82EAD26C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAD270: 419A002C  beq cr6, 0x82ead29c
	if ctx.cr[6].eq {
	pc = 0x82EAD29C; continue 'dispatch;
	}
	// 82EAD274: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD278: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD27C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EAD280: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EAD284: 409A0018  bne cr6, 0x82ead29c
	if !ctx.cr[6].eq {
	pc = 0x82EAD29C; continue 'dispatch;
	}
	// 82EAD288: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD28C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EAD290: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EAD294: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAD298: 4BFFDAD9  bl 0x82eaad70
	ctx.lr = 0x82EAD29C;
	sub_82EAAD70(ctx, base);
	pc = 0x82EAD29C; continue 'dispatch;
            }
            0x82EAD29C => {
    //   block [0x82EAD29C..0x82EAD2B4)
	// 82EAD29C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EAD2A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAD2A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAD2A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAD2AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAD2B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAD2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAD2B8 size=180
    let mut pc: u32 = 0x82EAD2B8;
    'dispatch: loop {
        match pc {
            0x82EAD2B8 => {
    //   block [0x82EAD2B8..0x82EAD2F0)
	// 82EAD2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAD2BC: 4BDFC141  bl 0x82ca93fc
	ctx.lr = 0x82EAD2C0;
	sub_82CA93D0(ctx, base);
	// 82EAD2C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAD2C4: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAD2C8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EAD2CC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82EAD2D0: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82EAD2D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD2D8: 4182008C  beq 0x82ead364
	if ctx.cr[0].eq {
	pc = 0x82EAD364; continue 'dispatch;
	}
	// 82EAD2DC: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD2E0: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD2E4: 41820080  beq 0x82ead364
	if ctx.cr[0].eq {
	pc = 0x82EAD364; continue 'dispatch;
	}
	// 82EAD2E8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAD2EC: 3B8BDAC0  addi r28, r11, -0x2540
	ctx.r[28].s64 = ctx.r[11].s64 + -9536;
	pc = 0x82EAD2F0; continue 'dispatch;
            }
            0x82EAD2F0 => {
    //   block [0x82EAD2F0..0x82EAD314)
	// 82EAD2F0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD2F4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD2F8: 41820060  beq 0x82ead358
	if ctx.cr[0].eq {
	pc = 0x82EAD358; continue 'dispatch;
	}
	// 82EAD2FC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD300: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82EAD304: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82EAD308: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EAD30C: 4099004C  ble cr6, 0x82ead358
	if !ctx.cr[6].gt {
	pc = 0x82EAD358; continue 'dispatch;
	}
	// 82EAD310: 3BE0000C  li r31, 0xc
	ctx.r[31].s64 = 12;
	pc = 0x82EAD314; continue 'dispatch;
            }
            0x82EAD314 => {
    //   block [0x82EAD314..0x82EAD33C)
	// 82EAD314: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EAD318: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAD31C: 419A0020  beq cr6, 0x82ead33c
	if ctx.cr[6].eq {
	pc = 0x82EAD33C; continue 'dispatch;
	}
	// 82EAD320: 7C9F5A14  add r4, r31, r11
	ctx.r[4].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82EAD324: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82EAD328: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82EAD32C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EAD330: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAD334: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAD338: 4E800421  bctrl
	ctx.lr = 0x82EAD33C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAD33C => {
    //   block [0x82EAD33C..0x82EAD358)
	// 82EAD33C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD340: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EAD344: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD348: 7C7F5A14  add r3, r31, r11
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82EAD34C: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82EAD350: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAD354: 4198FFC0  blt cr6, 0x82ead314
	if ctx.cr[6].lt {
	pc = 0x82EAD314; continue 'dispatch;
	}
	pc = 0x82EAD358; continue 'dispatch;
            }
            0x82EAD358 => {
    //   block [0x82EAD358..0x82EAD364)
	// 82EAD358: 83DE0020  lwz r30, 0x20(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EAD35C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD360: 4082FF90  bne 0x82ead2f0
	if !ctx.cr[0].eq {
	pc = 0x82EAD2F0; continue 'dispatch;
	}
	pc = 0x82EAD364; continue 'dispatch;
            }
            0x82EAD364 => {
    //   block [0x82EAD364..0x82EAD36C)
	// 82EAD364: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EAD368: 4BDFC0E4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAD370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAD370 size=364
    let mut pc: u32 = 0x82EAD370;
    'dispatch: loop {
        match pc {
            0x82EAD370 => {
    //   block [0x82EAD370..0x82EAD3B0)
	// 82EAD370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAD374: 4BDFC071  bl 0x82ca93e4
	ctx.lr = 0x82EAD378;
	sub_82CA93D0(ctx, base);
	// 82EAD378: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAD37C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EAD380: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 82EAD384: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82EAD388: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 82EAD38C: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
	// 82EAD390: 817A0014  lwz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAD394: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD398: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD39C: 41820138  beq 0x82ead4d4
	if ctx.cr[0].eq {
	pc = 0x82EAD4D4; continue 'dispatch;
	}
	// 82EAD3A0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAD3A4: 3B2BDAC0  addi r25, r11, -0x2540
	ctx.r[25].s64 = ctx.r[11].s64 + -9536;
	// 82EAD3A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAD3AC: 3AEBAFB4  addi r23, r11, -0x504c
	ctx.r[23].s64 = ctx.r[11].s64 + -20556;
	pc = 0x82EAD3B0; continue 'dispatch;
            }
            0x82EAD3B0 => {
    //   block [0x82EAD3B0..0x82EAD3C4)
	// 82EAD3B0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD3B4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EAD3B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAD3BC: 4099010C  ble cr6, 0x82ead4c8
	if !ctx.cr[6].gt {
	pc = 0x82EAD4C8; continue 'dispatch;
	}
	// 82EAD3C0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x82EAD3C4; continue 'dispatch;
            }
            0x82EAD3C4 => {
    //   block [0x82EAD3C4..0x82EAD3DC)
	// 82EAD3C4: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 82EAD3C8: 419A0014  beq cr6, 0x82ead3dc
	if ctx.cr[6].eq {
	pc = 0x82EAD3DC; continue 'dispatch;
	}
	// 82EAD3CC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD3D0: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EAD3D4: 7F135840  cmplw cr6, r19, r11
	ctx.cr[6].compare_u32(ctx.r[19].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAD3D8: 409A00DC  bne cr6, 0x82ead4b4
	if !ctx.cr[6].eq {
	pc = 0x82EAD4B4; continue 'dispatch;
	}
	pc = 0x82EAD3DC; continue 'dispatch;
            }
            0x82EAD3DC => {
    //   block [0x82EAD3DC..0x82EAD3E8)
	// 82EAD3DC: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD3E0: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD3E4: 480000C8  b 0x82ead4ac
	pc = 0x82EAD4AC; continue 'dispatch;
            }
            0x82EAD3E8 => {
    //   block [0x82EAD3E8..0x82EAD41C)
	// 82EAD3E8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD3EC: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD3F0: 7D7B5A14  add r11, r27, r11
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 82EAD3F4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAD3F8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EAD3FC: 409A00AC  bne cr6, 0x82ead4a8
	if !ctx.cr[6].eq {
	pc = 0x82EAD4A8; continue 'dispatch;
	}
	// 82EAD400: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAD404: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD408: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EAD40C: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82EAD410: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82EAD414: 4BFFEC65  bl 0x82eac078
	ctx.lr = 0x82EAD418;
	sub_82EAC078(ctx, base);
	// 82EAD418: 48000024  b 0x82ead43c
	pc = 0x82EAD43C; continue 'dispatch;
            }
            0x82EAD41C => {
    //   block [0x82EAD41C..0x82EAD434)
	// 82EAD41C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD420: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82EAD424: 409A0010  bne cr6, 0x82ead434
	if !ctx.cr[6].eq {
	pc = 0x82EAD434; continue 'dispatch;
	}
	// 82EAD428: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD42C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAD430: 409A0018  bne cr6, 0x82ead448
	if !ctx.cr[6].eq {
	pc = 0x82EAD448; continue 'dispatch;
	}
	pc = 0x82EAD434; continue 'dispatch;
            }
            0x82EAD434 => {
    //   block [0x82EAD434..0x82EAD43C)
	// 82EAD434: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EAD438: 4BFFDD09  bl 0x82eab140
	ctx.lr = 0x82EAD43C;
	sub_82EAB140(ctx, base);
	pc = 0x82EAD43C; continue 'dispatch;
            }
            0x82EAD43C => {
    //   block [0x82EAD43C..0x82EAD448)
	// 82EAD43C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD440: 4082FFDC  bne 0x82ead41c
	if !ctx.cr[0].eq {
	pc = 0x82EAD41C; continue 'dispatch;
	}
	// 82EAD444: 48000064  b 0x82ead4a8
	pc = 0x82EAD4A8; continue 'dispatch;
            }
            0x82EAD448 => {
    //   block [0x82EAD448..0x82EAD464)
	// 82EAD448: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD44C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82EAD450: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD454: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EAD458: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82EAD45C: 4099004C  ble cr6, 0x82ead4a8
	if !ctx.cr[6].gt {
	pc = 0x82EAD4A8; continue 'dispatch;
	}
	// 82EAD460: 3BC0000C  li r30, 0xc
	ctx.r[30].s64 = 12;
	pc = 0x82EAD464; continue 'dispatch;
            }
            0x82EAD464 => {
    //   block [0x82EAD464..0x82EAD48C)
	// 82EAD464: 81590048  lwz r10, 0x48(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EAD468: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAD46C: 419A0020  beq cr6, 0x82ead48c
	if ctx.cr[6].eq {
	pc = 0x82EAD48C; continue 'dispatch;
	}
	// 82EAD470: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EAD474: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 82EAD478: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 82EAD47C: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82EAD480: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAD484: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAD488: 4E800421  bctrl
	ctx.lr = 0x82EAD48C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAD48C => {
    //   block [0x82EAD48C..0x82EAD4A8)
	// 82EAD48C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD490: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EAD494: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD498: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EAD49C: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82EAD4A0: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAD4A4: 4198FFC0  blt cr6, 0x82ead464
	if ctx.cr[6].lt {
	pc = 0x82EAD464; continue 'dispatch;
	}
	pc = 0x82EAD4A8; continue 'dispatch;
            }
            0x82EAD4A8 => {
    //   block [0x82EAD4A8..0x82EAD4AC)
	// 82EAD4A8: 839C001C  lwz r28, 0x1c(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x82EAD4AC; continue 'dispatch;
            }
            0x82EAD4AC => {
    //   block [0x82EAD4AC..0x82EAD4B4)
	// 82EAD4AC: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD4B0: 4082FF38  bne 0x82ead3e8
	if !ctx.cr[0].eq {
	pc = 0x82EAD3E8; continue 'dispatch;
	}
	pc = 0x82EAD4B4; continue 'dispatch;
            }
            0x82EAD4B4 => {
    //   block [0x82EAD4B4..0x82EAD4C8)
	// 82EAD4B4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD4B8: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82EAD4BC: 3B7B0008  addi r27, r27, 8
	ctx.r[27].s64 = ctx.r[27].s64 + 8;
	// 82EAD4C0: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAD4C4: 4198FF00  blt cr6, 0x82ead3c4
	if ctx.cr[6].lt {
	pc = 0x82EAD3C4; continue 'dispatch;
	}
	pc = 0x82EAD4C8; continue 'dispatch;
            }
            0x82EAD4C8 => {
    //   block [0x82EAD4C8..0x82EAD4D4)
	// 82EAD4C8: 83FF0020  lwz r31, 0x20(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EAD4CC: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD4D0: 4082FEE0  bne 0x82ead3b0
	if !ctx.cr[0].eq {
	pc = 0x82EAD3B0; continue 'dispatch;
	}
	pc = 0x82EAD4D4; continue 'dispatch;
            }
            0x82EAD4D4 => {
    //   block [0x82EAD4D4..0x82EAD4DC)
	// 82EAD4D4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EAD4D8: 4BDFBF5C  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAD4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAD4E0 size=348
    let mut pc: u32 = 0x82EAD4E0;
    'dispatch: loop {
        match pc {
            0x82EAD4E0 => {
    //   block [0x82EAD4E0..0x82EAD540)
	// 82EAD4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAD4E4: 4BDFBF25  bl 0x82ca9408
	ctx.lr = 0x82EAD4E8;
	sub_82CA93D0(ctx, base);
	// 82EAD4E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAD4EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAD4F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAD4F4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EAD4F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EAD4FC: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 82EAD500: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EAD504: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EAD508: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82EAD50C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAD510: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82EAD514: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82EAD518: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82EAD51C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EAD520: 419A0110  beq cr6, 0x82ead630
	if ctx.cr[6].eq {
	pc = 0x82EAD630; continue 'dispatch;
	}
	// 82EAD524: 3D60071C  lis r11, 0x71c
	ctx.r[11].s64 = 119275520;
	// 82EAD528: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 82EAD52C: 616B71C7  ori r11, r11, 0x71c7
	ctx.r[11].u64 = ctx.r[11].u64 | 29127;
	// 82EAD530: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAD534: 1D7D0024  mulli r11, r29, 0x24
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 36 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EAD538: 40990008  ble cr6, 0x82ead540
	if !ctx.cr[6].gt {
	pc = 0x82EAD540; continue 'dispatch;
	}
	// 82EAD53C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82EAD540; continue 'dispatch;
            }
            0x82EAD540 => {
    //   block [0x82EAD540..0x82EAD554)
	// 82EAD540: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EAD544: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82EAD548: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAD54C: 40990008  ble cr6, 0x82ead554
	if !ctx.cr[6].gt {
	pc = 0x82EAD554; continue 'dispatch;
	}
	// 82EAD550: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x82EAD554; continue 'dispatch;
            }
            0x82EAD554 => {
    //   block [0x82EAD554..0x82EAD588)
	// 82EAD554: 4B7693D5  bl 0x82616928
	ctx.lr = 0x82EAD558;
	sub_82616928(ctx, base);
	// 82EAD558: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD55C: 41820068  beq 0x82ead5c4
	if ctx.cr[0].eq {
	pc = 0x82EAD5C4; continue 'dispatch;
	}
	// 82EAD560: 38C30004  addi r6, r3, 4
	ctx.r[6].s64 = ctx.r[3].s64 + 4;
	// 82EAD564: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82EAD568: 355DFFFF  addic. r10, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAD56C: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82EAD570: 4180004C  blt 0x82ead5bc
	if ctx.cr[0].lt {
	pc = 0x82EAD5BC; continue 'dispatch;
	}
	// 82EAD574: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EAD578: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82EAD57C: 39690008  addi r11, r9, 8
	ctx.r[11].s64 = ctx.r[9].s64 + 8;
	// 82EAD580: 3908AFB4  addi r8, r8, -0x504c
	ctx.r[8].s64 = ctx.r[8].s64 + -20556;
	// 82EAD584: 38E7A2F4  addi r7, r7, -0x5d0c
	ctx.r[7].s64 = ctx.r[7].s64 + -23820;
	pc = 0x82EAD588; continue 'dispatch;
            }
            0x82EAD588 => {
    //   block [0x82EAD588..0x82EAD5BC)
	// 82EAD588: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EAD58C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAD590: 93CBFFFC  stw r30, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[30].u32 ) };
	// 82EAD594: 39290024  addi r9, r9, 0x24
	ctx.r[9].s64 = ctx.r[9].s64 + 36;
	// 82EAD598: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82EAD59C: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EAD5A0: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EAD5A4: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EAD5A8: 93CB0010  stw r30, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82EAD5AC: 93CB0014  stw r30, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82EAD5B0: 9BCB0018  stb r30, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82EAD5B4: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 82EAD5B8: 4080FFD0  bge 0x82ead588
	if !ctx.cr[0].lt {
	pc = 0x82EAD588; continue 'dispatch;
	}
	pc = 0x82EAD5BC; continue 'dispatch;
            }
            0x82EAD5BC => {
    //   block [0x82EAD5BC..0x82EAD5C4)
	// 82EAD5BC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82EAD5C0: 48000008  b 0x82ead5c8
	pc = 0x82EAD5C8; continue 'dispatch;
            }
            0x82EAD5C4 => {
    //   block [0x82EAD5C4..0x82EAD5C8)
	// 82EAD5C4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82EAD5C8; continue 'dispatch;
            }
            0x82EAD5C8 => {
    //   block [0x82EAD5C8..0x82EAD5E8)
	// 82EAD5C8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EAD5CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EAD5D0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAD5D4: 93CB0018  stw r30, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82EAD5D8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAD5DC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAD5E0: 4099003C  ble cr6, 0x82ead61c
	if !ctx.cr[6].gt {
	pc = 0x82EAD61C; continue 'dispatch;
	}
	// 82EAD5E4: 39600024  li r11, 0x24
	ctx.r[11].s64 = 36;
	pc = 0x82EAD5E8; continue 'dispatch;
            }
            0x82EAD5E8 => {
    //   block [0x82EAD5E8..0x82EAD61C)
	// 82EAD5E8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD5EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EAD5F0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EAD5F4: 3909FFDC  addi r8, r9, -0x24
	ctx.r[8].s64 = ctx.r[9].s64 + -36;
	// 82EAD5F8: 91090018  stw r8, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82EAD5FC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD600: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EAD604: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 82EAD608: 81090018  lwz r8, 0x18(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAD60C: 9128001C  stw r9, 0x1c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82EAD610: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAD614: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EAD618: 4198FFD0  blt cr6, 0x82ead5e8
	if ctx.cr[6].lt {
	pc = 0x82EAD5E8; continue 'dispatch;
	}
	pc = 0x82EAD61C; continue 'dispatch;
            }
            0x82EAD61C => {
    //   block [0x82EAD61C..0x82EAD630)
	// 82EAD61C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAD620: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD624: 1D6B0024  mulli r11, r11, 0x24
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 36 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EAD628: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EAD62C: 93CBFFF8  stw r30, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[30].u32 ) };
	pc = 0x82EAD630; continue 'dispatch;
            }
            0x82EAD630 => {
    //   block [0x82EAD630..0x82EAD63C)
	// 82EAD630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAD634: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EAD638: 4BDFBE20  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAD640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAD640 size=88
    let mut pc: u32 = 0x82EAD640;
    'dispatch: loop {
        match pc {
            0x82EAD640 => {
    //   block [0x82EAD640..0x82EAD67C)
	// 82EAD640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAD644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAD648: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAD64C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAD650: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAD654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAD658: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAD65C: 4BFFE5AD  bl 0x82eabc08
	ctx.lr = 0x82EAD660;
	sub_82EABC08(ctx, base);
	// 82EAD660: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAD664: 41820018  beq 0x82ead67c
	if ctx.cr[0].eq {
	pc = 0x82EAD67C; continue 'dispatch;
	}
	// 82EAD668: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAD66C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAD670: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAD674: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAD678: 4E800421  bctrl
	ctx.lr = 0x82EAD67C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAD67C => {
    //   block [0x82EAD67C..0x82EAD698)
	// 82EAD67C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAD680: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAD684: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAD688: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAD68C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAD690: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAD694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAD698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAD698 size=484
    let mut pc: u32 = 0x82EAD698;
    'dispatch: loop {
        match pc {
            0x82EAD698 => {
    //   block [0x82EAD698..0x82EAD6D4)
	// 82EAD698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAD69C: 4BDFBD59  bl 0x82ca93f4
	ctx.lr = 0x82EAD6A0;
	sub_82CA93D0(ctx, base);
	// 82EAD6A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAD6A4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EAD6A8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EAD6AC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82EAD6B0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD6B4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD6B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAD6BC: 409901AC  ble cr6, 0x82ead868
	if !ctx.cr[6].gt {
	pc = 0x82EAD868; continue 'dispatch;
	}
	// 82EAD6C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAD6C4: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82EAD6C8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EAD6CC: 3B0BAFB4  addi r24, r11, -0x504c
	ctx.r[24].s64 = ctx.r[11].s64 + -20556;
	// 82EAD6D0: 3AE0FFFF  li r23, -1
	ctx.r[23].s64 = -1;
	pc = 0x82EAD6D4; continue 'dispatch;
            }
            0x82EAD6D4 => {
    //   block [0x82EAD6D4..0x82EAD6F0)
	// 82EAD6D4: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD6D8: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD6DC: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD6E0: 41820160  beq 0x82ead840
	if ctx.cr[0].eq {
	pc = 0x82EAD840; continue 'dispatch;
	}
	// 82EAD6E4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD6E8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD6EC: 7D4AD02E  lwzx r10, r10, r26
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	pc = 0x82EAD6F0; continue 'dispatch;
            }
            0x82EAD6F0 => {
    //   block [0x82EAD6F0..0x82EAD70C)
	// 82EAD6F0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD6F4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAD6F8: 419A0014  beq cr6, 0x82ead70c
	if ctx.cr[6].eq {
	pc = 0x82EAD70C; continue 'dispatch;
	}
	// 82EAD6FC: 83FF001C  lwz r31, 0x1c(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAD700: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD704: 4082FFEC  bne 0x82ead6f0
	if !ctx.cr[0].eq {
	pc = 0x82EAD6F0; continue 'dispatch;
	}
	// 82EAD708: 48000138  b 0x82ead840
	pc = 0x82EAD840; continue 'dispatch;
            }
            0x82EAD70C => {
    //   block [0x82EAD70C..0x82EAD734)
	// 82EAD70C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD710: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAD714: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EAD718: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 82EAD71C: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82EAD720: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82EAD724: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EAD728: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD72C: 4BFFE94D  bl 0x82eac078
	ctx.lr = 0x82EAD730;
	sub_82EAC078(ctx, base);
	// 82EAD730: 4800001C  b 0x82ead74c
	pc = 0x82EAD74C; continue 'dispatch;
            }
            0x82EAD734 => {
    //   block [0x82EAD734..0x82EAD74C)
	// 82EAD734: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD738: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD73C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAD740: 419A0018  beq cr6, 0x82ead758
	if ctx.cr[6].eq {
	pc = 0x82EAD758; continue 'dispatch;
	}
	// 82EAD744: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EAD748: 4BFFD9F9  bl 0x82eab140
	ctx.lr = 0x82EAD74C;
	sub_82EAB140(ctx, base);
	pc = 0x82EAD74C; continue 'dispatch;
            }
            0x82EAD74C => {
    //   block [0x82EAD74C..0x82EAD758)
	// 82EAD74C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD750: 4082FFE4  bne 0x82ead734
	if !ctx.cr[0].eq {
	pc = 0x82EAD734; continue 'dispatch;
	}
	// 82EAD754: 480000D0  b 0x82ead824
	pc = 0x82EAD824; continue 'dispatch;
            }
            0x82EAD758 => {
    //   block [0x82EAD758..0x82EAD784)
	// 82EAD758: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD75C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82EAD760: 815B001C  lwz r10, 0x1c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAD764: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAD768: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EAD76C: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82EAD770: 556BE13F  rlwinm. r11, r11, 0x1c, 4, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAD774: 41820010  beq 0x82ead784
	if ctx.cr[0].eq {
	pc = 0x82EAD784; continue 'dispatch;
	}
	// 82EAD778: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82EAD77C: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 82EAD780: 4BE033B1  bl 0x82cb0b30
	ctx.lr = 0x82EAD784;
	sub_82CB0B30(ctx, base);
	pc = 0x82EAD784; continue 'dispatch;
            }
            0x82EAD784 => {
    //   block [0x82EAD784..0x82EAD7B8)
	// 82EAD784: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD788: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EAD78C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD790: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82EAD794: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EAD798: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EAD79C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EAD7A0: 4BFFFA09  bl 0x82ead1a8
	ctx.lr = 0x82EAD7A4;
	sub_82EAD1A8(ctx, base);
	// 82EAD7A4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD7A8: 41820010  beq 0x82ead7b8
	if ctx.cr[0].eq {
	pc = 0x82EAD7B8; continue 'dispatch;
	}
	// 82EAD7AC: 92FF000C  stw r23, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[23].u32 ) };
	// 82EAD7B0: 92FF0008  stw r23, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82EAD7B4: 48000010  b 0x82ead7c4
	pc = 0x82EAD7C4; continue 'dispatch;
            }
            0x82EAD7B8 => {
    //   block [0x82EAD7B8..0x82EAD7C4)
	// 82EAD7B8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD7BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EAD7C0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x82EAD7C4; continue 'dispatch;
            }
            0x82EAD7C4 => {
    //   block [0x82EAD7C4..0x82EAD7DC)
	// 82EAD7C4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD7C8: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 82EAD7CC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD7D0: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAD7D4: 4098003C  bge cr6, 0x82ead810
	if !ctx.cr[6].lt {
	pc = 0x82EAD810; continue 'dispatch;
	}
	// 82EAD7D8: 395A0008  addi r10, r26, 8
	ctx.r[10].s64 = ctx.r[26].s64 + 8;
	pc = 0x82EAD7DC; continue 'dispatch;
            }
            0x82EAD7DC => {
    //   block [0x82EAD7DC..0x82EAD810)
	// 82EAD7DC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD7E0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EAD7E4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD7E8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EAD7EC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82EAD7F0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAD7F4: 910BFFF8  stw r8, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 82EAD7F8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD7FC: 910BFFFC  stw r8, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[8].u32 ) };
	// 82EAD800: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD804: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD808: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAD80C: 4198FFD0  blt cr6, 0x82ead7dc
	if ctx.cr[6].lt {
	pc = 0x82EAD7DC; continue 'dispatch;
	}
	pc = 0x82EAD810; continue 'dispatch;
            }
            0x82EAD810 => {
    //   block [0x82EAD810..0x82EAD824)
	// 82EAD810: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD814: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EAD818: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD81C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82EAD820: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82EAD824; continue 'dispatch;
            }
            0x82EAD824 => {
    //   block [0x82EAD824..0x82EAD840)
	// 82EAD824: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAD828: 40820018  bne 0x82ead840
	if !ctx.cr[0].eq {
	pc = 0x82EAD840; continue 'dispatch;
	}
	// 82EAD82C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAD830: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EAD834: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EAD838: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAD83C: 4E800421  bctrl
	ctx.lr = 0x82EAD840;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAD840 => {
    //   block [0x82EAD840..0x82EAD850)
	// 82EAD840: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAD844: 4182000C  beq 0x82ead850
	if ctx.cr[0].eq {
	pc = 0x82EAD850; continue 'dispatch;
	}
	// 82EAD848: 3B5A0008  addi r26, r26, 8
	ctx.r[26].s64 = ctx.r[26].s64 + 8;
	// 82EAD84C: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	pc = 0x82EAD850; continue 'dispatch;
            }
            0x82EAD850 => {
    //   block [0x82EAD850..0x82EAD868)
	// 82EAD850: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD854: 3959FFFF  addi r10, r25, -1
	ctx.r[10].s64 = ctx.r[25].s64 + -1;
	// 82EAD858: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82EAD85C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD860: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAD864: 4198FE70  blt cr6, 0x82ead6d4
	if ctx.cr[6].lt {
	pc = 0x82EAD6D4; continue 'dispatch;
	}
	pc = 0x82EAD868; continue 'dispatch;
            }
            0x82EAD868 => {
    //   block [0x82EAD868..0x82EAD87C)
	// 82EAD868: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EAD86C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EAD870: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAD874: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EAD878: 4BDFBBCC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAD880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAD880 size=572
    let mut pc: u32 = 0x82EAD880;
    'dispatch: loop {
        match pc {
            0x82EAD880 => {
    //   block [0x82EAD880..0x82EAD8CC)
	// 82EAD880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAD884: 4BDFBB6D  bl 0x82ca93f0
	ctx.lr = 0x82EAD888;
	sub_82CA93D0(ctx, base);
	// 82EAD888: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAD88C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAD890: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD894: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD898: 4182021C  beq 0x82eadab4
	if ctx.cr[0].eq {
	pc = 0x82EADAB4; continue 'dispatch;
	}
	// 82EAD89C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAD8A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAD8A4: 419A0210  beq cr6, 0x82eadab4
	if ctx.cr[6].eq {
	pc = 0x82EADAB4; continue 'dispatch;
	}
	// 82EAD8A8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAD8AC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD8B0: 41820204  beq 0x82eadab4
	if ctx.cr[0].eq {
	pc = 0x82EADAB4; continue 'dispatch;
	}
	// 82EAD8B4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAD8B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAD8BC: 419A01F8  beq cr6, 0x82eadab4
	if ctx.cr[6].eq {
	pc = 0x82EADAB4; continue 'dispatch;
	}
	// 82EAD8C0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAD8C4: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD8C8: 4800001C  b 0x82ead8e4
	pc = 0x82EAD8E4; continue 'dispatch;
            }
            0x82EAD8CC => {
    //   block [0x82EAD8CC..0x82EAD8E4)
	// 82EAD8CC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAD8D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAD8D4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD8D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAD8DC: 4E800421  bctrl
	ctx.lr = 0x82EAD8E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAD8E0: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
            }
            0x82EAD8E4 => {
    //   block [0x82EAD8E4..0x82EAD910)
	// 82EAD8E4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD8E8: 4082FFE4  bne 0x82ead8cc
	if !ctx.cr[0].eq {
	pc = 0x82EAD8CC; continue 'dispatch;
	}
	// 82EAD8EC: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EAD8F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAD8F4: 409A001C  bne cr6, 0x82ead910
	if !ctx.cr[6].eq {
	pc = 0x82EAD910; continue 'dispatch;
	}
	// 82EAD8F8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAD8FC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD900: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82EAD904: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAD908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAD90C: 419A01A8  beq cr6, 0x82eadab4
	if ctx.cr[6].eq {
	pc = 0x82EADAB4; continue 'dispatch;
	}
	pc = 0x82EAD910; continue 'dispatch;
            }
            0x82EAD910 => {
    //   block [0x82EAD910..0x82EAD944)
	// 82EAD910: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAD914: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EAD918: 3ADF0028  addi r22, r31, 0x28
	ctx.r[22].s64 = ctx.r[31].s64 + 40;
	// 82EAD91C: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 82EAD920: 82EB0014  lwz r23, 0x14(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAD924: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAD928: 3B4BAFB4  addi r26, r11, -0x504c
	ctx.r[26].s64 = ctx.r[11].s64 + -20556;
	// 82EAD92C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAD930: 3BABAFB4  addi r29, r11, -0x504c
	ctx.r[29].s64 = ctx.r[11].s64 + -20556;
	// 82EAD934: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EAD938: 3B2B9128  addi r25, r11, -0x6ed8
	ctx.r[25].s64 = ctx.r[11].s64 + -28376;
	// 82EAD93C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAD940: 3B6BAFB4  addi r27, r11, -0x504c
	ctx.r[27].s64 = ctx.r[11].s64 + -20556;
	pc = 0x82EAD944; continue 'dispatch;
            }
            0x82EAD944 => {
    //   block [0x82EAD944..0x82EAD98C)
	// 82EAD944: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EAD948: 3AF7FFFF  addi r23, r23, -1
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	// 82EAD94C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAD950: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAD954: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAD958: 409A0078  bne cr6, 0x82ead9d0
	if !ctx.cr[6].eq {
	pc = 0x82EAD9D0; continue 'dispatch;
	}
	// 82EAD95C: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EAD960: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EAD964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAD968: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82EAD96C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAD970: 9B0B0000  stb r24, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u8 ) };
	// 82EAD974: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EAD978: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAD97C: 4BFFFD1D  bl 0x82ead698
	ctx.lr = 0x82EAD980;
	sub_82EAD698(ctx, base);
	// 82EAD980: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAD984: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD988: 4800003C  b 0x82ead9c4
	pc = 0x82EAD9C4; continue 'dispatch;
            }
            0x82EAD98C => {
    //   block [0x82EAD98C..0x82EAD9C4)
	// 82EAD98C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAD990: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EAD994: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EAD998: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EAD99C: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 82EAD9A0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82EAD9A4: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EAD9A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAD9AC: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82EAD9B0: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EAD9B4: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82EAD9B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAD9BC: 4E800421  bctrl
	ctx.lr = 0x82EAD9C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAD9C0: 83DE001C  lwz r30, 0x1c(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
            }
            0x82EAD9C4 => {
    //   block [0x82EAD9C4..0x82EAD9D0)
	// 82EAD9C4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAD9C8: 4082FFC4  bne 0x82ead98c
	if !ctx.cr[0].eq {
	pc = 0x82EAD98C; continue 'dispatch;
	}
	// 82EAD9CC: 48000054  b 0x82eada20
	pc = 0x82EADA20; continue 'dispatch;
            }
            0x82EAD9D0 => {
    //   block [0x82EAD9D0..0x82EAD9DC)
	// 82EAD9D0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EAD9D4: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD9D8: 48000040  b 0x82eada18
	pc = 0x82EADA18; continue 'dispatch;
            }
            0x82EAD9DC => {
    //   block [0x82EAD9DC..0x82EADA18)
	// 82EAD9DC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAD9E0: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EAD9E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAD9E8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EAD9EC: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82EAD9F0: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82EAD9F4: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82EAD9F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAD9FC: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82EADA00: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EADA04: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EADA08: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 82EADA0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EADA10: 4E800421  bctrl
	ctx.lr = 0x82EADA14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EADA14: 83DE0010  lwz r30, 0x10(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
            }
            0x82EADA18 => {
    //   block [0x82EADA18..0x82EADA20)
	// 82EADA18: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EADA1C: 4082FFC0  bne 0x82ead9dc
	if !ctx.cr[0].eq {
	pc = 0x82EAD9DC; continue 'dispatch;
	}
	pc = 0x82EADA20; continue 'dispatch;
            }
            0x82EADA20 => {
    //   block [0x82EADA20..0x82EADA30)
	// 82EADA20: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EADA24: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EADA28: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EADA2C: 41820050  beq 0x82eada7c
	if ctx.cr[0].eq {
	pc = 0x82EADA7C; continue 'dispatch;
	}
	pc = 0x82EADA30; continue 'dispatch;
            }
            0x82EADA30 => {
    //   block [0x82EADA30..0x82EADA54)
	// 82EADA30: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EADA34: 813F002C  lwz r9, 0x2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EADA38: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EADA3C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EADA40: 419A0014  beq cr6, 0x82eada54
	if ctx.cr[6].eq {
	pc = 0x82EADA54; continue 'dispatch;
	}
	// 82EADA44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EADA48: 419A000C  beq cr6, 0x82eada54
	if ctx.cr[6].eq {
	pc = 0x82EADA54; continue 'dispatch;
	}
	// 82EADA4C: 83DE0010  lwz r30, 0x10(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EADA50: 48000024  b 0x82eada74
	pc = 0x82EADA74; continue 'dispatch;
            }
            0x82EADA54 => {
    //   block [0x82EADA54..0x82EADA74)
	// 82EADA54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EADA58: 930B0014  stw r24, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[24].u32 ) };
	// 82EADA5C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82EADA60: 83DE0010  lwz r30, 0x10(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EADA64: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EADA68: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82EADA6C: 4BFFD305  bl 0x82eaad70
	ctx.lr = 0x82EADA70;
	sub_82EAAD70(ctx, base);
	// 82EADA70: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	pc = 0x82EADA74; continue 'dispatch;
            }
            0x82EADA74 => {
    //   block [0x82EADA74..0x82EADA7C)
	// 82EADA74: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EADA78: 409AFFB8  bne cr6, 0x82eada30
	if !ctx.cr[6].eq {
	pc = 0x82EADA30; continue 'dispatch;
	}
	pc = 0x82EADA7C; continue 'dispatch;
            }
            0x82EADA7C => {
    //   block [0x82EADA7C..0x82EADAA0)
	// 82EADA7C: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EADA80: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EADA84: 91760004  stw r11, 4(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EADA88: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EADA8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EADA90: 409A0010  bne cr6, 0x82eadaa0
	if !ctx.cr[6].eq {
	pc = 0x82EADAA0; continue 'dispatch;
	}
	// 82EADA94: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EADA98: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EADA9C: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	pc = 0x82EADAA0; continue 'dispatch;
            }
            0x82EADAA0 => {
    //   block [0x82EADAA0..0x82EADAB4)
	// 82EADAA0: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EADAA4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EADAA8: 4098000C  bge cr6, 0x82eadab4
	if !ctx.cr[6].lt {
	pc = 0x82EADAB4; continue 'dispatch;
	}
	// 82EADAAC: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82EADAB0: 409AFE94  bne cr6, 0x82ead944
	if !ctx.cr[6].eq {
	pc = 0x82EAD944; continue 'dispatch;
	}
	pc = 0x82EADAB4; continue 'dispatch;
            }
            0x82EADAB4 => {
    //   block [0x82EADAB4..0x82EADABC)
	// 82EADAB4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EADAB8: 4BDFB988  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EADAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EADAC0 size=304
    let mut pc: u32 = 0x82EADAC0;
    'dispatch: loop {
        match pc {
            0x82EADAC0 => {
    //   block [0x82EADAC0..0x82EADAF8)
	// 82EADAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EADAC4: 4BDFB941  bl 0x82ca9404
	ctx.lr = 0x82EADAC8;
	sub_82CA93D0(ctx, base);
	// 82EADAC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EADACC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EADAD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EADAD4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EADAD8: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82EADADC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EADAE0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EADAE4: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EADAE8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EADAEC: 41820030  beq 0x82eadb1c
	if ctx.cr[0].eq {
	pc = 0x82EADB1C; continue 'dispatch;
	}
	// 82EADAF0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EADAF4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	pc = 0x82EADAF8; continue 'dispatch;
            }
            0x82EADAF8 => {
    //   block [0x82EADAF8..0x82EADB1C)
	// 82EADAF8: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EADAFC: 7F07D840  cmplw cr6, r7, r27
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82EADB00: 419A00D8  beq cr6, 0x82eadbd8
	if ctx.cr[6].eq {
	pc = 0x82EADBD8; continue 'dispatch;
	}
	// 82EADB04: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EADB08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EADB0C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82EADB10: 80E70010  lwz r7, 0x10(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EADB14: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EADB18: 4198FFE0  blt cr6, 0x82eadaf8
	if ctx.cr[6].lt {
	pc = 0x82EADAF8; continue 'dispatch;
	}
	pc = 0x82EADB1C; continue 'dispatch;
            }
            0x82EADB1C => {
    //   block [0x82EADB1C..0x82EADB58)
	// 82EADB1C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EADB20: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EADB24: 419A00B4  beq cr6, 0x82eadbd8
	if ctx.cr[6].eq {
	pc = 0x82EADBD8; continue 'dispatch;
	}
	// 82EADB28: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EADB2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EADB30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EADB34: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EADB38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EADB3C: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EADB40: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EADB44: 3B8AAFB4  addi r28, r10, -0x504c
	ctx.r[28].s64 = ctx.r[10].s64 + -20556;
	// 82EADB48: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82EADB4C: 409A000C  bne cr6, 0x82eadb58
	if !ctx.cr[6].eq {
	pc = 0x82EADB58; continue 'dispatch;
	}
	// 82EADB50: 4BFFF109  bl 0x82eacc58
	ctx.lr = 0x82EADB54;
	sub_82EACC58(ctx, base);
	// 82EADB54: 48000008  b 0x82eadb5c
	pc = 0x82EADB5C; continue 'dispatch;
            }
            0x82EADB58 => {
    //   block [0x82EADB58..0x82EADB5C)
	// 82EADB58: 4BFFF229  bl 0x82eacd80
	ctx.lr = 0x82EADB5C;
	sub_82EACD80(ctx, base);
	pc = 0x82EADB5C; continue 'dispatch;
            }
            0x82EADB5C => {
    //   block [0x82EADB5C..0x82EADBD8)
	// 82EADB5C: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EADB60: 419A0078  beq cr6, 0x82eadbd8
	if ctx.cr[6].eq {
	pc = 0x82EADBD8; continue 'dispatch;
	}
	// 82EADB64: 815D001C  lwz r10, 0x1c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EADB68: 546B2036  slwi r11, r3, 4
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EADB6C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82EADB70: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82EADB74: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EADB78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EADB7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EADB80: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82EADB84: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EADB88: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EADB8C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EADB90: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EADB94: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EADB98: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EADB9C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EADBA0: 80EA0010  lwz r7, 0x10(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EADBA4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EADBA8: 54EA1838  slwi r10, r7, 3
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EADBAC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EADBB0: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EADBB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EADBB8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EADBBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EADBC0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EADBC4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EADBC8: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EADBCC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EADBD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EADBD4: 4BFFEEDD  bl 0x82eacab0
	ctx.lr = 0x82EADBD8;
	sub_82EACAB0(ctx, base);
	pc = 0x82EADBD8; continue 'dispatch;
            }
            0x82EADBD8 => {
    //   block [0x82EADBD8..0x82EADBF0)
	// 82EADBD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EADBDC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EADBE0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EADBE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EADBE8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EADBEC: 4BDFB868  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EADBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EADBF0 size=116
    let mut pc: u32 = 0x82EADBF0;
    'dispatch: loop {
        match pc {
            0x82EADBF0 => {
    //   block [0x82EADBF0..0x82EADC38)
	// 82EADBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EADBF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EADBF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EADBFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EADC00: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EADC04: 816A8164  lwz r11, -0x7e9c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32412 as u32) ) } as u64;
	// 82EADC08: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EADC0C: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EADC10: 3BE97D60  addi r31, r9, 0x7d60
	ctx.r[31].s64 = ctx.r[9].s64 + 32096;
	// 82EADC14: 40820038  bne 0x82eadc4c
	if !ctx.cr[0].eq {
	pc = 0x82EADC4C; continue 'dispatch;
	}
	// 82EADC18: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EADC1C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EADC20: 8909DE58  lbz r8, -0x21a8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8616 as u32) ) } as u64;
	// 82EADC24: 916A8164  stw r11, -0x7e9c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-32412 as u32), ctx.r[11].u32 ) };
	// 82EADC28: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EADC2C: 4182000C  beq 0x82eadc38
	if ctx.cr[0].eq {
	pc = 0x82EADC38; continue 'dispatch;
	}
	// 82EADC30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EADC34: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EADC38; continue 'dispatch;
            }
            0x82EADC38 => {
    //   block [0x82EADC38..0x82EADC4C)
	// 82EADC38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EADC3C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EADC40: 386A8868  addi r3, r10, -0x7798
	ctx.r[3].s64 = ctx.r[10].s64 + -30616;
	// 82EADC44: 9969DE58  stb r11, -0x21a8(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8616 as u32), ctx.r[11].u8 ) };
	// 82EADC48: 4BDFC2D9  bl 0x82ca9f20
	ctx.lr = 0x82EADC4C;
	sub_82CA9F20(ctx, base);
	pc = 0x82EADC4C; continue 'dispatch;
            }
            0x82EADC4C => {
    //   block [0x82EADC4C..0x82EADC64)
	// 82EADC4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EADC50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EADC54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EADC58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EADC5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EADC60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EADC68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EADC68 size=116
    let mut pc: u32 = 0x82EADC68;
    'dispatch: loop {
        match pc {
            0x82EADC68 => {
    //   block [0x82EADC68..0x82EADCB0)
	// 82EADC68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EADC6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EADC70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EADC74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EADC78: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EADC7C: 816A856C  lwz r11, -0x7a94(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31380 as u32) ) } as u64;
	// 82EADC80: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EADC84: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EADC88: 3BE98168  addi r31, r9, -0x7e98
	ctx.r[31].s64 = ctx.r[9].s64 + -32408;
	// 82EADC8C: 40820038  bne 0x82eadcc4
	if !ctx.cr[0].eq {
	pc = 0x82EADCC4; continue 'dispatch;
	}
	// 82EADC90: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EADC94: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EADC98: 8909DE59  lbz r8, -0x21a7(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8615 as u32) ) } as u64;
	// 82EADC9C: 916A856C  stw r11, -0x7a94(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-31380 as u32), ctx.r[11].u32 ) };
	// 82EADCA0: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EADCA4: 4182000C  beq 0x82eadcb0
	if ctx.cr[0].eq {
	pc = 0x82EADCB0; continue 'dispatch;
	}
	// 82EADCA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EADCAC: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EADCB0; continue 'dispatch;
            }
            0x82EADCB0 => {
    //   block [0x82EADCB0..0x82EADCC4)
	// 82EADCB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EADCB4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EADCB8: 386A8850  addi r3, r10, -0x77b0
	ctx.r[3].s64 = ctx.r[10].s64 + -30640;
	// 82EADCBC: 9969DE59  stb r11, -0x21a7(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8615 as u32), ctx.r[11].u8 ) };
	// 82EADCC0: 4BDFC261  bl 0x82ca9f20
	ctx.lr = 0x82EADCC4;
	sub_82CA9F20(ctx, base);
	pc = 0x82EADCC4; continue 'dispatch;
            }
            0x82EADCC4 => {
    //   block [0x82EADCC4..0x82EADCDC)
	// 82EADCC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EADCC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EADCCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EADCD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EADCD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EADCD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EADCE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EADCE0 size=160
    let mut pc: u32 = 0x82EADCE0;
    'dispatch: loop {
        match pc {
            0x82EADCE0 => {
    //   block [0x82EADCE0..0x82EADD14)
	// 82EADCE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EADCE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EADCE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EADCEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EADCF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EADCF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EADCF8: 419A0064  beq cr6, 0x82eadd5c
	if ctx.cr[6].eq {
	pc = 0x82EADD5C; continue 'dispatch;
	}
	// 82EADCFC: 4BFFFEF5  bl 0x82eadbf0
	ctx.lr = 0x82EADD00;
	sub_82EADBF0(ctx, base);
	// 82EADD00: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EADD04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EADD08: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EADD0C: 40810050  ble 0x82eadd5c
	if !ctx.cr[0].gt {
	pc = 0x82EADD5C; continue 'dispatch;
	}
	// 82EADD10: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EADD14; continue 'dispatch;
            }
            0x82EADD14 => {
    //   block [0x82EADD14..0x82EADD20)
	// 82EADD14: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EADD18: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EADD1C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EADD20; continue 'dispatch;
            }
            0x82EADD20 => {
    //   block [0x82EADD20..0x82EADD44)
	// 82EADD20: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EADD24: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EADD28: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EADD2C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EADD30: 41820014  beq 0x82eadd44
	if ctx.cr[0].eq {
	pc = 0x82EADD44; continue 'dispatch;
	}
	// 82EADD34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EADD38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EADD3C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EADD40: 419AFFE0  beq cr6, 0x82eadd20
	if ctx.cr[6].eq {
	pc = 0x82EADD20; continue 'dispatch;
	}
	pc = 0x82EADD44; continue 'dispatch;
            }
            0x82EADD44 => {
    //   block [0x82EADD44..0x82EADD5C)
	// 82EADD44: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EADD48: 4182002C  beq 0x82eadd74
	if ctx.cr[0].eq {
	pc = 0x82EADD74; continue 'dispatch;
	}
	// 82EADD4C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EADD50: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EADD54: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EADD58: 4198FFBC  blt cr6, 0x82eadd14
	if ctx.cr[6].lt {
	pc = 0x82EADD14; continue 'dispatch;
	}
	pc = 0x82EADD5C; continue 'dispatch;
            }
            0x82EADD5C => {
    //   block [0x82EADD5C..0x82EADD60)
	// 82EADD5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EADD60; continue 'dispatch;
            }
            0x82EADD60 => {
    //   block [0x82EADD60..0x82EADD74)
	// 82EADD60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EADD64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EADD68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EADD6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EADD70: 4E800020  blr
	return;
            }
            0x82EADD74 => {
    //   block [0x82EADD74..0x82EADD80)
	// 82EADD74: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EADD78: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EADD7C: 4BFFFFE4  b 0x82eadd60
	pc = 0x82EADD60; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EADD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EADD80 size=160
    let mut pc: u32 = 0x82EADD80;
    'dispatch: loop {
        match pc {
            0x82EADD80 => {
    //   block [0x82EADD80..0x82EADDB4)
	// 82EADD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EADD84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EADD88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EADD8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EADD90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EADD94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EADD98: 419A0064  beq cr6, 0x82eaddfc
	if ctx.cr[6].eq {
	pc = 0x82EADDFC; continue 'dispatch;
	}
	// 82EADD9C: 4BFFFECD  bl 0x82eadc68
	ctx.lr = 0x82EADDA0;
	sub_82EADC68(ctx, base);
	// 82EADDA0: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EADDA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EADDA8: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EADDAC: 40810050  ble 0x82eaddfc
	if !ctx.cr[0].gt {
	pc = 0x82EADDFC; continue 'dispatch;
	}
	// 82EADDB0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EADDB4; continue 'dispatch;
            }
            0x82EADDB4 => {
    //   block [0x82EADDB4..0x82EADDC0)
	// 82EADDB4: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EADDB8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EADDBC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EADDC0; continue 'dispatch;
            }
            0x82EADDC0 => {
    //   block [0x82EADDC0..0x82EADDE4)
	// 82EADDC0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EADDC4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EADDC8: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EADDCC: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EADDD0: 41820014  beq 0x82eadde4
	if ctx.cr[0].eq {
	pc = 0x82EADDE4; continue 'dispatch;
	}
	// 82EADDD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EADDD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EADDDC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EADDE0: 419AFFE0  beq cr6, 0x82eaddc0
	if ctx.cr[6].eq {
	pc = 0x82EADDC0; continue 'dispatch;
	}
	pc = 0x82EADDE4; continue 'dispatch;
            }
            0x82EADDE4 => {
    //   block [0x82EADDE4..0x82EADDFC)
	// 82EADDE4: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EADDE8: 4182002C  beq 0x82eade14
	if ctx.cr[0].eq {
	pc = 0x82EADE14; continue 'dispatch;
	}
	// 82EADDEC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EADDF0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EADDF4: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EADDF8: 4198FFBC  blt cr6, 0x82eaddb4
	if ctx.cr[6].lt {
	pc = 0x82EADDB4; continue 'dispatch;
	}
	pc = 0x82EADDFC; continue 'dispatch;
            }
            0x82EADDFC => {
    //   block [0x82EADDFC..0x82EADE00)
	// 82EADDFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EADE00; continue 'dispatch;
            }
            0x82EADE00 => {
    //   block [0x82EADE00..0x82EADE14)
	// 82EADE00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EADE04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EADE08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EADE0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EADE10: 4E800020  blr
	return;
            }
            0x82EADE14 => {
    //   block [0x82EADE14..0x82EADE20)
	// 82EADE14: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EADE18: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EADE1C: 4BFFFFE4  b 0x82eade00
	pc = 0x82EADE00; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EADE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EADE20 size=200
    let mut pc: u32 = 0x82EADE20;
    'dispatch: loop {
        match pc {
            0x82EADE20 => {
    //   block [0x82EADE20..0x82EADE54)
	// 82EADE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EADE24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EADE28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EADE2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EADE30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EADE34: 4BFFFDBD  bl 0x82eadbf0
	ctx.lr = 0x82EADE38;
	sub_82EADBF0(ctx, base);
	// 82EADE38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EADE3C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EADE40: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EADE44: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EADE48: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EADE4C: 40810054  ble 0x82eadea0
	if !ctx.cr[0].gt {
	pc = 0x82EADEA0; continue 'dispatch;
	}
	// 82EADE50: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EADE54; continue 'dispatch;
            }
            0x82EADE54 => {
    //   block [0x82EADE54..0x82EADE60)
	// 82EADE54: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EADE58: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EADE5C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EADE60; continue 'dispatch;
            }
            0x82EADE60 => {
    //   block [0x82EADE60..0x82EADE84)
	// 82EADE60: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EADE64: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EADE68: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EADE6C: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EADE70: 41820014  beq 0x82eade84
	if ctx.cr[0].eq {
	pc = 0x82EADE84; continue 'dispatch;
	}
	// 82EADE74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EADE78: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EADE7C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EADE80: 419AFFE0  beq cr6, 0x82eade60
	if ctx.cr[6].eq {
	pc = 0x82EADE60; continue 'dispatch;
	}
	pc = 0x82EADE84; continue 'dispatch;
            }
            0x82EADE84 => {
    //   block [0x82EADE84..0x82EADEA0)
	// 82EADE84: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EADE88: 41820028  beq 0x82eadeb0
	if ctx.cr[0].eq {
	pc = 0x82EADEB0; continue 'dispatch;
	}
	// 82EADE8C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EADE90: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EADE94: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EADE98: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EADE9C: 4198FFB8  blt cr6, 0x82eade54
	if ctx.cr[6].lt {
	pc = 0x82EADE54; continue 'dispatch;
	}
	pc = 0x82EADEA0; continue 'dispatch;
            }
            0x82EADEA0 => {
    //   block [0x82EADEA0..0x82EADEB0)
	// 82EADEA0: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EADEA4: 409A0018  bne cr6, 0x82eadebc
	if !ctx.cr[6].eq {
	pc = 0x82EADEBC; continue 'dispatch;
	}
	// 82EADEA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EADEAC: 48000028  b 0x82eaded4
	pc = 0x82EADED4; continue 'dispatch;
            }
            0x82EADEB0 => {
    //   block [0x82EADEB0..0x82EADEBC)
	// 82EADEB0: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EADEB4: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EADEB8: 48000018  b 0x82eaded0
	pc = 0x82EADED0; continue 'dispatch;
            }
            0x82EADEBC => {
    //   block [0x82EADEBC..0x82EADED0)
	// 82EADEBC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EADEC0: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EADEC4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EADEC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EADECC: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EADED0; continue 'dispatch;
            }
            0x82EADED0 => {
    //   block [0x82EADED0..0x82EADED4)
	// 82EADED0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EADED4; continue 'dispatch;
            }
            0x82EADED4 => {
    //   block [0x82EADED4..0x82EADEE8)
	// 82EADED4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EADED8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EADEDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EADEE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EADEE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EADEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EADEE8 size=892
    let mut pc: u32 = 0x82EADEE8;
    'dispatch: loop {
        match pc {
            0x82EADEE8 => {
    //   block [0x82EADEE8..0x82EADF08)
	// 82EADEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EADEEC: 4BDFB521  bl 0x82ca940c
	ctx.lr = 0x82EADEF0;
	sub_82CA93D0(ctx, base);
	// 82EADEF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EADEF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EADEF8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EADEFC: 4BFC1F9D  bl 0x82e6fe98
	ctx.lr = 0x82EADF00;
	sub_82E6FE98(ctx, base);
	// 82EADF00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EADF04: 4182000C  beq 0x82eadf10
	if ctx.cr[0].eq {
	pc = 0x82EADF10; continue 'dispatch;
	}
	pc = 0x82EADF08; continue 'dispatch;
            }
            0x82EADF08 => {
    //   block [0x82EADF08..0x82EADF10)
	// 82EADF08: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EADF0C: 48000224  b 0x82eae130
	pc = 0x82EAE130; continue 'dispatch;
            }
            0x82EADF10 => {
    //   block [0x82EADF10..0x82EADF68)
	// 82EADF10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EADF14: 4830E14D  bl 0x831bc060
	ctx.lr = 0x82EADF18;
	sub_831BC060(ctx, base);
	// 82EADF18: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EADF1C: 41820210  beq 0x82eae12c
	if ctx.cr[0].eq {
	pc = 0x82EAE12C; continue 'dispatch;
	}
	// 82EADF20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EADF24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EADF28: 388BA204  addi r4, r11, -0x5dfc
	ctx.r[4].s64 = ctx.r[11].s64 + -24060;
	// 82EADF2C: 4BDFEC25  bl 0x82cacb50
	ctx.lr = 0x82EADF30;
	sub_82CACB50(ctx, base);
	// 82EADF30: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EADF34: 40820044  bne 0x82eadf78
	if !ctx.cr[0].eq {
	pc = 0x82EADF78; continue 'dispatch;
	}
	// 82EADF38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EADF3C: 4BA5FDCD  bl 0x8290dd08
	ctx.lr = 0x82EADF40;
	sub_8290DD08(ctx, base);
	// 82EADF40: 4BDFC481  bl 0x82caa3c0
	ctx.lr = 0x82EADF44;
	sub_82CAA3C0(ctx, base);
	// 82EADF44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EADF48: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EADF4C: 4B7689DD  bl 0x82616928
	ctx.lr = 0x82EADF50;
	sub_82616928(ctx, base);
	// 82EADF50: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EADF54: 41820014  beq 0x82eadf68
	if ctx.cr[0].eq {
	pc = 0x82EADF68; continue 'dispatch;
	}
	// 82EADF58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EADF5C: 4BFFF585  bl 0x82ead4e0
	ctx.lr = 0x82EADF60;
	sub_82EAD4E0(ctx, base);
	// 82EADF60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EADF64: 48000008  b 0x82eadf6c
	pc = 0x82EADF6C; continue 'dispatch;
            }
            0x82EADF68 => {
    //   block [0x82EADF68..0x82EADF6C)
	// 82EADF68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EADF6C; continue 'dispatch;
            }
            0x82EADF6C => {
    //   block [0x82EADF6C..0x82EADF78)
	// 82EADF6C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EADF70: 917D0010  stw r11, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EADF74: 480001BC  b 0x82eae130
	pc = 0x82EAE130; continue 'dispatch;
            }
            0x82EADF78 => {
    //   block [0x82EADF78..0x82EADFC0)
	// 82EADF78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EADF7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EADF80: 388BA344  addi r4, r11, -0x5cbc
	ctx.r[4].s64 = ctx.r[11].s64 + -23740;
	// 82EADF84: 4BDFEBCD  bl 0x82cacb50
	ctx.lr = 0x82EADF88;
	sub_82CACB50(ctx, base);
	// 82EADF88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EADF8C: 40820044  bne 0x82eadfd0
	if !ctx.cr[0].eq {
	pc = 0x82EADFD0; continue 'dispatch;
	}
	// 82EADF90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EADF94: 4BA5FD75  bl 0x8290dd08
	ctx.lr = 0x82EADF98;
	sub_8290DD08(ctx, base);
	// 82EADF98: 4BDFC429  bl 0x82caa3c0
	ctx.lr = 0x82EADF9C;
	sub_82CAA3C0(ctx, base);
	// 82EADF9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EADFA0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EADFA4: 4B768985  bl 0x82616928
	ctx.lr = 0x82EADFA8;
	sub_82616928(ctx, base);
	// 82EADFA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EADFAC: 41820014  beq 0x82eadfc0
	if ctx.cr[0].eq {
	pc = 0x82EADFC0; continue 'dispatch;
	}
	// 82EADFB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EADFB4: 4BFFD34D  bl 0x82eab300
	ctx.lr = 0x82EADFB8;
	sub_82EAB300(ctx, base);
	// 82EADFB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EADFBC: 48000008  b 0x82eadfc4
	pc = 0x82EADFC4; continue 'dispatch;
            }
            0x82EADFC0 => {
    //   block [0x82EADFC0..0x82EADFC4)
	// 82EADFC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EADFC4; continue 'dispatch;
            }
            0x82EADFC4 => {
    //   block [0x82EADFC4..0x82EADFD0)
	// 82EADFC4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EADFC8: 917D0014  stw r11, 0x14(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EADFCC: 48000164  b 0x82eae130
	pc = 0x82EAE130; continue 'dispatch;
            }
            0x82EADFD0 => {
    //   block [0x82EADFD0..0x82EAE018)
	// 82EADFD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EADFD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EADFD8: 388BA334  addi r4, r11, -0x5ccc
	ctx.r[4].s64 = ctx.r[11].s64 + -23756;
	// 82EADFDC: 4BDFEB75  bl 0x82cacb50
	ctx.lr = 0x82EADFE0;
	sub_82CACB50(ctx, base);
	// 82EADFE0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EADFE4: 408200A4  bne 0x82eae088
	if !ctx.cr[0].eq {
	pc = 0x82EAE088; continue 'dispatch;
	}
	// 82EADFE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EADFEC: 4BA5FD1D  bl 0x8290dd08
	ctx.lr = 0x82EADFF0;
	sub_8290DD08(ctx, base);
	// 82EADFF0: 4BDFC3D1  bl 0x82caa3c0
	ctx.lr = 0x82EADFF4;
	sub_82CAA3C0(ctx, base);
	// 82EADFF4: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 82EADFF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EADFFC: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82EAE000: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EAE004: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAE008: 57EB2036  slwi r11, r31, 4
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAE00C: 93FD0020  stw r31, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 82EAE010: 40990008  ble cr6, 0x82eae018
	if !ctx.cr[6].gt {
	pc = 0x82EAE018; continue 'dispatch;
	}
	// 82EAE014: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82EAE018; continue 'dispatch;
            }
            0x82EAE018 => {
    //   block [0x82EAE018..0x82EAE028)
	// 82EAE018: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EAE01C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EAE020: 41990008  bgt cr6, 0x82eae028
	if ctx.cr[6].gt {
	pc = 0x82EAE028; continue 'dispatch;
	}
	// 82EAE024: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82EAE028; continue 'dispatch;
            }
            0x82EAE028 => {
    //   block [0x82EAE028..0x82EAE054)
	// 82EAE028: 4B768901  bl 0x82616928
	ctx.lr = 0x82EAE02C;
	sub_82616928(ctx, base);
	// 82EAE02C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAE030: 41820048  beq 0x82eae078
	if ctx.cr[0].eq {
	pc = 0x82EAE078; continue 'dispatch;
	}
	// 82EAE034: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 82EAE038: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82EAE03C: 355FFFFF  addic. r10, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAE040: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82EAE044: 4180002C  blt 0x82eae070
	if ctx.cr[0].lt {
	pc = 0x82EAE070; continue 'dispatch;
	}
	// 82EAE048: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EAE04C: 3909AFB4  addi r8, r9, -0x504c
	ctx.r[8].s64 = ctx.r[9].s64 + -20556;
	// 82EAE050: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82EAE054; continue 'dispatch;
            }
            0x82EAE054 => {
    //   block [0x82EAE054..0x82EAE070)
	// 82EAE054: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EAE058: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EAE05C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EAE060: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EAE064: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EAE068: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82EAE06C: 4080FFE8  bge 0x82eae054
	if !ctx.cr[0].lt {
	pc = 0x82EAE054; continue 'dispatch;
	}
	pc = 0x82EAE070; continue 'dispatch;
            }
            0x82EAE070 => {
    //   block [0x82EAE070..0x82EAE078)
	// 82EAE070: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82EAE074: 48000008  b 0x82eae07c
	pc = 0x82EAE07C; continue 'dispatch;
            }
            0x82EAE078 => {
    //   block [0x82EAE078..0x82EAE07C)
	// 82EAE078: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EAE07C; continue 'dispatch;
            }
            0x82EAE07C => {
    //   block [0x82EAE07C..0x82EAE088)
	// 82EAE07C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAE080: 917D001C  stw r11, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EAE084: 480000AC  b 0x82eae130
	pc = 0x82EAE130; continue 'dispatch;
            }
            0x82EAE088 => {
    //   block [0x82EAE088..0x82EAE0BC)
	// 82EAE088: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE08C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAE090: 388BA31C  addi r4, r11, -0x5ce4
	ctx.r[4].s64 = ctx.r[11].s64 + -23780;
	// 82EAE094: 4BDFEABD  bl 0x82cacb50
	ctx.lr = 0x82EAE098;
	sub_82CACB50(ctx, base);
	// 82EAE098: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EAE09C: 40820020  bne 0x82eae0bc
	if !ctx.cr[0].eq {
	pc = 0x82EAE0BC; continue 'dispatch;
	}
	// 82EAE0A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAE0A4: 4BA5FC65  bl 0x8290dd08
	ctx.lr = 0x82EAE0A8;
	sub_8290DD08(ctx, base);
	// 82EAE0A8: 4BDFC319  bl 0x82caa3c0
	ctx.lr = 0x82EAE0AC;
	sub_82CAA3C0(ctx, base);
	// 82EAE0AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EAE0B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAE0B4: 917D0024  stw r11, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EAE0B8: 48000078  b 0x82eae130
	pc = 0x82EAE130; continue 'dispatch;
            }
            0x82EAE0BC => {
    //   block [0x82EAE0BC..0x82EAE118)
	// 82EAE0BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE0C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAE0C4: 388BA2F8  addi r4, r11, -0x5d08
	ctx.r[4].s64 = ctx.r[11].s64 + -23816;
	// 82EAE0C8: 4BDFEA89  bl 0x82cacb50
	ctx.lr = 0x82EAE0CC;
	sub_82CACB50(ctx, base);
	// 82EAE0CC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EAE0D0: 408200C4  bne 0x82eae194
	if !ctx.cr[0].eq {
	pc = 0x82EAE194; continue 'dispatch;
	}
	// 82EAE0D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE0D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAE0DC: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EAE0E0: 4BFD5E39  bl 0x82e83f18
	ctx.lr = 0x82EAE0E4;
	sub_82E83F18(ctx, base);
	// 82EAE0E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAE0E8: 41820044  beq 0x82eae12c
	if ctx.cr[0].eq {
	pc = 0x82EAE12C; continue 'dispatch;
	}
	// 82EAE0EC: 4BA5FC1D  bl 0x8290dd08
	ctx.lr = 0x82EAE0F0;
	sub_8290DD08(ctx, base);
	// 82EAE0F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAE0F4: 41820038  beq 0x82eae12c
	if ctx.cr[0].eq {
	pc = 0x82EAE12C; continue 'dispatch;
	}
	// 82EAE0F8: 4BFFFBE9  bl 0x82eadce0
	ctx.lr = 0x82EAE0FC;
	sub_82EADCE0(ctx, base);
	// 82EAE0FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAE100: 40820038  bne 0x82eae138
	if !ctx.cr[0].eq {
	pc = 0x82EAE138; continue 'dispatch;
	}
	// 82EAE104: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EAE108: 4BFFFAE9  bl 0x82eadbf0
	ctx.lr = 0x82EAE10C;
	sub_82EADBF0(ctx, base);
	// 82EAE10C: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EAE110: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAE114: 40990018  ble cr6, 0x82eae12c
	if !ctx.cr[6].gt {
	pc = 0x82EAE12C; continue 'dispatch;
	}
	pc = 0x82EAE118; continue 'dispatch;
            }
            0x82EAE118 => {
    //   block [0x82EAE118..0x82EAE12C)
	// 82EAE118: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EAE11C: 4BFFFAD5  bl 0x82eadbf0
	ctx.lr = 0x82EAE120;
	sub_82EADBF0(ctx, base);
	// 82EAE120: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EAE124: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EAE128: 4198FFF0  blt cr6, 0x82eae118
	if ctx.cr[6].lt {
	pc = 0x82EAE118; continue 'dispatch;
	}
	pc = 0x82EAE12C; continue 'dispatch;
            }
            0x82EAE12C => {
    //   block [0x82EAE12C..0x82EAE130)
	// 82EAE12C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EAE130; continue 'dispatch;
            }
            0x82EAE130 => {
    //   block [0x82EAE130..0x82EAE138)
	// 82EAE130: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EAE134: 4BDFB328  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EAE138 => {
    //   block [0x82EAE138..0x82EAE194)
	// 82EAE138: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE13C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAE140: 4E800421  bctrl
	ctx.lr = 0x82EAE144;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE144: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EAE148: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAE14C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EAE150: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EAE154: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE158: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAE15C: 4E800421  bctrl
	ctx.lr = 0x82EAE160;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE160: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAE164: 4182FFC8  beq 0x82eae12c
	if ctx.cr[0].eq {
	pc = 0x82EAE12C; continue 'dispatch;
	}
	// 82EAE168: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE16C: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE170: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EAE174: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EAE178: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAE17C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EAE180: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAE184: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAE188: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAE18C: 4BFD19E5  bl 0x82e7fb70
	ctx.lr = 0x82EAE190;
	sub_82E7FB70(ctx, base);
	// 82EAE190: 4BFFFD78  b 0x82eadf08
	pc = 0x82EADF08; continue 'dispatch;
            }
            0x82EAE194 => {
    //   block [0x82EAE194..0x82EAE1F0)
	// 82EAE194: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAE19C: 388BA308  addi r4, r11, -0x5cf8
	ctx.r[4].s64 = ctx.r[11].s64 + -23800;
	// 82EAE1A0: 4BDFE9B1  bl 0x82cacb50
	ctx.lr = 0x82EAE1A4;
	sub_82CACB50(ctx, base);
	// 82EAE1A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EAE1A8: 4082FF84  bne 0x82eae12c
	if !ctx.cr[0].eq {
	pc = 0x82EAE12C; continue 'dispatch;
	}
	// 82EAE1AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE1B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAE1B4: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EAE1B8: 4BFD5D61  bl 0x82e83f18
	ctx.lr = 0x82EAE1BC;
	sub_82E83F18(ctx, base);
	// 82EAE1BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAE1C0: 4182FF6C  beq 0x82eae12c
	if ctx.cr[0].eq {
	pc = 0x82EAE12C; continue 'dispatch;
	}
	// 82EAE1C4: 4BA5FB45  bl 0x8290dd08
	ctx.lr = 0x82EAE1C8;
	sub_8290DD08(ctx, base);
	// 82EAE1C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAE1CC: 4182FF60  beq 0x82eae12c
	if ctx.cr[0].eq {
	pc = 0x82EAE12C; continue 'dispatch;
	}
	// 82EAE1D0: 4BFFFBB1  bl 0x82eadd80
	ctx.lr = 0x82EAE1D4;
	sub_82EADD80(ctx, base);
	// 82EAE1D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAE1D8: 40820030  bne 0x82eae208
	if !ctx.cr[0].eq {
	pc = 0x82EAE208; continue 'dispatch;
	}
	// 82EAE1DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EAE1E0: 4BFFFA89  bl 0x82eadc68
	ctx.lr = 0x82EAE1E4;
	sub_82EADC68(ctx, base);
	// 82EAE1E4: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EAE1E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAE1EC: 4099FF40  ble cr6, 0x82eae12c
	if !ctx.cr[6].gt {
	pc = 0x82EAE12C; continue 'dispatch;
	}
	pc = 0x82EAE1F0; continue 'dispatch;
            }
            0x82EAE1F0 => {
    //   block [0x82EAE1F0..0x82EAE208)
	// 82EAE1F0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EAE1F4: 4BFFFA75  bl 0x82eadc68
	ctx.lr = 0x82EAE1F8;
	sub_82EADC68(ctx, base);
	// 82EAE1F8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EAE1FC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EAE200: 4198FFF0  blt cr6, 0x82eae1f0
	if ctx.cr[6].lt {
	pc = 0x82EAE1F0; continue 'dispatch;
	}
	// 82EAE204: 4BFFFF28  b 0x82eae12c
	pc = 0x82EAE12C; continue 'dispatch;
            }
            0x82EAE208 => {
    //   block [0x82EAE208..0x82EAE264)
	// 82EAE208: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE20C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EAE210: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAE214: 4E800421  bctrl
	ctx.lr = 0x82EAE218;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE218: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAE21C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EAE220: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EAE224: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE228: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAE22C: 4E800421  bctrl
	ctx.lr = 0x82EAE230;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE230: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAE234: 4182FEF8  beq 0x82eae12c
	if ctx.cr[0].eq {
	pc = 0x82EAE12C; continue 'dispatch;
	}
	// 82EAE238: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE23C: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAE240: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EAE244: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EAE248: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAE24C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EAE250: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAE254: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAE258: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAE25C: 4BFD1915  bl 0x82e7fb70
	ctx.lr = 0x82EAE260;
	sub_82E7FB70(ctx, base);
	// 82EAE260: 4BFFFCA8  b 0x82eadf08
	pc = 0x82EADF08; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAE268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAE268 size=184
    let mut pc: u32 = 0x82EAE268;
    'dispatch: loop {
        match pc {
            0x82EAE268 => {
    //   block [0x82EAE268..0x82EAE2C8)
	// 82EAE268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAE26C: 4BDFB195  bl 0x82ca9400
	ctx.lr = 0x82EAE270;
	sub_82CA93D0(ctx, base);
	// 82EAE270: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAE274: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAE278: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EAE27C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EAE280: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EAE284: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE288: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAE28C: 4BFDEFA5  bl 0x82e8d230
	ctx.lr = 0x82EAE290;
	sub_82E8D230(ctx, base);
	// 82EAE290: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE294: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EAE298: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE29C: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE2A0: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE2A4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE2A8: 4BFFC1E1  bl 0x82eaa488
	ctx.lr = 0x82EAE2AC;
	sub_82EAA488(ctx, base);
	// 82EAE2AC: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EAE2B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EAE2B4: 419A004C  beq cr6, 0x82eae300
	if ctx.cr[6].eq {
	pc = 0x82EAE300; continue 'dispatch;
	}
	// 82EAE2B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE2BC: 3B8BAFB4  addi r28, r11, -0x504c
	ctx.r[28].s64 = ctx.r[11].s64 + -20556;
	// 82EAE2C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE2C4: 3B6BAFB4  addi r27, r11, -0x504c
	ctx.r[27].s64 = ctx.r[11].s64 + -20556;
	pc = 0x82EAE2C8; continue 'dispatch;
            }
            0x82EAE2C8 => {
    //   block [0x82EAE2C8..0x82EAE300)
	// 82EAE2C8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE2CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAE2D0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EAE2D4: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE2D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EAE2DC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82EAE2E0: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EAE2E4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAE2E8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE2EC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAE2F0: 4BFFF7D1  bl 0x82eadac0
	ctx.lr = 0x82EAE2F4;
	sub_82EADAC0(ctx, base);
	// 82EAE2F4: 83FF000C  lwz r31, 0xc(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAE2F8: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAE2FC: 4082FFCC  bne 0x82eae2c8
	if !ctx.cr[0].eq {
	pc = 0x82EAE2C8; continue 'dispatch;
	}
	pc = 0x82EAE300; continue 'dispatch;
            }
            0x82EAE300 => {
    //   block [0x82EAE300..0x82EAE320)
	// 82EAE300: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EAE304: 4BFFD265  bl 0x82eab568
	ctx.lr = 0x82EAE308;
	sub_82EAB568(ctx, base);
	// 82EAE308: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EAE30C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EAE310: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAE314: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAE318: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EAE31C: 4BDFB134  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAE320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAE320 size=196
    let mut pc: u32 = 0x82EAE320;
    'dispatch: loop {
        match pc {
            0x82EAE320 => {
    //   block [0x82EAE320..0x82EAE358)
	// 82EAE320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAE324: 4BDFB0E1  bl 0x82ca9404
	ctx.lr = 0x82EAE328;
	sub_82CA93D0(ctx, base);
	// 82EAE328: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAE32C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE330: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAE334: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EAE338: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EAE33C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EAE340: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EAE344: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EAE348: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EAE34C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EAE350: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EAE354: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EAE358; continue 'dispatch;
            }
            0x82EAE358 => {
    //   block [0x82EAE358..0x82EAE384)
	// 82EAE358: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAE35C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAE360: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EAE364: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EAE368: 4082FFF0  bne 0x82eae358
	if !ctx.cr[0].eq {
	pc = 0x82EAE358; continue 'dispatch;
	}
	// 82EAE36C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAE370: 4BFFFAB1  bl 0x82eade20
	ctx.lr = 0x82EAE374;
	sub_82EADE20(ctx, base);
	// 82EAE374: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAE378: 4082000C  bne 0x82eae384
	if !ctx.cr[0].eq {
	pc = 0x82EAE384; continue 'dispatch;
	}
	// 82EAE37C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EAE380: 48000010  b 0x82eae390
	pc = 0x82EAE390; continue 'dispatch;
            }
            0x82EAE384 => {
    //   block [0x82EAE384..0x82EAE390)
	// 82EAE384: 4BFFF86D  bl 0x82eadbf0
	ctx.lr = 0x82EAE388;
	sub_82EADBF0(ctx, base);
	// 82EAE388: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EAE38C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EAE390; continue 'dispatch;
            }
            0x82EAE390 => {
    //   block [0x82EAE390..0x82EAE3B4)
	// 82EAE390: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EAE394: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EAE398: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EAE39C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAE3A0: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EAE3A4: 409A0010  bne cr6, 0x82eae3b4
	if !ctx.cr[6].eq {
	pc = 0x82EAE3B4; continue 'dispatch;
	}
	// 82EAE3A8: 4BFD16B1  bl 0x82e7fa58
	ctx.lr = 0x82EAE3AC;
	sub_82E7FA58(ctx, base);
	// 82EAE3AC: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EAE3B0: 4800000C  b 0x82eae3bc
	pc = 0x82EAE3BC; continue 'dispatch;
            }
            0x82EAE3B4 => {
    //   block [0x82EAE3B4..0x82EAE3BC)
	// 82EAE3B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAE3B8: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EAE3BC; continue 'dispatch;
            }
            0x82EAE3BC => {
    //   block [0x82EAE3BC..0x82EAE3D8)
	// 82EAE3BC: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAE3C0: 41820018  beq 0x82eae3d8
	if ctx.cr[0].eq {
	pc = 0x82EAE3D8; continue 'dispatch;
	}
	// 82EAE3C4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAE3C8: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EAE3CC: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EAE3D0: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EAE3D4: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EAE3D8; continue 'dispatch;
            }
            0x82EAE3D8 => {
    //   block [0x82EAE3D8..0x82EAE3E4)
	// 82EAE3D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAE3DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EAE3E0: 4BDFB074  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAE3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAE3E8 size=72
    let mut pc: u32 = 0x82EAE3E8;
    'dispatch: loop {
        match pc {
            0x82EAE3E8 => {
    //   block [0x82EAE3E8..0x82EAE430)
	// 82EAE3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAE3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAE3F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAE3F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAE3F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EAE3FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EAE400: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAE404: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAE408: 4BFFFF19  bl 0x82eae320
	ctx.lr = 0x82EAE40C;
	sub_82EAE320(ctx, base);
	// 82EAE40C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAE414: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EAE418: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAE41C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAE420: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAE424: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAE428: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAE42C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAE430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAE430 size=24
    let mut pc: u32 = 0x82EAE430;
    'dispatch: loop {
        match pc {
            0x82EAE430 => {
    //   block [0x82EAE430..0x82EAE448)
	// 82EAE430: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE434: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EAE438: 396BA380  addi r11, r11, -0x5c80
	ctx.r[11].s64 = ctx.r[11].s64 + -23680;
	// 82EAE43C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EAE440: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAE444: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAE448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EAE448 size=476
    let mut pc: u32 = 0x82EAE448;
    'dispatch: loop {
        match pc {
            0x82EAE448 => {
    //   block [0x82EAE448..0x82EAE508)
	// 82EAE448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAE44C: 4BDFAF99  bl 0x82ca93e4
	ctx.lr = 0x82EAE450;
	sub_82CA93D0(ctx, base);
	// 82EAE450: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAE454: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAE458: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAE45C: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82EAE460: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82EAE464: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAE46C: 409A01AC  bne cr6, 0x82eae618
	if !ctx.cr[6].eq {
	pc = 0x82EAE618; continue 'dispatch;
	}
	// 82EAE470: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EAE474: 419A01A4  beq cr6, 0x82eae618
	if ctx.cr[6].eq {
	pc = 0x82EAE618; continue 'dispatch;
	}
	// 82EAE478: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82EAE47C: 419A019C  beq cr6, 0x82eae618
	if ctx.cr[6].eq {
	pc = 0x82EAE618; continue 'dispatch;
	}
	// 82EAE480: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82EAE484: 419A0194  beq cr6, 0x82eae618
	if ctx.cr[6].eq {
	pc = 0x82EAE618; continue 'dispatch;
	}
	// 82EAE488: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EAE48C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAE490: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82EAE494: 40990184  ble cr6, 0x82eae618
	if !ctx.cr[6].gt {
	pc = 0x82EAE618; continue 'dispatch;
	}
	// 82EAE498: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82EAE49C: 4099017C  ble cr6, 0x82eae618
	if !ctx.cr[6].gt {
	pc = 0x82EAE618; continue 'dispatch;
	}
	// 82EAE4A0: FF030000  fcmpu cr6, f3, f0
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[0].f64);
	// 82EAE4A4: 40990174  ble cr6, 0x82eae618
	if !ctx.cr[6].gt {
	pc = 0x82EAE618; continue 'dispatch;
	}
	// 82EAE4A8: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 82EAE4AC: D03F0018  stfs f1, 0x18(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EAE4B0: D05F001C  stfs f2, 0x1c(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EAE4B4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EAE4B8: 6175FFFF  ori r21, r11, 0xffff
	ctx.r[21].u64 = ctx.r[11].u64 | 65535;
	// 82EAE4BC: D07F0020  stfs f3, 0x20(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EAE4C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EAE4C4: D09F0030  stfs f4, 0x30(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EAE4C8: D0BF0034  stfs f5, 0x34(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EAE4CC: 92FF0010  stw r23, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 82EAE4D0: D0DF0038  stfs f6, 0x38(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EAE4D4: 931F0014  stw r24, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[24].u32 ) };
	// 82EAE4D8: 3A60FFFF  li r19, -1
	ctx.r[19].s64 = -1;
	// 82EAE4DC: 7F1EA840  cmplw cr6, r30, r21
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82EAE4E0: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAE4E4: 57C3103A  slwi r3, r30, 2
	ctx.r[3].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EAE4E8: EDA00824  fdivs f13, f0, f1
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 82EAE4EC: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EAE4F0: ED801024  fdivs f12, f0, f2
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[2].f64) as f32) as f64;
	// 82EAE4F4: D19F0028  stfs f12, 0x28(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EAE4F8: EC001824  fdivs f0, f0, f3
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[3].f64) as f32) as f64;
	// 82EAE4FC: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EAE500: 40990008  ble cr6, 0x82eae508
	if !ctx.cr[6].gt {
	pc = 0x82EAE508; continue 'dispatch;
	}
	// 82EAE504: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	pc = 0x82EAE508; continue 'dispatch;
            }
            0x82EAE508 => {
    //   block [0x82EAE508..0x82EAE528)
	// 82EAE508: 4B768421  bl 0x82616928
	ctx.lr = 0x82EAE50C;
	sub_82616928(ctx, base);
	// 82EAE50C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EAE510: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82EAE514: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82EAE518: 419A00C8  beq cr6, 0x82eae5e0
	if ctx.cr[6].eq {
	pc = 0x82EAE5E0; continue 'dispatch;
	}
	// 82EAE51C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE520: 7EDAB378  mr r26, r22
	ctx.r[26].u64 = ctx.r[22].u64;
	// 82EAE524: 3A8BAFB4  addi r20, r11, -0x504c
	ctx.r[20].s64 = ctx.r[11].s64 + -20556;
	pc = 0x82EAE528; continue 'dispatch;
            }
            0x82EAE528 => {
    //   block [0x82EAE528..0x82EAE538)
	// 82EAE528: 7F17A840  cmplw cr6, r23, r21
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82EAE52C: 56E3103A  slwi r3, r23, 2
	ctx.r[3].u32 = ctx.r[23].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EAE530: 40990008  ble cr6, 0x82eae538
	if !ctx.cr[6].gt {
	pc = 0x82EAE538; continue 'dispatch;
	}
	// 82EAE534: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	pc = 0x82EAE538; continue 'dispatch;
            }
            0x82EAE538 => {
    //   block [0x82EAE538..0x82EAE554)
	// 82EAE538: 4B7683F1  bl 0x82616928
	ctx.lr = 0x82EAE53C;
	sub_82616928(ctx, base);
	// 82EAE53C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE540: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82EAE544: 7C7A592E  stwx r3, r26, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 82EAE548: 419A008C  beq cr6, 0x82eae5d4
	if ctx.cr[6].eq {
	pc = 0x82EAE5D4; continue 'dispatch;
	}
	// 82EAE54C: 7EDBB378  mr r27, r22
	ctx.r[27].u64 = ctx.r[22].u64;
	// 82EAE550: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	pc = 0x82EAE554; continue 'dispatch;
            }
            0x82EAE554 => {
    //   block [0x82EAE554..0x82EAE564)
	// 82EAE554: 7F18A840  cmplw cr6, r24, r21
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82EAE558: 5703103A  slwi r3, r24, 2
	ctx.r[3].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EAE55C: 40990008  ble cr6, 0x82eae564
	if !ctx.cr[6].gt {
	pc = 0x82EAE564; continue 'dispatch;
	}
	// 82EAE560: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	pc = 0x82EAE564; continue 'dispatch;
            }
            0x82EAE564 => {
    //   block [0x82EAE564..0x82EAE584)
	// 82EAE564: 4B7683C5  bl 0x82616928
	ctx.lr = 0x82EAE568;
	sub_82616928(ctx, base);
	// 82EAE568: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE56C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82EAE570: 7D7A582E  lwzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAE574: 7C6BD92E  stwx r3, r11, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[3].u32) };
	// 82EAE578: 419A0050  beq cr6, 0x82eae5c8
	if ctx.cr[6].eq {
	pc = 0x82EAE5C8; continue 'dispatch;
	}
	// 82EAE57C: 7EDCB378  mr r28, r22
	ctx.r[28].u64 = ctx.r[22].u64;
	// 82EAE580: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	pc = 0x82EAE584; continue 'dispatch;
            }
            0x82EAE584 => {
    //   block [0x82EAE584..0x82EAE5A8)
	// 82EAE584: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EAE588: 4B7683A1  bl 0x82616928
	ctx.lr = 0x82EAE58C;
	sub_82616928(ctx, base);
	// 82EAE58C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAE590: 41820018  beq 0x82eae5a8
	if ctx.cr[0].eq {
	pc = 0x82EAE5A8; continue 'dispatch;
	}
	// 82EAE594: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EAE598: 92C30004  stw r22, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	// 82EAE59C: 92830000  stw r20, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	// 82EAE5A0: 9AC30008  stb r22, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[22].u8 ) };
	// 82EAE5A4: 48000008  b 0x82eae5ac
	pc = 0x82EAE5AC; continue 'dispatch;
            }
            0x82EAE5A8 => {
    //   block [0x82EAE5A8..0x82EAE5AC)
	// 82EAE5A8: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x82EAE5AC; continue 'dispatch;
            }
            0x82EAE5AC => {
    //   block [0x82EAE5AC..0x82EAE5C8)
	// 82EAE5AC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE5B0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82EAE5B4: 7D5A502E  lwzx r10, r26, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EAE5B8: 7D4AD82E  lwzx r10, r10, r27
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EAE5BC: 7D6AE12E  stwx r11, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[11].u32) };
	// 82EAE5C0: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EAE5C4: 4082FFC0  bne 0x82eae584
	if !ctx.cr[0].eq {
	pc = 0x82EAE584; continue 'dispatch;
	}
	pc = 0x82EAE5C8; continue 'dispatch;
            }
            0x82EAE5C8 => {
    //   block [0x82EAE5C8..0x82EAE5D4)
	// 82EAE5C8: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 82EAE5CC: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EAE5D0: 4082FF84  bne 0x82eae554
	if !ctx.cr[0].eq {
	pc = 0x82EAE554; continue 'dispatch;
	}
	pc = 0x82EAE5D4; continue 'dispatch;
            }
            0x82EAE5D4 => {
    //   block [0x82EAE5D4..0x82EAE5E0)
	// 82EAE5D4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EAE5D8: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82EAE5DC: 4082FF4C  bne 0x82eae528
	if !ctx.cr[0].eq {
	pc = 0x82EAE528; continue 'dispatch;
	}
	pc = 0x82EAE5E0; continue 'dispatch;
            }
            0x82EAE5E0 => {
    //   block [0x82EAE5E0..0x82EAE60C)
	// 82EAE5E0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAE5E4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAE5E8: 409A0024  bne cr6, 0x82eae60c
	if !ctx.cr[6].eq {
	pc = 0x82EAE60C; continue 'dispatch;
	}
	// 82EAE5EC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAE5F0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAE5F4: 409A0018  bne cr6, 0x82eae60c
	if !ctx.cr[6].eq {
	pc = 0x82EAE60C; continue 'dispatch;
	}
	// 82EAE5F8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAE5FC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAE600: 409A000C  bne cr6, 0x82eae60c
	if !ctx.cr[6].eq {
	pc = 0x82EAE60C; continue 'dispatch;
	}
	// 82EAE604: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82EAE608: 48000008  b 0x82eae610
	pc = 0x82EAE610; continue 'dispatch;
            }
            0x82EAE60C => {
    //   block [0x82EAE60C..0x82EAE610)
	// 82EAE60C: 9ADF0004  stb r22, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[22].u8 ) };
	pc = 0x82EAE610; continue 'dispatch;
            }
            0x82EAE610 => {
    //   block [0x82EAE610..0x82EAE618)
	// 82EAE610: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAE614: 48000008  b 0x82eae61c
	pc = 0x82EAE61C; continue 'dispatch;
            }
            0x82EAE618 => {
    //   block [0x82EAE618..0x82EAE61C)
	// 82EAE618: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EAE61C; continue 'dispatch;
            }
            0x82EAE61C => {
    //   block [0x82EAE61C..0x82EAE624)
	// 82EAE61C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EAE620: 4BDFAE14  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAE628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAE628 size=224
    let mut pc: u32 = 0x82EAE628;
    'dispatch: loop {
        match pc {
            0x82EAE628 => {
    //   block [0x82EAE628..0x82EAE684)
	// 82EAE628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAE62C: 4BDFADD9  bl 0x82ca9404
	ctx.lr = 0x82EAE630;
	sub_82CA93D0(ctx, base);
	// 82EAE630: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 82EAE634: 9421EF50  stwu r1, -0x10b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-4272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAE638: 3FE08334  lis r31, -0x7ccc
	ctx.r[31].s64 = -2093744128;
	// 82EAE63C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EAE640: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EAE644: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EAE648: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAE64C: 38A01000  li r5, 0x1000
	ctx.r[5].s64 = 4096;
	// 82EAE650: 837FFEF0  lwz r27, -0x110(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82EAE654: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82EAE658: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EAE65C: 4BFD6CCD  bl 0x82e85328
	ctx.lr = 0x82EAE660;
	sub_82E85328(ctx, base);
	// 82EAE660: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82EAE664: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82EAE668: 917FFEF0  stw r11, -0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-272 as u32), ctx.r[11].u32 ) };
	// 82EAE66C: 4B7682BD  bl 0x82616928
	ctx.lr = 0x82EAE670;
	sub_82616928(ctx, base);
	// 82EAE670: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAE674: 41820010  beq 0x82eae684
	if ctx.cr[0].eq {
	pc = 0x82EAE684; continue 'dispatch;
	}
	// 82EAE678: 4BFD5B91  bl 0x82e84208
	ctx.lr = 0x82EAE67C;
	sub_82E84208(ctx, base);
	// 82EAE67C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EAE680: 48000008  b 0x82eae688
	pc = 0x82EAE688; continue 'dispatch;
            }
            0x82EAE684 => {
    //   block [0x82EAE684..0x82EAE688)
	// 82EAE684: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82EAE688; continue 'dispatch;
            }
            0x82EAE688 => {
    //   block [0x82EAE688..0x82EAE708)
	// 82EAE688: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EAE68C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAE690: 388B4DAC  addi r4, r11, 0x4dac
	ctx.r[4].s64 = ctx.r[11].s64 + 19884;
	// 82EAE694: 4BFD5A9D  bl 0x82e84130
	ctx.lr = 0x82EAE698;
	sub_82E84130(ctx, base);
	// 82EAE698: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EAE69C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAE6A0: 4BFD5AC9  bl 0x82e84168
	ctx.lr = 0x82EAE6A4;
	sub_82E84168(ctx, base);
	// 82EAE6A4: 937FFEF0  stw r27, -0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-272 as u32), ctx.r[27].u32 ) };
	// 82EAE6A8: 3FE08334  lis r31, -0x7ccc
	ctx.r[31].s64 = -2093744128;
	// 82EAE6AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EAE6B0: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EAE6B4: 838B0004  lwz r28, 4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE6B8: 4BFDB691  bl 0x82e89d48
	ctx.lr = 0x82EAE6BC;
	sub_82E89D48(ctx, base);
	// 82EAE6BC: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EAE6C0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82EAE6C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EAE6C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EAE6CC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EAE6D0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAE6D4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAE6D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAE6DC: 4E800421  bctrl
	ctx.lr = 0x82EAE6E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE6E0: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EAE6E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EAE6E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EAE6EC: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EAE6F0: 4BFDB669  bl 0x82e89d58
	ctx.lr = 0x82EAE6F4;
	sub_82E89D58(ctx, base);
	// 82EAE6F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EAE6F8: 4BFD6611  bl 0x82e84d08
	ctx.lr = 0x82EAE6FC;
	sub_82E84D08(ctx, base);
	// 82EAE6FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAE700: 382110B0  addi r1, r1, 0x10b0
	ctx.r[1].s64 = ctx.r[1].s64 + 4272;
	// 82EAE704: 4BDFAD50  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAE708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EAE708 size=1396
    let mut pc: u32 = 0x82EAE708;
    'dispatch: loop {
        match pc {
            0x82EAE708 => {
    //   block [0x82EAE708..0x82EAE728)
	// 82EAE708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAE70C: 4BDFACE1  bl 0x82ca93ec
	ctx.lr = 0x82EAE710;
	sub_82CA93D0(ctx, base);
	// 82EAE710: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAE714: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EAE718: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EAE71C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE720: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAE724: 409A0010  bne cr6, 0x82eae734
	if !ctx.cr[6].eq {
	pc = 0x82EAE734; continue 'dispatch;
	}
	pc = 0x82EAE728; continue 'dispatch;
            }
            0x82EAE728 => {
    //   block [0x82EAE728..0x82EAE72C)
	// 82EAE728: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EAE72C; continue 'dispatch;
            }
            0x82EAE72C => {
    //   block [0x82EAE72C..0x82EAE734)
	// 82EAE72C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EAE730: 4BDFAD0C  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EAE734 => {
    //   block [0x82EAE734..0x82EAE7AC)
	// 82EAE734: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAE738: 3BCBDAC0  addi r30, r11, -0x2540
	ctx.r[30].s64 = ctx.r[11].s64 + -9536;
	// 82EAE73C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82EAE740: 388B8EA4  addi r4, r11, -0x715c
	ctx.r[4].s64 = ctx.r[11].s64 + -29020;
	// 82EAE744: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EAE748: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAE74C: 4E800421  bctrl
	ctx.lr = 0x82EAE750;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE750: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EAE754: 4182FFD4  beq 0x82eae728
	if ctx.cr[0].eq {
	pc = 0x82EAE728; continue 'dispatch;
	}
	// 82EAE758: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE75C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE760: 386BA368  addi r3, r11, -0x5c98
	ctx.r[3].s64 = ctx.r[11].s64 + -23704;
	// 82EAE764: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE768: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 82EAE76C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EAE770: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAE774: 4E800421  bctrl
	ctx.lr = 0x82EAE778;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE778: 2B030014  cmplwi cr6, r3, 0x14
	ctx.cr[6].compare_u32(ctx.r[3].u32, 20 as u32, &mut ctx.xer);
	// 82EAE77C: 409AFFAC  bne cr6, 0x82eae728
	if !ctx.cr[6].eq {
	pc = 0x82EAE728; continue 'dispatch;
	}
	// 82EAE780: 3EA00100  lis r21, 0x100
	ctx.r[21].s64 = 16777216;
	// 82EAE784: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE788: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE78C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE790: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EAE798: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 82EAE79C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAE7A0: 4E800421  bctrl
	ctx.lr = 0x82EAE7A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE7A4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE7A8: 419A0018  beq cr6, 0x82eae7c0
	if ctx.cr[6].eq {
	pc = 0x82EAE7C0; continue 'dispatch;
	}
            }
            0x82EAE7AC => {
    //   block [0x82EAE7AC..0x82EAE7C0)
	// 82EAE7AC: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAE7B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAE7B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAE7B8: 4E800421  bctrl
	ctx.lr = 0x82EAE7BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE7BC: 4BFFFF6C  b 0x82eae728
	pc = 0x82EAE728; continue 'dispatch;
            }
            0x82EAE7C0 => {
    //   block [0x82EAE7C0..0x82EAEB7C)
	// 82EAE7C0: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAE7C4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE7C8: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE7CC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE7D0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE7D4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAE7D8: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAE7DC: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAE7E0: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAE7E4: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAE7E8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE7EC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAE7F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EAE7F4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAE7F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAE7FC: 4E800421  bctrl
	ctx.lr = 0x82EAE800;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE800: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE804: 409AFFA8  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAE808: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAE80C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE810: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE814: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE818: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE81C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAE820: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAE824: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAE828: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAE82C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAE830: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE834: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAE838: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EAE83C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAE840: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAE844: 4E800421  bctrl
	ctx.lr = 0x82EAE848;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE848: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE84C: 409AFF60  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAE850: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAE854: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE858: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE85C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE860: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE864: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAE868: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAE86C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAE870: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAE874: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAE878: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE87C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAE880: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EAE884: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAE888: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAE88C: 4E800421  bctrl
	ctx.lr = 0x82EAE890;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE890: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE894: 409AFF18  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAE898: C01D0018  lfs f0, 0x18(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAE89C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE8A0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAE8A4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE8A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE8AC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE8B0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EAE8B4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE8B8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE8BC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAE8C0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAE8C4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAE8C8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAE8CC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAE8D0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAE8D4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EAE8D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAE8DC: 4E800421  bctrl
	ctx.lr = 0x82EAE8E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE8E0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE8E4: 409AFEC8  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAE8E8: C01D001C  lfs f0, 0x1c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAE8EC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE8F0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAE8F4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE8F8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE8FC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE900: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EAE904: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE908: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE90C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAE910: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAE914: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAE918: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAE91C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAE920: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAE924: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EAE928: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAE92C: 4E800421  bctrl
	ctx.lr = 0x82EAE930;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE930: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE934: 409AFE78  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAE938: C01D0020  lfs f0, 0x20(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAE93C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE940: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAE944: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE948: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE94C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE950: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82EAE954: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE958: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE95C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAE960: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAE964: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAE968: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAE96C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAE970: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAE974: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EAE978: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAE97C: 4E800421  bctrl
	ctx.lr = 0x82EAE980;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE980: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE984: 409AFE28  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAE988: C01D0024  lfs f0, 0x24(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAE98C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE990: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAE994: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE998: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE99C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE9A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EAE9A4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE9A8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE9AC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAE9B0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAE9B4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAE9B8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAE9BC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAE9C0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAE9C4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EAE9C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAE9CC: 4E800421  bctrl
	ctx.lr = 0x82EAE9D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE9D0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE9D4: 409AFDD8  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAE9D8: C01D0028  lfs f0, 0x28(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAE9DC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE9E0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAE9E4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE9E8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE9EC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE9F0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EAE9F4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE9F8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE9FC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAEA00: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEA04: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEA08: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAEA0C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEA10: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAEA14: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EAEA18: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAEA1C: 4E800421  bctrl
	ctx.lr = 0x82EAEA20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEA20: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAEA24: 409AFD88  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAEA28: C01D002C  lfs f0, 0x2c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAEA2C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEA30: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAEA34: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAEA38: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAEA3C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAEA40: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EAEA44: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEA48: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEA4C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAEA50: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEA54: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEA58: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAEA5C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEA60: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAEA64: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EAEA68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAEA6C: 4E800421  bctrl
	ctx.lr = 0x82EAEA70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEA70: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAEA74: 409AFD38  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAEA78: C01D0030  lfs f0, 0x30(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAEA7C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEA80: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAEA84: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAEA88: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAEA8C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAEA90: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82EAEA94: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEA98: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEA9C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAEAA0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEAA4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEAA8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAEAAC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEAB0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAEAB4: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EAEAB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAEABC: 4E800421  bctrl
	ctx.lr = 0x82EAEAC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEAC0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAEAC4: 409AFCE8  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAEAC8: C01D0034  lfs f0, 0x34(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAEACC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEAD0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAEAD4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAEAD8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAEADC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAEAE0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EAEAE4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEAE8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEAEC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAEAF0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEAF4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEAF8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAEAFC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEB00: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAEB04: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EAEB08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAEB0C: 4E800421  bctrl
	ctx.lr = 0x82EAEB10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEB10: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAEB14: 409AFC98  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAEB18: C01D0038  lfs f0, 0x38(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAEB1C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEB20: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAEB24: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAEB28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAEB2C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAEB30: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82EAEB34: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEB38: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEB3C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAEB40: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEB44: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEB48: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAEB4C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEB50: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAEB54: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EAEB58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAEB5C: 4E800421  bctrl
	ctx.lr = 0x82EAEB60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEB60: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAEB64: 409AFC48  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAEB68: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAEB6C: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82EAEB70: 7ED7B378  mr r23, r22
	ctx.r[23].u64 = ctx.r[22].u64;
	// 82EAEB74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAEB78: 409900E0  ble cr6, 0x82eaec58
	if !ctx.cr[6].gt {
	pc = 0x82EAEC58; continue 'dispatch;
	}
            }
            0x82EAEB7C => {
    //   block [0x82EAEB7C..0x82EAEB8C)
	// 82EAEB7C: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAEB80: 7ED9B378  mr r25, r22
	ctx.r[25].u64 = ctx.r[22].u64;
	// 82EAEB84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAEB88: 409900C0  ble cr6, 0x82eaec48
	if !ctx.cr[6].gt {
	pc = 0x82EAEC48; continue 'dispatch;
	}
	pc = 0x82EAEB8C; continue 'dispatch;
            }
            0x82EAEB8C => {
    //   block [0x82EAEB8C..0x82EAEBA8)
	// 82EAEB8C: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAEB90: 7ED8B378  mr r24, r22
	ctx.r[24].u64 = ctx.r[22].u64;
	// 82EAEB94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAEB98: 409900A0  ble cr6, 0x82eaec38
	if !ctx.cr[6].gt {
	pc = 0x82EAEC38; continue 'dispatch;
	}
	// 82EAEB9C: 56FB103A  slwi r27, r23, 2
	ctx.r[27].u32 = ctx.r[23].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82EAEBA0: 573A103A  slwi r26, r25, 2
	ctx.r[26].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82EAEBA4: 7EDCB378  mr r28, r22
	ctx.r[28].u64 = ctx.r[22].u64;
	pc = 0x82EAEBA8; continue 'dispatch;
            }
            0x82EAEBA8 => {
    //   block [0x82EAEBA8..0x82EAEBF0)
	// 82EAEBA8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAEBAC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAEBB0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAEBB4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAEBB8: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAEBBC: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EAEBC0: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EAEBC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAEBC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAEBCC: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEBD0: 409A0020  bne cr6, 0x82eaebf0
	if !ctx.cr[6].eq {
	pc = 0x82EAEBF0; continue 'dispatch;
	}
	// 82EAEBD4: 92C10088  stw r22, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[22].u32 ) };
	// 82EAEBD8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82EAEBDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEBE0: 4E800421  bctrl
	ctx.lr = 0x82EAEBE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEBE4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAEBE8: 409AFBC4  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAEBEC: 48000038  b 0x82eaec24
	pc = 0x82EAEC24; continue 'dispatch;
            }
            0x82EAEBF0 => {
    //   block [0x82EAEBF0..0x82EAEC24)
	// 82EAEBF0: 92A1008C  stw r21, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[21].u32 ) };
	// 82EAEBF4: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82EAEBF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEBFC: 4E800421  bctrl
	ctx.lr = 0x82EAEC00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEC00: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAEC04: 409A005C  bne cr6, 0x82eaec60
	if !ctx.cr[6].eq {
	pc = 0x82EAEC60; continue 'dispatch;
	}
	// 82EAEC08: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAEC0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAEC10: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAEC14: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EAEC18: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EAEC1C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAEC20: 4BFF5B39  bl 0x82ea4758
	ctx.lr = 0x82EAEC24;
	sub_82EA4758(ctx, base);
            }
            0x82EAEC24 => {
    //   block [0x82EAEC24..0x82EAEC38)
	// 82EAEC24: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAEC28: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82EAEC2C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EAEC30: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAEC34: 4198FF74  blt cr6, 0x82eaeba8
	if ctx.cr[6].lt {
	pc = 0x82EAEBA8; continue 'dispatch;
	}
	pc = 0x82EAEC38; continue 'dispatch;
            }
            0x82EAEC38 => {
    //   block [0x82EAEC38..0x82EAEC48)
	// 82EAEC38: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAEC3C: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82EAEC40: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAEC44: 4198FF48  blt cr6, 0x82eaeb8c
	if ctx.cr[6].lt {
	pc = 0x82EAEB8C; continue 'dispatch;
	}
	pc = 0x82EAEC48; continue 'dispatch;
            }
            0x82EAEC48 => {
    //   block [0x82EAEC48..0x82EAEC58)
	// 82EAEC48: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAEC4C: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82EAEC50: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAEC54: 4198FF28  blt cr6, 0x82eaeb7c
	if ctx.cr[6].lt {
	pc = 0x82EAEB7C; continue 'dispatch;
	}
	pc = 0x82EAEC58; continue 'dispatch;
            }
            0x82EAEC58 => {
    //   block [0x82EAEC58..0x82EAEC60)
	// 82EAEC58: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82EAEC5C: 48000008  b 0x82eaec64
	pc = 0x82EAEC64; continue 'dispatch;
            }
            0x82EAEC60 => {
    //   block [0x82EAEC60..0x82EAEC64)
	// 82EAEC60: 7EDDB378  mr r29, r22
	ctx.r[29].u64 = ctx.r[22].u64;
	pc = 0x82EAEC64; continue 'dispatch;
            }
            0x82EAEC64 => {
    //   block [0x82EAEC64..0x82EAEC7C)
	// 82EAEC64: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAEC68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEC6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEC70: 4E800421  bctrl
	ctx.lr = 0x82EAEC74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEC74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EAEC78: 4BFFFAB4  b 0x82eae72c
	pc = 0x82EAE72C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAEC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAEC80 size=316
    let mut pc: u32 = 0x82EAEC80;
    'dispatch: loop {
        match pc {
            0x82EAEC80 => {
    //   block [0x82EAEC80..0x82EAECB8)
	// 82EAEC80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAEC84: 4BDFA76D  bl 0x82ca93f0
	ctx.lr = 0x82EAEC88;
	sub_82CA93D0(ctx, base);
	// 82EAEC88: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAEC8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAEC90: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAEC94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAEC98: 419A011C  beq cr6, 0x82eaedb4
	if ctx.cr[6].eq {
	pc = 0x82EAEDB4; continue 'dispatch;
	}
	// 82EAEC9C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAECA0: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EAECA4: 3F008330  lis r24, -0x7cd0
	ctx.r[24].s64 = -2094006272;
	// 82EAECA8: 7EF6BB78  mr r22, r23
	ctx.r[22].u64 = ctx.r[23].u64;
	// 82EAECAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAECB0: 409900F0  ble cr6, 0x82eaeda0
	if !ctx.cr[6].gt {
	pc = 0x82EAEDA0; continue 'dispatch;
	}
	// 82EAECB4: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	pc = 0x82EAECB8; continue 'dispatch;
            }
            0x82EAECB8 => {
    //   block [0x82EAECB8..0x82EAECCC)
	// 82EAECB8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAECBC: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 82EAECC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAECC4: 409900B4  ble cr6, 0x82eaed78
	if !ctx.cr[6].gt {
	pc = 0x82EAED78; continue 'dispatch;
	}
	// 82EAECC8: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	pc = 0x82EAECCC; continue 'dispatch;
            }
            0x82EAECCC => {
    //   block [0x82EAECCC..0x82EAECE0)
	// 82EAECCC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAECD0: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 82EAECD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAECD8: 40990074  ble cr6, 0x82eaed4c
	if !ctx.cr[6].gt {
	pc = 0x82EAED4C; continue 'dispatch;
	}
	// 82EAECDC: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	pc = 0x82EAECE0; continue 'dispatch;
            }
            0x82EAECE0 => {
    //   block [0x82EAECE0..0x82EAED20)
	// 82EAECE0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAECE4: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAECE8: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EAECEC: 7FCBE82E  lwzx r30, r11, r29
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EAECF0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAECF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAECF8: 41820028  beq 0x82eaed20
	if ctx.cr[0].eq {
	pc = 0x82EAED20; continue 'dispatch;
	}
	// 82EAECFC: 897E0008  lbz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAED00: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAED04: 409A001C  bne cr6, 0x82eaed20
	if !ctx.cr[6].eq {
	pc = 0x82EAED20; continue 'dispatch;
	}
	// 82EAED08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAED0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EAED10: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAED14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAED18: 4E800421  bctrl
	ctx.lr = 0x82EAED1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAED1C: 92FE0004  stw r23, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
            }
            0x82EAED20 => {
    //   block [0x82EAED20..0x82EAED4C)
	// 82EAED20: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAED24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EAED28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAED2C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAED30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAED34: 4E800421  bctrl
	ctx.lr = 0x82EAED38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAED38: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAED3C: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EAED40: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EAED44: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAED48: 4198FF98  blt cr6, 0x82eaece0
	if ctx.cr[6].lt {
	pc = 0x82EAECE0; continue 'dispatch;
	}
            }
            0x82EAED4C => {
    //   block [0x82EAED4C..0x82EAED78)
	// 82EAED4C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAED50: 8158DAB4  lwz r10, -0x254c(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAED54: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAED58: 7C6BE02E  lwzx r3, r11, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EAED5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAED60: 4E800421  bctrl
	ctx.lr = 0x82EAED64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAED64: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAED68: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82EAED6C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EAED70: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAED74: 4198FF58  blt cr6, 0x82eaeccc
	if ctx.cr[6].lt {
	pc = 0x82EAECCC; continue 'dispatch;
	}
            }
            0x82EAED78 => {
    //   block [0x82EAED78..0x82EAEDA0)
	// 82EAED78: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAED7C: 7C7B582E  lwzx r3, r27, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAED80: 8178DAB4  lwz r11, -0x254c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAED84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAED88: 4E800421  bctrl
	ctx.lr = 0x82EAED8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAED8C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAED90: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 82EAED94: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EAED98: 7F165840  cmplw cr6, r22, r11
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAED9C: 4198FF1C  blt cr6, 0x82eaecb8
	if ctx.cr[6].lt {
	pc = 0x82EAECB8; continue 'dispatch;
	}
            }
            0x82EAEDA0 => {
    //   block [0x82EAEDA0..0x82EAEDB4)
	// 82EAEDA0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAEDA4: 8178DAB4  lwz r11, -0x254c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAEDA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEDAC: 4E800421  bctrl
	ctx.lr = 0x82EAEDB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEDB0: 92FF0008  stw r23, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
            }
            0x82EAEDB4 => {
    //   block [0x82EAEDB4..0x82EAEDBC)
	// 82EAEDB4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EAEDB8: 4BDFA688  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAEDC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAEDC0 size=4
    let mut pc: u32 = 0x82EAEDC0;
    'dispatch: loop {
        match pc {
            0x82EAEDC0 => {
    //   block [0x82EAEDC0..0x82EAEDC4)
	// 82EAEDC0: 4BFFFEC0  b 0x82eaec80
	sub_82EAEC80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAEDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAEDC8 size=68
    let mut pc: u32 = 0x82EAEDC8;
    'dispatch: loop {
        match pc {
            0x82EAEDC8 => {
    //   block [0x82EAEDC8..0x82EAEE0C)
	// 82EAEDC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAEDCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAEDD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAEDD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAEDD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAEDDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAEDE0: 396BA380  addi r11, r11, -0x5c80
	ctx.r[11].s64 = ctx.r[11].s64 + -23680;
	// 82EAEDE4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAEDE8: 4BFFFE99  bl 0x82eaec80
	ctx.lr = 0x82EAEDEC;
	sub_82EAEC80(ctx, base);
	// 82EAEDEC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EAEDF0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EAEDF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAEDF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAEDFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAEE00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAEE04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAEE08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAEE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAEE10 size=1852
    let mut pc: u32 = 0x82EAEE10;
    'dispatch: loop {
        match pc {
            0x82EAEE10 => {
    //   block [0x82EAEE10..0x82EAF2D4)
	// 82EAEE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAEE14: 4BDFA5C1  bl 0x82ca93d4
	ctx.lr = 0x82EAEE18;
	sub_82CA93D0(ctx, base);
	// 82EAEE18: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAEE1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EAEE20: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EAEE24: 4BFFFE5D  bl 0x82eaec80
	ctx.lr = 0x82EAEE28;
	sub_82EAEC80(ctx, base);
	// 82EAEE28: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EAEE2C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAEE30: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EAEE34: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAEE38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEE3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEE40: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAEE44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEE48: 4E800421  bctrl
	ctx.lr = 0x82EAEE4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEE4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAEE50: 418206F0  beq 0x82eaf540
	if ctx.cr[0].eq {
	pc = 0x82EAF540; continue 'dispatch;
	}
	// 82EAEE54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEE58: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 82EAEE5C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EAEE60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAEE64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEE68: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAEE6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEE70: 4E800421  bctrl
	ctx.lr = 0x82EAEE74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEE74: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEE78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EAEE7C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAEE80: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAEE84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAEE88: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAEE8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEE90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEE94: 4E800421  bctrl
	ctx.lr = 0x82EAEE98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEE98: 2B1C0014  cmplwi cr6, r28, 0x14
	ctx.cr[6].compare_u32(ctx.r[28].u32, 20 as u32, &mut ctx.xer);
	// 82EAEE9C: 409A068C  bne cr6, 0x82eaf528
	if !ctx.cr[6].eq {
	pc = 0x82EAF528; continue 'dispatch;
	}
	// 82EAEEA0: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAEEA4: 409A0684  bne cr6, 0x82eaf528
	if !ctx.cr[6].eq {
	pc = 0x82EAF528; continue 'dispatch;
	}
	// 82EAEEA8: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 82EAEEAC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAEEB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EAEEB4: 388BA368  addi r4, r11, -0x5c98
	ctx.r[4].s64 = ctx.r[11].s64 + -23704;
	// 82EAEEB8: 9A210074  stb r17, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[17].u8 ) };
	// 82EAEEBC: 4BDFDC95  bl 0x82cacb50
	ctx.lr = 0x82EAEEC0;
	sub_82CACB50(ctx, base);
	// 82EAEEC0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EAEEC4: 40820664  bne 0x82eaf528
	if !ctx.cr[0].eq {
	pc = 0x82EAF528; continue 'dispatch;
	}
	// 82EAEEC8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EAEECC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAEED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEED4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAEED8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEEDC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEEE0: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEEE4: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAEEE8: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEEEC: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAEEF0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAEEF4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EAEEF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEEFC: 409A0638  bne cr6, 0x82eaf534
	if !ctx.cr[6].eq {
	pc = 0x82EAF534; continue 'dispatch;
	}
	// 82EAEF00: 39FE000C  addi r15, r30, 0xc
	ctx.r[15].s64 = ctx.r[30].s64 + 12;
	// 82EAEF04: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAEF08: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAEF0C: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 82EAEF10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEF14: 4E800421  bctrl
	ctx.lr = 0x82EAEF18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEF18: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAEF1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAEF20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEF24: 409A060C  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAEF28: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEF2C: 3A1E0010  addi r16, r30, 0x10
	ctx.r[16].s64 = ctx.r[30].s64 + 16;
	// 82EAEF30: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAEF34: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAEF38: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEF3C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEF40: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEF44: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAEF48: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEF4C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 82EAEF50: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAEF54: 916F0000  stw r11, 0(r15)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[15].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAEF58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEF5C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAEF60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEF64: 4E800421  bctrl
	ctx.lr = 0x82EAEF68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEF68: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAEF6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAEF70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEF74: 409A05BC  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAEF78: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEF7C: 3A5E0014  addi r18, r30, 0x14
	ctx.r[18].s64 = ctx.r[30].s64 + 20;
	// 82EAEF80: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAEF84: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAEF88: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEF8C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEF90: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEF94: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAEF98: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEF9C: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 82EAEFA0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAEFA4: 91700000  stw r11, 0(r16)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAEFA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEFAC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAEFB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEFB4: 4E800421  bctrl
	ctx.lr = 0x82EAEFB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEFB8: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAEFBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAEFC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEFC4: 409A056C  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAEFC8: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEFCC: 3B9E0018  addi r28, r30, 0x18
	ctx.r[28].s64 = ctx.r[30].s64 + 24;
	// 82EAEFD0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAEFD4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAEFD8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEFDC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEFE0: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEFE4: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAEFE8: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEFEC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EAEFF0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAEFF4: 91720000  stw r11, 0(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAEFF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEFFC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF000: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF004: 4E800421  bctrl
	ctx.lr = 0x82EAF008;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF008: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF00C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF010: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF014: 409A051C  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF018: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF01C: 3B7E001C  addi r27, r30, 0x1c
	ctx.r[27].s64 = ctx.r[30].s64 + 28;
	// 82EAF020: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF024: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF028: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF02C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF030: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF034: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF038: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF03C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EAF040: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF044: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF048: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF04C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF050: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF054: 4E800421  bctrl
	ctx.lr = 0x82EAF058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF058: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF05C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF064: 409A04CC  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF068: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF06C: 3B9E0020  addi r28, r30, 0x20
	ctx.r[28].s64 = ctx.r[30].s64 + 32;
	// 82EAF070: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF074: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF078: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF07C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF080: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF084: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF088: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF08C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EAF090: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF094: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF098: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF09C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF0A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF0A4: 4E800421  bctrl
	ctx.lr = 0x82EAF0A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF0A8: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF0AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF0B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF0B4: 409A047C  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF0B8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF0BC: 3B7E0024  addi r27, r30, 0x24
	ctx.r[27].s64 = ctx.r[30].s64 + 36;
	// 82EAF0C0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF0C4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF0C8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF0CC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF0D0: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF0D4: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF0D8: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF0DC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EAF0E0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF0E4: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF0E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF0EC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF0F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF0F4: 4E800421  bctrl
	ctx.lr = 0x82EAF0F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF0F8: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF0FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF104: 409A042C  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF108: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF10C: 3B9E0028  addi r28, r30, 0x28
	ctx.r[28].s64 = ctx.r[30].s64 + 40;
	// 82EAF110: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF114: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF118: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF11C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF120: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF124: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF128: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF12C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EAF130: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF134: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF138: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF13C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF140: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF144: 4E800421  bctrl
	ctx.lr = 0x82EAF148;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF148: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF14C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF154: 409A03DC  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF158: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF15C: 3B7E002C  addi r27, r30, 0x2c
	ctx.r[27].s64 = ctx.r[30].s64 + 44;
	// 82EAF160: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF164: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF168: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF16C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF170: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF174: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF178: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF17C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EAF180: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF184: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF188: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF18C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF190: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF194: 4E800421  bctrl
	ctx.lr = 0x82EAF198;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF198: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF19C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF1A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF1A4: 409A038C  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF1A8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF1AC: 3B9E0030  addi r28, r30, 0x30
	ctx.r[28].s64 = ctx.r[30].s64 + 48;
	// 82EAF1B0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF1B4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF1B8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF1BC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF1C0: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF1C4: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF1C8: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF1CC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EAF1D0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF1D4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF1D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF1DC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF1E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF1E4: 4E800421  bctrl
	ctx.lr = 0x82EAF1E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF1E8: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF1EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF1F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF1F4: 409A033C  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF1F8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF1FC: 3B7E0034  addi r27, r30, 0x34
	ctx.r[27].s64 = ctx.r[30].s64 + 52;
	// 82EAF200: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF204: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF208: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF20C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF210: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF214: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF218: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF21C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EAF220: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF224: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF228: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF22C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF230: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF234: 4E800421  bctrl
	ctx.lr = 0x82EAF238;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF238: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF23C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF244: 409A02EC  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF248: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF24C: 3B9E0038  addi r28, r30, 0x38
	ctx.r[28].s64 = ctx.r[30].s64 + 56;
	// 82EAF250: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF254: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF258: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF25C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF260: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF264: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF268: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF26C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EAF270: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF274: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF278: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF27C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF280: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF284: 4E800421  bctrl
	ctx.lr = 0x82EAF288;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF288: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF28C: 409A029C  bne cr6, 0x82eaf528
	if !ctx.cr[6].eq {
	pc = 0x82EAF528; continue 'dispatch;
	}
	// 82EAF290: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 82EAF294: 3A60FFFF  li r19, -1
	ctx.r[19].s64 = -1;
	// 82EAF298: 6176FFFF  ori r22, r11, 0xffff
	ctx.r[22].u64 = ctx.r[11].u64 | 65535;
	// 82EAF29C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF2A0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF2A4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF2A8: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF2AC: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF2B0: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF2B4: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF2B8: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF2BC: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF2C0: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF2C4: 7F0BB040  cmplw cr6, r11, r22
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82EAF2C8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EAF2CC: 40990008  ble cr6, 0x82eaf2d4
	if !ctx.cr[6].gt {
	pc = 0x82EAF2D4; continue 'dispatch;
	}
	// 82EAF2D0: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
            }
            0x82EAF2D4 => {
    //   block [0x82EAF2D4..0x82EAF2FC)
	// 82EAF2D4: 4B767655  bl 0x82616928
	ctx.lr = 0x82EAF2D8;
	sub_82616928(ctx, base);
	// 82EAF2D8: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF2DC: 7E378B78  mr r23, r17
	ctx.r[23].u64 = ctx.r[17].u64;
	// 82EAF2E0: 907E0008  stw r3, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82EAF2E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAF2E8: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 82EAF2EC: 409901AC  ble cr6, 0x82eaf498
	if !ctx.cr[6].gt {
	pc = 0x82EAF498; continue 'dispatch;
	}
	// 82EAF2F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAF2F4: 7E3A8B78  mr r26, r17
	ctx.r[26].u64 = ctx.r[17].u64;
	// 82EAF2F8: 3AABAFB4  addi r21, r11, -0x504c
	ctx.r[21].s64 = ctx.r[11].s64 + -20556;
	pc = 0x82EAF2FC; continue 'dispatch;
            }
            0x82EAF2FC => {
    //   block [0x82EAF2FC..0x82EAF310)
	// 82EAF2FC: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF300: 7F0BB040  cmplw cr6, r11, r22
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82EAF304: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EAF308: 40990008  ble cr6, 0x82eaf310
	if !ctx.cr[6].gt {
	pc = 0x82EAF310; continue 'dispatch;
	}
	// 82EAF30C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	pc = 0x82EAF310; continue 'dispatch;
            }
            0x82EAF310 => {
    //   block [0x82EAF310..0x82EAF330)
	// 82EAF310: 4B767619  bl 0x82616928
	ctx.lr = 0x82EAF314;
	sub_82616928(ctx, base);
	// 82EAF314: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF318: 7E388B78  mr r24, r17
	ctx.r[24].u64 = ctx.r[17].u64;
	// 82EAF31C: 7C6BD12E  stwx r3, r11, r26
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32), ctx.r[3].u32) };
	// 82EAF320: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAF328: 4099015C  ble cr6, 0x82eaf484
	if !ctx.cr[6].gt {
	pc = 0x82EAF484; continue 'dispatch;
	}
	// 82EAF32C: 7E3B8B78  mr r27, r17
	ctx.r[27].u64 = ctx.r[17].u64;
	pc = 0x82EAF330; continue 'dispatch;
            }
            0x82EAF330 => {
    //   block [0x82EAF330..0x82EAF344)
	// 82EAF330: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF334: 7F0BB040  cmplw cr6, r11, r22
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82EAF338: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EAF33C: 40990008  ble cr6, 0x82eaf344
	if !ctx.cr[6].gt {
	pc = 0x82EAF344; continue 'dispatch;
	}
	// 82EAF340: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	pc = 0x82EAF344; continue 'dispatch;
            }
            0x82EAF344 => {
    //   block [0x82EAF344..0x82EAF368)
	// 82EAF344: 4B7675E5  bl 0x82616928
	ctx.lr = 0x82EAF348;
	sub_82616928(ctx, base);
	// 82EAF348: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF34C: 7E398B78  mr r25, r17
	ctx.r[25].u64 = ctx.r[17].u64;
	// 82EAF350: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EAF354: 7C6BD92E  stwx r3, r11, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[3].u32) };
	// 82EAF358: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF35C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAF360: 40990110  ble cr6, 0x82eaf470
	if !ctx.cr[6].gt {
	pc = 0x82EAF470; continue 'dispatch;
	}
	// 82EAF364: 7E3C8B78  mr r28, r17
	ctx.r[28].u64 = ctx.r[17].u64;
	pc = 0x82EAF368; continue 'dispatch;
            }
            0x82EAF368 => {
    //   block [0x82EAF368..0x82EAF38C)
	// 82EAF368: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EAF36C: 4B7675BD  bl 0x82616928
	ctx.lr = 0x82EAF370;
	sub_82616928(ctx, base);
	// 82EAF370: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAF374: 41820018  beq 0x82eaf38c
	if ctx.cr[0].eq {
	pc = 0x82EAF38C; continue 'dispatch;
	}
	// 82EAF378: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EAF37C: 92230004  stw r17, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[17].u32 ) };
	// 82EAF380: 92A30000  stw r21, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 82EAF384: 9A230008  stb r17, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[17].u8 ) };
	// 82EAF388: 48000008  b 0x82eaf390
	pc = 0x82EAF390; continue 'dispatch;
            }
            0x82EAF38C => {
    //   block [0x82EAF38C..0x82EAF390)
	// 82EAF38C: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	pc = 0x82EAF390; continue 'dispatch;
            }
            0x82EAF390 => {
    //   block [0x82EAF390..0x82EAF408)
	// 82EAF390: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF394: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF398: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EAF39C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF3A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF3A4: 7D4AD02E  lwzx r10, r10, r26
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EAF3A8: 7D4AD82E  lwzx r10, r10, r27
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EAF3AC: 7D6AE12E  stwx r11, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[11].u32) };
	// 82EAF3B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF3B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF3B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF3BC: 4E800421  bctrl
	ctx.lr = 0x82EAF3C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF3C0: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF3C4: 409A0164  bne cr6, 0x82eaf528
	if !ctx.cr[6].eq {
	pc = 0x82EAF528; continue 'dispatch;
	}
	// 82EAF3C8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAF3CC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF3D0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF3D4: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF3D8: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF3DC: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF3E0: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF3E4: 7D6B5379  or. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAF3E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAF3EC: 41820070  beq 0x82eaf45c
	if ctx.cr[0].eq {
	pc = 0x82EAF45C; continue 'dispatch;
	}
	// 82EAF3F0: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 82EAF3F4: 4B767535  bl 0x82616928
	ctx.lr = 0x82EAF3F8;
	sub_82616928(ctx, base);
	// 82EAF3F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAF3FC: 4182000C  beq 0x82eaf408
	if ctx.cr[0].eq {
	pc = 0x82EAF408; continue 'dispatch;
	}
	// 82EAF400: 4BFF68F9  bl 0x82ea5cf8
	ctx.lr = 0x82EAF404;
	sub_82EA5CF8(ctx, base);
	// 82EAF404: 48000008  b 0x82eaf40c
	pc = 0x82EAF40C; continue 'dispatch;
            }
            0x82EAF408 => {
    //   block [0x82EAF408..0x82EAF40C)
	// 82EAF408: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	pc = 0x82EAF40C; continue 'dispatch;
            }
            0x82EAF40C => {
    //   block [0x82EAF40C..0x82EAF45C)
	// 82EAF40C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF410: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EAF414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAF418: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EAF41C: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EAF420: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EAF424: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82EAF428: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF42C: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EAF430: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EAF434: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EAF438: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAF43C: 4BFF7EBD  bl 0x82ea72f8
	ctx.lr = 0x82EAF440;
	sub_82EA72F8(ctx, base);
	// 82EAF440: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAF444: 41820080  beq 0x82eaf4c4
	if ctx.cr[0].eq {
	pc = 0x82EAF4C4; continue 'dispatch;
	}
	// 82EAF448: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF44C: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EAF450: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EAF454: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EAF458: 9A8B0008  stb r20, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[20].u8 ) };
	pc = 0x82EAF45C; continue 'dispatch;
            }
            0x82EAF45C => {
    //   block [0x82EAF45C..0x82EAF470)
	// 82EAF45C: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF460: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82EAF464: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EAF468: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAF46C: 4198FEFC  blt cr6, 0x82eaf368
	if ctx.cr[6].lt {
	pc = 0x82EAF368; continue 'dispatch;
	}
	pc = 0x82EAF470; continue 'dispatch;
            }
            0x82EAF470 => {
    //   block [0x82EAF470..0x82EAF484)
	// 82EAF470: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF474: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82EAF478: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EAF47C: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAF480: 4198FEB0  blt cr6, 0x82eaf330
	if ctx.cr[6].lt {
	pc = 0x82EAF330; continue 'dispatch;
	}
	pc = 0x82EAF484; continue 'dispatch;
            }
            0x82EAF484 => {
    //   block [0x82EAF484..0x82EAF498)
	// 82EAF484: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF488: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82EAF48C: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82EAF490: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAF494: 4198FE68  blt cr6, 0x82eaf2fc
	if ctx.cr[6].lt {
	pc = 0x82EAF2FC; continue 'dispatch;
	}
	pc = 0x82EAF498; continue 'dispatch;
            }
            0x82EAF498 => {
    //   block [0x82EAF498..0x82EAF4C4)
	// 82EAF498: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF49C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAF4A0: 409A007C  bne cr6, 0x82eaf51c
	if !ctx.cr[6].eq {
	pc = 0x82EAF51C; continue 'dispatch;
	}
	// 82EAF4A4: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF4A8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAF4AC: 409A0070  bne cr6, 0x82eaf51c
	if !ctx.cr[6].eq {
	pc = 0x82EAF51C; continue 'dispatch;
	}
	// 82EAF4B0: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF4B4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAF4B8: 409A0064  bne cr6, 0x82eaf51c
	if !ctx.cr[6].eq {
	pc = 0x82EAF51C; continue 'dispatch;
	}
	// 82EAF4BC: 9A9E0004  stb r20, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[20].u8 ) };
	// 82EAF4C0: 48000060  b 0x82eaf520
	pc = 0x82EAF520; continue 'dispatch;
            }
            0x82EAF4C4 => {
    //   block [0x82EAF4C4..0x82EAF4FC)
	// 82EAF4C4: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF4C8: 56EB103A  slwi r11, r23, 2
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAF4CC: 570A103A  slwi r10, r24, 2
	ctx.r[10].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EAF4D0: 5729103A  slwi r9, r25, 2
	ctx.r[9].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EAF4D4: 7E3C8B78  mr r28, r17
	ctx.r[28].u64 = ctx.r[17].u64;
	// 82EAF4D8: 7D08582E  lwzx r8, r8, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAF4DC: 7D08502E  lwzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EAF4E0: 7D08482E  lwzx r8, r8, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EAF4E4: 92280004  stw r17, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[17].u32 ) };
	// 82EAF4E8: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF4EC: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAF4F0: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EAF4F4: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EAF4F8: 9A2B0008  stb r17, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[17].u8 ) };
	pc = 0x82EAF4FC; continue 'dispatch;
            }
            0x82EAF4FC => {
    //   block [0x82EAF4FC..0x82EAF51C)
	// 82EAF4FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF500: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF508: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAF50C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF510: 4E800421  bctrl
	ctx.lr = 0x82EAF514;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF514: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EAF518: 4800002C  b 0x82eaf544
	pc = 0x82EAF544; continue 'dispatch;
            }
            0x82EAF51C => {
    //   block [0x82EAF51C..0x82EAF520)
	// 82EAF51C: 9A3E0004  stb r17, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[17].u8 ) };
	pc = 0x82EAF520; continue 'dispatch;
            }
            0x82EAF520 => {
    //   block [0x82EAF520..0x82EAF528)
	// 82EAF520: 7E9CA378  mr r28, r20
	ctx.r[28].u64 = ctx.r[20].u64;
	// 82EAF524: 4BFFFFD8  b 0x82eaf4fc
	pc = 0x82EAF4FC; continue 'dispatch;
            }
            0x82EAF528 => {
    //   block [0x82EAF528..0x82EAF530)
	// 82EAF528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF52C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x82EAF530; continue 'dispatch;
            }
            0x82EAF530 => {
    //   block [0x82EAF530..0x82EAF534)
	// 82EAF530: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82EAF534; continue 'dispatch;
            }
            0x82EAF534 => {
    //   block [0x82EAF534..0x82EAF540)
	// 82EAF534: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAF538: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF53C: 4E800421  bctrl
	ctx.lr = 0x82EAF540;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAF540 => {
    //   block [0x82EAF540..0x82EAF544)
	// 82EAF540: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EAF544; continue 'dispatch;
            }
            0x82EAF544 => {
    //   block [0x82EAF544..0x82EAF54C)
	// 82EAF544: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82EAF548: 4BDF9EDC  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAF550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF550 size=88
    let mut pc: u32 = 0x82EAF550;
    'dispatch: loop {
        match pc {
            0x82EAF550 => {
    //   block [0x82EAF550..0x82EAF58C)
	// 82EAF550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF554: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAF558: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAF55C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAF560: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF564: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAF568: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAF56C: 4BFFF85D  bl 0x82eaedc8
	ctx.lr = 0x82EAF570;
	sub_82EAEDC8(ctx, base);
	// 82EAF570: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAF574: 41820018  beq 0x82eaf58c
	if ctx.cr[0].eq {
	pc = 0x82EAF58C; continue 'dispatch;
	}
	// 82EAF578: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAF57C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF580: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAF584: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF588: 4E800421  bctrl
	ctx.lr = 0x82EAF58C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAF58C => {
    //   block [0x82EAF58C..0x82EAF5A8)
	// 82EAF58C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF590: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAF594: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAF598: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAF59C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAF5A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAF5A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAF5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAF5A8 size=172
    let mut pc: u32 = 0x82EAF5A8;
    'dispatch: loop {
        match pc {
            0x82EAF5A8 => {
    //   block [0x82EAF5A8..0x82EAF654)
	// 82EAF5A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAF5AC: 392003E8  li r9, 0x3e8
	ctx.r[9].s64 = 1000;
	// 82EAF5B0: 394BAFB4  addi r10, r11, -0x504c
	ctx.r[10].s64 = ctx.r[11].s64 + -20556;
	// 82EAF5B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAF5B8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EAF5BC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EAF5C0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EAF5C4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EAF5C8: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EAF5CC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAF5D0: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EAF5D4: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EAF5D8: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EAF5DC: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EAF5E0: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EAF5E4: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EAF5E8: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82EAF5EC: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82EAF5F0: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82EAF5F4: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82EAF5F8: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82EAF5FC: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EAF600: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EAF604: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82EAF608: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82EAF60C: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EAF610: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAF614: 91630058  stw r11, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAF618: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAF61C: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EAF620: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EAF624: 91630068  stw r11, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EAF628: 9163006C  stw r11, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EAF62C: 91630070  stw r11, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EAF630: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EAF634: 91630078  stw r11, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EAF638: 9163007C  stw r11, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EAF63C: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EAF640: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EAF644: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EAF648: 9163008C  stw r11, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EAF64C: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EAF650: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAF658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAF658 size=292
    let mut pc: u32 = 0x82EAF658;
    'dispatch: loop {
        match pc {
            0x82EAF658 => {
    //   block [0x82EAF658..0x82EAF77C)
	// 82EAF658: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAF65C: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EAF660: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF664: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EAF668: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF66C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EAF670: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAF674: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAF678: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAF67C: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EAF680: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAF684: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EAF688: 8164001C  lwz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAF68C: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EAF690: 81640020  lwz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EAF694: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EAF698: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EAF69C: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EAF6A0: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EAF6A4: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EAF6A8: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EAF6AC: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82EAF6B0: 81640034  lwz r11, 0x34(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EAF6B4: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82EAF6B8: 81640030  lwz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EAF6BC: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82EAF6C0: 81640038  lwz r11, 0x38(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EAF6C4: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82EAF6C8: 8164003C  lwz r11, 0x3c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EAF6CC: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82EAF6D0: 81640040  lwz r11, 0x40(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EAF6D4: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EAF6D8: 81640044  lwz r11, 0x44(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EAF6DC: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EAF6E0: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EAF6E4: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82EAF6E8: 8164004C  lwz r11, 0x4c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EAF6EC: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82EAF6F0: 81640050  lwz r11, 0x50(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EAF6F4: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EAF6F8: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAF6FC: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAF700: 81640058  lwz r11, 0x58(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EAF704: 91630058  stw r11, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAF708: 8164005C  lwz r11, 0x5c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EAF70C: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAF710: 81640060  lwz r11, 0x60(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAF714: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EAF718: 81640064  lwz r11, 0x64(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EAF71C: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EAF720: 81640068  lwz r11, 0x68(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EAF724: 91630068  stw r11, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EAF728: 8164006C  lwz r11, 0x6c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EAF72C: 9163006C  stw r11, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EAF730: 81640070  lwz r11, 0x70(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EAF734: 91630070  stw r11, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EAF738: 81640074  lwz r11, 0x74(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EAF73C: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EAF740: 81640078  lwz r11, 0x78(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EAF744: 91630078  stw r11, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EAF748: 81640084  lwz r11, 0x84(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EAF74C: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EAF750: 81640088  lwz r11, 0x88(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EAF754: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EAF758: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EAF75C: 9163008C  stw r11, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EAF760: 81640090  lwz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EAF764: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EAF768: 8164007C  lwz r11, 0x7c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EAF76C: 9163007C  stw r11, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EAF770: 81640080  lwz r11, 0x80(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EAF774: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EAF778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAF780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF780 size=372
    let mut pc: u32 = 0x82EAF780;
    'dispatch: loop {
        match pc {
            0x82EAF780 => {
    //   block [0x82EAF780..0x82EAF8C8)
	// 82EAF780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAF788: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAF78C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAF790: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF794: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAF798: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAF79C: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EAF7A0: 394BDE74  addi r10, r11, -0x218c
	ctx.r[10].s64 = ctx.r[11].s64 + -8588;
	// 82EAF7A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAF7A8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAF7AC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EAF7B0: 9169FEF4  stw r11, -0x10c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-268 as u32), ctx.r[11].u32 ) };
	// 82EAF7B4: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EAF7B8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAF7BC: 9169FEF8  stw r11, -0x108(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-264 as u32), ctx.r[11].u32 ) };
	// 82EAF7C0: 4BFFFE99  bl 0x82eaf658
	ctx.lr = 0x82EAF7C4;
	sub_82EAF658(ctx, base);
	// 82EAF7C4: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 82EAF7C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EAF7CC: 915E8684  stw r10, -0x797c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-31100 as u32), ctx.r[10].u32 ) };
	// 82EAF7D0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF7D4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAF7D8: 4BFCFE81  bl 0x82e7f658
	ctx.lr = 0x82EAF7DC;
	sub_82E7F658(ctx, base);
	// 82EAF7DC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAF7E0: 386B8698  addi r3, r11, -0x7968
	ctx.r[3].s64 = ctx.r[11].s64 + -31080;
	// 82EAF7E4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF7E8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EAF7EC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAF7F0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EAF7F4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAF7F8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EAF7FC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EAF800: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EAF804: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EAF808: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAF80C: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EAF810: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAF814: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EAF818: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EAF81C: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EAF820: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EAF824: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAF828: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82EAF82C: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EAF830: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82EAF834: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EAF838: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EAF83C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAF840: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EAF844: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EAF848: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82EAF84C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EAF850: 916100AC  stw r11, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82EAF854: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EAF858: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EAF85C: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EAF860: 916100B4  stw r11, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82EAF864: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EAF868: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82EAF86C: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EAF870: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82EAF874: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EAF878: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EAF87C: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EAF880: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82EAF884: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EAF888: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82EAF88C: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EAF890: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82EAF894: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EAF898: 906BFEF0  stw r3, -0x110(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-272 as u32), ctx.r[3].u32 ) };
	// 82EAF89C: 817E8684  lwz r11, -0x797c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-31100 as u32) ) } as u64;
	// 82EAF8A0: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAF8A4: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF8A8: 808B0024  lwz r4, 0x24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EAF8AC: 4BFD595D  bl 0x82e85208
	ctx.lr = 0x82EAF8B0;
	sub_82E85208(ctx, base);
	// 82EAF8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EAF8B4: 4BFD01CD  bl 0x82e7fa80
	ctx.lr = 0x82EAF8B8;
	sub_82E7FA80(ctx, base);
	// 82EAF8B8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EAF8BC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAF8C0: 409A002C  bne cr6, 0x82eaf8ec
	if !ctx.cr[6].eq {
	pc = 0x82EAF8EC; continue 'dispatch;
	}
	// 82EAF8C4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	pc = 0x82EAF8C8; continue 'dispatch;
            }
            0x82EAF8C8 => {
    //   block [0x82EAF8C8..0x82EAF8EC)
	// 82EAF8C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EAF8CC: 4BCE75AD  bl 0x82b96e78
	ctx.lr = 0x82EAF8D0;
	sub_82B96E78(ctx, base);
	// 82EAF8D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF8D4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EAF8D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAF8DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAF8E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAF8E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAF8E8: 4E800020  blr
	return;
            }
            0x82EAF8EC => {
    //   block [0x82EAF8EC..0x82EAF8F4)
	// 82EAF8EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EAF8F0: 4BFFFFD8  b 0x82eaf8c8
	pc = 0x82EAF8C8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAF8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF8F8 size=104
    let mut pc: u32 = 0x82EAF8F8;
    'dispatch: loop {
        match pc {
            0x82EAF8F8 => {
    //   block [0x82EAF8F8..0x82EAF948)
	// 82EAF8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF8FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAF900: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAF904: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAF908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF90C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAF910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAF914: 3BCB8698  addi r30, r11, -0x7968
	ctx.r[30].s64 = ctx.r[11].s64 + -31080;
	// 82EAF918: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAF91C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAF920: 4BFD53D1  bl 0x82e84cf0
	ctx.lr = 0x82EAF924;
	sub_82E84CF0(ctx, base);
	// 82EAF924: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EAF928: 814BFEF8  lwz r10, -0x108(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-264 as u32) ) } as u64;
	// 82EAF92C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAF930: 419A0018  beq cr6, 0x82eaf948
	if ctx.cr[6].eq {
	pc = 0x82EAF948; continue 'dispatch;
	}
	// 82EAF934: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EAF938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF93C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAF940: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF944: 4E800421  bctrl
	ctx.lr = 0x82EAF948;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAF948 => {
    //   block [0x82EAF948..0x82EAF960)
	// 82EAF948: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAF94C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAF950: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAF954: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAF958: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAF95C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAF960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF960 size=104
    let mut pc: u32 = 0x82EAF960;
    'dispatch: loop {
        match pc {
            0x82EAF960 => {
    //   block [0x82EAF960..0x82EAF9A4)
	// 82EAF960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF964: 4BDF9AA9  bl 0x82ca940c
	ctx.lr = 0x82EAF968;
	sub_82CA93D0(ctx, base);
	// 82EAF968: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF96C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAF970: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAF974: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EAF978: 419A0048  beq cr6, 0x82eaf9c0
	if ctx.cr[6].eq {
	pc = 0x82EAF9C0; continue 'dispatch;
	}
	// 82EAF97C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82EAF980: 4B766FA9  bl 0x82616928
	ctx.lr = 0x82EAF984;
	sub_82616928(ctx, base);
	// 82EAF984: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAF988: 3FA08334  lis r29, -0x7ccc
	ctx.r[29].s64 = -2093744128;
	// 82EAF98C: 41820018  beq 0x82eaf9a4
	if ctx.cr[0].eq {
	pc = 0x82EAF9A4; continue 'dispatch;
	}
	// 82EAF990: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EAF994: 80BDFEF0  lwz r5, -0x110(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82EAF998: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAF99C: 4BFD58F5  bl 0x82e85290
	ctx.lr = 0x82EAF9A0;
	sub_82E85290(ctx, base);
	// 82EAF9A0: 48000008  b 0x82eaf9a8
	pc = 0x82EAF9A8; continue 'dispatch;
            }
            0x82EAF9A4 => {
    //   block [0x82EAF9A4..0x82EAF9A8)
	// 82EAF9A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EAF9A8; continue 'dispatch;
            }
            0x82EAF9A8 => {
    //   block [0x82EAF9A8..0x82EAF9C0)
	// 82EAF9A8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAF9AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EAF9B0: 396B8688  addi r11, r11, -0x7978
	ctx.r[11].s64 = ctx.r[11].s64 + -31096;
	// 82EAF9B4: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EAF9B8: 419A0008  beq cr6, 0x82eaf9c0
	if ctx.cr[6].eq {
	pc = 0x82EAF9C0; continue 'dispatch;
	}
	// 82EAF9BC: 907DFEF0  stw r3, -0x110(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-272 as u32), ctx.r[3].u32 ) };
	pc = 0x82EAF9C0; continue 'dispatch;
            }
            0x82EAF9C0 => {
    //   block [0x82EAF9C0..0x82EAF9C8)
	// 82EAF9C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAF9C4: 4BDF9A98  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAF9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF9C8 size=108
    let mut pc: u32 = 0x82EAF9C8;
    'dispatch: loop {
        match pc {
            0x82EAF9C8 => {
    //   block [0x82EAF9C8..0x82EAFA04)
	// 82EAF9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF9CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAF9D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAF9D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF9D8: 3FE08335  lis r31, -0x7ccb
	ctx.r[31].s64 = -2093678592;
	// 82EAF9DC: 807F8688  lwz r3, -0x7978(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-31096 as u32) ) } as u64;
	// 82EAF9E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EAF9E4: 419A003C  beq cr6, 0x82eafa20
	if ctx.cr[6].eq {
	pc = 0x82EAFA20; continue 'dispatch;
	}
	// 82EAF9E8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EAF9EC: 814BFEF0  lwz r10, -0x110(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82EAF9F0: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EAF9F4: 409A0010  bne cr6, 0x82eafa04
	if !ctx.cr[6].eq {
	pc = 0x82EAFA04; continue 'dispatch;
	}
	// 82EAF9F8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EAF9FC: 394A8698  addi r10, r10, -0x7968
	ctx.r[10].s64 = ctx.r[10].s64 + -31080;
	// 82EAFA00: 914BFEF0  stw r10, -0x110(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-272 as u32), ctx.r[10].u32 ) };
	pc = 0x82EAFA04; continue 'dispatch;
            }
            0x82EAFA04 => {
    //   block [0x82EAFA04..0x82EAFA20)
	// 82EAFA04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFA08: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EAFA0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFA10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFA14: 4E800421  bctrl
	ctx.lr = 0x82EAFA18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFA18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAFA1C: 917F8688  stw r11, -0x7978(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-31096 as u32), ctx.r[11].u32 ) };
            }
            0x82EAFA20 => {
    //   block [0x82EAFA20..0x82EAFA34)
	// 82EAFA20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAFA24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFA28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFA2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFA30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFA38 size=20
    let mut pc: u32 = 0x82EAFA38;
    'dispatch: loop {
        match pc {
            0x82EAFA38 => {
    //   block [0x82EAFA38..0x82EAFA4C)
	// 82EAFA38: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EAFA3C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EAFA40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAFA44: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82EAFA48: 4BFD00C0  b 0x82e7fb08
	sub_82E7FB08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFA50 size=16
    let mut pc: u32 = 0x82EAFA50;
    'dispatch: loop {
        match pc {
            0x82EAFA50 => {
    //   block [0x82EAFA50..0x82EAFA60)
	// 82EAFA50: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82EAFA54: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82EAFA58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EAFA5C: 4BFD00AC  b 0x82e7fb08
	sub_82E7FB08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFA60 size=96
    let mut pc: u32 = 0x82EAFA60;
    'dispatch: loop {
        match pc {
            0x82EAFA60 => {
    //   block [0x82EAFA60..0x82EAFAC0)
	// 82EAFA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFA64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFA68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFA6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFA70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFA74: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82EAFA78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAFA7C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EAFA80: 38AB70A8  addi r5, r11, 0x70a8
	ctx.r[5].s64 = ctx.r[11].s64 + 28840;
	// 82EAFA84: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAFA88: 4BFD0081  bl 0x82e7fb08
	ctx.lr = 0x82EAFA8C;
	sub_82E7FB08(ctx, base);
	// 82EAFA8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAFA90: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EAFA94: 38AB8FD8  addi r5, r11, -0x7028
	ctx.r[5].s64 = ctx.r[11].s64 + -28712;
	// 82EAFA98: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EAFA9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAFAA0: 4BFD0069  bl 0x82e7fb08
	ctx.lr = 0x82EAFAA4;
	sub_82E7FB08(ctx, base);
	// 82EAFAA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFAA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAFAAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFAB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFAB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAFAB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFAC0 size=96
    let mut pc: u32 = 0x82EAFAC0;
    'dispatch: loop {
        match pc {
            0x82EAFAC0 => {
    //   block [0x82EAFAC0..0x82EAFB20)
	// 82EAFAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFAC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFAC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFAD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFAD4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EAFAD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAFADC: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EAFAE0: 38AB4D6C  addi r5, r11, 0x4d6c
	ctx.r[5].s64 = ctx.r[11].s64 + 19820;
	// 82EAFAE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAFAE8: 4BFD0021  bl 0x82e7fb08
	ctx.lr = 0x82EAFAEC;
	sub_82E7FB08(ctx, base);
	// 82EAFAEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAFAF0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EAFAF4: 38AB8FD8  addi r5, r11, -0x7028
	ctx.r[5].s64 = ctx.r[11].s64 + -28712;
	// 82EAFAF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EAFAFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAFB00: 4BFD0009  bl 0x82e7fb08
	ctx.lr = 0x82EAFB04;
	sub_82E7FB08(ctx, base);
	// 82EAFB04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFB08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAFB0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFB10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFB14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAFB18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFB1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFB20 size=96
    let mut pc: u32 = 0x82EAFB20;
    'dispatch: loop {
        match pc {
            0x82EAFB20 => {
    //   block [0x82EAFB20..0x82EAFB80)
	// 82EAFB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFB24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFB28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFB2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFB30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFB34: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EAFB38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAFB3C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EAFB40: 38AB4D64  addi r5, r11, 0x4d64
	ctx.r[5].s64 = ctx.r[11].s64 + 19812;
	// 82EAFB44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAFB48: 4BFCFFC1  bl 0x82e7fb08
	ctx.lr = 0x82EAFB4C;
	sub_82E7FB08(ctx, base);
	// 82EAFB4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAFB50: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EAFB54: 38AB8FD8  addi r5, r11, -0x7028
	ctx.r[5].s64 = ctx.r[11].s64 + -28712;
	// 82EAFB58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EAFB5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAFB60: 4BFCFFA9  bl 0x82e7fb08
	ctx.lr = 0x82EAFB64;
	sub_82E7FB08(ctx, base);
	// 82EAFB64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFB68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAFB6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFB70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFB74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAFB78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFB7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFB80 size=108
    let mut pc: u32 = 0x82EAFB80;
    'dispatch: loop {
        match pc {
            0x82EAFB80 => {
    //   block [0x82EAFB80..0x82EAFBB8)
	// 82EAFB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFB84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFB88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFB8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFB90: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFB94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAFB98: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EAFB9C: 816B8688  lwz r11, -0x7978(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31096 as u32) ) } as u64;
	// 82EAFBA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAFBA4: 409A0014  bne cr6, 0x82eafbb8
	if !ctx.cr[6].eq {
	pc = 0x82EAFBB8; continue 'dispatch;
	}
	// 82EAFBA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EAFBAC: 419A000C  beq cr6, 0x82eafbb8
	if ctx.cr[6].eq {
	pc = 0x82EAFBB8; continue 'dispatch;
	}
	// 82EAFBB0: 38800064  li r4, 0x64
	ctx.r[4].s64 = 100;
	// 82EAFBB4: 4BFFFDAD  bl 0x82eaf960
	ctx.lr = 0x82EAFBB8;
	sub_82EAF960(ctx, base);
	pc = 0x82EAFBB8; continue 'dispatch;
            }
            0x82EAFBB8 => {
    //   block [0x82EAFBB8..0x82EAFBEC)
	// 82EAFBB8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAFBBC: 396BDE74  addi r11, r11, -0x218c
	ctx.r[11].s64 = ctx.r[11].s64 + -8588;
	// 82EAFBC0: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EAFBC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFBC8: 4E800421  bctrl
	ctx.lr = 0x82EAFBCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFBCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EAFBD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFBD4: 4BFD0865  bl 0x82e80438
	ctx.lr = 0x82EAFBD8;
	sub_82E80438(ctx, base);
	// 82EAFBD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAFBDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFBE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFBE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFBE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFBF0 size=80
    let mut pc: u32 = 0x82EAFBF0;
    'dispatch: loop {
        match pc {
            0x82EAFBF0 => {
    //   block [0x82EAFBF0..0x82EAFC28)
	// 82EAFBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFBF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFBF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFBFC: 4BFD006D  bl 0x82e7fc68
	ctx.lr = 0x82EAFC00;
	sub_82E7FC68(ctx, base);
	// 82EAFC00: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFC04: 816B8684  lwz r11, -0x797c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31100 as u32) ) } as u64;
	// 82EAFC08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAFC0C: 419A001C  beq cr6, 0x82eafc28
	if ctx.cr[6].eq {
	pc = 0x82EAFC28; continue 'dispatch;
	}
	// 82EAFC10: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EAFC14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAFC18: 419A0010  beq cr6, 0x82eafc28
	if ctx.cr[6].eq {
	pc = 0x82EAFC28; continue 'dispatch;
	}
	// 82EAFC1C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAFC20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFC24: 4E800421  bctrl
	ctx.lr = 0x82EAFC28;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAFC28 => {
    //   block [0x82EAFC28..0x82EAFC40)
	// 82EAFC28: 4BFFFDA1  bl 0x82eaf9c8
	ctx.lr = 0x82EAFC2C;
	sub_82EAF9C8(ctx, base);
	// 82EAFC2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAFC30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAFC34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFC38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFC3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFC40 size=60
    let mut pc: u32 = 0x82EAFC40;
    'dispatch: loop {
        match pc {
            0x82EAFC40 => {
    //   block [0x82EAFC40..0x82EAFC68)
	// 82EAFC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFC44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFC48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFC4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EAFC50: 419A0018  beq cr6, 0x82eafc68
	if ctx.cr[6].eq {
	pc = 0x82EAFC68; continue 'dispatch;
	}
	// 82EAFC54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFC58: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EAFC5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFC60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFC64: 4E800421  bctrl
	ctx.lr = 0x82EAFC68;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAFC68 => {
    //   block [0x82EAFC68..0x82EAFC7C)
	// 82EAFC68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAFC6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAFC70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFC74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFC78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFC80 size=4
    let mut pc: u32 = 0x82EAFC80;
    'dispatch: loop {
        match pc {
            0x82EAFC80 => {
    //   block [0x82EAFC80..0x82EAFC84)
	// 82EAFC80: 4BFCFE60  b 0x82e7fae0
	sub_82E7FAE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFC88 size=4
    let mut pc: u32 = 0x82EAFC88;
    'dispatch: loop {
        match pc {
            0x82EAFC88 => {
    //   block [0x82EAFC88..0x82EAFC8C)
	// 82EAFC88: 4BFD00B0  b 0x82e7fd38
	sub_82E7FD38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFC90 size=4
    let mut pc: u32 = 0x82EAFC90;
    'dispatch: loop {
        match pc {
            0x82EAFC90 => {
    //   block [0x82EAFC90..0x82EAFC94)
	// 82EAFC90: 4BFD0918  b 0x82e805a8
	sub_82E805A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFC98 size=4
    let mut pc: u32 = 0x82EAFC98;
    'dispatch: loop {
        match pc {
            0x82EAFC98 => {
    //   block [0x82EAFC98..0x82EAFC9C)
	// 82EAFC98: 4BFD03A8  b 0x82e80040
	sub_82E80040(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFCA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFCA0 size=4
    let mut pc: u32 = 0x82EAFCA0;
    'dispatch: loop {
        match pc {
            0x82EAFCA0 => {
    //   block [0x82EAFCA0..0x82EAFCA4)
	// 82EAFCA0: 4BFFFAE0  b 0x82eaf780
	sub_82EAF780(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFCA8 size=156
    let mut pc: u32 = 0x82EAFCA8;
    'dispatch: loop {
        match pc {
            0x82EAFCA8 => {
    //   block [0x82EAFCA8..0x82EAFCE8)
	// 82EAFCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFCAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFCB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFCB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFCB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFCBC: 4BFCFDCD  bl 0x82e7fa88
	ctx.lr = 0x82EAFCC0;
	sub_82E7FA88(ctx, base);
	// 82EAFCC0: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 82EAFCC4: 817E8684  lwz r11, -0x797c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-31100 as u32) ) } as u64;
	// 82EAFCC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAFCCC: 419A001C  beq cr6, 0x82eafce8
	if ctx.cr[6].eq {
	pc = 0x82EAFCE8; continue 'dispatch;
	}
	// 82EAFCD0: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EAFCD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAFCD8: 419A0010  beq cr6, 0x82eafce8
	if ctx.cr[6].eq {
	pc = 0x82EAFCE8; continue 'dispatch;
	}
	// 82EAFCDC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EAFCE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFCE4: 4E800421  bctrl
	ctx.lr = 0x82EAFCE8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EAFCE8 => {
    //   block [0x82EAFCE8..0x82EAFD44)
	// 82EAFCE8: 4BFFFCE1  bl 0x82eaf9c8
	ctx.lr = 0x82EAFCEC;
	sub_82EAF9C8(ctx, base);
	// 82EAFCEC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFCF0: 3FE08330  lis r31, -0x7cd0
	ctx.r[31].s64 = -2094006272;
	// 82EAFCF4: 386B8698  addi r3, r11, -0x7968
	ctx.r[3].s64 = ctx.r[11].s64 + -31080;
	// 82EAFCF8: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EAFCFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAFD00: 396BF8F8  addi r11, r11, -0x708
	ctx.r[11].s64 = ctx.r[11].s64 + -1800;
	// 82EAFD04: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EAFD08: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EAFD0C: 917FDAB4  stw r11, -0x254c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-9548 as u32), ctx.r[11].u32 ) };
	// 82EAFD10: 4BFD54F9  bl 0x82e85208
	ctx.lr = 0x82EAFD14;
	sub_82E85208(ctx, base);
	// 82EAFD14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAFD18: 3D4082E8  lis r10, -0x7d18
	ctx.r[10].s64 = -2098724864;
	// 82EAFD1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAFD20: 917E8684  stw r11, -0x797c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-31100 as u32), ctx.r[11].u32 ) };
	// 82EAFD24: 396AF5F0  addi r11, r10, -0xa10
	ctx.r[11].s64 = ctx.r[10].s64 + -2576;
	// 82EAFD28: 917FDAB4  stw r11, -0x254c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-9548 as u32), ctx.r[11].u32 ) };
	// 82EAFD2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAFD30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFD34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFD38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAFD3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFD40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFD48 size=140
    let mut pc: u32 = 0x82EAFD48;
    'dispatch: loop {
        match pc {
            0x82EAFD48 => {
    //   block [0x82EAFD48..0x82EAFD88)
	// 82EAFD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFD4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFD50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFD54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFD58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFD5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EAFD60: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82EAFD64: 4B766BC5  bl 0x82616928
	ctx.lr = 0x82EAFD68;
	sub_82616928(ctx, base);
	// 82EAFD68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EAFD6C: 4182001C  beq 0x82eafd88
	if ctx.cr[0].eq {
	pc = 0x82EAFD88; continue 'dispatch;
	}
	// 82EAFD70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFD74: 4BFD4495  bl 0x82e84208
	ctx.lr = 0x82EAFD78;
	sub_82E84208(ctx, base);
	// 82EAFD78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAFD7C: 396BA39C  addi r11, r11, -0x5c64
	ctx.r[11].s64 = ctx.r[11].s64 + -23652;
	// 82EAFD80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAFD84: 48000008  b 0x82eafd8c
	pc = 0x82EAFD8C; continue 'dispatch;
            }
            0x82EAFD88 => {
    //   block [0x82EAFD88..0x82EAFD8C)
	// 82EAFD88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82EAFD8C; continue 'dispatch;
            }
            0x82EAFD8C => {
    //   block [0x82EAFD8C..0x82EAFDD4)
	// 82EAFD8C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAFD90: 396BDE74  addi r11, r11, -0x218c
	ctx.r[11].s64 = ctx.r[11].s64 + -8588;
	// 82EAFD94: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EAFD98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFD9C: 4E800421  bctrl
	ctx.lr = 0x82EAFDA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFDA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFDA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EAFDA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EAFDAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFDB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFDB4: 4E800421  bctrl
	ctx.lr = 0x82EAFDB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFDB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFDBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAFDC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFDC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFDC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAFDCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFDD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EAFDD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EAFDD8 size=572
    let mut pc: u32 = 0x82EAFDD8;
    'dispatch: loop {
        match pc {
            0x82EAFDD8 => {
    //   block [0x82EAFDD8..0x82EB000C)
	// 82EAFDD8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFDDC: 396B8C64  addi r11, r11, -0x739c
	ctx.r[11].s64 = ctx.r[11].s64 + -29596;
	// 82EAFDE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFDE4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFDE8: 419A0224  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFDEC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFDF0: 396BE16C  addi r11, r11, -0x1e94
	ctx.r[11].s64 = ctx.r[11].s64 + -7828;
	// 82EAFDF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFDF8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFDFC: 419A0210  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFE00: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EAFE04: 396B8E0C  addi r11, r11, -0x71f4
	ctx.r[11].s64 = ctx.r[11].s64 + -29172;
	// 82EAFE08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE0C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE10: 419A01FC  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFE14: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EAFE18: 396B8CF8  addi r11, r11, -0x7308
	ctx.r[11].s64 = ctx.r[11].s64 + -29448;
	// 82EAFE1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE20: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE24: 419A01E8  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFE28: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EAFE2C: 396B8BE4  addi r11, r11, -0x741c
	ctx.r[11].s64 = ctx.r[11].s64 + -29724;
	// 82EAFE30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE34: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE38: 419A01D4  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFE3C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFE40: 396B9E5C  addi r11, r11, -0x61a4
	ctx.r[11].s64 = ctx.r[11].s64 + -24996;
	// 82EAFE44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE48: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE4C: 419A01C0  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFE50: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFE54: 396BE058  addi r11, r11, -0x1fa8
	ctx.r[11].s64 = ctx.r[11].s64 + -8104;
	// 82EAFE58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE5C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE60: 419A01AC  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFE64: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFE68: 396BDF44  addi r11, r11, -0x20bc
	ctx.r[11].s64 = ctx.r[11].s64 + -8380;
	// 82EAFE6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE70: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE74: 419A0198  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFE78: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFE7C: 396BDE30  addi r11, r11, -0x21d0
	ctx.r[11].s64 = ctx.r[11].s64 + -8656;
	// 82EAFE80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE84: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE88: 419A0184  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFE8C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFE90: 396BDD1C  addi r11, r11, -0x22e4
	ctx.r[11].s64 = ctx.r[11].s64 + -8932;
	// 82EAFE94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFE98: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFE9C: 419A0170  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFEA0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFEA4: 396BDC08  addi r11, r11, -0x23f8
	ctx.r[11].s64 = ctx.r[11].s64 + -9208;
	// 82EAFEA8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFEAC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFEB0: 419A015C  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFEB4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFEB8: 396BDAF4  addi r11, r11, -0x250c
	ctx.r[11].s64 = ctx.r[11].s64 + -9484;
	// 82EAFEBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFEC0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFEC4: 419A0148  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFEC8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFECC: 396BD9E0  addi r11, r11, -0x2620
	ctx.r[11].s64 = ctx.r[11].s64 + -9760;
	// 82EAFED0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFED4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFED8: 419A0134  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFEDC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFEE0: 396BD8CC  addi r11, r11, -0x2734
	ctx.r[11].s64 = ctx.r[11].s64 + -10036;
	// 82EAFEE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFEE8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFEEC: 419A0120  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFEF0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFEF4: 396BD7B8  addi r11, r11, -0x2848
	ctx.r[11].s64 = ctx.r[11].s64 + -10312;
	// 82EAFEF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFEFC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF00: 419A010C  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFF04: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFF08: 396BD6A4  addi r11, r11, -0x295c
	ctx.r[11].s64 = ctx.r[11].s64 + -10588;
	// 82EAFF0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF10: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF14: 419A00F8  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFF18: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFF1C: 396BD590  addi r11, r11, -0x2a70
	ctx.r[11].s64 = ctx.r[11].s64 + -10864;
	// 82EAFF20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF24: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF28: 419A00E4  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFF2C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFF30: 396BD47C  addi r11, r11, -0x2b84
	ctx.r[11].s64 = ctx.r[11].s64 + -11140;
	// 82EAFF34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF38: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF3C: 419A00D0  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFF40: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFF44: 396BD358  addi r11, r11, -0x2ca8
	ctx.r[11].s64 = ctx.r[11].s64 + -11432;
	// 82EAFF48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF4C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF50: 419A00BC  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFF54: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFF58: 396BD244  addi r11, r11, -0x2dbc
	ctx.r[11].s64 = ctx.r[11].s64 + -11708;
	// 82EAFF5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF60: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF64: 419A00A8  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFF68: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFF6C: 396BD12C  addi r11, r11, -0x2ed4
	ctx.r[11].s64 = ctx.r[11].s64 + -11988;
	// 82EAFF70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF74: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF78: 419A0094  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFF7C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EAFF80: 396B8AD0  addi r11, r11, -0x7530
	ctx.r[11].s64 = ctx.r[11].s64 + -30000;
	// 82EAFF84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF88: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFF8C: 419A0080  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFF90: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EAFF94: 396B89BC  addi r11, r11, -0x7644
	ctx.r[11].s64 = ctx.r[11].s64 + -30276;
	// 82EAFF98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFF9C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFFA0: 419A006C  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFFA4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFFA8: 396BD018  addi r11, r11, -0x2fe8
	ctx.r[11].s64 = ctx.r[11].s64 + -12264;
	// 82EAFFAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFFB0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFFB4: 419A0058  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFFB8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFFBC: 396BCF04  addi r11, r11, -0x30fc
	ctx.r[11].s64 = ctx.r[11].s64 + -12540;
	// 82EAFFC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFFC4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFFC8: 419A0044  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFFCC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFFD0: 396BCDF0  addi r11, r11, -0x3210
	ctx.r[11].s64 = ctx.r[11].s64 + -12816;
	// 82EAFFD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFFD8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFFDC: 419A0030  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFFE0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFFE4: 396BCCDC  addi r11, r11, -0x3324
	ctx.r[11].s64 = ctx.r[11].s64 + -13092;
	// 82EAFFE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFFEC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EAFFF0: 419A001C  beq cr6, 0x82eb000c
	if ctx.cr[6].eq {
	pc = 0x82EB000C; continue 'dispatch;
	}
	// 82EAFFF4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFFF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAFFFC: 396BCBC8  addi r11, r11, -0x3438
	ctx.r[11].s64 = ctx.r[11].s64 + -13368;
	// 82EB0000: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0004: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB0008: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x82EB000C; continue 'dispatch;
            }
            0x82EB000C => {
    //   block [0x82EB000C..0x82EB0014)
	// 82EB000C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB0010: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB0018 size=456
    let mut pc: u32 = 0x82EB0018;
    'dispatch: loop {
        match pc {
            0x82EB0018 => {
    //   block [0x82EB0018..0x82EB01E0)
	// 82EB0018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB001C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB0020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB0024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB0028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB002C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0030: 4BFD58D1  bl 0x82e85900
	ctx.lr = 0x82EB0034;
	sub_82E85900(ctx, base);
	// 82EB0034: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB0038: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EB003C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB0040: 396BA3B0  addi r11, r11, -0x5c50
	ctx.r[11].s64 = ctx.r[11].s64 + -23632;
	// 82EB0044: 394A8704  addi r10, r10, -0x78fc
	ctx.r[10].s64 = ctx.r[10].s64 + -30972;
	// 82EB0048: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB004C: 3929990C  addi r9, r9, -0x66f4
	ctx.r[9].s64 = ctx.r[9].s64 + -26356;
	// 82EB0050: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB0054: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB0058: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82EB005C: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82EB0060: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82EB0064: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82EB0068: 4BFE2ED1  bl 0x82e92f38
	ctx.lr = 0x82EB006C;
	sub_82E92F38(ctx, base);
	// 82EB006C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0070: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EB0074: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0078: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB007C: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EB0080: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EB0084: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EB0088: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EB008C: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EB0090: D01F00DC  stfs f0, 0xdc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EB0094: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EB0098: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EB009C: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EB00A0: D01F00EC  stfs f0, 0xec(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EB00A4: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EB00A8: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EB00AC: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EB00B0: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EB00B4: D01F0100  stfs f0, 0x100(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EB00B8: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB00BC: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB00C0: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EB00C4: D01F0110  stfs f0, 0x110(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82EB00C8: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82EB00CC: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82EB00D0: D01F011C  stfs f0, 0x11c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82EB00D4: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82EB00D8: D01F0124  stfs f0, 0x124(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EB00DC: D01F0128  stfs f0, 0x128(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EB00E0: D01F012C  stfs f0, 0x12c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EB00E4: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82EB00E8: D01F0144  stfs f0, 0x144(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82EB00EC: D01F0148  stfs f0, 0x148(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82EB00F0: D01F014C  stfs f0, 0x14c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82EB00F4: 997F00BC  stb r11, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u8 ) };
	// 82EB00F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB00FC: 9BDF01B5  stb r30, 0x1b5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(437 as u32), ctx.r[30].u8 ) };
	// 82EB0100: 9BDF00BF  stb r30, 0xbf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(191 as u32), ctx.r[30].u8 ) };
	// 82EB0104: 396B115C  addi r11, r11, 0x115c
	ctx.r[11].s64 = ctx.r[11].s64 + 4444;
	// 82EB0108: 93DF0174  stw r30, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[30].u32 ) };
	// 82EB010C: 93DF0178  stw r30, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[30].u32 ) };
	// 82EB0110: 9BDF00BE  stb r30, 0xbe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(190 as u32), ctx.r[30].u8 ) };
	// 82EB0114: 9BDF00C0  stb r30, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u8 ) };
	// 82EB0118: 9BDF00C1  stb r30, 0xc1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(193 as u32), ctx.r[30].u8 ) };
	// 82EB011C: 9BDF00BD  stb r30, 0xbd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(189 as u32), ctx.r[30].u8 ) };
	// 82EB0120: 915F013C  stw r10, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[10].u32 ) };
	// 82EB0124: 93DF0138  stw r30, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[30].u32 ) };
	// 82EB0128: 93DF0134  stw r30, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[30].u32 ) };
	// 82EB012C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0130: D1BF00EC  stfs f13, 0xec(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EB0134: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0138: D1BF00F0  stfs f13, 0xf0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EB013C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0140: D1BF00F4  stfs f13, 0xf4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EB0144: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0148: D1BF00E0  stfs f13, 0xe0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EB014C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0150: D1BF00E4  stfs f13, 0xe4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EB0154: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0158: D1BF00E8  stfs f13, 0xe8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EB015C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0160: D1BF00F8  stfs f13, 0xf8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EB0164: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0168: D1BF00FC  stfs f13, 0xfc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EB016C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0170: D1BF0100  stfs f13, 0x100(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EB0174: 93DF0140  stw r30, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[30].u32 ) };
	// 82EB0178: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB017C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0180: D1BF0144  stfs f13, 0x144(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82EB0184: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0188: D1BF0148  stfs f13, 0x148(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82EB018C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0190: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0194: D1BF014C  stfs f13, 0x14c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82EB0198: 93DF0150  stw r30, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[30].u32 ) };
	// 82EB019C: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82EB01A0: 93DF0154  stw r30, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[30].u32 ) };
	// 82EB01A4: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82EB01A8: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82EB01AC: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EB01B0: 93DF01B0  stw r30, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[30].u32 ) };
	// 82EB01B4: C1AB0B24  lfs f13, 0xb24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB01B8: 93DF01AC  stw r30, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[30].u32 ) };
	// 82EB01BC: D1BF0194  stfs f13, 0x194(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 82EB01C0: 93DF01CC  stw r30, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[30].u32 ) };
	// 82EB01C4: 9BDF01C8  stb r30, 0x1c8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[30].u8 ) };
	// 82EB01C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB01CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB01D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB01D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB01D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB01DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB01E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB01E0 size=12
    let mut pc: u32 = 0x82EB01E0;
    'dispatch: loop {
        match pc {
            0x82EB01E0 => {
    //   block [0x82EB01E0..0x82EB01EC)
	// 82EB01E0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB01E4: 386B8C64  addi r3, r11, -0x739c
	ctx.r[3].s64 = ctx.r[11].s64 + -29596;
	// 82EB01E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB01F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB01F0 size=52
    let mut pc: u32 = 0x82EB01F0;
    'dispatch: loop {
        match pc {
            0x82EB01F0 => {
    //   block [0x82EB01F0..0x82EB0224)
	// 82EB01F0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EB01F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB01F8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EB01FC: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EB0200: 8083006C  lwz r4, 0x6c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB0204: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0208: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82EB020C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EB0210: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0214: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EB0218: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB021C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0220: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0224(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB0224 size=4
    let mut pc: u32 = 0x82EB0224;
    'dispatch: loop {
        match pc {
            0x82EB0224 => {
    //   block [0x82EB0224..0x82EB0228)
	// 82EB0224: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB0228 size=52
    let mut pc: u32 = 0x82EB0228;
    'dispatch: loop {
        match pc {
            0x82EB0228 => {
    //   block [0x82EB0228..0x82EB0240)
	// 82EB0228: 81630160  lwz r11, 0x160(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB022C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0230: 40820010  bne 0x82eb0240
	if !ctx.cr[0].eq {
	pc = 0x82EB0240; continue 'dispatch;
	}
	// 82EB0234: 81430164  lwz r10, 0x164(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB0238: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB023C: 419A0018  beq cr6, 0x82eb0254
	if ctx.cr[6].eq {
	pc = 0x82EB0254; continue 'dispatch;
	}
	pc = 0x82EB0240; continue 'dispatch;
            }
            0x82EB0240 => {
    //   block [0x82EB0240..0x82EB0254)
	// 82EB0240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB0244: 419A0018  beq cr6, 0x82eb025c
	if ctx.cr[6].eq {
		sub_82EB025C(ctx, base);
		return;
	}
	// 82EB0248: 81630164  lwz r11, 0x164(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB024C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB0250: 419A000C  beq cr6, 0x82eb025c
	if ctx.cr[6].eq {
		sub_82EB025C(ctx, base);
		return;
	}
	pc = 0x82EB0254; continue 'dispatch;
            }
            0x82EB0254 => {
    //   block [0x82EB0254..0x82EB025C)
	// 82EB0254: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB0258: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB025C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB025C size=8
    let mut pc: u32 = 0x82EB025C;
    'dispatch: loop {
        match pc {
            0x82EB025C => {
    //   block [0x82EB025C..0x82EB0264)
	// 82EB025C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB0260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB0268 size=52
    let mut pc: u32 = 0x82EB0268;
    'dispatch: loop {
        match pc {
            0x82EB0268 => {
    //   block [0x82EB0268..0x82EB0280)
	// 82EB0268: 81630168  lwz r11, 0x168(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB026C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0270: 40820010  bne 0x82eb0280
	if !ctx.cr[0].eq {
	pc = 0x82EB0280; continue 'dispatch;
	}
	// 82EB0274: 8143016C  lwz r10, 0x16c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB0278: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB027C: 419A0018  beq cr6, 0x82eb0294
	if ctx.cr[6].eq {
	pc = 0x82EB0294; continue 'dispatch;
	}
	pc = 0x82EB0280; continue 'dispatch;
            }
            0x82EB0280 => {
    //   block [0x82EB0280..0x82EB0294)
	// 82EB0280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB0284: 419A0018  beq cr6, 0x82eb029c
	if ctx.cr[6].eq {
		sub_82EB029C(ctx, base);
		return;
	}
	// 82EB0288: 8163016C  lwz r11, 0x16c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB028C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB0290: 419A000C  beq cr6, 0x82eb029c
	if ctx.cr[6].eq {
		sub_82EB029C(ctx, base);
		return;
	}
	pc = 0x82EB0294; continue 'dispatch;
            }
            0x82EB0294 => {
    //   block [0x82EB0294..0x82EB029C)
	// 82EB0294: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB0298: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB029C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB029C size=8
    let mut pc: u32 = 0x82EB029C;
    'dispatch: loop {
        match pc {
            0x82EB029C => {
    //   block [0x82EB029C..0x82EB02A4)
	// 82EB029C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB02A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB02A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB02A8 size=20
    let mut pc: u32 = 0x82EB02A8;
    'dispatch: loop {
        match pc {
            0x82EB02A8 => {
    //   block [0x82EB02A8..0x82EB02BC)
	// 82EB02A8: 81630158  lwz r11, 0x158(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(344 as u32) ) } as u64;
	// 82EB02AC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB02B0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB02B4: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82EB02B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB02C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB02C0 size=44
    let mut pc: u32 = 0x82EB02C0;
    'dispatch: loop {
        match pc {
            0x82EB02C0 => {
    //   block [0x82EB02C0..0x82EB02E4)
	// 82EB02C0: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EB02C4: 814300A0  lwz r10, 0xa0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB02C8: 396B4300  addi r11, r11, 0x4300
	ctx.r[11].s64 = ctx.r[11].s64 + 17152;
	// 82EB02CC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB02D0: 409A0014  bne cr6, 0x82eb02e4
	if !ctx.cr[6].eq {
	pc = 0x82EB02E4; continue 'dispatch;
	}
	// 82EB02D4: 81630178  lwz r11, 0x178(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(376 as u32) ) } as u64;
	// 82EB02D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB02DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB02E0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x82EB02E4; continue 'dispatch;
            }
            0x82EB02E4 => {
    //   block [0x82EB02E4..0x82EB02EC)
	// 82EB02E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB02E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB02F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB02F0 size=2268
    let mut pc: u32 = 0x82EB02F0;
    'dispatch: loop {
        match pc {
            0x82EB02F0 => {
    //   block [0x82EB02F0..0x82EB0358)
	// 82EB02F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB02F4: 4BDF90FD  bl 0x82ca93f0
	ctx.lr = 0x82EB02F8;
	sub_82CA93D0(ctx, base);
	// 82EB02F8: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82EB02FC: 4BDFD9DD  bl 0x82cadcd8
	ctx.lr = 0x82EB0300;
	sub_82CADCA0(ctx, base);
	// 82EB0300: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0304: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0308: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82EB030C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82EB0310: 4B3B06A9  bl 0x822609b8
	ctx.lr = 0x82EB0314;
	sub_822609B8(ctx, base);
	// 82EB0314: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0318: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EB031C: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB0320: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0324: 4BFD1435  bl 0x82e81758
	ctx.lr = 0x82EB0328;
	sub_82E81758(ctx, base);
	// 82EB0328: 987F00C0  stb r3, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[3].u8 ) };
	// 82EB032C: C1BF0110  lfs f13, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0330: C19F0114  lfs f12, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0334: C17F0118  lfs f11, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0338: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB033C: 4182001C  beq 0x82eb0358
	if ctx.cr[0].eq {
	pc = 0x82EB0358; continue 'dispatch;
	}
	// 82EB0340: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0344: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB0348: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB034C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB0350: C19F00E8  lfs f12, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0354: 48000018  b 0x82eb036c
	pc = 0x82EB036C; continue 'dispatch;
            }
            0x82EB0358 => {
    //   block [0x82EB0358..0x82EB036C)
	// 82EB0358: C01F0144  lfs f0, 0x144(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB035C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB0360: C1BF0148  lfs f13, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0364: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB0368: C19F014C  lfs f12, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EB036C; continue 'dispatch;
            }
            0x82EB036C => {
    //   block [0x82EB036C..0x82EB0418)
	// 82EB036C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0370: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0374: D19F00DC  stfs f12, 0xdc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EB0378: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EB037C: D1BF00D8  stfs f13, 0xd8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EB0380: 3B7F00F8  addi r27, r31, 0xf8
	ctx.r[27].s64 = ctx.r[31].s64 + 248;
	// 82EB0384: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EB0388: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 82EB038C: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 82EB0390: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0394: D0170000  stfs f0, 0(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0398: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB039C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB03A0: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB03A4: D0170004  stfs f0, 4(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB03A8: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB03AC: D0170008  stfs f0, 8(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB03B0: C00B0054  lfs f0, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB03B4: D017000C  stfs f0, 0xc(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB03B8: 9B17001C  stb r24, 0x1c(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(28 as u32), ctx.r[24].u8 ) };
	// 82EB03BC: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB03C0: C3DB0000  lfs f30, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB03C4: C3BB0004  lfs f29, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB03C8: C39B0008  lfs f28, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EB03CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB03D0: 41820048  beq 0x82eb0418
	if ctx.cr[0].eq {
	pc = 0x82EB0418; continue 'dispatch;
	}
	// 82EB03D4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB03D8: 419A0040  beq cr6, 0x82eb0418
	if ctx.cr[6].eq {
	pc = 0x82EB0418; continue 'dispatch;
	}
	// 82EB03DC: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB03E0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB03E4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB03E8: 83ABFFFC  lwz r29, -4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB03EC: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB03F0: 41820028  beq 0x82eb0418
	if ctx.cr[0].eq {
	pc = 0x82EB0418; continue 'dispatch;
	}
	// 82EB03F4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB03F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB03FC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0400: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EB0404: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0408: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB040C: 4E800421  bctrl
	ctx.lr = 0x82EB0410;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0410: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0414: 41820020  beq 0x82eb0434
	if ctx.cr[0].eq {
	pc = 0x82EB0434; continue 'dispatch;
	}
            }
            0x82EB0418 => {
    //   block [0x82EB0418..0x82EB0434)
	// 82EB0418: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EB041C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0420: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0424: 4E800421  bctrl
	ctx.lr = 0x82EB0428;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0428: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB042C: 41820008  beq 0x82eb0434
	if ctx.cr[0].eq {
	pc = 0x82EB0434; continue 'dispatch;
	}
	// 82EB0430: 9ADF00BC  stb r22, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[22].u8 ) };
            }
            0x82EB0434 => {
    //   block [0x82EB0434..0x82EB0468)
	// 82EB0434: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82EB0438: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB043C: 419A002C  beq cr6, 0x82eb0468
	if ctx.cr[6].eq {
	pc = 0x82EB0468; continue 'dispatch;
	}
	// 82EB0440: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0444: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB0448: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB044C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EB0450: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0458: 4E800421  bctrl
	ctx.lr = 0x82EB045C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB045C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB0460: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB0464: 409A00F0  bne cr6, 0x82eb0554
	if !ctx.cr[6].eq {
	pc = 0x82EB0554; continue 'dispatch;
	}
            }
            0x82EB0468 => {
    //   block [0x82EB0468..0x82EB04C4)
	// 82EB0468: 897F01B5  lbz r11, 0x1b5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(437 as u32) ) } as u64;
	// 82EB046C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0470: 408200E0  bne 0x82eb0550
	if !ctx.cr[0].eq {
	pc = 0x82EB0550; continue 'dispatch;
	}
	// 82EB0474: 897F00BF  lbz r11, 0xbf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB0478: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB047C: 408200D4  bne 0x82eb0550
	if !ctx.cr[0].eq {
	pc = 0x82EB0550; continue 'dispatch;
	}
	// 82EB0480: C01F0034  lfs f0, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0484: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0488: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB048C: C19F00EC  lfs f12, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0490: EC0D6028  fsubs f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0494: C15F00E4  lfs f10, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB0498: C1BF00F0  lfs f13, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB049C: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB04A0: C19F00E8  lfs f12, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB04A4: C15F00F4  lfs f10, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB04A8: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB04AC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB04B0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB04B4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB04B8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB04BC: 40990008  ble cr6, 0x82eb04c4
	if !ctx.cr[6].gt {
	pc = 0x82EB04C4; continue 'dispatch;
	}
	// 82EB04C0: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	pc = 0x82EB04C4; continue 'dispatch;
            }
            0x82EB04C4 => {
    //   block [0x82EB04C4..0x82EB04F4)
	// 82EB04C4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB04C8: 4082002C  bne 0x82eb04f4
	if !ctx.cr[0].eq {
	pc = 0x82EB04F4; continue 'dispatch;
	}
	// 82EB04CC: 897F0094  lbz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EB04D0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB04D4: 409A0020  bne cr6, 0x82eb04f4
	if !ctx.cr[6].eq {
	pc = 0x82EB04F4; continue 'dispatch;
	}
	// 82EB04D8: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB04DC: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB04E0: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82EB04E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB04E8: 4198000C  blt cr6, 0x82eb04f4
	if ctx.cr[6].lt {
	pc = 0x82EB04F4; continue 'dispatch;
	}
	// 82EB04EC: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB04F0: 9ADF01B5  stb r22, 0x1b5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(437 as u32), ctx.r[22].u8 ) };
	pc = 0x82EB04F4; continue 'dispatch;
            }
            0x82EB04F4 => {
    //   block [0x82EB04F4..0x82EB0528)
	// 82EB04F4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB04F8: 4082005C  bne 0x82eb0554
	if !ctx.cr[0].eq {
	pc = 0x82EB0554; continue 'dispatch;
	}
	// 82EB04FC: 897F00BC  lbz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EB0500: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0504: 40820050  bne 0x82eb0554
	if !ctx.cr[0].eq {
	pc = 0x82EB0554; continue 'dispatch;
	}
	// 82EB0508: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB050C: 409A001C  bne cr6, 0x82eb0528
	if !ctx.cr[6].eq {
	pc = 0x82EB0528; continue 'dispatch;
	}
	// 82EB0510: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0518: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EB051C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0520: 4E800421  bctrl
	ctx.lr = 0x82EB0524;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0524: 48000024  b 0x82eb0548
	pc = 0x82EB0548; continue 'dispatch;
            }
            0x82EB0528 => {
    //   block [0x82EB0528..0x82EB0548)
	// 82EB0528: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB052C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB0530: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0534: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EB0538: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB053C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0540: 4E800421  bctrl
	ctx.lr = 0x82EB0544;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0544: 987F0190  stb r3, 0x190(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[3].u8 ) };
            }
            0x82EB0548 => {
    //   block [0x82EB0548..0x82EB0550)
	// 82EB0548: 8BDF0190  lbz r30, 0x190(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB054C: 48000008  b 0x82eb0554
	pc = 0x82EB0554; continue 'dispatch;
            }
            0x82EB0550 => {
    //   block [0x82EB0550..0x82EB0554)
	// 82EB0550: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	pc = 0x82EB0554; continue 'dispatch;
            }
            0x82EB0554 => {
    //   block [0x82EB0554..0x82EB05C4)
	// 82EB0554: 57DE063F  clrlwi. r30, r30, 0x18
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB0558: 4182006C  beq 0x82eb05c4
	if ctx.cr[0].eq {
	pc = 0x82EB05C4; continue 'dispatch;
	}
	// 82EB055C: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB0560: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0564: 40820060  bne 0x82eb05c4
	if !ctx.cr[0].eq {
	pc = 0x82EB05C4; continue 'dispatch;
	}
	// 82EB0568: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB056C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0570: 9ADF00BE  stb r22, 0xbe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(190 as u32), ctx.r[22].u8 ) };
	// 82EB0574: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB0578: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB057C: 4BFD16BD  bl 0x82e81c38
	ctx.lr = 0x82EB0580;
	sub_82E81C38(ctx, base);
	// 82EB0580: C01F0144  lfs f0, 0x144(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0584: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EB0588: C01F0148  lfs f0, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB058C: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EB0590: C01F014C  lfs f0, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0594: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EB0598: 817F0150  lwz r11, 0x150(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82EB059C: 815F0154  lwz r10, 0x154(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EB05A0: 893F00BF  lbz r9, 0xbf(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB05A4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB05A8: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 82EB05AC: 915F0138  stw r10, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[10].u32 ) };
	// 82EB05B0: 41820014  beq 0x82eb05c4
	if ctx.cr[0].eq {
	pc = 0x82EB05C4; continue 'dispatch;
	}
	// 82EB05B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB05B8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB05BC: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB05C0: 4BFD1049  bl 0x82e81608
	ctx.lr = 0x82EB05C4;
	sub_82E81608(ctx, base);
	pc = 0x82EB05C4; continue 'dispatch;
            }
            0x82EB05C4 => {
    //   block [0x82EB05C4..0x82EB05E4)
	// 82EB05C4: 897F00BC  lbz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EB05C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB05CC: 41820018  beq 0x82eb05e4
	if ctx.cr[0].eq {
	pc = 0x82EB05E4; continue 'dispatch;
	}
	// 82EB05D0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB05D4: 419A05E4  beq cr6, 0x82eb0bb8
	if ctx.cr[6].eq {
	pc = 0x82EB0BB8; continue 'dispatch;
	}
	// 82EB05D8: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB05DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB05E0: 418205D8  beq 0x82eb0bb8
	if ctx.cr[0].eq {
	pc = 0x82EB0BB8; continue 'dispatch;
	}
	pc = 0x82EB05E4; continue 'dispatch;
            }
            0x82EB05E4 => {
    //   block [0x82EB05E4..0x82EB062C)
	// 82EB05E4: 897F00BE  lbz r11, 0xbe(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(190 as u32) ) } as u64;
	// 82EB05E8: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 82EB05EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB05F0: 408201B8  bne 0x82eb07a8
	if !ctx.cr[0].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
	// 82EB05F4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB05F8: 419A01B0  beq cr6, 0x82eb07a8
	if ctx.cr[6].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
	// 82EB05FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB0600: 419A002C  beq cr6, 0x82eb062c
	if ctx.cr[6].eq {
	pc = 0x82EB062C; continue 'dispatch;
	}
	// 82EB0604: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0608: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB060C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0610: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EB0614: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0618: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB061C: 4E800421  bctrl
	ctx.lr = 0x82EB0620;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0620: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB0624: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB0628: 409A0180  bne cr6, 0x82eb07a8
	if !ctx.cr[6].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
            }
            0x82EB062C => {
    //   block [0x82EB062C..0x82EB06F0)
	// 82EB062C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0630: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0634: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB0638: 7EDCB378  mr r28, r22
	ctx.r[28].u64 = ctx.r[22].u64;
	// 82EB063C: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0640: 4BFD14B1  bl 0x82e81af0
	ctx.lr = 0x82EB0644;
	sub_82E81AF0(ctx, base);
	// 82EB0644: 9B1F00BC  stb r24, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[24].u8 ) };
	// 82EB0648: C01F00E0  lfs f0, 0xe0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB064C: D01F00EC  stfs f0, 0xec(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EB0650: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82EB0654: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0658: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EB065C: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EB0660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0664: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0668: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EB066C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0670: 889F0190  lbz r4, 0x190(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB0674: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB0678: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB067C: 4E800421  bctrl
	ctx.lr = 0x82EB0680;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0680: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB0684: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0688: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB068C: 9B1F01B5  stb r24, 0x1b5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(437 as u32), ctx.r[24].u8 ) };
	// 82EB0690: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB0694: 997F00BD  stb r11, 0xbd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(189 as u32), ctx.r[11].u8 ) };
	// 82EB0698: 80AA0014  lwz r5, 0x14(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB069C: 4BFD164D  bl 0x82e81ce8
	ctx.lr = 0x82EB06A0;
	sub_82E81CE8(ctx, base);
	// 82EB06A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB06A4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB06A8: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB06AC: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB06B0: 4BFD13C1  bl 0x82e81a70
	ctx.lr = 0x82EB06B4;
	sub_82E81A70(ctx, base);
	// 82EB06B4: C01F00E0  lfs f0, 0xe0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB06B8: D01F0144  stfs f0, 0x144(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82EB06BC: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB06C0: D01F0148  stfs f0, 0x148(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82EB06C4: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB06C8: D01F014C  stfs f0, 0x14c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82EB06CC: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB06D0: 815F0138  lwz r10, 0x138(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB06D4: 893F00BF  lbz r9, 0xbf(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB06D8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB06DC: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82EB06E0: 915F0154  stw r10, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[10].u32 ) };
	// 82EB06E4: 4182000C  beq 0x82eb06f0
	if ctx.cr[0].eq {
	pc = 0x82EB06F0; continue 'dispatch;
	}
	// 82EB06E8: 9B1F00BD  stb r24, 0xbd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(189 as u32), ctx.r[24].u8 ) };
	// 82EB06EC: 480004CC  b 0x82eb0bb8
	pc = 0x82EB0BB8; continue 'dispatch;
            }
            0x82EB06F0 => {
    //   block [0x82EB06F0..0x82EB0714)
	// 82EB06F0: 897F00BD  lbz r11, 0xbd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(189 as u32) ) } as u64;
	// 82EB06F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB06F8: 418200B0  beq 0x82eb07a8
	if ctx.cr[0].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
	// 82EB06FC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB0700: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0704: 40820010  bne 0x82eb0714
	if !ctx.cr[0].eq {
	pc = 0x82EB0714; continue 'dispatch;
	}
	// 82EB0708: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB070C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0710: 41820098  beq 0x82eb07a8
	if ctx.cr[0].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
	pc = 0x82EB0714; continue 'dispatch;
            }
            0x82EB0714 => {
    //   block [0x82EB0714..0x82EB0740)
	// 82EB0714: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB0718: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82EB071C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0720: 40820020  bne 0x82eb0740
	if !ctx.cr[0].eq {
	pc = 0x82EB0740; continue 'dispatch;
	}
	// 82EB0724: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB0728: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB072C: 4BFE2B05  bl 0x82e93230
	ctx.lr = 0x82EB0730;
	sub_82E93230(ctx, base);
	// 82EB0730: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB0734: 419A000C  beq cr6, 0x82eb0740
	if ctx.cr[6].eq {
	pc = 0x82EB0740; continue 'dispatch;
	}
	// 82EB0738: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB073C: 907F013C  stw r3, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[3].u32 ) };
	pc = 0x82EB0740; continue 'dispatch;
            }
            0x82EB0740 => {
    //   block [0x82EB0740..0x82EB0774)
	// 82EB0740: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0744: 40820050  bne 0x82eb0794
	if !ctx.cr[0].eq {
	pc = 0x82EB0794; continue 'dispatch;
	}
	// 82EB0748: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB074C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB0750: 419A0024  beq cr6, 0x82eb0774
	if ctx.cr[6].eq {
	pc = 0x82EB0774; continue 'dispatch;
	}
	// 82EB0754: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB0758: 931F013C  stw r24, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[24].u32 ) };
	// 82EB075C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0760: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0764: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0768: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB076C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0770: 48000020  b 0x82eb0790
	pc = 0x82EB0790; continue 'dispatch;
            }
            0x82EB0774 => {
    //   block [0x82EB0774..0x82EB0790)
	// 82EB0774: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB0778: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 82EB077C: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0780: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0784: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0788: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB078C: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EB0790; continue 'dispatch;
            }
            0x82EB0790 => {
    //   block [0x82EB0790..0x82EB0794)
	// 82EB0790: D01B0008  stfs f0, 8(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EB0794; continue 'dispatch;
            }
            0x82EB0794 => {
    //   block [0x82EB0794..0x82EB07A8)
	// 82EB0794: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB079C: 816B0088  lwz r11, 0x88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB07A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB07A4: 4E800421  bctrl
	ctx.lr = 0x82EB07A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB07A8 => {
    //   block [0x82EB07A8..0x82EB07D0)
	// 82EB07A8: 897F00BF  lbz r11, 0xbf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB07AC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB07B0: 41820020  beq 0x82eb07d0
	if ctx.cr[0].eq {
	pc = 0x82EB07D0; continue 'dispatch;
	}
	// 82EB07B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB07B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB07BC: 9B1F00BD  stb r24, 0xbd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(189 as u32), ctx.r[24].u8 ) };
	// 82EB07C0: 816B0088  lwz r11, 0x88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB07C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB07C8: 4E800421  bctrl
	ctx.lr = 0x82EB07CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB07CC: 480003EC  b 0x82eb0bb8
	pc = 0x82EB0BB8; continue 'dispatch;
            }
            0x82EB07D0 => {
    //   block [0x82EB07D0..0x82EB07E4)
	// 82EB07D0: 897F00BD  lbz r11, 0xbd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(189 as u32) ) } as u64;
	// 82EB07D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB07D8: 4082000C  bne 0x82eb07e4
	if !ctx.cr[0].eq {
	pc = 0x82EB07E4; continue 'dispatch;
	}
	// 82EB07DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB07E0: 480003DC  b 0x82eb0bbc
	pc = 0x82EB0BBC; continue 'dispatch;
            }
            0x82EB07E4 => {
    //   block [0x82EB07E4..0x82EB0818)
	// 82EB07E4: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB07E8: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EB07EC: 40820074  bne 0x82eb0860
	if !ctx.cr[0].eq {
	pc = 0x82EB0860; continue 'dispatch;
	}
	// 82EB07F0: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB07F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB07F8: 41820020  beq 0x82eb0818
	if ctx.cr[0].eq {
	pc = 0x82EB0818; continue 'dispatch;
	}
	// 82EB07FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0800: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0804: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB0808: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB080C: 4B2FF5E5  bl 0x821afdf0
	ctx.lr = 0x82EB0810;
	sub_821AFDF0(ctx, base);
	// 82EB0810: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB0814: 4800004C  b 0x82eb0860
	pc = 0x82EB0860; continue 'dispatch;
            }
            0x82EB0818 => {
    //   block [0x82EB0818..0x82EB0860)
	// 82EB0818: 4B3B01A1  bl 0x822609b8
	ctx.lr = 0x82EB081C;
	sub_822609B8(ctx, base);
	// 82EB081C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0820: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB0824: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB0828: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB082C: 80AA0014  lwz r5, 0x14(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0830: C3EB004C  lfs f31, 0x4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB0834: 4BFD0E9D  bl 0x82e816d0
	ctx.lr = 0x82EB0838;
	sub_82E816D0(ctx, base);
	// 82EB0838: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB083C: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB0840: EFFF0828  fsubs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EB0844: 4BFD0ABD  bl 0x82e81300
	ctx.lr = 0x82EB0848;
	sub_82E81300(ctx, base);
	// 82EB0848: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB084C: C00B0C4C  lfs f0, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0850: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB0854: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EB0858: 40990008  ble cr6, 0x82eb0860
	if !ctx.cr[6].gt {
	pc = 0x82EB0860; continue 'dispatch;
	}
	// 82EB085C: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	pc = 0x82EB0860; continue 'dispatch;
            }
            0x82EB0860 => {
    //   block [0x82EB0860..0x82EB0894)
	// 82EB0860: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0864: 418200CC  beq 0x82eb0930
	if ctx.cr[0].eq {
	pc = 0x82EB0930; continue 'dispatch;
	}
	// 82EB0868: 83DF013C  lwz r30, 0x13c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB086C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0870: 41820024  beq 0x82eb0894
	if ctx.cr[0].eq {
	pc = 0x82EB0894; continue 'dispatch;
	}
	// 82EB0874: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB0878: 419A001C  beq cr6, 0x82eb0894
	if ctx.cr[6].eq {
	pc = 0x82EB0894; continue 'dispatch;
	}
	// 82EB087C: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB0880: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB0884: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB0888: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB088C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0890: 4082006C  bne 0x82eb08fc
	if !ctx.cr[0].eq {
	pc = 0x82EB08FC; continue 'dispatch;
	}
	pc = 0x82EB0894; continue 'dispatch;
            }
            0x82EB0894 => {
    //   block [0x82EB0894..0x82EB08B4)
	// 82EB0894: 817F0140  lwz r11, 0x140(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82EB0898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB089C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB08A0: 40820014  bne 0x82eb08b4
	if !ctx.cr[0].eq {
	pc = 0x82EB08B4; continue 'dispatch;
	}
	// 82EB08A4: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EB08A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB08AC: 4E800421  bctrl
	ctx.lr = 0x82EB08B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB08B0: 48000038  b 0x82eb08e8
	pc = 0x82EB08E8; continue 'dispatch;
            }
            0x82EB08B4 => {
    //   block [0x82EB08B4..0x82EB08CC)
	// 82EB08B4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EB08B8: 409A0014  bne cr6, 0x82eb08cc
	if !ctx.cr[6].eq {
	pc = 0x82EB08CC; continue 'dispatch;
	}
	// 82EB08BC: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EB08C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB08C4: 4E800421  bctrl
	ctx.lr = 0x82EB08C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB08C8: 48000008  b 0x82eb08d0
	pc = 0x82EB08D0; continue 'dispatch;
            }
            0x82EB08CC => {
    //   block [0x82EB08CC..0x82EB08D0)
	// 82EB08CC: 48003AA5  bl 0x82eb4370
	ctx.lr = 0x82EB08D0;
	sub_82EB4370(ctx, base);
	pc = 0x82EB08D0; continue 'dispatch;
            }
            0x82EB08D0 => {
    //   block [0x82EB08D0..0x82EB08E8)
	// 82EB08D0: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB08D4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB08D8: 419A0010  beq cr6, 0x82eb08e8
	if ctx.cr[6].eq {
	pc = 0x82EB08E8; continue 'dispatch;
	}
	// 82EB08DC: 817F0140  lwz r11, 0x140(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82EB08E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB08E4: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB08E8; continue 'dispatch;
            }
            0x82EB08E8 => {
    //   block [0x82EB08E8..0x82EB08FC)
	// 82EB08E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB08EC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB08F0: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB08F4: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB08F8: 4B414941  bl 0x822c5238
	ctx.lr = 0x82EB08FC;
	sub_822C5238(ctx, base);
	pc = 0x82EB08FC; continue 'dispatch;
            }
            0x82EB08FC => {
    //   block [0x82EB08FC..0x82EB0918)
	// 82EB08FC: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EB0900: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0904: 41820014  beq 0x82eb0918
	if ctx.cr[0].eq {
	pc = 0x82EB0918; continue 'dispatch;
	}
	// 82EB0908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB090C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0910: 4E800421  bctrl
	ctx.lr = 0x82EB0914;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0914: 4800001C  b 0x82eb0930
	pc = 0x82EB0930; continue 'dispatch;
            }
            0x82EB0918 => {
    //   block [0x82EB0918..0x82EB0930)
	// 82EB0918: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB091C: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB0920: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0924: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB0928: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB092C: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	pc = 0x82EB0930; continue 'dispatch;
            }
            0x82EB0930 => {
    //   block [0x82EB0930..0x82EB09BC)
	// 82EB0930: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB0934: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0938: 41820148  beq 0x82eb0a80
	if ctx.cr[0].eq {
	pc = 0x82EB0A80; continue 'dispatch;
	}
	// 82EB093C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB0940: 419A0140  beq cr6, 0x82eb0a80
	if ctx.cr[6].eq {
	pc = 0x82EB0A80; continue 'dispatch;
	}
	// 82EB0944: 813F008C  lwz r9, 0x8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB0948: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB094C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EB0950: 806AFFFC  lwz r3, -4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB0954: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0958: 41820128  beq 0x82eb0a80
	if ctx.cr[0].eq {
	pc = 0x82EB0A80; continue 'dispatch;
	}
	// 82EB095C: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0960: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB0964: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB0968: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB096C: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0970: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB0974: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB0978: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB097C: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0980: 9B010050  stb r24, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u8 ) };
	// 82EB0984: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB0988: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB098C: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0990: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0994: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82EB0998: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EB099C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EB09A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB09A4: 4E800421  bctrl
	ctx.lr = 0x82EB09A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB09A8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB09AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB09B0: 409A000C  bne cr6, 0x82eb09bc
	if !ctx.cr[6].eq {
	pc = 0x82EB09BC; continue 'dispatch;
	}
	// 82EB09B4: 9B1F01B4  stb r24, 0x1b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[24].u8 ) };
	// 82EB09B8: 4800001C  b 0x82eb09d4
	pc = 0x82EB09D4; continue 'dispatch;
            }
            0x82EB09BC => {
    //   block [0x82EB09BC..0x82EB09D4)
	// 82EB09BC: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EB09C0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EB09C4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82EB09C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB09CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB09D0: 4E800421  bctrl
	ctx.lr = 0x82EB09D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB09D4 => {
    //   block [0x82EB09D4..0x82EB09FC)
	// 82EB09D4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB09D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB09DC: 4182008C  beq 0x82eb0a68
	if ctx.cr[0].eq {
	pc = 0x82EB0A68; continue 'dispatch;
	}
	// 82EB09E0: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB09E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB09E8: 41820014  beq 0x82eb09fc
	if ctx.cr[0].eq {
	pc = 0x82EB09FC; continue 'dispatch;
	}
	// 82EB09EC: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB09F0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB09F4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB09F8: 930BFFFC  stw r24, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[24].u32 ) };
	pc = 0x82EB09FC; continue 'dispatch;
            }
            0x82EB09FC => {
    //   block [0x82EB09FC..0x82EB0A38)
	// 82EB09FC: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB0A00: 813F007C  lwz r9, 0x7c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB0A04: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EB0A08: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB0A0C: 4098002C  bge cr6, 0x82eb0a38
	if !ctx.cr[6].lt {
	pc = 0x82EB0A38; continue 'dispatch;
	}
	// 82EB0A10: 813F0088  lwz r9, 0x88(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB0A14: 1D6A000C  mulli r11, r10, 0xc
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB0A18: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EB0A1C: 915F013C  stw r10, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[10].u32 ) };
	// 82EB0A20: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A24: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0A28: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A2C: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB0A30: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A34: 48000018  b 0x82eb0a4c
	pc = 0x82EB0A4C; continue 'dispatch;
            }
            0x82EB0A38 => {
    //   block [0x82EB0A38..0x82EB0A4C)
	// 82EB0A38: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A3C: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0A40: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A44: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB0A48: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EB0A4C; continue 'dispatch;
            }
            0x82EB0A4C => {
    //   block [0x82EB0A4C..0x82EB0A68)
	// 82EB0A4C: D01B0008  stfs f0, 8(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB0A50: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A54: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB0A58: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A5C: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB0A60: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A64: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	pc = 0x82EB0A68; continue 'dispatch;
            }
            0x82EB0A68 => {
    //   block [0x82EB0A68..0x82EB0A80)
	// 82EB0A68: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0A6C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0A70: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0A74: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0A78: 4B4147C1  bl 0x822c5238
	ctx.lr = 0x82EB0A7C;
	sub_822C5238(ctx, base);
	// 82EB0A7C: 480000DC  b 0x82eb0b58
	pc = 0x82EB0B58; continue 'dispatch;
            }
            0x82EB0A80 => {
    //   block [0x82EB0A80..0x82EB0AAC)
	// 82EB0A80: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB0A84: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82EB0A88: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0A8C: 41820020  beq 0x82eb0aac
	if ctx.cr[0].eq {
	pc = 0x82EB0AAC; continue 'dispatch;
	}
	// 82EB0A90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0A94: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0A98: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0A9C: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0AA0: 4B2FF351  bl 0x821afdf0
	ctx.lr = 0x82EB0AA4;
	sub_821AFDF0(ctx, base);
	// 82EB0AA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB0AA8: 4800004C  b 0x82eb0af4
	pc = 0x82EB0AF4; continue 'dispatch;
            }
            0x82EB0AAC => {
    //   block [0x82EB0AAC..0x82EB0AF4)
	// 82EB0AAC: 4B3AFF0D  bl 0x822609b8
	ctx.lr = 0x82EB0AB0;
	sub_822609B8(ctx, base);
	// 82EB0AB0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0AB4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB0AB8: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0ABC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0AC0: 80AA0014  lwz r5, 0x14(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0AC4: C3EB004C  lfs f31, 0x4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB0AC8: 4BFD0C09  bl 0x82e816d0
	ctx.lr = 0x82EB0ACC;
	sub_82E816D0(ctx, base);
	// 82EB0ACC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0AD0: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0AD4: EFFF0828  fsubs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EB0AD8: 4BFD0829  bl 0x82e81300
	ctx.lr = 0x82EB0ADC;
	sub_82E81300(ctx, base);
	// 82EB0ADC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0AE0: C00B0A98  lfs f0, 0xa98(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0AE4: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB0AE8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EB0AEC: 40990008  ble cr6, 0x82eb0af4
	if !ctx.cr[6].gt {
	pc = 0x82EB0AF4; continue 'dispatch;
	}
	// 82EB0AF0: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	pc = 0x82EB0AF4; continue 'dispatch;
            }
            0x82EB0AF4 => {
    //   block [0x82EB0AF4..0x82EB0B28)
	// 82EB0AF4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0AF8: 41820030  beq 0x82eb0b28
	if ctx.cr[0].eq {
	pc = 0x82EB0B28; continue 'dispatch;
	}
	// 82EB0AFC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0B00: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0B04: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0B08: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0B0C: 4B41472D  bl 0x822c5238
	ctx.lr = 0x82EB0B10;
	sub_822C5238(ctx, base);
	// 82EB0B10: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EB0B14: 389F0104  addi r4, r31, 0x104
	ctx.r[4].s64 = ctx.r[31].s64 + 260;
	// 82EB0B18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0B1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0B20: 4E800421  bctrl
	ctx.lr = 0x82EB0B24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0B24: 987F01B6  stb r3, 0x1b6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(438 as u32), ctx.r[3].u8 ) };
            }
            0x82EB0B28 => {
    //   block [0x82EB0B28..0x82EB0B48)
	// 82EB0B28: 897F01B6  lbz r11, 0x1b6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(438 as u32) ) } as u64;
	// 82EB0B2C: 38BF0104  addi r5, r31, 0x104
	ctx.r[5].s64 = ctx.r[31].s64 + 260;
	// 82EB0B30: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82EB0B34: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0B3C: 4182000C  beq 0x82eb0b48
	if ctx.cr[0].eq {
	pc = 0x82EB0B48; continue 'dispatch;
	}
	// 82EB0B40: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EB0B44: 48000008  b 0x82eb0b4c
	pc = 0x82EB0B4C; continue 'dispatch;
            }
            0x82EB0B48 => {
    //   block [0x82EB0B48..0x82EB0B4C)
	// 82EB0B48: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	pc = 0x82EB0B4C; continue 'dispatch;
            }
            0x82EB0B4C => {
    //   block [0x82EB0B4C..0x82EB0B58)
	// 82EB0B4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0B50: 4E800421  bctrl
	ctx.lr = 0x82EB0B54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0B54: 9B1F00BC  stb r24, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[24].u8 ) };
            }
            0x82EB0B58 => {
    //   block [0x82EB0B58..0x82EB0B80)
	// 82EB0B58: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0B5C: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EB0B60: 409A0020  bne cr6, 0x82eb0b80
	if !ctx.cr[6].eq {
	pc = 0x82EB0B80; continue 'dispatch;
	}
	// 82EB0B64: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0B68: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 82EB0B6C: 409A0014  bne cr6, 0x82eb0b80
	if !ctx.cr[6].eq {
	pc = 0x82EB0B80; continue 'dispatch;
	}
	// 82EB0B70: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0B74: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82EB0B78: FF1C0000  fcmpu cr6, f28, f0
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[0].f64);
	// 82EB0B7C: 419A0008  beq cr6, 0x82eb0b84
	if ctx.cr[6].eq {
	pc = 0x82EB0B84; continue 'dispatch;
	}
	pc = 0x82EB0B80; continue 'dispatch;
            }
            0x82EB0B80 => {
    //   block [0x82EB0B80..0x82EB0B84)
	// 82EB0B80: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x82EB0B84; continue 'dispatch;
            }
            0x82EB0B84 => {
    //   block [0x82EB0B84..0x82EB0BA0)
	// 82EB0B84: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0B88: 41820018  beq 0x82eb0ba0
	if ctx.cr[0].eq {
	pc = 0x82EB0BA0; continue 'dispatch;
	}
	// 82EB0B8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0B90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0B94: 816B0088  lwz r11, 0x88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB0B98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0B9C: 4E800421  bctrl
	ctx.lr = 0x82EB0BA0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB0BA0 => {
    //   block [0x82EB0BA0..0x82EB0BB8)
	// 82EB0BA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0BA4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82EB0BA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0BAC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB0BB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0BB4: 4E800421  bctrl
	ctx.lr = 0x82EB0BB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB0BB8 => {
    //   block [0x82EB0BB8..0x82EB0BBC)
	// 82EB0BB8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EB0BBC; continue 'dispatch;
            }
            0x82EB0BBC => {
    //   block [0x82EB0BBC..0x82EB0BCC)
	// 82EB0BBC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EB0BC0: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82EB0BC4: 4BDFD161  bl 0x82cadd24
	ctx.lr = 0x82EB0BC8;
	sub_82CADCEC(ctx, base);
	// 82EB0BC8: 4BDF8878  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB0BD0 size=184
    let mut pc: u32 = 0x82EB0BD0;
    'dispatch: loop {
        match pc {
            0x82EB0BD0 => {
    //   block [0x82EB0BD0..0x82EB0C40)
	// 82EB0BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0BD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB0BD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB0BDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB0BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0BE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0BE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0BEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB0BF0: C1BF01A0  lfs f13, 0x1a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0BF4: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0BF8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB0BFC: C1BF0118  lfs f13, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0C00: C01F0124  lfs f0, 0x124(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0C04: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB0C08: C19F011C  lfs f12, 0x11c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0C0C: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0C10: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB0C14: C17F0120  lfs f11, 0x120(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0C18: C19F0114  lfs f12, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0C1C: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0C20: 419A0020  beq cr6, 0x82eb0c40
	if ctx.cr[6].eq {
	pc = 0x82EB0C40; continue 'dispatch;
	}
	// 82EB0C24: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB0C28: C17F0198  lfs f11, 0x198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0C2C: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB0C30: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB0C34: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB0C38: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EB0C3C: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	pc = 0x82EB0C40; continue 'dispatch;
            }
            0x82EB0C40 => {
    //   block [0x82EB0C40..0x82EB0C88)
	// 82EB0C40: 4B3AFD79  bl 0x822609b8
	ctx.lr = 0x82EB0C44;
	sub_822609B8(ctx, base);
	// 82EB0C44: C1630058  lfs f11, 0x58(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0C48: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0C4C: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB0C50: C1BF01A8  lfs f13, 0x1a8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0C54: C19F019C  lfs f12, 0x19c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0C58: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82EB0C5C: FD600090  fmr f11, f0
	ctx.f[11].f64 = ctx.f[0].f64;
	// 82EB0C60: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB0C64: D01F01A8  stfs f0, 0x1a8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82EB0C68: EDAB602A  fadds f13, f11, f12
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EB0C6C: D1BF019C  stfs f13, 0x19c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82EB0C70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB0C74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB0C78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB0C7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB0C80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB0C84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB0C88 size=156
    let mut pc: u32 = 0x82EB0C88;
    'dispatch: loop {
        match pc {
            0x82EB0C88 => {
    //   block [0x82EB0C88..0x82EB0D24)
	// 82EB0C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0C8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB0C90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB0C94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB0C98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0C9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0CA0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0CA4: 83E30184  lwz r31, 0x184(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(388 as u32) ) } as u64;
	// 82EB0CA8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0CAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB0CB0: D0030198  stfs f0, 0x198(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82EB0CB4: D003019C  stfs f0, 0x19c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82EB0CB8: 99630190  stb r11, 0x190(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(400 as u32), ctx.r[11].u8 ) };
	// 82EB0CBC: C1830110  lfs f12, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0CC0: C1A300F8  lfs f13, 0xf8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0CC4: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0CC8: C16300FC  lfs f11, 0xfc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0CCC: C1830114  lfs f12, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0CD0: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0CD4: C1430118  lfs f10, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB0CD8: C1630100  lfs f11, 0x100(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(256 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0CDC: D00301A8  stfs f0, 0x1a8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82EB0CE0: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB0CE4: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB0CE8: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB0CEC: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB0CF0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB0CF4: D00301A4  stfs f0, 0x1a4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 82EB0CF8: 83CA0014  lwz r30, 0x14(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0CFC: 4B3AFCBD  bl 0x822609b8
	ctx.lr = 0x82EB0D00;
	sub_822609B8(ctx, base);
	// 82EB0D00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB0D04: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB0D08: 4B414531  bl 0x822c5238
	ctx.lr = 0x82EB0D0C;
	sub_822C5238(ctx, base);
	// 82EB0D0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB0D10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB0D14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB0D18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB0D1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB0D20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB0D28 size=192
    let mut pc: u32 = 0x82EB0D28;
    'dispatch: loop {
        match pc {
            0x82EB0D28 => {
    //   block [0x82EB0D28..0x82EB0DAC)
	// 82EB0D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0D2C: 4BDF86E1  bl 0x82ca940c
	ctx.lr = 0x82EB0D30;
	sub_82CA93D0(ctx, base);
	// 82EB0D30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0D34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0D38: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB0D3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0D40: 408200A0  bne 0x82eb0de0
	if !ctx.cr[0].eq {
	pc = 0x82EB0DE0; continue 'dispatch;
	}
	// 82EB0D44: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0D48: 83DF0184  lwz r30, 0x184(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 82EB0D4C: 83AB0014  lwz r29, 0x14(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0D50: 4B3AFC69  bl 0x822609b8
	ctx.lr = 0x82EB0D54;
	sub_822609B8(ctx, base);
	// 82EB0D54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB0D58: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB0D5C: 4B2FF095  bl 0x821afdf0
	ctx.lr = 0x82EB0D60;
	sub_821AFDF0(ctx, base);
	// 82EB0D60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0D64: 4182007C  beq 0x82eb0de0
	if ctx.cr[0].eq {
	pc = 0x82EB0DE0; continue 'dispatch;
	}
	// 82EB0D68: C1BF019C  lfs f13, 0x19c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0D6C: C01F0194  lfs f0, 0x194(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0D70: ED600372  fmuls f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB0D74: C19F0198  lfs f12, 0x198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0D78: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82EB0D7C: 41980030  blt cr6, 0x82eb0dac
	if ctx.cr[6].lt {
	pc = 0x82EB0DAC; continue 'dispatch;
	}
	// 82EB0D80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0D84: C16B0C14  lfs f11, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0D88: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EB0D8C: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB0D90: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EB0D94: 41990018  bgt cr6, 0x82eb0dac
	if ctx.cr[6].gt {
	pc = 0x82EB0DAC; continue 'dispatch;
	}
	// 82EB0D98: C1BF01A4  lfs f13, 0x1a4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0D9C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB0DA0: C1BF01A8  lfs f13, 0x1a8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0DA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB0DA8: 40990028  ble cr6, 0x82eb0dd0
	if !ctx.cr[6].gt {
	pc = 0x82EB0DD0; continue 'dispatch;
	}
	pc = 0x82EB0DAC; continue 'dispatch;
            }
            0x82EB0DAC => {
    //   block [0x82EB0DAC..0x82EB0DD0)
	// 82EB0DAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB0DB0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0DB4: 83DF0184  lwz r30, 0x184(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 82EB0DB8: 997F0190  stb r11, 0x190(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u8 ) };
	// 82EB0DBC: 83AA0014  lwz r29, 0x14(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0DC0: 4B3AFBF9  bl 0x822609b8
	ctx.lr = 0x82EB0DC4;
	sub_822609B8(ctx, base);
	// 82EB0DC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB0DC8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB0DCC: 4B41446D  bl 0x822c5238
	ctx.lr = 0x82EB0DD0;
	sub_822C5238(ctx, base);
	pc = 0x82EB0DD0; continue 'dispatch;
            }
            0x82EB0DD0 => {
    //   block [0x82EB0DD0..0x82EB0DE0)
	// 82EB0DD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0DD4: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0DD8: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82EB0DDC: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	pc = 0x82EB0DE0; continue 'dispatch;
            }
            0x82EB0DE0 => {
    //   block [0x82EB0DE0..0x82EB0DE8)
	// 82EB0DE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB0DE4: 4BDF8678  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB0DE8 size=44
    let mut pc: u32 = 0x82EB0DE8;
    'dispatch: loop {
        match pc {
            0x82EB0DE8 => {
    //   block [0x82EB0DE8..0x82EB0E14)
	// 82EB0DE8: 896300BE  lbz r11, 0xbe(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(190 as u32) ) } as u64;
	// 82EB0DEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0DF0: 40820024  bne 0x82eb0e14
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82EB0E14);
		return;
	}
	// 82EB0DF4: 896300BF  lbz r11, 0xbf(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB0DF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0DFC: 40820018  bne 0x82eb0e14
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82EB0E14);
		return;
	}
	// 82EB0E00: 896300BD  lbz r11, 0xbd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(189 as u32) ) } as u64;
	// 82EB0E04: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB0E08: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB0E0C: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82EB0E10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB0E20 size=352
    let mut pc: u32 = 0x82EB0E20;
    'dispatch: loop {
        match pc {
            0x82EB0E20 => {
    //   block [0x82EB0E20..0x82EB0E50)
	// 82EB0E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0E24: 4BDF85E1  bl 0x82ca9404
	ctx.lr = 0x82EB0E28;
	sub_82CA93D0(ctx, base);
	// 82EB0E28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0E2C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB0E30: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EB0E34: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 82EB0E38: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB0E3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0E40: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB0E44: 4B3B6DDD  bl 0x82267c20
	ctx.lr = 0x82EB0E48;
	sub_82267C20(ctx, base);
	// 82EB0E48: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB0E4C: 4082000C  bne 0x82eb0e58
	if !ctx.cr[0].eq {
	pc = 0x82EB0E58; continue 'dispatch;
	}
	pc = 0x82EB0E50; continue 'dispatch;
            }
            0x82EB0E50 => {
    //   block [0x82EB0E50..0x82EB0E58)
	// 82EB0E50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB0E54: 48000124  b 0x82eb0f78
	pc = 0x82EB0F78; continue 'dispatch;
            }
            0x82EB0E58 => {
    //   block [0x82EB0E58..0x82EB0EAC)
	// 82EB0E58: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB0E5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB0E60: 4BFCB469  bl 0x82e7c2c8
	ctx.lr = 0x82EB0E64;
	sub_82E7C2C8(ctx, base);
	// 82EB0E64: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82EB0E68: 4182FFE8  beq 0x82eb0e50
	if ctx.cr[0].eq {
	pc = 0x82EB0E50; continue 'dispatch;
	}
	// 82EB0E6C: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB0E70: 93BF006C  stw r29, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82EB0E74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0E78: 41820034  beq 0x82eb0eac
	if ctx.cr[0].eq {
	pc = 0x82EB0EAC; continue 'dispatch;
	}
	// 82EB0E7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0E80: 3B7F0070  addi r27, r31, 0x70
	ctx.r[27].s64 = ctx.r[31].s64 + 112;
	// 82EB0E84: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB0E88: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EB0E8C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EB0E90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0E94: 4E800421  bctrl
	ctx.lr = 0x82EB0E98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0E98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0E9C: 40820018  bne 0x82eb0eb4
	if !ctx.cr[0].eq {
	pc = 0x82EB0EB4; continue 'dispatch;
	}
	// 82EB0EA0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB0EA4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB0EA8: 4800000C  b 0x82eb0eb4
	pc = 0x82EB0EB4; continue 'dispatch;
            }
            0x82EB0EAC => {
    //   block [0x82EB0EAC..0x82EB0EB4)
	// 82EB0EAC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB0EB0: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB0EB4; continue 'dispatch;
            }
            0x82EB0EB4 => {
    //   block [0x82EB0EB4..0x82EB0F30)
	// 82EB0EB4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB0EB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB0EBC: 38AB70AC  addi r5, r11, 0x70ac
	ctx.r[5].s64 = ctx.r[11].s64 + 28844;
	// 82EB0EC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB0EC4: 4BFDC1CD  bl 0x82e8d090
	ctx.lr = 0x82EB0EC8;
	sub_82E8D090(ctx, base);
	// 82EB0EC8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB0ECC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB0ED0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB0ED4: 38AB5D84  addi r5, r11, 0x5d84
	ctx.r[5].s64 = ctx.r[11].s64 + 23940;
	// 82EB0ED8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB0EDC: 915F0174  stw r10, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[10].u32 ) };
	// 82EB0EE0: 4BFDC1B1  bl 0x82e8d090
	ctx.lr = 0x82EB0EE4;
	sub_82E8D090(ctx, base);
	// 82EB0EE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0EE8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB0EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0EF0: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB0EF4: 915F0178  stw r10, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[10].u32 ) };
	// 82EB0EF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0EFC: 4E800421  bctrl
	ctx.lr = 0x82EB0F00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0F00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0F04: 4182002C  beq 0x82eb0f30
	if ctx.cr[0].eq {
	pc = 0x82EB0F30; continue 'dispatch;
	}
	// 82EB0F08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0F10: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB0F14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0F18: 4E800421  bctrl
	ctx.lr = 0x82EB0F1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0F1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0F20: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB0F24: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB0F28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0F2C: 4E800421  bctrl
	ctx.lr = 0x82EB0F30;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB0F30 => {
    //   block [0x82EB0F30..0x82EB0F74)
	// 82EB0F30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0F38: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB0F3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0F40: 4E800421  bctrl
	ctx.lr = 0x82EB0F44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0F44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0F48: 4182002C  beq 0x82eb0f74
	if ctx.cr[0].eq {
	pc = 0x82EB0F74; continue 'dispatch;
	}
	// 82EB0F4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0F50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0F54: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB0F58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0F5C: 4E800421  bctrl
	ctx.lr = 0x82EB0F60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0F60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0F64: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB0F68: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0F6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0F70: 4E800421  bctrl
	ctx.lr = 0x82EB0F74;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB0F74 => {
    //   block [0x82EB0F74..0x82EB0F78)
	// 82EB0F74: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EB0F78; continue 'dispatch;
            }
            0x82EB0F78 => {
    //   block [0x82EB0F78..0x82EB0F80)
	// 82EB0F78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB0F7C: 4BDF84D8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB0F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB0F80 size=432
    let mut pc: u32 = 0x82EB0F80;
    'dispatch: loop {
        match pc {
            0x82EB0F80 => {
    //   block [0x82EB0F80..0x82EB0FB8)
	// 82EB0F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0F84: 4BDF8485  bl 0x82ca9408
	ctx.lr = 0x82EB0F88;
	sub_82CA93D0(ctx, base);
	// 82EB0F88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0F8C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EB0F90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0F94: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EB0F98: 409A0020  bne cr6, 0x82eb0fb8
	if !ctx.cr[6].eq {
	pc = 0x82EB0FB8; continue 'dispatch;
	}
	// 82EB0F9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB0FA0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EB0FA4: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EB0FA8: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB0FAC: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 82EB0FB0: 917F0178  stw r11, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 82EB0FB4: 480000AC  b 0x82eb1060
	pc = 0x82EB1060; continue 'dispatch;
            }
            0x82EB0FB8 => {
    //   block [0x82EB0FB8..0x82EB0FDC)
	// 82EB0FB8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB0FBC: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 82EB0FC0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB0FC4: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB0FC8: 4B3B6C59  bl 0x82267c20
	ctx.lr = 0x82EB0FCC;
	sub_82267C20(ctx, base);
	// 82EB0FCC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB0FD0: 4082000C  bne 0x82eb0fdc
	if !ctx.cr[0].eq {
	pc = 0x82EB0FDC; continue 'dispatch;
	}
	// 82EB0FD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB0FD8: 48000114  b 0x82eb10ec
	pc = 0x82EB10EC; continue 'dispatch;
            }
            0x82EB0FDC => {
    //   block [0x82EB0FDC..0x82EB1004)
	// 82EB0FDC: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB0FE0: 939F006C  stw r28, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 82EB0FE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0FE8: 4182003C  beq 0x82eb1024
	if ctx.cr[0].eq {
	pc = 0x82EB1024; continue 'dispatch;
	}
	// 82EB0FEC: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB0FF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB0FF4: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0FF8: 4182002C  beq 0x82eb1024
	if ctx.cr[0].eq {
	pc = 0x82EB1024; continue 'dispatch;
	}
	// 82EB0FFC: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1000: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x82EB1004; continue 'dispatch;
            }
            0x82EB1004 => {
    //   block [0x82EB1004..0x82EB1024)
	// 82EB1004: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1008: 80E70084  lwz r7, 0x84(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EB100C: 7F07E040  cmplw cr6, r7, r28
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EB1010: 419A00E4  beq cr6, 0x82eb10f4
	if ctx.cr[6].eq {
	pc = 0x82EB10F4; continue 'dispatch;
	}
	// 82EB1014: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB1018: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB101C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB1020: 4198FFE4  blt cr6, 0x82eb1004
	if ctx.cr[6].lt {
	pc = 0x82EB1004; continue 'dispatch;
	}
	pc = 0x82EB1024; continue 'dispatch;
            }
            0x82EB1024 => {
    //   block [0x82EB1024..0x82EB102C)
	// 82EB1024: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB1028: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB102C; continue 'dispatch;
            }
            0x82EB102C => {
    //   block [0x82EB102C..0x82EB1060)
	// 82EB102C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB1030: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB1034: 38AB70AC  addi r5, r11, 0x70ac
	ctx.r[5].s64 = ctx.r[11].s64 + 28844;
	// 82EB1038: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB103C: 4BFDC055  bl 0x82e8d090
	ctx.lr = 0x82EB1040;
	sub_82E8D090(ctx, base);
	// 82EB1040: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB1044: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB1048: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB104C: 38AB5D84  addi r5, r11, 0x5d84
	ctx.r[5].s64 = ctx.r[11].s64 + 23940;
	// 82EB1050: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB1054: 915F0174  stw r10, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[10].u32 ) };
	// 82EB1058: 4BFDC039  bl 0x82e8d090
	ctx.lr = 0x82EB105C;
	sub_82E8D090(ctx, base);
	// 82EB105C: 907F0178  stw r3, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[3].u32 ) };
	pc = 0x82EB1060; continue 'dispatch;
            }
            0x82EB1060 => {
    //   block [0x82EB1060..0x82EB10A4)
	// 82EB1060: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1068: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB106C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1070: 4E800421  bctrl
	ctx.lr = 0x82EB1074;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1074: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1078: 4182002C  beq 0x82eb10a4
	if ctx.cr[0].eq {
	pc = 0x82EB10A4; continue 'dispatch;
	}
	// 82EB107C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1084: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB1088: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB108C: 4E800421  bctrl
	ctx.lr = 0x82EB1090;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1090: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1094: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB1098: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB109C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB10A0: 4E800421  bctrl
	ctx.lr = 0x82EB10A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB10A4 => {
    //   block [0x82EB10A4..0x82EB10E8)
	// 82EB10A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB10A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB10AC: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB10B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB10B4: 4E800421  bctrl
	ctx.lr = 0x82EB10B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB10B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB10BC: 4182002C  beq 0x82eb10e8
	if ctx.cr[0].eq {
	pc = 0x82EB10E8; continue 'dispatch;
	}
	// 82EB10C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB10C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB10C8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB10CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB10D0: 4E800421  bctrl
	ctx.lr = 0x82EB10D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB10D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB10D8: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB10DC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB10E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB10E4: 4E800421  bctrl
	ctx.lr = 0x82EB10E8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB10E8 => {
    //   block [0x82EB10E8..0x82EB10EC)
	// 82EB10E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EB10EC; continue 'dispatch;
            }
            0x82EB10EC => {
    //   block [0x82EB10EC..0x82EB10F4)
	// 82EB10EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB10F0: 4BDF8368  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EB10F4 => {
    //   block [0x82EB10F4..0x82EB1130)
	// 82EB10F4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB10F8: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EB10FC: 348B0004  addic. r4, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82EB1100: 4182FF24  beq 0x82eb1024
	if ctx.cr[0].eq {
	pc = 0x82EB1024; continue 'dispatch;
	}
	// 82EB1104: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1108: 3BBF0070  addi r29, r31, 0x70
	ctx.r[29].s64 = ctx.r[31].s64 + 112;
	// 82EB110C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB1110: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EB1114: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1118: 4E800421  bctrl
	ctx.lr = 0x82EB111C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB111C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1120: 4082FF0C  bne 0x82eb102c
	if !ctx.cr[0].eq {
	pc = 0x82EB102C; continue 'dispatch;
	}
	// 82EB1124: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB1128: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB112C: 4BFFFF00  b 0x82eb102c
	pc = 0x82EB102C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB1158 size=12
    let mut pc: u32 = 0x82EB1158;
    'dispatch: loop {
        match pc {
            0x82EB1158 => {
    //   block [0x82EB1158..0x82EB1164)
	// 82EB1158: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB115C: 996301B5  stb r11, 0x1b5(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(437 as u32), ctx.r[11].u8 ) };
	// 82EB1160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB1168 size=12
    let mut pc: u32 = 0x82EB1168;
    'dispatch: loop {
        match pc {
            0x82EB1168 => {
    //   block [0x82EB1168..0x82EB1174)
	// 82EB1168: 816300A4  lwz r11, 0xa4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EB116C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1170: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB1178 size=24
    let mut pc: u32 = 0x82EB1178;
    'dispatch: loop {
        match pc {
            0x82EB1178 => {
    //   block [0x82EB1178..0x82EB1190)
	// 82EB1178: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB117C: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82EB1180: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82EB1184: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB1188: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB118C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB1190 size=1012
    let mut pc: u32 = 0x82EB1190;
    'dispatch: loop {
        match pc {
            0x82EB1190 => {
    //   block [0x82EB1190..0x82EB11EC)
	// 82EB1190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1194: 4BDF826D  bl 0x82ca9400
	ctx.lr = 0x82EB1198;
	sub_82CA93D0(ctx, base);
	// 82EB1198: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EB119C: 4BDFCB3D  bl 0x82cadcd8
	ctx.lr = 0x82EB11A0;
	sub_82CADCA0(ctx, base);
	// 82EB11A0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB11A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB11A8: 3BDF00F8  addi r30, r31, 0xf8
	ctx.r[30].s64 = ctx.r[31].s64 + 248;
	// 82EB11AC: 3BBF0104  addi r29, r31, 0x104
	ctx.r[29].s64 = ctx.r[31].s64 + 260;
	// 82EB11B0: 3B7F0110  addi r27, r31, 0x110
	ctx.r[27].s64 = ctx.r[31].s64 + 272;
	// 82EB11B4: 3B9F0074  addi r28, r31, 0x74
	ctx.r[28].s64 = ctx.r[31].s64 + 116;
	// 82EB11B8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB11BC: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB11C0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB11C4: 409A0028  bne cr6, 0x82eb11ec
	if !ctx.cr[6].eq {
	pc = 0x82EB11EC; continue 'dispatch;
	}
	// 82EB11C8: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB11CC: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB11D0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EB11D4: 409A0018  bne cr6, 0x82eb11ec
	if !ctx.cr[6].eq {
	pc = 0x82EB11EC; continue 'dispatch;
	}
	// 82EB11D8: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB11DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB11E0: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB11E4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EB11E8: 419A0008  beq cr6, 0x82eb11f0
	if ctx.cr[6].eq {
	pc = 0x82EB11F0; continue 'dispatch;
	}
	pc = 0x82EB11EC; continue 'dispatch;
            }
            0x82EB11EC => {
    //   block [0x82EB11EC..0x82EB11F0)
	// 82EB11EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EB11F0; continue 'dispatch;
            }
            0x82EB11F0 => {
    //   block [0x82EB11F0..0x82EB1214)
	// 82EB11F0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB11F4: 41820020  beq 0x82eb1214
	if ctx.cr[0].eq {
	pc = 0x82EB1214; continue 'dispatch;
	}
	// 82EB11F8: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB11FC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB1200: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB1204: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB1208: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB120C: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB1210: 48000364  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
            }
            0x82EB1214 => {
    //   block [0x82EB1214..0x82EB1274)
	// 82EB1214: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB1218: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB121C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB1220: 409802D0  bge cr6, 0x82eb14f0
	if !ctx.cr[6].lt {
	pc = 0x82EB14F0; continue 'dispatch;
	}
	// 82EB1224: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB1228: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB122C: 811F01BC  lwz r8, 0x1bc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EB1230: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EB1234: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB1238: 409A02B8  bne cr6, 0x82eb14f0
	if !ctx.cr[6].eq {
	pc = 0x82EB14F0; continue 'dispatch;
	}
	// 82EB123C: 815F013C  lwz r10, 0x13c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB1240: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB1244: 419902AC  bgt cr6, 0x82eb14f0
	if ctx.cr[6].gt {
	pc = 0x82EB14F0; continue 'dispatch;
	}
	// 82EB1248: 835F0188  lwz r26, 0x188(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB124C: 4B3AF76D  bl 0x822609b8
	ctx.lr = 0x82EB1250;
	sub_822609B8(ctx, base);
	// 82EB1250: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EB1254: 4BFD00AD  bl 0x82e81300
	ctx.lr = 0x82EB1258;
	sub_82E81300(ctx, base);
	// 82EB1258: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB125C: C3AB0C18  lfs f29, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB1260: FF01E800  fcmpu cr6, f1, f29
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 82EB1264: 419A0010  beq cr6, 0x82eb1274
	if ctx.cr[6].eq {
	pc = 0x82EB1274; continue 'dispatch;
	}
	// 82EB1268: C01F01C4  lfs f0, 0x1c4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB126C: EF800072  fmuls f28, f0, f1
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EB1270: 480001C0  b 0x82eb1430
	pc = 0x82EB1430; continue 'dispatch;
            }
            0x82EB1274 => {
    //   block [0x82EB1274..0x82EB1288)
	// 82EB1274: 4B3AF745  bl 0x822609b8
	ctx.lr = 0x82EB1278;
	sub_822609B8(ctx, base);
	// 82EB1278: C01F01C4  lfs f0, 0x1c4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB127C: C1A30058  lfs f13, 0x58(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1280: EF800372  fmuls f28, f0, f13
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1284: 480001AC  b 0x82eb1430
	pc = 0x82EB1430; continue 'dispatch;
            }
            0x82EB1288 => {
    //   block [0x82EB1288..0x82EB12F4)
	// 82EB1288: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB128C: C11D0000  lfs f8, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB1290: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB1294: C0FD0004  lfs f7, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EB1298: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82EB129C: C0DD0008  lfs f6, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EB12A0: D1010070  stfs f8, 0x70(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EB12A4: D0E10074  stfs f7, 0x74(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EB12A8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB12AC: D0C10078  stfs f6, 0x78(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EB12B0: D3A10050  stfs f29, 0x50(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB12B4: D3A10054  stfs f29, 0x54(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB12B8: D3A10058  stfs f29, 0x58(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB12BC: 41980070  blt cr6, 0x82eb132c
	if ctx.cr[6].lt {
	pc = 0x82EB132C; continue 'dispatch;
	}
	// 82EB12C0: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB12C4: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB12C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB12CC: 409A0028  bne cr6, 0x82eb12f4
	if !ctx.cr[6].eq {
	pc = 0x82EB12F4; continue 'dispatch;
	}
	// 82EB12D0: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB12D4: C17F00E4  lfs f11, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB12D8: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82EB12DC: 409A0018  bne cr6, 0x82eb12f4
	if !ctx.cr[6].eq {
	pc = 0x82EB12F4; continue 'dispatch;
	}
	// 82EB12E0: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB12E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB12E8: C17F00E8  lfs f11, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB12EC: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82EB12F0: 419A0008  beq cr6, 0x82eb12f8
	if ctx.cr[6].eq {
	pc = 0x82EB12F8; continue 'dispatch;
	}
	pc = 0x82EB12F4; continue 'dispatch;
            }
            0x82EB12F4 => {
    //   block [0x82EB12F4..0x82EB12F8)
	// 82EB12F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EB12F8; continue 'dispatch;
            }
            0x82EB12F8 => {
    //   block [0x82EB12F8..0x82EB1314)
	// 82EB12F8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB12FC: 41820018  beq 0x82eb1314
	if ctx.cr[0].eq {
	pc = 0x82EB1314; continue 'dispatch;
	}
	// 82EB1300: C19F00E4  lfs f12, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1304: C17F00E8  lfs f11, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB1308: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB130C: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1310: 48000040  b 0x82eb1350
	pc = 0x82EB1350; continue 'dispatch;
            }
            0x82EB1314 => {
    //   block [0x82EB1314..0x82EB132C)
	// 82EB1314: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1318: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EB131C: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB1320: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1324: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1328: 48000028  b 0x82eb1350
	pc = 0x82EB1350; continue 'dispatch;
            }
            0x82EB132C => {
    //   block [0x82EB132C..0x82EB1350)
	// 82EB132C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB1330: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1334: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB1338: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB133C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1340: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1344: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1348: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB134C: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82EB1350; continue 'dispatch;
            }
            0x82EB1350 => {
    //   block [0x82EB1350..0x82EB1388)
	// 82EB1350: ED4D4028  fsubs f10, f13, f8
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB1354: D1610058  stfs f11, 0x58(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB1358: EC0C3828  fsubs f0, f12, f7
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EB135C: ED2B3028  fsubs f9, f11, f6
	ctx.f[9].f64 = (((ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EB1360: ED4A02B2  fmuls f10, f10, f10
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EB1364: EC00503A  fmadds f0, f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EB1368: EC09027A  fmadds f0, f9, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB136C: EFE0002C  fsqrts f31, f0
	ctx.f[31].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB1370: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82EB1374: 419A0014  beq cr6, 0x82eb1388
	if ctx.cr[6].eq {
	pc = 0x82EB1388; continue 'dispatch;
	}
	// 82EB1378: C01F01C0  lfs f0, 0x1c0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB137C: EFDC002A  fadds f30, f28, f0
	ctx.f[30].f64 = ((ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB1380: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82EB1384: 419800B8  blt cr6, 0x82eb143c
	if ctx.cr[6].lt {
	pc = 0x82EB143C; continue 'dispatch;
	}
	pc = 0x82EB1388; continue 'dispatch;
            }
            0x82EB1388 => {
    //   block [0x82EB1388..0x82EB13F4)
	// 82EB1388: C01F01C0  lfs f0, 0x1c0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB138C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB1390: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB1394: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EB1398: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EB139C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB13A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB13A4: EF9C0028  fsubs f28, f28, f0
	ctx.f[28].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB13A8: 4B3D7D71  bl 0x82289118
	ctx.lr = 0x82EB13AC;
	sub_82289118(ctx, base);
	// 82EB13AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB13B0: 408200E0  bne 0x82eb1490
	if !ctx.cr[0].eq {
	pc = 0x82EB1490; continue 'dispatch;
	}
	// 82EB13B4: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB13B8: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB13BC: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB13C0: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB13C4: D1BD0004  stfs f13, 4(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB13C8: D19D0008  stfs f12, 8(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB13CC: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB13D0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB13D4: 409A0020  bne cr6, 0x82eb13f4
	if !ctx.cr[6].eq {
	pc = 0x82EB13F4; continue 'dispatch;
	}
	// 82EB13D8: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB13DC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB13E0: 409A0014  bne cr6, 0x82eb13f4
	if !ctx.cr[6].eq {
	pc = 0x82EB13F4; continue 'dispatch;
	}
	// 82EB13E4: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB13E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB13EC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EB13F0: 419A0008  beq cr6, 0x82eb13f8
	if ctx.cr[6].eq {
	pc = 0x82EB13F8; continue 'dispatch;
	}
	pc = 0x82EB13F4; continue 'dispatch;
            }
            0x82EB13F4 => {
    //   block [0x82EB13F4..0x82EB13F8)
	// 82EB13F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EB13F8; continue 'dispatch;
            }
            0x82EB13F8 => {
    //   block [0x82EB13F8..0x82EB1418)
	// 82EB13F8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB13FC: 408200EC  bne 0x82eb14e8
	if !ctx.cr[0].eq {
	pc = 0x82EB14E8; continue 'dispatch;
	}
	// 82EB1400: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB1404: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB1408: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB140C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB1410: 40980008  bge cr6, 0x82eb1418
	if !ctx.cr[6].lt {
	pc = 0x82EB1418; continue 'dispatch;
	}
	// 82EB1414: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB1418; continue 'dispatch;
            }
            0x82EB1418 => {
    //   block [0x82EB1418..0x82EB1430)
	// 82EB1418: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB141C: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB1420: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB1424: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EB1428: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB142C: D3BF01C0  stfs f29, 0x1c0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	pc = 0x82EB1430; continue 'dispatch;
            }
            0x82EB1430 => {
    //   block [0x82EB1430..0x82EB143C)
	// 82EB1430: FF1CE800  fcmpu cr6, f28, f29
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[29].f64);
	// 82EB1434: 4199FE54  bgt cr6, 0x82eb1288
	if ctx.cr[6].gt {
	pc = 0x82EB1288; continue 'dispatch;
	}
	// 82EB1438: 4800013C  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
            }
            0x82EB143C => {
    //   block [0x82EB143C..0x82EB1490)
	// 82EB143C: EDAD4028  fsubs f13, f13, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB1440: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB1444: EC1EF824  fdivs f0, f30, f31
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 82EB1448: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EB144C: ED8C3828  fsubs f12, f12, f7
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EB1450: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EB1454: ED6B3028  fsubs f11, f11, f6
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EB1458: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB145C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB1460: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1464: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1468: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB146C: EDAD402A  fadds f13, f13, f8
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[8].f64) as f32) as f64;
	// 82EB1470: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB1474: EDAC382A  fadds f13, f12, f7
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[7].f64) as f32) as f64;
	// 82EB1478: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB147C: EC00302A  fadds f0, f0, f6
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64;
	// 82EB1480: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB1484: 4B3D7C95  bl 0x82289118
	ctx.lr = 0x82EB1488;
	sub_82289118(ctx, base);
	// 82EB1488: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB148C: 4182003C  beq 0x82eb14c8
	if ctx.cr[0].eq {
	pc = 0x82EB14C8; continue 'dispatch;
	}
	pc = 0x82EB1490; continue 'dispatch;
            }
            0x82EB1490 => {
    //   block [0x82EB1490..0x82EB14C8)
	// 82EB1490: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1494: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB1498: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB149C: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB14A0: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14A4: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB14A8: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB14AC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB14B0: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB14B4: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB14B8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB14BC: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB14C0: D3BF01C0  stfs f29, 0x1c0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB14C4: 480000B0  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
            }
            0x82EB14C8 => {
    //   block [0x82EB14C8..0x82EB14E8)
	// 82EB14C8: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14CC: D3DF01C0  stfs f30, 0x1c0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB14D0: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB14D4: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14D8: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB14DC: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14E0: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB14E4: 48000090  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
            }
            0x82EB14E8 => {
    //   block [0x82EB14E8..0x82EB14F0)
	// 82EB14E8: D3FF01C0  stfs f31, 0x1c0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB14EC: 48000088  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
            }
            0x82EB14F0 => {
    //   block [0x82EB14F0..0x82EB1550)
	// 82EB14F0: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB14F4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14F8: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB14FC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1500: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1504: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB1508: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB150C: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB1510: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB1514: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB1518: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB151C: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1520: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1524: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB1528: 409A0028  bne cr6, 0x82eb1550
	if !ctx.cr[6].eq {
	pc = 0x82EB1550; continue 'dispatch;
	}
	// 82EB152C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1530: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1534: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB1538: 409A0018  bne cr6, 0x82eb1550
	if !ctx.cr[6].eq {
	pc = 0x82EB1550; continue 'dispatch;
	}
	// 82EB153C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1540: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB1544: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1548: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB154C: 419A0008  beq cr6, 0x82eb1554
	if ctx.cr[6].eq {
	pc = 0x82EB1554; continue 'dispatch;
	}
	pc = 0x82EB1550; continue 'dispatch;
            }
            0x82EB1550 => {
    //   block [0x82EB1550..0x82EB1554)
	// 82EB1550: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EB1554; continue 'dispatch;
            }
            0x82EB1554 => {
    //   block [0x82EB1554..0x82EB1568)
	// 82EB1554: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1558: 41820010  beq 0x82eb1568
	if ctx.cr[0].eq {
	pc = 0x82EB1568; continue 'dispatch;
	}
	// 82EB155C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB1560: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1564: 4800000C  b 0x82eb1570
	pc = 0x82EB1570; continue 'dispatch;
            }
            0x82EB1568 => {
    //   block [0x82EB1568..0x82EB1570)
	// 82EB1568: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB156C: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EB1570; continue 'dispatch;
            }
            0x82EB1570 => {
    //   block [0x82EB1570..0x82EB1574)
	// 82EB1570: D01F01C0  stfs f0, 0x1c0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	pc = 0x82EB1574; continue 'dispatch;
            }
            0x82EB1574 => {
    //   block [0x82EB1574..0x82EB1584)
	// 82EB1574: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EB1578: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EB157C: 4BDFC7A9  bl 0x82cadd24
	ctx.lr = 0x82EB1580;
	sub_82CADCEC(ctx, base);
	// 82EB1580: 4BDF7ED0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB1588 size=72
    let mut pc: u32 = 0x82EB1588;
    'dispatch: loop {
        match pc {
            0x82EB1588 => {
    //   block [0x82EB1588..0x82EB15B8)
	// 82EB1588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB158C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB1590: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB1594: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB1598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB159C: 386001D0  li r3, 0x1d0
	ctx.r[3].s64 = 464;
	// 82EB15A0: 4B765389  bl 0x82616928
	ctx.lr = 0x82EB15A4;
	sub_82616928(ctx, base);
	// 82EB15A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB15A8: 41820010  beq 0x82eb15b8
	if ctx.cr[0].eq {
	pc = 0x82EB15B8; continue 'dispatch;
	}
	// 82EB15AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB15B0: 4BFFEA69  bl 0x82eb0018
	ctx.lr = 0x82EB15B4;
	sub_82EB0018(ctx, base);
	// 82EB15B4: 48000008  b 0x82eb15bc
	pc = 0x82EB15BC; continue 'dispatch;
            }
            0x82EB15B8 => {
    //   block [0x82EB15B8..0x82EB15BC)
	// 82EB15B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB15BC; continue 'dispatch;
            }
            0x82EB15BC => {
    //   block [0x82EB15BC..0x82EB15D0)
	// 82EB15BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB15C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB15C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB15C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB15CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB15D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB15D0 size=228
    let mut pc: u32 = 0x82EB15D0;
    'dispatch: loop {
        match pc {
            0x82EB15D0 => {
    //   block [0x82EB15D0..0x82EB1624)
	// 82EB15D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB15D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB15D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB15DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB15E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB15E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB15E8: 396BA3B0  addi r11, r11, -0x5c50
	ctx.r[11].s64 = ctx.r[11].s64 + -23632;
	// 82EB15EC: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EB15F0: 388A5E98  addi r4, r10, 0x5e98
	ctx.r[4].s64 = ctx.r[10].s64 + 24216;
	// 82EB15F4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB15F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB15FC: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB1600: 4B3B6621  bl 0x82267c20
	ctx.lr = 0x82EB1604;
	sub_82267C20(ctx, base);
	// 82EB1604: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1608: 4182001C  beq 0x82eb1624
	if ctx.cr[0].eq {
	pc = 0x82EB1624; continue 'dispatch;
	}
	// 82EB160C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1610: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EB1614: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EB1618: 388B1130  addi r4, r11, 0x1130
	ctx.r[4].s64 = ctx.r[11].s64 + 4400;
	// 82EB161C: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1620: 4BFE6EC1  bl 0x82e984e0
	ctx.lr = 0x82EB1624;
	sub_82E984E0(ctx, base);
	pc = 0x82EB1624; continue 'dispatch;
            }
            0x82EB1624 => {
    //   block [0x82EB1624..0x82EB165C)
	// 82EB1624: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB1628: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB162C: 41820034  beq 0x82eb1660
	if ctx.cr[0].eq {
	pc = 0x82EB1660; continue 'dispatch;
	}
	// 82EB1630: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB1634: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82EB1638: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB163C: 419A0020  beq cr6, 0x82eb165c
	if ctx.cr[6].eq {
	pc = 0x82EB165C; continue 'dispatch;
	}
	// 82EB1640: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1644: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EB1648: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82EB164C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1650: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1654: 4E800421  bctrl
	ctx.lr = 0x82EB1658;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1658: 48000008  b 0x82eb1660
	pc = 0x82EB1660; continue 'dispatch;
            }
            0x82EB165C => {
    //   block [0x82EB165C..0x82EB1660)
	// 82EB165C: 4B994155  bl 0x828457b0
	ctx.lr = 0x82EB1660;
	sub_828457B0(ctx, base);
	pc = 0x82EB1660; continue 'dispatch;
            }
            0x82EB1660 => {
    //   block [0x82EB1660..0x82EB1680)
	// 82EB1660: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB1664: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1668: 41820018  beq 0x82eb1680
	if ctx.cr[0].eq {
	pc = 0x82EB1680; continue 'dispatch;
	}
	// 82EB166C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1670: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EB1674: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1678: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB167C: 4E800421  bctrl
	ctx.lr = 0x82EB1680;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB1680 => {
    //   block [0x82EB1680..0x82EB16B4)
	// 82EB1680: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB1684: 4BFE18ED  bl 0x82e92f70
	ctx.lr = 0x82EB1688;
	sub_82E92F70(ctx, base);
	// 82EB1688: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB168C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1690: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB1694: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82EB1698: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EB169C: 4BFD41DD  bl 0x82e85878
	ctx.lr = 0x82EB16A0;
	sub_82E85878(ctx, base);
	// 82EB16A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB16A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB16A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB16AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB16B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB16B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB16B8 size=320
    let mut pc: u32 = 0x82EB16B8;
    'dispatch: loop {
        match pc {
            0x82EB16B8 => {
    //   block [0x82EB16B8..0x82EB17B0)
	// 82EB16B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB16BC: 4BDF7D51  bl 0x82ca940c
	ctx.lr = 0x82EB16C0;
	sub_82CA93D0(ctx, base);
	// 82EB16C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB16C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB16C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB16CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB16D0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB16D4: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB16D8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB16DC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB16E0: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB16E4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB16E8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB16EC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB16F0: 4B3AF2C9  bl 0x822609b8
	ctx.lr = 0x82EB16F4;
	sub_822609B8(ctx, base);
	// 82EB16F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB16F8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB16FC: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1700: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EB1704: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EB1708: 995F00BE  stb r10, 0xbe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(190 as u32), ctx.r[10].u8 ) };
	// 82EB170C: 995F00BC  stb r10, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[10].u8 ) };
	// 82EB1710: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1714: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB1718: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB171C: 4E800421  bctrl
	ctx.lr = 0x82EB1720;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1720: C01F0110  lfs f0, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1724: D01F011C  stfs f0, 0x11c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82EB1728: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB172C: C01F0114  lfs f0, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1730: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB1734: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82EB1738: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EB173C: C01F0118  lfs f0, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1744: D01F0124  stfs f0, 0x124(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EB1748: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB174C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1750: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1754: D01F0110  stfs f0, 0x110(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82EB1758: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB175C: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82EB1760: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1764: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82EB1768: 995F01B4  stb r10, 0x1b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[10].u8 ) };
	// 82EB176C: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1770: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EB1774: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1778: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EB177C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1780: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EB1784: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1788: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EB178C: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1790: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EB1794: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1798: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EB179C: 4BFFEB55  bl 0x82eb02f0
	ctx.lr = 0x82EB17A0;
	sub_82EB02F0(ctx, base);
	// 82EB17A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB17A4: 4082000C  bne 0x82eb17b0
	if !ctx.cr[0].eq {
	pc = 0x82EB17B0; continue 'dispatch;
	}
	// 82EB17A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB17AC: 48000044  b 0x82eb17f0
	pc = 0x82EB17F0; continue 'dispatch;
            }
            0x82EB17B0 => {
    //   block [0x82EB17B0..0x82EB17EC)
	// 82EB17B0: 897F00BC  lbz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EB17B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB17B8: 40820034  bne 0x82eb17ec
	if !ctx.cr[0].eq {
	pc = 0x82EB17EC; continue 'dispatch;
	}
	// 82EB17BC: 897F01B4  lbz r11, 0x1b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EB17C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB17C4: 41820028  beq 0x82eb17ec
	if ctx.cr[0].eq {
	pc = 0x82EB17EC; continue 'dispatch;
	}
	// 82EB17C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB17CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EB17D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB17D4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EB17D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB17DC: 4E800421  bctrl
	ctx.lr = 0x82EB17E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB17E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB17E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB17E8: 41820008  beq 0x82eb17f0
	if ctx.cr[0].eq {
	pc = 0x82EB17F0; continue 'dispatch;
	}
            }
            0x82EB17EC => {
    //   block [0x82EB17EC..0x82EB17F0)
	// 82EB17EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EB17F0; continue 'dispatch;
            }
            0x82EB17F0 => {
    //   block [0x82EB17F0..0x82EB17F8)
	// 82EB17F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB17F4: 4BDF7C68  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB17F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB17F8 size=1040
    let mut pc: u32 = 0x82EB17F8;
    'dispatch: loop {
        match pc {
            0x82EB17F8 => {
    //   block [0x82EB17F8..0x82EB1858)
	// 82EB17F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB17FC: 4BDF7C11  bl 0x82ca940c
	ctx.lr = 0x82EB1800;
	sub_82CA93D0(ctx, base);
	// 82EB1800: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EB1804: 4BDFC4C1  bl 0x82cadcc4
	ctx.lr = 0x82EB1808;
	sub_82CADCA0(ctx, base);
	// 82EB1808: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB180C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EB1810: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EB1814: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82EB1818: 394A115C  addi r10, r10, 0x115c
	ctx.r[10].s64 = ctx.r[10].s64 + 4444;
	// 82EB181C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB1820: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82EB1824: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1828: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB182C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB1830: 409A0028  bne cr6, 0x82eb1858
	if !ctx.cr[6].eq {
	pc = 0x82EB1858; continue 'dispatch;
	}
	// 82EB1834: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1838: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB183C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB1840: 409A0018  bne cr6, 0x82eb1858
	if !ctx.cr[6].eq {
	pc = 0x82EB1858; continue 'dispatch;
	}
	// 82EB1844: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1848: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB184C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1850: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB1854: 419A0008  beq cr6, 0x82eb185c
	if ctx.cr[6].eq {
	pc = 0x82EB185C; continue 'dispatch;
	}
	pc = 0x82EB1858; continue 'dispatch;
            }
            0x82EB1858 => {
    //   block [0x82EB1858..0x82EB185C)
	// 82EB1858: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x82EB185C; continue 'dispatch;
            }
            0x82EB185C => {
    //   block [0x82EB185C..0x82EB18C8)
	// 82EB185C: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB1860: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EB1864: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EB1868: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB186C: C3280C18  lfs f25, 0xc18(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EB1870: C2E90EE0  lfs f23, 0xee0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3808 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82EB1874: C30A0C14  lfs f24, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EB1878: 418202C0  beq 0x82eb1b38
	if ctx.cr[0].eq {
	pc = 0x82EB1B38; continue 'dispatch;
	}
	// 82EB187C: 815F0164  lwz r10, 0x164(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB1880: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB1884: 419A00C0  beq cr6, 0x82eb1944
	if ctx.cr[6].eq {
	pc = 0x82EB1944; continue 'dispatch;
	}
	// 82EB1888: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EB188C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EB1890: 4BFD44D9  bl 0x82e85d68
	ctx.lr = 0x82EB1894;
	sub_82E85D68(ctx, base);
	// 82EB1894: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1898: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB189C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB18A0: C00B0044  lfs f0, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB18A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB18A8: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB18AC: C1AB0A44  lfs f13, 0xa44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2628 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18B0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB18B4: 40990014  ble cr6, 0x82eb18c8
	if !ctx.cr[6].gt {
	pc = 0x82EB18C8; continue 'dispatch;
	}
	// 82EB18B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB18BC: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18C0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB18C4: 48000020  b 0x82eb18e4
	pc = 0x82EB18E4; continue 'dispatch;
            }
            0x82EB18C8 => {
    //   block [0x82EB18C8..0x82EB18E4)
	// 82EB18C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB18CC: C1AB89C8  lfs f13, -0x7638(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB18D4: 40980010  bge cr6, 0x82eb18e4
	if !ctx.cr[6].lt {
	pc = 0x82EB18E4; continue 'dispatch;
	}
	// 82EB18D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB18DC: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18E0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	pc = 0x82EB18E4; continue 'dispatch;
            }
            0x82EB18E4 => {
    //   block [0x82EB18E4..0x82EB1900)
	// 82EB18E4: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EB18E8: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18EC: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB18F0: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EB18F4: 40980034  bge cr6, 0x82eb1928
	if !ctx.cr[6].lt {
	pc = 0x82EB1928; continue 'dispatch;
	}
	// 82EB18F8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EB18FC: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EB1900; continue 'dispatch;
            }
            0x82EB1900 => {
    //   block [0x82EB1900..0x82EB1914)
	// 82EB1900: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 82EB1904: 41980010  blt cr6, 0x82eb1914
	if ctx.cr[6].lt {
	pc = 0x82EB1914; continue 'dispatch;
	}
	// 82EB1908: FF00C000  fcmpu cr6, f0, f24
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[24].f64);
	// 82EB190C: 41990008  bgt cr6, 0x82eb1914
	if ctx.cr[6].gt {
	pc = 0x82EB1914; continue 'dispatch;
	}
	// 82EB1910: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82EB1914; continue 'dispatch;
            }
            0x82EB1914 => {
    //   block [0x82EB1914..0x82EB1920)
	// 82EB1914: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82EB1918: 409AFFE8  bne cr6, 0x82eb1900
	if !ctx.cr[6].eq {
	pc = 0x82EB1900; continue 'dispatch;
	}
	// 82EB191C: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EB1920; continue 'dispatch;
            }
            0x82EB1920 => {
    //   block [0x82EB1920..0x82EB1928)
	// 82EB1920: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1924: 48000214  b 0x82eb1b38
	pc = 0x82EB1B38; continue 'dispatch;
            }
            0x82EB1928 => {
    //   block [0x82EB1928..0x82EB193C)
	// 82EB1928: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82EB192C: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1930: 4099000C  ble cr6, 0x82eb193c
	if !ctx.cr[6].gt {
	pc = 0x82EB193C; continue 'dispatch;
	}
	// 82EB1934: D30B0008  stfs f24, 8(r11)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1938: 48000200  b 0x82eb1b38
	pc = 0x82EB1B38; continue 'dispatch;
            }
            0x82EB193C => {
    //   block [0x82EB193C..0x82EB1944)
	// 82EB193C: D2EB0008  stfs f23, 8(r11)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1940: 480001F8  b 0x82eb1b38
	pc = 0x82EB1B38; continue 'dispatch;
            }
            0x82EB1944 => {
    //   block [0x82EB1944..0x82EB19AC)
	// 82EB1944: 815F0160  lwz r10, 0x160(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB1948: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB194C: 419A02A8  beq cr6, 0x82eb1bf4
	if ctx.cr[6].eq {
	pc = 0x82EB1BF4; continue 'dispatch;
	}
	// 82EB1950: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1954: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EB1958: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB195C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EB1960: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1964: D3210054  stfs f25, 0x54(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1968: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB196C: 4B3CD8FD  bl 0x8227f268
	ctx.lr = 0x82EB1970;
	sub_8227F268(ctx, base);
	// 82EB1970: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1974: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1978: C3E30008  lfs f31, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB197C: C3C30000  lfs f30, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB1980: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1984: C1AB0050  lfs f13, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1988: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB198C: C1AB0054  lfs f13, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1990: C18B004C  lfs f12, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1994: EC0D07FA  fmadds f0, f13, f31, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB1998: EC2C07BA  fmadds f1, f12, f30, f0
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB199C: FF01C000  fcmpu cr6, f1, f24
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[24].f64);
	// 82EB19A0: 4198000C  blt cr6, 0x82eb19ac
	if ctx.cr[6].lt {
	pc = 0x82EB19AC; continue 'dispatch;
	}
	// 82EB19A4: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	// 82EB19A8: 48000020  b 0x82eb19c8
	pc = 0x82EB19C8; continue 'dispatch;
            }
            0x82EB19AC => {
    //   block [0x82EB19AC..0x82EB19C0)
	// 82EB19AC: FF01B800  fcmpu cr6, f1, f23
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[23].f64);
	// 82EB19B0: 41990010  bgt cr6, 0x82eb19c0
	if ctx.cr[6].gt {
	pc = 0x82EB19C0; continue 'dispatch;
	}
	// 82EB19B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB19B8: C00BA3A4  lfs f0, -0x5c5c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB19BC: 4800000C  b 0x82eb19c8
	pc = 0x82EB19C8; continue 'dispatch;
            }
            0x82EB19C0 => {
    //   block [0x82EB19C0..0x82EB19C8)
	// 82EB19C0: 4B3AEF81  bl 0x82260940
	ctx.lr = 0x82EB19C4;
	sub_82260940(ctx, base);
	// 82EB19C4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	pc = 0x82EB19C8; continue 'dispatch;
            }
            0x82EB19C8 => {
    //   block [0x82EB19C8..0x82EB19F8)
	// 82EB19C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB19CC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB19D0: C1AB004C  lfs f13, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB19D4: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB19D8: C18B0054  lfs f12, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB19DC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB19E0: EDAC6FB8  fmsubs f13, f12, f30, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB19E4: FF0DC800  fcmpu cr6, f13, f25
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[25].f64);
	// 82EB19E8: C1ABDF1C  lfs f13, -0x20e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8420 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB19EC: 4099000C  ble cr6, 0x82eb19f8
	if !ctx.cr[6].gt {
	pc = 0x82EB19F8; continue 'dispatch;
	}
	// 82EB19F0: EFC06824  fdivs f30, f0, f13
	ctx.f[30].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EB19F4: 4800000C  b 0x82eb1a00
	pc = 0x82EB1A00; continue 'dispatch;
            }
            0x82EB19F8 => {
    //   block [0x82EB19F8..0x82EB1A00)
	// 82EB19F8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EB19FC: FFC00050  fneg f30, f0
	ctx.f[30].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82EB1A00; continue 'dispatch;
            }
            0x82EB1A00 => {
    //   block [0x82EB1A00..0x82EB1A3C)
	// 82EB1A00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1A04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB1A08: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB1A0C: FF60F210  fabs f27, f30
	ctx.f[27].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 82EB1A10: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1A14: C3AA0A44  lfs f29, 0xa44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2628 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB1A18: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EB1A1C: C3E989CC  lfs f31, -0x7634(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB1A20: C0030044  lfs f0, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1A24: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EB1A28: C38A89C8  lfs f28, -0x7638(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30264 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EB1A2C: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EB1A30: 4099000C  ble cr6, 0x82eb1a3c
	if !ctx.cr[6].gt {
	pc = 0x82EB1A3C; continue 'dispatch;
	}
	// 82EB1A34: EF40F828  fsubs f26, f0, f31
	ctx.f[26].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EB1A38: 48000018  b 0x82eb1a50
	pc = 0x82EB1A50; continue 'dispatch;
            }
            0x82EB1A3C => {
    //   block [0x82EB1A3C..0x82EB1A4C)
	// 82EB1A3C: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82EB1A40: 4098000C  bge cr6, 0x82eb1a4c
	if !ctx.cr[6].lt {
	pc = 0x82EB1A4C; continue 'dispatch;
	}
	// 82EB1A44: EF40F82A  fadds f26, f0, f31
	ctx.f[26].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EB1A48: 48000008  b 0x82eb1a50
	pc = 0x82EB1A50; continue 'dispatch;
            }
            0x82EB1A4C => {
    //   block [0x82EB1A4C..0x82EB1A50)
	// 82EB1A4C: FF400090  fmr f26, f0
	ctx.f[26].f64 = ctx.f[0].f64;
	pc = 0x82EB1A50; continue 'dispatch;
            }
            0x82EB1A50 => {
    //   block [0x82EB1A50..0x82EB1A98)
	// 82EB1A50: 895D001C  lbz r10, 0x1c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EB1A54: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1A58: 41820058  beq 0x82eb1ab0
	if ctx.cr[0].eq {
	pc = 0x82EB1AB0; continue 'dispatch;
	}
	// 82EB1A5C: 895F0069  lbz r10, 0x69(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(105 as u32) ) } as u64;
	// 82EB1A60: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1A64: 4182004C  beq 0x82eb1ab0
	if ctx.cr[0].eq {
	pc = 0x82EB1AB0; continue 'dispatch;
	}
	// 82EB1A68: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EB1A6C: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB1A70: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB1A74: 388AC904  addi r4, r10, -0x36fc
	ctx.r[4].s64 = ctx.r[10].s64 + -14076;
	// 82EB1A78: 4BFCBC49  bl 0x82e7d6c0
	ctx.lr = 0x82EB1A7C;
	sub_82E7D6C0(ctx, base);
	// 82EB1A7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1A80: 4182003C  beq 0x82eb1abc
	if ctx.cr[0].eq {
	pc = 0x82EB1ABC; continue 'dispatch;
	}
	// 82EB1A84: C01D0014  lfs f0, 0x14(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1A88: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EB1A8C: 4099000C  ble cr6, 0x82eb1a98
	if !ctx.cr[6].gt {
	pc = 0x82EB1A98; continue 'dispatch;
	}
	// 82EB1A90: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EB1A94: 48000010  b 0x82eb1aa4
	pc = 0x82EB1AA4; continue 'dispatch;
            }
            0x82EB1A98 => {
    //   block [0x82EB1A98..0x82EB1AA4)
	// 82EB1A98: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82EB1A9C: 40980008  bge cr6, 0x82eb1aa4
	if !ctx.cr[6].lt {
	pc = 0x82EB1AA4; continue 'dispatch;
	}
	// 82EB1AA0: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	pc = 0x82EB1AA4; continue 'dispatch;
            }
            0x82EB1AA4 => {
    //   block [0x82EB1AA4..0x82EB1AB0)
	// 82EB1AA4: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB1AA8: 9BC30004  stb r30, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1AAC: 48000010  b 0x82eb1abc
	pc = 0x82EB1ABC; continue 'dispatch;
            }
            0x82EB1AB0 => {
    //   block [0x82EB1AB0..0x82EB1ABC)
	// 82EB1AB0: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1AB4: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EB1AB8: 40980010  bge cr6, 0x82eb1ac8
	if !ctx.cr[6].lt {
	pc = 0x82EB1AC8; continue 'dispatch;
	}
	pc = 0x82EB1ABC; continue 'dispatch;
            }
            0x82EB1ABC => {
    //   block [0x82EB1ABC..0x82EB1AC8)
	// 82EB1ABC: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB1AC0: D34B0008  stfs f26, 8(r11)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1AC4: 4BFFFE5C  b 0x82eb1920
	pc = 0x82EB1920; continue 'dispatch;
            }
            0x82EB1AC8 => {
    //   block [0x82EB1AC8..0x82EB1AF4)
	// 82EB1AC8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB1ACC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB1AD0: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82EB1AD4: 4B336BA5  bl 0x821e8678
	ctx.lr = 0x82EB1AD8;
	sub_821E8678(ctx, base);
	// 82EB1AD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1ADC: 40820018  bne 0x82eb1af4
	if !ctx.cr[0].eq {
	pc = 0x82EB1AF4; continue 'dispatch;
	}
	// 82EB1AE0: C01F0050  lfs f0, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1AE4: EC00D824  fdivs f0, f0, f27
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[27].f64) as f32) as f64;
	// 82EB1AE8: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1AEC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1AF0: 48000014  b 0x82eb1b04
	pc = 0x82EB1B04; continue 'dispatch;
            }
            0x82EB1AF4 => {
    //   block [0x82EB1AF4..0x82EB1B04)
	// 82EB1AF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB1AF8: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1AFC: C00B0BF8  lfs f0, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1B00: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82EB1B04; continue 'dispatch;
            }
            0x82EB1B04 => {
    //   block [0x82EB1B04..0x82EB1B30)
	// 82EB1B04: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB1B08: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1B0C: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB1B10: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1B14: FF1EC800  fcmpu cr6, f30, f25
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[25].f64);
	// 82EB1B18: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1B1C: C1AA0044  lfs f13, 0x44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1B20: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1B24: 4099000C  ble cr6, 0x82eb1b30
	if !ctx.cr[6].gt {
	pc = 0x82EB1B30; continue 'dispatch;
	}
	// 82EB1B28: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB1B2C: 48000008  b 0x82eb1b34
	pc = 0x82EB1B34; continue 'dispatch;
            }
            0x82EB1B30 => {
    //   block [0x82EB1B30..0x82EB1B34)
	// 82EB1B30: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x82EB1B34; continue 'dispatch;
            }
            0x82EB1B34 => {
    //   block [0x82EB1B34..0x82EB1B38)
	// 82EB1B34: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EB1B38; continue 'dispatch;
            }
            0x82EB1B38 => {
    //   block [0x82EB1B38..0x82EB1B64)
	// 82EB1B38: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB1B3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1B40: 41820040  beq 0x82eb1b80
	if ctx.cr[0].eq {
	pc = 0x82EB1B80; continue 'dispatch;
	}
	// 82EB1B44: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1B48: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1B4C: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1B50: C1AA0058  lfs f13, 0x58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1B54: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB1B58: 4099000C  ble cr6, 0x82eb1b64
	if !ctx.cr[6].gt {
	pc = 0x82EB1B64; continue 'dispatch;
	}
	// 82EB1B5C: D30B0008  stfs f24, 8(r11)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1B60: 48000034  b 0x82eb1b94
	pc = 0x82EB1B94; continue 'dispatch;
            }
            0x82EB1B64 => {
    //   block [0x82EB1B64..0x82EB1B78)
	// 82EB1B64: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB1B68: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1B6C: 4098000C  bge cr6, 0x82eb1b78
	if !ctx.cr[6].lt {
	pc = 0x82EB1B78; continue 'dispatch;
	}
	// 82EB1B70: D2EB0008  stfs f23, 8(r11)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1B74: 48000024  b 0x82eb1b98
	pc = 0x82EB1B98; continue 'dispatch;
            }
            0x82EB1B78 => {
    //   block [0x82EB1B78..0x82EB1B80)
	// 82EB1B78: D32B0008  stfs f25, 8(r11)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1B7C: 4800001C  b 0x82eb1b98
	pc = 0x82EB1B98; continue 'dispatch;
            }
            0x82EB1B80 => {
    //   block [0x82EB1B80..0x82EB1B94)
	// 82EB1B80: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB1B84: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1B88: 4182006C  beq 0x82eb1bf4
	if ctx.cr[0].eq {
	pc = 0x82EB1BF4; continue 'dispatch;
	}
	// 82EB1B8C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1B90: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EB1B94; continue 'dispatch;
            }
            0x82EB1B94 => {
    //   block [0x82EB1B94..0x82EB1B98)
	// 82EB1B94: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	pc = 0x82EB1B98; continue 'dispatch;
            }
            0x82EB1B98 => {
    //   block [0x82EB1B98..0x82EB1BEC)
	// 82EB1B98: 817F015C  lwz r11, 0x15c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 82EB1B9C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1BA0: 4182004C  beq 0x82eb1bec
	if ctx.cr[0].eq {
	pc = 0x82EB1BEC; continue 'dispatch;
	}
	// 82EB1BA4: 896B0004  lbz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1BA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1BAC: 41820040  beq 0x82eb1bec
	if ctx.cr[0].eq {
	pc = 0x82EB1BEC; continue 'dispatch;
	}
	// 82EB1BB0: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82EB1BB4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1BB8: 4182003C  beq 0x82eb1bf4
	if ctx.cr[0].eq {
	pc = 0x82EB1BF4; continue 'dispatch;
	}
	// 82EB1BBC: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1BC0: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1BC4: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1BC8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1BCC: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1BD0: EC00C03C  fnmsubs f0, f0, f0, f24
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[0].f64 - ctx.f[24].f64) as f32) as f64);
	// 82EB1BD4: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB1BD8: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1BDC: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1BE0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB1BE4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1BE8: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EB1BEC; continue 'dispatch;
            }
            0x82EB1BEC => {
    //   block [0x82EB1BEC..0x82EB1BF4)
	// 82EB1BEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB1BF0: 48000008  b 0x82eb1bf8
	pc = 0x82EB1BF8; continue 'dispatch;
            }
            0x82EB1BF4 => {
    //   block [0x82EB1BF4..0x82EB1BF8)
	// 82EB1BF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB1BF8; continue 'dispatch;
            }
            0x82EB1BF8 => {
    //   block [0x82EB1BF8..0x82EB1C08)
	// 82EB1BF8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EB1BFC: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EB1C00: 4BDFC111  bl 0x82cadd10
	ctx.lr = 0x82EB1C04;
	sub_82CADCEC(ctx, base);
	// 82EB1C04: 4BDF7858  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB1C08 size=748
    let mut pc: u32 = 0x82EB1C08;
    'dispatch: loop {
        match pc {
            0x82EB1C08 => {
    //   block [0x82EB1C08..0x82EB1CF8)
	// 82EB1C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1C0C: 4BDF77F5  bl 0x82ca9400
	ctx.lr = 0x82EB1C10;
	sub_82CA93D0(ctx, base);
	// 82EB1C10: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EB1C14: 4BDFC091  bl 0x82cadca4
	ctx.lr = 0x82EB1C18;
	sub_82CADCA0(ctx, base);
	// 82EB1C18: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB1C1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB1C20: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB1C24: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB1C28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB1C2C: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EB1C30: C17E0000  lfs f11, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB1C34: C19D0000  lfs f12, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1C38: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB1C3C: C13E0004  lfs f9, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB1C40: C15D0004  lfs f10, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB1C44: ED4A4828  fsubs f10, f10, f9
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB1C48: C11D0008  lfs f8, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB1C4C: C13E0008  lfs f9, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB1C50: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB1C54: ED284828  fsubs f9, f8, f9
	ctx.f[9].f64 = (((ctx.f[8].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB1C58: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1C5C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1C60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB1C64: ED0C02F2  fmuls f8, f12, f11
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1C68: C30B0C18  lfs f24, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EB1C6C: ECEA0372  fmuls f7, f10, f13
	ctx.f[7].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1C70: ECC90032  fmuls f6, f9, f0
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1C74: EDA94378  fmsubs f13, f9, f13, f8
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB1C78: EC0C3838  fmsubs f0, f12, f0, f7
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EB1C7C: ED8A32F8  fmsubs f12, f10, f11, f6
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EB1C80: ED6D0372  fmuls f11, f13, f13
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1C84: ED60583A  fmadds f11, f0, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EB1C88: ED6C5B3A  fmadds f11, f12, f12, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EB1C8C: ED60582C  fsqrts f11, f11
	ctx.f[11].f64 = ((ctx.f[11].f64).sqrt() as f32) as f64;
	// 82EB1C90: FF0BC000  fcmpu cr6, f11, f24
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[24].f64);
	// 82EB1C94: 419A0244  beq cr6, 0x82eb1ed8
	if ctx.cr[6].eq {
	pc = 0x82EB1ED8; continue 'dispatch;
	}
	// 82EB1C98: 815F0158  lwz r10, 0x158(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 82EB1C9C: C15F0060  lfs f10, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB1CA0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1CA4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB1CA8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB1CAC: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EB1CB0: C12A0004  lfs f9, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB1CB4: ED695824  fdivs f11, f9, f11
	ctx.f[11].f64 = ((ctx.f[9].f64 / ctx.f[11].f64) as f32) as f64;
	// 82EB1CB8: 80690014  lwz r3, 0x14(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1CBC: ED6B02B2  fmuls f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EB1CC0: EECC02F2  fmuls f22, f12, f11
	ctx.f[22].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1CC4: EEAD02F2  fmuls f21, f13, f11
	ctx.f[21].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1CC8: EE8002F2  fmuls f20, f0, f11
	ctx.f[20].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1CCC: 4B3369AD  bl 0x821e8678
	ctx.lr = 0x82EB1CD0;
	sub_821E8678(ctx, base);
	// 82EB1CD0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB1CD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB1CD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1CDC: 3F608334  lis r27, -0x7ccc
	ctx.r[27].s64 = -2093744128;
	// 82EB1CE0: C1EA0C14  lfs f15, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[15].f64 = (tmp.f32 as f64);
	// 82EB1CE4: C22B0BFC  lfs f17, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 82EB1CE8: 41820010  beq 0x82eb1cf8
	if ctx.cr[0].eq {
	pc = 0x82EB1CF8; continue 'dispatch;
	}
	// 82EB1CEC: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1CF0: EE600472  fmuls f19, f0, f17
	ctx.f[19].f64 = (((ctx.f[0].f64 * ctx.f[17].f64) as f32) as f64);
	// 82EB1CF4: 4800001C  b 0x82eb1d10
	pc = 0x82EB1D10; continue 'dispatch;
            }
            0x82EB1CF8 => {
    //   block [0x82EB1CF8..0x82EB1D0C)
	// 82EB1CF8: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB1CFC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1D00: 4182000C  beq 0x82eb1d0c
	if ctx.cr[0].eq {
	pc = 0x82EB1D0C; continue 'dispatch;
	}
	// 82EB1D04: C26B000C  lfs f19, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 82EB1D08: 48000008  b 0x82eb1d10
	pc = 0x82EB1D10; continue 'dispatch;
            }
            0x82EB1D0C => {
    //   block [0x82EB1D0C..0x82EB1D10)
	// 82EB1D0C: FE607890  fmr f19, f15
	ctx.f[19].f64 = ctx.f[15].f64;
	pc = 0x82EB1D10; continue 'dispatch;
            }
            0x82EB1D10 => {
    //   block [0x82EB1D10..0x82EB1D38)
	// 82EB1D10: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82EB1D14: C25F0058  lfs f18, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 82EB1D18: D3010050  stfs f24, 0x50(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1D1C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EB1D20: D3010054  stfs f24, 0x54(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1D24: D3010058  stfs f24, 0x58(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB1D28: D3010060  stfs f24, 0x60(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB1D2C: C20B84AC  lfs f16, -0x7b54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31572 as u32) ) };
	ctx.f[16].f64 = (tmp.f32 as f64);
	// 82EB1D30: D3010064  stfs f24, 0x64(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB1D34: D3010068  stfs f24, 0x68(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	pc = 0x82EB1D38; continue 'dispatch;
            }
            0x82EB1D38 => {
    //   block [0x82EB1D38..0x82EB1D74)
	// 82EB1D38: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1D3C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82EB1D40: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D44: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1D48: 409A002C  bne cr6, 0x82eb1d74
	if !ctx.cr[6].eq {
	pc = 0x82EB1D74; continue 'dispatch;
	}
	// 82EB1D4C: EFC0B02A  fadds f30, f0, f22
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[22].f64) as f32) as f64;
	// 82EB1D50: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1D54: EFB5682A  fadds f29, f21, f13
	ctx.f[29].f64 = ((ctx.f[21].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB1D58: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D5C: EF80A02A  fadds f28, f0, f20
	ctx.f[28].f64 = ((ctx.f[0].f64 + ctx.f[20].f64) as f32) as f64;
	// 82EB1D60: EC16682A  fadds f0, f22, f13
	ctx.f[0].f64 = ((ctx.f[22].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB1D64: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D68: ED8CA82A  fadds f12, f12, f21
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[21].f64) as f32) as f64;
	// 82EB1D6C: EDB4682A  fadds f13, f20, f13
	ctx.f[13].f64 = ((ctx.f[20].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB1D70: 48000028  b 0x82eb1d98
	pc = 0x82EB1D98; continue 'dispatch;
            }
            0x82EB1D74 => {
    //   block [0x82EB1D74..0x82EB1D98)
	// 82EB1D74: EFC0B028  fsubs f30, f0, f22
	ctx.f[30].f64 = (((ctx.f[0].f64 - ctx.f[22].f64) as f32) as f64);
	// 82EB1D78: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1D7C: EFADA828  fsubs f29, f13, f21
	ctx.f[29].f64 = (((ctx.f[13].f64 - ctx.f[21].f64) as f32) as f64);
	// 82EB1D80: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D84: EF80A028  fsubs f28, f0, f20
	ctx.f[28].f64 = (((ctx.f[0].f64 - ctx.f[20].f64) as f32) as f64);
	// 82EB1D88: EC0DB028  fsubs f0, f13, f22
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[22].f64) as f32) as f64);
	// 82EB1D8C: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D90: ED8CA828  fsubs f12, f12, f21
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[21].f64) as f32) as f64);
	// 82EB1D94: EDADA028  fsubs f13, f13, f20
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[20].f64) as f32) as f64);
	pc = 0x82EB1D98; continue 'dispatch;
            }
            0x82EB1D98 => {
    //   block [0x82EB1D98..0x82EB1DD4)
	// 82EB1D98: ED8CE828  fsubs f12, f12, f29
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[29].f64) as f32) as f64);
	// 82EB1D9C: ED60F028  fsubs f11, f0, f30
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82EB1DA0: EDADE028  fsubs f13, f13, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EB1DA4: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB1DA8: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB1DAC: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB1DB0: EEE0002C  fsqrts f23, f0
	ctx.f[23].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB1DB4: FF17C000  fcmpu cr6, f23, f24
	ctx.cr[6].compare_f64(ctx.f[23].f64, ctx.f[24].f64);
	// 82EB1DB8: 419A0120  beq cr6, 0x82eb1ed8
	if ctx.cr[6].eq {
	pc = 0x82EB1ED8; continue 'dispatch;
	}
	// 82EB1DBC: EC0FB824  fdivs f0, f15, f23
	ctx.f[0].f64 = ((ctx.f[15].f64 / ctx.f[23].f64) as f32) as f64;
	// 82EB1DC0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EB1DC4: FFE0C090  fmr f31, f24
	ctx.f[31].f64 = ctx.f[24].f64;
	// 82EB1DC8: EF6002F2  fmuls f27, f0, f11
	ctx.f[27].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1DCC: EF400332  fmuls f26, f0, f12
	ctx.f[26].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB1DD0: EF200372  fmuls f25, f0, f13
	ctx.f[25].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x82EB1DD4; continue 'dispatch;
            }
            0x82EB1DD4 => {
    //   block [0x82EB1DD4..0x82EB1E50)
	// 82EB1DD4: FF1FB800  fcmpu cr6, f31, f23
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[23].f64);
	// 82EB1DD8: 41990100  bgt cr6, 0x82eb1ed8
	if ctx.cr[6].gt {
	pc = 0x82EB1ED8; continue 'dispatch;
	}
	// 82EB1DDC: EDBA07F2  fmuls f13, f26, f31
	ctx.f[13].f64 = (((ctx.f[26].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB1DE0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1DE4: EC1B07F2  fmuls f0, f27, f31
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB1DE8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB1DEC: ED72982A  fadds f11, f18, f19
	ctx.f[11].f64 = ((ctx.f[18].f64 + ctx.f[19].f64) as f32) as f64;
	// 82EB1DF0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB1DF4: ED9907F2  fmuls f12, f25, f31
	ctx.f[12].f64 = (((ctx.f[25].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB1DF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EB1DFC: FC20C090  fmr f1, f24
	ctx.f[1].f64 = ctx.f[24].f64;
	// 82EB1E00: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1E04: EDADE82A  fadds f13, f13, f29
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EB1E08: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1E0C: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EB1E10: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1E14: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB1E18: ED8CE02A  fadds f12, f12, f28
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[28].f64) as f32) as f64;
	// 82EB1E1C: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB1E20: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB1E24: EC0D5828  fsubs f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB1E28: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB1E2C: 4B77D6E5  bl 0x8262f510
	ctx.lr = 0x82EB1E30;
	sub_8262F510(ctx, base);
	// 82EB1E30: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1E34: 418200B8  beq 0x82eb1eec
	if ctx.cr[0].eq {
	pc = 0x82EB1EEC; continue 'dispatch;
	}
	// 82EB1E38: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB1E3C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB1E40: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1E44: 4182000C  beq 0x82eb1e50
	if ctx.cr[0].eq {
	pc = 0x82EB1E50; continue 'dispatch;
	}
	// 82EB1E48: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1E4C: 48000008  b 0x82eb1e54
	pc = 0x82EB1E54; continue 'dispatch;
            }
            0x82EB1E50 => {
    //   block [0x82EB1E50..0x82EB1E54)
	// 82EB1E50: FC007890  fmr f0, f15
	ctx.f[0].f64 = ctx.f[15].f64;
	pc = 0x82EB1E54; continue 'dispatch;
            }
            0x82EB1E54 => {
    //   block [0x82EB1E54..0x82EB1ED8)
	// 82EB1E54: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EB1E58: 2B1C0002  cmplwi cr6, r28, 2
	ctx.cr[6].compare_u32(ctx.r[28].u32, 2 as u32, &mut ctx.xer);
	// 82EB1E5C: 4198FF78  blt cr6, 0x82eb1dd4
	if ctx.cr[6].lt {
	pc = 0x82EB1DD4; continue 'dispatch;
	}
	// 82EB1E60: FF1FB800  fcmpu cr6, f31, f23
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[23].f64);
	// 82EB1E64: 41990074  bgt cr6, 0x82eb1ed8
	if ctx.cr[6].gt {
	pc = 0x82EB1ED8; continue 'dispatch;
	}
	// 82EB1E68: EC17F828  fsubs f0, f23, f31
	ctx.f[0].f64 = (((ctx.f[23].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EB1E6C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1E70: ED529C3A  fmadds f10, f18, f16, f19
	ctx.f[10].f64 = (((ctx.f[18].f64 * ctx.f[16].f64 + ctx.f[19].f64) as f32) as f64);
	// 82EB1E74: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB1E78: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB1E7C: FC20C090  fmr f1, f24
	ctx.f[1].f64 = ctx.f[24].f64;
	// 82EB1E80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EB1E84: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1E88: EC00FC7A  fmadds f0, f0, f17, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[17].f64 + ctx.f[31].f64) as f32) as f64);
	// 82EB1E8C: EDBB0032  fmuls f13, f27, f0
	ctx.f[13].f64 = (((ctx.f[27].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1E90: ED9A0032  fmuls f12, f26, f0
	ctx.f[12].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1E94: ED790032  fmuls f11, f25, f0
	ctx.f[11].f64 = (((ctx.f[25].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1E98: EC0DF02A  fadds f0, f13, f30
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EB1E9C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1EA0: EDACE82A  fadds f13, f12, f29
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EB1EA4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB1EA8: ED8BE02A  fadds f12, f11, f28
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[28].f64) as f32) as f64;
	// 82EB1EAC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1EB0: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB1EB4: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB1EB8: EC0D5028  fsubs f0, f13, f10
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB1EBC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB1EC0: 4B77D651  bl 0x8262f510
	ctx.lr = 0x82EB1EC4;
	sub_8262F510(ctx, base);
	// 82EB1EC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1EC8: 41820024  beq 0x82eb1eec
	if ctx.cr[0].eq {
	pc = 0x82EB1EEC; continue 'dispatch;
	}
	// 82EB1ECC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EB1ED0: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 82EB1ED4: 4198FE64  blt cr6, 0x82eb1d38
	if ctx.cr[6].lt {
	pc = 0x82EB1D38; continue 'dispatch;
	}
	pc = 0x82EB1ED8; continue 'dispatch;
            }
            0x82EB1ED8 => {
    //   block [0x82EB1ED8..0x82EB1EDC)
	// 82EB1ED8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB1EDC; continue 'dispatch;
            }
            0x82EB1EDC => {
    //   block [0x82EB1EDC..0x82EB1EEC)
	// 82EB1EDC: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82EB1EE0: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EB1EE4: 4BDFBE0D  bl 0x82cadcf0
	ctx.lr = 0x82EB1EE8;
	sub_82CADCEC(ctx, base);
	// 82EB1EE8: 4BDF7568  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EB1EEC => {
    //   block [0x82EB1EEC..0x82EB1EF4)
	// 82EB1EEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB1EF0: 4BFFFFEC  b 0x82eb1edc
	pc = 0x82EB1EDC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB1EF8 size=108
    let mut pc: u32 = 0x82EB1EF8;
    'dispatch: loop {
        match pc {
            0x82EB1EF8 => {
    //   block [0x82EB1EF8..0x82EB1F54)
	// 82EB1EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB1F00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB1F04: 81640064  lwz r11, 0x64(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB1F08: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82EB1F0C: 8124006C  lwz r9, 0x6c(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB1F10: 81030060  lwz r8, 0x60(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB1F14: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB1F18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1F1C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82EB1F20: 7C8B5396  divwu r4, r11, r10
	ctx.r[4].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82EB1F24: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB1F28: 4098002C  bge cr6, 0x82eb1f54
	if !ctx.cr[6].lt {
	pc = 0x82EB1F54; continue 'dispatch;
	}
	// 82EB1F2C: 81630058  lwz r11, 0x58(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB1F30: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB1F34: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1F38: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EB1F3C: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82EB1F40: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1F44: 80630064  lwz r3, 0x64(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB1F48: 816B00A8  lwz r11, 0xa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EB1F4C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EB1F50: 4BFD71A9  bl 0x82e890f8
	ctx.lr = 0x82EB1F54;
	sub_82E890F8(ctx, base);
	pc = 0x82EB1F54; continue 'dispatch;
            }
            0x82EB1F54 => {
    //   block [0x82EB1F54..0x82EB1F64)
	// 82EB1F54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB1F58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB1F5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB1F60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB1F68 size=88
    let mut pc: u32 = 0x82EB1F68;
    'dispatch: loop {
        match pc {
            0x82EB1F68 => {
    //   block [0x82EB1F68..0x82EB1FA4)
	// 82EB1F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB1F70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB1F74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB1F78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB1F7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB1F80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB1F84: 4BFFF64D  bl 0x82eb15d0
	ctx.lr = 0x82EB1F88;
	sub_82EB15D0(ctx, base);
	// 82EB1F88: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1F8C: 41820018  beq 0x82eb1fa4
	if ctx.cr[0].eq {
	pc = 0x82EB1FA4; continue 'dispatch;
	}
	// 82EB1F90: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB1F94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1F98: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB1F9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1FA0: 4E800421  bctrl
	ctx.lr = 0x82EB1FA4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB1FA4 => {
    //   block [0x82EB1FA4..0x82EB1FC0)
	// 82EB1FA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1FA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB1FAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB1FB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB1FB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB1FB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB1FBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB1FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB1FC0 size=480
    let mut pc: u32 = 0x82EB1FC0;
    'dispatch: loop {
        match pc {
            0x82EB1FC0 => {
    //   block [0x82EB1FC0..0x82EB2010)
	// 82EB1FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB1FC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB1FCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB1FD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB1FD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB1FD8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB1FDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB1FE0: 388B60C0  addi r4, r11, 0x60c0
	ctx.r[4].s64 = ctx.r[11].s64 + 24768;
	// 82EB1FE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB1FE8: 4BFD76F9  bl 0x82e896e0
	ctx.lr = 0x82EB1FEC;
	sub_82E896E0(ctx, base);
	// 82EB1FEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1FF0: 41820020  beq 0x82eb2010
	if ctx.cr[0].eq {
	pc = 0x82EB2010; continue 'dispatch;
	}
	// 82EB1FF4: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1FF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1FFC: 41820014  beq 0x82eb2010
	if ctx.cr[0].eq {
	pc = 0x82EB2010; continue 'dispatch;
	}
	// 82EB2000: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB2004: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB2008: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB200C: 419A017C  beq cr6, 0x82eb2188
	if ctx.cr[6].eq {
	pc = 0x82EB2188; continue 'dispatch;
	}
	pc = 0x82EB2010; continue 'dispatch;
            }
            0x82EB2010 => {
    //   block [0x82EB2010..0x82EB2044)
	// 82EB2010: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB2014: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2018: 41820090  beq 0x82eb20a8
	if ctx.cr[0].eq {
	pc = 0x82EB20A8; continue 'dispatch;
	}
	// 82EB201C: 80BF0070  lwz r5, 0x70(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB2020: 2F05FFFF  cmpwi cr6, r5, -1
	ctx.cr[6].compare_i32(ctx.r[5].s32, -1, &mut ctx.xer);
	// 82EB2024: 419A0084  beq cr6, 0x82eb20a8
	if ctx.cr[6].eq {
	pc = 0x82EB20A8; continue 'dispatch;
	}
	// 82EB2028: 897E0058  lbz r11, 0x58(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB202C: 815E0050  lwz r10, 0x50(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB2030: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2034: 41820074  beq 0x82eb20a8
	if ctx.cr[0].eq {
	pc = 0x82EB20A8; continue 'dispatch;
	}
	// 82EB2038: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB203C: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB2040: 409A0040  bne cr6, 0x82eb2080
	if !ctx.cr[6].eq {
	pc = 0x82EB2080; continue 'dispatch;
	}
	pc = 0x82EB2044; continue 'dispatch;
            }
            0x82EB2044 => {
    //   block [0x82EB2044..0x82EB2074)
	// 82EB2044: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB2048: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EB204C: 419A0028  beq cr6, 0x82eb2074
	if ctx.cr[6].eq {
	pc = 0x82EB2074; continue 'dispatch;
	}
	// 82EB2050: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB2054: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB2058: 4098001C  bge cr6, 0x82eb2074
	if !ctx.cr[6].lt {
	pc = 0x82EB2074; continue 'dispatch;
	}
	// 82EB205C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB2060: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EB2064: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB2068: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB206C: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EB2070: 409A0008  bne cr6, 0x82eb2078
	if !ctx.cr[6].eq {
	pc = 0x82EB2078; continue 'dispatch;
	}
	pc = 0x82EB2074; continue 'dispatch;
            }
            0x82EB2074 => {
    //   block [0x82EB2074..0x82EB2078)
	// 82EB2074: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EB2078; continue 'dispatch;
            }
            0x82EB2078 => {
    //   block [0x82EB2078..0x82EB2080)
	// 82EB2078: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EB207C: 4800010C  b 0x82eb2188
	pc = 0x82EB2188; continue 'dispatch;
            }
            0x82EB2080 => {
    //   block [0x82EB2080..0x82EB20A8)
	// 82EB2080: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2084: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EB2088: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB208C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EB2090: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2094: 4E800421  bctrl
	ctx.lr = 0x82EB2098;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2098: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB209C: 4182000C  beq 0x82eb20a8
	if ctx.cr[0].eq {
	pc = 0x82EB20A8; continue 'dispatch;
	}
	// 82EB20A0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB20A4: 4BFFFFA0  b 0x82eb2044
	pc = 0x82EB2044; continue 'dispatch;
            }
            0x82EB20A8 => {
    //   block [0x82EB20A8..0x82EB20EC)
	// 82EB20A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB20AC: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82EB20B0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB20B4: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB20B8: 396B0034  addi r11, r11, 0x34
	ctx.r[11].s64 = ctx.r[11].s64 + 52;
	// 82EB20BC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB20C0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB20C4: 409A0028  bne cr6, 0x82eb20ec
	if !ctx.cr[6].eq {
	pc = 0x82EB20EC; continue 'dispatch;
	}
	// 82EB20C8: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB20CC: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB20D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB20D4: 409A0018  bne cr6, 0x82eb20ec
	if !ctx.cr[6].eq {
	pc = 0x82EB20EC; continue 'dispatch;
	}
	// 82EB20D8: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB20DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB20E0: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB20E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB20E8: 419A0008  beq cr6, 0x82eb20f0
	if ctx.cr[6].eq {
	pc = 0x82EB20F0; continue 'dispatch;
	}
	pc = 0x82EB20EC; continue 'dispatch;
            }
            0x82EB20EC => {
    //   block [0x82EB20EC..0x82EB20F0)
	// 82EB20EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82EB20F0; continue 'dispatch;
            }
            0x82EB20F0 => {
    //   block [0x82EB20F0..0x82EB2168)
	// 82EB20F0: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB20F4: 4182007C  beq 0x82eb2170
	if ctx.cr[0].eq {
	pc = 0x82EB2170; continue 'dispatch;
	}
	// 82EB20F8: 895F01C8  lbz r10, 0x1c8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(456 as u32) ) } as u64;
	// 82EB20FC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2100: 40820068  bne 0x82eb2168
	if !ctx.cr[0].eq {
	pc = 0x82EB2168; continue 'dispatch;
	}
	// 82EB2104: 815F00A0  lwz r10, 0xa0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB2108: 3BDF01CC  addi r30, r31, 0x1cc
	ctx.r[30].s64 = ctx.r[31].s64 + 460;
	// 82EB210C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EB2110: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB2114: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EB2118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB211C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB2120: 4E800421  bctrl
	ctx.lr = 0x82EB2124;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2124: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB2128: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB212C: 907F01CC  stw r3, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[3].u32 ) };
	// 82EB2130: 995F01C8  stb r10, 0x1c8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[10].u8 ) };
	// 82EB2134: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2138: 806B0064  lwz r3, 0x64(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB213C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2140: 41820028  beq 0x82eb2168
	if ctx.cr[0].eq {
	pc = 0x82EB2168; continue 'dispatch;
	}
	// 82EB2144: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB2148: 388BE7E8  addi r4, r11, -0x1818
	ctx.r[4].s64 = ctx.r[11].s64 + -6168;
	// 82EB214C: 4BFD5585  bl 0x82e876d0
	ctx.lr = 0x82EB2150;
	sub_82E876D0(ctx, base);
	// 82EB2150: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2154: 41820014  beq 0x82eb2168
	if ctx.cr[0].eq {
	pc = 0x82EB2168; continue 'dispatch;
	}
	// 82EB2158: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB215C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB2160: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2164: 4BFFFD95  bl 0x82eb1ef8
	ctx.lr = 0x82EB2168;
	sub_82EB1EF8(ctx, base);
            }
            0x82EB2168 => {
    //   block [0x82EB2168..0x82EB2170)
	// 82EB2168: 807F01CC  lwz r3, 0x1cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EB216C: 4800001C  b 0x82eb2188
	pc = 0x82EB2188; continue 'dispatch;
            }
            0x82EB2170 => {
    //   block [0x82EB2170..0x82EB2188)
	// 82EB2170: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB2174: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB2178: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB217C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2180: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2184: 4E800421  bctrl
	ctx.lr = 0x82EB2188;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB2188 => {
    //   block [0x82EB2188..0x82EB21A0)
	// 82EB2188: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB218C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2190: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2194: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB2198: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB219C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB21A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB21A0 size=12
    let mut pc: u32 = 0x82EB21A0;
    'dispatch: loop {
        match pc {
            0x82EB21A0 => {
    //   block [0x82EB21A0..0x82EB21AC)
	// 82EB21A0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82EB21A4: 38850004  addi r4, r5, 4
	ctx.r[4].s64 = ctx.r[5].s64 + 4;
	// 82EB21A8: 4BFFF510  b 0x82eb16b8
	sub_82EB16B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB21B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB21B0 size=140
    let mut pc: u32 = 0x82EB21B0;
    'dispatch: loop {
        match pc {
            0x82EB21B0 => {
    //   block [0x82EB21B0..0x82EB2230)
	// 82EB21B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB21B4: 4BDF7255  bl 0x82ca9408
	ctx.lr = 0x82EB21B8;
	sub_82CA93D0(ctx, base);
	// 82EB21B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB21BC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EB21C0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EB21C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB21C8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EB21CC: 4BFFFDF5  bl 0x82eb1fc0
	ctx.lr = 0x82EB21D0;
	sub_82EB1FC0(ctx, base);
	// 82EB21D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB21D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB21D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB21DC: 4BFFFDE5  bl 0x82eb1fc0
	ctx.lr = 0x82EB21E0;
	sub_82EB1FC0(ctx, base);
	// 82EB21E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB21E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB21E8: 419A0048  beq cr6, 0x82eb2230
	if ctx.cr[6].eq {
	pc = 0x82EB2230; continue 'dispatch;
	}
	// 82EB21EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB21F0: 419A0040  beq cr6, 0x82eb2230
	if ctx.cr[6].eq {
	pc = 0x82EB2230; continue 'dispatch;
	}
	// 82EB21F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB21F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB21FC: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB2200: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2204: 4E800421  bctrl
	ctx.lr = 0x82EB2208;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2208: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB220C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EB2210: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB2214: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB2218: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB221C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2220: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB2224: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2228: 4E800421  bctrl
	ctx.lr = 0x82EB222C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB222C: 48000008  b 0x82eb2234
	pc = 0x82EB2234; continue 'dispatch;
            }
            0x82EB2230 => {
    //   block [0x82EB2230..0x82EB2234)
	// 82EB2230: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB2234; continue 'dispatch;
            }
            0x82EB2234 => {
    //   block [0x82EB2234..0x82EB223C)
	// 82EB2234: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB2238: 4BDF7220  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB2240 size=8
    let mut pc: u32 = 0x82EB2240;
    'dispatch: loop {
        match pc {
            0x82EB2240 => {
    //   block [0x82EB2240..0x82EB2248)
	// 82EB2240: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2244: 4BFFF474  b 0x82eb16b8
	sub_82EB16B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB2248 size=856
    let mut pc: u32 = 0x82EB2248;
    'dispatch: loop {
        match pc {
            0x82EB2248 => {
    //   block [0x82EB2248..0x82EB22A4)
	// 82EB2248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB224C: 4BDF71B1  bl 0x82ca93fc
	ctx.lr = 0x82EB2250;
	sub_82CA93D0(ctx, base);
	// 82EB2250: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2254: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2258: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB225C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EB2260: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82EB2264: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EB2268: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB226C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EB2270: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82EB2274: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82EB2278: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EB227C: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2280: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB2284: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB2288: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB228C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EB2290: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2294: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EB2298: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB229C: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EB22A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EB22A4; continue 'dispatch;
            }
            0x82EB22A4 => {
    //   block [0x82EB22A4..0x82EB2328)
	// 82EB22A4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB22A8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB22AC: 4200FFF8  bdnz 0x82eb22a4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB22A4; continue 'dispatch;
	}
	// 82EB22B0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EB22B4: 9B4100C8  stb r26, 0xc8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[26].u8 ) };
	// 82EB22B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB22BC: 4BFFFD05  bl 0x82eb1fc0
	ctx.lr = 0x82EB22C0;
	sub_82EB1FC0(ctx, base);
	// 82EB22C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB22C4: 895F0068  lbz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB22C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB22CC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB22D0: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82EB22D4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82EB22D8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB22DC: 409A0060  bne cr6, 0x82eb233c
	if !ctx.cr[6].eq {
	pc = 0x82EB233C; continue 'dispatch;
	}
	// 82EB22E0: 897F00BF  lbz r11, 0xbf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB22E4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB22E8: 409A0054  bne cr6, 0x82eb233c
	if !ctx.cr[6].eq {
	pc = 0x82EB233C; continue 'dispatch;
	}
	// 82EB22EC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB22F0: 419A0068  beq cr6, 0x82eb2358
	if ctx.cr[6].eq {
	pc = 0x82EB2358; continue 'dispatch;
	}
	// 82EB22F4: C01F00EC  lfs f0, 0xec(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB22F8: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB22FC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB2300: 409A0028  bne cr6, 0x82eb2328
	if !ctx.cr[6].eq {
	pc = 0x82EB2328; continue 'dispatch;
	}
	// 82EB2304: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2308: C1BF00F0  lfs f13, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB230C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB2310: 409A0018  bne cr6, 0x82eb2328
	if !ctx.cr[6].eq {
	pc = 0x82EB2328; continue 'dispatch;
	}
	// 82EB2314: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2318: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EB231C: C1BF00F4  lfs f13, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB2320: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB2324: 419A0008  beq cr6, 0x82eb232c
	if ctx.cr[6].eq {
	pc = 0x82EB232C; continue 'dispatch;
	}
	pc = 0x82EB2328; continue 'dispatch;
            }
            0x82EB2328 => {
    //   block [0x82EB2328..0x82EB232C)
	// 82EB2328: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82EB232C; continue 'dispatch;
            }
            0x82EB232C => {
    //   block [0x82EB232C..0x82EB233C)
	// 82EB232C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB2330: 4182000C  beq 0x82eb233c
	if ctx.cr[0].eq {
	pc = 0x82EB233C; continue 'dispatch;
	}
	// 82EB2334: 807F0138  lwz r3, 0x138(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB2338: 48000018  b 0x82eb2350
	pc = 0x82EB2350; continue 'dispatch;
            }
            0x82EB233C => {
    //   block [0x82EB233C..0x82EB2350)
	// 82EB233C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB2340: 419A0018  beq cr6, 0x82eb2358
	if ctx.cr[6].eq {
	pc = 0x82EB2358; continue 'dispatch;
	}
	// 82EB2344: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB2348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB234C: 4BFFFC75  bl 0x82eb1fc0
	ctx.lr = 0x82EB2350;
	sub_82EB1FC0(ctx, base);
	pc = 0x82EB2350; continue 'dispatch;
            }
            0x82EB2350 => {
    //   block [0x82EB2350..0x82EB2358)
	// 82EB2350: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB2354: 409A0020  bne cr6, 0x82eb2374
	if !ctx.cr[6].eq {
	pc = 0x82EB2374; continue 'dispatch;
	}
	pc = 0x82EB2358; continue 'dispatch;
            }
            0x82EB2358 => {
    //   block [0x82EB2358..0x82EB2374)
	// 82EB2358: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB235C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB2360: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2364: 389F00E0  addi r4, r31, 0xe0
	ctx.r[4].s64 = ctx.r[31].s64 + 224;
	// 82EB2368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB236C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2370: 4E800421  bctrl
	ctx.lr = 0x82EB2374;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB2374 => {
    //   block [0x82EB2374..0x82EB2394)
	// 82EB2374: 897F00BF  lbz r11, 0xbf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB2378: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB237C: 40820048  bne 0x82eb23c4
	if !ctx.cr[0].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	// 82EB2380: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB2384: 41820010  beq 0x82eb2394
	if ctx.cr[0].eq {
	pc = 0x82EB2394; continue 'dispatch;
	}
	// 82EB2388: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB238C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB2390: 409A0034  bne cr6, 0x82eb23c4
	if !ctx.cr[6].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	pc = 0x82EB2394; continue 'dispatch;
            }
            0x82EB2394 => {
    //   block [0x82EB2394..0x82EB23C4)
	// 82EB2394: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB2398: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB239C: 409A0028  bne cr6, 0x82eb23c4
	if !ctx.cr[6].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	// 82EB23A0: 897F01B5  lbz r11, 0x1b5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(437 as u32) ) } as u64;
	// 82EB23A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB23A8: 4082001C  bne 0x82eb23c4
	if !ctx.cr[0].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	// 82EB23AC: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB23B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB23B4: 40820010  bne 0x82eb23c4
	if !ctx.cr[0].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	// 82EB23B8: 9B5B0000  stb r26, 0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82EB23BC: 887F00BD  lbz r3, 0xbd(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(189 as u32) ) } as u64;
	// 82EB23C0: 480001D8  b 0x82eb2598
	pc = 0x82EB2598; continue 'dispatch;
            }
            0x82EB23C4 => {
    //   block [0x82EB23C4..0x82EB2454)
	// 82EB23C4: 9B3B0000  stb r25, 0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 82EB23C8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB23CC: 93BF0134  stw r29, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[29].u32 ) };
	// 82EB23D0: 907F0138  stw r3, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[3].u32 ) };
	// 82EB23D4: 419A01BC  beq cr6, 0x82eb2590
	if ctx.cr[6].eq {
	pc = 0x82EB2590; continue 'dispatch;
	}
	// 82EB23D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB23DC: 419A01B4  beq cr6, 0x82eb2590
	if ctx.cr[6].eq {
	pc = 0x82EB2590; continue 'dispatch;
	}
	// 82EB23E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB23E4: 3BDF0074  addi r30, r31, 0x74
	ctx.r[30].s64 = ctx.r[31].s64 + 116;
	// 82EB23E8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB23EC: D01E0024  stfs f0, 0x24(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EB23F0: 935E0008  stw r26, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82EB23F4: 817F0174  lwz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EB23F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB23FC: 419A0058  beq cr6, 0x82eb2454
	if ctx.cr[6].eq {
	pc = 0x82EB2454; continue 'dispatch;
	}
	// 82EB2400: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2408: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB240C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2410: 4E800421  bctrl
	ctx.lr = 0x82EB2414;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2414: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2418: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB241C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2420: 4E800421  bctrl
	ctx.lr = 0x82EB2424;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2424: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB2428: 396B52B8  addi r11, r11, 0x52b8
	ctx.r[11].s64 = ctx.r[11].s64 + 21176;
	// 82EB242C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EB2430: 409A0024  bne cr6, 0x82eb2454
	if !ctx.cr[6].eq {
	pc = 0x82EB2454; continue 'dispatch;
	}
	// 82EB2434: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB2438: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EB243C: 815F0134  lwz r10, 0x134(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB2440: 807F0174  lwz r3, 0x174(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EB2444: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2448: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB244C: 4BFED4F5  bl 0x82e9f940
	ctx.lr = 0x82EB2450;
	sub_82E9F940(ctx, base);
	// 82EB2450: 48000148  b 0x82eb2598
	pc = 0x82EB2598; continue 'dispatch;
            }
            0x82EB2454 => {
    //   block [0x82EB2454..0x82EB24C0)
	// 82EB2454: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB245C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB2460: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2464: 4E800421  bctrl
	ctx.lr = 0x82EB2468;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2468: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB246C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB2470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2474: 916A0054  stw r11, 0x54(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB2478: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB247C: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB2480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2484: 4E800421  bctrl
	ctx.lr = 0x82EB2488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2488: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB248C: 906B0058  stw r3, 0x58(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EB2490: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB2494: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2498: 40820028  bne 0x82eb24c0
	if !ctx.cr[0].eq {
	pc = 0x82EB24C0; continue 'dispatch;
	}
	// 82EB249C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB24A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB24A4: 80DF0138  lwz r6, 0x138(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB24A8: 80BF0134  lwz r5, 0x134(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB24AC: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB24B0: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB24B4: 4BFF158D  bl 0x82ea3a40
	ctx.lr = 0x82EB24B8;
	sub_82EA3A40(ctx, base);
	// 82EB24B8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EB24BC: 480000D8  b 0x82eb2594
	pc = 0x82EB2594; continue 'dispatch;
            }
            0x82EB24C0 => {
    //   block [0x82EB24C0..0x82EB2510)
	// 82EB24C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB24C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB24C8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB24CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB24D0: 4E800421  bctrl
	ctx.lr = 0x82EB24D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB24D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB24D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB24DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB24E0: 4E800421  bctrl
	ctx.lr = 0x82EB24E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB24E4: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB24E8: 4B3AE4D1  bl 0x822609b8
	ctx.lr = 0x82EB24EC;
	sub_822609B8(ctx, base);
	// 82EB24EC: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB24F0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB24F4: 4BFCF025  bl 0x82e81518
	ctx.lr = 0x82EB24F8;
	sub_82E81518(ctx, base);
	// 82EB24F8: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82EB24FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB2500: C00B0A8C  lfs f0, 0xa8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2504: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82EB2508: 40980008  bge cr6, 0x82eb2510
	if !ctx.cr[6].lt {
	pc = 0x82EB2510; continue 'dispatch;
	}
	// 82EB250C: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
            }
            0x82EB2510 => {
    //   block [0x82EB2510..0x82EB2588)
	// 82EB2510: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB2514: 1D5D0014  mulli r10, r29, 0x14
	ctx.r[10].s32 = ((ctx.r[29].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EB2518: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB251C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB2520: 9B5F00BF  stb r26, 0xbf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(191 as u32), ctx.r[26].u8 ) };
	// 82EB2524: 80DF0138  lwz r6, 0x138(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB2528: 80BF0134  lwz r5, 0x134(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB252C: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB2530: 80E90014  lwz r7, 0x14(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2534: 895F01B5  lbz r10, 0x1b5(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(437 as u32) ) } as u64;
	// 82EB2538: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB253C: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 82EB2540: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 82EB2544: 99410067  stb r10, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[10].u8 ) };
	// 82EB2548: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 82EB254C: C02B0010  lfs f1, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB2550: 4BFF0D49  bl 0x82ea3298
	ctx.lr = 0x82EB2554;
	sub_82EA3298(ctx, base);
	// 82EB2554: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EB2558: 4198003C  blt cr6, 0x82eb2594
	if ctx.cr[6].lt {
	pc = 0x82EB2594; continue 'dispatch;
	}
	// 82EB255C: 419A002C  beq cr6, 0x82eb2588
	if ctx.cr[6].eq {
	pc = 0x82EB2588; continue 'dispatch;
	}
	// 82EB2560: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 82EB2564: 40980030  bge cr6, 0x82eb2594
	if !ctx.cr[6].lt {
	pc = 0x82EB2594; continue 'dispatch;
	}
	// 82EB2568: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB256C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EB2570: 9B3F00BF  stb r25, 0xbf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(191 as u32), ctx.r[25].u8 ) };
	// 82EB2574: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2578: 4BFCF091  bl 0x82e81608
	ctx.lr = 0x82EB257C;
	sub_82E81608(ctx, base);
	// 82EB257C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EB2580: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB2584: 4BFCF4C5  bl 0x82e81a48
	ctx.lr = 0x82EB2588;
	sub_82E81A48(ctx, base);
	pc = 0x82EB2588; continue 'dispatch;
            }
            0x82EB2588 => {
    //   block [0x82EB2588..0x82EB2590)
	// 82EB2588: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 82EB258C: 48000008  b 0x82eb2594
	pc = 0x82EB2594; continue 'dispatch;
            }
            0x82EB2590 => {
    //   block [0x82EB2590..0x82EB2594)
	// 82EB2590: 9B5F00BF  stb r26, 0xbf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(191 as u32), ctx.r[26].u8 ) };
	pc = 0x82EB2594; continue 'dispatch;
            }
            0x82EB2594 => {
    //   block [0x82EB2594..0x82EB2598)
	// 82EB2594: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x82EB2598; continue 'dispatch;
            }
            0x82EB2598 => {
    //   block [0x82EB2598..0x82EB25A0)
	// 82EB2598: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82EB259C: 4BDF6EB0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB25A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB25A0 size=464
    let mut pc: u32 = 0x82EB25A0;
    'dispatch: loop {
        match pc {
            0x82EB25A0 => {
    //   block [0x82EB25A0..0x82EB25F4)
	// 82EB25A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB25A4: 4BDF6E65  bl 0x82ca9408
	ctx.lr = 0x82EB25A8;
	sub_82CA93D0(ctx, base);
	// 82EB25A8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB25AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB25B0: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB25B4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EB25B8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EB25BC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB25C0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB25C4: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB25C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB25CC: 409A0028  bne cr6, 0x82eb25f4
	if !ctx.cr[6].eq {
	pc = 0x82EB25F4; continue 'dispatch;
	}
	// 82EB25D0: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB25D4: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB25D8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EB25DC: 409A0018  bne cr6, 0x82eb25f4
	if !ctx.cr[6].eq {
	pc = 0x82EB25F4; continue 'dispatch;
	}
	// 82EB25E0: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB25E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB25E8: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB25EC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EB25F0: 419A0008  beq cr6, 0x82eb25f8
	if ctx.cr[6].eq {
	pc = 0x82EB25F8; continue 'dispatch;
	}
	pc = 0x82EB25F4; continue 'dispatch;
            }
            0x82EB25F4 => {
    //   block [0x82EB25F4..0x82EB25F8)
	// 82EB25F4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82EB25F8; continue 'dispatch;
            }
            0x82EB25F8 => {
    //   block [0x82EB25F8..0x82EB2630)
	// 82EB25F8: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB25FC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB2600: 4182005C  beq 0x82eb265c
	if ctx.cr[0].eq {
	pc = 0x82EB265C; continue 'dispatch;
	}
	// 82EB2604: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB2608: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB260C: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2610: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82EB2614: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB2618: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB261C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EB2620: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82EB2624: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EB2628: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB262C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82EB2630; continue 'dispatch;
            }
            0x82EB2630 => {
    //   block [0x82EB2630..0x82EB265C)
	// 82EB2630: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB2634: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB2638: 4200FFF8  bdnz 0x82eb2630
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB2630; continue 'dispatch;
	}
	// 82EB263C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB2640: 9B8100B8  stb r28, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u8 ) };
	// 82EB2644: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB2648: 4BFFF979  bl 0x82eb1fc0
	ctx.lr = 0x82EB264C;
	sub_82EB1FC0(ctx, base);
	// 82EB264C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB2650: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB2654: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EB2658: 48000030  b 0x82eb2688
	pc = 0x82EB2688; continue 'dispatch;
            }
            0x82EB265C => {
    //   block [0x82EB265C..0x82EB2688)
	// 82EB265C: D1A10054  stfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB2660: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB2664: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB2668: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB266C: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB2670: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2674: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB2678: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EB267C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB2680: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2684: 4E800421  bctrl
	ctx.lr = 0x82EB2688;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB2688 => {
    //   block [0x82EB2688..0x82EB26C4)
	// 82EB2688: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB268C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB2690: 409A004C  bne cr6, 0x82eb26dc
	if !ctx.cr[6].eq {
	pc = 0x82EB26DC; continue 'dispatch;
	}
	// 82EB2694: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB2698: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 82EB269C: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82EB26A0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EB26A4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB26A8: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26AC: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB26B0: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26B4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB26B8: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26BC: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB26C0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82EB26C4; continue 'dispatch;
            }
            0x82EB26C4 => {
    //   block [0x82EB26C4..0x82EB26DC)
	// 82EB26C4: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB26C8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB26CC: 4200FFF8  bdnz 0x82eb26c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB26C4; continue 'dispatch;
	}
	// 82EB26D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB26D4: 9B9F0058  stb r28, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	// 82EB26D8: 48000090  b 0x82eb2768
	pc = 0x82EB2768; continue 'dispatch;
            }
            0x82EB26DC => {
    //   block [0x82EB26DC..0x82EB2724)
	// 82EB26DC: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26E0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB26E4: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB26E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB26EC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26F0: 388B60C0  addi r4, r11, 0x60c0
	ctx.r[4].s64 = ctx.r[11].s64 + 24768;
	// 82EB26F4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB26F8: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26FC: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB2700: 9B9F0058  stb r28, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	// 82EB2704: 4BFD6FDD  bl 0x82e896e0
	ctx.lr = 0x82EB2708;
	sub_82E896E0(ctx, base);
	// 82EB2708: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82EB270C: 41820018  beq 0x82eb2724
	if ctx.cr[0].eq {
	pc = 0x82EB2724; continue 'dispatch;
	}
	// 82EB2710: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB2714: 93C40004  stw r30, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82EB2718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB271C: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EB2720: 4B2FBF89  bl 0x821ae6a8
	ctx.lr = 0x82EB2724;
	sub_821AE6A8(ctx, base);
	pc = 0x82EB2724; continue 'dispatch;
            }
            0x82EB2724 => {
    //   block [0x82EB2724..0x82EB2764)
	// 82EB2724: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB2728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB272C: 388B20C0  addi r4, r11, 0x20c0
	ctx.r[4].s64 = ctx.r[11].s64 + 8384;
	// 82EB2730: 4BFD6FB1  bl 0x82e896e0
	ctx.lr = 0x82EB2734;
	sub_82E896E0(ctx, base);
	// 82EB2734: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB2738: 4182002C  beq 0x82eb2764
	if ctx.cr[0].eq {
	pc = 0x82EB2764; continue 'dispatch;
	}
	// 82EB273C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2740: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB2744: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB2748: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB274C: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2750: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2754: 4E800421  bctrl
	ctx.lr = 0x82EB2758;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2758: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB275C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2760: 4B2FBF49  bl 0x821ae6a8
	ctx.lr = 0x82EB2764;
	sub_821AE6A8(ctx, base);
            }
            0x82EB2764 => {
    //   block [0x82EB2764..0x82EB2768)
	// 82EB2764: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EB2768; continue 'dispatch;
            }
            0x82EB2768 => {
    //   block [0x82EB2768..0x82EB2770)
	// 82EB2768: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EB276C: 4BDF6CEC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2770 size=116
    let mut pc: u32 = 0x82EB2770;
    'dispatch: loop {
        match pc {
            0x82EB2770 => {
    //   block [0x82EB2770..0x82EB27B8)
	// 82EB2770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2778: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB277C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2780: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB2784: 816A86F8  lwz r11, -0x7908(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30984 as u32) ) } as u64;
	// 82EB2788: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB278C: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EB2790: 3BE986B0  addi r31, r9, -0x7950
	ctx.r[31].s64 = ctx.r[9].s64 + -31056;
	// 82EB2794: 40820038  bne 0x82eb27cc
	if !ctx.cr[0].eq {
	pc = 0x82EB27CC; continue 'dispatch;
	}
	// 82EB2798: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EB279C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EB27A0: 8909DF21  lbz r8, -0x20df(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8415 as u32) ) } as u64;
	// 82EB27A4: 916A86F8  stw r11, -0x7908(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-30984 as u32), ctx.r[11].u32 ) };
	// 82EB27A8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB27AC: 4182000C  beq 0x82eb27b8
	if ctx.cr[0].eq {
	pc = 0x82EB27B8; continue 'dispatch;
	}
	// 82EB27B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB27B4: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB27B8; continue 'dispatch;
            }
            0x82EB27B8 => {
    //   block [0x82EB27B8..0x82EB27CC)
	// 82EB27B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB27BC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EB27C0: 386A88F0  addi r3, r10, -0x7710
	ctx.r[3].s64 = ctx.r[10].s64 + -30480;
	// 82EB27C4: 9969DF21  stb r11, -0x20df(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8415 as u32), ctx.r[11].u8 ) };
	// 82EB27C8: 4BDF7759  bl 0x82ca9f20
	ctx.lr = 0x82EB27CC;
	sub_82CA9F20(ctx, base);
	pc = 0x82EB27CC; continue 'dispatch;
            }
            0x82EB27CC => {
    //   block [0x82EB27CC..0x82EB27E4)
	// 82EB27CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB27D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB27D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB27D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB27DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB27E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB27E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB27E8 size=116
    let mut pc: u32 = 0x82EB27E8;
    'dispatch: loop {
        match pc {
            0x82EB27E8 => {
    //   block [0x82EB27E8..0x82EB2830)
	// 82EB27E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB27EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB27F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB27F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB27F8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB27FC: 816A8748  lwz r11, -0x78b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30904 as u32) ) } as u64;
	// 82EB2800: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2804: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EB2808: 3BE98700  addi r31, r9, -0x7900
	ctx.r[31].s64 = ctx.r[9].s64 + -30976;
	// 82EB280C: 40820038  bne 0x82eb2844
	if !ctx.cr[0].eq {
	pc = 0x82EB2844; continue 'dispatch;
	}
	// 82EB2810: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EB2814: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EB2818: 8909DF20  lbz r8, -0x20e0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8416 as u32) ) } as u64;
	// 82EB281C: 916A8748  stw r11, -0x78b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-30904 as u32), ctx.r[11].u32 ) };
	// 82EB2820: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2824: 4182000C  beq 0x82eb2830
	if ctx.cr[0].eq {
	pc = 0x82EB2830; continue 'dispatch;
	}
	// 82EB2828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB282C: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB2830; continue 'dispatch;
            }
            0x82EB2830 => {
    //   block [0x82EB2830..0x82EB2844)
	// 82EB2830: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB2834: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EB2838: 386A88D8  addi r3, r10, -0x7728
	ctx.r[3].s64 = ctx.r[10].s64 + -30504;
	// 82EB283C: 9969DF20  stb r11, -0x20e0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8416 as u32), ctx.r[11].u8 ) };
	// 82EB2840: 4BDF76E1  bl 0x82ca9f20
	ctx.lr = 0x82EB2844;
	sub_82CA9F20(ctx, base);
	pc = 0x82EB2844; continue 'dispatch;
            }
            0x82EB2844 => {
    //   block [0x82EB2844..0x82EB285C)
	// 82EB2844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2848: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB284C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2854: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2858: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2860 size=192
    let mut pc: u32 = 0x82EB2860;
    'dispatch: loop {
        match pc {
            0x82EB2860 => {
    //   block [0x82EB2860..0x82EB2898)
	// 82EB2860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2868: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB286C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2874: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2878: 4B77BC11  bl 0x8262e488
	ctx.lr = 0x82EB287C;
	sub_8262E488(ctx, base);
	// 82EB287C: 80830040  lwz r4, 0x40(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB2880: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2884: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2888: 4081006C  ble 0x82eb28f4
	if !ctx.cr[0].gt {
	pc = 0x82EB28F4; continue 'dispatch;
	}
	// 82EB288C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2890: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB2894: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	pc = 0x82EB2898; continue 'dispatch;
            }
            0x82EB2898 => {
    //   block [0x82EB2898..0x82EB28BC)
	// 82EB2898: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB289C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EB28A0: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB28A4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82EB28A8: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EB28AC: 409A0038  bne cr6, 0x82eb28e4
	if !ctx.cr[6].eq {
	pc = 0x82EB28E4; continue 'dispatch;
	}
	// 82EB28B0: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EB28B4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EB28B8: 7D1F5050  subf r8, r31, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	pc = 0x82EB28BC; continue 'dispatch;
            }
            0x82EB28BC => {
    //   block [0x82EB28BC..0x82EB28E4)
	// 82EB28BC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB28C0: 419A0050  beq cr6, 0x82eb2910
	if ctx.cr[6].eq {
	pc = 0x82EB2910; continue 'dispatch;
	}
	// 82EB28C4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB28C8: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB28CC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB28D0: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 82EB28D4: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EB28D8: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB28DC: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB28E0: 419AFFDC  beq cr6, 0x82eb28bc
	if ctx.cr[6].eq {
	pc = 0x82EB28BC; continue 'dispatch;
	}
	pc = 0x82EB28E4; continue 'dispatch;
            }
            0x82EB28E4 => {
    //   block [0x82EB28E4..0x82EB28F4)
	// 82EB28E4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB28E8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB28EC: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82EB28F0: 4198FFA8  blt cr6, 0x82eb2898
	if ctx.cr[6].lt {
	pc = 0x82EB2898; continue 'dispatch;
	}
	pc = 0x82EB28F4; continue 'dispatch;
            }
            0x82EB28F4 => {
    //   block [0x82EB28F4..0x82EB28F8)
	// 82EB28F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB28F8; continue 'dispatch;
            }
            0x82EB28F8 => {
    //   block [0x82EB28F8..0x82EB2910)
	// 82EB28F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB28FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2900: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2904: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB2908: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB290C: 4E800020  blr
	return;
            }
            0x82EB2910 => {
    //   block [0x82EB2910..0x82EB2920)
	// 82EB2910: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB2914: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB2918: 806B0104  lwz r3, 0x104(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EB291C: 4BFFFFDC  b 0x82eb28f8
	pc = 0x82EB28F8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2920 size=192
    let mut pc: u32 = 0x82EB2920;
    'dispatch: loop {
        match pc {
            0x82EB2920 => {
    //   block [0x82EB2920..0x82EB2958)
	// 82EB2920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2928: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB292C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2930: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2934: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2938: 4B77BBE9  bl 0x8262e520
	ctx.lr = 0x82EB293C;
	sub_8262E520(ctx, base);
	// 82EB293C: 80830040  lwz r4, 0x40(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB2940: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2944: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2948: 4081006C  ble 0x82eb29b4
	if !ctx.cr[0].gt {
	pc = 0x82EB29B4; continue 'dispatch;
	}
	// 82EB294C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2950: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB2954: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	pc = 0x82EB2958; continue 'dispatch;
            }
            0x82EB2958 => {
    //   block [0x82EB2958..0x82EB297C)
	// 82EB2958: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB295C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EB2960: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2964: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82EB2968: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EB296C: 409A0038  bne cr6, 0x82eb29a4
	if !ctx.cr[6].eq {
	pc = 0x82EB29A4; continue 'dispatch;
	}
	// 82EB2970: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EB2974: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EB2978: 7D1F5050  subf r8, r31, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	pc = 0x82EB297C; continue 'dispatch;
            }
            0x82EB297C => {
    //   block [0x82EB297C..0x82EB29A4)
	// 82EB297C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2980: 419A0050  beq cr6, 0x82eb29d0
	if ctx.cr[6].eq {
	pc = 0x82EB29D0; continue 'dispatch;
	}
	// 82EB2984: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB2988: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB298C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2990: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 82EB2994: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EB2998: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB299C: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB29A0: 419AFFDC  beq cr6, 0x82eb297c
	if ctx.cr[6].eq {
	pc = 0x82EB297C; continue 'dispatch;
	}
	pc = 0x82EB29A4; continue 'dispatch;
            }
            0x82EB29A4 => {
    //   block [0x82EB29A4..0x82EB29B4)
	// 82EB29A4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB29A8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB29AC: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82EB29B0: 4198FFA8  blt cr6, 0x82eb2958
	if ctx.cr[6].lt {
	pc = 0x82EB2958; continue 'dispatch;
	}
	pc = 0x82EB29B4; continue 'dispatch;
            }
            0x82EB29B4 => {
    //   block [0x82EB29B4..0x82EB29B8)
	// 82EB29B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB29B8; continue 'dispatch;
            }
            0x82EB29B8 => {
    //   block [0x82EB29B8..0x82EB29D0)
	// 82EB29B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB29BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB29C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB29C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB29C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB29CC: 4E800020  blr
	return;
            }
            0x82EB29D0 => {
    //   block [0x82EB29D0..0x82EB29E0)
	// 82EB29D0: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB29D4: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB29D8: 806B0104  lwz r3, 0x104(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EB29DC: 4BFFFFDC  b 0x82eb29b8
	pc = 0x82EB29B8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB29E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB29E0 size=192
    let mut pc: u32 = 0x82EB29E0;
    'dispatch: loop {
        match pc {
            0x82EB29E0 => {
    //   block [0x82EB29E0..0x82EB2A18)
	// 82EB29E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB29E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB29E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB29EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB29F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB29F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB29F8: 4BFFFD79  bl 0x82eb2770
	ctx.lr = 0x82EB29FC;
	sub_82EB2770(ctx, base);
	// 82EB29FC: 80830040  lwz r4, 0x40(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB2A00: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2A04: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2A08: 4081006C  ble 0x82eb2a74
	if !ctx.cr[0].gt {
	pc = 0x82EB2A74; continue 'dispatch;
	}
	// 82EB2A0C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2A10: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB2A14: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	pc = 0x82EB2A18; continue 'dispatch;
            }
            0x82EB2A18 => {
    //   block [0x82EB2A18..0x82EB2A3C)
	// 82EB2A18: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2A1C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EB2A20: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2A24: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82EB2A28: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EB2A2C: 409A0038  bne cr6, 0x82eb2a64
	if !ctx.cr[6].eq {
	pc = 0x82EB2A64; continue 'dispatch;
	}
	// 82EB2A30: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EB2A34: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EB2A38: 7D1F5050  subf r8, r31, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	pc = 0x82EB2A3C; continue 'dispatch;
            }
            0x82EB2A3C => {
    //   block [0x82EB2A3C..0x82EB2A64)
	// 82EB2A3C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2A40: 419A0050  beq cr6, 0x82eb2a90
	if ctx.cr[6].eq {
	pc = 0x82EB2A90; continue 'dispatch;
	}
	// 82EB2A44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB2A48: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB2A4C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2A50: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 82EB2A54: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EB2A58: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB2A5C: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB2A60: 419AFFDC  beq cr6, 0x82eb2a3c
	if ctx.cr[6].eq {
	pc = 0x82EB2A3C; continue 'dispatch;
	}
	pc = 0x82EB2A64; continue 'dispatch;
            }
            0x82EB2A64 => {
    //   block [0x82EB2A64..0x82EB2A74)
	// 82EB2A64: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB2A68: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB2A6C: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82EB2A70: 4198FFA8  blt cr6, 0x82eb2a18
	if ctx.cr[6].lt {
	pc = 0x82EB2A18; continue 'dispatch;
	}
	pc = 0x82EB2A74; continue 'dispatch;
            }
            0x82EB2A74 => {
    //   block [0x82EB2A74..0x82EB2A78)
	// 82EB2A74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB2A78; continue 'dispatch;
            }
            0x82EB2A78 => {
    //   block [0x82EB2A78..0x82EB2A90)
	// 82EB2A78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB2A7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2A80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2A84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB2A88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2A8C: 4E800020  blr
	return;
            }
            0x82EB2A90 => {
    //   block [0x82EB2A90..0x82EB2AA0)
	// 82EB2A90: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB2A94: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB2A98: 806B0104  lwz r3, 0x104(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EB2A9C: 4BFFFFDC  b 0x82eb2a78
	pc = 0x82EB2A78; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2AA0 size=192
    let mut pc: u32 = 0x82EB2AA0;
    'dispatch: loop {
        match pc {
            0x82EB2AA0 => {
    //   block [0x82EB2AA0..0x82EB2AD8)
	// 82EB2AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB2AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2AB8: 4BFFFD31  bl 0x82eb27e8
	ctx.lr = 0x82EB2ABC;
	sub_82EB27E8(ctx, base);
	// 82EB2ABC: 80830040  lwz r4, 0x40(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB2AC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2AC4: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2AC8: 4081006C  ble 0x82eb2b34
	if !ctx.cr[0].gt {
	pc = 0x82EB2B34; continue 'dispatch;
	}
	// 82EB2ACC: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2AD0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB2AD4: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	pc = 0x82EB2AD8; continue 'dispatch;
            }
            0x82EB2AD8 => {
    //   block [0x82EB2AD8..0x82EB2AFC)
	// 82EB2AD8: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2ADC: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EB2AE0: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2AE4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82EB2AE8: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EB2AEC: 409A0038  bne cr6, 0x82eb2b24
	if !ctx.cr[6].eq {
	pc = 0x82EB2B24; continue 'dispatch;
	}
	// 82EB2AF0: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EB2AF4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EB2AF8: 7D1F5050  subf r8, r31, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	pc = 0x82EB2AFC; continue 'dispatch;
            }
            0x82EB2AFC => {
    //   block [0x82EB2AFC..0x82EB2B24)
	// 82EB2AFC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2B00: 419A0050  beq cr6, 0x82eb2b50
	if ctx.cr[6].eq {
	pc = 0x82EB2B50; continue 'dispatch;
	}
	// 82EB2B04: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB2B08: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB2B0C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2B10: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 82EB2B14: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EB2B18: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB2B1C: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB2B20: 419AFFDC  beq cr6, 0x82eb2afc
	if ctx.cr[6].eq {
	pc = 0x82EB2AFC; continue 'dispatch;
	}
	pc = 0x82EB2B24; continue 'dispatch;
            }
            0x82EB2B24 => {
    //   block [0x82EB2B24..0x82EB2B34)
	// 82EB2B24: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB2B28: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB2B2C: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82EB2B30: 4198FFA8  blt cr6, 0x82eb2ad8
	if ctx.cr[6].lt {
	pc = 0x82EB2AD8; continue 'dispatch;
	}
	pc = 0x82EB2B34; continue 'dispatch;
            }
            0x82EB2B34 => {
    //   block [0x82EB2B34..0x82EB2B38)
	// 82EB2B34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB2B38; continue 'dispatch;
            }
            0x82EB2B38 => {
    //   block [0x82EB2B38..0x82EB2B50)
	// 82EB2B38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB2B3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2B40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2B44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB2B48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2B4C: 4E800020  blr
	return;
            }
            0x82EB2B50 => {
    //   block [0x82EB2B50..0x82EB2B60)
	// 82EB2B50: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB2B54: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB2B58: 806B0104  lwz r3, 0x104(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EB2B5C: 4BFFFFDC  b 0x82eb2b38
	pc = 0x82EB2B38; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2B60 size=192
    let mut pc: u32 = 0x82EB2B60;
    'dispatch: loop {
        match pc {
            0x82EB2B60 => {
    //   block [0x82EB2B60..0x82EB2B98)
	// 82EB2B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2B68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB2B6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2B70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2B74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2B78: 4B77BB71  bl 0x8262e6e8
	ctx.lr = 0x82EB2B7C;
	sub_8262E6E8(ctx, base);
	// 82EB2B7C: 80830040  lwz r4, 0x40(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB2B80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2B84: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2B88: 4081006C  ble 0x82eb2bf4
	if !ctx.cr[0].gt {
	pc = 0x82EB2BF4; continue 'dispatch;
	}
	// 82EB2B8C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2B90: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB2B94: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	pc = 0x82EB2B98; continue 'dispatch;
            }
            0x82EB2B98 => {
    //   block [0x82EB2B98..0x82EB2BBC)
	// 82EB2B98: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2B9C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EB2BA0: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2BA4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82EB2BA8: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EB2BAC: 409A0038  bne cr6, 0x82eb2be4
	if !ctx.cr[6].eq {
	pc = 0x82EB2BE4; continue 'dispatch;
	}
	// 82EB2BB0: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EB2BB4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EB2BB8: 7D1F5050  subf r8, r31, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	pc = 0x82EB2BBC; continue 'dispatch;
            }
            0x82EB2BBC => {
    //   block [0x82EB2BBC..0x82EB2BE4)
	// 82EB2BBC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2BC0: 419A0050  beq cr6, 0x82eb2c10
	if ctx.cr[6].eq {
	pc = 0x82EB2C10; continue 'dispatch;
	}
	// 82EB2BC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB2BC8: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB2BCC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2BD0: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 82EB2BD4: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EB2BD8: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB2BDC: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB2BE0: 419AFFDC  beq cr6, 0x82eb2bbc
	if ctx.cr[6].eq {
	pc = 0x82EB2BBC; continue 'dispatch;
	}
	pc = 0x82EB2BE4; continue 'dispatch;
            }
            0x82EB2BE4 => {
    //   block [0x82EB2BE4..0x82EB2BF4)
	// 82EB2BE4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB2BE8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB2BEC: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82EB2BF0: 4198FFA8  blt cr6, 0x82eb2b98
	if ctx.cr[6].lt {
	pc = 0x82EB2B98; continue 'dispatch;
	}
	pc = 0x82EB2BF4; continue 'dispatch;
            }
            0x82EB2BF4 => {
    //   block [0x82EB2BF4..0x82EB2BF8)
	// 82EB2BF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB2BF8; continue 'dispatch;
            }
            0x82EB2BF8 => {
    //   block [0x82EB2BF8..0x82EB2C10)
	// 82EB2BF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB2BFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2C00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2C04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB2C08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2C0C: 4E800020  blr
	return;
            }
            0x82EB2C10 => {
    //   block [0x82EB2C10..0x82EB2C20)
	// 82EB2C10: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB2C14: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB2C18: 806B0104  lwz r3, 0x104(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EB2C1C: 4BFFFFDC  b 0x82eb2bf8
	pc = 0x82EB2BF8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2C20 size=192
    let mut pc: u32 = 0x82EB2C20;
    'dispatch: loop {
        match pc {
            0x82EB2C20 => {
    //   block [0x82EB2C20..0x82EB2C58)
	// 82EB2C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2C28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB2C2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2C30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2C34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2C38: 4B77B981  bl 0x8262e5b8
	ctx.lr = 0x82EB2C3C;
	sub_8262E5B8(ctx, base);
	// 82EB2C3C: 80830040  lwz r4, 0x40(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB2C40: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2C44: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2C48: 4081006C  ble 0x82eb2cb4
	if !ctx.cr[0].gt {
	pc = 0x82EB2CB4; continue 'dispatch;
	}
	// 82EB2C4C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2C50: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB2C54: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	pc = 0x82EB2C58; continue 'dispatch;
            }
            0x82EB2C58 => {
    //   block [0x82EB2C58..0x82EB2C7C)
	// 82EB2C58: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2C5C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EB2C60: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2C64: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82EB2C68: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EB2C6C: 409A0038  bne cr6, 0x82eb2ca4
	if !ctx.cr[6].eq {
	pc = 0x82EB2CA4; continue 'dispatch;
	}
	// 82EB2C70: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EB2C74: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EB2C78: 7D1F5050  subf r8, r31, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	pc = 0x82EB2C7C; continue 'dispatch;
            }
            0x82EB2C7C => {
    //   block [0x82EB2C7C..0x82EB2CA4)
	// 82EB2C7C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2C80: 419A0050  beq cr6, 0x82eb2cd0
	if ctx.cr[6].eq {
	pc = 0x82EB2CD0; continue 'dispatch;
	}
	// 82EB2C84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB2C88: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB2C8C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2C90: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 82EB2C94: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EB2C98: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB2C9C: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB2CA0: 419AFFDC  beq cr6, 0x82eb2c7c
	if ctx.cr[6].eq {
	pc = 0x82EB2C7C; continue 'dispatch;
	}
	pc = 0x82EB2CA4; continue 'dispatch;
            }
            0x82EB2CA4 => {
    //   block [0x82EB2CA4..0x82EB2CB4)
	// 82EB2CA4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB2CA8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB2CAC: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82EB2CB0: 4198FFA8  blt cr6, 0x82eb2c58
	if ctx.cr[6].lt {
	pc = 0x82EB2C58; continue 'dispatch;
	}
	pc = 0x82EB2CB4; continue 'dispatch;
            }
            0x82EB2CB4 => {
    //   block [0x82EB2CB4..0x82EB2CB8)
	// 82EB2CB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB2CB8; continue 'dispatch;
            }
            0x82EB2CB8 => {
    //   block [0x82EB2CB8..0x82EB2CD0)
	// 82EB2CB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB2CBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2CC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2CC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB2CC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2CCC: 4E800020  blr
	return;
            }
            0x82EB2CD0 => {
    //   block [0x82EB2CD0..0x82EB2CE0)
	// 82EB2CD0: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB2CD4: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB2CD8: 806B0104  lwz r3, 0x104(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EB2CDC: 4BFFFFDC  b 0x82eb2cb8
	pc = 0x82EB2CB8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2CE0 size=192
    let mut pc: u32 = 0x82EB2CE0;
    'dispatch: loop {
        match pc {
            0x82EB2CE0 => {
    //   block [0x82EB2CE0..0x82EB2D18)
	// 82EB2CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2CE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2CE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB2CEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2CF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2CF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2CF8: 4B77B959  bl 0x8262e650
	ctx.lr = 0x82EB2CFC;
	sub_8262E650(ctx, base);
	// 82EB2CFC: 80830040  lwz r4, 0x40(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB2D00: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2D04: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2D08: 4081006C  ble 0x82eb2d74
	if !ctx.cr[0].gt {
	pc = 0x82EB2D74; continue 'dispatch;
	}
	// 82EB2D0C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2D10: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB2D14: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	pc = 0x82EB2D18; continue 'dispatch;
            }
            0x82EB2D18 => {
    //   block [0x82EB2D18..0x82EB2D3C)
	// 82EB2D18: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2D1C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EB2D20: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2D24: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82EB2D28: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82EB2D2C: 409A0038  bne cr6, 0x82eb2d64
	if !ctx.cr[6].eq {
	pc = 0x82EB2D64; continue 'dispatch;
	}
	// 82EB2D30: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82EB2D34: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82EB2D38: 7D1F5050  subf r8, r31, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	pc = 0x82EB2D3C; continue 'dispatch;
            }
            0x82EB2D3C => {
    //   block [0x82EB2D3C..0x82EB2D64)
	// 82EB2D3C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2D40: 419A0050  beq cr6, 0x82eb2d90
	if ctx.cr[6].eq {
	pc = 0x82EB2D90; continue 'dispatch;
	}
	// 82EB2D44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB2D48: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB2D4C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2D50: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 82EB2D54: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82EB2D58: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB2D5C: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB2D60: 419AFFDC  beq cr6, 0x82eb2d3c
	if ctx.cr[6].eq {
	pc = 0x82EB2D3C; continue 'dispatch;
	}
	pc = 0x82EB2D64; continue 'dispatch;
            }
            0x82EB2D64 => {
    //   block [0x82EB2D64..0x82EB2D74)
	// 82EB2D64: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB2D68: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB2D6C: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82EB2D70: 4198FFA8  blt cr6, 0x82eb2d18
	if ctx.cr[6].lt {
	pc = 0x82EB2D18; continue 'dispatch;
	}
	pc = 0x82EB2D74; continue 'dispatch;
            }
            0x82EB2D74 => {
    //   block [0x82EB2D74..0x82EB2D78)
	// 82EB2D74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB2D78; continue 'dispatch;
            }
            0x82EB2D78 => {
    //   block [0x82EB2D78..0x82EB2D90)
	// 82EB2D78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB2D7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2D80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2D84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB2D88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2D8C: 4E800020  blr
	return;
            }
            0x82EB2D90 => {
    //   block [0x82EB2D90..0x82EB2DA0)
	// 82EB2D90: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB2D94: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB2D98: 806B0104  lwz r3, 0x104(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EB2D9C: 4BFFFFDC  b 0x82eb2d78
	pc = 0x82EB2D78; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2DA0 size=116
    let mut pc: u32 = 0x82EB2DA0;
    'dispatch: loop {
        match pc {
            0x82EB2DA0 => {
    //   block [0x82EB2DA0..0x82EB2DE8)
	// 82EB2DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2DA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2DAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2DB0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB2DB4: 816A8B54  lwz r11, -0x74ac(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-29868 as u32) ) } as u64;
	// 82EB2DB8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2DBC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EB2DC0: 3BE98750  addi r31, r9, -0x78b0
	ctx.r[31].s64 = ctx.r[9].s64 + -30896;
	// 82EB2DC4: 40820038  bne 0x82eb2dfc
	if !ctx.cr[0].eq {
	pc = 0x82EB2DFC; continue 'dispatch;
	}
	// 82EB2DC8: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EB2DCC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EB2DD0: 8909DF22  lbz r8, -0x20de(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8414 as u32) ) } as u64;
	// 82EB2DD4: 916A8B54  stw r11, -0x74ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-29868 as u32), ctx.r[11].u32 ) };
	// 82EB2DD8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2DDC: 4182000C  beq 0x82eb2de8
	if ctx.cr[0].eq {
	pc = 0x82EB2DE8; continue 'dispatch;
	}
	// 82EB2DE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB2DE4: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB2DE8; continue 'dispatch;
            }
            0x82EB2DE8 => {
    //   block [0x82EB2DE8..0x82EB2DFC)
	// 82EB2DE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB2DEC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EB2DF0: 386A8908  addi r3, r10, -0x76f8
	ctx.r[3].s64 = ctx.r[10].s64 + -30456;
	// 82EB2DF4: 9969DF22  stb r11, -0x20de(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8414 as u32), ctx.r[11].u8 ) };
	// 82EB2DF8: 4BDF7129  bl 0x82ca9f20
	ctx.lr = 0x82EB2DFC;
	sub_82CA9F20(ctx, base);
	pc = 0x82EB2DFC; continue 'dispatch;
            }
            0x82EB2DFC => {
    //   block [0x82EB2DFC..0x82EB2E14)
	// 82EB2DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2E00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB2E04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2E08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2E0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2E10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2E18 size=160
    let mut pc: u32 = 0x82EB2E18;
    'dispatch: loop {
        match pc {
            0x82EB2E18 => {
    //   block [0x82EB2E18..0x82EB2E4C)
	// 82EB2E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2E20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2E24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2E28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2E2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EB2E30: 419A0064  beq cr6, 0x82eb2e94
	if ctx.cr[6].eq {
	pc = 0x82EB2E94; continue 'dispatch;
	}
	// 82EB2E34: 4BFFFF6D  bl 0x82eb2da0
	ctx.lr = 0x82EB2E38;
	sub_82EB2DA0(ctx, base);
	// 82EB2E38: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB2E3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EB2E40: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2E44: 40810050  ble 0x82eb2e94
	if !ctx.cr[0].gt {
	pc = 0x82EB2E94; continue 'dispatch;
	}
	// 82EB2E48: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EB2E4C; continue 'dispatch;
            }
            0x82EB2E4C => {
    //   block [0x82EB2E4C..0x82EB2E58)
	// 82EB2E4C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2E50: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EB2E54: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EB2E58; continue 'dispatch;
            }
            0x82EB2E58 => {
    //   block [0x82EB2E58..0x82EB2E7C)
	// 82EB2E58: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2E5C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2E60: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2E64: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EB2E68: 41820014  beq 0x82eb2e7c
	if ctx.cr[0].eq {
	pc = 0x82EB2E7C; continue 'dispatch;
	}
	// 82EB2E6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB2E70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB2E74: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EB2E78: 419AFFE0  beq cr6, 0x82eb2e58
	if ctx.cr[6].eq {
	pc = 0x82EB2E58; continue 'dispatch;
	}
	pc = 0x82EB2E7C; continue 'dispatch;
            }
            0x82EB2E7C => {
    //   block [0x82EB2E7C..0x82EB2E94)
	// 82EB2E7C: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB2E80: 4182002C  beq 0x82eb2eac
	if ctx.cr[0].eq {
	pc = 0x82EB2EAC; continue 'dispatch;
	}
	// 82EB2E84: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EB2E88: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EB2E8C: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EB2E90: 4198FFBC  blt cr6, 0x82eb2e4c
	if ctx.cr[6].lt {
	pc = 0x82EB2E4C; continue 'dispatch;
	}
	pc = 0x82EB2E94; continue 'dispatch;
            }
            0x82EB2E94 => {
    //   block [0x82EB2E94..0x82EB2E98)
	// 82EB2E94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB2E98; continue 'dispatch;
            }
            0x82EB2E98 => {
    //   block [0x82EB2E98..0x82EB2EAC)
	// 82EB2E98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB2E9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2EA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2EA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2EA8: 4E800020  blr
	return;
            }
            0x82EB2EAC => {
    //   block [0x82EB2EAC..0x82EB2EB8)
	// 82EB2EAC: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB2EB0: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EB2EB4: 4BFFFFE4  b 0x82eb2e98
	pc = 0x82EB2E98; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB2EB8 size=320
    let mut pc: u32 = 0x82EB2EB8;
    'dispatch: loop {
        match pc {
            0x82EB2EB8 => {
    //   block [0x82EB2EB8..0x82EB2F04)
	// 82EB2EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2EBC: 4BDF6551  bl 0x82ca940c
	ctx.lr = 0x82EB2EC0;
	sub_82CA93D0(ctx, base);
	// 82EB2EC0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EB2EC4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EB2EC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2ECC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB2ED0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2ED4: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB2ED8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2EDC: 4E800421  bctrl
	ctx.lr = 0x82EB2EE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2EE0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB2EE4: 817E0168  lwz r11, 0x168(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB2EE8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EB2EEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2EF0: C3CA0C18  lfs f30, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB2EF4: 40820010  bne 0x82eb2f04
	if !ctx.cr[0].eq {
	pc = 0x82EB2F04; continue 'dispatch;
	}
	// 82EB2EF8: 817E016C  lwz r11, 0x16c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB2EFC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2F00: 4182000C  beq 0x82eb2f0c
	if ctx.cr[0].eq {
	pc = 0x82EB2F0C; continue 'dispatch;
	}
            }
            0x82EB2F04 => {
    //   block [0x82EB2F04..0x82EB2F0C)
	// 82EB2F04: 992B0004  stb r9, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	// 82EB2F08: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EB2F0C; continue 'dispatch;
            }
            0x82EB2F0C => {
    //   block [0x82EB2F0C..0x82EB2F24)
	// 82EB2F0C: 817E0160  lwz r11, 0x160(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB2F10: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2F14: 40820010  bne 0x82eb2f24
	if !ctx.cr[0].eq {
	pc = 0x82EB2F24; continue 'dispatch;
	}
	// 82EB2F18: 817E0164  lwz r11, 0x164(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB2F1C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2F20: 4182000C  beq 0x82eb2f2c
	if ctx.cr[0].eq {
	pc = 0x82EB2F2C; continue 'dispatch;
	}
	pc = 0x82EB2F24; continue 'dispatch;
            }
            0x82EB2F24 => {
    //   block [0x82EB2F24..0x82EB2F2C)
	// 82EB2F24: 992B0004  stb r9, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	// 82EB2F28: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EB2F2C; continue 'dispatch;
            }
            0x82EB2F2C => {
    //   block [0x82EB2F2C..0x82EB2F40)
	// 82EB2F2C: 817E0170  lwz r11, 0x170(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 82EB2F30: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2F34: 4182000C  beq 0x82eb2f40
	if ctx.cr[0].eq {
	pc = 0x82EB2F40; continue 'dispatch;
	}
	// 82EB2F38: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB2F3C: 992B0004  stb r9, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	pc = 0x82EB2F40; continue 'dispatch;
            }
            0x82EB2F40 => {
    //   block [0x82EB2F40..0x82EB2F68)
	// 82EB2F40: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB2F44: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB2F48: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB2F4C: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82EB2F50: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2F54: 4B335725  bl 0x821e8678
	ctx.lr = 0x82EB2F58;
	sub_821E8678(ctx, base);
	// 82EB2F58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2F5C: 4182000C  beq 0x82eb2f68
	if ctx.cr[0].eq {
	pc = 0x82EB2F68; continue 'dispatch;
	}
	// 82EB2F60: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2F64: 48000030  b 0x82eb2f94
	pc = 0x82EB2F94; continue 'dispatch;
            }
            0x82EB2F68 => {
    //   block [0x82EB2F68..0x82EB2F80)
	// 82EB2F68: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB2F6C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB2F70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2F74: 4182000C  beq 0x82eb2f80
	if ctx.cr[0].eq {
	pc = 0x82EB2F80; continue 'dispatch;
	}
	// 82EB2F78: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB2F7C: 4800000C  b 0x82eb2f88
	pc = 0x82EB2F88; continue 'dispatch;
            }
            0x82EB2F80 => {
    //   block [0x82EB2F80..0x82EB2F88)
	// 82EB2F80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB2F84: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EB2F88; continue 'dispatch;
            }
            0x82EB2F88 => {
    //   block [0x82EB2F88..0x82EB2F94)
	// 82EB2F88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB2F8C: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2F90: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82EB2F94; continue 'dispatch;
            }
            0x82EB2F94 => {
    //   block [0x82EB2F94..0x82EB2FB8)
	// 82EB2F94: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB2F98: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB2F9C: 4BFD2A55  bl 0x82e859f0
	ctx.lr = 0x82EB2FA0;
	sub_82E859F0(ctx, base);
	// 82EB2FA0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB2FA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB2FA8: 40990040  ble cr6, 0x82eb2fe8
	if !ctx.cr[6].gt {
	pc = 0x82EB2FE8; continue 'dispatch;
	}
	// 82EB2FAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB2FB0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB2FB4: C3EB0A8C  lfs f31, 0xa8c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2700 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EB2FB8; continue 'dispatch;
            }
            0x82EB2FB8 => {
    //   block [0x82EB2FB8..0x82EB2FE8)
	// 82EB2FB8: 817E01AC  lwz r11, 0x1ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB2FBC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB2FC0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB2FC4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB2FC8: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82EB2FCC: D3EB0008  stfs f31, 8(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB2FD0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB2FD4: D3CB000C  stfs f30, 0xc(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB2FD8: 4BFD2A19  bl 0x82e859f0
	ctx.lr = 0x82EB2FDC;
	sub_82E859F0(ctx, base);
	// 82EB2FDC: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB2FE0: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB2FE4: 4198FFD4  blt cr6, 0x82eb2fb8
	if ctx.cr[6].lt {
	pc = 0x82EB2FB8; continue 'dispatch;
	}
	pc = 0x82EB2FE8; continue 'dispatch;
            }
            0x82EB2FE8 => {
    //   block [0x82EB2FE8..0x82EB2FF8)
	// 82EB2FE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB2FEC: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EB2FF0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EB2FF4: 4BDF6468  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB2FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB2FF8 size=1848
    let mut pc: u32 = 0x82EB2FF8;
    'dispatch: loop {
        match pc {
            0x82EB2FF8 => {
    //   block [0x82EB2FF8..0x82EB303C)
	// 82EB2FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2FFC: 4BDF6405  bl 0x82ca9400
	ctx.lr = 0x82EB3000;
	sub_82CA93D0(ctx, base);
	// 82EB3000: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82EB3004: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EB3008: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB300C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82EB3010: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB3014: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82EB3018: 419A0704  beq cr6, 0x82eb371c
	if ctx.cr[6].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB301C: 4BFD29D5  bl 0x82e859f0
	ctx.lr = 0x82EB3020;
	sub_82E859F0(ctx, base);
	// 82EB3020: 83A30400  lwz r29, 0x400(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB3024: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 82EB3028: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB302C: 40820010  bne 0x82eb303c
	if !ctx.cr[0].eq {
	pc = 0x82EB303C; continue 'dispatch;
	}
	// 82EB3030: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82EB3034: 4B437185  bl 0x822ea1b8
	ctx.lr = 0x82EB3038;
	sub_822EA1B8(ctx, base);
	// 82EB3038: 48000034  b 0x82eb306c
	pc = 0x82EB306C; continue 'dispatch;
            }
            0x82EB303C => {
    //   block [0x82EB303C..0x82EB3054)
	// 82EB303C: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 82EB3040: 616BCCCC  ori r11, r11, 0xcccc
	ctx.r[11].u64 = ctx.r[11].u64 | 52428;
	// 82EB3044: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB3048: 1D7D0014  mulli r11, r29, 0x14
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB304C: 40990008  ble cr6, 0x82eb3054
	if !ctx.cr[6].gt {
	pc = 0x82EB3054; continue 'dispatch;
	}
	// 82EB3050: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82EB3054; continue 'dispatch;
            }
            0x82EB3054 => {
    //   block [0x82EB3054..0x82EB3068)
	// 82EB3054: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EB3058: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82EB305C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB3060: 40990008  ble cr6, 0x82eb3068
	if !ctx.cr[6].gt {
	pc = 0x82EB3068; continue 'dispatch;
	}
	// 82EB3064: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82EB3068; continue 'dispatch;
            }
            0x82EB3068 => {
    //   block [0x82EB3068..0x82EB306C)
	// 82EB3068: 4B7638C1  bl 0x82616928
	ctx.lr = 0x82EB306C;
	sub_82616928(ctx, base);
	pc = 0x82EB306C; continue 'dispatch;
            }
            0x82EB306C => {
    //   block [0x82EB306C..0x82EB30AC)
	// 82EB306C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB3070: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3074: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB3078: C16A0A94  lfs f11, 0xa94(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2708 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB307C: C3CB0C18  lfs f30, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB3080: 419A0050  beq cr6, 0x82eb30d0
	if ctx.cr[6].eq {
	pc = 0x82EB30D0; continue 'dispatch;
	}
	// 82EB3084: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 82EB3088: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82EB308C: 355DFFFF  addic. r10, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB3090: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EB3094: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB3098: 41800040  blt 0x82eb30d8
	if ctx.cr[0].lt {
	pc = 0x82EB30D8; continue 'dispatch;
	}
	// 82EB309C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EB30A0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB30A4: 3929A3A8  addi r9, r9, -0x5c58
	ctx.r[9].s64 = ctx.r[9].s64 + -23640;
	// 82EB30A8: C0080A8C  lfs f0, 0xa8c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EB30AC; continue 'dispatch;
            }
            0x82EB30AC => {
    //   block [0x82EB30AC..0x82EB30D0)
	// 82EB30AC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB30B0: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EB30B4: D3CB000C  stfs f30, 0xc(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB30B8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB30BC: D16B0010  stfs f11, 0x10(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB30C0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB30C4: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82EB30C8: 4080FFE4  bge 0x82eb30ac
	if !ctx.cr[0].lt {
	pc = 0x82EB30AC; continue 'dispatch;
	}
	// 82EB30CC: 4800000C  b 0x82eb30d8
	pc = 0x82EB30D8; continue 'dispatch;
            }
            0x82EB30D0 => {
    //   block [0x82EB30D0..0x82EB30D8)
	// 82EB30D0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB30D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x82EB30D8; continue 'dispatch;
            }
            0x82EB30D8 => {
    //   block [0x82EB30D8..0x82EB3160)
	// 82EB30D8: 3D4082EB  lis r10, -0x7d15
	ctx.r[10].s64 = -2098528256;
	// 82EB30DC: D3DF01C0  stfs f30, 0x1c0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB30E0: 3CA082EB  lis r5, -0x7d15
	ctx.r[5].s64 = -2098528256;
	// 82EB30E4: 909F01AC  stw r4, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[4].u32 ) };
	// 82EB30E8: 394A4370  addi r10, r10, 0x4370
	ctx.r[10].s64 = ctx.r[10].s64 + 17264;
	// 82EB30EC: 93BF00AC  stw r29, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[29].u32 ) };
	// 82EB30F0: 3CC082EB  lis r6, -0x7d15
	ctx.r[6].s64 = -2098528256;
	// 82EB30F4: 93DF01B8  stw r30, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[30].u32 ) };
	// 82EB30F8: 3CE082EA  lis r7, -0x7d16
	ctx.r[7].s64 = -2098593792;
	// 82EB30FC: 93DF01BC  stw r30, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[30].u32 ) };
	// 82EB3100: 3D0082EB  lis r8, -0x7d15
	ctx.r[8].s64 = -2098528256;
	// 82EB3104: 3D2082EB  lis r9, -0x7d15
	ctx.r[9].s64 = -2098528256;
	// 82EB3108: 3D6082EA  lis r11, -0x7d16
	ctx.r[11].s64 = -2098593792;
	// 82EB310C: 915F00A8  stw r10, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[10].u32 ) };
	// 82EB3110: 38A54270  addi r5, r5, 0x4270
	ctx.r[5].s64 = ctx.r[5].s64 + 17008;
	// 82EB3114: 396B63A8  addi r11, r11, 0x63a8
	ctx.r[11].s64 = ctx.r[11].s64 + 25512;
	// 82EB3118: 38C642E0  addi r6, r6, 0x42e0
	ctx.r[6].s64 = ctx.r[6].s64 + 17120;
	// 82EB311C: 38E763A8  addi r7, r7, 0x63a8
	ctx.r[7].s64 = ctx.r[7].s64 + 25512;
	// 82EB3120: 39084BA0  addi r8, r8, 0x4ba0
	ctx.r[8].s64 = ctx.r[8].s64 + 19360;
	// 82EB3124: 39294BA0  addi r9, r9, 0x4ba0
	ctx.r[9].s64 = ctx.r[9].s64 + 19360;
	// 82EB3128: 90BF009C  stw r5, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[5].u32 ) };
	// 82EB312C: 3F808334  lis r28, -0x7ccc
	ctx.r[28].s64 = -2093744128;
	// 82EB3130: 917F00B0  stw r11, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EB3134: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB3138: 90DF00A0  stw r6, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[6].u32 ) };
	// 82EB313C: 90FF00A4  stw r7, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 82EB3140: 911F00B4  stw r8, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[8].u32 ) };
	// 82EB3144: 913F00B8  stw r9, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[9].u32 ) };
	// 82EB3148: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB314C: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3150: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3154: 4182000C  beq 0x82eb3160
	if ctx.cr[0].eq {
	pc = 0x82EB3160; continue 'dispatch;
	}
	// 82EB3158: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB315C: 48000008  b 0x82eb3164
	pc = 0x82EB3164; continue 'dispatch;
            }
            0x82EB3160 => {
    //   block [0x82EB3160..0x82EB3164)
	// 82EB3160: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EB3164; continue 'dispatch;
            }
            0x82EB3164 => {
    //   block [0x82EB3164..0x82EB3188)
	// 82EB3164: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3168: C1AB0AC8  lfs f13, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB316C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB3170: D01F01C4  stfs f0, 0x1c4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82EB3174: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3178: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB317C: 4182000C  beq 0x82eb3188
	if ctx.cr[0].eq {
	pc = 0x82EB3188; continue 'dispatch;
	}
	// 82EB3180: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3184: 48000008  b 0x82eb318c
	pc = 0x82EB318C; continue 'dispatch;
            }
            0x82EB3188 => {
    //   block [0x82EB3188..0x82EB318C)
	// 82EB3188: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EB318C; continue 'dispatch;
            }
            0x82EB318C => {
    //   block [0x82EB318C..0x82EB31B0)
	// 82EB318C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3190: C18B0BFC  lfs f12, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB3194: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB3198: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EB319C: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB31A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB31A4: 4182000C  beq 0x82eb31b0
	if ctx.cr[0].eq {
	pc = 0x82EB31B0; continue 'dispatch;
	}
	// 82EB31A8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB31AC: 48000008  b 0x82eb31b4
	pc = 0x82EB31B4; continue 'dispatch;
            }
            0x82EB31B0 => {
    //   block [0x82EB31B0..0x82EB31B4)
	// 82EB31B0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EB31B4; continue 'dispatch;
            }
            0x82EB31B4 => {
    //   block [0x82EB31B4..0x82EB31D8)
	// 82EB31B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB31B8: C1AB0C84  lfs f13, 0xc84(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3204 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB31BC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB31C0: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EB31C4: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB31C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB31CC: 4182000C  beq 0x82eb31d8
	if ctx.cr[0].eq {
	pc = 0x82EB31D8; continue 'dispatch;
	}
	// 82EB31D0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB31D4: 48000008  b 0x82eb31dc
	pc = 0x82EB31DC; continue 'dispatch;
            }
            0x82EB31D8 => {
    //   block [0x82EB31D8..0x82EB31DC)
	// 82EB31D8: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EB31DC; continue 'dispatch;
            }
            0x82EB31DC => {
    //   block [0x82EB31DC..0x82EB31F4)
	// 82EB31DC: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82EB31E0: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB31E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB31E8: 4182000C  beq 0x82eb31f4
	if ctx.cr[0].eq {
	pc = 0x82EB31F4; continue 'dispatch;
	}
	// 82EB31EC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB31F0: 48000008  b 0x82eb31f8
	pc = 0x82EB31F8; continue 'dispatch;
            }
            0x82EB31F4 => {
    //   block [0x82EB31F4..0x82EB31F8)
	// 82EB31F4: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EB31F8; continue 'dispatch;
            }
            0x82EB31F8 => {
    //   block [0x82EB31F8..0x82EB321C)
	// 82EB31F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB31FC: C1ABBDF4  lfs f13, -0x420c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB3200: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB3204: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EB3208: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB320C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3210: 4182000C  beq 0x82eb321c
	if ctx.cr[0].eq {
	pc = 0x82EB321C; continue 'dispatch;
	}
	// 82EB3214: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3218: 48000008  b 0x82eb3220
	pc = 0x82EB3220; continue 'dispatch;
            }
            0x82EB321C => {
    //   block [0x82EB321C..0x82EB3220)
	// 82EB321C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EB3220; continue 'dispatch;
            }
            0x82EB3220 => {
    //   block [0x82EB3220..0x82EB3238)
	// 82EB3220: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EB3224: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3228: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB322C: 4182000C  beq 0x82eb3238
	if ctx.cr[0].eq {
	pc = 0x82EB3238; continue 'dispatch;
	}
	// 82EB3230: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB3234: 48000008  b 0x82eb323c
	pc = 0x82EB323C; continue 'dispatch;
            }
            0x82EB3238 => {
    //   block [0x82EB3238..0x82EB323C)
	// 82EB3238: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	pc = 0x82EB323C; continue 'dispatch;
            }
            0x82EB323C => {
    //   block [0x82EB323C..0x82EB3274)
	// 82EB323C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3240: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82EB3244: C00B0AA4  lfs f0, 0xaa4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3248: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB324C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB3250: 937F0054  stw r27, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82EB3254: D1BF004C  stfs f13, 0x4c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EB3258: C00BA500  lfs f0, -0x5b00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB325C: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB3260: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3264: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3268: 4182000C  beq 0x82eb3274
	if ctx.cr[0].eq {
	pc = 0x82EB3274; continue 'dispatch;
	}
	// 82EB326C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3270: 48000008  b 0x82eb3278
	pc = 0x82EB3278; continue 'dispatch;
            }
            0x82EB3274 => {
    //   block [0x82EB3274..0x82EB3278)
	// 82EB3274: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EB3278; continue 'dispatch;
            }
            0x82EB3278 => {
    //   block [0x82EB3278..0x82EB3298)
	// 82EB3278: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB327C: D3FF0060  stfs f31, 0x60(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB3280: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB3284: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3288: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB328C: 4182000C  beq 0x82eb3298
	if ctx.cr[0].eq {
	pc = 0x82EB3298; continue 'dispatch;
	}
	// 82EB3290: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3294: 48000008  b 0x82eb329c
	pc = 0x82EB329C; continue 'dispatch;
            }
            0x82EB3298 => {
    //   block [0x82EB3298..0x82EB329C)
	// 82EB3298: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EB329C; continue 'dispatch;
            }
            0x82EB329C => {
    //   block [0x82EB329C..0x82EB32D8)
	// 82EB329C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB32A0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB32A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB32A8: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB32AC: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82EB32B0: D17F0064  stfs f11, 0x64(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB32B4: 9BBF0068  stb r29, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[29].u8 ) };
	// 82EB32B8: 9BBF0069  stb r29, 0x69(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(105 as u32), ctx.r[29].u8 ) };
	// 82EB32BC: 9B7F01B6  stb r27, 0x1b6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(438 as u32), ctx.r[27].u8 ) };
	// 82EB32C0: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB32C4: 4B3353B5  bl 0x821e8678
	ctx.lr = 0x82EB32C8;
	sub_821E8678(ctx, base);
	// 82EB32C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB32CC: 4182000C  beq 0x82eb32d8
	if ctx.cr[0].eq {
	pc = 0x82EB32D8; continue 'dispatch;
	}
	// 82EB32D0: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB32D4: 48000028  b 0x82eb32fc
	pc = 0x82EB32FC; continue 'dispatch;
            }
            0x82EB32D8 => {
    //   block [0x82EB32D8..0x82EB32EC)
	// 82EB32D8: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB32DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB32E0: 4182000C  beq 0x82eb32ec
	if ctx.cr[0].eq {
	pc = 0x82EB32EC; continue 'dispatch;
	}
	// 82EB32E4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB32E8: 48000008  b 0x82eb32f0
	pc = 0x82EB32F0; continue 'dispatch;
            }
            0x82EB32EC => {
    //   block [0x82EB32EC..0x82EB32F0)
	// 82EB32EC: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EB32F0; continue 'dispatch;
            }
            0x82EB32F0 => {
    //   block [0x82EB32F0..0x82EB32FC)
	// 82EB32F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB32F4: C1AB0C4C  lfs f13, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB32F8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x82EB32FC; continue 'dispatch;
            }
            0x82EB32FC => {
    //   block [0x82EB32FC..0x82EB33FC)
	// 82EB32FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3300: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB3304: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 82EB3308: 93BF006C  stw r29, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82EB330C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3310: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB3314: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3318: 4E800421  bctrl
	ctx.lr = 0x82EB331C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB331C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3320: 389F002C  addi r4, r31, 0x2c
	ctx.r[4].s64 = ctx.r[31].s64 + 44;
	// 82EB3324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3328: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB332C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3330: 4E800421  bctrl
	ctx.lr = 0x82EB3334;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3334: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3338: 807C0718  lwz r3, 0x718(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB333C: 388BDF68  addi r4, r11, -0x2098
	ctx.r[4].s64 = ctx.r[11].s64 + -8344;
	// 82EB3340: 4B3B48E1  bl 0x82267c20
	ctx.lr = 0x82EB3344;
	sub_82267C20(ctx, base);
	// 82EB3344: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3348: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB334C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EB3350: 388BA4F4  addi r4, r11, -0x5b0c
	ctx.r[4].s64 = ctx.r[11].s64 + -23308;
	// 82EB3354: 915F017C  stw r10, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[10].u32 ) };
	// 82EB3358: 4BFD0BC1  bl 0x82e83f18
	ctx.lr = 0x82EB335C;
	sub_82E83F18(ctx, base);
	// 82EB335C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EB3360: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3364: 418200B0  beq 0x82eb3414
	if ctx.cr[0].eq {
	pc = 0x82EB3414; continue 'dispatch;
	}
	// 82EB3368: 4BA5A9A1  bl 0x8290dd08
	ctx.lr = 0x82EB336C;
	sub_8290DD08(ctx, base);
	// 82EB336C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EB3370: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB3374: 388B1694  addi r4, r11, 0x1694
	ctx.r[4].s64 = ctx.r[11].s64 + 5780;
	// 82EB3378: 4BDF97D9  bl 0x82cacb50
	ctx.lr = 0x82EB337C;
	sub_82CACB50(ctx, base);
	// 82EB337C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3380: 41820084  beq 0x82eb3404
	if ctx.cr[0].eq {
	pc = 0x82EB3404; continue 'dispatch;
	}
	// 82EB3384: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3388: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB338C: 388B0F40  addi r4, r11, 0xf40
	ctx.r[4].s64 = ctx.r[11].s64 + 3904;
	// 82EB3390: 4BDF97C1  bl 0x82cacb50
	ctx.lr = 0x82EB3394;
	sub_82CACB50(ctx, base);
	// 82EB3394: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3398: 4182006C  beq 0x82eb3404
	if ctx.cr[0].eq {
	pc = 0x82EB3404; continue 'dispatch;
	}
	// 82EB339C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EB33A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB33A4: 388BD56C  addi r4, r11, -0x2a94
	ctx.r[4].s64 = ctx.r[11].s64 + -10900;
	// 82EB33A8: 4BDF97A9  bl 0x82cacb50
	ctx.lr = 0x82EB33AC;
	sub_82CACB50(ctx, base);
	// 82EB33AC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB33B0: 41820054  beq 0x82eb3404
	if ctx.cr[0].eq {
	pc = 0x82EB3404; continue 'dispatch;
	}
	// 82EB33B4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EB33B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB33BC: 388B1698  addi r4, r11, 0x1698
	ctx.r[4].s64 = ctx.r[11].s64 + 5784;
	// 82EB33C0: 4BDF9791  bl 0x82cacb50
	ctx.lr = 0x82EB33C4;
	sub_82CACB50(ctx, base);
	// 82EB33C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB33C8: 41820034  beq 0x82eb33fc
	if ctx.cr[0].eq {
	pc = 0x82EB33FC; continue 'dispatch;
	}
	// 82EB33CC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EB33D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB33D4: 388B1700  addi r4, r11, 0x1700
	ctx.r[4].s64 = ctx.r[11].s64 + 5888;
	// 82EB33D8: 4BDF9779  bl 0x82cacb50
	ctx.lr = 0x82EB33DC;
	sub_82CACB50(ctx, base);
	// 82EB33DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB33E0: 4182001C  beq 0x82eb33fc
	if ctx.cr[0].eq {
	pc = 0x82EB33FC; continue 'dispatch;
	}
	// 82EB33E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EB33E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB33EC: 388B7088  addi r4, r11, 0x7088
	ctx.r[4].s64 = ctx.r[11].s64 + 28808;
	// 82EB33F0: 4BDF9761  bl 0x82cacb50
	ctx.lr = 0x82EB33F4;
	sub_82CACB50(ctx, base);
	// 82EB33F4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB33F8: 40820324  bne 0x82eb371c
	if !ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
            }
            0x82EB33FC => {
    //   block [0x82EB33FC..0x82EB3404)
	// 82EB33FC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB3400: 48000008  b 0x82eb3408
	pc = 0x82EB3408; continue 'dispatch;
            }
            0x82EB3404 => {
    //   block [0x82EB3404..0x82EB3408)
	// 82EB3404: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82EB3408; continue 'dispatch;
            }
            0x82EB3408 => {
    //   block [0x82EB3408..0x82EB3414)
	// 82EB3408: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EB340C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB3410: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	pc = 0x82EB3414; continue 'dispatch;
            }
            0x82EB3414 => {
    //   block [0x82EB3414..0x82EB3460)
	// 82EB3414: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3418: 4182006C  beq 0x82eb3484
	if ctx.cr[0].eq {
	pc = 0x82EB3484; continue 'dispatch;
	}
	// 82EB341C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3420: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EB3424: 388BA4DC  addi r4, r11, -0x5b24
	ctx.r[4].s64 = ctx.r[11].s64 + -23332;
	// 82EB3428: 4BFD0AF1  bl 0x82e83f18
	ctx.lr = 0x82EB342C;
	sub_82E83F18(ctx, base);
	// 82EB342C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3430: 41820030  beq 0x82eb3460
	if ctx.cr[0].eq {
	pc = 0x82EB3460; continue 'dispatch;
	}
	// 82EB3434: 4BA5A8D5  bl 0x8290dd08
	ctx.lr = 0x82EB3438;
	sub_8290DD08(ctx, base);
	// 82EB3438: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB343C: 41820024  beq 0x82eb3460
	if ctx.cr[0].eq {
	pc = 0x82EB3460; continue 'dispatch;
	}
	// 82EB3440: 4BFFF9D9  bl 0x82eb2e18
	ctx.lr = 0x82EB3444;
	sub_82EB2E18(ctx, base);
	// 82EB3444: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3448: 41820018  beq 0x82eb3460
	if ctx.cr[0].eq {
	pc = 0x82EB3460; continue 'dispatch;
	}
	// 82EB344C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB3450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3458: 4E800421  bctrl
	ctx.lr = 0x82EB345C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB345C: 48000024  b 0x82eb3480
	pc = 0x82EB3480; continue 'dispatch;
            }
            0x82EB3460 => {
    //   block [0x82EB3460..0x82EB347C)
	// 82EB3460: 38600104  li r3, 0x104
	ctx.r[3].s64 = 260;
	// 82EB3464: 4B7634C5  bl 0x82616928
	ctx.lr = 0x82EB3468;
	sub_82616928(ctx, base);
	// 82EB3468: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB346C: 41820010  beq 0x82eb347c
	if ctx.cr[0].eq {
	pc = 0x82EB347C; continue 'dispatch;
	}
	// 82EB3470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB3474: 4802C4B5  bl 0x82edf928
	ctx.lr = 0x82EB3478;
	sub_82EDF928(ctx, base);
	// 82EB3478: 48000008  b 0x82eb3480
	pc = 0x82EB3480; continue 'dispatch;
            }
            0x82EB347C => {
    //   block [0x82EB347C..0x82EB3480)
	// 82EB347C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x82EB3480; continue 'dispatch;
            }
            0x82EB3480 => {
    //   block [0x82EB3480..0x82EB3484)
	// 82EB3480: 907F01B0  stw r3, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	pc = 0x82EB3484; continue 'dispatch;
            }
            0x82EB3484 => {
    //   block [0x82EB3484..0x82EB3570)
	// 82EB3484: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EB3488: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB348C: 4BFD1F1D  bl 0x82e853a8
	ctx.lr = 0x82EB3490;
	sub_82E853A8(ctx, base);
	// 82EB3490: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3494: 41820288  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB3498: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB349C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB34A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB34A4: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EB34A8: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB34AC: 4B3351CD  bl 0x821e8678
	ctx.lr = 0x82EB34B0;
	sub_821E8678(ctx, base);
	// 82EB34B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB34B4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB34B8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB34BC: 907F0158  stw r3, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[3].u32 ) };
	// 82EB34C0: 388BD1AC  addi r4, r11, -0x2e54
	ctx.r[4].s64 = ctx.r[11].s64 + -11860;
	// 82EB34C4: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB34C8: 4B3351B1  bl 0x821e8678
	ctx.lr = 0x82EB34CC;
	sub_821E8678(ctx, base);
	// 82EB34CC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB34D0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB34D4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB34D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB34DC: 388BC6DC  addi r4, r11, -0x3924
	ctx.r[4].s64 = ctx.r[11].s64 + -14628;
	// 82EB34E0: 915F015C  stw r10, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[10].u32 ) };
	// 82EB34E4: 4BFCA1DD  bl 0x82e7d6c0
	ctx.lr = 0x82EB34E8;
	sub_82E7D6C0(ctx, base);
	// 82EB34E8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB34EC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB34F0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB34F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB34F8: 388BCB2C  addi r4, r11, -0x34d4
	ctx.r[4].s64 = ctx.r[11].s64 + -13524;
	// 82EB34FC: 915F0160  stw r10, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[10].u32 ) };
	// 82EB3500: 4BFCA1C1  bl 0x82e7d6c0
	ctx.lr = 0x82EB3504;
	sub_82E7D6C0(ctx, base);
	// 82EB3504: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3508: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB350C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3510: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB3514: 388BCF7C  addi r4, r11, -0x3084
	ctx.r[4].s64 = ctx.r[11].s64 + -12420;
	// 82EB3518: 915F0164  stw r10, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[10].u32 ) };
	// 82EB351C: 4BFCA1A5  bl 0x82e7d6c0
	ctx.lr = 0x82EB3520;
	sub_82E7D6C0(ctx, base);
	// 82EB3520: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3524: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB3528: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB352C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB3530: 388BC7F0  addi r4, r11, -0x3810
	ctx.r[4].s64 = ctx.r[11].s64 + -14352;
	// 82EB3534: 915F0168  stw r10, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[10].u32 ) };
	// 82EB3538: 4BFCA189  bl 0x82e7d6c0
	ctx.lr = 0x82EB353C;
	sub_82E7D6C0(ctx, base);
	// 82EB353C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3540: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB3544: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3548: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB354C: 388BD710  addi r4, r11, -0x28f0
	ctx.r[4].s64 = ctx.r[11].s64 + -10480;
	// 82EB3550: 915F016C  stw r10, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[10].u32 ) };
	// 82EB3554: 4BFCA16D  bl 0x82e7d6c0
	ctx.lr = 0x82EB3558;
	sub_82E7D6C0(ctx, base);
	// 82EB3558: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB355C: 907F0170  stw r3, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[3].u32 ) };
	// 82EB3560: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3564: 4182000C  beq 0x82eb3570
	if ctx.cr[0].eq {
	pc = 0x82EB3570; continue 'dispatch;
	}
	// 82EB3568: D3CB0008  stfs f30, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB356C: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	pc = 0x82EB3570; continue 'dispatch;
            }
            0x82EB3570 => {
    //   block [0x82EB3570..0x82EB3584)
	// 82EB3570: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB3574: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3578: 4182000C  beq 0x82eb3584
	if ctx.cr[0].eq {
	pc = 0x82EB3584; continue 'dispatch;
	}
	// 82EB357C: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB3580: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	pc = 0x82EB3584; continue 'dispatch;
            }
            0x82EB3584 => {
    //   block [0x82EB3584..0x82EB3598)
	// 82EB3584: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB3588: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB358C: 4182000C  beq 0x82eb3598
	if ctx.cr[0].eq {
	pc = 0x82EB3598; continue 'dispatch;
	}
	// 82EB3590: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB3594: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	pc = 0x82EB3598; continue 'dispatch;
            }
            0x82EB3598 => {
    //   block [0x82EB3598..0x82EB35AC)
	// 82EB3598: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB359C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB35A0: 4182000C  beq 0x82eb35ac
	if ctx.cr[0].eq {
	pc = 0x82EB35AC; continue 'dispatch;
	}
	// 82EB35A4: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB35A8: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	pc = 0x82EB35AC; continue 'dispatch;
            }
            0x82EB35AC => {
    //   block [0x82EB35AC..0x82EB35C0)
	// 82EB35AC: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82EB35B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB35B4: 4182000C  beq 0x82eb35c0
	if ctx.cr[0].eq {
	pc = 0x82EB35C0; continue 'dispatch;
	}
	// 82EB35B8: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB35BC: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	pc = 0x82EB35C0; continue 'dispatch;
            }
            0x82EB35C0 => {
    //   block [0x82EB35C0..0x82EB36AC)
	// 82EB35C0: 4B3AD3F9  bl 0x822609b8
	ctx.lr = 0x82EB35C4;
	sub_822609B8(ctx, base);
	// 82EB35C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB35C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB35CC: 388BA4B0  addi r4, r11, -0x5b50
	ctx.r[4].s64 = ctx.r[11].s64 + -23376;
	// 82EB35D0: 4BFCDC01  bl 0x82e811d0
	ctx.lr = 0x82EB35D4;
	sub_82E811D0(ctx, base);
	// 82EB35D4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB35D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB35DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB35E0: 388BA48C  addi r4, r11, -0x5b74
	ctx.r[4].s64 = ctx.r[11].s64 + -23412;
	// 82EB35E4: 915F0184  stw r10, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[10].u32 ) };
	// 82EB35E8: 4BFCDB81  bl 0x82e81168
	ctx.lr = 0x82EB35EC;
	sub_82E81168(ctx, base);
	// 82EB35EC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB35F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB35F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB35F8: 388BA464  addi r4, r11, -0x5b9c
	ctx.r[4].s64 = ctx.r[11].s64 + -23452;
	// 82EB35FC: 915F0180  stw r10, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[10].u32 ) };
	// 82EB3600: 4BFCDBD1  bl 0x82e811d0
	ctx.lr = 0x82EB3604;
	sub_82E811D0(ctx, base);
	// 82EB3604: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3608: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB360C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB3610: 388BA444  addi r4, r11, -0x5bbc
	ctx.r[4].s64 = ctx.r[11].s64 + -23484;
	// 82EB3614: 915F0188  stw r10, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[10].u32 ) };
	// 82EB3618: 4BFCDBB9  bl 0x82e811d0
	ctx.lr = 0x82EB361C;
	sub_82E811D0(ctx, base);
	// 82EB361C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3620: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3628: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB362C: 915F018C  stw r10, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[10].u32 ) };
	// 82EB3630: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3634: 4E800421  bctrl
	ctx.lr = 0x82EB3638;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3638: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB363C: 418200E0  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB3640: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3648: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB364C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3650: 4E800421  bctrl
	ctx.lr = 0x82EB3654;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3654: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3658: 418200C4  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB365C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3664: 816B0074  lwz r11, 0x74(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB3668: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB366C: 4E800421  bctrl
	ctx.lr = 0x82EB3670;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3670: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3674: 418200A8  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB3678: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB367C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3680: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB3684: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3688: 4E800421  bctrl
	ctx.lr = 0x82EB368C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB368C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3690: 4182008C  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB3694: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EB3698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB369C: 409A0010  bne cr6, 0x82eb36ac
	if !ctx.cr[6].eq {
	pc = 0x82EB36AC; continue 'dispatch;
	}
	// 82EB36A0: 38800032  li r4, 0x32
	ctx.r[4].s64 = 50;
	// 82EB36A4: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB36A8: 4BFDF979  bl 0x82e93020
	ctx.lr = 0x82EB36AC;
	sub_82E93020(ctx, base);
            }
            0x82EB36AC => {
    //   block [0x82EB36AC..0x82EB36DC)
	// 82EB36AC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB36B0: 807C0718  lwz r3, 0x718(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB36B4: 388B5E98  addi r4, r11, 0x5e98
	ctx.r[4].s64 = ctx.r[11].s64 + 24216;
	// 82EB36B8: 4B3B4569  bl 0x82267c20
	ctx.lr = 0x82EB36BC;
	sub_82267C20(ctx, base);
	// 82EB36BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB36C0: 4182001C  beq 0x82eb36dc
	if ctx.cr[0].eq {
	pc = 0x82EB36DC; continue 'dispatch;
	}
	// 82EB36C4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB36C8: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EB36CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EB36D0: 388B1130  addi r4, r11, 0x1130
	ctx.r[4].s64 = ctx.r[11].s64 + 4400;
	// 82EB36D4: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB36D8: 4BFE4CF1  bl 0x82e983c8
	ctx.lr = 0x82EB36DC;
	sub_82E983C8(ctx, base);
	pc = 0x82EB36DC; continue 'dispatch;
            }
            0x82EB36DC => {
    //   block [0x82EB36DC..0x82EB3700)
	// 82EB36DC: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB36E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB36E4: 4182001C  beq 0x82eb3700
	if ctx.cr[0].eq {
	pc = 0x82EB3700; continue 'dispatch;
	}
	// 82EB36E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB36EC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB36F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB36F4: 4E800421  bctrl
	ctx.lr = 0x82EB36F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB36F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB36FC: 41820020  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
            }
            0x82EB3700 => {
    //   block [0x82EB3700..0x82EB371C)
	// 82EB3700: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3708: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB370C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3710: 4E800421  bctrl
	ctx.lr = 0x82EB3714;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3714: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3718: 48000008  b 0x82eb3720
	pc = 0x82EB3720; continue 'dispatch;
            }
            0x82EB371C => {
    //   block [0x82EB371C..0x82EB3720)
	// 82EB371C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB3720; continue 'dispatch;
            }
            0x82EB3720 => {
    //   block [0x82EB3720..0x82EB3730)
	// 82EB3720: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EB3724: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82EB3728: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EB372C: 4BDF5D24  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB3730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB3730 size=2872
    let mut pc: u32 = 0x82EB3730;
    'dispatch: loop {
        match pc {
            0x82EB3730 => {
    //   block [0x82EB3730..0x82EB3754)
	// 82EB3730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB3734: 4BDF5CD9  bl 0x82ca940c
	ctx.lr = 0x82EB3738;
	sub_82CA93D0(ctx, base);
	// 82EB3738: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EB373C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EB3740: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB3744: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EB3748: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB374C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EB3750: 409A000C  bne cr6, 0x82eb375c
	if !ctx.cr[6].eq {
	pc = 0x82EB375C; continue 'dispatch;
	}
	pc = 0x82EB3754; continue 'dispatch;
            }
            0x82EB3754 => {
    //   block [0x82EB3754..0x82EB375C)
	// 82EB3754: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB3758: 48000B00  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB375C => {
    //   block [0x82EB375C..0x82EB37A0)
	// 82EB375C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3764: 3BCB88AC  addi r30, r11, -0x7754
	ctx.r[30].s64 = ctx.r[11].s64 + -30548;
	// 82EB3768: 483088F9  bl 0x831bc060
	ctx.lr = 0x82EB376C;
	sub_831BC060(ctx, base);
	// 82EB376C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3770: 4BDF93E1  bl 0x82cacb50
	ctx.lr = 0x82EB3774;
	sub_82CACB50(ctx, base);
	// 82EB3774: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB377C: 40820024  bne 0x82eb37a0
	if !ctx.cr[0].eq {
	pc = 0x82EB37A0; continue 'dispatch;
	}
	// 82EB3780: 4BA5A589  bl 0x8290dd08
	ctx.lr = 0x82EB3784;
	sub_8290DD08(ctx, base);
	// 82EB3784: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3788: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EB378C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB3790: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB3794: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3798: 4E800421  bctrl
	ctx.lr = 0x82EB379C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB379C: 48000ABC  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB37A0 => {
    //   block [0x82EB37A0..0x82EB37E4)
	// 82EB37A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB37A4: 3BCBA674  addi r30, r11, -0x598c
	ctx.r[30].s64 = ctx.r[11].s64 + -22924;
	// 82EB37A8: 483088B9  bl 0x831bc060
	ctx.lr = 0x82EB37AC;
	sub_831BC060(ctx, base);
	// 82EB37AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB37B0: 4BDF93A1  bl 0x82cacb50
	ctx.lr = 0x82EB37B4;
	sub_82CACB50(ctx, base);
	// 82EB37B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB37B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB37BC: 40820048  bne 0x82eb3804
	if !ctx.cr[0].eq {
	pc = 0x82EB3804; continue 'dispatch;
	}
	// 82EB37C0: 4BA5A549  bl 0x8290dd08
	ctx.lr = 0x82EB37C4;
	sub_8290DD08(ctx, base);
	// 82EB37C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB37C8: 4182FF8C  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB37CC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB37D0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB37D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB37D8: 4182000C  beq 0x82eb37e4
	if ctx.cr[0].eq {
	pc = 0x82EB37E4; continue 'dispatch;
	}
	// 82EB37DC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB37E0: 4800000C  b 0x82eb37ec
	pc = 0x82EB37EC; continue 'dispatch;
            }
            0x82EB37E4 => {
    //   block [0x82EB37E4..0x82EB37EC)
	// 82EB37E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB37E8: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EB37EC; continue 'dispatch;
            }
            0x82EB37EC => {
    //   block [0x82EB37EC..0x82EB3804)
	// 82EB37EC: 4BDF83C5  bl 0x82cabbb0
	ctx.lr = 0x82EB37F0;
	sub_82CABBB0(ctx, base);
	// 82EB37F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB37F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB37F8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB37FC: D01D0034  stfs f0, 0x34(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EB3800: 48000A58  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3804 => {
    //   block [0x82EB3804..0x82EB3850)
	// 82EB3804: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3808: 3BCBA668  addi r30, r11, -0x5998
	ctx.r[30].s64 = ctx.r[11].s64 + -22936;
	// 82EB380C: 48308855  bl 0x831bc060
	ctx.lr = 0x82EB3810;
	sub_831BC060(ctx, base);
	// 82EB3810: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3814: 4BDF933D  bl 0x82cacb50
	ctx.lr = 0x82EB3818;
	sub_82CACB50(ctx, base);
	// 82EB3818: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB381C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3820: 40820080  bne 0x82eb38a0
	if !ctx.cr[0].eq {
	pc = 0x82EB38A0; continue 'dispatch;
	}
	// 82EB3824: 4BA5A4E5  bl 0x8290dd08
	ctx.lr = 0x82EB3828;
	sub_8290DD08(ctx, base);
	// 82EB3828: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB382C: 4182FF28  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3830: 3FE08334  lis r31, -0x7ccc
	ctx.r[31].s64 = -2093744128;
	// 82EB3834: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB3838: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB383C: C3CA0C14  lfs f30, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB3840: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3844: 4182000C  beq 0x82eb3850
	if ctx.cr[0].eq {
	pc = 0x82EB3850; continue 'dispatch;
	}
	// 82EB3848: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB384C: 48000008  b 0x82eb3854
	pc = 0x82EB3854; continue 'dispatch;
            }
            0x82EB3850 => {
    //   block [0x82EB3850..0x82EB3854)
	// 82EB3850: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	pc = 0x82EB3854; continue 'dispatch;
            }
            0x82EB3854 => {
    //   block [0x82EB3854..0x82EB3874)
	// 82EB3854: 4BDF835D  bl 0x82cabbb0
	ctx.lr = 0x82EB3858;
	sub_82CABBB0(ctx, base);
	// 82EB3858: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB385C: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3860: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3864: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3868: 4182000C  beq 0x82eb3874
	if ctx.cr[0].eq {
	pc = 0x82EB3874; continue 'dispatch;
	}
	// 82EB386C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB3870: 48000008  b 0x82eb3878
	pc = 0x82EB3878; continue 'dispatch;
            }
            0x82EB3874 => {
    //   block [0x82EB3874..0x82EB3878)
	// 82EB3874: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	pc = 0x82EB3878; continue 'dispatch;
            }
            0x82EB3878 => {
    //   block [0x82EB3878..0x82EB3898)
	// 82EB3878: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB387C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3880: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB3884: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3888: 816A0030  lwz r11, 0x30(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EB388C: EC4D083A  fmadds f2, f13, f0, f1
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64);
	// 82EB3890: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3894: 4E800421  bctrl
	ctx.lr = 0x82EB3898;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB3898 => {
    //   block [0x82EB3898..0x82EB38A0)
	// 82EB3898: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB389C: 480009BC  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB38A0 => {
    //   block [0x82EB38A0..0x82EB38E4)
	// 82EB38A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB38A4: 3BCBA65C  addi r30, r11, -0x59a4
	ctx.r[30].s64 = ctx.r[11].s64 + -22948;
	// 82EB38A8: 483087B9  bl 0x831bc060
	ctx.lr = 0x82EB38AC;
	sub_831BC060(ctx, base);
	// 82EB38AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB38B0: 4BDF92A1  bl 0x82cacb50
	ctx.lr = 0x82EB38B4;
	sub_82CACB50(ctx, base);
	// 82EB38B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB38B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB38BC: 40820048  bne 0x82eb3904
	if !ctx.cr[0].eq {
	pc = 0x82EB3904; continue 'dispatch;
	}
	// 82EB38C0: 4BA5A449  bl 0x8290dd08
	ctx.lr = 0x82EB38C4;
	sub_8290DD08(ctx, base);
	// 82EB38C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB38C8: 4182FE8C  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB38CC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB38D0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB38D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB38D8: 4182000C  beq 0x82eb38e4
	if ctx.cr[0].eq {
	pc = 0x82EB38E4; continue 'dispatch;
	}
	// 82EB38DC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB38E0: 4800000C  b 0x82eb38ec
	pc = 0x82EB38EC; continue 'dispatch;
            }
            0x82EB38E4 => {
    //   block [0x82EB38E4..0x82EB38EC)
	// 82EB38E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB38E8: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EB38EC; continue 'dispatch;
            }
            0x82EB38EC => {
    //   block [0x82EB38EC..0x82EB3904)
	// 82EB38EC: 4BDF82C5  bl 0x82cabbb0
	ctx.lr = 0x82EB38F0;
	sub_82CABBB0(ctx, base);
	// 82EB38F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB38F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB38F8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB38FC: D01D0038  stfs f0, 0x38(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EB3900: 48000958  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3904 => {
    //   block [0x82EB3904..0x82EB3948)
	// 82EB3904: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3908: 3BCBA648  addi r30, r11, -0x59b8
	ctx.r[30].s64 = ctx.r[11].s64 + -22968;
	// 82EB390C: 48308755  bl 0x831bc060
	ctx.lr = 0x82EB3910;
	sub_831BC060(ctx, base);
	// 82EB3910: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3914: 4BDF923D  bl 0x82cacb50
	ctx.lr = 0x82EB3918;
	sub_82CACB50(ctx, base);
	// 82EB3918: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB391C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3920: 40820048  bne 0x82eb3968
	if !ctx.cr[0].eq {
	pc = 0x82EB3968; continue 'dispatch;
	}
	// 82EB3924: 4BA5A3E5  bl 0x8290dd08
	ctx.lr = 0x82EB3928;
	sub_8290DD08(ctx, base);
	// 82EB3928: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB392C: 4182FE28  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3930: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3934: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3938: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB393C: 4182000C  beq 0x82eb3948
	if ctx.cr[0].eq {
	pc = 0x82EB3948; continue 'dispatch;
	}
	// 82EB3940: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3944: 4800000C  b 0x82eb3950
	pc = 0x82EB3950; continue 'dispatch;
            }
            0x82EB3948 => {
    //   block [0x82EB3948..0x82EB3950)
	// 82EB3948: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB394C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EB3950; continue 'dispatch;
            }
            0x82EB3950 => {
    //   block [0x82EB3950..0x82EB3968)
	// 82EB3950: 4BDF8261  bl 0x82cabbb0
	ctx.lr = 0x82EB3954;
	sub_82CABBB0(ctx, base);
	// 82EB3954: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3958: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB395C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3960: D01D0040  stfs f0, 0x40(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EB3964: 480008F4  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3968 => {
    //   block [0x82EB3968..0x82EB39AC)
	// 82EB3968: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB396C: 3BCBA638  addi r30, r11, -0x59c8
	ctx.r[30].s64 = ctx.r[11].s64 + -22984;
	// 82EB3970: 483086F1  bl 0x831bc060
	ctx.lr = 0x82EB3974;
	sub_831BC060(ctx, base);
	// 82EB3974: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3978: 4BDF91D9  bl 0x82cacb50
	ctx.lr = 0x82EB397C;
	sub_82CACB50(ctx, base);
	// 82EB397C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3984: 40820048  bne 0x82eb39cc
	if !ctx.cr[0].eq {
	pc = 0x82EB39CC; continue 'dispatch;
	}
	// 82EB3988: 4BA5A381  bl 0x8290dd08
	ctx.lr = 0x82EB398C;
	sub_8290DD08(ctx, base);
	// 82EB398C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3990: 4182FDC4  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3994: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3998: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB399C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB39A0: 4182000C  beq 0x82eb39ac
	if ctx.cr[0].eq {
	pc = 0x82EB39AC; continue 'dispatch;
	}
	// 82EB39A4: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB39A8: 4800000C  b 0x82eb39b4
	pc = 0x82EB39B4; continue 'dispatch;
            }
            0x82EB39AC => {
    //   block [0x82EB39AC..0x82EB39B4)
	// 82EB39AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB39B0: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EB39B4; continue 'dispatch;
            }
            0x82EB39B4 => {
    //   block [0x82EB39B4..0x82EB39CC)
	// 82EB39B4: 4BDF81FD  bl 0x82cabbb0
	ctx.lr = 0x82EB39B8;
	sub_82CABBB0(ctx, base);
	// 82EB39B8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB39BC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB39C0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB39C4: D01D003C  stfs f0, 0x3c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82EB39C8: 48000890  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB39CC => {
    //   block [0x82EB39CC..0x82EB3A10)
	// 82EB39CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB39D0: 3BCBA628  addi r30, r11, -0x59d8
	ctx.r[30].s64 = ctx.r[11].s64 + -23000;
	// 82EB39D4: 4830868D  bl 0x831bc060
	ctx.lr = 0x82EB39D8;
	sub_831BC060(ctx, base);
	// 82EB39D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB39DC: 4BDF9175  bl 0x82cacb50
	ctx.lr = 0x82EB39E0;
	sub_82CACB50(ctx, base);
	// 82EB39E0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB39E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB39E8: 40820048  bne 0x82eb3a30
	if !ctx.cr[0].eq {
	pc = 0x82EB3A30; continue 'dispatch;
	}
	// 82EB39EC: 4BA5A31D  bl 0x8290dd08
	ctx.lr = 0x82EB39F0;
	sub_8290DD08(ctx, base);
	// 82EB39F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB39F4: 4182FD60  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB39F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB39FC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3A00: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3A04: 4182000C  beq 0x82eb3a10
	if ctx.cr[0].eq {
	pc = 0x82EB3A10; continue 'dispatch;
	}
	// 82EB3A08: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3A0C: 4800000C  b 0x82eb3a18
	pc = 0x82EB3A18; continue 'dispatch;
            }
            0x82EB3A10 => {
    //   block [0x82EB3A10..0x82EB3A18)
	// 82EB3A10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3A14: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EB3A18; continue 'dispatch;
            }
            0x82EB3A18 => {
    //   block [0x82EB3A18..0x82EB3A30)
	// 82EB3A18: 4BDF8199  bl 0x82cabbb0
	ctx.lr = 0x82EB3A1C;
	sub_82CABBB0(ctx, base);
	// 82EB3A1C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3A20: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3A24: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3A28: D01D0044  stfs f0, 0x44(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EB3A2C: 4800082C  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3A30 => {
    //   block [0x82EB3A30..0x82EB3A74)
	// 82EB3A30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3A34: 3BCBA618  addi r30, r11, -0x59e8
	ctx.r[30].s64 = ctx.r[11].s64 + -23016;
	// 82EB3A38: 48308629  bl 0x831bc060
	ctx.lr = 0x82EB3A3C;
	sub_831BC060(ctx, base);
	// 82EB3A3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3A40: 4BDF9111  bl 0x82cacb50
	ctx.lr = 0x82EB3A44;
	sub_82CACB50(ctx, base);
	// 82EB3A44: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3A48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3A4C: 40820048  bne 0x82eb3a94
	if !ctx.cr[0].eq {
	pc = 0x82EB3A94; continue 'dispatch;
	}
	// 82EB3A50: 4BA5A2B9  bl 0x8290dd08
	ctx.lr = 0x82EB3A54;
	sub_8290DD08(ctx, base);
	// 82EB3A54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3A58: 4182FCFC  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3A5C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3A60: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3A64: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3A68: 4182000C  beq 0x82eb3a74
	if ctx.cr[0].eq {
	pc = 0x82EB3A74; continue 'dispatch;
	}
	// 82EB3A6C: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3A70: 4800000C  b 0x82eb3a7c
	pc = 0x82EB3A7C; continue 'dispatch;
            }
            0x82EB3A74 => {
    //   block [0x82EB3A74..0x82EB3A7C)
	// 82EB3A74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3A78: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EB3A7C; continue 'dispatch;
            }
            0x82EB3A7C => {
    //   block [0x82EB3A7C..0x82EB3A94)
	// 82EB3A7C: 4BDF8135  bl 0x82cabbb0
	ctx.lr = 0x82EB3A80;
	sub_82CABBB0(ctx, base);
	// 82EB3A80: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3A84: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3A88: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3A8C: D01D004C  stfs f0, 0x4c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EB3A90: 480007C8  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3A94 => {
    //   block [0x82EB3A94..0x82EB3AE0)
	// 82EB3A94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3A98: 3BCBA608  addi r30, r11, -0x59f8
	ctx.r[30].s64 = ctx.r[11].s64 + -23032;
	// 82EB3A9C: 483085C5  bl 0x831bc060
	ctx.lr = 0x82EB3AA0;
	sub_831BC060(ctx, base);
	// 82EB3AA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3AA4: 4BDF90AD  bl 0x82cacb50
	ctx.lr = 0x82EB3AA8;
	sub_82CACB50(ctx, base);
	// 82EB3AA8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3AAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3AB0: 40820044  bne 0x82eb3af4
	if !ctx.cr[0].eq {
	pc = 0x82EB3AF4; continue 'dispatch;
	}
	// 82EB3AB4: 4BA5A255  bl 0x8290dd08
	ctx.lr = 0x82EB3AB8;
	sub_8290DD08(ctx, base);
	// 82EB3AB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3ABC: 4182FC98  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3AC0: 4BDF80F1  bl 0x82cabbb0
	ctx.lr = 0x82EB3AC4;
	sub_82CABBB0(ctx, base);
	// 82EB3AC4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3AC8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3ACC: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB3AD0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB3AD4: 4099000C  ble cr6, 0x82eb3ae0
	if !ctx.cr[6].gt {
	pc = 0x82EB3AE0; continue 'dispatch;
	}
	// 82EB3AD8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB3ADC: 4800000C  b 0x82eb3ae8
	pc = 0x82EB3AE8; continue 'dispatch;
            }
            0x82EB3AE0 => {
    //   block [0x82EB3AE0..0x82EB3AE8)
	// 82EB3AE0: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB3AE4: FC00682E  fsel f0, f0, f0, f13
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	pc = 0x82EB3AE8; continue 'dispatch;
            }
            0x82EB3AE8 => {
    //   block [0x82EB3AE8..0x82EB3AF4)
	// 82EB3AE8: D01D0050  stfs f0, 0x50(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB3AEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3AF0: 48000768  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3AF4 => {
    //   block [0x82EB3AF4..0x82EB3B34)
	// 82EB3AF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3AF8: 3BCBA5F8  addi r30, r11, -0x5a08
	ctx.r[30].s64 = ctx.r[11].s64 + -23048;
	// 82EB3AFC: 48308565  bl 0x831bc060
	ctx.lr = 0x82EB3B00;
	sub_831BC060(ctx, base);
	// 82EB3B00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3B04: 4BDF904D  bl 0x82cacb50
	ctx.lr = 0x82EB3B08;
	sub_82CACB50(ctx, base);
	// 82EB3B08: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3B0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3B10: 40820024  bne 0x82eb3b34
	if !ctx.cr[0].eq {
	pc = 0x82EB3B34; continue 'dispatch;
	}
	// 82EB3B14: 4BA5A1F5  bl 0x8290dd08
	ctx.lr = 0x82EB3B18;
	sub_8290DD08(ctx, base);
	// 82EB3B18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3B1C: 4182FC38  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3B20: 4BDF68A1  bl 0x82caa3c0
	ctx.lr = 0x82EB3B24;
	sub_82CAA3C0(ctx, base);
	// 82EB3B24: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB3B28: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3B2C: 917D0054  stw r11, 0x54(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB3B30: 48000728  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3B34 => {
    //   block [0x82EB3B34..0x82EB3B78)
	// 82EB3B34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3B38: 3BCBA5EC  addi r30, r11, -0x5a14
	ctx.r[30].s64 = ctx.r[11].s64 + -23060;
	// 82EB3B3C: 48308525  bl 0x831bc060
	ctx.lr = 0x82EB3B40;
	sub_831BC060(ctx, base);
	// 82EB3B40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3B44: 4BDF900D  bl 0x82cacb50
	ctx.lr = 0x82EB3B48;
	sub_82CACB50(ctx, base);
	// 82EB3B48: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3B50: 40820048  bne 0x82eb3b98
	if !ctx.cr[0].eq {
	pc = 0x82EB3B98; continue 'dispatch;
	}
	// 82EB3B54: 4BA5A1B5  bl 0x8290dd08
	ctx.lr = 0x82EB3B58;
	sub_8290DD08(ctx, base);
	// 82EB3B58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3B5C: 4182FBF8  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3B60: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3B64: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3B68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3B6C: 4182000C  beq 0x82eb3b78
	if ctx.cr[0].eq {
	pc = 0x82EB3B78; continue 'dispatch;
	}
	// 82EB3B70: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3B74: 4800000C  b 0x82eb3b80
	pc = 0x82EB3B80; continue 'dispatch;
            }
            0x82EB3B78 => {
    //   block [0x82EB3B78..0x82EB3B80)
	// 82EB3B78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3B7C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EB3B80; continue 'dispatch;
            }
            0x82EB3B80 => {
    //   block [0x82EB3B80..0x82EB3B98)
	// 82EB3B80: 4BDF8031  bl 0x82cabbb0
	ctx.lr = 0x82EB3B84;
	sub_82CABBB0(ctx, base);
	// 82EB3B84: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3B88: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3B8C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3B90: D01D0058  stfs f0, 0x58(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB3B94: 480006C4  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3B98 => {
    //   block [0x82EB3B98..0x82EB3BD8)
	// 82EB3B98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3B9C: 3BCBA5D0  addi r30, r11, -0x5a30
	ctx.r[30].s64 = ctx.r[11].s64 + -23088;
	// 82EB3BA0: 483084C1  bl 0x831bc060
	ctx.lr = 0x82EB3BA4;
	sub_831BC060(ctx, base);
	// 82EB3BA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3BA8: 4BDF8FA9  bl 0x82cacb50
	ctx.lr = 0x82EB3BAC;
	sub_82CACB50(ctx, base);
	// 82EB3BAC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3BB4: 40820024  bne 0x82eb3bd8
	if !ctx.cr[0].eq {
	pc = 0x82EB3BD8; continue 'dispatch;
	}
	// 82EB3BB8: 4BA5A151  bl 0x8290dd08
	ctx.lr = 0x82EB3BBC;
	sub_8290DD08(ctx, base);
	// 82EB3BBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3BC0: 4182FB94  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3BC4: 4BDF7FED  bl 0x82cabbb0
	ctx.lr = 0x82EB3BC8;
	sub_82CABBB0(ctx, base);
	// 82EB3BC8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3BCC: D01D0060  stfs f0, 0x60(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB3BD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3BD4: 48000684  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3BD8 => {
    //   block [0x82EB3BD8..0x82EB3C1C)
	// 82EB3BD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3BDC: 3BCBA5C0  addi r30, r11, -0x5a40
	ctx.r[30].s64 = ctx.r[11].s64 + -23104;
	// 82EB3BE0: 48308481  bl 0x831bc060
	ctx.lr = 0x82EB3BE4;
	sub_831BC060(ctx, base);
	// 82EB3BE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3BE8: 4BDF8F69  bl 0x82cacb50
	ctx.lr = 0x82EB3BEC;
	sub_82CACB50(ctx, base);
	// 82EB3BEC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3BF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3BF4: 40820048  bne 0x82eb3c3c
	if !ctx.cr[0].eq {
	pc = 0x82EB3C3C; continue 'dispatch;
	}
	// 82EB3BF8: 4BA5A111  bl 0x8290dd08
	ctx.lr = 0x82EB3BFC;
	sub_8290DD08(ctx, base);
	// 82EB3BFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3C00: 4182FB54  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3C04: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3C08: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3C0C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3C10: 4182000C  beq 0x82eb3c1c
	if ctx.cr[0].eq {
	pc = 0x82EB3C1C; continue 'dispatch;
	}
	// 82EB3C14: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3C18: 4800000C  b 0x82eb3c24
	pc = 0x82EB3C24; continue 'dispatch;
            }
            0x82EB3C1C => {
    //   block [0x82EB3C1C..0x82EB3C24)
	// 82EB3C1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3C20: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EB3C24; continue 'dispatch;
            }
            0x82EB3C24 => {
    //   block [0x82EB3C24..0x82EB3C3C)
	// 82EB3C24: 4BDF7F8D  bl 0x82cabbb0
	ctx.lr = 0x82EB3C28;
	sub_82CABBB0(ctx, base);
	// 82EB3C28: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3C2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3C30: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3C34: D01D005C  stfs f0, 0x5c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB3C38: 48000620  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3C3C => {
    //   block [0x82EB3C3C..0x82EB3C8C)
	// 82EB3C3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3C40: 3BCBA5B4  addi r30, r11, -0x5a4c
	ctx.r[30].s64 = ctx.r[11].s64 + -23116;
	// 82EB3C44: 4830841D  bl 0x831bc060
	ctx.lr = 0x82EB3C48;
	sub_831BC060(ctx, base);
	// 82EB3C48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3C4C: 4BDF8F05  bl 0x82cacb50
	ctx.lr = 0x82EB3C50;
	sub_82CACB50(ctx, base);
	// 82EB3C50: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3C58: 40820060  bne 0x82eb3cb8
	if !ctx.cr[0].eq {
	pc = 0x82EB3CB8; continue 'dispatch;
	}
	// 82EB3C5C: 4BA5A0AD  bl 0x8290dd08
	ctx.lr = 0x82EB3C60;
	sub_8290DD08(ctx, base);
	// 82EB3C60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3C64: 4182FAF0  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3C68: 4BDF7F49  bl 0x82cabbb0
	ctx.lr = 0x82EB3C6C;
	sub_82CABBB0(ctx, base);
	// 82EB3C6C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3C70: D01D0064  stfs f0, 0x64(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB3C74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3C78: 4BFD1D79  bl 0x82e859f0
	ctx.lr = 0x82EB3C7C;
	sub_82E859F0(ctx, base);
	// 82EB3C7C: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB3C80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3C84: 4099FC14  ble cr6, 0x82eb3898
	if !ctx.cr[6].gt {
	pc = 0x82EB3898; continue 'dispatch;
	}
	// 82EB3C88: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82EB3C8C; continue 'dispatch;
            }
            0x82EB3C8C => {
    //   block [0x82EB3C8C..0x82EB3CB8)
	// 82EB3C8C: 817D01AC  lwz r11, 0x1ac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB3C90: C01D0064  lfs f0, 0x64(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3C94: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3C98: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EB3C9C: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 82EB3CA0: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB3CA4: 4BFD1D4D  bl 0x82e859f0
	ctx.lr = 0x82EB3CA8;
	sub_82E859F0(ctx, base);
	// 82EB3CA8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB3CAC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3CB0: 4198FFDC  blt cr6, 0x82eb3c8c
	if ctx.cr[6].lt {
	pc = 0x82EB3C8C; continue 'dispatch;
	}
	// 82EB3CB4: 4BFFFBE4  b 0x82eb3898
	pc = 0x82EB3898; continue 'dispatch;
            }
            0x82EB3CB8 => {
    //   block [0x82EB3CB8..0x82EB3D04)
	// 82EB3CB8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3CBC: 3BCBA5A4  addi r30, r11, -0x5a5c
	ctx.r[30].s64 = ctx.r[11].s64 + -23132;
	// 82EB3CC0: 483083A1  bl 0x831bc060
	ctx.lr = 0x82EB3CC4;
	sub_831BC060(ctx, base);
	// 82EB3CC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3CC8: 4BDF8E89  bl 0x82cacb50
	ctx.lr = 0x82EB3CCC;
	sub_82CACB50(ctx, base);
	// 82EB3CCC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3CD4: 40820030  bne 0x82eb3d04
	if !ctx.cr[0].eq {
	pc = 0x82EB3D04; continue 'dispatch;
	}
	// 82EB3CD8: 4BA5A031  bl 0x8290dd08
	ctx.lr = 0x82EB3CDC;
	sub_8290DD08(ctx, base);
	// 82EB3CDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3CE0: 4182FA74  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3CE4: 4BDF66DD  bl 0x82caa3c0
	ctx.lr = 0x82EB3CE8;
	sub_82CAA3C0(ctx, base);
	// 82EB3CE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB3CEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3CF0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB3CF4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB3CF8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82EB3CFC: 997D0068  stb r11, 0x68(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 82EB3D00: 48000558  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3D04 => {
    //   block [0x82EB3D04..0x82EB3D48)
	// 82EB3D04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3D08: 3BCBA594  addi r30, r11, -0x5a6c
	ctx.r[30].s64 = ctx.r[11].s64 + -23148;
	// 82EB3D0C: 48308355  bl 0x831bc060
	ctx.lr = 0x82EB3D10;
	sub_831BC060(ctx, base);
	// 82EB3D10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3D14: 4BDF8E3D  bl 0x82cacb50
	ctx.lr = 0x82EB3D18;
	sub_82CACB50(ctx, base);
	// 82EB3D18: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3D1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3D20: 4082004C  bne 0x82eb3d6c
	if !ctx.cr[0].eq {
	pc = 0x82EB3D6C; continue 'dispatch;
	}
	// 82EB3D24: 4BA59FE5  bl 0x8290dd08
	ctx.lr = 0x82EB3D28;
	sub_8290DD08(ctx, base);
	// 82EB3D28: 4BFFEB39  bl 0x82eb2860
	ctx.lr = 0x82EB3D2C;
	sub_82EB2860(ctx, base);
	// 82EB3D2C: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3D30: 40820030  bne 0x82eb3d60
	if !ctx.cr[0].eq {
	pc = 0x82EB3D60; continue 'dispatch;
	}
	// 82EB3D34: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3D38: 4B77A751  bl 0x8262e488
	ctx.lr = 0x82EB3D3C;
	sub_8262E488(ctx, base);
	// 82EB3D3C: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3D40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3D44: 4099FA10  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	pc = 0x82EB3D48; continue 'dispatch;
            }
            0x82EB3D48 => {
    //   block [0x82EB3D48..0x82EB3D60)
	// 82EB3D48: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3D4C: 4B77A73D  bl 0x8262e488
	ctx.lr = 0x82EB3D50;
	sub_8262E488(ctx, base);
	// 82EB3D50: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3D54: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3D58: 4198FFF0  blt cr6, 0x82eb3d48
	if ctx.cr[6].lt {
	pc = 0x82EB3D48; continue 'dispatch;
	}
	// 82EB3D5C: 4BFFF9F8  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
            }
            0x82EB3D60 => {
    //   block [0x82EB3D60..0x82EB3D6C)
	// 82EB3D60: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3D64: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82EB3D68: 480004F0  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3D6C => {
    //   block [0x82EB3D6C..0x82EB3DB0)
	// 82EB3D6C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3D70: 3BCBA588  addi r30, r11, -0x5a78
	ctx.r[30].s64 = ctx.r[11].s64 + -23160;
	// 82EB3D74: 483082ED  bl 0x831bc060
	ctx.lr = 0x82EB3D78;
	sub_831BC060(ctx, base);
	// 82EB3D78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3D7C: 4BDF8DD5  bl 0x82cacb50
	ctx.lr = 0x82EB3D80;
	sub_82CACB50(ctx, base);
	// 82EB3D80: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3D84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3D88: 4082004C  bne 0x82eb3dd4
	if !ctx.cr[0].eq {
	pc = 0x82EB3DD4; continue 'dispatch;
	}
	// 82EB3D8C: 4BA59F7D  bl 0x8290dd08
	ctx.lr = 0x82EB3D90;
	sub_8290DD08(ctx, base);
	// 82EB3D90: 4BFFEB91  bl 0x82eb2920
	ctx.lr = 0x82EB3D94;
	sub_82EB2920(ctx, base);
	// 82EB3D94: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3D98: 40820030  bne 0x82eb3dc8
	if !ctx.cr[0].eq {
	pc = 0x82EB3DC8; continue 'dispatch;
	}
	// 82EB3D9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3DA0: 4B77A781  bl 0x8262e520
	ctx.lr = 0x82EB3DA4;
	sub_8262E520(ctx, base);
	// 82EB3DA4: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3DA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3DAC: 4099F9A8  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	pc = 0x82EB3DB0; continue 'dispatch;
            }
            0x82EB3DB0 => {
    //   block [0x82EB3DB0..0x82EB3DC8)
	// 82EB3DB0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3DB4: 4B77A76D  bl 0x8262e520
	ctx.lr = 0x82EB3DB8;
	sub_8262E520(ctx, base);
	// 82EB3DB8: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3DBC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3DC0: 4198FFF0  blt cr6, 0x82eb3db0
	if ctx.cr[6].lt {
	pc = 0x82EB3DB0; continue 'dispatch;
	}
	// 82EB3DC4: 4BFFF990  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
            }
            0x82EB3DC8 => {
    //   block [0x82EB3DC8..0x82EB3DD4)
	// 82EB3DC8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3DCC: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EB3DD0: 48000488  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3DD4 => {
    //   block [0x82EB3DD4..0x82EB3E18)
	// 82EB3DD4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3DD8: 3BCBA578  addi r30, r11, -0x5a88
	ctx.r[30].s64 = ctx.r[11].s64 + -23176;
	// 82EB3DDC: 48308285  bl 0x831bc060
	ctx.lr = 0x82EB3DE0;
	sub_831BC060(ctx, base);
	// 82EB3DE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3DE4: 4BDF8D6D  bl 0x82cacb50
	ctx.lr = 0x82EB3DE8;
	sub_82CACB50(ctx, base);
	// 82EB3DE8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3DEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3DF0: 4082004C  bne 0x82eb3e3c
	if !ctx.cr[0].eq {
	pc = 0x82EB3E3C; continue 'dispatch;
	}
	// 82EB3DF4: 4BA59F15  bl 0x8290dd08
	ctx.lr = 0x82EB3DF8;
	sub_8290DD08(ctx, base);
	// 82EB3DF8: 4BFFECA9  bl 0x82eb2aa0
	ctx.lr = 0x82EB3DFC;
	sub_82EB2AA0(ctx, base);
	// 82EB3DFC: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3E00: 40820030  bne 0x82eb3e30
	if !ctx.cr[0].eq {
	pc = 0x82EB3E30; continue 'dispatch;
	}
	// 82EB3E04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3E08: 4BFFE9E1  bl 0x82eb27e8
	ctx.lr = 0x82EB3E0C;
	sub_82EB27E8(ctx, base);
	// 82EB3E0C: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3E10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3E14: 4099F940  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	pc = 0x82EB3E18; continue 'dispatch;
            }
            0x82EB3E18 => {
    //   block [0x82EB3E18..0x82EB3E30)
	// 82EB3E18: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3E1C: 4BFFE9CD  bl 0x82eb27e8
	ctx.lr = 0x82EB3E20;
	sub_82EB27E8(ctx, base);
	// 82EB3E20: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3E24: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3E28: 4198FFF0  blt cr6, 0x82eb3e18
	if ctx.cr[6].lt {
	pc = 0x82EB3E18; continue 'dispatch;
	}
	// 82EB3E2C: 4BFFF928  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
            }
            0x82EB3E30 => {
    //   block [0x82EB3E30..0x82EB3E3C)
	// 82EB3E30: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3E34: 917D00B0  stw r11, 0xb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EB3E38: 48000420  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3E3C => {
    //   block [0x82EB3E3C..0x82EB3E80)
	// 82EB3E3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3E40: 3BCBA56C  addi r30, r11, -0x5a94
	ctx.r[30].s64 = ctx.r[11].s64 + -23188;
	// 82EB3E44: 4830821D  bl 0x831bc060
	ctx.lr = 0x82EB3E48;
	sub_831BC060(ctx, base);
	// 82EB3E48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3E4C: 4BDF8D05  bl 0x82cacb50
	ctx.lr = 0x82EB3E50;
	sub_82CACB50(ctx, base);
	// 82EB3E50: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3E58: 4082004C  bne 0x82eb3ea4
	if !ctx.cr[0].eq {
	pc = 0x82EB3EA4; continue 'dispatch;
	}
	// 82EB3E5C: 4BA59EAD  bl 0x8290dd08
	ctx.lr = 0x82EB3E60;
	sub_8290DD08(ctx, base);
	// 82EB3E60: 4BFFED01  bl 0x82eb2b60
	ctx.lr = 0x82EB3E64;
	sub_82EB2B60(ctx, base);
	// 82EB3E64: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3E68: 40820030  bne 0x82eb3e98
	if !ctx.cr[0].eq {
	pc = 0x82EB3E98; continue 'dispatch;
	}
	// 82EB3E6C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3E70: 4B77A879  bl 0x8262e6e8
	ctx.lr = 0x82EB3E74;
	sub_8262E6E8(ctx, base);
	// 82EB3E74: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3E78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3E7C: 4099F8D8  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	pc = 0x82EB3E80; continue 'dispatch;
            }
            0x82EB3E80 => {
    //   block [0x82EB3E80..0x82EB3E98)
	// 82EB3E80: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3E84: 4B77A865  bl 0x8262e6e8
	ctx.lr = 0x82EB3E88;
	sub_8262E6E8(ctx, base);
	// 82EB3E88: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3E8C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3E90: 4198FFF0  blt cr6, 0x82eb3e80
	if ctx.cr[6].lt {
	pc = 0x82EB3E80; continue 'dispatch;
	}
	// 82EB3E94: 4BFFF8C0  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
            }
            0x82EB3E98 => {
    //   block [0x82EB3E98..0x82EB3EA4)
	// 82EB3E98: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3E9C: 917D00B4  stw r11, 0xb4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82EB3EA0: 480003B8  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3EA4 => {
    //   block [0x82EB3EA4..0x82EB3EE8)
	// 82EB3EA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3EA8: 3BCBA560  addi r30, r11, -0x5aa0
	ctx.r[30].s64 = ctx.r[11].s64 + -23200;
	// 82EB3EAC: 483081B5  bl 0x831bc060
	ctx.lr = 0x82EB3EB0;
	sub_831BC060(ctx, base);
	// 82EB3EB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3EB4: 4BDF8C9D  bl 0x82cacb50
	ctx.lr = 0x82EB3EB8;
	sub_82CACB50(ctx, base);
	// 82EB3EB8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3EC0: 4082004C  bne 0x82eb3f0c
	if !ctx.cr[0].eq {
	pc = 0x82EB3F0C; continue 'dispatch;
	}
	// 82EB3EC4: 4BA59E45  bl 0x8290dd08
	ctx.lr = 0x82EB3EC8;
	sub_8290DD08(ctx, base);
	// 82EB3EC8: 4BFFEC99  bl 0x82eb2b60
	ctx.lr = 0x82EB3ECC;
	sub_82EB2B60(ctx, base);
	// 82EB3ECC: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3ED0: 40820030  bne 0x82eb3f00
	if !ctx.cr[0].eq {
	pc = 0x82EB3F00; continue 'dispatch;
	}
	// 82EB3ED4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3ED8: 4B77A811  bl 0x8262e6e8
	ctx.lr = 0x82EB3EDC;
	sub_8262E6E8(ctx, base);
	// 82EB3EDC: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3EE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3EE4: 4099F870  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	pc = 0x82EB3EE8; continue 'dispatch;
            }
            0x82EB3EE8 => {
    //   block [0x82EB3EE8..0x82EB3F00)
	// 82EB3EE8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3EEC: 4B77A7FD  bl 0x8262e6e8
	ctx.lr = 0x82EB3EF0;
	sub_8262E6E8(ctx, base);
	// 82EB3EF0: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3EF4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3EF8: 4198FFF0  blt cr6, 0x82eb3ee8
	if ctx.cr[6].lt {
	pc = 0x82EB3EE8; continue 'dispatch;
	}
	// 82EB3EFC: 4BFFF858  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
            }
            0x82EB3F00 => {
    //   block [0x82EB3F00..0x82EB3F0C)
	// 82EB3F00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3F04: 917D00B8  stw r11, 0xb8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82EB3F08: 48000350  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3F0C => {
    //   block [0x82EB3F0C..0x82EB3F50)
	// 82EB3F0C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3F10: 3BCBA548  addi r30, r11, -0x5ab8
	ctx.r[30].s64 = ctx.r[11].s64 + -23224;
	// 82EB3F14: 4830814D  bl 0x831bc060
	ctx.lr = 0x82EB3F18;
	sub_831BC060(ctx, base);
	// 82EB3F18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3F1C: 4BDF8C35  bl 0x82cacb50
	ctx.lr = 0x82EB3F20;
	sub_82CACB50(ctx, base);
	// 82EB3F20: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3F28: 4082004C  bne 0x82eb3f74
	if !ctx.cr[0].eq {
	pc = 0x82EB3F74; continue 'dispatch;
	}
	// 82EB3F2C: 4BA59DDD  bl 0x8290dd08
	ctx.lr = 0x82EB3F30;
	sub_8290DD08(ctx, base);
	// 82EB3F30: 4BFFEDB1  bl 0x82eb2ce0
	ctx.lr = 0x82EB3F34;
	sub_82EB2CE0(ctx, base);
	// 82EB3F34: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3F38: 40820030  bne 0x82eb3f68
	if !ctx.cr[0].eq {
	pc = 0x82EB3F68; continue 'dispatch;
	}
	// 82EB3F3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3F40: 4B77A711  bl 0x8262e650
	ctx.lr = 0x82EB3F44;
	sub_8262E650(ctx, base);
	// 82EB3F44: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3F48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3F4C: 4099F808  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	pc = 0x82EB3F50; continue 'dispatch;
            }
            0x82EB3F50 => {
    //   block [0x82EB3F50..0x82EB3F68)
	// 82EB3F50: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3F54: 4B77A6FD  bl 0x8262e650
	ctx.lr = 0x82EB3F58;
	sub_8262E650(ctx, base);
	// 82EB3F58: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3F5C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3F60: 4198FFF0  blt cr6, 0x82eb3f50
	if ctx.cr[6].lt {
	pc = 0x82EB3F50; continue 'dispatch;
	}
	// 82EB3F64: 4BFFF7F0  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
            }
            0x82EB3F68 => {
    //   block [0x82EB3F68..0x82EB3F74)
	// 82EB3F68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3F6C: 917D00AC  stw r11, 0xac(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82EB3F70: 480002E8  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3F74 => {
    //   block [0x82EB3F74..0x82EB3FB8)
	// 82EB3F74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3F78: 3BCBA53C  addi r30, r11, -0x5ac4
	ctx.r[30].s64 = ctx.r[11].s64 + -23236;
	// 82EB3F7C: 483080E5  bl 0x831bc060
	ctx.lr = 0x82EB3F80;
	sub_831BC060(ctx, base);
	// 82EB3F80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3F84: 4BDF8BCD  bl 0x82cacb50
	ctx.lr = 0x82EB3F88;
	sub_82CACB50(ctx, base);
	// 82EB3F88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3F8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3F90: 4082004C  bne 0x82eb3fdc
	if !ctx.cr[0].eq {
	pc = 0x82EB3FDC; continue 'dispatch;
	}
	// 82EB3F94: 4BA59D75  bl 0x8290dd08
	ctx.lr = 0x82EB3F98;
	sub_8290DD08(ctx, base);
	// 82EB3F98: 4BFFEC89  bl 0x82eb2c20
	ctx.lr = 0x82EB3F9C;
	sub_82EB2C20(ctx, base);
	// 82EB3F9C: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3FA0: 40820030  bne 0x82eb3fd0
	if !ctx.cr[0].eq {
	pc = 0x82EB3FD0; continue 'dispatch;
	}
	// 82EB3FA4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3FA8: 4B77A611  bl 0x8262e5b8
	ctx.lr = 0x82EB3FAC;
	sub_8262E5B8(ctx, base);
	// 82EB3FAC: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3FB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3FB4: 4099F7A0  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	pc = 0x82EB3FB8; continue 'dispatch;
            }
            0x82EB3FB8 => {
    //   block [0x82EB3FB8..0x82EB3FD0)
	// 82EB3FB8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3FBC: 4B77A5FD  bl 0x8262e5b8
	ctx.lr = 0x82EB3FC0;
	sub_8262E5B8(ctx, base);
	// 82EB3FC0: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3FC4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3FC8: 4198FFF0  blt cr6, 0x82eb3fb8
	if ctx.cr[6].lt {
	pc = 0x82EB3FB8; continue 'dispatch;
	}
	// 82EB3FCC: 4BFFF788  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
            }
            0x82EB3FD0 => {
    //   block [0x82EB3FD0..0x82EB3FDC)
	// 82EB3FD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3FD4: 917D00A8  stw r11, 0xa8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82EB3FD8: 48000280  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB3FDC => {
    //   block [0x82EB3FDC..0x82EB4020)
	// 82EB3FDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3FE0: 3BCBA534  addi r30, r11, -0x5acc
	ctx.r[30].s64 = ctx.r[11].s64 + -23244;
	// 82EB3FE4: 4830807D  bl 0x831bc060
	ctx.lr = 0x82EB3FE8;
	sub_831BC060(ctx, base);
	// 82EB3FE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3FEC: 4BDF8B65  bl 0x82cacb50
	ctx.lr = 0x82EB3FF0;
	sub_82CACB50(ctx, base);
	// 82EB3FF0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3FF8: 4082004C  bne 0x82eb4044
	if !ctx.cr[0].eq {
	pc = 0x82EB4044; continue 'dispatch;
	}
	// 82EB3FFC: 4BA59D0D  bl 0x8290dd08
	ctx.lr = 0x82EB4000;
	sub_8290DD08(ctx, base);
	// 82EB4000: 4BFFE9E1  bl 0x82eb29e0
	ctx.lr = 0x82EB4004;
	sub_82EB29E0(ctx, base);
	// 82EB4004: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4008: 40820030  bne 0x82eb4038
	if !ctx.cr[0].eq {
	pc = 0x82EB4038; continue 'dispatch;
	}
	// 82EB400C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB4010: 4BFFE761  bl 0x82eb2770
	ctx.lr = 0x82EB4014;
	sub_82EB2770(ctx, base);
	// 82EB4014: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB4018: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB401C: 4099F738  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	pc = 0x82EB4020; continue 'dispatch;
            }
            0x82EB4020 => {
    //   block [0x82EB4020..0x82EB4038)
	// 82EB4020: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB4024: 4BFFE74D  bl 0x82eb2770
	ctx.lr = 0x82EB4028;
	sub_82EB2770(ctx, base);
	// 82EB4028: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB402C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB4030: 4198FFF0  blt cr6, 0x82eb4020
	if ctx.cr[6].lt {
	pc = 0x82EB4020; continue 'dispatch;
	}
	// 82EB4034: 4BFFF720  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
            }
            0x82EB4038 => {
    //   block [0x82EB4038..0x82EB4044)
	// 82EB4038: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB403C: 917D00A4  stw r11, 0xa4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EB4040: 48000218  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB4044 => {
    //   block [0x82EB4044..0x82EB407C)
	// 82EB4044: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB4048: 3BCBA528  addi r30, r11, -0x5ad8
	ctx.r[30].s64 = ctx.r[11].s64 + -23256;
	// 82EB404C: 48308015  bl 0x831bc060
	ctx.lr = 0x82EB4050;
	sub_831BC060(ctx, base);
	// 82EB4050: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB4054: 4BDF8AFD  bl 0x82cacb50
	ctx.lr = 0x82EB4058;
	sub_82CACB50(ctx, base);
	// 82EB4058: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB405C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4060: 4082001C  bne 0x82eb407c
	if !ctx.cr[0].eq {
	pc = 0x82EB407C; continue 'dispatch;
	}
	// 82EB4064: 4BA59CA5  bl 0x8290dd08
	ctx.lr = 0x82EB4068;
	sub_8290DD08(ctx, base);
	// 82EB4068: 4BDF6359  bl 0x82caa3c0
	ctx.lr = 0x82EB406C;
	sub_82CAA3C0(ctx, base);
	// 82EB406C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EB4070: 387D0074  addi r3, r29, 0x74
	ctx.r[3].s64 = ctx.r[29].s64 + 116;
	// 82EB4074: 4BFDEFAD  bl 0x82e93020
	ctx.lr = 0x82EB4078;
	sub_82E93020(ctx, base);
	// 82EB4078: 4BFFF820  b 0x82eb3898
	pc = 0x82EB3898; continue 'dispatch;
            }
            0x82EB407C => {
    //   block [0x82EB407C..0x82EB40C0)
	// 82EB407C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB4080: 3BCBA518  addi r30, r11, -0x5ae8
	ctx.r[30].s64 = ctx.r[11].s64 + -23272;
	// 82EB4084: 48307FDD  bl 0x831bc060
	ctx.lr = 0x82EB4088;
	sub_831BC060(ctx, base);
	// 82EB4088: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB408C: 4BDF8AC5  bl 0x82cacb50
	ctx.lr = 0x82EB4090;
	sub_82CACB50(ctx, base);
	// 82EB4090: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB4094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4098: 40820084  bne 0x82eb411c
	if !ctx.cr[0].eq {
	pc = 0x82EB411C; continue 'dispatch;
	}
	// 82EB409C: 4BA59C6D  bl 0x8290dd08
	ctx.lr = 0x82EB40A0;
	sub_8290DD08(ctx, base);
	// 82EB40A0: 3FE08334  lis r31, -0x7ccc
	ctx.r[31].s64 = -2093744128;
	// 82EB40A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB40A8: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB40AC: C3CA0C14  lfs f30, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB40B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB40B4: 4182000C  beq 0x82eb40c0
	if ctx.cr[0].eq {
	pc = 0x82EB40C0; continue 'dispatch;
	}
	// 82EB40B8: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB40BC: 48000008  b 0x82eb40c4
	pc = 0x82EB40C4; continue 'dispatch;
            }
            0x82EB40C0 => {
    //   block [0x82EB40C0..0x82EB40C4)
	// 82EB40C0: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	pc = 0x82EB40C4; continue 'dispatch;
            }
            0x82EB40C4 => {
    //   block [0x82EB40C4..0x82EB40E4)
	// 82EB40C4: 4BDF7AED  bl 0x82cabbb0
	ctx.lr = 0x82EB40C8;
	sub_82CABBB0(ctx, base);
	// 82EB40C8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB40CC: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB40D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB40D4: ED8007F2  fmuls f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB40D8: 4182000C  beq 0x82eb40e4
	if ctx.cr[0].eq {
	pc = 0x82EB40E4; continue 'dispatch;
	}
	// 82EB40DC: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB40E0: 48000008  b 0x82eb40e8
	pc = 0x82EB40E8; continue 'dispatch;
            }
            0x82EB40E4 => {
    //   block [0x82EB40E4..0x82EB40E8)
	// 82EB40E4: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	pc = 0x82EB40E8; continue 'dispatch;
            }
            0x82EB40E8 => {
    //   block [0x82EB40E8..0x82EB4100)
	// 82EB40E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB40EC: C00B0AC8  lfs f0, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB40F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB40F4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB40F8: D01D01C4  stfs f0, 0x1c4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82EB40FC: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EB4100; continue 'dispatch;
            }
            0x82EB4100 => {
    //   block [0x82EB4100..0x82EB410C)
	// 82EB4100: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EB4104: 41980008  blt cr6, 0x82eb410c
	if ctx.cr[6].lt {
	pc = 0x82EB410C; continue 'dispatch;
	}
	// 82EB4108: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82EB410C; continue 'dispatch;
            }
            0x82EB410C => {
    //   block [0x82EB410C..0x82EB411C)
	// 82EB410C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EB4110: 409AFFF0  bne cr6, 0x82eb4100
	if !ctx.cr[6].eq {
	pc = 0x82EB4100; continue 'dispatch;
	}
	// 82EB4114: D01D01C4  stfs f0, 0x1c4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82EB4118: 4BFFF780  b 0x82eb3898
	pc = 0x82EB3898; continue 'dispatch;
            }
            0x82EB411C => {
    //   block [0x82EB411C..0x82EB41D0)
	// 82EB411C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB4120: 3BCBA504  addi r30, r11, -0x5afc
	ctx.r[30].s64 = ctx.r[11].s64 + -23292;
	// 82EB4124: 48307F3D  bl 0x831bc060
	ctx.lr = 0x82EB4128;
	sub_831BC060(ctx, base);
	// 82EB4128: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB412C: 4BDF8A25  bl 0x82cacb50
	ctx.lr = 0x82EB4130;
	sub_82CACB50(ctx, base);
	// 82EB4130: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB4134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4138: 408200AC  bne 0x82eb41e4
	if !ctx.cr[0].eq {
	pc = 0x82EB41E4; continue 'dispatch;
	}
	// 82EB413C: 4BA59BCD  bl 0x8290dd08
	ctx.lr = 0x82EB4140;
	sub_8290DD08(ctx, base);
	// 82EB4140: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EB4144: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB4148: 388B1694  addi r4, r11, 0x1694
	ctx.r[4].s64 = ctx.r[11].s64 + 5780;
	// 82EB414C: 4BDF8A05  bl 0x82cacb50
	ctx.lr = 0x82EB4150;
	sub_82CACB50(ctx, base);
	// 82EB4150: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB4154: 41820084  beq 0x82eb41d8
	if ctx.cr[0].eq {
	pc = 0x82EB41D8; continue 'dispatch;
	}
	// 82EB4158: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB415C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4160: 388B0F40  addi r4, r11, 0xf40
	ctx.r[4].s64 = ctx.r[11].s64 + 3904;
	// 82EB4164: 4BDF89ED  bl 0x82cacb50
	ctx.lr = 0x82EB4168;
	sub_82CACB50(ctx, base);
	// 82EB4168: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB416C: 4182006C  beq 0x82eb41d8
	if ctx.cr[0].eq {
	pc = 0x82EB41D8; continue 'dispatch;
	}
	// 82EB4170: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EB4174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4178: 388BD56C  addi r4, r11, -0x2a94
	ctx.r[4].s64 = ctx.r[11].s64 + -10900;
	// 82EB417C: 4BDF89D5  bl 0x82cacb50
	ctx.lr = 0x82EB4180;
	sub_82CACB50(ctx, base);
	// 82EB4180: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB4184: 41820054  beq 0x82eb41d8
	if ctx.cr[0].eq {
	pc = 0x82EB41D8; continue 'dispatch;
	}
	// 82EB4188: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EB418C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4190: 388B1698  addi r4, r11, 0x1698
	ctx.r[4].s64 = ctx.r[11].s64 + 5784;
	// 82EB4194: 4BDF89BD  bl 0x82cacb50
	ctx.lr = 0x82EB4198;
	sub_82CACB50(ctx, base);
	// 82EB4198: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB419C: 41820034  beq 0x82eb41d0
	if ctx.cr[0].eq {
	pc = 0x82EB41D0; continue 'dispatch;
	}
	// 82EB41A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EB41A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB41A8: 388B1700  addi r4, r11, 0x1700
	ctx.r[4].s64 = ctx.r[11].s64 + 5888;
	// 82EB41AC: 4BDF89A5  bl 0x82cacb50
	ctx.lr = 0x82EB41B0;
	sub_82CACB50(ctx, base);
	// 82EB41B0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB41B4: 4182001C  beq 0x82eb41d0
	if ctx.cr[0].eq {
	pc = 0x82EB41D0; continue 'dispatch;
	}
	// 82EB41B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EB41BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB41C0: 388B7088  addi r4, r11, 0x7088
	ctx.r[4].s64 = ctx.r[11].s64 + 28808;
	// 82EB41C4: 4BDF898D  bl 0x82cacb50
	ctx.lr = 0x82EB41C8;
	sub_82CACB50(ctx, base);
	// 82EB41C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB41CC: 4082F588  bne 0x82eb3754
	if !ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	pc = 0x82EB41D0; continue 'dispatch;
            }
            0x82EB41D0 => {
    //   block [0x82EB41D0..0x82EB41D8)
	// 82EB41D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB41D4: 48000008  b 0x82eb41dc
	pc = 0x82EB41DC; continue 'dispatch;
            }
            0x82EB41D8 => {
    //   block [0x82EB41D8..0x82EB41DC)
	// 82EB41D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EB41DC; continue 'dispatch;
            }
            0x82EB41DC => {
    //   block [0x82EB41DC..0x82EB41E4)
	// 82EB41DC: 997D0069  stb r11, 0x69(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 82EB41E0: 4BFFF6B8  b 0x82eb3898
	pc = 0x82EB3898; continue 'dispatch;
            }
            0x82EB41E4 => {
    //   block [0x82EB41E4..0x82EB424C)
	// 82EB41E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB41E8: 3BCBA4DC  addi r30, r11, -0x5b24
	ctx.r[30].s64 = ctx.r[11].s64 + -23332;
	// 82EB41EC: 48307E75  bl 0x831bc060
	ctx.lr = 0x82EB41F0;
	sub_831BC060(ctx, base);
	// 82EB41F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB41F4: 4BDF895D  bl 0x82cacb50
	ctx.lr = 0x82EB41F8;
	sub_82CACB50(ctx, base);
	// 82EB41F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB41FC: 4182F69C  beq 0x82eb3898
	if ctx.cr[0].eq {
	pc = 0x82EB3898; continue 'dispatch;
	}
	// 82EB4200: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB4204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4208: 3BCBA4F4  addi r30, r11, -0x5b0c
	ctx.r[30].s64 = ctx.r[11].s64 + -23308;
	// 82EB420C: 48307E55  bl 0x831bc060
	ctx.lr = 0x82EB4210;
	sub_831BC060(ctx, base);
	// 82EB4210: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB4214: 4BDF893D  bl 0x82cacb50
	ctx.lr = 0x82EB4218;
	sub_82CACB50(ctx, base);
	// 82EB4218: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB421C: 4182F67C  beq 0x82eb3898
	if ctx.cr[0].eq {
	pc = 0x82EB3898; continue 'dispatch;
	}
	// 82EB4220: 807D01B0  lwz r3, 0x1b0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB4224: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4228: 41820024  beq 0x82eb424c
	if ctx.cr[0].eq {
	pc = 0x82EB424C; continue 'dispatch;
	}
	// 82EB422C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4230: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB4234: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB4238: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB423C: 4E800421  bctrl
	ctx.lr = 0x82EB4240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4240: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB4244: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB4248: 419AF650  beq cr6, 0x82eb3898
	if ctx.cr[6].eq {
	pc = 0x82EB3898; continue 'dispatch;
	}
            }
            0x82EB424C => {
    //   block [0x82EB424C..0x82EB4258)
	// 82EB424C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB4250: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB4254: 4B7653E5  bl 0x82619638
	ctx.lr = 0x82EB4258;
	sub_82619638(ctx, base);
	pc = 0x82EB4258; continue 'dispatch;
            }
            0x82EB4258 => {
    //   block [0x82EB4258..0x82EB4268)
	// 82EB4258: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB425C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EB4260: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EB4264: 4BDF51F8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB4268 size=8
    let mut pc: u32 = 0x82EB4268;
    'dispatch: loop {
        match pc {
            0x82EB4268 => {
    //   block [0x82EB4268..0x82EB4270)
	// 82EB4268: 8063006C  lwz r3, 0x6c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB426C: 4BFDAAD4  b 0x82e8ed40
	sub_82E8ED40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB4270 size=112
    let mut pc: u32 = 0x82EB4270;
    'dispatch: loop {
        match pc {
            0x82EB4270 => {
    //   block [0x82EB4270..0x82EB42A4)
	// 82EB4270: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB4274: C00B00D8  lfs f0, 0xd8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4278: C1AB0044  lfs f13, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB427C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4280: 41990050  bgt cr6, 0x82eb42d0
	if ctx.cr[6].gt {
	pc = 0x82EB42D0; continue 'dispatch;
	}
	// 82EB4284: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EB4288: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB428C: 41980044  blt cr6, 0x82eb42d0
	if ctx.cr[6].lt {
	pc = 0x82EB42D0; continue 'dispatch;
	}
	// 82EB4290: 894B00C1  lbz r10, 0xc1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(193 as u32) ) } as u64;
	// 82EB4294: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4298: 4182000C  beq 0x82eb42a4
	if ctx.cr[0].eq {
	pc = 0x82EB42A4; continue 'dispatch;
	}
	// 82EB429C: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB42A0: 48000008  b 0x82eb42a8
	pc = 0x82EB42A8; continue 'dispatch;
            }
            0x82EB42A4 => {
    //   block [0x82EB42A4..0x82EB42A8)
	// 82EB42A4: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EB42A8; continue 'dispatch;
            }
            0x82EB42A8 => {
    //   block [0x82EB42A8..0x82EB42D0)
	// 82EB42A8: C1AB00DC  lfs f13, 0xdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB42AC: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB42B0: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB42B4: C00B00D4  lfs f0, 0xd4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB42B8: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB42BC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EB42C0: 41990010  bgt cr6, 0x82eb42d0
	if ctx.cr[6].gt {
	pc = 0x82EB42D0; continue 'dispatch;
	}
	// 82EB42C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB42C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB42CC: 4800000C  b 0x82eb42d8
	pc = 0x82EB42D8; continue 'dispatch;
            }
            0x82EB42D0 => {
    //   block [0x82EB42D0..0x82EB42D8)
	// 82EB42D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB42D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB42D8; continue 'dispatch;
            }
            0x82EB42D8 => {
    //   block [0x82EB42D8..0x82EB42E0)
	// 82EB42D8: 994B00C1  stb r10, 0xc1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(193 as u32), ctx.r[10].u8 ) };
	// 82EB42DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB42E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB42E0 size=28
    let mut pc: u32 = 0x82EB42E0;
    'dispatch: loop {
        match pc {
            0x82EB42E0 => {
    //   block [0x82EB42E0..0x82EB42FC)
	// 82EB42E0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB42E4: C0230044  lfs f1, 0x44(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB42E8: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82EB42EC: 8063006C  lwz r3, 0x6c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB42F0: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82EB42F4: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB42F8: 4BFDA290  b 0x82e8e588
	sub_82E8E588(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB4300 size=32
    let mut pc: u32 = 0x82EB4300;
    'dispatch: loop {
        match pc {
            0x82EB4300 => {
    //   block [0x82EB4300..0x82EB4320)
	// 82EB4300: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB4304: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82EB4308: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82EB430C: 814B0178  lwz r10, 0x178(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(376 as u32) ) } as u64;
	// 82EB4310: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4314: 4082000C  bne 0x82eb4320
	if !ctx.cr[0].eq {
		sub_82EB4320(ctx, base);
		return;
	}
	// 82EB4318: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB431C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB4320 size=24
    let mut pc: u32 = 0x82EB4320;
    'dispatch: loop {
        match pc {
            0x82EB4320 => {
    //   block [0x82EB4320..0x82EB4338)
	// 82EB4320: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4324: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EB4328: C02B0044  lfs f1, 0x44(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB432C: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82EB4330: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4334: 4BFDA334  b 0x82e8e668
	sub_82E8E668(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB4338 size=32
    let mut pc: u32 = 0x82EB4338;
    'dispatch: loop {
        match pc {
            0x82EB4338 => {
    //   block [0x82EB4338..0x82EB4358)
	// 82EB4338: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB433C: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82EB4340: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82EB4344: 814B0178  lwz r10, 0x178(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(376 as u32) ) } as u64;
	// 82EB4348: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB434C: 4082000C  bne 0x82eb4358
	if !ctx.cr[0].eq {
		sub_82EB4358(ctx, base);
		return;
	}
	// 82EB4350: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB4354: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB4358 size=24
    let mut pc: u32 = 0x82EB4358;
    'dispatch: loop {
        match pc {
            0x82EB4358 => {
    //   block [0x82EB4358..0x82EB4370)
	// 82EB4358: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB435C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EB4360: C02B0044  lfs f1, 0x44(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB4364: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82EB4368: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB436C: 4BFDA5C4  b 0x82e8e930
	sub_82E8E930(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB4370 size=448
    let mut pc: u32 = 0x82EB4370;
    'dispatch: loop {
        match pc {
            0x82EB4370 => {
    //   block [0x82EB4370..0x82EB43C0)
	// 82EB4370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB4378: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB437C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB4380: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4384: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB4388: 3BDF00F8  addi r30, r31, 0xf8
	ctx.r[30].s64 = ctx.r[31].s64 + 248;
	// 82EB438C: C01F00E0  lfs f0, 0xe0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4390: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4394: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB4398: 409A0028  bne cr6, 0x82eb43c0
	if !ctx.cr[6].eq {
	pc = 0x82EB43C0; continue 'dispatch;
	}
	// 82EB439C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB43A0: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB43A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB43A8: 409A0018  bne cr6, 0x82eb43c0
	if !ctx.cr[6].eq {
	pc = 0x82EB43C0; continue 'dispatch;
	}
	// 82EB43AC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB43B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB43B4: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB43B8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB43BC: 419A0008  beq cr6, 0x82eb43c4
	if ctx.cr[6].eq {
	pc = 0x82EB43C4; continue 'dispatch;
	}
	pc = 0x82EB43C0; continue 'dispatch;
            }
            0x82EB43C0 => {
    //   block [0x82EB43C0..0x82EB43C4)
	// 82EB43C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EB43C4; continue 'dispatch;
            }
            0x82EB43C4 => {
    //   block [0x82EB43C4..0x82EB4420)
	// 82EB43C4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB43C8: 4082014C  bne 0x82eb4514
	if !ctx.cr[0].eq {
	pc = 0x82EB4514; continue 'dispatch;
	}
	// 82EB43CC: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB43D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB43D4: 4182004C  beq 0x82eb4420
	if ctx.cr[0].eq {
	pc = 0x82EB4420; continue 'dispatch;
	}
	// 82EB43D8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB43DC: 419A0044  beq cr6, 0x82eb4420
	if ctx.cr[6].eq {
	pc = 0x82EB4420; continue 'dispatch;
	}
	// 82EB43E0: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB43E4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB43E8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB43EC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB43F0: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB43F4: 806BFFFC  lwz r3, -4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB43F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB43FC: 41820024  beq 0x82eb4420
	if ctx.cr[0].eq {
	pc = 0x82EB4420; continue 'dispatch;
	}
	// 82EB4400: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4404: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EB4408: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB440C: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EB4410: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4414: 4E800421  bctrl
	ctx.lr = 0x82EB4418;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4418: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB441C: 418200F8  beq 0x82eb4514
	if ctx.cr[0].eq {
	pc = 0x82EB4514; continue 'dispatch;
	}
            }
            0x82EB4420 => {
    //   block [0x82EB4420..0x82EB4440)
	// 82EB4420: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB4424: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB4428: 4BFDED61  bl 0x82e93188
	ctx.lr = 0x82EB442C;
	sub_82E93188(ctx, base);
	// 82EB442C: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB4430: 907F013C  stw r3, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[3].u32 ) };
	// 82EB4434: 409A000C  bne cr6, 0x82eb4440
	if !ctx.cr[6].eq {
	pc = 0x82EB4440; continue 'dispatch;
	}
	// 82EB4438: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB443C: 480000DC  b 0x82eb4518
	pc = 0x82EB4518; continue 'dispatch;
            }
            0x82EB4440 => {
    //   block [0x82EB4440..0x82EB44E0)
	// 82EB4440: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4444: 1D63000C  mulli r11, r3, 0xc
	ctx.r[11].s32 = ((ctx.r[3].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB4448: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB444C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4450: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4454: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4458: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB445C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4460: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4464: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4468: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB446C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4470: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4474: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4478: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB447C: C17F0118  lfs f11, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB4480: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4484: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB4488: C17F0038  lfs f11, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB448C: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB4490: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4494: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4498: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB449C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB44A0: 40980074  bge cr6, 0x82eb4514
	if !ctx.cr[6].lt {
	pc = 0x82EB4514; continue 'dispatch;
	}
	// 82EB44A4: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB44A8: 813F007C  lwz r9, 0x7c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB44AC: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EB44B0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB44B4: 4098002C  bge cr6, 0x82eb44e0
	if !ctx.cr[6].lt {
	pc = 0x82EB44E0; continue 'dispatch;
	}
	// 82EB44B8: 813F0088  lwz r9, 0x88(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB44BC: 1D6A000C  mulli r11, r10, 0xc
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB44C0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EB44C4: 915F013C  stw r10, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[10].u32 ) };
	// 82EB44C8: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB44CC: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB44D0: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB44D4: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB44D8: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB44DC: 48000018  b 0x82eb44f4
	pc = 0x82EB44F4; continue 'dispatch;
            }
            0x82EB44E0 => {
    //   block [0x82EB44E0..0x82EB44F4)
	// 82EB44E0: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB44E4: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB44E8: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB44EC: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB44F0: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EB44F4; continue 'dispatch;
            }
            0x82EB44F4 => {
    //   block [0x82EB44F4..0x82EB4514)
	// 82EB44F4: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB44F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB44FC: 83FF0188  lwz r31, 0x188(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB4500: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4504: 4B3AC4B5  bl 0x822609b8
	ctx.lr = 0x82EB4508;
	sub_822609B8(ctx, base);
	// 82EB4508: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB450C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB4510: 4B410D29  bl 0x822c5238
	ctx.lr = 0x82EB4514;
	sub_822C5238(ctx, base);
	pc = 0x82EB4514; continue 'dispatch;
            }
            0x82EB4514 => {
    //   block [0x82EB4514..0x82EB4518)
	// 82EB4514: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EB4518; continue 'dispatch;
            }
            0x82EB4518 => {
    //   block [0x82EB4518..0x82EB4530)
	// 82EB4518: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB451C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB4520: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB4524: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB4528: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB452C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB4530 size=1648
    let mut pc: u32 = 0x82EB4530;
    'dispatch: loop {
        match pc {
            0x82EB4530 => {
    //   block [0x82EB4530..0x82EB4588)
	// 82EB4530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4534: 4BDF4EB5  bl 0x82ca93e8
	ctx.lr = 0x82EB4538;
	sub_82CA93D0(ctx, base);
	// 82EB4538: DBA1FF80  stfd f29, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[29].u64 ) };
	// 82EB453C: DBC1FF88  stfd f30, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 82EB4540: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 82EB4544: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4548: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB454C: 3ADF00E0  addi r22, r31, 0xe0
	ctx.r[22].s64 = ctx.r[31].s64 + 224;
	// 82EB4550: 3B3F00F8  addi r25, r31, 0xf8
	ctx.r[25].s64 = ctx.r[31].s64 + 248;
	// 82EB4554: C0160000  lfs f0, 0(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4558: C1B90000  lfs f13, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB455C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB4560: 409A0028  bne cr6, 0x82eb4588
	if !ctx.cr[6].eq {
	pc = 0x82EB4588; continue 'dispatch;
	}
	// 82EB4564: C0190004  lfs f0, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4568: C1B60004  lfs f13, 4(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB456C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4570: 409A0018  bne cr6, 0x82eb4588
	if !ctx.cr[6].eq {
	pc = 0x82EB4588; continue 'dispatch;
	}
	// 82EB4574: C0190008  lfs f0, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4578: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB457C: C1B60008  lfs f13, 8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4580: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4584: 419A0008  beq cr6, 0x82eb458c
	if ctx.cr[6].eq {
	pc = 0x82EB458C; continue 'dispatch;
	}
	pc = 0x82EB4588; continue 'dispatch;
            }
            0x82EB4588 => {
    //   block [0x82EB4588..0x82EB458C)
	// 82EB4588: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EB458C; continue 'dispatch;
            }
            0x82EB458C => {
    //   block [0x82EB458C..0x82EB4658)
	// 82EB458C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4590: 408205F0  bne 0x82eb4b80
	if !ctx.cr[0].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB4594: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB4598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB459C: 419A05E4  beq cr6, 0x82eb4b80
	if ctx.cr[6].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB45A0: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB45A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB45A8: 419A05D8  beq cr6, 0x82eb4b80
	if ctx.cr[6].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB45AC: 4B3AC40D  bl 0x822609b8
	ctx.lr = 0x82EB45B0;
	sub_822609B8(ctx, base);
	// 82EB45B0: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB45B4: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 82EB45B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB45BC: 4082009C  bne 0x82eb4658
	if !ctx.cr[0].eq {
	pc = 0x82EB4658; continue 'dispatch;
	}
	// 82EB45C0: C1BF0110  lfs f13, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB45C4: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB45C8: C0190000  lfs f0, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB45CC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB45D0: C1990004  lfs f12, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB45D4: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB45D8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB45DC: C15F0118  lfs f10, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB45E0: C1990008  lfs f12, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB45E4: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB45E8: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB45EC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB45F0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB45F4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB45F8: EFE0002C  fsqrts f31, f0
	ctx.f[31].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB45FC: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 82EB4600: 40990058  ble cr6, 0x82eb4658
	if !ctx.cr[6].gt {
	pc = 0x82EB4658; continue 'dispatch;
	}
	// 82EB4604: 4B3AC3B5  bl 0x822609b8
	ctx.lr = 0x82EB4608;
	sub_822609B8(ctx, base);
	// 82EB4608: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB460C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB4610: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB4614: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82EB4618: 80AA0014  lwz r5, 0x14(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB461C: C3CB004C  lfs f30, 0x4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB4620: 4BFCD0B1  bl 0x82e816d0
	ctx.lr = 0x82EB4624;
	sub_82E816D0(ctx, base);
	// 82EB4624: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB4628: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82EB462C: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB4630: EFDE0828  fsubs f30, f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EB4634: C3AB0008  lfs f29, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB4638: 4BFCCCC9  bl 0x82e81300
	ctx.lr = 0x82EB463C;
	sub_82E81300(ctx, base);
	// 82EB463C: EDBFE824  fdivs f13, f31, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[31].f64 / ctx.f[29].f64) as f32) as f64;
	// 82EB4640: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4644: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4648: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB464C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4650: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EB4654: 4198052C  blt cr6, 0x82eb4b80
	if ctx.cr[6].lt {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	pc = 0x82EB4658; continue 'dispatch;
            }
            0x82EB4658 => {
    //   block [0x82EB4658..0x82EB46C0)
	// 82EB4658: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EB465C: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB4660: 4BFDEB29  bl 0x82e93188
	ctx.lr = 0x82EB4664;
	sub_82E93188(ctx, base);
	// 82EB4664: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB4668: 907F013C  stw r3, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[3].u32 ) };
	// 82EB466C: 419A0514  beq cr6, 0x82eb4b80
	if ctx.cr[6].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB4670: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4674: 1D63000C  mulli r11, r3, 0xc
	ctx.r[11].s32 = ((ctx.r[3].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB4678: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB467C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EB4680: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4684: D0190000  stfs f0, 0(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4688: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB468C: D0190004  stfs f0, 4(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4690: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4694: D0190008  stfs f0, 8(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4698: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB469C: 83DF013C  lwz r30, 0x13c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB46A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB46A4: 7FD5F378  mr r21, r30
	ctx.r[21].u64 = ctx.r[30].u64;
	// 82EB46A8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB46AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB46B0: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB46B4: 419A0228  beq cr6, 0x82eb48dc
	if ctx.cr[6].eq {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB46B8: 1F9E000C  mulli r28, r30, 0xc
	ctx.r[28].s32 = ((ctx.r[30].s32 as i64 * 12 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 82EB46BC: 57DB103A  slwi r27, r30, 2
	ctx.r[27].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	pc = 0x82EB46C0; continue 'dispatch;
            }
            0x82EB46C0 => {
    //   block [0x82EB46C0..0x82EB4708)
	// 82EB46C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB46C4: 419A0044  beq cr6, 0x82eb4708
	if ctx.cr[6].eq {
	pc = 0x82EB4708; continue 'dispatch;
	}
	// 82EB46C8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB46CC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB46D0: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EB46D4: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB46D8: 806BFFFC  lwz r3, -4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB46DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB46E0: 41820028  beq 0x82eb4708
	if ctx.cr[0].eq {
	pc = 0x82EB4708; continue 'dispatch;
	}
	// 82EB46E4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB46E8: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB46EC: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB46F0: 7CCBE214  add r6, r11, r28
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EB46F4: 816A0024  lwz r11, 0x24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EB46F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB46FC: 4E800421  bctrl
	ctx.lr = 0x82EB4700;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4700: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4704: 41820494  beq 0x82eb4b98
	if ctx.cr[0].eq {
	pc = 0x82EB4B98; continue 'dispatch;
	}
            }
            0x82EB4708 => {
    //   block [0x82EB4708..0x82EB4774)
	// 82EB4708: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB470C: 3BBC000C  addi r29, r28, 0xc
	ctx.r[29].s64 = ctx.r[28].s64 + 12;
	// 82EB4710: C01F004C  lfs f0, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4714: 3B5E0001  addi r26, r30, 1
	ctx.r[26].s64 = ctx.r[30].s64 + 1;
	// 82EB4718: 7CABEA14  add r5, r11, r29
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB471C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4720: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4724: 3B1B0004  addi r24, r27, 4
	ctx.r[24].s64 = ctx.r[27].s64 + 4;
	// 82EB4728: C19F0114  lfs f12, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB472C: C15F0118  lfs f10, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4730: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4734: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB4738: C1250004  lfs f9, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB473C: EDAC4828  fsubs f13, f12, f9
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB4740: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4744: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB4748: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB474C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4750: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4754: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB4758: 41990184  bgt cr6, 0x82eb48dc
	if ctx.cr[6].gt {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB475C: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82EB4760: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4764: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4768: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB476C: 40980008  bge cr6, 0x82eb4774
	if !ctx.cr[6].lt {
	pc = 0x82EB4774; continue 'dispatch;
	}
	// 82EB4770: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82EB4774; continue 'dispatch;
            }
            0x82EB4774 => {
    //   block [0x82EB4774..0x82EB47D0)
	// 82EB4774: C1BF0044  lfs f13, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4778: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB477C: 41990160  bgt cr6, 0x82eb48dc
	if ctx.cr[6].gt {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB4780: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4788: 815F00A4  lwz r10, 0xa4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EB478C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4790: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EB4794: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB4798: 4E800421  bctrl
	ctx.lr = 0x82EB479C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB479C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB47A0: 4182013C  beq 0x82eb48dc
	if ctx.cr[0].eq {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB47A4: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB47A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB47AC: 41820024  beq 0x82eb47d0
	if ctx.cr[0].eq {
	pc = 0x82EB47D0; continue 'dispatch;
	}
	// 82EB47B0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB47B4: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB47B8: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB47BC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB47C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB47C4: 4E800421  bctrl
	ctx.lr = 0x82EB47C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB47C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB47CC: 41820110  beq 0x82eb48dc
	if ctx.cr[0].eq {
	pc = 0x82EB48DC; continue 'dispatch;
	}
            }
            0x82EB47D0 => {
    //   block [0x82EB47D0..0x82EB4894)
	// 82EB47D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB47D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB47D8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB47DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB47E0: 4E800421  bctrl
	ctx.lr = 0x82EB47E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB47E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB47E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB47EC: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB47F0: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB47F4: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB47F8: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB47FC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EB4800: 7CCBEA14  add r6, r11, r29
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4804: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4808: 7CABE214  add r5, r11, r28
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EB480C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4810: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4814: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4818: 4E800421  bctrl
	ctx.lr = 0x82EB481C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB481C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4820: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4824: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB4828: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB482C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 82EB4830: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4834: 7CCBE214  add r6, r11, r28
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EB4838: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB483C: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4840: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB4844: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4848: 4E800421  bctrl
	ctx.lr = 0x82EB484C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB484C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4850: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4854: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB4858: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB485C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82EB4860: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4864: 7CCBEA14  add r6, r11, r29
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4868: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB486C: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4870: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB4874: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4878: 4E800421  bctrl
	ctx.lr = 0x82EB487C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB487C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4880: 41820014  beq 0x82eb4894
	if ctx.cr[0].eq {
	pc = 0x82EB4894; continue 'dispatch;
	}
	// 82EB4884: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4888: 4182000C  beq 0x82eb4894
	if ctx.cr[0].eq {
	pc = 0x82EB4894; continue 'dispatch;
	}
	// 82EB488C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4890: 4182004C  beq 0x82eb48dc
	if ctx.cr[0].eq {
	pc = 0x82EB48DC; continue 'dispatch;
	}
            }
            0x82EB4894 => {
    //   block [0x82EB4894..0x82EB48DC)
	// 82EB4894: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4898: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB489C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB48A0: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB48A4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB48A8: 41990034  bgt cr6, 0x82eb48dc
	if ctx.cr[6].gt {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB48AC: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB48B0: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82EB48B4: 7F55D378  mr r21, r26
	ctx.r[21].u64 = ctx.r[26].u64;
	// 82EB48B8: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB48BC: 40980020  bge cr6, 0x82eb48dc
	if !ctx.cr[6].lt {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB48C0: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB48C4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82EB48C8: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 82EB48CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB48D0: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82EB48D4: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB48D8: 409AFDE8  bne cr6, 0x82eb46c0
	if !ctx.cr[6].eq {
	pc = 0x82EB46C0; continue 'dispatch;
	}
	pc = 0x82EB48DC; continue 'dispatch;
            }
            0x82EB48DC => {
    //   block [0x82EB48DC..0x82EB49A4)
	// 82EB48DC: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB48E0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EB48E4: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB48E8: 409801E0  bge cr6, 0x82eb4ac8
	if !ctx.cr[6].lt {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB48EC: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB48F0: 39550001  addi r10, r21, 1
	ctx.r[10].s64 = ctx.r[21].s64 + 1;
	// 82EB48F4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB48F8: 409A01D0  bne cr6, 0x82eb4ac8
	if !ctx.cr[6].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB48FC: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4900: 1FB5000C  mulli r29, r21, 0xc
	ctx.r[29].s32 = ((ctx.r[21].s32 as i64 * 12 as i64) as i32);
	ctx.r[29].s64 = ctx.r[29].s32 as i64;
	// 82EB4904: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4908: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB490C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4910: 389F0110  addi r4, r31, 0x110
	ctx.r[4].s64 = ctx.r[31].s64 + 272;
	// 82EB4914: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4918: C1440000  lfs f10, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB491C: EC0A0028  fsubs f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB4920: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4924: C1240004  lfs f9, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB4928: EDA96828  fsubs f13, f9, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB492C: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4930: C1440008  lfs f10, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4934: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB4938: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB493C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4940: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4944: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB4948: 40990164  ble cr6, 0x82eb4aac
	if !ctx.cr[6].gt {
	pc = 0x82EB4AAC; continue 'dispatch;
	}
	// 82EB494C: C01F004C  lfs f0, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4950: FD804890  fmr f12, f9
	ctx.f[12].f64 = ctx.f[9].f64;
	// 82EB4954: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4958: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB495C: C0160000  lfs f0, 0(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4960: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB4964: C1B60004  lfs f13, 4(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4968: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB496C: FD805090  fmr f12, f10
	ctx.f[12].f64 = ctx.f[10].f64;
	// 82EB4970: C1560008  lfs f10, 8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4974: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4978: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB497C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4980: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4984: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB4988: 41990140  bgt cr6, 0x82eb4ac8
	if ctx.cr[6].gt {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB498C: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4990: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4994: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4998: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB499C: 40980008  bge cr6, 0x82eb49a4
	if !ctx.cr[6].lt {
	pc = 0x82EB49A4; continue 'dispatch;
	}
	// 82EB49A0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82EB49A4; continue 'dispatch;
            }
            0x82EB49A4 => {
    //   block [0x82EB49A4..0x82EB4AAC)
	// 82EB49A4: C1BF0044  lfs f13, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB49A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB49AC: 4199011C  bgt cr6, 0x82eb4ac8
	if ctx.cr[6].gt {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB49B0: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EB49B4: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82EB49B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB49BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB49C0: 4E800421  bctrl
	ctx.lr = 0x82EB49C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB49C4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB49C8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB49CC: 409A00FC  bne cr6, 0x82eb4ac8
	if !ctx.cr[6].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB49D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB49D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB49D8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB49DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB49E0: 4E800421  bctrl
	ctx.lr = 0x82EB49E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB49E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB49E8: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB49EC: D3E10058  stfs f31, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB49F0: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB49F4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB49F8: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB49FC: 7CABEA14  add r5, r11, r29
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4A00: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82EB4A04: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4A08: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 82EB4A0C: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4A10: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4A14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4A18: 4E800421  bctrl
	ctx.lr = 0x82EB4A1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4A1C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4A20: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4A24: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB4A28: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4A2C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 82EB4A30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4A34: 7CCBEA14  add r6, r11, r29
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4A38: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4A3C: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4A40: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB4A44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4A48: 4E800421  bctrl
	ctx.lr = 0x82EB4A4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4A4C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4A50: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4A54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB4A58: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EB4A5C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 82EB4A60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4A64: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4A68: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4A6C: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB4A70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4A74: 4E800421  bctrl
	ctx.lr = 0x82EB4A78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4A78: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4A7C: 4182004C  beq 0x82eb4ac8
	if ctx.cr[0].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB4A80: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4A84: 41820044  beq 0x82eb4ac8
	if ctx.cr[0].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB4A88: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB4A8C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB4A90: 409A0038  bne cr6, 0x82eb4ac8
	if !ctx.cr[6].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB4A94: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4A98: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4A9C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB4AA0: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4AA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB4AA8: 40980020  bge cr6, 0x82eb4ac8
	if !ctx.cr[6].lt {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
            }
            0x82EB4AAC => {
    //   block [0x82EB4AAC..0x82EB4AC8)
	// 82EB4AAC: C0160000  lfs f0, 0(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4AB0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82EB4AB4: D0190000  stfs f0, 0(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4AB8: C0160004  lfs f0, 4(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4ABC: D0190004  stfs f0, 4(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4AC0: C0160008  lfs f0, 8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4AC4: D0190008  stfs f0, 8(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EB4AC8; continue 'dispatch;
            }
            0x82EB4AC8 => {
    //   block [0x82EB4AC8..0x82EB4B34)
	// 82EB4AC8: 813F013C  lwz r9, 0x13c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB4ACC: 7F154840  cmplw cr6, r21, r9
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB4AD0: 409A006C  bne cr6, 0x82eb4b3c
	if !ctx.cr[6].eq {
	pc = 0x82EB4B3C; continue 'dispatch;
	}
	// 82EB4AD4: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB4AD8: 39150001  addi r8, r21, 1
	ctx.r[8].s64 = ctx.r[21].s64 + 1;
	// 82EB4ADC: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB4AE0: 40980054  bge cr6, 0x82eb4b34
	if !ctx.cr[6].lt {
	pc = 0x82EB4B34; continue 'dispatch;
	}
	// 82EB4AE4: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4AE8: 1D69000C  mulli r11, r9, 0xc
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB4AEC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB4AF0: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4AF4: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4AF8: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4AFC: C15F0118  lfs f10, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4B00: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4B04: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4B08: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4B0C: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4B10: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4B14: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4B18: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB4B1C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4B20: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4B24: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4B28: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB4B2C: 40980008  bge cr6, 0x82eb4b34
	if !ctx.cr[6].lt {
	pc = 0x82EB4B34; continue 'dispatch;
	}
	// 82EB4B30: 7D154378  mr r21, r8
	ctx.r[21].u64 = ctx.r[8].u64;
	pc = 0x82EB4B34; continue 'dispatch;
            }
            0x82EB4B34 => {
    //   block [0x82EB4B34..0x82EB4B3C)
	// 82EB4B34: 7F154840  cmplw cr6, r21, r9
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB4B38: 419A0048  beq cr6, 0x82eb4b80
	if ctx.cr[6].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	pc = 0x82EB4B3C; continue 'dispatch;
            }
            0x82EB4B3C => {
    //   block [0x82EB4B3C..0x82EB4B48)
	// 82EB4B3C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4B40: 92BF013C  stw r21, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[21].u32 ) };
	// 82EB4B44: 40820028  bne 0x82eb4b6c
	if !ctx.cr[0].eq {
	pc = 0x82EB4B6C; continue 'dispatch;
	}
	pc = 0x82EB4B48; continue 'dispatch;
            }
            0x82EB4B48 => {
    //   block [0x82EB4B48..0x82EB4B6C)
	// 82EB4B48: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4B4C: 1D75000C  mulli r11, r21, 0xc
	ctx.r[11].s32 = ((ctx.r[21].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB4B50: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB4B54: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4B58: D0190000  stfs f0, 0(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4B5C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4B60: D0190004  stfs f0, 4(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4B64: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4B68: D0190008  stfs f0, 8(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EB4B6C; continue 'dispatch;
            }
            0x82EB4B6C => {
    //   block [0x82EB4B6C..0x82EB4B80)
	// 82EB4B6C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4B70: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82EB4B74: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB4B78: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4B7C: 4B4106BD  bl 0x822c5238
	ctx.lr = 0x82EB4B80;
	sub_822C5238(ctx, base);
	pc = 0x82EB4B80; continue 'dispatch;
            }
            0x82EB4B80 => {
    //   block [0x82EB4B80..0x82EB4B98)
	// 82EB4B80: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB4B84: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EB4B88: CBA1FF80  lfd f29, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82EB4B8C: CBC1FF88  lfd f30, -0x78(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82EB4B90: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82EB4B94: 4BDF48A4  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EB4B98 => {
    //   block [0x82EB4B98..0x82EB4BA0)
	// 82EB4B98: 92BF013C  stw r21, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[21].u32 ) };
	// 82EB4B9C: 4BFFFFAC  b 0x82eb4b48
	pc = 0x82EB4B48; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB4BA0 size=308
    let mut pc: u32 = 0x82EB4BA0;
    'dispatch: loop {
        match pc {
            0x82EB4BA0 => {
    //   block [0x82EB4BA0..0x82EB4C20)
	// 82EB4BA0: C1A50000  lfs f13, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4BA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4BA8: C0030110  lfs f0, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4BAC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4BB0: C1850004  lfs f12, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4BB4: C1430114  lfs f10, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4BB8: ED4A6028  fsubs f10, f10, f12
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB4BBC: C1650008  lfs f11, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB4BC0: C1230118  lfs f9, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB4BC4: ED295828  fsubs f9, f9, f11
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB4BC8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4BCC: EC0A02BA  fmadds f0, f10, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4BD0: EC09027A  fmadds f0, f9, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4BD4: C12B0C18  lfs f9, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB4BD8: ED40002C  fsqrts f10, f0
	ctx.f[10].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB4BDC: FF0A4800  fcmpu cr6, f10, f9
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[9].f64);
	// 82EB4BE0: 419A0040  beq cr6, 0x82eb4c20
	if ctx.cr[6].eq {
	pc = 0x82EB4C20; continue 'dispatch;
	}
	// 82EB4BE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4BE8: C1030110  lfs f8, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB4BEC: C0E30114  lfs f7, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EB4BF0: EDAD4028  fsubs f13, f13, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB4BF4: C1030118  lfs f8, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB4BF8: ED8C3828  fsubs f12, f12, f7
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EB4BFC: ED6B4028  fsubs f11, f11, f8
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB4C00: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C04: EC005024  fdivs f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EB4C08: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB4C0C: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4C10: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB4C14: D1840008  stfs f12, 8(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4C18: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB4C1C: 48000020  b 0x82eb4c3c
	pc = 0x82EB4C3C; continue 'dispatch;
            }
            0x82EB4C20 => {
    //   block [0x82EB4C20..0x82EB4C3C)
	// 82EB4C20: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4C24: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4C28: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C2C: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4C30: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C34: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4C38: C00B0054  lfs f0, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EB4C3C; continue 'dispatch;
            }
            0x82EB4C3C => {
    //   block [0x82EB4C3C..0x82EB4C58)
	// 82EB4C3C: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB4C40: 8163015C  lwz r11, 0x15c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(348 as u32) ) } as u64;
	// 82EB4C44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4C48: 41820010  beq 0x82eb4c58
	if ctx.cr[0].eq {
	pc = 0x82EB4C58; continue 'dispatch;
	}
	// 82EB4C4C: 896B0004  lbz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4C50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4C54: 40820008  bne 0x82eb4c5c
	if !ctx.cr[0].eq {
	pc = 0x82EB4C5C; continue 'dispatch;
	}
	pc = 0x82EB4C58; continue 'dispatch;
            }
            0x82EB4C58 => {
    //   block [0x82EB4C58..0x82EB4C5C)
	// 82EB4C58: D1240008  stfs f9, 8(r4)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EB4C5C; continue 'dispatch;
            }
            0x82EB4C5C => {
    //   block [0x82EB4C5C..0x82EB4C90)
	// 82EB4C5C: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C60: C1A300E0  lfs f13, 0xe0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4C64: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4C68: 409A0028  bne cr6, 0x82eb4c90
	if !ctx.cr[6].eq {
	pc = 0x82EB4C90; continue 'dispatch;
	}
	// 82EB4C6C: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C70: C1A300E4  lfs f13, 0xe4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4C74: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4C78: 409A0018  bne cr6, 0x82eb4c90
	if !ctx.cr[6].eq {
	pc = 0x82EB4C90; continue 'dispatch;
	}
	// 82EB4C7C: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB4C84: C1A300E8  lfs f13, 0xe8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4C88: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4C8C: 419A0008  beq cr6, 0x82eb4c94
	if ctx.cr[6].eq {
	pc = 0x82EB4C94; continue 'dispatch;
	}
	pc = 0x82EB4C90; continue 'dispatch;
            }
            0x82EB4C90 => {
    //   block [0x82EB4C90..0x82EB4C94)
	// 82EB4C90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EB4C94; continue 'dispatch;
            }
            0x82EB4C94 => {
    //   block [0x82EB4C94..0x82EB4CA4)
	// 82EB4C94: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4C98: 4182000C  beq 0x82eb4ca4
	if ctx.cr[0].eq {
	pc = 0x82EB4CA4; continue 'dispatch;
	}
	// 82EB4C9C: C0030040  lfs f0, 0x40(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4CA0: 48000008  b 0x82eb4ca8
	pc = 0x82EB4CA8; continue 'dispatch;
            }
            0x82EB4CA4 => {
    //   block [0x82EB4CA4..0x82EB4CA8)
	// 82EB4CA4: C003003C  lfs f0, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EB4CA8; continue 'dispatch;
            }
            0x82EB4CA8 => {
    //   block [0x82EB4CA8..0x82EB4CB8)
	// 82EB4CA8: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 82EB4CAC: 4099000C  ble cr6, 0x82eb4cb8
	if !ctx.cr[6].gt {
	pc = 0x82EB4CB8; continue 'dispatch;
	}
	// 82EB4CB0: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4CB4: 48000014  b 0x82eb4cc8
	pc = 0x82EB4CC8; continue 'dispatch;
            }
            0x82EB4CB8 => {
    //   block [0x82EB4CB8..0x82EB4CC8)
	// 82EB4CB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4CBC: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4CC0: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4CC4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82EB4CC8; continue 'dispatch;
            }
            0x82EB4CC8 => {
    //   block [0x82EB4CC8..0x82EB4CD4)
	// 82EB4CC8: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4CCC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB4CD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB4CD8 size=84
    let mut pc: u32 = 0x82EB4CD8;
    'dispatch: loop {
        match pc {
            0x82EB4CD8 => {
    //   block [0x82EB4CD8..0x82EB4CFC)
	// 82EB4CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB4CE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4CE4: 814301B0  lwz r10, 0x1b0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB4CE8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82EB4CEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB4CF0: 409A000C  bne cr6, 0x82eb4cfc
	if !ctx.cr[6].eq {
	pc = 0x82EB4CFC; continue 'dispatch;
	}
	// 82EB4CF4: 4BFFFEAD  bl 0x82eb4ba0
	ctx.lr = 0x82EB4CF8;
	sub_82EB4BA0(ctx, base);
	// 82EB4CF8: 48000024  b 0x82eb4d1c
	pc = 0x82EB4D1C; continue 'dispatch;
            }
            0x82EB4CFC => {
    //   block [0x82EB4CFC..0x82EB4D1C)
	// 82EB4CFC: 806301B0  lwz r3, 0x1b0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB4D00: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82EB4D04: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EB4D08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4D0C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4D10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4D14: 4E800421  bctrl
	ctx.lr = 0x82EB4D18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4D18: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
            }
            0x82EB4D1C => {
    //   block [0x82EB4D1C..0x82EB4D2C)
	// 82EB4D1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB4D20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB4D24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB4D28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB4D30 size=108
    let mut pc: u32 = 0x82EB4D30;
    'dispatch: loop {
        match pc {
            0x82EB4D30 => {
    //   block [0x82EB4D30..0x82EB4D9C)
	// 82EB4D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB4D38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4D3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4D40: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4D48: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4D4C: C0030110  lfs f0, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D50: D00300F8  stfs f0, 0xf8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EB4D54: C0030114  lfs f0, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D58: D00300FC  stfs f0, 0xfc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EB4D5C: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB4D60: C0030118  lfs f0, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D64: D0030100  stfs f0, 0x100(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EB4D68: C0030110  lfs f0, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D6C: D0030104  stfs f0, 0x104(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB4D70: C0030114  lfs f0, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D74: D0030108  stfs f0, 0x108(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB4D78: C0030118  lfs f0, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D7C: D003010C  stfs f0, 0x10c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EB4D80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4D84: 4E800421  bctrl
	ctx.lr = 0x82EB4D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4D88: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB4D8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB4D90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB4D94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB4D98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB4DA0 size=76
    let mut pc: u32 = 0x82EB4DA0;
    'dispatch: loop {
        match pc {
            0x82EB4DA0 => {
    //   block [0x82EB4DA0..0x82EB4DEC)
	// 82EB4DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB4DA8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4DAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB4DB0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EB4DB4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EB4DB8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB4DBC: 814B0158  lwz r10, 0x158(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(344 as u32) ) } as u64;
	// 82EB4DC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4DC4: C02A0004  lfs f1, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB4DC8: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4DCC: 4B77A745  bl 0x8262f510
	ctx.lr = 0x82EB4DD0;
	sub_8262F510(ctx, base);
	// 82EB4DD0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB4DD4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB4DD8: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB4DDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB4DE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB4DE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB4DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB4DF0 size=88
    let mut pc: u32 = 0x82EB4DF0;
    'dispatch: loop {
        match pc {
            0x82EB4DF0 => {
    //   block [0x82EB4DF0..0x82EB4E1C)
	// 82EB4DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4DF4: 4BDF4619  bl 0x82ca940c
	ctx.lr = 0x82EB4DF8;
	sub_82CA93D0(ctx, base);
	// 82EB4DF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4DFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB4E00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB4E04: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB4E08: 4BFFFF99  bl 0x82eb4da0
	ctx.lr = 0x82EB4E0C;
	sub_82EB4DA0(ctx, base);
	// 82EB4E0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4E10: 4082000C  bne 0x82eb4e1c
	if !ctx.cr[0].eq {
	pc = 0x82EB4E1C; continue 'dispatch;
	}
	// 82EB4E14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB4E18: 48000028  b 0x82eb4e40
	pc = 0x82EB4E40; continue 'dispatch;
            }
            0x82EB4E1C => {
    //   block [0x82EB4E1C..0x82EB4E40)
	// 82EB4E1C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB4E20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB4E24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4E28: 4BFFCDE1  bl 0x82eb1c08
	ctx.lr = 0x82EB4E2C;
	sub_82EB1C08(ctx, base);
	// 82EB4E2C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB4E30: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB4E34: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB4E38: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB4E3C: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x82EB4E40; continue 'dispatch;
            }
            0x82EB4E40 => {
    //   block [0x82EB4E40..0x82EB4E48)
	// 82EB4E40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB4E44: 4BDF4618  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB4E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB4E48 size=476
    let mut pc: u32 = 0x82EB4E48;
    'dispatch: loop {
        match pc {
            0x82EB4E48 => {
    //   block [0x82EB4E48..0x82EB4E9C)
	// 82EB4E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4E4C: 4BDF45C1  bl 0x82ca940c
	ctx.lr = 0x82EB4E50;
	sub_82CA93D0(ctx, base);
	// 82EB4E50: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 82EB4E54: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EB4E58: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EB4E5C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4E60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB4E64: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EB4E68: C01E00E0  lfs f0, 0xe0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4E6C: C1BE00F8  lfs f13, 0xf8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4E70: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB4E74: 409A0028  bne cr6, 0x82eb4e9c
	if !ctx.cr[6].eq {
	pc = 0x82EB4E9C; continue 'dispatch;
	}
	// 82EB4E78: C01E00FC  lfs f0, 0xfc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4E7C: C1BE00E4  lfs f13, 0xe4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4E80: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4E84: 409A0018  bne cr6, 0x82eb4e9c
	if !ctx.cr[6].eq {
	pc = 0x82EB4E9C; continue 'dispatch;
	}
	// 82EB4E88: C01E0100  lfs f0, 0x100(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4E8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB4E90: C1BE00E8  lfs f13, 0xe8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4E94: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4E98: 419A0008  beq cr6, 0x82eb4ea0
	if ctx.cr[6].eq {
	pc = 0x82EB4EA0; continue 'dispatch;
	}
	pc = 0x82EB4E9C; continue 'dispatch;
            }
            0x82EB4E9C => {
    //   block [0x82EB4E9C..0x82EB4EA0)
	// 82EB4E9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EB4EA0; continue 'dispatch;
            }
            0x82EB4EA0 => {
    //   block [0x82EB4EA0..0x82EB4F3C)
	// 82EB4EA0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4EA4: 40820168  bne 0x82eb500c
	if !ctx.cr[0].eq {
	pc = 0x82EB500C; continue 'dispatch;
	}
	// 82EB4EA8: 817E013C  lwz r11, 0x13c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB4EAC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4EB0: 4182015C  beq 0x82eb500c
	if ctx.cr[0].eq {
	pc = 0x82EB500C; continue 'dispatch;
	}
	// 82EB4EB4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB4EB8: 419A0154  beq cr6, 0x82eb500c
	if ctx.cr[6].eq {
	pc = 0x82EB500C; continue 'dispatch;
	}
	// 82EB4EBC: 813E0088  lwz r9, 0x88(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4EC0: 1D4B000C  mulli r10, r11, 0xc
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EB4EC4: 7FEA4A14  add r31, r10, r9
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EB4EC8: 815E0084  lwz r10, 0x84(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EB4ECC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB4ED0: 813E006C  lwz r9, 0x6c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB4ED4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB4ED8: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4EDC: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4EE0: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4EE4: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB4EE8: C17FFFF4  lfs f11, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB4EEC: C15FFFF8  lfs f10, -8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4EF0: EFED5828  fsubs f31, f13, f11
	ctx.f[31].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB4EF4: C13FFFFC  lfs f9, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB4EF8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB4EFC: EFA05028  fsubs f29, f0, f10
	ctx.f[29].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB4F00: EFCC4828  fsubs f30, f12, f9
	ctx.f[30].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB4F04: 419A0038  beq cr6, 0x82eb4f3c
	if ctx.cr[6].eq {
	pc = 0x82EB4F3C; continue 'dispatch;
	}
	// 82EB4F08: 81490028  lwz r10, 0x28(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EB4F0C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB4F10: 4098002C  bge cr6, 0x82eb4f3c
	if !ctx.cr[6].lt {
	pc = 0x82EB4F3C; continue 'dispatch;
	}
	// 82EB4F14: 81490034  lwz r10, 0x34(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB4F18: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB4F1C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB4F20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4F24: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB4F28: 419A0014  beq cr6, 0x82eb4f3c
	if ctx.cr[6].eq {
	pc = 0x82EB4F3C; continue 'dispatch;
	}
	// 82EB4F2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4F30: 4182000C  beq 0x82eb4f3c
	if ctx.cr[0].eq {
	pc = 0x82EB4F3C; continue 'dispatch;
	}
	// 82EB4F34: 4BFDA6ED  bl 0x82e8f620
	ctx.lr = 0x82EB4F38;
	sub_82E8F620(ctx, base);
	// 82EB4F38: 48000020  b 0x82eb4f58
	pc = 0x82EB4F58; continue 'dispatch;
            }
            0x82EB4F3C => {
    //   block [0x82EB4F3C..0x82EB4F58)
	// 82EB4F3C: EDAD5828  fsubs f13, f13, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB4F40: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB4F44: ED8C4828  fsubs f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB4F48: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB4F4C: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB4F50: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4F54: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	pc = 0x82EB4F58; continue 'dispatch;
            }
            0x82EB4F58 => {
    //   block [0x82EB4F58..0x82EB4FD8)
	// 82EB4F58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4F5C: C14B0C18  lfs f10, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4F60: FF015000  fcmpu cr6, f1, f10
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[10].f64);
	// 82EB4F64: 419A0080  beq cr6, 0x82eb4fe4
	if ctx.cr[6].eq {
	pc = 0x82EB4FE4; continue 'dispatch;
	}
	// 82EB4F68: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4F6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4F70: FD206850  fneg f9, f13
	ctx.f[9].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EB4F74: C19E0114  lfs f12, 0x114(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4F78: C1BFFFF8  lfs f13, -8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4F7C: ED6C6828  fsubs f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4F80: C11E0118  lfs f8, 0x118(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB4F84: C1BFFFFC  lfs f13, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4F88: EDA86828  fsubs f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4F8C: C19E0110  lfs f12, 0x110(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4F90: C11FFFF4  lfs f8, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB4F94: ED8C4028  fsubs f12, f12, f8
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB4F98: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4F9C: EC000824  fdivs f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 82EB4FA0: ED6B0772  fmuls f11, f11, f29
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EB4FA4: ED6D5FBA  fmadds f11, f13, f30, f11
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EB4FA8: ED6C5FFA  fmadds f11, f12, f31, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EB4FAC: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4FB0: FF0B4800  fcmpu cr6, f11, f9
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[9].f64);
	// 82EB4FB4: 41980030  blt cr6, 0x82eb4fe4
	if ctx.cr[6].lt {
	pc = 0x82EB4FE4; continue 'dispatch;
	}
	// 82EB4FB8: FF0B0800  fcmpu cr6, f11, f1
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[1].f64);
	// 82EB4FBC: 41990028  bgt cr6, 0x82eb4fe4
	if ctx.cr[6].gt {
	pc = 0x82EB4FE4; continue 'dispatch;
	}
	// 82EB4FC0: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB4FC4: EDAC6FB8  fmsubs f13, f12, f30, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4FC8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4FCC: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EB4FD0: 40980008  bge cr6, 0x82eb4fd8
	if !ctx.cr[6].lt {
	pc = 0x82EB4FD8; continue 'dispatch;
	}
	// 82EB4FD4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82EB4FD8; continue 'dispatch;
            }
            0x82EB4FD8 => {
    //   block [0x82EB4FD8..0x82EB4FE4)
	// 82EB4FD8: C1BE005C  lfs f13, 0x5c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4FDC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4FE0: 4198002C  blt cr6, 0x82eb500c
	if ctx.cr[6].lt {
	pc = 0x82EB500C; continue 'dispatch;
	}
	pc = 0x82EB4FE4; continue 'dispatch;
            }
            0x82EB4FE4 => {
    //   block [0x82EB4FE4..0x82EB500C)
	// 82EB4FE4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB4FE8: 389E0110  addi r4, r30, 0x110
	ctx.r[4].s64 = ctx.r[30].s64 + 272;
	// 82EB4FEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4FF0: 4BFFCC19  bl 0x82eb1c08
	ctx.lr = 0x82EB4FF4;
	sub_82EB1C08(ctx, base);
	// 82EB4FF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4FF8: 41820014  beq 0x82eb500c
	if ctx.cr[0].eq {
	pc = 0x82EB500C; continue 'dispatch;
	}
	// 82EB4FFC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EB5000: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB5004: 917E0140  stw r11, 0x140(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82EB5008: 48000008  b 0x82eb5010
	pc = 0x82EB5010; continue 'dispatch;
            }
            0x82EB500C => {
    //   block [0x82EB500C..0x82EB5010)
	// 82EB500C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EB5010; continue 'dispatch;
            }
            0x82EB5010 => {
    //   block [0x82EB5010..0x82EB5024)
	// 82EB5010: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5014: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82EB5018: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EB501C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EB5020: 4BDF443C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5028 size=68
    let mut pc: u32 = 0x82EB5028;
    'dispatch: loop {
        match pc {
            0x82EB5028 => {
    //   block [0x82EB5028..0x82EB506C)
	// 82EB5028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB502C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5030: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5034: 81630158  lwz r11, 0x158(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(344 as u32) ) } as u64;
	// 82EB5038: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB503C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB5040: 38630110  addi r3, r3, 0x110
	ctx.r[3].s64 = ctx.r[3].s64 + 272;
	// 82EB5044: C02B0004  lfs f1, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB5048: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB504C: 4B77A4C5  bl 0x8262f510
	ctx.lr = 0x82EB5050;
	sub_8262F510(ctx, base);
	// 82EB5050: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB5054: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB5058: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB505C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB5060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5070 size=216
    let mut pc: u32 = 0x82EB5070;
    'dispatch: loop {
        match pc {
            0x82EB5070 => {
    //   block [0x82EB5070..0x82EB50A8)
	// 82EB5070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB507C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5084: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5088: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82EB508C: 4BFFD6E5  bl 0x82eb2770
	ctx.lr = 0x82EB5090;
	sub_82EB2770(ctx, base);
	// 82EB5090: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB5094: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB5098: 808B0040  lwz r4, 0x40(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB509C: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB50A0: 40810054  ble 0x82eb50f4
	if !ctx.cr[0].gt {
	pc = 0x82EB50F4; continue 'dispatch;
	}
	// 82EB50A4: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EB50A8; continue 'dispatch;
            }
            0x82EB50A8 => {
    //   block [0x82EB50A8..0x82EB50B4)
	// 82EB50A8: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB50AC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EB50B0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	pc = 0x82EB50B4; continue 'dispatch;
            }
            0x82EB50B4 => {
    //   block [0x82EB50B4..0x82EB50D8)
	// 82EB50B4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB50B8: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB50BC: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB50C0: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EB50C4: 41820014  beq 0x82eb50d8
	if ctx.cr[0].eq {
	pc = 0x82EB50D8; continue 'dispatch;
	}
	// 82EB50C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB50CC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EB50D0: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EB50D4: 419AFFE0  beq cr6, 0x82eb50b4
	if ctx.cr[6].eq {
	pc = 0x82EB50B4; continue 'dispatch;
	}
	pc = 0x82EB50D8; continue 'dispatch;
            }
            0x82EB50D8 => {
    //   block [0x82EB50D8..0x82EB50F4)
	// 82EB50D8: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB50DC: 41820030  beq 0x82eb510c
	if ctx.cr[0].eq {
	pc = 0x82EB510C; continue 'dispatch;
	}
	// 82EB50E0: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB50E4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB50E8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB50EC: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB50F0: 4198FFB8  blt cr6, 0x82eb50a8
	if ctx.cr[6].lt {
	pc = 0x82EB50A8; continue 'dispatch;
	}
	pc = 0x82EB50F4; continue 'dispatch;
            }
            0x82EB50F4 => {
    //   block [0x82EB50F4..0x82EB510C)
	// 82EB50F4: 2B040010  cmplwi cr6, r4, 0x10
	ctx.cr[6].compare_u32(ctx.r[4].u32, 16 as u32, &mut ctx.xer);
	// 82EB50F8: 409A0020  bne cr6, 0x82eb5118
	if !ctx.cr[6].eq {
	pc = 0x82EB5118; continue 'dispatch;
	}
	// 82EB50FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB5100: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB5104: 994B0044  stb r10, 0x44(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 82EB5108: 48000028  b 0x82eb5130
	pc = 0x82EB5130; continue 'dispatch;
            }
            0x82EB510C => {
    //   block [0x82EB510C..0x82EB5118)
	// 82EB510C: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB5110: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EB5114: 48000018  b 0x82eb512c
	pc = 0x82EB512C; continue 'dispatch;
            }
            0x82EB5118 => {
    //   block [0x82EB5118..0x82EB512C)
	// 82EB5118: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB511C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EB5120: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB5124: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB5128: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	pc = 0x82EB512C; continue 'dispatch;
            }
            0x82EB512C => {
    //   block [0x82EB512C..0x82EB5130)
	// 82EB512C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EB5130; continue 'dispatch;
            }
            0x82EB5130 => {
    //   block [0x82EB5130..0x82EB5148)
	// 82EB5130: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB5134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB513C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB5140: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5144: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5148 size=216
    let mut pc: u32 = 0x82EB5148;
    'dispatch: loop {
        match pc {
            0x82EB5148 => {
    //   block [0x82EB5148..0x82EB5180)
	// 82EB5148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB514C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5150: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB5154: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5158: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB515C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5160: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82EB5164: 4BFFD685  bl 0x82eb27e8
	ctx.lr = 0x82EB5168;
	sub_82EB27E8(ctx, base);
	// 82EB5168: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB516C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB5170: 808B0040  lwz r4, 0x40(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB5174: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB5178: 40810054  ble 0x82eb51cc
	if !ctx.cr[0].gt {
	pc = 0x82EB51CC; continue 'dispatch;
	}
	// 82EB517C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EB5180; continue 'dispatch;
            }
            0x82EB5180 => {
    //   block [0x82EB5180..0x82EB518C)
	// 82EB5180: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5184: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EB5188: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	pc = 0x82EB518C; continue 'dispatch;
            }
            0x82EB518C => {
    //   block [0x82EB518C..0x82EB51B0)
	// 82EB518C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5190: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5194: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB5198: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EB519C: 41820014  beq 0x82eb51b0
	if ctx.cr[0].eq {
	pc = 0x82EB51B0; continue 'dispatch;
	}
	// 82EB51A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB51A4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EB51A8: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EB51AC: 419AFFE0  beq cr6, 0x82eb518c
	if ctx.cr[6].eq {
	pc = 0x82EB518C; continue 'dispatch;
	}
	pc = 0x82EB51B0; continue 'dispatch;
            }
            0x82EB51B0 => {
    //   block [0x82EB51B0..0x82EB51CC)
	// 82EB51B0: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB51B4: 41820030  beq 0x82eb51e4
	if ctx.cr[0].eq {
	pc = 0x82EB51E4; continue 'dispatch;
	}
	// 82EB51B8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB51BC: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB51C0: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB51C4: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB51C8: 4198FFB8  blt cr6, 0x82eb5180
	if ctx.cr[6].lt {
	pc = 0x82EB5180; continue 'dispatch;
	}
	pc = 0x82EB51CC; continue 'dispatch;
            }
            0x82EB51CC => {
    //   block [0x82EB51CC..0x82EB51E4)
	// 82EB51CC: 2B040010  cmplwi cr6, r4, 0x10
	ctx.cr[6].compare_u32(ctx.r[4].u32, 16 as u32, &mut ctx.xer);
	// 82EB51D0: 409A0020  bne cr6, 0x82eb51f0
	if !ctx.cr[6].eq {
	pc = 0x82EB51F0; continue 'dispatch;
	}
	// 82EB51D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB51D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB51DC: 994B0044  stb r10, 0x44(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 82EB51E0: 48000028  b 0x82eb5208
	pc = 0x82EB5208; continue 'dispatch;
            }
            0x82EB51E4 => {
    //   block [0x82EB51E4..0x82EB51F0)
	// 82EB51E4: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB51E8: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EB51EC: 48000018  b 0x82eb5204
	pc = 0x82EB5204; continue 'dispatch;
            }
            0x82EB51F0 => {
    //   block [0x82EB51F0..0x82EB5204)
	// 82EB51F0: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB51F4: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EB51F8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB51FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB5200: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	pc = 0x82EB5204; continue 'dispatch;
            }
            0x82EB5204 => {
    //   block [0x82EB5204..0x82EB5208)
	// 82EB5204: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EB5208; continue 'dispatch;
            }
            0x82EB5208 => {
    //   block [0x82EB5208..0x82EB5220)
	// 82EB5208: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB520C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5210: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5214: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB5218: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB521C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5220 size=132
    let mut pc: u32 = 0x82EB5220;
    'dispatch: loop {
        match pc {
            0x82EB5220 => {
    //   block [0x82EB5220..0x82EB524C)
	// 82EB5220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5228: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB522C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5230: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB5234: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5238: 392BAFB4  addi r9, r11, -0x504c
	ctx.r[9].s64 = ctx.r[11].s64 + -20556;
	// 82EB523C: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 82EB5240: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EB5244: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EB5248: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x82EB524C; continue 'dispatch;
            }
            0x82EB524C => {
    //   block [0x82EB524C..0x82EB527C)
	// 82EB524C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5250: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5254: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EB5258: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB525C: 4082FFF0  bne 0x82eb524c
	if !ctx.cr[0].eq {
	pc = 0x82EB524C; continue 'dispatch;
	}
	// 82EB5260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5264: 90BF0104  stw r5, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[5].u32 ) };
	// 82EB5268: 4BFFFE09  bl 0x82eb5070
	ctx.lr = 0x82EB526C;
	sub_82EB5070(ctx, base);
	// 82EB526C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5270: 4082000C  bne 0x82eb527c
	if !ctx.cr[0].eq {
	pc = 0x82EB527C; continue 'dispatch;
	}
	// 82EB5274: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB5278: 48000010  b 0x82eb5288
	pc = 0x82EB5288; continue 'dispatch;
            }
            0x82EB527C => {
    //   block [0x82EB527C..0x82EB5288)
	// 82EB527C: 4BFFD4F5  bl 0x82eb2770
	ctx.lr = 0x82EB5280;
	sub_82EB2770(ctx, base);
	// 82EB5280: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB5284: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EB5288; continue 'dispatch;
            }
            0x82EB5288 => {
    //   block [0x82EB5288..0x82EB52A4)
	// 82EB5288: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82EB528C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5290: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB5294: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5298: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB529C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB52A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB52A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB52A8 size=132
    let mut pc: u32 = 0x82EB52A8;
    'dispatch: loop {
        match pc {
            0x82EB52A8 => {
    //   block [0x82EB52A8..0x82EB52D4)
	// 82EB52A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB52AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB52B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB52B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB52B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB52BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB52C0: 392BAFB4  addi r9, r11, -0x504c
	ctx.r[9].s64 = ctx.r[11].s64 + -20556;
	// 82EB52C4: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 82EB52C8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EB52CC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EB52D0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x82EB52D4; continue 'dispatch;
            }
            0x82EB52D4 => {
    //   block [0x82EB52D4..0x82EB5304)
	// 82EB52D4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB52D8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB52DC: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EB52E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB52E4: 4082FFF0  bne 0x82eb52d4
	if !ctx.cr[0].eq {
	pc = 0x82EB52D4; continue 'dispatch;
	}
	// 82EB52E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB52EC: 90BF0104  stw r5, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[5].u32 ) };
	// 82EB52F0: 4BFFFE59  bl 0x82eb5148
	ctx.lr = 0x82EB52F4;
	sub_82EB5148(ctx, base);
	// 82EB52F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB52F8: 4082000C  bne 0x82eb5304
	if !ctx.cr[0].eq {
	pc = 0x82EB5304; continue 'dispatch;
	}
	// 82EB52FC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB5300: 48000010  b 0x82eb5310
	pc = 0x82EB5310; continue 'dispatch;
            }
            0x82EB5304 => {
    //   block [0x82EB5304..0x82EB5310)
	// 82EB5304: 4BFFD4E5  bl 0x82eb27e8
	ctx.lr = 0x82EB5308;
	sub_82EB27E8(ctx, base);
	// 82EB5308: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB530C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EB5310; continue 'dispatch;
            }
            0x82EB5310 => {
    //   block [0x82EB5310..0x82EB532C)
	// 82EB5310: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82EB5314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5318: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB531C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5320: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5324: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5330 size=148
    let mut pc: u32 = 0x82EB5330;
    'dispatch: loop {
        match pc {
            0x82EB5330 => {
    //   block [0x82EB5330..0x82EB5364)
	// 82EB5330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5338: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB533C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5344: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EB5348: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB534C: 394AA7C0  addi r10, r10, -0x5840
	ctx.r[10].s64 = ctx.r[10].s64 + -22592;
	// 82EB5350: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EB5354: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82EB5358: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82EB535C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB5360: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82EB5364; continue 'dispatch;
            }
            0x82EB5364 => {
    //   block [0x82EB5364..0x82EB5390)
	// 82EB5364: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5368: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB536C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB5370: 409AFFF4  bne cr6, 0x82eb5364
	if !ctx.cr[6].eq {
	pc = 0x82EB5364; continue 'dispatch;
	}
	// 82EB5374: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EB5378: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB537C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB5380: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82EB5384: 4B7615A5  bl 0x82616928
	ctx.lr = 0x82EB5388;
	sub_82616928(ctx, base);
	// 82EB5388: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB538C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x82EB5390; continue 'dispatch;
            }
            0x82EB5390 => {
    //   block [0x82EB5390..0x82EB53C4)
	// 82EB5390: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5394: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EB5398: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB539C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EB53A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB53A4: 4082FFEC  bne 0x82eb5390
	if !ctx.cr[0].eq {
	pc = 0x82EB5390; continue 'dispatch;
	}
	// 82EB53A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB53AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB53B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB53B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB53B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB53BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB53C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB53C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB53C8 size=84
    let mut pc: u32 = 0x82EB53C8;
    'dispatch: loop {
        match pc {
            0x82EB53C8 => {
    //   block [0x82EB53C8..0x82EB541C)
	// 82EB53C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB53CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB53D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB53D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB53D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB53DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB53E0: 396BA7C0  addi r11, r11, -0x5840
	ctx.r[11].s64 = ctx.r[11].s64 + -22592;
	// 82EB53E4: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82EB53E8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB53EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB53F0: 816ADAB4  lwz r11, -0x254c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB53F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB53F8: 4E800421  bctrl
	ctx.lr = 0x82EB53FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB53FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB5400: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB5404: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB5408: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB540C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5414: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5418: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5420 size=88
    let mut pc: u32 = 0x82EB5420;
    'dispatch: loop {
        match pc {
            0x82EB5420 => {
    //   block [0x82EB5420..0x82EB545C)
	// 82EB5420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5428: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB542C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5430: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EB5434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5438: 48306C29  bl 0x831bc060
	ctx.lr = 0x82EB543C;
	sub_831BC060(ctx, base);
	// 82EB543C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5440: 4182001C  beq 0x82eb545c
	if ctx.cr[0].eq {
	pc = 0x82EB545C; continue 'dispatch;
	}
	// 82EB5444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5448: 48306C19  bl 0x831bc060
	ctx.lr = 0x82EB544C;
	sub_831BC060(ctx, base);
	// 82EB544C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5450: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82EB5454: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB5458: 419A0008  beq cr6, 0x82eb5460
	if ctx.cr[6].eq {
	pc = 0x82EB5460; continue 'dispatch;
	}
	pc = 0x82EB545C; continue 'dispatch;
            }
            0x82EB545C => {
    //   block [0x82EB545C..0x82EB5460)
	// 82EB545C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EB5460; continue 'dispatch;
            }
            0x82EB5460 => {
    //   block [0x82EB5460..0x82EB5478)
	// 82EB5460: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EB5464: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB5468: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB546C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5470: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5474: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5478 size=12
    let mut pc: u32 = 0x82EB5478;
    'dispatch: loop {
        match pc {
            0x82EB5478 => {
    //   block [0x82EB5478..0x82EB5484)
	// 82EB5478: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB547C: 386BE058  addi r3, r11, -0x1fa8
	ctx.r[3].s64 = ctx.r[11].s64 + -8104;
	// 82EB5480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5488 size=12
    let mut pc: u32 = 0x82EB5488;
    'dispatch: loop {
        match pc {
            0x82EB5488 => {
    //   block [0x82EB5488..0x82EB5494)
	// 82EB5488: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB548C: 386BDD1C  addi r3, r11, -0x22e4
	ctx.r[3].s64 = ctx.r[11].s64 + -8932;
	// 82EB5490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5498 size=12
    let mut pc: u32 = 0x82EB5498;
    'dispatch: loop {
        match pc {
            0x82EB5498 => {
    //   block [0x82EB5498..0x82EB54A4)
	// 82EB5498: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB549C: 386BDAF4  addi r3, r11, -0x250c
	ctx.r[3].s64 = ctx.r[11].s64 + -9484;
	// 82EB54A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB54A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB54A8 size=92
    let mut pc: u32 = 0x82EB54A8;
    'dispatch: loop {
        match pc {
            0x82EB54A8 => {
    //   block [0x82EB54A8..0x82EB5504)
	// 82EB54A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB54AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB54B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB54B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB54B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB54BC: 4BFFFE75  bl 0x82eb5330
	ctx.lr = 0x82EB54C0;
	sub_82EB5330(ctx, base);
	// 82EB54C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB54C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB54C8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB54CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB54D0: 396BA818  addi r11, r11, -0x57e8
	ctx.r[11].s64 = ctx.r[11].s64 + -22504;
	// 82EB54D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB54D8: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EB54DC: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EB54E0: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EB54E4: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EB54E8: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EB54EC: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EB54F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB54F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB54F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB54FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5500: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5508 size=12
    let mut pc: u32 = 0x82EB5508;
    'dispatch: loop {
        match pc {
            0x82EB5508 => {
    //   block [0x82EB5508..0x82EB5514)
	// 82EB5508: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB550C: 386BD9E0  addi r3, r11, -0x2620
	ctx.r[3].s64 = ctx.r[11].s64 + -9760;
	// 82EB5510: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5518 size=12
    let mut pc: u32 = 0x82EB5518;
    'dispatch: loop {
        match pc {
            0x82EB5518 => {
    //   block [0x82EB5518..0x82EB5524)
	// 82EB5518: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB551C: 386BD6A4  addi r3, r11, -0x295c
	ctx.r[3].s64 = ctx.r[11].s64 + -10588;
	// 82EB5520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5528 size=12
    let mut pc: u32 = 0x82EB5528;
    'dispatch: loop {
        match pc {
            0x82EB5528 => {
    //   block [0x82EB5528..0x82EB5534)
	// 82EB5528: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB552C: 386BD8CC  addi r3, r11, -0x2734
	ctx.r[3].s64 = ctx.r[11].s64 + -10036;
	// 82EB5530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5538 size=88
    let mut pc: u32 = 0x82EB5538;
    'dispatch: loop {
        match pc {
            0x82EB5538 => {
    //   block [0x82EB5538..0x82EB5590)
	// 82EB5538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB553C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5540: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5544: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5548: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB554C: 4BFFFDE5  bl 0x82eb5330
	ctx.lr = 0x82EB5550;
	sub_82EB5330(ctx, base);
	// 82EB5550: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB5554: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB5558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB555C: 396BA86C  addi r11, r11, -0x5794
	ctx.r[11].s64 = ctx.r[11].s64 + -22420;
	// 82EB5560: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5564: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB5568: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB556C: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EB5570: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EB5574: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EB5578: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EB557C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB5580: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5584: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5588: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB558C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5590 size=12
    let mut pc: u32 = 0x82EB5590;
    'dispatch: loop {
        match pc {
            0x82EB5590 => {
    //   block [0x82EB5590..0x82EB559C)
	// 82EB5590: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB5594: 386BD244  addi r3, r11, -0x2dbc
	ctx.r[3].s64 = ctx.r[11].s64 + -11708;
	// 82EB5598: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


