pub fn sub_82EEBD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEBD50 size=168
    let mut pc: u32 = 0x82EEBD50;
    'dispatch: loop {
        match pc {
            0x82EEBD50 => {
    //   block [0x82EEBD50..0x82EEBDC0)
	// 82EEBD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEBD54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEBD58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEBD5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEBD60: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEBD64: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEBD68: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBD6C: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBD70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBD74: 409A004C  bne cr6, 0x82eebdc0
	if !ctx.cr[6].eq {
	pc = 0x82EEBDC0; continue 'dispatch;
	}
	// 82EEBD78: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBD7C: 896B8F5C  lbz r11, -0x70a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28836 as u32) ) } as u64;
	// 82EEBD80: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEBD84: 4082003C  bne 0x82eebdc0
	if !ctx.cr[0].eq {
	pc = 0x82EEBDC0; continue 'dispatch;
	}
	// 82EEBD88: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBD8C: 3BEB8F5C  addi r31, r11, -0x70a4
	ctx.r[31].s64 = ctx.r[11].s64 + -28836;
	// 82EEBD90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBD94: 38CBC228  addi r6, r11, -0x3dd8
	ctx.r[6].s64 = ctx.r[11].s64 + -15832;
	// 82EEBD98: 38A00036  li r5, 0x36
	ctx.r[5].s64 = 54;
	// 82EEBD9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBDA0: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEBDA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEBDA8: 4BFFF3C1  bl 0x82eeb168
	ctx.lr = 0x82EEBDAC;
	sub_82EEB168(ctx, base);
	// 82EEBDAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEBDB0: 48206009  bl 0x830f1db8
	ctx.lr = 0x82EEBDB4;
	sub_830F1DB8(ctx, base);
	// 82EEBDB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEBDB8: 40820008  bne 0x82eebdc0
	if !ctx.cr[0].eq {
	pc = 0x82EEBDC0; continue 'dispatch;
	}
	// 82EEBDBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEBDC0; continue 'dispatch;
            }
            0x82EEBDC0 => {
    //   block [0x82EEBDC0..0x82EEBDF8)
	// 82EEBDC0: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEBDC4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBDC8: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBDCC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBDD0: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEBDD4: 806A8F50  lwz r3, -0x70b0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBDD8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEBDDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEBDE0: 4E800421  bctrl
	ctx.lr = 0x82EEBDE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEBDE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEBDE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEBDEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEBDF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEBDF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEBDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEBDF8 size=168
    let mut pc: u32 = 0x82EEBDF8;
    'dispatch: loop {
        match pc {
            0x82EEBDF8 => {
    //   block [0x82EEBDF8..0x82EEBE68)
	// 82EEBDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEBDFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEBE00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEBE04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEBE08: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEBE0C: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEBE10: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBE14: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBE18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBE1C: 409A004C  bne cr6, 0x82eebe68
	if !ctx.cr[6].eq {
	pc = 0x82EEBE68; continue 'dispatch;
	}
	// 82EEBE20: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBE24: 896B8F5D  lbz r11, -0x70a3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28835 as u32) ) } as u64;
	// 82EEBE28: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEBE2C: 4082003C  bne 0x82eebe68
	if !ctx.cr[0].eq {
	pc = 0x82EEBE68; continue 'dispatch;
	}
	// 82EEBE30: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBE34: 3BEB8F5D  addi r31, r11, -0x70a3
	ctx.r[31].s64 = ctx.r[11].s64 + -28835;
	// 82EEBE38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBE3C: 38CBC228  addi r6, r11, -0x3dd8
	ctx.r[6].s64 = ctx.r[11].s64 + -15832;
	// 82EEBE40: 38A0003C  li r5, 0x3c
	ctx.r[5].s64 = 60;
	// 82EEBE44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBE48: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEBE4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEBE50: 4BFFF319  bl 0x82eeb168
	ctx.lr = 0x82EEBE54;
	sub_82EEB168(ctx, base);
	// 82EEBE54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEBE58: 48205F61  bl 0x830f1db8
	ctx.lr = 0x82EEBE5C;
	sub_830F1DB8(ctx, base);
	// 82EEBE5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEBE60: 40820008  bne 0x82eebe68
	if !ctx.cr[0].eq {
	pc = 0x82EEBE68; continue 'dispatch;
	}
	// 82EEBE64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEBE68; continue 'dispatch;
            }
            0x82EEBE68 => {
    //   block [0x82EEBE68..0x82EEBEA0)
	// 82EEBE68: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEBE6C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBE70: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBE74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBE78: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEBE7C: 806A8F50  lwz r3, -0x70b0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBE80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBE84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEBE88: 4E800421  bctrl
	ctx.lr = 0x82EEBE8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEBE8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEBE90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEBE94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEBE98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEBE9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEBEA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEBEA0 size=176
    let mut pc: u32 = 0x82EEBEA0;
    'dispatch: loop {
        match pc {
            0x82EEBEA0 => {
    //   block [0x82EEBEA0..0x82EEBF14)
	// 82EEBEA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEBEA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEBEA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEBEAC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEBEB0: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEBEB4: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEBEB8: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82EEBEBC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBEC0: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBEC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBEC8: 409A004C  bne cr6, 0x82eebf14
	if !ctx.cr[6].eq {
	pc = 0x82EEBF14; continue 'dispatch;
	}
	// 82EEBECC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBED0: 896B8F5E  lbz r11, -0x70a2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28834 as u32) ) } as u64;
	// 82EEBED4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEBED8: 4082003C  bne 0x82eebf14
	if !ctx.cr[0].eq {
	pc = 0x82EEBF14; continue 'dispatch;
	}
	// 82EEBEDC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBEE0: 3BEB8F5E  addi r31, r11, -0x70a2
	ctx.r[31].s64 = ctx.r[11].s64 + -28834;
	// 82EEBEE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBEE8: 38CBC228  addi r6, r11, -0x3dd8
	ctx.r[6].s64 = ctx.r[11].s64 + -15832;
	// 82EEBEEC: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 82EEBEF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBEF4: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEBEF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEBEFC: 4BFFF26D  bl 0x82eeb168
	ctx.lr = 0x82EEBF00;
	sub_82EEB168(ctx, base);
	// 82EEBF00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEBF04: 48205EB5  bl 0x830f1db8
	ctx.lr = 0x82EEBF08;
	sub_830F1DB8(ctx, base);
	// 82EEBF08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEBF0C: 40820008  bne 0x82eebf14
	if !ctx.cr[0].eq {
	pc = 0x82EEBF14; continue 'dispatch;
	}
	// 82EEBF10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEBF14; continue 'dispatch;
            }
            0x82EEBF14 => {
    //   block [0x82EEBF14..0x82EEBF50)
	// 82EEBF14: 80A10094  lwz r5, 0x94(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEBF18: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEBF1C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBF20: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBF24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBF28: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEBF2C: 806A8F50  lwz r3, -0x70b0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEBF30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEBF34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEBF38: 4E800421  bctrl
	ctx.lr = 0x82EEBF3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEBF3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEBF40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEBF44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEBF48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEBF4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEBF50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEBF50 size=168
    let mut pc: u32 = 0x82EEBF50;
    'dispatch: loop {
        match pc {
            0x82EEBF50 => {
    //   block [0x82EEBF50..0x82EEBFC0)
	// 82EEBF50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEBF54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEBF58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEBF5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEBF60: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEBF64: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEBF68: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBF6C: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEBF70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEBF74: 409A004C  bne cr6, 0x82eebfc0
	if !ctx.cr[6].eq {
	pc = 0x82EEBFC0; continue 'dispatch;
	}
	// 82EEBF78: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBF7C: 896B8F5F  lbz r11, -0x70a1(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28833 as u32) ) } as u64;
	// 82EEBF80: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEBF84: 4082003C  bne 0x82eebfc0
	if !ctx.cr[0].eq {
	pc = 0x82EEBFC0; continue 'dispatch;
	}
	// 82EEBF88: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBF8C: 3BEB8F5F  addi r31, r11, -0x70a1
	ctx.r[31].s64 = ctx.r[11].s64 + -28833;
	// 82EEBF90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBF94: 38CBC244  addi r6, r11, -0x3dbc
	ctx.r[6].s64 = ctx.r[11].s64 + -15804;
	// 82EEBF98: 38A0004D  li r5, 0x4d
	ctx.r[5].s64 = 77;
	// 82EEBF9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEBFA0: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEBFA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEBFA8: 4BFFF1C1  bl 0x82eeb168
	ctx.lr = 0x82EEBFAC;
	sub_82EEB168(ctx, base);
	// 82EEBFAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEBFB0: 48205E09  bl 0x830f1db8
	ctx.lr = 0x82EEBFB4;
	sub_830F1DB8(ctx, base);
	// 82EEBFB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEBFB8: 40820008  bne 0x82eebfc0
	if !ctx.cr[0].eq {
	pc = 0x82EEBFC0; continue 'dispatch;
	}
	// 82EEBFBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEBFC0; continue 'dispatch;
            }
            0x82EEBFC0 => {
    //   block [0x82EEBFC0..0x82EEBFF8)
	// 82EEBFC0: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEBFC4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEBFC8: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEBFCC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBFD0: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEBFD4: 806A8F54  lwz r3, -0x70ac(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEBFD8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEBFDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEBFE0: 4E800421  bctrl
	ctx.lr = 0x82EEBFE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEBFE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEBFE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEBFEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEBFF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEBFF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEBFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEBFF8 size=168
    let mut pc: u32 = 0x82EEBFF8;
    'dispatch: loop {
        match pc {
            0x82EEBFF8 => {
    //   block [0x82EEBFF8..0x82EEC068)
	// 82EEBFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEBFFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC000: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEC004: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC008: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEC00C: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEC010: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC014: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC01C: 409A004C  bne cr6, 0x82eec068
	if !ctx.cr[6].eq {
	pc = 0x82EEC068; continue 'dispatch;
	}
	// 82EEC020: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC024: 896B8F60  lbz r11, -0x70a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28832 as u32) ) } as u64;
	// 82EEC028: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEC02C: 4082003C  bne 0x82eec068
	if !ctx.cr[0].eq {
	pc = 0x82EEC068; continue 'dispatch;
	}
	// 82EEC030: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC034: 3BEB8F60  addi r31, r11, -0x70a0
	ctx.r[31].s64 = ctx.r[11].s64 + -28832;
	// 82EEC038: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC03C: 38CBC244  addi r6, r11, -0x3dbc
	ctx.r[6].s64 = ctx.r[11].s64 + -15804;
	// 82EEC040: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 82EEC044: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC048: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEC04C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEC050: 4BFFF119  bl 0x82eeb168
	ctx.lr = 0x82EEC054;
	sub_82EEB168(ctx, base);
	// 82EEC054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEC058: 48205D61  bl 0x830f1db8
	ctx.lr = 0x82EEC05C;
	sub_830F1DB8(ctx, base);
	// 82EEC05C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC060: 40820008  bne 0x82eec068
	if !ctx.cr[0].eq {
	pc = 0x82EEC068; continue 'dispatch;
	}
	// 82EEC064: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEC068; continue 'dispatch;
            }
            0x82EEC068 => {
    //   block [0x82EEC068..0x82EEC0A0)
	// 82EEC068: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEC06C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC070: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC074: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEC078: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEC07C: 806A8F54  lwz r3, -0x70ac(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC080: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEC084: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEC088: 4E800421  bctrl
	ctx.lr = 0x82EEC08C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEC08C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEC090: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC094: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC098: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEC09C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC0A0 size=160
    let mut pc: u32 = 0x82EEC0A0;
    'dispatch: loop {
        match pc {
            0x82EEC0A0 => {
    //   block [0x82EEC0A0..0x82EEC10C)
	// 82EEC0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC0A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC0A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEC0AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC0B0: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEC0B4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC0B8: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC0BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC0C0: 409A004C  bne cr6, 0x82eec10c
	if !ctx.cr[6].eq {
	pc = 0x82EEC10C; continue 'dispatch;
	}
	// 82EEC0C4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC0C8: 896B8F61  lbz r11, -0x709f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28831 as u32) ) } as u64;
	// 82EEC0CC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEC0D0: 4082003C  bne 0x82eec10c
	if !ctx.cr[0].eq {
	pc = 0x82EEC10C; continue 'dispatch;
	}
	// 82EEC0D4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC0D8: 3BEB8F61  addi r31, r11, -0x709f
	ctx.r[31].s64 = ctx.r[11].s64 + -28831;
	// 82EEC0DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC0E0: 38CBC244  addi r6, r11, -0x3dbc
	ctx.r[6].s64 = ctx.r[11].s64 + -15804;
	// 82EEC0E4: 38A00059  li r5, 0x59
	ctx.r[5].s64 = 89;
	// 82EEC0E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC0EC: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEC0F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEC0F4: 4BFFF075  bl 0x82eeb168
	ctx.lr = 0x82EEC0F8;
	sub_82EEB168(ctx, base);
	// 82EEC0F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEC0FC: 48205CBD  bl 0x830f1db8
	ctx.lr = 0x82EEC100;
	sub_830F1DB8(ctx, base);
	// 82EEC100: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC104: 40820008  bne 0x82eec10c
	if !ctx.cr[0].eq {
	pc = 0x82EEC10C; continue 'dispatch;
	}
	// 82EEC108: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEC10C; continue 'dispatch;
            }
            0x82EEC10C => {
    //   block [0x82EEC10C..0x82EEC140)
	// 82EEC10C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC110: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC114: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEC118: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEC11C: 806A8F54  lwz r3, -0x70ac(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC120: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEC124: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEC128: 4E800421  bctrl
	ctx.lr = 0x82EEC12C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEC12C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEC130: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC134: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC138: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEC13C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC140 size=168
    let mut pc: u32 = 0x82EEC140;
    'dispatch: loop {
        match pc {
            0x82EEC140 => {
    //   block [0x82EEC140..0x82EEC1B0)
	// 82EEC140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC148: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEC14C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC150: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEC154: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEC158: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC15C: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC164: 409A004C  bne cr6, 0x82eec1b0
	if !ctx.cr[6].eq {
	pc = 0x82EEC1B0; continue 'dispatch;
	}
	// 82EEC168: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC16C: 896B8F62  lbz r11, -0x709e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28830 as u32) ) } as u64;
	// 82EEC170: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEC174: 4082003C  bne 0x82eec1b0
	if !ctx.cr[0].eq {
	pc = 0x82EEC1B0; continue 'dispatch;
	}
	// 82EEC178: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC17C: 3BEB8F62  addi r31, r11, -0x709e
	ctx.r[31].s64 = ctx.r[11].s64 + -28830;
	// 82EEC180: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC184: 38CBC244  addi r6, r11, -0x3dbc
	ctx.r[6].s64 = ctx.r[11].s64 + -15804;
	// 82EEC188: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 82EEC18C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC190: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEC194: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEC198: 4BFFEFD1  bl 0x82eeb168
	ctx.lr = 0x82EEC19C;
	sub_82EEB168(ctx, base);
	// 82EEC19C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEC1A0: 48205C19  bl 0x830f1db8
	ctx.lr = 0x82EEC1A4;
	sub_830F1DB8(ctx, base);
	// 82EEC1A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC1A8: 40820008  bne 0x82eec1b0
	if !ctx.cr[0].eq {
	pc = 0x82EEC1B0; continue 'dispatch;
	}
	// 82EEC1AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEC1B0; continue 'dispatch;
            }
            0x82EEC1B0 => {
    //   block [0x82EEC1B0..0x82EEC1E8)
	// 82EEC1B0: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEC1B4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC1B8: 816B8F54  lwz r11, -0x70ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC1BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEC1C0: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEC1C4: 806A8F54  lwz r3, -0x70ac(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28844 as u32) ) } as u64;
	// 82EEC1C8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEC1CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEC1D0: 4E800421  bctrl
	ctx.lr = 0x82EEC1D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEC1D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEC1D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC1DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC1E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEC1E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC1E8 size=184
    let mut pc: u32 = 0x82EEC1E8;
    'dispatch: loop {
        match pc {
            0x82EEC1E8 => {
    //   block [0x82EEC1E8..0x82EEC2A0)
	// 82EEC1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC1EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC1F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC1F4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC1F8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC1FC: 480000ED  bl 0x82eec2e8
	ctx.lr = 0x82EEC200;
	sub_82EEC2E8(ctx, base);
	// 82EEC200: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC204: 396BC260  addi r11, r11, -0x3da0
	ctx.r[11].s64 = ctx.r[11].s64 + -15776;
	// 82EEC208: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC20C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC210: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC214: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEC218: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEC21C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC220: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EEC224: 48000145  bl 0x82eec368
	ctx.lr = 0x82EEC228;
	sub_82EEC368(ctx, base);
	// 82EEC228: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC22C: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEC230: 48000179  bl 0x82eec3a8
	ctx.lr = 0x82EEC234;
	sub_82EEC3A8(ctx, base);
	// 82EEC234: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC238: 38AB000C  addi r5, r11, 0xc
	ctx.r[5].s64 = ctx.r[11].s64 + 12;
	// 82EEC23C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC240: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 82EEC244: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC248: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EEC24C: 48101265  bl 0x82fed4b0
	ctx.lr = 0x82EEC250;
	sub_82FED4B0(ctx, base);
	// 82EEC250: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC254: 386B0054  addi r3, r11, 0x54
	ctx.r[3].s64 = ctx.r[11].s64 + 84;
	// 82EEC258: 482056D1  bl 0x830f1928
	ctx.lr = 0x82EEC25C;
	sub_830F1928(ctx, base);
	// 82EEC25C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC260: 386B005C  addi r3, r11, 0x5c
	ctx.r[3].s64 = ctx.r[11].s64 + 92;
	// 82EEC264: 482056C5  bl 0x830f1928
	ctx.lr = 0x82EEC268;
	sub_830F1928(ctx, base);
	// 82EEC268: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC26C: 386B0064  addi r3, r11, 0x64
	ctx.r[3].s64 = ctx.r[11].s64 + 100;
	// 82EEC270: 48000179  bl 0x82eec3e8
	ctx.lr = 0x82EEC274;
	sub_82EEC3E8(ctx, base);
	// 82EEC274: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC278: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EEC27C: 914B02EC  stw r10, 0x2ec(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(748 as u32), ctx.r[10].u32 ) };
	// 82EEC280: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC284: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EEC288: 48001919  bl 0x82eedba0
	ctx.lr = 0x82EEC28C;
	sub_82EEDBA0(ctx, base);
	// 82EEC28C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC290: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC294: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC298: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC29C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC2A0 size=68
    let mut pc: u32 = 0x82EEC2A0;
    'dispatch: loop {
        match pc {
            0x82EEC2A0 => {
    //   block [0x82EEC2A0..0x82EEC2D0)
	// 82EEC2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC2A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC2A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC2AC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC2B0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEC2B4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC2B8: 48000291  bl 0x82eec548
	ctx.lr = 0x82EEC2BC;
	sub_82EEC548(ctx, base);
	// 82EEC2BC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEC2C0: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC2C4: 4182000C  beq 0x82eec2d0
	if ctx.cr[0].eq {
	pc = 0x82EEC2D0; continue 'dispatch;
	}
	// 82EEC2C8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC2CC: 4B9594E5  bl 0x828457b0
	ctx.lr = 0x82EEC2D0;
	sub_828457B0(ctx, base);
	pc = 0x82EEC2D0; continue 'dispatch;
            }
            0x82EEC2D0 => {
    //   block [0x82EEC2D0..0x82EEC2E4)
	// 82EEC2D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC2D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC2D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC2DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC2E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEC2E8 size=28
    let mut pc: u32 = 0x82EEC2E8;
    'dispatch: loop {
        match pc {
            0x82EEC2E8 => {
    //   block [0x82EEC2E8..0x82EEC304)
	// 82EEC2E8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEC2EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC2F0: 396BC278  addi r11, r11, -0x3d88
	ctx.r[11].s64 = ctx.r[11].s64 + -15752;
	// 82EEC2F4: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC2F8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC2FC: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC300: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC308 size=68
    let mut pc: u32 = 0x82EEC308;
    'dispatch: loop {
        match pc {
            0x82EEC308 => {
    //   block [0x82EEC308..0x82EEC338)
	// 82EEC308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC30C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC310: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC314: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC318: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEC31C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC320: 48000031  bl 0x82eec350
	ctx.lr = 0x82EEC324;
	sub_82EEC350(ctx, base);
	// 82EEC324: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEC328: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC32C: 4182000C  beq 0x82eec338
	if ctx.cr[0].eq {
	pc = 0x82EEC338; continue 'dispatch;
	}
	// 82EEC330: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC334: 4B95947D  bl 0x828457b0
	ctx.lr = 0x82EEC338;
	sub_828457B0(ctx, base);
	pc = 0x82EEC338; continue 'dispatch;
            }
            0x82EEC338 => {
    //   block [0x82EEC338..0x82EEC34C)
	// 82EEC338: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC33C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC340: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC344: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEC350 size=24
    let mut pc: u32 = 0x82EEC350;
    'dispatch: loop {
        match pc {
            0x82EEC350 => {
    //   block [0x82EEC350..0x82EEC368)
	// 82EEC350: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEC354: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC358: 396BC278  addi r11, r11, -0x3d88
	ctx.r[11].s64 = ctx.r[11].s64 + -15752;
	// 82EEC35C: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC360: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC364: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC368 size=60
    let mut pc: u32 = 0x82EEC368;
    'dispatch: loop {
        match pc {
            0x82EEC368 => {
    //   block [0x82EEC368..0x82EEC3A4)
	// 82EEC368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC36C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC370: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC374: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC378: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC37C: 4800011D  bl 0x82eec498
	ctx.lr = 0x82EEC380;
	sub_82EEC498(ctx, base);
	// 82EEC380: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC384: 396BC290  addi r11, r11, -0x3d70
	ctx.r[11].s64 = ctx.r[11].s64 + -15728;
	// 82EEC388: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC38C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC390: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC394: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC398: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC39C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC3A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC3A8 size=60
    let mut pc: u32 = 0x82EEC3A8;
    'dispatch: loop {
        match pc {
            0x82EEC3A8 => {
    //   block [0x82EEC3A8..0x82EEC3E4)
	// 82EEC3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC3AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC3B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC3B4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC3B8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC3BC: 4800016D  bl 0x82eec528
	ctx.lr = 0x82EEC3C0;
	sub_82EEC528(ctx, base);
	// 82EEC3C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC3C4: 396BC2AC  addi r11, r11, -0x3d54
	ctx.r[11].s64 = ctx.r[11].s64 + -15700;
	// 82EEC3C8: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC3CC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC3D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC3D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC3D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC3DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC3E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC3E8 size=60
    let mut pc: u32 = 0x82EEC3E8;
    'dispatch: loop {
        match pc {
            0x82EEC3E8 => {
    //   block [0x82EEC3E8..0x82EEC424)
	// 82EEC3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC3F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC3F4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC3F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEC3FC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC400: 48001AA9  bl 0x82eedea8
	ctx.lr = 0x82EEC404;
	sub_82EEDEA8(ctx, base);
	// 82EEC404: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC408: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EEC40C: 48000DC5  bl 0x82eed1d0
	ctx.lr = 0x82EEC410;
	sub_82EED1D0(ctx, base);
	// 82EEC410: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC414: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC418: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC41C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC428 size=68
    let mut pc: u32 = 0x82EEC428;
    'dispatch: loop {
        match pc {
            0x82EEC428 => {
    //   block [0x82EEC428..0x82EEC458)
	// 82EEC428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC42C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC430: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC434: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC438: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEC43C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC440: 48000031  bl 0x82eec470
	ctx.lr = 0x82EEC444;
	sub_82EEC470(ctx, base);
	// 82EEC444: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEC448: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC44C: 4182000C  beq 0x82eec458
	if ctx.cr[0].eq {
	pc = 0x82EEC458; continue 'dispatch;
	}
	// 82EEC450: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC454: 4B95935D  bl 0x828457b0
	ctx.lr = 0x82EEC458;
	sub_828457B0(ctx, base);
	pc = 0x82EEC458; continue 'dispatch;
            }
            0x82EEC458 => {
    //   block [0x82EEC458..0x82EEC46C)
	// 82EEC458: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC45C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC460: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC464: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC470 size=40
    let mut pc: u32 = 0x82EEC470;
    'dispatch: loop {
        match pc {
            0x82EEC470 => {
    //   block [0x82EEC470..0x82EEC498)
	// 82EEC470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC478: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC47C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC480: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC484: 4800163D  bl 0x82eedac0
	ctx.lr = 0x82EEC488;
	sub_82EEDAC0(ctx, base);
	// 82EEC488: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC48C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC490: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEC498 size=28
    let mut pc: u32 = 0x82EEC498;
    'dispatch: loop {
        match pc {
            0x82EEC498 => {
    //   block [0x82EEC498..0x82EEC4B4)
	// 82EEC498: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEC49C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC4A0: 396BC2C0  addi r11, r11, -0x3d40
	ctx.r[11].s64 = ctx.r[11].s64 + -15680;
	// 82EEC4A4: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC4A8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC4AC: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC4B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC4B8 size=68
    let mut pc: u32 = 0x82EEC4B8;
    'dispatch: loop {
        match pc {
            0x82EEC4B8 => {
    //   block [0x82EEC4B8..0x82EEC4E8)
	// 82EEC4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC4BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC4C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC4C4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC4C8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEC4CC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC4D0: 48000031  bl 0x82eec500
	ctx.lr = 0x82EEC4D4;
	sub_82EEC500(ctx, base);
	// 82EEC4D4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEC4D8: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC4DC: 4182000C  beq 0x82eec4e8
	if ctx.cr[0].eq {
	pc = 0x82EEC4E8; continue 'dispatch;
	}
	// 82EEC4E0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC4E4: 4B9592CD  bl 0x828457b0
	ctx.lr = 0x82EEC4E8;
	sub_828457B0(ctx, base);
	pc = 0x82EEC4E8; continue 'dispatch;
            }
            0x82EEC4E8 => {
    //   block [0x82EEC4E8..0x82EEC4FC)
	// 82EEC4E8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC4EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC4F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC4F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC4F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC500 size=40
    let mut pc: u32 = 0x82EEC500;
    'dispatch: loop {
        match pc {
            0x82EEC500 => {
    //   block [0x82EEC500..0x82EEC528)
	// 82EEC500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC508: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC50C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC510: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC514: 4800154D  bl 0x82eeda60
	ctx.lr = 0x82EEC518;
	sub_82EEDA60(ctx, base);
	// 82EEC518: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC51C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC520: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEC528 size=28
    let mut pc: u32 = 0x82EEC528;
    'dispatch: loop {
        match pc {
            0x82EEC528 => {
    //   block [0x82EEC528..0x82EEC544)
	// 82EEC528: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEC52C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC530: 396BC2DC  addi r11, r11, -0x3d24
	ctx.r[11].s64 = ctx.r[11].s64 + -15652;
	// 82EEC534: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC538: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC53C: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC540: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC548 size=160
    let mut pc: u32 = 0x82EEC548;
    'dispatch: loop {
        match pc {
            0x82EEC548 => {
    //   block [0x82EEC548..0x82EEC588)
	// 82EEC548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC54C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC550: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC554: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC558: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC55C: 396BC260  addi r11, r11, -0x3da0
	ctx.r[11].s64 = ctx.r[11].s64 + -15776;
	// 82EEC560: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC564: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEC568: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC56C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EEC570: 48001601  bl 0x82eedb70
	ctx.lr = 0x82EEC574;
	sub_82EEDB70(ctx, base);
	// 82EEC574: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC578: 41820010  beq 0x82eec588
	if ctx.cr[0].eq {
	pc = 0x82EEC588; continue 'dispatch;
	}
	// 82EEC57C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC580: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EEC584: 4810101D  bl 0x82fed5a0
	ctx.lr = 0x82EEC588;
	sub_82FED5A0(ctx, base);
	pc = 0x82EEC588; continue 'dispatch;
            }
            0x82EEC588 => {
    //   block [0x82EEC588..0x82EEC5E8)
	// 82EEC588: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC58C: 386B0064  addi r3, r11, 0x64
	ctx.r[3].s64 = ctx.r[11].s64 + 100;
	// 82EEC590: 48003AC9  bl 0x82ef0058
	ctx.lr = 0x82EEC594;
	sub_82EF0058(ctx, base);
	// 82EEC594: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC598: 386B005C  addi r3, r11, 0x5c
	ctx.r[3].s64 = ctx.r[11].s64 + 92;
	// 82EEC59C: 48205415  bl 0x830f19b0
	ctx.lr = 0x82EEC5A0;
	sub_830F19B0(ctx, base);
	// 82EEC5A0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC5A4: 386B0054  addi r3, r11, 0x54
	ctx.r[3].s64 = ctx.r[11].s64 + 84;
	// 82EEC5A8: 48205409  bl 0x830f19b0
	ctx.lr = 0x82EEC5AC;
	sub_830F19B0(ctx, base);
	// 82EEC5AC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC5B0: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EEC5B4: 481017FD  bl 0x82feddb0
	ctx.lr = 0x82EEC5B8;
	sub_82FEDDB0(ctx, base);
	// 82EEC5B8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC5BC: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEC5C0: 4BFFFF41  bl 0x82eec500
	ctx.lr = 0x82EEC5C4;
	sub_82EEC500(ctx, base);
	// 82EEC5C4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC5C8: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EEC5CC: 4BFFFEA5  bl 0x82eec470
	ctx.lr = 0x82EEC5D0;
	sub_82EEC470(ctx, base);
	// 82EEC5D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC5D4: 4BFFFD7D  bl 0x82eec350
	ctx.lr = 0x82EEC5D8;
	sub_82EEC350(ctx, base);
	// 82EEC5D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC5DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC5E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC5E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEC5E8 size=56
    let mut pc: u32 = 0x82EEC5E8;
    'dispatch: loop {
        match pc {
            0x82EEC5E8 => {
    //   block [0x82EEC5E8..0x82EEC5F4)
	// 82EEC5E8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEC5EC: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC5F0: 396B02EC  addi r11, r11, 0x2ec
	ctx.r[11].s64 = ctx.r[11].s64 + 748;
	pc = 0x82EEC5F4; continue 'dispatch;
            }
            0x82EEC5F4 => {
    //   block [0x82EEC5F4..0x82EEC620)
	// 82EEC5F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82EEC5F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EEC5FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82EEC600: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EEC604: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82EEC608: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EEC60C: 4082FFE8  bne 0x82eec5f4
	if !ctx.cr[0].eq {
	pc = 0x82EEC5F4; continue 'dispatch;
	}
	// 82EEC610: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82EEC614: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEC618: 8061FFF0  lwz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEC61C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC620 size=596
    let mut pc: u32 = 0x82EEC620;
    'dispatch: loop {
        match pc {
            0x82EEC620 => {
    //   block [0x82EEC620..0x82EEC694)
	// 82EEC620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC628: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EEC62C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEC630: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC634: 906100C4  stw r3, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[3].u32 ) };
	// 82EEC638: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC63C: 816B8F58  lwz r11, -0x70a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28840 as u32) ) } as u64;
	// 82EEC640: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEC644: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEC648: 419A004C  beq cr6, 0x82eec694
	if ctx.cr[6].eq {
	pc = 0x82EEC694; continue 'dispatch;
	}
	// 82EEC64C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC650: 896B8F65  lbz r11, -0x709b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28827 as u32) ) } as u64;
	// 82EEC654: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEC658: 4082003C  bne 0x82eec694
	if !ctx.cr[0].eq {
	pc = 0x82EEC694; continue 'dispatch;
	}
	// 82EEC65C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC660: 3BEB8F65  addi r31, r11, -0x709b
	ctx.r[31].s64 = ctx.r[11].s64 + -28827;
	// 82EEC664: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC668: 38CBC360  addi r6, r11, -0x3ca0
	ctx.r[6].s64 = ctx.r[11].s64 + -15520;
	// 82EEC66C: 38A00079  li r5, 0x79
	ctx.r[5].s64 = 121;
	// 82EEC670: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC674: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEC678: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEC67C: 4BFFEAED  bl 0x82eeb168
	ctx.lr = 0x82EEC680;
	sub_82EEB168(ctx, base);
	// 82EEC680: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEC684: 48205735  bl 0x830f1db8
	ctx.lr = 0x82EEC688;
	sub_830F1DB8(ctx, base);
	// 82EEC688: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC68C: 40820008  bne 0x82eec694
	if !ctx.cr[0].eq {
	pc = 0x82EEC694; continue 'dispatch;
	}
	// 82EEC690: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEC694; continue 'dispatch;
            }
            0x82EEC694 => {
    //   block [0x82EEC694..0x82EEC6EC)
	// 82EEC694: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEC698: 816B02EC  lwz r11, 0x2ec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(748 as u32) ) } as u64;
	// 82EEC69C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC6A0: 4199004C  bgt cr6, 0x82eec6ec
	if ctx.cr[6].gt {
	pc = 0x82EEC6EC; continue 'dispatch;
	}
	// 82EEC6A4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC6A8: 896B8F64  lbz r11, -0x709c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28828 as u32) ) } as u64;
	// 82EEC6AC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEC6B0: 4082003C  bne 0x82eec6ec
	if !ctx.cr[0].eq {
	pc = 0x82EEC6EC; continue 'dispatch;
	}
	// 82EEC6B4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC6B8: 3BEB8F64  addi r31, r11, -0x709c
	ctx.r[31].s64 = ctx.r[11].s64 + -28828;
	// 82EEC6BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC6C0: 38CBC34C  addi r6, r11, -0x3cb4
	ctx.r[6].s64 = ctx.r[11].s64 + -15540;
	// 82EEC6C4: 38A0007B  li r5, 0x7b
	ctx.r[5].s64 = 123;
	// 82EEC6C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC6CC: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEC6D0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEC6D4: 4BFFEA95  bl 0x82eeb168
	ctx.lr = 0x82EEC6D8;
	sub_82EEB168(ctx, base);
	// 82EEC6D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEC6DC: 482056DD  bl 0x830f1db8
	ctx.lr = 0x82EEC6E0;
	sub_830F1DB8(ctx, base);
	// 82EEC6E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC6E4: 40820008  bne 0x82eec6ec
	if !ctx.cr[0].eq {
	pc = 0x82EEC6EC; continue 'dispatch;
	}
	// 82EEC6E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEC6EC; continue 'dispatch;
            }
            0x82EEC6EC => {
    //   block [0x82EEC6EC..0x82EEC6F4)
	// 82EEC6EC: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEC6F0: 396B02EC  addi r11, r11, 0x2ec
	ctx.r[11].s64 = ctx.r[11].s64 + 748;
	pc = 0x82EEC6F4; continue 'dispatch;
            }
            0x82EEC6F4 => {
    //   block [0x82EEC6F4..0x82EEC7A4)
	// 82EEC6F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82EEC6F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EEC6FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82EEC700: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82EEC704: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82EEC708: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EEC70C: 4082FFE8  bne 0x82eec6f4
	if !ctx.cr[0].eq {
	pc = 0x82EEC6F4; continue 'dispatch;
	}
	// 82EEC710: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82EEC714: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEC718: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEC71C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEC720: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEC724: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC728: 409A0130  bne cr6, 0x82eec858
	if !ctx.cr[6].eq {
	pc = 0x82EEC858; continue 'dispatch;
	}
	// 82EEC72C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC730: 816B8F58  lwz r11, -0x70a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28840 as u32) ) } as u64;
	// 82EEC734: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEC738: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEC73C: 409A011C  bne cr6, 0x82eec858
	if !ctx.cr[6].eq {
	pc = 0x82EEC858; continue 'dispatch;
	}
	// 82EEC740: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEC744: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEC748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC74C: 419A0058  beq cr6, 0x82eec7a4
	if ctx.cr[6].eq {
	pc = 0x82EEC7A4; continue 'dispatch;
	}
	// 82EEC750: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC754: 896B8F63  lbz r11, -0x709d(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28829 as u32) ) } as u64;
	// 82EEC758: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEC75C: 40820048  bne 0x82eec7a4
	if !ctx.cr[0].eq {
	pc = 0x82EEC7A4; continue 'dispatch;
	}
	// 82EEC760: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC764: 3BEBC308  addi r31, r11, -0x3cf8
	ctx.r[31].s64 = ctx.r[11].s64 + -15608;
	// 82EEC768: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC76C: 3BCB8F63  addi r30, r11, -0x709d
	ctx.r[30].s64 = ctx.r[11].s64 + -28829;
	// 82EEC770: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC774: 38CBC2F0  addi r6, r11, -0x3d10
	ctx.r[6].s64 = ctx.r[11].s64 + -15632;
	// 82EEC778: 38A00084  li r5, 0x84
	ctx.r[5].s64 = 132;
	// 82EEC77C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC780: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEC784: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EEC788: 4BFFE9E1  bl 0x82eeb168
	ctx.lr = 0x82EEC78C;
	sub_82EEB168(ctx, base);
	// 82EEC78C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EEC790: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EEC794: 482056FD  bl 0x830f1e90
	ctx.lr = 0x82EEC798;
	sub_830F1E90(ctx, base);
	// 82EEC798: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC79C: 40820008  bne 0x82eec7a4
	if !ctx.cr[0].eq {
	pc = 0x82EEC7A4; continue 'dispatch;
	}
	// 82EEC7A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEC7A4; continue 'dispatch;
            }
            0x82EEC7A4 => {
    //   block [0x82EEC7A4..0x82EEC7BC)
	// 82EEC7A4: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEC7A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEC7AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC7B0: 419A0038  beq cr6, 0x82eec7e8
	if ctx.cr[6].eq {
	pc = 0x82EEC7E8; continue 'dispatch;
	}
	// 82EEC7B4: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEC7B8: 396B02EC  addi r11, r11, 0x2ec
	ctx.r[11].s64 = ctx.r[11].s64 + 748;
	pc = 0x82EEC7BC; continue 'dispatch;
            }
            0x82EEC7BC => {
    //   block [0x82EEC7BC..0x82EEC7E8)
	// 82EEC7BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82EEC7C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EEC7C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82EEC7C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EEC7CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82EEC7D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EEC7D4: 4082FFE8  bne 0x82eec7bc
	if !ctx.cr[0].eq {
	pc = 0x82EEC7BC; continue 'dispatch;
	}
	// 82EEC7D8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82EEC7DC: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EEC7E0: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EEC7E4: 48000078  b 0x82eec85c
	pc = 0x82EEC85C; continue 'dispatch;
            }
            0x82EEC7E8 => {
    //   block [0x82EEC7E8..0x82EEC858)
	// 82EEC7E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEC7EC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC7F0: 816B8F58  lwz r11, -0x70a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28840 as u32) ) } as u64;
	// 82EEC7F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEC7F8: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEC7FC: 806A8F58  lwz r3, -0x70a8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28840 as u32) ) } as u64;
	// 82EEC800: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEC804: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEC808: 4E800421  bctrl
	ctx.lr = 0x82EEC80C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEC80C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC810: 808B8F58  lwz r4, -0x70a8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28840 as u32) ) } as u64;
	// 82EEC814: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC818: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEC81C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEC820: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EEC824: 806A8F50  lwz r3, -0x70b0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EEC828: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEC82C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEC830: 4E800421  bctrl
	ctx.lr = 0x82EEC834;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEC834: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC838: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEC83C: 914B8F58  stw r10, -0x70a8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-28840 as u32), ctx.r[10].u32 ) };
	// 82EEC840: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC844: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEC848: 914B8F50  stw r10, -0x70b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-28848 as u32), ctx.r[10].u32 ) };
	// 82EEC84C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC850: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEC854: 914B8F54  stw r10, -0x70ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-28844 as u32), ctx.r[10].u32 ) };
            }
            0x82EEC858 => {
    //   block [0x82EEC858..0x82EEC85C)
	// 82EEC858: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82EEC85C; continue 'dispatch;
            }
            0x82EEC85C => {
    //   block [0x82EEC85C..0x82EEC874)
	// 82EEC85C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EEC860: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC864: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC868: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EEC86C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEC870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEC878 size=128
    let mut pc: u32 = 0x82EEC878;
    'dispatch: loop {
        match pc {
            0x82EEC878 => {
    //   block [0x82EEC878..0x82EEC8A8)
	// 82EEC878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC880: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC884: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEC888: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEC88C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEC890: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEC894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC898: 409A0010  bne cr6, 0x82eec8a8
	if !ctx.cr[6].eq {
	pc = 0x82EEC8A8; continue 'dispatch;
	}
	// 82EEC89C: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EEC8A0: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EEC8A4: 48000044  b 0x82eec8e8
	pc = 0x82EEC8E8; continue 'dispatch;
            }
            0x82EEC8A8 => {
    //   block [0x82EEC8A8..0x82EEC8CC)
	// 82EEC8A8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82EEC8AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEC8B0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEC8B4: 48001175  bl 0x82eeda28
	ctx.lr = 0x82EEC8B8;
	sub_82EEDA28(ctx, base);
	// 82EEC8B8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC8BC: 40820010  bne 0x82eec8cc
	if !ctx.cr[0].eq {
	pc = 0x82EEC8CC; continue 'dispatch;
	}
	// 82EEC8C0: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EEC8C4: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EEC8C8: 48000020  b 0x82eec8e8
	pc = 0x82EEC8E8; continue 'dispatch;
            }
            0x82EEC8CC => {
    //   block [0x82EEC8CC..0x82EEC8E8)
	// 82EEC8CC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EEC8D0: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEC8D4: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEC8D8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEC8DC: 386B0064  addi r3, r11, 0x64
	ctx.r[3].s64 = ctx.r[11].s64 + 100;
	// 82EEC8E0: 48001769  bl 0x82eee048
	ctx.lr = 0x82EEC8E4;
	sub_82EEE048(ctx, base);
	// 82EEC8E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EEC8E8; continue 'dispatch;
            }
            0x82EEC8E8 => {
    //   block [0x82EEC8E8..0x82EEC8F8)
	// 82EEC8E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEC8EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEC8F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEC8F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEC8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EEC8F8 size=1144
    let mut pc: u32 = 0x82EEC8F8;
    'dispatch: loop {
        match pc {
            0x82EEC8F8 => {
    //   block [0x82EEC8F8..0x82EEC940)
	// 82EEC8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEC8FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEC900: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEC904: 9421FB00  stwu r1, -0x500(r1)
	ea = ctx.r[1].u32.wrapping_add(-1280 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEC908: 90610514  stw r3, 0x514(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1300 as u32), ctx.r[3].u32 ) };
	// 82EEC90C: 9081051C  stw r4, 0x51c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1308 as u32), ctx.r[4].u32 ) };
	// 82EEC910: 90A10524  stw r5, 0x524(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1316 as u32), ctx.r[5].u32 ) };
	// 82EEC914: 90C1052C  stw r6, 0x52c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1324 as u32), ctx.r[6].u32 ) };
	// 82EEC918: 90E10534  stw r7, 0x534(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1332 as u32), ctx.r[7].u32 ) };
	// 82EEC91C: 9101053C  stw r8, 0x53c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1340 as u32), ctx.r[8].u32 ) };
	// 82EEC920: 91210544  stw r9, 0x544(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1348 as u32), ctx.r[9].u32 ) };
	// 82EEC924: 9141054C  stw r10, 0x54c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1356 as u32), ctx.r[10].u32 ) };
	// 82EEC928: 8161052C  lwz r11, 0x52c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82EEC92C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC930: 419A0010  beq cr6, 0x82eec940
	if ctx.cr[6].eq {
	pc = 0x82EEC940; continue 'dispatch;
	}
	// 82EEC934: 8161054C  lwz r11, 0x54c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82EEC938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEC93C: 409A0010  bne cr6, 0x82eec94c
	if !ctx.cr[6].eq {
	pc = 0x82EEC94C; continue 'dispatch;
	}
	pc = 0x82EEC940; continue 'dispatch;
            }
            0x82EEC940 => {
    //   block [0x82EEC940..0x82EEC94C)
	// 82EEC940: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EEC944: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EEC948: 48000414  b 0x82eecd5c
	pc = 0x82EECD5C; continue 'dispatch;
            }
            0x82EEC94C => {
    //   block [0x82EEC94C..0x82EEC970)
	// 82EEC94C: 8061054C  lwz r3, 0x54c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82EEC950: 48205731  bl 0x830f2080
	ctx.lr = 0x82EEC954;
	sub_830F2080(ctx, base);
	// 82EEC954: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EEC958: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EEC95C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC960: 40980010  bge cr6, 0x82eec970
	if !ctx.cr[6].lt {
	pc = 0x82EEC970; continue 'dispatch;
	}
	// 82EEC964: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EEC968: 6163FFFF  ori r3, r11, 0xffff
	ctx.r[3].u64 = ctx.r[11].u64 | 65535;
	// 82EEC96C: 480003F0  b 0x82eecd5c
	pc = 0x82EECD5C; continue 'dispatch;
            }
            0x82EEC970 => {
    //   block [0x82EEC970..0x82EECA00)
	// 82EEC970: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEC974: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82EEC978: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EEC97C: 80E10544  lwz r7, 0x544(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1348 as u32) ) } as u64;
	// 82EEC980: 80C1053C  lwz r6, 0x53c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1340 as u32) ) } as u64;
	// 82EEC984: 80A10534  lwz r5, 0x534(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1332 as u32) ) } as u64;
	// 82EEC988: 8081052C  lwz r4, 0x52c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82EEC98C: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EEC990: 80610514  lwz r3, 0x514(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EEC994: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82EEC998: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EEC99C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEC9A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEC9A4: 4E800421  bctrl
	ctx.lr = 0x82EEC9A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEC9A8: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EEC9AC: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EEC9B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC9B4: 4098004C  bge cr6, 0x82eeca00
	if !ctx.cr[6].lt {
	pc = 0x82EECA00; continue 'dispatch;
	}
	// 82EEC9B8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC9BC: 896B8F66  lbz r11, -0x709a(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28826 as u32) ) } as u64;
	// 82EEC9C0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEC9C4: 4082003C  bne 0x82eeca00
	if !ctx.cr[0].eq {
	pc = 0x82EECA00; continue 'dispatch;
	}
	// 82EEC9C8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEC9CC: 3BEB8F66  addi r31, r11, -0x709a
	ctx.r[31].s64 = ctx.r[11].s64 + -28826;
	// 82EEC9D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC9D4: 38CBC464  addi r6, r11, -0x3b9c
	ctx.r[6].s64 = ctx.r[11].s64 + -15260;
	// 82EEC9D8: 38A000BD  li r5, 0xbd
	ctx.r[5].s64 = 189;
	// 82EEC9DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEC9E0: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EEC9E4: 386104C8  addi r3, r1, 0x4c8
	ctx.r[3].s64 = ctx.r[1].s64 + 1224;
	// 82EEC9E8: 4BFFE781  bl 0x82eeb168
	ctx.lr = 0x82EEC9EC;
	sub_82EEB168(ctx, base);
	// 82EEC9EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEC9F0: 482053C9  bl 0x830f1db8
	ctx.lr = 0x82EEC9F4;
	sub_830F1DB8(ctx, base);
	// 82EEC9F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEC9F8: 40820008  bne 0x82eeca00
	if !ctx.cr[0].eq {
	pc = 0x82EECA00; continue 'dispatch;
	}
	// 82EEC9FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
            }
            0x82EECA00 => {
    //   block [0x82EECA00..0x82EECA14)
	// 82EECA00: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECA04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EECA08: 4098000C  bge cr6, 0x82eeca14
	if !ctx.cr[6].lt {
	pc = 0x82EECA14; continue 'dispatch;
	}
	// 82EECA0C: 80610474  lwz r3, 0x474(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECA10: 4800034C  b 0x82eecd5c
	pc = 0x82EECD5C; continue 'dispatch;
            }
            0x82EECA14 => {
    //   block [0x82EECA14..0x82EECAA0)
	// 82EECA14: 80810524  lwz r4, 0x524(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1316 as u32) ) } as u64;
	// 82EECA18: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECA1C: 386B02E4  addi r3, r11, 0x2e4
	ctx.r[3].s64 = ctx.r[11].s64 + 740;
	// 82EECA20: 4811C681  bl 0x830090a0
	ctx.lr = 0x82EECA24;
	sub_830090A0(ctx, base);
	// 82EECA24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EECA28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECA2C: 388BC460  addi r4, r11, -0x3ba0
	ctx.r[4].s64 = ctx.r[11].s64 + -15264;
	// 82EECA30: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECA34: 386B02E4  addi r3, r11, 0x2e4
	ctx.r[3].s64 = ctx.r[11].s64 + 740;
	// 82EECA38: 48000F89  bl 0x82eed9c0
	ctx.lr = 0x82EECA3C;
	sub_82EED9C0(ctx, base);
	// 82EECA3C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EECA40: 40820060  bne 0x82eecaa0
	if !ctx.cr[0].eq {
	pc = 0x82EECAA0; continue 'dispatch;
	}
	// 82EECA44: 80C1051C  lwz r6, 0x51c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1308 as u32) ) } as u64;
	// 82EECA48: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECA4C: 38ABC450  addi r5, r11, -0x3bb0
	ctx.r[5].s64 = ctx.r[11].s64 + -15280;
	// 82EECA50: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EECA54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EECA58: 4BFFE5F1  bl 0x82eeb048
	ctx.lr = 0x82EECA5C;
	sub_82EEB048(ctx, base);
	// 82EECA5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EECA60: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECA64: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECA68: 48100669  bl 0x82fed0d0
	ctx.lr = 0x82EECA6C;
	sub_82FED0D0(ctx, base);
	// 82EECA6C: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECA70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EECA74: C02B0C14  lfs f1, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EECA78: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EECA7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECA80: 38ABC43C  addi r5, r11, -0x3bc4
	ctx.r[5].s64 = ctx.r[11].s64 + -15300;
	// 82EECA84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECA88: 388BC430  addi r4, r11, -0x3bd0
	ctx.r[4].s64 = ctx.r[11].s64 + -15312;
	// 82EECA8C: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECA90: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECA94: 481006BD  bl 0x82fed150
	ctx.lr = 0x82EECA98;
	sub_82FED150(ctx, base);
	// 82EECA98: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECA9C: 48000154  b 0x82eecbf0
	pc = 0x82EECBF0; continue 'dispatch;
            }
            0x82EECAA0 => {
    //   block [0x82EECAA0..0x82EECB1C)
	// 82EECAA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EECAA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECAA8: 388BC42C  addi r4, r11, -0x3bd4
	ctx.r[4].s64 = ctx.r[11].s64 + -15316;
	// 82EECAAC: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECAB0: 386B02E4  addi r3, r11, 0x2e4
	ctx.r[3].s64 = ctx.r[11].s64 + 740;
	// 82EECAB4: 48000F0D  bl 0x82eed9c0
	ctx.lr = 0x82EECAB8;
	sub_82EED9C0(ctx, base);
	// 82EECAB8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EECABC: 40820060  bne 0x82eecb1c
	if !ctx.cr[0].eq {
	pc = 0x82EECB1C; continue 'dispatch;
	}
	// 82EECAC0: 80C1051C  lwz r6, 0x51c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1308 as u32) ) } as u64;
	// 82EECAC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECAC8: 38ABC41C  addi r5, r11, -0x3be4
	ctx.r[5].s64 = ctx.r[11].s64 + -15332;
	// 82EECACC: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EECAD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EECAD4: 4BFFE575  bl 0x82eeb048
	ctx.lr = 0x82EECAD8;
	sub_82EEB048(ctx, base);
	// 82EECAD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EECADC: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECAE0: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECAE4: 481005ED  bl 0x82fed0d0
	ctx.lr = 0x82EECAE8;
	sub_82FED0D0(ctx, base);
	// 82EECAE8: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECAEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EECAF0: C02B0C14  lfs f1, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EECAF4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EECAF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECAFC: 38ABC40C  addi r5, r11, -0x3bf4
	ctx.r[5].s64 = ctx.r[11].s64 + -15348;
	// 82EECB00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECB04: 388BC430  addi r4, r11, -0x3bd0
	ctx.r[4].s64 = ctx.r[11].s64 + -15312;
	// 82EECB08: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECB0C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECB10: 48100641  bl 0x82fed150
	ctx.lr = 0x82EECB14;
	sub_82FED150(ctx, base);
	// 82EECB14: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECB18: 480000D8  b 0x82eecbf0
	pc = 0x82EECBF0; continue 'dispatch;
            }
            0x82EECB1C => {
    //   block [0x82EECB1C..0x82EECB98)
	// 82EECB1C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EECB20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECB24: 388BC408  addi r4, r11, -0x3bf8
	ctx.r[4].s64 = ctx.r[11].s64 + -15352;
	// 82EECB28: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECB2C: 386B02E4  addi r3, r11, 0x2e4
	ctx.r[3].s64 = ctx.r[11].s64 + 740;
	// 82EECB30: 48000E91  bl 0x82eed9c0
	ctx.lr = 0x82EECB34;
	sub_82EED9C0(ctx, base);
	// 82EECB34: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EECB38: 40820060  bne 0x82eecb98
	if !ctx.cr[0].eq {
	pc = 0x82EECB98; continue 'dispatch;
	}
	// 82EECB3C: 80C1051C  lwz r6, 0x51c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1308 as u32) ) } as u64;
	// 82EECB40: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECB44: 38ABC3F8  addi r5, r11, -0x3c08
	ctx.r[5].s64 = ctx.r[11].s64 + -15368;
	// 82EECB48: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EECB4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EECB50: 4BFFE4F9  bl 0x82eeb048
	ctx.lr = 0x82EECB54;
	sub_82EEB048(ctx, base);
	// 82EECB54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EECB58: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECB5C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECB60: 48100571  bl 0x82fed0d0
	ctx.lr = 0x82EECB64;
	sub_82FED0D0(ctx, base);
	// 82EECB64: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECB68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EECB6C: C02B0C14  lfs f1, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EECB70: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EECB74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECB78: 38ABC3E8  addi r5, r11, -0x3c18
	ctx.r[5].s64 = ctx.r[11].s64 + -15384;
	// 82EECB7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECB80: 388BC430  addi r4, r11, -0x3bd0
	ctx.r[4].s64 = ctx.r[11].s64 + -15312;
	// 82EECB84: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECB88: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECB8C: 481005C5  bl 0x82fed150
	ctx.lr = 0x82EECB90;
	sub_82FED150(ctx, base);
	// 82EECB90: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECB94: 4800005C  b 0x82eecbf0
	pc = 0x82EECBF0; continue 'dispatch;
            }
            0x82EECB98 => {
    //   block [0x82EECB98..0x82EECBF0)
	// 82EECB98: 80C1051C  lwz r6, 0x51c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1308 as u32) ) } as u64;
	// 82EECB9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECBA0: 38ABC3D8  addi r5, r11, -0x3c28
	ctx.r[5].s64 = ctx.r[11].s64 + -15400;
	// 82EECBA4: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EECBA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EECBAC: 4BFFE49D  bl 0x82eeb048
	ctx.lr = 0x82EECBB0;
	sub_82EEB048(ctx, base);
	// 82EECBB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EECBB4: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECBB8: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECBBC: 48100515  bl 0x82fed0d0
	ctx.lr = 0x82EECBC0;
	sub_82FED0D0(ctx, base);
	// 82EECBC0: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECBC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EECBC8: C02B0C14  lfs f1, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EECBCC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EECBD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECBD4: 38ABC3C4  addi r5, r11, -0x3c3c
	ctx.r[5].s64 = ctx.r[11].s64 + -15420;
	// 82EECBD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECBDC: 388BC430  addi r4, r11, -0x3bd0
	ctx.r[4].s64 = ctx.r[11].s64 + -15312;
	// 82EECBE0: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECBE4: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EECBE8: 48100569  bl 0x82fed150
	ctx.lr = 0x82EECBEC;
	sub_82FED150(ctx, base);
	// 82EECBEC: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	pc = 0x82EECBF0; continue 'dispatch;
            }
            0x82EECBF0 => {
    //   block [0x82EECBF0..0x82EECC04)
	// 82EECBF0: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECBF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EECBF8: 4098000C  bge cr6, 0x82eecc04
	if !ctx.cr[6].lt {
	pc = 0x82EECC04; continue 'dispatch;
	}
	// 82EECBFC: 80610474  lwz r3, 0x474(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECC00: 4800015C  b 0x82eecd5c
	pc = 0x82EECD5C; continue 'dispatch;
            }
            0x82EECC04 => {
    //   block [0x82EECC04..0x82EECC80)
	// 82EECC04: 80C1051C  lwz r6, 0x51c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1308 as u32) ) } as u64;
	// 82EECC08: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECC0C: 38ABC3B4  addi r5, r11, -0x3c4c
	ctx.r[5].s64 = ctx.r[11].s64 + -15436;
	// 82EECC10: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EECC14: 38610370  addi r3, r1, 0x370
	ctx.r[3].s64 = ctx.r[1].s64 + 880;
	// 82EECC18: 4BFFE431  bl 0x82eeb048
	ctx.lr = 0x82EECC1C;
	sub_82EEB048(ctx, base);
	// 82EECC1C: 396104D4  addi r11, r1, 0x4d4
	ctx.r[11].s64 = ctx.r[1].s64 + 1236;
	// 82EECC20: 916104D8  stw r11, 0x4d8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1240 as u32), ctx.r[11].u32 ) };
	// 82EECC24: 806104D8  lwz r3, 0x4d8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82EECC28: 48000871  bl 0x82eed498
	ctx.lr = 0x82EECC2C;
	sub_82EED498(ctx, base);
	// 82EECC2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EECC30: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECC34: 480005ED  bl 0x82eed220
	ctx.lr = 0x82EECC38;
	sub_82EED220(ctx, base);
	// 82EECC38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EECC3C: 38810370  addi r4, r1, 0x370
	ctx.r[4].s64 = ctx.r[1].s64 + 880;
	// 82EECC40: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECC44: 4800066D  bl 0x82eed2b0
	ctx.lr = 0x82EECC48;
	sub_82EED2B0(ctx, base);
	// 82EECC48: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECC4C: 388BC3AC  addi r4, r11, -0x3c54
	ctx.r[4].s64 = ctx.r[11].s64 + -15444;
	// 82EECC50: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECC54: 480032CD  bl 0x82eeff20
	ctx.lr = 0x82EECC58;
	sub_82EEFF20(ctx, base);
	// 82EECC58: 90610368  stw r3, 0x368(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(872 as u32), ctx.r[3].u32 ) };
	// 82EECC5C: 81610368  lwz r11, 0x368(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(872 as u32) ) } as u64;
	// 82EECC60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EECC64: 4098001C  bge cr6, 0x82eecc80
	if !ctx.cr[6].lt {
	pc = 0x82EECC80; continue 'dispatch;
	}
	// 82EECC68: 81610368  lwz r11, 0x368(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(872 as u32) ) } as u64;
	// 82EECC6C: 916104DC  stw r11, 0x4dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1244 as u32), ctx.r[11].u32 ) };
	// 82EECC70: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECC74: 48000605  bl 0x82eed278
	ctx.lr = 0x82EECC78;
	sub_82EED278(ctx, base);
	// 82EECC78: 806104DC  lwz r3, 0x4dc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1244 as u32) ) } as u64;
	// 82EECC7C: 480000E0  b 0x82eecd5c
	pc = 0x82EECD5C; continue 'dispatch;
            }
            0x82EECC80 => {
    //   block [0x82EECC80..0x82EECCD0)
	// 82EECC80: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECC84: 480007E5  bl 0x82eed468
	ctx.lr = 0x82EECC88;
	sub_82EED468(ctx, base);
	// 82EECC88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EECC8C: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECC90: 81410514  lwz r10, 0x514(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECC94: 386A0054  addi r3, r10, 0x54
	ctx.r[3].s64 = ctx.r[10].s64 + 84;
	// 82EECC98: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EECC9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EECCA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EECCA4: 4E800421  bctrl
	ctx.lr = 0x82EECCA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EECCA8: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECCAC: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECCB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EECCB4: 4098001C  bge cr6, 0x82eeccd0
	if !ctx.cr[6].lt {
	pc = 0x82EECCD0; continue 'dispatch;
	}
	// 82EECCB8: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECCBC: 916104E0  stw r11, 0x4e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1248 as u32), ctx.r[11].u32 ) };
	// 82EECCC0: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECCC4: 480005B5  bl 0x82eed278
	ctx.lr = 0x82EECCC8;
	sub_82EED278(ctx, base);
	// 82EECCC8: 806104E0  lwz r3, 0x4e0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1248 as u32) ) } as u64;
	// 82EECCCC: 48000090  b 0x82eecd5c
	pc = 0x82EECD5C; continue 'dispatch;
            }
            0x82EECCD0 => {
    //   block [0x82EECCD0..0x82EECD38)
	// 82EECCD0: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECCD4: 38EB02E4  addi r7, r11, 0x2e4
	ctx.r[7].s64 = ctx.r[11].s64 + 740;
	// 82EECCD8: 80C1051C  lwz r6, 0x51c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1308 as u32) ) } as u64;
	// 82EECCDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECCE0: 38ABC37C  addi r5, r11, -0x3c84
	ctx.r[5].s64 = ctx.r[11].s64 + -15492;
	// 82EECCE4: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EECCE8: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 82EECCEC: 4BFFE4FD  bl 0x82eeb1e8
	ctx.lr = 0x82EECCF0;
	sub_82EEB1E8(ctx, base);
	// 82EECCF0: 38810160  addi r4, r1, 0x160
	ctx.r[4].s64 = ctx.r[1].s64 + 352;
	// 82EECCF4: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECCF8: 81410514  lwz r10, 0x514(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECCFC: 386A005C  addi r3, r10, 0x5c
	ctx.r[3].s64 = ctx.r[10].s64 + 92;
	// 82EECD00: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EECD04: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EECD08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EECD0C: 4E800421  bctrl
	ctx.lr = 0x82EECD10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EECD10: 90610474  stw r3, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[3].u32 ) };
	// 82EECD14: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECD18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EECD1C: 4098001C  bge cr6, 0x82eecd38
	if !ctx.cr[6].lt {
	pc = 0x82EECD38; continue 'dispatch;
	}
	// 82EECD20: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECD24: 916104E4  stw r11, 0x4e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1252 as u32), ctx.r[11].u32 ) };
	// 82EECD28: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECD2C: 4800054D  bl 0x82eed278
	ctx.lr = 0x82EECD30;
	sub_82EED278(ctx, base);
	// 82EECD30: 806104E4  lwz r3, 0x4e4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1252 as u32) ) } as u64;
	// 82EECD34: 48000028  b 0x82eecd5c
	pc = 0x82EECD5C; continue 'dispatch;
            }
            0x82EECD38 => {
    //   block [0x82EECD38..0x82EECD5C)
	// 82EECD38: 8081051C  lwz r4, 0x51c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1308 as u32) ) } as u64;
	// 82EECD3C: 81610514  lwz r11, 0x514(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1300 as u32) ) } as u64;
	// 82EECD40: 386B01E0  addi r3, r11, 0x1e0
	ctx.r[3].s64 = ctx.r[11].s64 + 480;
	// 82EECD44: 482045ED  bl 0x830f1330
	ctx.lr = 0x82EECD48;
	sub_830F1330(ctx, base);
	// 82EECD48: 81610474  lwz r11, 0x474(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EECD4C: 916104E8  stw r11, 0x4e8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1256 as u32), ctx.r[11].u32 ) };
	// 82EECD50: 38610480  addi r3, r1, 0x480
	ctx.r[3].s64 = ctx.r[1].s64 + 1152;
	// 82EECD54: 48000525  bl 0x82eed278
	ctx.lr = 0x82EECD58;
	sub_82EED278(ctx, base);
	// 82EECD58: 806104E8  lwz r3, 0x4e8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1256 as u32) ) } as u64;
	pc = 0x82EECD5C; continue 'dispatch;
            }
            0x82EECD5C => {
    //   block [0x82EECD5C..0x82EECD70)
	// 82EECD5C: 38210500  addi r1, r1, 0x500
	ctx.r[1].s64 = ctx.r[1].s64 + 1280;
	// 82EECD60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EECD64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EECD68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EECD6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EECD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EECD70 size=768
    let mut pc: u32 = 0x82EECD70;
    'dispatch: loop {
        match pc {
            0x82EECD70 => {
    //   block [0x82EECD70..0x82EECDA8)
	// 82EECD70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EECD74: 4BDBC681  bl 0x82ca93f4
	ctx.lr = 0x82EECD78;
	sub_82CA93D0(ctx, base);
	// 82EECD78: 9421FDE0  stwu r1, -0x220(r1)
	ea = ctx.r[1].u32.wrapping_add(-544 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EECD7C: 90610234  stw r3, 0x234(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(564 as u32), ctx.r[3].u32 ) };
	// 82EECD80: 9081023C  stw r4, 0x23c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(572 as u32), ctx.r[4].u32 ) };
	// 82EECD84: 90A10244  stw r5, 0x244(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(580 as u32), ctx.r[5].u32 ) };
	// 82EECD88: 90C1024C  stw r6, 0x24c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(588 as u32), ctx.r[6].u32 ) };
	// 82EECD8C: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECD90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EECD94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EECD98: 419A0010  beq cr6, 0x82eecda8
	if ctx.cr[6].eq {
	pc = 0x82EECDA8; continue 'dispatch;
	}
	// 82EECD9C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EECDA0: 6163FFFF  ori r3, r11, 0xffff
	ctx.r[3].u64 = ctx.r[11].u64 | 65535;
	// 82EECDA4: 480002C4  b 0x82eed068
	pc = 0x82EED068; continue 'dispatch;
            }
            0x82EECDA8 => {
    //   block [0x82EECDA8..0x82EECDDC)
	// 82EECDA8: 8161023C  lwz r11, 0x23c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EECDAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EECDB0: 419A002C  beq cr6, 0x82eecddc
	if ctx.cr[6].eq {
	pc = 0x82EECDDC; continue 'dispatch;
	}
	// 82EECDB4: 81610244  lwz r11, 0x244(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EECDB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EECDBC: 419A0020  beq cr6, 0x82eecddc
	if ctx.cr[6].eq {
	pc = 0x82EECDDC; continue 'dispatch;
	}
	// 82EECDC0: 8161024C  lwz r11, 0x24c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EECDC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EECDC8: 419A0014  beq cr6, 0x82eecddc
	if ctx.cr[6].eq {
	pc = 0x82EECDDC; continue 'dispatch;
	}
	// 82EECDCC: 8161024C  lwz r11, 0x24c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EECDD0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EECDD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EECDD8: 419A0010  beq cr6, 0x82eecde8
	if ctx.cr[6].eq {
	pc = 0x82EECDE8; continue 'dispatch;
	}
	pc = 0x82EECDDC; continue 'dispatch;
            }
            0x82EECDDC => {
    //   block [0x82EECDDC..0x82EECDE8)
	// 82EECDDC: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EECDE0: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EECDE4: 48000284  b 0x82eed068
	pc = 0x82EED068; continue 'dispatch;
            }
            0x82EECDE8 => {
    //   block [0x82EECDE8..0x82EECE88)
	// 82EECDE8: 80C1023C  lwz r6, 0x23c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EECDEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EECDF0: 38ABC47C  addi r5, r11, -0x3b84
	ctx.r[5].s64 = ctx.r[11].s64 + -15236;
	// 82EECDF4: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EECDF8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82EECDFC: 4BFFE24D  bl 0x82eeb048
	ctx.lr = 0x82EECE00;
	sub_82EEB048(ctx, base);
	// 82EECE00: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EECE04: 4800897D  bl 0x82ef5780
	ctx.lr = 0x82EECE08;
	sub_82EF5780(ctx, base);
	// 82EECE08: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EECE0C: 48008975  bl 0x82ef5780
	ctx.lr = 0x82EECE10;
	sub_82EF5780(ctx, base);
	// 82EECE10: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EECE14: 48117D95  bl 0x83004ba8
	ctx.lr = 0x82EECE18;
	sub_83004BA8(ctx, base);
	// 82EECE18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EECE1C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EECE20: 48117D89  bl 0x83004ba8
	ctx.lr = 0x82EECE24;
	sub_83004BA8(ctx, base);
	// 82EECE24: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EECE28: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EECE2C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82EECE30: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECE34: 81410234  lwz r10, 0x234(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECE38: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 82EECE3C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EECE40: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82EECE44: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EECE48: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EECE4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EECE50: 4E800421  bctrl
	ctx.lr = 0x82EECE54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EECE54: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EECE58: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EECE5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EECE60: 40980028  bge cr6, 0x82eece88
	if !ctx.cr[6].lt {
	pc = 0x82EECE88; continue 'dispatch;
	}
	// 82EECE64: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EECE68: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EECE6C: 916101B4  stw r11, 0x1b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(436 as u32), ctx.r[11].u32 ) };
	// 82EECE70: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EECE74: 4800709D  bl 0x82ef3f10
	ctx.lr = 0x82EECE78;
	sub_82EF3F10(ctx, base);
	// 82EECE78: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EECE7C: 48006FE5  bl 0x82ef3e60
	ctx.lr = 0x82EECE80;
	sub_82EF3E60(ctx, base);
	// 82EECE80: 806101B4  lwz r3, 0x1b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EECE84: 480001E4  b 0x82eed068
	pc = 0x82EED068; continue 'dispatch;
            }
            0x82EECE88 => {
    //   block [0x82EECE88..0x82EECEE0)
	// 82EECE88: 38800508  li r4, 0x508
	ctx.r[4].s64 = 1288;
	// 82EECE8C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EECE90: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EECE94: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EECE98: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EECE9C: 806A8F50  lwz r3, -0x70b0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EECEA0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EECEA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EECEA8: 4E800421  bctrl
	ctx.lr = 0x82EECEAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EECEAC: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 82EECEB0: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EECEB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EECEB8: 409A0028  bne cr6, 0x82eecee0
	if !ctx.cr[6].eq {
	pc = 0x82EECEE0; continue 'dispatch;
	}
	// 82EECEBC: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EECEC0: 616B000E  ori r11, r11, 0xe
	ctx.r[11].u64 = ctx.r[11].u64 | 14;
	// 82EECEC4: 916101B8  stw r11, 0x1b8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EECEC8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EECECC: 48007045  bl 0x82ef3f10
	ctx.lr = 0x82EECED0;
	sub_82EF3F10(ctx, base);
	// 82EECED0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EECED4: 48006F8D  bl 0x82ef3e60
	ctx.lr = 0x82EECED8;
	sub_82EF3E60(ctx, base);
	// 82EECED8: 806101B8  lwz r3, 0x1b8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EECEDC: 4800018C  b 0x82eed068
	pc = 0x82EED068; continue 'dispatch;
            }
            0x82EECEE0 => {
    //   block [0x82EECEE0..0x82EECF10)
	// 82EECEE0: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EECEE4: 38600508  li r3, 0x508
	ctx.r[3].s64 = 1288;
	// 82EECEE8: 48000189  bl 0x82eed070
	ctx.lr = 0x82EECEEC;
	sub_82EED070(ctx, base);
	// 82EECEEC: 906101BC  stw r3, 0x1bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(444 as u32), ctx.r[3].u32 ) };
	// 82EECEF0: 816101BC  lwz r11, 0x1bc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EECEF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EECEF8: 419A0018  beq cr6, 0x82eecf10
	if ctx.cr[6].eq {
	pc = 0x82EECF10; continue 'dispatch;
	}
	// 82EECEFC: 80810234  lwz r4, 0x234(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF00: 806101BC  lwz r3, 0x1bc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EECF04: 48008B4D  bl 0x82ef5a50
	ctx.lr = 0x82EECF08;
	sub_82EF5A50(ctx, base);
	// 82EECF08: 906101C8  stw r3, 0x1c8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), ctx.r[3].u32 ) };
	// 82EECF0C: 4800000C  b 0x82eecf18
	pc = 0x82EECF18; continue 'dispatch;
            }
            0x82EECF10 => {
    //   block [0x82EECF10..0x82EECF18)
	// 82EECF10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EECF14: 916101C8  stw r11, 0x1c8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), ctx.r[11].u32 ) };
	pc = 0x82EECF18; continue 'dispatch;
            }
            0x82EECF18 => {
    //   block [0x82EECF18..0x82EED014)
	// 82EECF18: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF1C: 814101C8  lwz r10, 0x1c8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(456 as u32) ) } as u64;
	// 82EECF20: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EECF24: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF28: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 82EECF2C: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF30: 3BCB0064  addi r30, r11, 0x64
	ctx.r[30].s64 = ctx.r[11].s64 + 100;
	// 82EECF34: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF38: 3BAB02E4  addi r29, r11, 0x2e4
	ctx.r[29].s64 = ctx.r[11].s64 + 740;
	// 82EECF3C: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF40: 3B8B01E0  addi r28, r11, 0x1e0
	ctx.r[28].s64 = ctx.r[11].s64 + 480;
	// 82EECF44: 8361023C  lwz r27, 0x23c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EECF48: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF4C: 81410234  lwz r10, 0x234(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF50: 386A005C  addi r3, r10, 0x5c
	ctx.r[3].s64 = ctx.r[10].s64 + 92;
	// 82EECF54: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EECF58: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EECF5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EECF60: 4E800421  bctrl
	ctx.lr = 0x82EECF64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EECF64: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EECF68: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF6C: 81410234  lwz r10, 0x234(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECF70: 386A0054  addi r3, r10, 0x54
	ctx.r[3].s64 = ctx.r[10].s64 + 84;
	// 82EECF74: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EECF78: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EECF7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EECF80: 4E800421  bctrl
	ctx.lr = 0x82EECF84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EECF84: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EECF88: 83010244  lwz r24, 0x244(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EECF8C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EECF90: 48000231  bl 0x82eed1c0
	ctx.lr = 0x82EECF94;
	sub_82EED1C0(ctx, base);
	// 82EECF94: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82EECF98: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EECF9C: 48000225  bl 0x82eed1c0
	ctx.lr = 0x82EECFA0;
	sub_82EED1C0(ctx, base);
	// 82EECFA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EECFA4: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECFA8: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EECFAC: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82EECFB0: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82EECFB4: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82EECFB8: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EECFBC: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EECFC0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82EECFC4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82EECFC8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EECFCC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82EECFD0: 48003559  bl 0x82ef0528
	ctx.lr = 0x82EECFD4;
	sub_82EF0528(ctx, base);
	// 82EECFD4: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EECFD8: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EECFDC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EECFE0: 40980034  bge cr6, 0x82eed014
	if !ctx.cr[6].lt {
	pc = 0x82EED014; continue 'dispatch;
	}
	// 82EECFE4: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECFE8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EECFEC: 80610234  lwz r3, 0x234(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EECFF0: 48000091  bl 0x82eed080
	ctx.lr = 0x82EECFF4;
	sub_82EED080(ctx, base);
	// 82EECFF4: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EECFF8: 916101C0  stw r11, 0x1c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
	// 82EECFFC: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EED000: 48006F11  bl 0x82ef3f10
	ctx.lr = 0x82EED004;
	sub_82EF3F10(ctx, base);
	// 82EED004: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EED008: 48006E59  bl 0x82ef3e60
	ctx.lr = 0x82EED00C;
	sub_82EF3E60(ctx, base);
	// 82EED00C: 806101C0  lwz r3, 0x1c0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EED010: 48000058  b 0x82eed068
	pc = 0x82EED068; continue 'dispatch;
            }
            0x82EED014 => {
    //   block [0x82EED014..0x82EED038)
	// 82EED014: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EED018: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED01C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED020: 419A0018  beq cr6, 0x82eed038
	if ctx.cr[6].eq {
	pc = 0x82EED038; continue 'dispatch;
	}
	// 82EED024: 81610234  lwz r11, 0x234(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82EED028: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED02C: 396B04F8  addi r11, r11, 0x4f8
	ctx.r[11].s64 = ctx.r[11].s64 + 1272;
	// 82EED030: 916101CC  stw r11, 0x1cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 82EED034: 4800000C  b 0x82eed040
	pc = 0x82EED040; continue 'dispatch;
            }
            0x82EED038 => {
    //   block [0x82EED038..0x82EED040)
	// 82EED038: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EED03C: 916101CC  stw r11, 0x1cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	pc = 0x82EED040; continue 'dispatch;
            }
            0x82EED040 => {
    //   block [0x82EED040..0x82EED068)
	// 82EED040: 816101CC  lwz r11, 0x1cc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EED044: 8141024C  lwz r10, 0x24c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EED048: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EED04C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EED050: 916101C4  stw r11, 0x1c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), ctx.r[11].u32 ) };
	// 82EED054: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EED058: 48006EB9  bl 0x82ef3f10
	ctx.lr = 0x82EED05C;
	sub_82EF3F10(ctx, base);
	// 82EED05C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EED060: 48006E01  bl 0x82ef3e60
	ctx.lr = 0x82EED064;
	sub_82EF3E60(ctx, base);
	// 82EED064: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	pc = 0x82EED068; continue 'dispatch;
            }
            0x82EED068 => {
    //   block [0x82EED068..0x82EED070)
	// 82EED068: 38210220  addi r1, r1, 0x220
	ctx.r[1].s64 = ctx.r[1].s64 + 544;
	// 82EED06C: 4BDBC3D8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EED070 size=16
    let mut pc: u32 = 0x82EED070;
    'dispatch: loop {
        match pc {
            0x82EED070 => {
    //   block [0x82EED070..0x82EED080)
	// 82EED070: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EED074: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EED078: 8061001C  lwz r3, 0x1c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EED07C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED080 size=316
    let mut pc: u32 = 0x82EED080;
    'dispatch: loop {
        match pc {
            0x82EED080 => {
    //   block [0x82EED080..0x82EED0EC)
	// 82EED080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED088: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EED08C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED090: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EED094: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EED098: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EED09C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED0A0: 409A004C  bne cr6, 0x82eed0ec
	if !ctx.cr[6].eq {
	pc = 0x82EED0EC; continue 'dispatch;
	}
	// 82EED0A4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EED0A8: 896B8F68  lbz r11, -0x7098(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28824 as u32) ) } as u64;
	// 82EED0AC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EED0B0: 4082003C  bne 0x82eed0ec
	if !ctx.cr[0].eq {
	pc = 0x82EED0EC; continue 'dispatch;
	}
	// 82EED0B4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EED0B8: 3BEB8F68  addi r31, r11, -0x7098
	ctx.r[31].s64 = ctx.r[11].s64 + -28824;
	// 82EED0BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EED0C0: 38CBC4A0  addi r6, r11, -0x3b60
	ctx.r[6].s64 = ctx.r[11].s64 + -15200;
	// 82EED0C4: 38A00131  li r5, 0x131
	ctx.r[5].s64 = 305;
	// 82EED0C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EED0CC: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EED0D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EED0D4: 4BFFE095  bl 0x82eeb168
	ctx.lr = 0x82EED0D8;
	sub_82EEB168(ctx, base);
	// 82EED0D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EED0DC: 48204CDD  bl 0x830f1db8
	ctx.lr = 0x82EED0E0;
	sub_830F1DB8(ctx, base);
	// 82EED0E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EED0E4: 40820008  bne 0x82eed0ec
	if !ctx.cr[0].eq {
	pc = 0x82EED0EC; continue 'dispatch;
	}
	// 82EED0E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EED0EC; continue 'dispatch;
            }
            0x82EED0EC => {
    //   block [0x82EED0EC..0x82EED148)
	// 82EED0EC: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EED0F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED0F4: 8141009C  lwz r10, 0x9c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EED0F8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EED0FC: 419A004C  beq cr6, 0x82eed148
	if ctx.cr[6].eq {
	pc = 0x82EED148; continue 'dispatch;
	}
	// 82EED100: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EED104: 896B8F67  lbz r11, -0x7099(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28825 as u32) ) } as u64;
	// 82EED108: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EED10C: 4082003C  bne 0x82eed148
	if !ctx.cr[0].eq {
	pc = 0x82EED148; continue 'dispatch;
	}
	// 82EED110: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EED114: 3BEB8F67  addi r31, r11, -0x7099
	ctx.r[31].s64 = ctx.r[11].s64 + -28825;
	// 82EED118: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EED11C: 38CBC488  addi r6, r11, -0x3b78
	ctx.r[6].s64 = ctx.r[11].s64 + -15224;
	// 82EED120: 38A00132  li r5, 0x132
	ctx.r[5].s64 = 306;
	// 82EED124: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EED128: 388BC218  addi r4, r11, -0x3de8
	ctx.r[4].s64 = ctx.r[11].s64 + -15848;
	// 82EED12C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EED130: 4BFFE039  bl 0x82eeb168
	ctx.lr = 0x82EED134;
	sub_82EEB168(ctx, base);
	// 82EED134: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EED138: 48204C81  bl 0x830f1db8
	ctx.lr = 0x82EED13C;
	sub_830F1DB8(ctx, base);
	// 82EED13C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EED140: 40820008  bne 0x82eed148
	if !ctx.cr[0].eq {
	pc = 0x82EED148; continue 'dispatch;
	}
	// 82EED144: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EED148; continue 'dispatch;
            }
            0x82EED148 => {
    //   block [0x82EED148..0x82EED1A8)
	// 82EED148: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EED14C: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EED150: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EED154: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EED158: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EED15C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EED160: 4E800421  bctrl
	ctx.lr = 0x82EED164;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EED164: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EED168: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EED16C: 816B8F50  lwz r11, -0x70b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EED170: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EED174: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EED178: 806A8F50  lwz r3, -0x70b0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28848 as u32) ) } as u64;
	// 82EED17C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EED180: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EED184: 4E800421  bctrl
	ctx.lr = 0x82EED188;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EED188: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EED18C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED190: 8141009C  lwz r10, 0x9c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EED194: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EED198: 409A0010  bne cr6, 0x82eed1a8
	if !ctx.cr[6].eq {
	pc = 0x82EED1A8; continue 'dispatch;
	}
	// 82EED19C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EED1A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EED1A4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
            }
            0x82EED1A8 => {
    //   block [0x82EED1A8..0x82EED1BC)
	// 82EED1A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EED1AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED1B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED1B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EED1B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EED1C0 size=16
    let mut pc: u32 = 0x82EED1C0;
    'dispatch: loop {
        match pc {
            0x82EED1C0 => {
    //   block [0x82EED1C0..0x82EED1D0)
	// 82EED1C0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EED1C4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EED1C8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EED1CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED1D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED1D0 size=76
    let mut pc: u32 = 0x82EED1D0;
    'dispatch: loop {
        match pc {
            0x82EED1D0 => {
    //   block [0x82EED1D0..0x82EED21C)
	// 82EED1D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED1D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED1D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED1DC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED1E0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EED1E4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EED1E8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EED1EC: 481179BD  bl 0x83004ba8
	ctx.lr = 0x82EED1F0;
	sub_83004BA8(ctx, base);
	// 82EED1F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EED1F4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED1F8: 48001C21  bl 0x82eeee18
	ctx.lr = 0x82EED1FC;
	sub_82EEEE18(ctx, base);
	// 82EED1FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EED200: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED204: 48000325  bl 0x82eed528
	ctx.lr = 0x82EED208;
	sub_82EED528(ctx, base);
	// 82EED208: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED20C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED210: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED214: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED218: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED220 size=88
    let mut pc: u32 = 0x82EED220;
    'dispatch: loop {
        match pc {
            0x82EED220 => {
    //   block [0x82EED220..0x82EED278)
	// 82EED220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED228: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED22C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED230: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED234: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED238: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED23C: 480003E5  bl 0x82eed620
	ctx.lr = 0x82EED240;
	sub_82EED620(ctx, base);
	// 82EED240: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED244: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EED248: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EED24C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EED250: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED254: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EED258: 4BFFE0E9  bl 0x82eeb340
	ctx.lr = 0x82EED25C;
	sub_82EEB340(ctx, base);
	// 82EED25C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED260: 48000271  bl 0x82eed4d0
	ctx.lr = 0x82EED264;
	sub_82EED4D0(ctx, base);
	// 82EED264: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED268: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED26C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED274: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED278 size=52
    let mut pc: u32 = 0x82EED278;
    'dispatch: loop {
        match pc {
            0x82EED278 => {
    //   block [0x82EED278..0x82EED2AC)
	// 82EED278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED27C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED280: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED284: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED288: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED28C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EED290: 48000421  bl 0x82eed6b0
	ctx.lr = 0x82EED294;
	sub_82EED6B0(ctx, base);
	// 82EED294: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED298: 48000239  bl 0x82eed4d0
	ctx.lr = 0x82EED29C;
	sub_82EED4D0(ctx, base);
	// 82EED29C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED2A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED2A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED2A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED2B0 size=440
    let mut pc: u32 = 0x82EED2B0;
    'dispatch: loop {
        match pc {
            0x82EED2B0 => {
    //   block [0x82EED2B0..0x82EED328)
	// 82EED2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED2B4: 4BDBC159  bl 0x82ca940c
	ctx.lr = 0x82EED2B8;
	sub_82CA93D0(ctx, base);
	// 82EED2B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED2BC: 906100B4  stw r3, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 82EED2C0: 908100BC  stw r4, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[4].u32 ) };
	// 82EED2C4: 90A100C4  stw r5, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[5].u32 ) };
	// 82EED2C8: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED2CC: 4800031D  bl 0x82eed5e8
	ctx.lr = 0x82EED2D0;
	sub_82EED5E8(ctx, base);
	// 82EED2D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EED2D4: 3D000800  lis r8, 0x800
	ctx.r[8].s64 = 134217728;
	// 82EED2D8: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 82EED2DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EED2E0: 80A100C4  lwz r5, 0xc4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EED2E4: 3C808000  lis r4, -0x8000
	ctx.r[4].s64 = -2147483648;
	// 82EED2E8: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EED2EC: 4BDD61A5  bl 0x82cc3490
	ctx.lr = 0x82EED2F0;
	sub_82CC3490(ctx, base);
	// 82EED2F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EED2F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EED2F8: 4BFFE049  bl 0x82eeb340
	ctx.lr = 0x82EED2FC;
	sub_82EEB340(ctx, base);
	// 82EED2FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EED300: 4BFFFEC1  bl 0x82eed1c0
	ctx.lr = 0x82EED304;
	sub_82EED1C0(ctx, base);
	// 82EED304: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EED308: 409A0020  bne cr6, 0x82eed328
	if !ctx.cr[6].eq {
	pc = 0x82EED328; continue 'dispatch;
	}
	// 82EED30C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EED310: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EED314: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EED318: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EED31C: 4BFFE045  bl 0x82eeb360
	ctx.lr = 0x82EED320;
	sub_82EEB360(ctx, base);
	// 82EED320: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EED324: 4800013C  b 0x82eed460
	pc = 0x82EED460; continue 'dispatch;
            }
            0x82EED328 => {
    //   block [0x82EED328..0x82EED38C)
	// 82EED328: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EED32C: 4BFFFE95  bl 0x82eed1c0
	ctx.lr = 0x82EED330;
	sub_82EED1C0(ctx, base);
	// 82EED330: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EED334: 4BDD9ADD  bl 0x82cc6e10
	ctx.lr = 0x82EED338;
	sub_82CC6E10(ctx, base);
	// 82EED338: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EED33C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EED340: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EED344: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED348: 48000339  bl 0x82eed680
	ctx.lr = 0x82EED34C;
	sub_82EED680(ctx, base);
	// 82EED34C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EED350: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EED354: 4BFFDFED  bl 0x82eeb340
	ctx.lr = 0x82EED358;
	sub_82EEB340(ctx, base);
	// 82EED358: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EED35C: 48002F65  bl 0x82ef02c0
	ctx.lr = 0x82EED360;
	sub_82EF02C0(ctx, base);
	// 82EED360: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EED364: 40820028  bne 0x82eed38c
	if !ctx.cr[0].eq {
	pc = 0x82EED38C; continue 'dispatch;
	}
	// 82EED368: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EED36C: 616B000E  ori r11, r11, 0xe
	ctx.r[11].u64 = ctx.r[11].u64 | 14;
	// 82EED370: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EED374: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EED378: 48000339  bl 0x82eed6b0
	ctx.lr = 0x82EED37C;
	sub_82EED6B0(ctx, base);
	// 82EED37C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EED380: 4BFFDFE1  bl 0x82eeb360
	ctx.lr = 0x82EED384;
	sub_82EEB360(ctx, base);
	// 82EED384: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EED388: 480000D8  b 0x82eed460
	pc = 0x82EED460; continue 'dispatch;
            }
            0x82EED38C => {
    //   block [0x82EED38C..0x82EED3FC)
	// 82EED38C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED390: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EED394: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EED398: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82EED39C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED3A0: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EED3A4: 4800033D  bl 0x82eed6e0
	ctx.lr = 0x82EED3A8;
	sub_82EED6E0(ctx, base);
	// 82EED3A8: 3BE10064  addi r31, r1, 0x64
	ctx.r[31].s64 = ctx.r[1].s64 + 100;
	// 82EED3AC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED3B0: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED3B4: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED3B8: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EED3BC: 4BFFFE05  bl 0x82eed1c0
	ctx.lr = 0x82EED3C0;
	sub_82EED1C0(ctx, base);
	// 82EED3C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EED3C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EED3C8: 4BFFFDF9  bl 0x82eed1c0
	ctx.lr = 0x82EED3CC;
	sub_82EED1C0(ctx, base);
	// 82EED3CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EED3D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EED3D4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EED3D8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EED3DC: 4BDD62AD  bl 0x82cc3688
	ctx.lr = 0x82EED3E0;
	sub_82CC3688(ctx, base);
	// 82EED3E0: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EED3E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EED3E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EED3EC: 419A0010  beq cr6, 0x82eed3fc
	if ctx.cr[6].eq {
	pc = 0x82EED3FC; continue 'dispatch;
	}
	// 82EED3F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EED3F4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EED3F8: 48000010  b 0x82eed408
	pc = 0x82EED408; continue 'dispatch;
            }
            0x82EED3FC => {
    //   block [0x82EED3FC..0x82EED408)
	// 82EED3FC: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EED400: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EED404: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	pc = 0x82EED408; continue 'dispatch;
            }
            0x82EED408 => {
    //   block [0x82EED408..0x82EED460)
	// 82EED408: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED40C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EED410: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED414: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED418: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED41C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EED420: 4BFFFDA1  bl 0x82eed1c0
	ctx.lr = 0x82EED424;
	sub_82EED1C0(ctx, base);
	// 82EED424: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EED428: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EED42C: 38ABC4AC  addi r5, r11, -0x3b54
	ctx.r[5].s64 = ctx.r[11].s64 + -15188;
	// 82EED430: 3880001B  li r4, 0x1b
	ctx.r[4].s64 = 27;
	// 82EED434: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EED438: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EED43C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82EED440: 4BFFDDA9  bl 0x82eeb1e8
	ctx.lr = 0x82EED444;
	sub_82EEB1E8(ctx, base);
	// 82EED444: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EED448: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EED44C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EED450: 48000261  bl 0x82eed6b0
	ctx.lr = 0x82EED454;
	sub_82EED6B0(ctx, base);
	// 82EED454: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EED458: 4BFFDF09  bl 0x82eeb360
	ctx.lr = 0x82EED45C;
	sub_82EEB360(ctx, base);
	// 82EED45C: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	pc = 0x82EED460; continue 'dispatch;
            }
            0x82EED460 => {
    //   block [0x82EED460..0x82EED468)
	// 82EED460: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EED464: 4BDBBFF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED468 size=44
    let mut pc: u32 = 0x82EED468;
    'dispatch: loop {
        match pc {
            0x82EED468 => {
    //   block [0x82EED468..0x82EED494)
	// 82EED468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED46C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED470: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED474: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED478: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED47C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EED480: 4BFFFD41  bl 0x82eed1c0
	ctx.lr = 0x82EED484;
	sub_82EED1C0(ctx, base);
	// 82EED484: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED48C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED498 size=56
    let mut pc: u32 = 0x82EED498;
    'dispatch: loop {
        match pc {
            0x82EED498 => {
    //   block [0x82EED498..0x82EED4D0)
	// 82EED498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED49C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED4A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED4A4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED4A8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED4AC: 481176FD  bl 0x83004ba8
	ctx.lr = 0x82EED4B0;
	sub_83004BA8(ctx, base);
	// 82EED4B0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED4B4: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82EED4B8: 481176F1  bl 0x83004ba8
	ctx.lr = 0x82EED4BC;
	sub_83004BA8(ctx, base);
	// 82EED4BC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED4C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED4C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED4C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED4CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED4D0 size=84
    let mut pc: u32 = 0x82EED4D0;
    'dispatch: loop {
        match pc {
            0x82EED4D0 => {
    //   block [0x82EED4D0..0x82EED4FC)
	// 82EED4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED4D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED4D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED4DC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED4E0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED4E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED4E8: 419A0014  beq cr6, 0x82eed4fc
	if ctx.cr[6].eq {
	pc = 0x82EED4FC; continue 'dispatch;
	}
	// 82EED4EC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED4F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EED4F4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EED4F8: 4800000C  b 0x82eed504
	pc = 0x82EED504; continue 'dispatch;
            }
            0x82EED4FC => {
    //   block [0x82EED4FC..0x82EED504)
	// 82EED4FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EED500: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EED504; continue 'dispatch;
            }
            0x82EED504 => {
    //   block [0x82EED504..0x82EED524)
	// 82EED504: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EED508: 48000171  bl 0x82eed678
	ctx.lr = 0x82EED50C;
	sub_82EED678(ctx, base);
	// 82EED50C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED510: 48000169  bl 0x82eed678
	ctx.lr = 0x82EED514;
	sub_82EED678(ctx, base);
	// 82EED514: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED51C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED528 size=192
    let mut pc: u32 = 0x82EED528;
    'dispatch: loop {
        match pc {
            0x82EED528 => {
    //   block [0x82EED528..0x82EED578)
	// 82EED528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED52C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED530: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED534: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED538: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED53C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED540: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EED544: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EED548: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED54C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EED550: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EED554: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED558: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EED55C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EED560: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED564: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED568: 409A0010  bne cr6, 0x82eed578
	if !ctx.cr[6].eq {
	pc = 0x82EED578; continue 'dispatch;
	}
	// 82EED56C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EED570: 48000068  b 0x82eed5d8
	pc = 0x82EED5D8; continue 'dispatch;
	// 82EED574: 48000060  b 0x82eed5d4
	pc = 0x82EED5D4; continue 'dispatch;
            }
            0x82EED578 => {
    //   block [0x82EED578..0x82EED594)
	// 82EED578: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED57C: 4800019D  bl 0x82eed718
	ctx.lr = 0x82EED580;
	sub_82EED718(ctx, base);
	// 82EED580: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED584: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EED588: 4098000C  bge cr6, 0x82eed594
	if !ctx.cr[6].lt {
	pc = 0x82EED594; continue 'dispatch;
	}
	// 82EED58C: 480001B5  bl 0x82eed740
	ctx.lr = 0x82EED590;
	sub_82EED740(ctx, base);
	// 82EED590: 48000044  b 0x82eed5d4
	pc = 0x82EED5D4; continue 'dispatch;
            }
            0x82EED594 => {
    //   block [0x82EED594..0x82EED5D4)
	// 82EED594: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED598: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED59C: 48000205  bl 0x82eed7a0
	ctx.lr = 0x82EED5A0;
	sub_82EED7A0(ctx, base);
	// 82EED5A0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED5A4: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82EED5A8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED5AC: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED5B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED5B4: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EED5B8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED5BC: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED5C0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EED5C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EED5C8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EED5CC: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED5D0: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x82EED5D4; continue 'dispatch;
            }
            0x82EED5D4 => {
    //   block [0x82EED5D4..0x82EED5D8)
	// 82EED5D4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EED5D8; continue 'dispatch;
            }
            0x82EED5D8 => {
    //   block [0x82EED5D8..0x82EED5E8)
	// 82EED5D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED5DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED5E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED5E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED5E8 size=56
    let mut pc: u32 = 0x82EED5E8;
    'dispatch: loop {
        match pc {
            0x82EED5E8 => {
    //   block [0x82EED5E8..0x82EED620)
	// 82EED5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED5EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED5F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED5F4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED5F8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED5FC: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EED600: 48000279  bl 0x82eed878
	ctx.lr = 0x82EED604;
	sub_82EED878(ctx, base);
	// 82EED604: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED608: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EED60C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EED610: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED614: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED618: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED61C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED620 size=88
    let mut pc: u32 = 0x82EED620;
    'dispatch: loop {
        match pc {
            0x82EED620 => {
    //   block [0x82EED620..0x82EED65C)
	// 82EED620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED628: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED62C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED630: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED634: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED638: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED63C: 48000155  bl 0x82eed790
	ctx.lr = 0x82EED640;
	sub_82EED790(ctx, base);
	// 82EED640: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED648: 419A0014  beq cr6, 0x82eed65c
	if ctx.cr[6].eq {
	pc = 0x82EED65C; continue 'dispatch;
	}
	// 82EED64C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED650: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EED654: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EED658: 4800000C  b 0x82eed664
	pc = 0x82EED664; continue 'dispatch;
            }
            0x82EED65C => {
    //   block [0x82EED65C..0x82EED664)
	// 82EED65C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EED660: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EED664; continue 'dispatch;
            }
            0x82EED664 => {
    //   block [0x82EED664..0x82EED678)
	// 82EED664: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED668: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED66C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED670: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED674: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EED678 size=8
    let mut pc: u32 = 0x82EED678;
    'dispatch: loop {
        match pc {
            0x82EED678 => {
    //   block [0x82EED678..0x82EED680)
	// 82EED678: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EED67C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED680 size=48
    let mut pc: u32 = 0x82EED680;
    'dispatch: loop {
        match pc {
            0x82EED680 => {
    //   block [0x82EED680..0x82EED6B0)
	// 82EED680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED688: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED68C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED690: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED694: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EED698: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED69C: 4B3FCB1D  bl 0x822ea1b8
	ctx.lr = 0x82EED6A0;
	sub_822EA1B8(ctx, base);
	// 82EED6A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED6A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED6A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED6AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED6B0 size=44
    let mut pc: u32 = 0x82EED6B0;
    'dispatch: loop {
        match pc {
            0x82EED6B0 => {
    //   block [0x82EED6B0..0x82EED6DC)
	// 82EED6B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED6B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED6B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED6BC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED6C0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED6C4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EED6C8: 48000241  bl 0x82eed908
	ctx.lr = 0x82EED6CC;
	sub_82EED908(ctx, base);
	// 82EED6CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED6D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED6D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED6D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED6E0 size=56
    let mut pc: u32 = 0x82EED6E0;
    'dispatch: loop {
        match pc {
            0x82EED6E0 => {
    //   block [0x82EED6E0..0x82EED718)
	// 82EED6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED6E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED6E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED6EC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED6F0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED6F4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED6F8: 48000181  bl 0x82eed878
	ctx.lr = 0x82EED6FC;
	sub_82EED878(ctx, base);
	// 82EED6FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EED700: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED704: 480000CD  bl 0x82eed7d0
	ctx.lr = 0x82EED708;
	sub_82EED7D0(ctx, base);
	// 82EED708: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED70C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED710: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED714: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED718 size=40
    let mut pc: u32 = 0x82EED718;
    'dispatch: loop {
        match pc {
            0x82EED718 => {
    //   block [0x82EED718..0x82EED740)
	// 82EED718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED71C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED720: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED724: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED728: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED72C: 48000175  bl 0x82eed8a0
	ctx.lr = 0x82EED730;
	sub_82EED8A0(ctx, base);
	// 82EED730: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED734: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED738: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED73C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED740 size=76
    let mut pc: u32 = 0x82EED740;
    'dispatch: loop {
        match pc {
            0x82EED740 => {
    //   block [0x82EED740..0x82EED78C)
	// 82EED740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED744: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED748: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED74C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EED750: 388B16DC  addi r4, r11, 0x16dc
	ctx.r[4].s64 = ctx.r[11].s64 + 5852;
	// 82EED754: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EED758: 4B4047E9  bl 0x822f1f40
	ctx.lr = 0x82EED75C;
	sub_822F1F40(ctx, base);
	// 82EED75C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82EED760: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EED764: 4B40460D  bl 0x822f1d70
	ctx.lr = 0x82EED768;
	sub_822F1D70(ctx, base);
	// 82EED768: 4B4046B9  bl 0x822f1e20
	ctx.lr = 0x82EED76C;
	sub_822F1E20(ctx, base);
	// 82EED76C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EED770: 4B404571  bl 0x822f1ce0
	ctx.lr = 0x82EED774;
	sub_822F1CE0(ctx, base);
	// 82EED774: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EED778: 4B284099  bl 0x82171810
	ctx.lr = 0x82EED77C;
	sub_82171810(ctx, base);
	// 82EED77C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EED780: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED784: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED788: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EED790 size=16
    let mut pc: u32 = 0x82EED790;
    'dispatch: loop {
        match pc {
            0x82EED790 => {
    //   block [0x82EED790..0x82EED7A0)
	// 82EED790: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EED794: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EED798: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EED79C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED7A0 size=48
    let mut pc: u32 = 0x82EED7A0;
    'dispatch: loop {
        match pc {
            0x82EED7A0 => {
    //   block [0x82EED7A0..0x82EED7D0)
	// 82EED7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED7A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED7A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED7AC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED7B0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED7B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EED7B8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED7BC: 4800018D  bl 0x82eed948
	ctx.lr = 0x82EED7C0;
	sub_82EED948(ctx, base);
	// 82EED7C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED7C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED7C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED7CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED7D0 size=168
    let mut pc: u32 = 0x82EED7D0;
    'dispatch: loop {
        match pc {
            0x82EED7D0 => {
    //   block [0x82EED7D0..0x82EED844)
	// 82EED7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED7D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED7D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EED7DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED7E0: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EED7E4: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EED7E8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EED7EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EED7F0: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EED7F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EED7F8: 409A004C  bne cr6, 0x82eed844
	if !ctx.cr[6].eq {
	pc = 0x82EED844; continue 'dispatch;
	}
	// 82EED7FC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EED800: 896B8F69  lbz r11, -0x7097(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28823 as u32) ) } as u64;
	// 82EED804: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EED808: 4082003C  bne 0x82eed844
	if !ctx.cr[0].eq {
	pc = 0x82EED844; continue 'dispatch;
	}
	// 82EED80C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EED810: 3BEB8F69  addi r31, r11, -0x7097
	ctx.r[31].s64 = ctx.r[11].s64 + -28823;
	// 82EED814: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EED818: 38CBC53C  addi r6, r11, -0x3ac4
	ctx.r[6].s64 = ctx.r[11].s64 + -15044;
	// 82EED81C: 38A0002F  li r5, 0x2f
	ctx.r[5].s64 = 47;
	// 82EED820: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EED824: 388BC4D8  addi r4, r11, -0x3b28
	ctx.r[4].s64 = ctx.r[11].s64 + -15144;
	// 82EED828: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EED82C: 4BFFD93D  bl 0x82eeb168
	ctx.lr = 0x82EED830;
	sub_82EEB168(ctx, base);
	// 82EED830: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EED834: 48204585  bl 0x830f1db8
	ctx.lr = 0x82EED838;
	sub_830F1DB8(ctx, base);
	// 82EED838: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EED83C: 40820008  bne 0x82eed844
	if !ctx.cr[0].eq {
	pc = 0x82EED844; continue 'dispatch;
	}
	// 82EED840: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EED844; continue 'dispatch;
            }
            0x82EED844 => {
    //   block [0x82EED844..0x82EED878)
	// 82EED844: 83E10084  lwz r31, 0x84(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EED848: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EED84C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EED850: 4BFFDAF1  bl 0x82eeb340
	ctx.lr = 0x82EED854;
	sub_82EEB340(ctx, base);
	// 82EED854: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EED858: 48000081  bl 0x82eed8d8
	ctx.lr = 0x82EED85C;
	sub_82EED8D8(ctx, base);
	// 82EED85C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EED860: 4BFFFE51  bl 0x82eed6b0
	ctx.lr = 0x82EED864;
	sub_82EED6B0(ctx, base);
	// 82EED864: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EED868: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED86C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED870: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EED874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EED878 size=36
    let mut pc: u32 = 0x82EED878;
    'dispatch: loop {
        match pc {
            0x82EED878 => {
    //   block [0x82EED878..0x82EED89C)
	// 82EED878: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EED87C: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EED880: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EED884: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EED888: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EED88C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EED890: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EED894: 8061FFF0  lwz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EED898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EED8A0 size=56
    let mut pc: u32 = 0x82EED8A0;
    'dispatch: loop {
        match pc {
            0x82EED8A0 => {
    //   block [0x82EED8A0..0x82EED8C8)
	// 82EED8A0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EED8A4: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 82EED8A8: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82EED8AC: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EED8B0: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EED8B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED8B8: 40990010  ble cr6, 0x82eed8c8
	if !ctx.cr[6].gt {
	pc = 0x82EED8C8; continue 'dispatch;
	}
	// 82EED8BC: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EED8C0: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 82EED8C4: 4800000C  b 0x82eed8d0
	pc = 0x82EED8D0; continue 'dispatch;
            }
            0x82EED8C8 => {
    //   block [0x82EED8C8..0x82EED8D0)
	// 82EED8C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EED8CC: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	pc = 0x82EED8D0; continue 'dispatch;
            }
            0x82EED8D0 => {
    //   block [0x82EED8D0..0x82EED8D8)
	// 82EED8D0: 8061FFF4  lwz r3, -0xc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EED8D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED8D8 size=48
    let mut pc: u32 = 0x82EED8D8;
    'dispatch: loop {
        match pc {
            0x82EED8D8 => {
    //   block [0x82EED8D8..0x82EED908)
	// 82EED8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED8DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED8E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED8E4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED8E8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED8EC: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED8F0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED8F4: 4BC62355  bl 0x82b4fc48
	ctx.lr = 0x82EED8F8;
	sub_82B4FC48(ctx, base);
	// 82EED8F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED8FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED900: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED904: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED908 size=60
    let mut pc: u32 = 0x82EED908;
    'dispatch: loop {
        match pc {
            0x82EED908 => {
    //   block [0x82EED908..0x82EED934)
	// 82EED908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED90C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED910: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED914: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED918: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED91C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED920: 419A0014  beq cr6, 0x82eed934
	if ctx.cr[6].eq {
	pc = 0x82EED934; continue 'dispatch;
	}
	// 82EED924: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED928: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EED92C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EED930: 4B957E81  bl 0x828457b0
	ctx.lr = 0x82EED934;
	sub_828457B0(ctx, base);
	pc = 0x82EED934; continue 'dispatch;
            }
            0x82EED934 => {
    //   block [0x82EED934..0x82EED944)
	// 82EED934: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED938: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED93C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EED948 size=120
    let mut pc: u32 = 0x82EED948;
    'dispatch: loop {
        match pc {
            0x82EED948 => {
    //   block [0x82EED948..0x82EED974)
	// 82EED948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED94C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED950: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED954: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED958: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED95C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED964: 41990010  bgt cr6, 0x82eed974
	if ctx.cr[6].gt {
	pc = 0x82EED974; continue 'dispatch;
	}
	// 82EED968: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EED96C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EED970: 48000034  b 0x82eed9a4
	pc = 0x82EED9A4; continue 'dispatch;
            }
            0x82EED974 => {
    //   block [0x82EED974..0x82EED9A4)
	// 82EED974: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED978: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EED97C: 0CCB0000  twi 6, r11, 0
	// 82EED980: 7D6A5B96  divwu r11, r10, r11
	ctx.r[11].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 82EED984: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82EED988: 4098001C  bge cr6, 0x82eed9a4
	if !ctx.cr[6].lt {
	pc = 0x82EED9A4; continue 'dispatch;
	}
	// 82EED98C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EED990: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EED994: 4B404265  bl 0x822f1bf8
	ctx.lr = 0x82EED998;
	sub_822F1BF8(ctx, base);
	// 82EED998: 4B404489  bl 0x822f1e20
	ctx.lr = 0x82EED99C;
	sub_822F1E20(ctx, base);
	// 82EED99C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EED9A0: 4B4041F9  bl 0x822f1b98
	ctx.lr = 0x82EED9A4;
	sub_822F1B98(ctx, base);
	pc = 0x82EED9A4; continue 'dispatch;
            }
            0x82EED9A4 => {
    //   block [0x82EED9A4..0x82EED9C0)
	// 82EED9A4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED9A8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EED9AC: 4B3FC80D  bl 0x822ea1b8
	ctx.lr = 0x82EED9B0;
	sub_822EA1B8(ctx, base);
	// 82EED9B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EED9B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EED9B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EED9BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EED9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EED9C0 size=100
    let mut pc: u32 = 0x82EED9C0;
    'dispatch: loop {
        match pc {
            0x82EED9C0 => {
    //   block [0x82EED9C0..0x82EED9F4)
	// 82EED9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EED9C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EED9C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EED9CC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EED9D0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EED9D4: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EED9D8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EED9DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED9E0: 409A0014  bne cr6, 0x82eed9f4
	if !ctx.cr[6].eq {
	pc = 0x82EED9F4; continue 'dispatch;
	}
	// 82EED9E4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED9E8: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 82EED9EC: 7C6B5910  subfe r3, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[3].u32 = res;
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82EED9F0: 48000024  b 0x82eeda14
	pc = 0x82EEDA14; continue 'dispatch;
            }
            0x82EED9F4 => {
    //   block [0x82EED9F4..0x82EEDA08)
	// 82EED9F4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EED9F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EED9FC: 409A000C  bne cr6, 0x82eeda08
	if !ctx.cr[6].eq {
	pc = 0x82EEDA08; continue 'dispatch;
	}
	// 82EEDA00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EEDA04: 48000010  b 0x82eeda14
	pc = 0x82EEDA14; continue 'dispatch;
            }
            0x82EEDA08 => {
    //   block [0x82EEDA08..0x82EEDA14)
	// 82EEDA08: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDA0C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDA10: 4BDBF141  bl 0x82cacb50
	ctx.lr = 0x82EEDA14;
	sub_82CACB50(ctx, base);
	pc = 0x82EEDA14; continue 'dispatch;
            }
            0x82EEDA14 => {
    //   block [0x82EEDA14..0x82EEDA24)
	// 82EEDA14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDA18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDA1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDA20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDA28 size=56
    let mut pc: u32 = 0x82EEDA28;
    'dispatch: loop {
        match pc {
            0x82EEDA28 => {
    //   block [0x82EEDA28..0x82EEDA60)
	// 82EEDA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDA2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDA30: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDA34: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDA38: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEDA3C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEDA40: 38A10084  addi r5, r1, 0x84
	ctx.r[5].s64 = ctx.r[1].s64 + 132;
	// 82EEDA44: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EEDA48: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EEDA4C: 4800019D  bl 0x82eedbe8
	ctx.lr = 0x82EEDA50;
	sub_82EEDBE8(ctx, base);
	// 82EEDA50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDA54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDA58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDA5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDA60 size=24
    let mut pc: u32 = 0x82EEDA60;
    'dispatch: loop {
        match pc {
            0x82EEDA60 => {
    //   block [0x82EEDA60..0x82EEDA78)
	// 82EEDA60: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEDA64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEDA68: 396BC2DC  addi r11, r11, -0x3d24
	ctx.r[11].s64 = ctx.r[11].s64 + -15652;
	// 82EEDA6C: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEDA70: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEDA74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDA78 size=68
    let mut pc: u32 = 0x82EEDA78;
    'dispatch: loop {
        match pc {
            0x82EEDA78 => {
    //   block [0x82EEDA78..0x82EEDAA8)
	// 82EEDA78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDA7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDA80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDA84: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDA88: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEDA8C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDA90: 4BFFFFD1  bl 0x82eeda60
	ctx.lr = 0x82EEDA94;
	sub_82EEDA60(ctx, base);
	// 82EEDA94: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDA98: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDA9C: 4182000C  beq 0x82eedaa8
	if ctx.cr[0].eq {
	pc = 0x82EEDAA8; continue 'dispatch;
	}
	// 82EEDAA0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDAA4: 4B957D0D  bl 0x828457b0
	ctx.lr = 0x82EEDAA8;
	sub_828457B0(ctx, base);
	pc = 0x82EEDAA8; continue 'dispatch;
            }
            0x82EEDAA8 => {
    //   block [0x82EEDAA8..0x82EEDABC)
	// 82EEDAA8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDAAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDAB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDAB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDAB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDAC0 size=24
    let mut pc: u32 = 0x82EEDAC0;
    'dispatch: loop {
        match pc {
            0x82EEDAC0 => {
    //   block [0x82EEDAC0..0x82EEDAD8)
	// 82EEDAC0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEDAC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEDAC8: 396BC2C0  addi r11, r11, -0x3d40
	ctx.r[11].s64 = ctx.r[11].s64 + -15680;
	// 82EEDACC: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEDAD0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEDAD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDAD8 size=12
    let mut pc: u32 = 0x82EEDAD8;
    'dispatch: loop {
        match pc {
            0x82EEDAD8 => {
    //   block [0x82EEDAD8..0x82EEDAE4)
	// 82EEDAD8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEDADC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEDAE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDAE8 size=68
    let mut pc: u32 = 0x82EEDAE8;
    'dispatch: loop {
        match pc {
            0x82EEDAE8 => {
    //   block [0x82EEDAE8..0x82EEDB18)
	// 82EEDAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDAEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDAF0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDAF4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDAF8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEDAFC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDB00: 4BFFFFC1  bl 0x82eedac0
	ctx.lr = 0x82EEDB04;
	sub_82EEDAC0(ctx, base);
	// 82EEDB04: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDB08: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDB0C: 4182000C  beq 0x82eedb18
	if ctx.cr[0].eq {
	pc = 0x82EEDB18; continue 'dispatch;
	}
	// 82EEDB10: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDB14: 4B957C9D  bl 0x828457b0
	ctx.lr = 0x82EEDB18;
	sub_828457B0(ctx, base);
	pc = 0x82EEDB18; continue 'dispatch;
            }
            0x82EEDB18 => {
    //   block [0x82EEDB18..0x82EEDB2C)
	// 82EEDB18: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDB1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDB20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDB24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDB28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDB30 size=64
    let mut pc: u32 = 0x82EEDB30;
    'dispatch: loop {
        match pc {
            0x82EEDB30 => {
    //   block [0x82EEDB30..0x82EEDB70)
	// 82EEDB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDB34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDB38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDB3C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDB40: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEDB44: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDB48: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDB4C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDB50: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEDB54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEDB58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEDB5C: 4E800421  bctrl
	ctx.lr = 0x82EEDB60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEDB60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDB64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDB68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDB6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDB70 size=48
    let mut pc: u32 = 0x82EEDB70;
    'dispatch: loop {
        match pc {
            0x82EEDB70 => {
    //   block [0x82EEDB70..0x82EEDBA0)
	// 82EEDB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDB74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDB78: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDB7C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDB80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEDB84: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDB88: 386B001C  addi r3, r11, 0x1c
	ctx.r[3].s64 = ctx.r[11].s64 + 28;
	// 82EEDB8C: 4800002D  bl 0x82eedbb8
	ctx.lr = 0x82EEDB90;
	sub_82EEDBB8(ctx, base);
	// 82EEDB90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDB94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDB98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDB9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDBA0 size=20
    let mut pc: u32 = 0x82EEDBA0;
    'dispatch: loop {
        match pc {
            0x82EEDBA0 => {
    //   block [0x82EEDBA0..0x82EEDBB4)
	// 82EEDBA0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEDBA4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEDBA8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EEDBAC: 994B0010  stb r10, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 82EEDBB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDBB8 size=44
    let mut pc: u32 = 0x82EEDBB8;
    'dispatch: loop {
        match pc {
            0x82EEDBB8 => {
    //   block [0x82EEDBB8..0x82EEDBE4)
	// 82EEDBB8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEDBBC: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EEDBC0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEDBC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEDBC8: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEDBCC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EEDBD0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EEDBD4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EEDBD8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82EEDBDC: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EEDBE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDBE8 size=92
    let mut pc: u32 = 0x82EEDBE8;
    'dispatch: loop {
        match pc {
            0x82EEDBE8 => {
    //   block [0x82EEDBE8..0x82EEDC30)
	// 82EEDBE8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEDBEC: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EEDBF0: 90A10024  stw r5, 0x24(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), ctx.r[5].u32 ) };
	// 82EEDBF4: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEDBF8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEDBFC: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEDC00: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEDC04: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEDC08: 41990028  bgt cr6, 0x82eedc30
	if ctx.cr[6].gt {
	pc = 0x82EEDC30; continue 'dispatch;
	}
	// 82EEDC0C: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEDC10: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEDC14: 81410024  lwz r10, 0x24(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EEDC18: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEDC1C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEDC20: 41990010  bgt cr6, 0x82eedc30
	if ctx.cr[6].gt {
	pc = 0x82EEDC30; continue 'dispatch;
	}
	// 82EEDC24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EEDC28: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEDC2C: 4800000C  b 0x82eedc38
	pc = 0x82EEDC38; continue 'dispatch;
            }
            0x82EEDC30 => {
    //   block [0x82EEDC30..0x82EEDC38)
	// 82EEDC30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEDC34: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEDC38; continue 'dispatch;
            }
            0x82EEDC38 => {
    //   block [0x82EEDC38..0x82EEDC44)
	// 82EEDC38: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEDC3C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EEDC40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDC48 size=44
    let mut pc: u32 = 0x82EEDC48;
    'dispatch: loop {
        match pc {
            0x82EEDC48 => {
    //   block [0x82EEDC48..0x82EEDC74)
	// 82EEDC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDC4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDC50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDC54: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDC58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEDC5C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDC60: 4800B0E1  bl 0x82ef8d40
	ctx.lr = 0x82EEDC64;
	sub_82EF8D40(ctx, base);
	// 82EEDC64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDC68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDC6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDC70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEDC78 size=24
    let mut pc: u32 = 0x82EEDC78;
    'dispatch: loop {
        match pc {
            0x82EEDC78 => {
    //   block [0x82EEDC78..0x82EEDC90)
	// 82EEDC78: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEDC7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEDC80: 396BC544  addi r11, r11, -0x3abc
	ctx.r[11].s64 = ctx.r[11].s64 + -15036;
	// 82EEDC84: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEDC88: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEDC8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDC90 size=144
    let mut pc: u32 = 0x82EEDC90;
    'dispatch: loop {
        match pc {
            0x82EEDC90 => {
    //   block [0x82EEDC90..0x82EEDCE4)
	// 82EEDC90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDC94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDC98: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDC9C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDCA0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEDCA4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDCA8: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDCAC: 41820044  beq 0x82eedcf0
	if ctx.cr[0].eq {
	pc = 0x82EEDCF0; continue 'dispatch;
	}
	// 82EEDCB0: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EEDCB4: 38CBDC78  addi r6, r11, -0x2388
	ctx.r[6].s64 = ctx.r[11].s64 + -9096;
	// 82EEDCB8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDCBC: 80ABFFFC  lwz r5, -4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EEDCC0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EEDCC4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDCC8: 4B402371  bl 0x822f0038
	ctx.lr = 0x82EEDCCC;
	sub_822F0038(ctx, base);
	// 82EEDCCC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDCD0: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDCD4: 41820010  beq 0x82eedce4
	if ctx.cr[0].eq {
	pc = 0x82EEDCE4; continue 'dispatch;
	}
	// 82EEDCD8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDCDC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82EEDCE0: 4B957AD1  bl 0x828457b0
	ctx.lr = 0x82EEDCE4;
	sub_828457B0(ctx, base);
	pc = 0x82EEDCE4; continue 'dispatch;
            }
            0x82EEDCE4 => {
    //   block [0x82EEDCE4..0x82EEDCF0)
	// 82EEDCE4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDCE8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82EEDCEC: 48000024  b 0x82eedd10
	pc = 0x82EEDD10; continue 'dispatch;
            }
            0x82EEDCF0 => {
    //   block [0x82EEDCF0..0x82EEDD0C)
	// 82EEDCF0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDCF4: 4BFFFF85  bl 0x82eedc78
	ctx.lr = 0x82EEDCF8;
	sub_82EEDC78(ctx, base);
	// 82EEDCF8: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDCFC: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDD00: 4182000C  beq 0x82eedd0c
	if ctx.cr[0].eq {
	pc = 0x82EEDD0C; continue 'dispatch;
	}
	// 82EEDD04: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDD08: 4B957AA9  bl 0x828457b0
	ctx.lr = 0x82EEDD0C;
	sub_828457B0(ctx, base);
	pc = 0x82EEDD0C; continue 'dispatch;
            }
            0x82EEDD0C => {
    //   block [0x82EEDD0C..0x82EEDD10)
	// 82EEDD0C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	pc = 0x82EEDD10; continue 'dispatch;
            }
            0x82EEDD10 => {
    //   block [0x82EEDD10..0x82EEDD20)
	// 82EEDD10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDD14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDD18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDD1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDD20 size=56
    let mut pc: u32 = 0x82EEDD20;
    'dispatch: loop {
        match pc {
            0x82EEDD20 => {
    //   block [0x82EEDD20..0x82EEDD58)
	// 82EEDD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDD24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDD28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDD2C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDD30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEDD34: 396BC558  addi r11, r11, -0x3aa8
	ctx.r[11].s64 = ctx.r[11].s64 + -15016;
	// 82EEDD38: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDD3C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEDD40: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDD44: 4BFFFF35  bl 0x82eedc78
	ctx.lr = 0x82EEDD48;
	sub_82EEDC78(ctx, base);
	// 82EEDD48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDD4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDD50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDD54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDD58 size=144
    let mut pc: u32 = 0x82EEDD58;
    'dispatch: loop {
        match pc {
            0x82EEDD58 => {
    //   block [0x82EEDD58..0x82EEDDAC)
	// 82EEDD58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDD5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDD60: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDD64: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDD68: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEDD6C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDD70: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDD74: 41820044  beq 0x82eeddb8
	if ctx.cr[0].eq {
	pc = 0x82EEDDB8; continue 'dispatch;
	}
	// 82EEDD78: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EEDD7C: 38CBDD20  addi r6, r11, -0x22e0
	ctx.r[6].s64 = ctx.r[11].s64 + -8928;
	// 82EEDD80: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDD84: 80ABFFFC  lwz r5, -4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EEDD88: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EEDD8C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDD90: 4B4022A9  bl 0x822f0038
	ctx.lr = 0x82EEDD94;
	sub_822F0038(ctx, base);
	// 82EEDD94: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDD98: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDD9C: 41820010  beq 0x82eeddac
	if ctx.cr[0].eq {
	pc = 0x82EEDDAC; continue 'dispatch;
	}
	// 82EEDDA0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDDA4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82EEDDA8: 4B957A09  bl 0x828457b0
	ctx.lr = 0x82EEDDAC;
	sub_828457B0(ctx, base);
	pc = 0x82EEDDAC; continue 'dispatch;
            }
            0x82EEDDAC => {
    //   block [0x82EEDDAC..0x82EEDDB8)
	// 82EEDDAC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDDB0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82EEDDB4: 48000024  b 0x82eeddd8
	pc = 0x82EEDDD8; continue 'dispatch;
            }
            0x82EEDDB8 => {
    //   block [0x82EEDDB8..0x82EEDDD4)
	// 82EEDDB8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDDBC: 4BFFFF65  bl 0x82eedd20
	ctx.lr = 0x82EEDDC0;
	sub_82EEDD20(ctx, base);
	// 82EEDDC0: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEDDC4: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDDC8: 4182000C  beq 0x82eeddd4
	if ctx.cr[0].eq {
	pc = 0x82EEDDD4; continue 'dispatch;
	}
	// 82EEDDCC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDDD0: 4B9579E1  bl 0x828457b0
	ctx.lr = 0x82EEDDD4;
	sub_828457B0(ctx, base);
	pc = 0x82EEDDD4; continue 'dispatch;
            }
            0x82EEDDD4 => {
    //   block [0x82EEDDD4..0x82EEDDD8)
	// 82EEDDD4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	pc = 0x82EEDDD8; continue 'dispatch;
            }
            0x82EEDDD8 => {
    //   block [0x82EEDDD8..0x82EEDDE8)
	// 82EEDDD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDDDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDDE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDDE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDDE8 size=48
    let mut pc: u32 = 0x82EEDDE8;
    'dispatch: loop {
        match pc {
            0x82EEDDE8 => {
    //   block [0x82EEDDE8..0x82EEDE18)
	// 82EEDDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDDEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDDF0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDDF4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDDF8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEDDFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EEDE00: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDE04: 4800CCC5  bl 0x82efaac8
	ctx.lr = 0x82EEDE08;
	sub_82EFAAC8(ctx, base);
	// 82EEDE08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDE0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDE10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDE14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDE18 size=48
    let mut pc: u32 = 0x82EEDE18;
    'dispatch: loop {
        match pc {
            0x82EEDE18 => {
    //   block [0x82EEDE18..0x82EEDE48)
	// 82EEDE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDE1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDE20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDE24: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDE28: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEDE2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEDE30: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDE34: 4800BD4D  bl 0x82ef9b80
	ctx.lr = 0x82EEDE38;
	sub_82EF9B80(ctx, base);
	// 82EEDE38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDE3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDE40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDE44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDE48 size=48
    let mut pc: u32 = 0x82EEDE48;
    'dispatch: loop {
        match pc {
            0x82EEDE48 => {
    //   block [0x82EEDE48..0x82EEDE78)
	// 82EEDE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDE4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDE50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDE54: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDE58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEDE5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EEDE60: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDE64: 4800BE9D  bl 0x82ef9d00
	ctx.lr = 0x82EEDE68;
	sub_82EF9D00(ctx, base);
	// 82EEDE68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDE6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDE70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDE74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDE78 size=48
    let mut pc: u32 = 0x82EEDE78;
    'dispatch: loop {
        match pc {
            0x82EEDE78 => {
    //   block [0x82EEDE78..0x82EEDEA8)
	// 82EEDE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDE7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDE80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDE84: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDE88: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82EEDE8C: 3C800002  lis r4, 2
	ctx.r[4].s64 = 131072;
	// 82EEDE90: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDE94: 4800D96D  bl 0x82efb800
	ctx.lr = 0x82EEDE98;
	sub_82EFB800(ctx, base);
	// 82EEDE98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDE9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDEA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDEA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDEA8 size=196
    let mut pc: u32 = 0x82EEDEA8;
    'dispatch: loop {
        match pc {
            0x82EEDEA8 => {
    //   block [0x82EEDEA8..0x82EEDF38)
	// 82EEDEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDEAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDEB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEDEB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDEB8: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEDEBC: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEDEC0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEDEC4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEDEC8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEDECC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEDED0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEDED4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEDED8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEDEDC: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEDEE0: 48000759  bl 0x82eee638
	ctx.lr = 0x82EEDEE4;
	sub_82EEE638(ctx, base);
	// 82EEDEE4: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEDEE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDEEC: 4098004C  bge cr6, 0x82eedf38
	if !ctx.cr[6].lt {
	pc = 0x82EEDF38; continue 'dispatch;
	}
	// 82EEDEF0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEDEF4: 896B8F70  lbz r11, -0x7090(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28816 as u32) ) } as u64;
	// 82EEDEF8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEDEFC: 4082003C  bne 0x82eedf38
	if !ctx.cr[0].eq {
	pc = 0x82EEDF38; continue 'dispatch;
	}
	// 82EEDF00: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEDF04: 3BEB8F70  addi r31, r11, -0x7090
	ctx.r[31].s64 = ctx.r[11].s64 + -28816;
	// 82EEDF08: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEDF0C: 38CBC594  addi r6, r11, -0x3a6c
	ctx.r[6].s64 = ctx.r[11].s64 + -14956;
	// 82EEDF10: 38A0000D  li r5, 0xd
	ctx.r[5].s64 = 13;
	// 82EEDF14: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEDF18: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 82EEDF1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEDF20: 4BFFD249  bl 0x82eeb168
	ctx.lr = 0x82EEDF24;
	sub_82EEB168(ctx, base);
	// 82EEDF24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEDF28: 48203E91  bl 0x830f1db8
	ctx.lr = 0x82EEDF2C;
	sub_830F1DB8(ctx, base);
	// 82EEDF2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDF30: 40820008  bne 0x82eedf38
	if !ctx.cr[0].eq {
	pc = 0x82EEDF38; continue 'dispatch;
	}
	// 82EEDF34: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEDF38; continue 'dispatch;
            }
            0x82EEDF38 => {
    //   block [0x82EEDF38..0x82EEDF54)
	// 82EEDF38: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEDF3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEDF40: 40990014  ble cr6, 0x82eedf54
	if !ctx.cr[6].gt {
	pc = 0x82EEDF54; continue 'dispatch;
	}
	// 82EEDF44: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEDF48: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEDF4C: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEDF50: 48000761  bl 0x82eee6b0
	ctx.lr = 0x82EEDF54;
	sub_82EEE6B0(ctx, base);
	pc = 0x82EEDF54; continue 'dispatch;
            }
            0x82EEDF54 => {
    //   block [0x82EEDF54..0x82EEDF6C)
	// 82EEDF54: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEDF58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEDF5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDF60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDF64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEDF68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDF70 size=52
    let mut pc: u32 = 0x82EEDF70;
    'dispatch: loop {
        match pc {
            0x82EEDF70 => {
    //   block [0x82EEDF70..0x82EEDFA4)
	// 82EEDF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDF74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDF78: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDF7C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEDF80: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDF84: 480002ED  bl 0x82eee270
	ctx.lr = 0x82EEDF88;
	sub_82EEE270(ctx, base);
	// 82EEDF88: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEDF8C: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEDF90: 480006F9  bl 0x82eee688
	ctx.lr = 0x82EEDF94;
	sub_82EEE688(ctx, base);
	// 82EEDF94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEDF98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEDF9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEDFA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEDFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEDFA8 size=156
    let mut pc: u32 = 0x82EEDFA8;
    'dispatch: loop {
        match pc {
            0x82EEDFA8 => {
    //   block [0x82EEDFA8..0x82EEE020)
	// 82EEDFA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEDFAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEDFB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEDFB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEDFB8: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEDFBC: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEDFC0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEDFC4: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEDFC8: 480008A9  bl 0x82eee870
	ctx.lr = 0x82EEDFCC;
	sub_82EEE870(ctx, base);
	// 82EEDFCC: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEDFD0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EEDFD4: 4198004C  blt cr6, 0x82eee020
	if ctx.cr[6].lt {
	pc = 0x82EEE020; continue 'dispatch;
	}
	// 82EEDFD8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEDFDC: 896B8F71  lbz r11, -0x708f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28815 as u32) ) } as u64;
	// 82EEDFE0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEDFE4: 4082003C  bne 0x82eee020
	if !ctx.cr[0].eq {
	pc = 0x82EEE020; continue 'dispatch;
	}
	// 82EEDFE8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEDFEC: 3BEB8F71  addi r31, r11, -0x708f
	ctx.r[31].s64 = ctx.r[11].s64 + -28815;
	// 82EEDFF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEDFF4: 38CBC5A0  addi r6, r11, -0x3a60
	ctx.r[6].s64 = ctx.r[11].s64 + -14944;
	// 82EEDFF8: 38A00019  li r5, 0x19
	ctx.r[5].s64 = 25;
	// 82EEDFFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE000: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 82EEE004: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEE008: 4BFFD161  bl 0x82eeb168
	ctx.lr = 0x82EEE00C;
	sub_82EEB168(ctx, base);
	// 82EEE00C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEE010: 48203DA9  bl 0x830f1db8
	ctx.lr = 0x82EEE014;
	sub_830F1DB8(ctx, base);
	// 82EEE014: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE018: 40820008  bne 0x82eee020
	if !ctx.cr[0].eq {
	pc = 0x82EEE020; continue 'dispatch;
	}
	// 82EEE01C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEE020; continue 'dispatch;
            }
            0x82EEE020 => {
    //   block [0x82EEE020..0x82EEE044)
	// 82EEE020: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEE024: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEE028: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEE02C: 4800088D  bl 0x82eee8b8
	ctx.lr = 0x82EEE030;
	sub_82EEE8B8(ctx, base);
	// 82EEE030: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEE034: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE038: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE03C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEE040: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE048 size=292
    let mut pc: u32 = 0x82EEE048;
    'dispatch: loop {
        match pc {
            0x82EEE048 => {
    //   block [0x82EEE048..0x82EEE0D8)
	// 82EEE048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE04C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE050: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEE054: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE058: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEE05C: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EEE060: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EEE064: 90C100AC  stw r6, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[6].u32 ) };
	// 82EEE068: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE06C: 480001CD  bl 0x82eee238
	ctx.lr = 0x82EEE070;
	sub_82EEE238(ctx, base);
	// 82EEE070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEE074: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEE078: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE07C: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 82EEE080: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82EEE084: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EEE088: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EEE08C: 80A100AC  lwz r5, 0xac(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EEE090: 808100A4  lwz r4, 0xa4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE094: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEE098: 4BDD6301  bl 0x82cc4398
	ctx.lr = 0x82EEE09C;
	sub_82CC4398(ctx, base);
	// 82EEE09C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEE0A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEE0A4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EEE0A8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EEE0AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEE0B0: 419A003C  beq cr6, 0x82eee0ec
	if ctx.cr[6].eq {
	pc = 0x82EEE0EC; continue 'dispatch;
	}
	// 82EEE0B4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EEE0B8: 2B0B0012  cmplwi cr6, r11, 0x12
	ctx.cr[6].compare_u32(ctx.r[11].u32, 18 as u32, &mut ctx.xer);
	// 82EEE0BC: 419A001C  beq cr6, 0x82eee0d8
	if ctx.cr[6].eq {
	pc = 0x82EEE0D8; continue 'dispatch;
	}
	// 82EEE0C0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EEE0C4: 3D408007  lis r10, -0x7ff9
	ctx.r[10].s64 = -2147024896;
	// 82EEE0C8: 614A0057  ori r10, r10, 0x57
	ctx.r[10].u64 = ctx.r[10].u64 | 87;
	// 82EEE0CC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEE0D0: 419A0010  beq cr6, 0x82eee0e0
	if ctx.cr[6].eq {
	pc = 0x82EEE0E0; continue 'dispatch;
	}
	// 82EEE0D4: 48000034  b 0x82eee108
	pc = 0x82EEE108; continue 'dispatch;
            }
            0x82EEE0D8 => {
    //   block [0x82EEE0D8..0x82EEE0E0)
	// 82EEE0D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EEE0DC: 4800007C  b 0x82eee158
	pc = 0x82EEE158; continue 'dispatch;
            }
            0x82EEE0E0 => {
    //   block [0x82EEE0E0..0x82EEE0EC)
	// 82EEE0E0: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EEE0E4: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EEE0E8: 48000070  b 0x82eee158
	pc = 0x82EEE158; continue 'dispatch;
            }
            0x82EEE0EC => {
    //   block [0x82EEE0EC..0x82EEE108)
	// 82EEE0EC: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE0F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EEE0F4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEE0F8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE0FC: 480001F5  bl 0x82eee2f0
	ctx.lr = 0x82EEE100;
	sub_82EEE2F0(ctx, base);
	// 82EEE100: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEE104: 48000054  b 0x82eee158
	pc = 0x82EEE158; continue 'dispatch;
            }
            0x82EEE108 => {
    //   block [0x82EEE108..0x82EEE150)
	// 82EEE108: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE10C: 896B8F72  lbz r11, -0x708e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28814 as u32) ) } as u64;
	// 82EEE110: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEE114: 4082003C  bne 0x82eee150
	if !ctx.cr[0].eq {
	pc = 0x82EEE150; continue 'dispatch;
	}
	// 82EEE118: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE11C: 3BEB8F72  addi r31, r11, -0x708e
	ctx.r[31].s64 = ctx.r[11].s64 + -28814;
	// 82EEE120: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EEE124: 38CB1700  addi r6, r11, 0x1700
	ctx.r[6].s64 = ctx.r[11].s64 + 5888;
	// 82EEE128: 38A0003D  li r5, 0x3d
	ctx.r[5].s64 = 61;
	// 82EEE12C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE130: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 82EEE134: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEE138: 4BFFD031  bl 0x82eeb168
	ctx.lr = 0x82EEE13C;
	sub_82EEB168(ctx, base);
	// 82EEE13C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEE140: 48203C79  bl 0x830f1db8
	ctx.lr = 0x82EEE144;
	sub_830F1DB8(ctx, base);
	// 82EEE144: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE148: 40820008  bne 0x82eee150
	if !ctx.cr[0].eq {
	pc = 0x82EEE150; continue 'dispatch;
	}
	// 82EEE14C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEE150; continue 'dispatch;
            }
            0x82EEE150 => {
    //   block [0x82EEE150..0x82EEE158)
	// 82EEE150: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EEE154: 61634005  ori r3, r11, 0x4005
	ctx.r[3].u64 = ctx.r[11].u64 | 16389;
	pc = 0x82EEE158; continue 'dispatch;
            }
            0x82EEE158 => {
    //   block [0x82EEE158..0x82EEE16C)
	// 82EEE158: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEE15C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE160: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE164: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEE168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE170 size=80
    let mut pc: u32 = 0x82EEE170;
    'dispatch: loop {
        match pc {
            0x82EEE170 => {
    //   block [0x82EEE170..0x82EEE198)
	// 82EEE170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE178: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE17C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEE180: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE184: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEE188: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE18C: 409A000C  bne cr6, 0x82eee198
	if !ctx.cr[6].eq {
	pc = 0x82EEE198; continue 'dispatch;
	}
	// 82EEE190: 48000020  b 0x82eee1b0
	pc = 0x82EEE1B0; continue 'dispatch;
	// 82EEE194: 4800001C  b 0x82eee1b0
	pc = 0x82EEE1B0; continue 'dispatch;
            }
            0x82EEE198 => {
    //   block [0x82EEE198..0x82EEE1B0)
	// 82EEE198: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE19C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEE1A0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EEE1A4: 409A000C  bne cr6, 0x82eee1b0
	if !ctx.cr[6].eq {
	pc = 0x82EEE1B0; continue 'dispatch;
	}
	// 82EEE1A8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE1AC: 4800028D  bl 0x82eee438
	ctx.lr = 0x82EEE1B0;
	sub_82EEE438(ctx, base);
	pc = 0x82EEE1B0; continue 'dispatch;
            }
            0x82EEE1B0 => {
    //   block [0x82EEE1B0..0x82EEE1C0)
	// 82EEE1B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEE1B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE1B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE1BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE1C0 size=120
    let mut pc: u32 = 0x82EEE1C0;
    'dispatch: loop {
        match pc {
            0x82EEE1C0 => {
    //   block [0x82EEE1C0..0x82EEE238)
	// 82EEE1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE1C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE1C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EEE1CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEE1D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE1D4: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEE1D8: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EEE1DC: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE1E0: 48000091  bl 0x82eee270
	ctx.lr = 0x82EEE1E4;
	sub_82EEE270(ctx, base);
	// 82EEE1E4: 83E1009C  lwz r31, 0x9c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEE1E8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82EEE1EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEE1F0: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE1F4: 388B0024  addi r4, r11, 0x24
	ctx.r[4].s64 = ctx.r[11].s64 + 36;
	// 82EEE1F8: 48005A11  bl 0x82ef3c08
	ctx.lr = 0x82EEE1FC;
	sub_82EF3C08(ctx, base);
	// 82EEE1FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EEE200: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EEE204: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EEE208: 480007E9  bl 0x82eee9f0
	ctx.lr = 0x82EEE20C;
	sub_82EEE9F0(ctx, base);
	// 82EEE20C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82EEE210: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEE214: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE218: 388B0024  addi r4, r11, 0x24
	ctx.r[4].s64 = ctx.r[11].s64 + 36;
	// 82EEE21C: 480006ED  bl 0x82eee908
	ctx.lr = 0x82EEE220;
	sub_82EEE908(ctx, base);
	// 82EEE220: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEE224: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE228: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE22C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EEE230: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEE234: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE238 size=52
    let mut pc: u32 = 0x82EEE238;
    'dispatch: loop {
        match pc {
            0x82EEE238 => {
    //   block [0x82EEE238..0x82EEE26C)
	// 82EEE238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE23C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE240: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE244: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEE248: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE24C: 48000025  bl 0x82eee270
	ctx.lr = 0x82EEE250;
	sub_82EEE270(ctx, base);
	// 82EEE250: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE254: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEE258: 48000739  bl 0x82eee990
	ctx.lr = 0x82EEE25C;
	sub_82EEE990(ctx, base);
	// 82EEE25C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEE260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE270 size=128
    let mut pc: u32 = 0x82EEE270;
    'dispatch: loop {
        match pc {
            0x82EEE270 => {
    //   block [0x82EEE270..0x82EEE2BC)
	// 82EEE270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE278: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE27C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEE280: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE284: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEE28C: 419A0048  beq cr6, 0x82eee2d4
	if ctx.cr[6].eq {
	pc = 0x82EEE2D4; continue 'dispatch;
	}
	// 82EEE290: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE294: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEE298: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EEE29C: 409A0020  bne cr6, 0x82eee2bc
	if !ctx.cr[6].eq {
	pc = 0x82EEE2BC; continue 'dispatch;
	}
	// 82EEE2A0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE2A4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE2A8: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 82EEE2AC: 409A0010  bne cr6, 0x82eee2bc
	if !ctx.cr[6].eq {
	pc = 0x82EEE2BC; continue 'dispatch;
	}
	// 82EEE2B0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE2B4: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EEE2B8: 4BDD5199  bl 0x82cc3450
	ctx.lr = 0x82EEE2BC;
	sub_82CC3450(ctx, base);
	pc = 0x82EEE2BC; continue 'dispatch;
            }
            0x82EEE2BC => {
    //   block [0x82EEE2BC..0x82EEE2D4)
	// 82EEE2BC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE2C0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE2C4: 4BDD44ED  bl 0x82cc27b0
	ctx.lr = 0x82EEE2C8;
	sub_82CC27B0(ctx, base);
	// 82EEE2C8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE2CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEE2D0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x82EEE2D4; continue 'dispatch;
            }
            0x82EEE2D4 => {
    //   block [0x82EEE2D4..0x82EEE2F0)
	// 82EEE2D4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE2D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEE2DC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEE2E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEE2E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE2E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE2EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE2F0 size=324
    let mut pc: u32 = 0x82EEE2F0;
    'dispatch: loop {
        match pc {
            0x82EEE2F0 => {
    //   block [0x82EEE2F0..0x82EEE35C)
	// 82EEE2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE2F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE2F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEE2FC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE300: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EEE304: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE308: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE30C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEE310: 409A004C  bne cr6, 0x82eee35c
	if !ctx.cr[6].eq {
	pc = 0x82EEE35C; continue 'dispatch;
	}
	// 82EEE314: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE318: 896B8F74  lbz r11, -0x708c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28812 as u32) ) } as u64;
	// 82EEE31C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEE320: 4082003C  bne 0x82eee35c
	if !ctx.cr[0].eq {
	pc = 0x82EEE35C; continue 'dispatch;
	}
	// 82EEE324: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE328: 3BEB8F74  addi r31, r11, -0x708c
	ctx.r[31].s64 = ctx.r[11].s64 + -28812;
	// 82EEE32C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE330: 38CBC5BC  addi r6, r11, -0x3a44
	ctx.r[6].s64 = ctx.r[11].s64 + -14916;
	// 82EEE334: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 82EEE338: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE33C: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 82EEE340: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEE344: 4BFFCE25  bl 0x82eeb168
	ctx.lr = 0x82EEE348;
	sub_82EEB168(ctx, base);
	// 82EEE348: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEE34C: 48203A6D  bl 0x830f1db8
	ctx.lr = 0x82EEE350;
	sub_830F1DB8(ctx, base);
	// 82EEE350: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE354: 40820008  bne 0x82eee35c
	if !ctx.cr[0].eq {
	pc = 0x82EEE35C; continue 'dispatch;
	}
	// 82EEE358: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEE35C; continue 'dispatch;
            }
            0x82EEE35C => {
    //   block [0x82EEE35C..0x82EEE3D0)
	// 82EEE35C: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 82EEE360: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEE364: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE368: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EEE36C: 4BDBB645  bl 0x82ca99b0
	ctx.lr = 0x82EEE370;
	sub_82CA99B0(ctx, base);
	// 82EEE370: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEE374: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEE378: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE37C: 386B0034  addi r3, r11, 0x34
	ctx.r[3].s64 = ctx.r[11].s64 + 52;
	// 82EEE380: 4BDBB631  bl 0x82ca99b0
	ctx.lr = 0x82EEE384;
	sub_82CA99B0(ctx, base);
	// 82EEE384: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE388: 38EB0008  addi r7, r11, 8
	ctx.r[7].s64 = ctx.r[11].s64 + 8;
	// 82EEE38C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EEE390: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEE394: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE398: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EEE39C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE3A0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE3A4: 4BDD63CD  bl 0x82cc4770
	ctx.lr = 0x82EEE3A8;
	sub_82CC4770(ctx, base);
	// 82EEE3A8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EEE3AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEE3B0: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 82EEE3B4: 409A001C  bne cr6, 0x82eee3d0
	if !ctx.cr[6].eq {
	pc = 0x82EEE3D0; continue 'dispatch;
	}
	// 82EEE3B8: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE3BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EEE3C0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEE3C4: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE3C8: 48000071  bl 0x82eee438
	ctx.lr = 0x82EEE3CC;
	sub_82EEE438(ctx, base);
	// 82EEE3CC: 48000054  b 0x82eee420
	pc = 0x82EEE420; continue 'dispatch;
            }
            0x82EEE3D0 => {
    //   block [0x82EEE3D0..0x82EEE418)
	// 82EEE3D0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE3D4: 896B8F73  lbz r11, -0x708d(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28813 as u32) ) } as u64;
	// 82EEE3D8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEE3DC: 4082003C  bne 0x82eee418
	if !ctx.cr[0].eq {
	pc = 0x82EEE418; continue 'dispatch;
	}
	// 82EEE3E0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE3E4: 3BEB8F73  addi r31, r11, -0x708d
	ctx.r[31].s64 = ctx.r[11].s64 + -28813;
	// 82EEE3E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EEE3EC: 38CB1700  addi r6, r11, 0x1700
	ctx.r[6].s64 = ctx.r[11].s64 + 5888;
	// 82EEE3F0: 38A0008C  li r5, 0x8c
	ctx.r[5].s64 = 140;
	// 82EEE3F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE3F8: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 82EEE3FC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEE400: 4BFFCD69  bl 0x82eeb168
	ctx.lr = 0x82EEE404;
	sub_82EEB168(ctx, base);
	// 82EEE404: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEE408: 482039B1  bl 0x830f1db8
	ctx.lr = 0x82EEE40C;
	sub_830F1DB8(ctx, base);
	// 82EEE40C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE410: 40820008  bne 0x82eee418
	if !ctx.cr[0].eq {
	pc = 0x82EEE418; continue 'dispatch;
	}
	// 82EEE414: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEE418; continue 'dispatch;
            }
            0x82EEE418 => {
    //   block [0x82EEE418..0x82EEE420)
	// 82EEE418: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEE41C: 4BFFFE55  bl 0x82eee270
	ctx.lr = 0x82EEE420;
	sub_82EEE270(ctx, base);
	pc = 0x82EEE420; continue 'dispatch;
            }
            0x82EEE420 => {
    //   block [0x82EEE420..0x82EEE434)
	// 82EEE420: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEE424: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE428: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE42C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEE430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE438 size=508
    let mut pc: u32 = 0x82EEE438;
    'dispatch: loop {
        match pc {
            0x82EEE438 => {
    //   block [0x82EEE438..0x82EEE4A4)
	// 82EEE438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE43C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE440: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEE444: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE448: 906100B4  stw r3, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 82EEE44C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE450: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEE454: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EEE458: 419A004C  beq cr6, 0x82eee4a4
	if ctx.cr[6].eq {
	pc = 0x82EEE4A4; continue 'dispatch;
	}
	// 82EEE45C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE460: 896B8F76  lbz r11, -0x708a(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28810 as u32) ) } as u64;
	// 82EEE464: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEE468: 4082003C  bne 0x82eee4a4
	if !ctx.cr[0].eq {
	pc = 0x82EEE4A4; continue 'dispatch;
	}
	// 82EEE46C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE470: 3BEB8F76  addi r31, r11, -0x708a
	ctx.r[31].s64 = ctx.r[11].s64 + -28810;
	// 82EEE474: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE478: 38CBC5DC  addi r6, r11, -0x3a24
	ctx.r[6].s64 = ctx.r[11].s64 + -14884;
	// 82EEE47C: 38A00093  li r5, 0x93
	ctx.r[5].s64 = 147;
	// 82EEE480: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE484: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 82EEE488: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEE48C: 4BFFCCDD  bl 0x82eeb168
	ctx.lr = 0x82EEE490;
	sub_82EEB168(ctx, base);
	// 82EEE490: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEE494: 48203925  bl 0x830f1db8
	ctx.lr = 0x82EEE498;
	sub_830F1DB8(ctx, base);
	// 82EEE498: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE49C: 40820008  bne 0x82eee4a4
	if !ctx.cr[0].eq {
	pc = 0x82EEE4A4; continue 'dispatch;
	}
	// 82EEE4A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEE4A4; continue 'dispatch;
            }
            0x82EEE4A4 => {
    //   block [0x82EEE4A4..0x82EEE4EC)
	// 82EEE4A4: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE4A8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE4AC: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 82EEE4B0: 419A0170  beq cr6, 0x82eee620
	if ctx.cr[6].eq {
	pc = 0x82EEE620; continue 'dispatch;
	}
	// 82EEE4B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEE4B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEE4BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEE4C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EEE4C4: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE4C8: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EEE4CC: 4BDD48B5  bl 0x82cc2d80
	ctx.lr = 0x82EEE4D0;
	sub_82CC2D80(ctx, base);
	// 82EEE4D0: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEE4D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEE4D8: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 82EEE4DC: 419A0010  beq cr6, 0x82eee4ec
	if ctx.cr[6].eq {
	pc = 0x82EEE4EC; continue 'dispatch;
	}
	// 82EEE4E0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEE4E4: 2B0B03E4  cmplwi cr6, r11, 0x3e4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 996 as u32, &mut ctx.xer);
	// 82EEE4E8: 409A0008  bne cr6, 0x82eee4f0
	if !ctx.cr[6].eq {
	pc = 0x82EEE4F0; continue 'dispatch;
	}
	pc = 0x82EEE4EC; continue 'dispatch;
            }
            0x82EEE4EC => {
    //   block [0x82EEE4EC..0x82EEE4F0)
	// 82EEE4EC: 48000134  b 0x82eee620
	pc = 0x82EEE620; continue 'dispatch;
            }
            0x82EEE4F0 => {
    //   block [0x82EEE4F0..0x82EEE558)
	// 82EEE4F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEE4F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEE4F8: 409A0114  bne cr6, 0x82eee60c
	if !ctx.cr[6].eq {
	pc = 0x82EEE60C; continue 'dispatch;
	}
	// 82EEE4FC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEE500: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEE504: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEE508: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82EEE50C: 4099004C  ble cr6, 0x82eee558
	if !ctx.cr[6].gt {
	pc = 0x82EEE558; continue 'dispatch;
	}
	// 82EEE510: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE514: 896B8F75  lbz r11, -0x708b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28811 as u32) ) } as u64;
	// 82EEE518: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEE51C: 4082003C  bne 0x82eee558
	if !ctx.cr[0].eq {
	pc = 0x82EEE558; continue 'dispatch;
	}
	// 82EEE520: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEE524: 3BEB8F75  addi r31, r11, -0x708b
	ctx.r[31].s64 = ctx.r[11].s64 + -28811;
	// 82EEE528: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE52C: 38CBC5D4  addi r6, r11, -0x3a2c
	ctx.r[6].s64 = ctx.r[11].s64 + -14892;
	// 82EEE530: 38A0009F  li r5, 0x9f
	ctx.r[5].s64 = 159;
	// 82EEE534: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEE538: 388BC56C  addi r4, r11, -0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + -14996;
	// 82EEE53C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EEE540: 4BFFCC29  bl 0x82eeb168
	ctx.lr = 0x82EEE544;
	sub_82EEB168(ctx, base);
	// 82EEE544: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEE548: 48203871  bl 0x830f1db8
	ctx.lr = 0x82EEE54C;
	sub_830F1DB8(ctx, base);
	// 82EEE54C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE550: 40820008  bne 0x82eee558
	if !ctx.cr[0].eq {
	pc = 0x82EEE558; continue 'dispatch;
	}
	// 82EEE554: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEE558; continue 'dispatch;
            }
            0x82EEE558 => {
    //   block [0x82EEE558..0x82EEE5A0)
	// 82EEE558: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEE55C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEE560: 409900AC  ble cr6, 0x82eee60c
	if !ctx.cr[6].gt {
	pc = 0x82EEE60C; continue 'dispatch;
	}
	// 82EEE564: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE568: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEE56C: 48000305  bl 0x82eee870
	ctx.lr = 0x82EEE570;
	sub_82EEE870(ctx, base);
	// 82EEE570: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82EEE574: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EEE578: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEE57C: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEE580: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE584: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEE588: 48000281  bl 0x82eee808
	ctx.lr = 0x82EEE58C;
	sub_82EEE808(ctx, base);
	// 82EEE58C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEE590: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EEE594: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EEE598: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EEE59C: 4800001C  b 0x82eee5b8
	pc = 0x82EEE5B8; continue 'dispatch;
            }
            0x82EEE5A0 => {
    //   block [0x82EEE5A0..0x82EEE5B8)
	// 82EEE5A0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEE5A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EEE5A8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EEE5AC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EEE5B0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EEE5B4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEE5B8; continue 'dispatch;
            }
            0x82EEE5B8 => {
    //   block [0x82EEE5B8..0x82EEE600)
	// 82EEE5B8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEE5BC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEE5C0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EEE5C4: 4098003C  bge cr6, 0x82eee600
	if !ctx.cr[6].lt {
	pc = 0x82EEE600; continue 'dispatch;
	}
	// 82EEE5C8: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EEE5CC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE5D0: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EEE5D4: 480002E5  bl 0x82eee8b8
	ctx.lr = 0x82EEE5D8;
	sub_82EEE8B8(ctx, base);
	// 82EEE5D8: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEE5DC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEE5E0: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 312 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EEE5E4: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE5E8: 394A0034  addi r10, r10, 0x34
	ctx.r[10].s64 = ctx.r[10].s64 + 52;
	// 82EEE5EC: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEE5F0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEE5F4: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEE5F8: 4BDBAE89  bl 0x82ca9480
	ctx.lr = 0x82EEE5FC;
	sub_82CA9480(ctx, base);
	// 82EEE5FC: 4BFFFFA4  b 0x82eee5a0
	pc = 0x82EEE5A0; continue 'dispatch;
            }
            0x82EEE600 => {
    //   block [0x82EEE600..0x82EEE60C)
	// 82EEE600: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE604: 4BFFFCED  bl 0x82eee2f0
	ctx.lr = 0x82EEE608;
	sub_82EEE2F0(ctx, base);
	// 82EEE608: 48000018  b 0x82eee620
	pc = 0x82EEE620; continue 'dispatch;
            }
            0x82EEE60C => {
    //   block [0x82EEE60C..0x82EEE620)
	// 82EEE60C: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE610: 4BFFFC61  bl 0x82eee270
	ctx.lr = 0x82EEE614;
	sub_82EEE270(ctx, base);
	// 82EEE614: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEE618: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEE61C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82EEE620; continue 'dispatch;
            }
            0x82EEE620 => {
    //   block [0x82EEE620..0x82EEE634)
	// 82EEE620: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EEE624: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE628: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE62C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEE630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE638 size=76
    let mut pc: u32 = 0x82EEE638;
    'dispatch: loop {
        match pc {
            0x82EEE638 => {
    //   block [0x82EEE638..0x82EEE684)
	// 82EEE638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE63C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE640: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE644: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEE648: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEE64C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEE650: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEE654: 48116555  bl 0x83004ba8
	ctx.lr = 0x82EEE658;
	sub_83004BA8(ctx, base);
	// 82EEE658: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EEE65C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE660: 480007B9  bl 0x82eeee18
	ctx.lr = 0x82EEE664;
	sub_82EEEE18(ctx, base);
	// 82EEE664: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEE668: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE66C: 4800061D  bl 0x82eeec88
	ctx.lr = 0x82EEE670;
	sub_82EEEC88(ctx, base);
	// 82EEE670: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE674: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEE678: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE67C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE688 size=40
    let mut pc: u32 = 0x82EEE688;
    'dispatch: loop {
        match pc {
            0x82EEE688 => {
    //   block [0x82EEE688..0x82EEE6B0)
	// 82EEE688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE68C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE690: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE694: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEE698: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE69C: 480006E5  bl 0x82eeed80
	ctx.lr = 0x82EEE6A0;
	sub_82EEED80(ctx, base);
	// 82EEE6A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEE6A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE6A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE6AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE6B0 size=344
    let mut pc: u32 = 0x82EEE6B0;
    'dispatch: loop {
        match pc {
            0x82EEE6B0 => {
    //   block [0x82EEE6B0..0x82EEE6E0)
	// 82EEE6B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE6B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE6B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE6BC: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEE6C0: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EEE6C4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE6C8: 48000509  bl 0x82eeebd0
	ctx.lr = 0x82EEE6CC;
	sub_82EEEBD0(ctx, base);
	// 82EEE6CC: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEE6D0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EEE6D4: 4098000C  bge cr6, 0x82eee6e0
	if !ctx.cr[6].lt {
	pc = 0x82EEE6E0; continue 'dispatch;
	}
	// 82EEE6D8: 4BFFF069  bl 0x82eed740
	ctx.lr = 0x82EEE6DC;
	sub_82EED740(ctx, base);
	// 82EEE6DC: 4800011C  b 0x82eee7f8
	pc = 0x82EEE7F8; continue 'dispatch;
            }
            0x82EEE6E0 => {
    //   block [0x82EEE6E0..0x82EEE75C)
	// 82EEE6E0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE6E4: 4800035D  bl 0x82eeea40
	ctx.lr = 0x82EEE6E8;
	sub_82EEEA40(ctx, base);
	// 82EEE6E8: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEE6EC: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EEE6F0: 40980108  bge cr6, 0x82eee7f8
	if !ctx.cr[6].lt {
	pc = 0x82EEE7F8; continue 'dispatch;
	}
	// 82EEE6F4: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEE6F8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE6FC: 48000755  bl 0x82eeee50
	ctx.lr = 0x82EEE700;
	sub_82EEEE50(ctx, base);
	// 82EEE700: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EEE704: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEE708: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EEE70C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEE710: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE714: 48000375  bl 0x82eeea88
	ctx.lr = 0x82EEE718;
	sub_82EEEA88(ctx, base);
	// 82EEE718: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEE71C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EEE720: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE724: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EEE728: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEE72C: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE730: 480054D9  bl 0x82ef3c08
	ctx.lr = 0x82EEE734;
	sub_82EF3C08(ctx, base);
	// 82EEE734: E8830000  ld r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEE738: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE73C: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82EEE740: 80C10068  lwz r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EEE744: 48000C4D  bl 0x82eef390
	ctx.lr = 0x82EEE748;
	sub_82EEF390(ctx, base);
	// 82EEE748: 48000014  b 0x82eee75c
	pc = 0x82EEE75C; continue 'dispatch;
	// 82EEE74C: 80A1009C  lwz r5, 0x9c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEE750: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEE754: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE758: 48116619  bl 0x83004d70
	ctx.lr = 0x82EEE75C;
	sub_83004D70(ctx, base);
            }
            0x82EEE75C => {
    //   block [0x82EEE75C..0x82EEE7BC)
	// 82EEE75C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE760: 48000111  bl 0x82eee870
	ctx.lr = 0x82EEE764;
	sub_82EEE870(ctx, base);
	// 82EEE764: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEE768: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE76C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEE774: 419A0048  beq cr6, 0x82eee7bc
	if ctx.cr[6].eq {
	pc = 0x82EEE7BC; continue 'dispatch;
	}
	// 82EEE778: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE77C: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE780: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE784: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE788: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE78C: 480005BD  bl 0x82eeed48
	ctx.lr = 0x82EEE790;
	sub_82EEED48(ctx, base);
	// 82EEE790: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE794: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE798: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEE79C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE7A0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEE7A4: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEE7A8: 7CAB53D6  divw r5, r11, r10
	ctx.r[5].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEE7AC: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE7B0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE7B4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE7B8: 481165B9  bl 0x83004d70
	ctx.lr = 0x82EEE7BC;
	sub_83004D70(ctx, base);
	pc = 0x82EEE7BC; continue 'dispatch;
            }
            0x82EEE7BC => {
    //   block [0x82EEE7BC..0x82EEE7F8)
	// 82EEE7BC: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEE7C0: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 312 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EEE7C4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEE7C8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEE7CC: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE7D0: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EEE7D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEE7D8: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 312 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EEE7DC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEE7E0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEE7E4: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE7E8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EEE7EC: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE7F0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEE7F4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x82EEE7F8; continue 'dispatch;
            }
            0x82EEE7F8 => {
    //   block [0x82EEE7F8..0x82EEE808)
	// 82EEE7F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEE7FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE808 size=104
    let mut pc: u32 = 0x82EEE808;
    'dispatch: loop {
        match pc {
            0x82EEE808 => {
    //   block [0x82EEE808..0x82EEE870)
	// 82EEE808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE80C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE810: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE814: 906102B4  stw r3, 0x2b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(692 as u32), ctx.r[3].u32 ) };
	// 82EEE818: 908102BC  stw r4, 0x2bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(700 as u32), ctx.r[4].u32 ) };
	// 82EEE81C: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEE820: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEE824: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 82EEE828: 4BDBB189  bl 0x82ca99b0
	ctx.lr = 0x82EEE82C;
	sub_82CA99B0(ctx, base);
	// 82EEE82C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEE830: 38810190  addi r4, r1, 0x190
	ctx.r[4].s64 = ctx.r[1].s64 + 400;
	// 82EEE834: 38A00108  li r5, 0x108
	ctx.r[5].s64 = 264;
	// 82EEE838: 4BDBAC49  bl 0x82ca9480
	ctx.lr = 0x82EEE83C;
	sub_82CA9480(ctx, base);
	// 82EEE83C: E8A10160  ld r5, 0x160(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) };
	// 82EEE840: E8C10168  ld r6, 0x168(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(360 as u32) ) };
	// 82EEE844: E8E10170  ld r7, 0x170(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 82EEE848: E9010178  ld r8, 0x178(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) };
	// 82EEE84C: E9210180  ld r9, 0x180(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(384 as u32) ) };
	// 82EEE850: E9410188  ld r10, 0x188(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) };
	// 82EEE854: 808102BC  lwz r4, 0x2bc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(700 as u32) ) } as u64;
	// 82EEE858: 806102B4  lwz r3, 0x2b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(692 as u32) ) } as u64;
	// 82EEE85C: 4800026D  bl 0x82eeeac8
	ctx.lr = 0x82EEE860;
	sub_82EEEAC8(ctx, base);
	// 82EEE860: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 82EEE864: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE868: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE86C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEE870 size=72
    let mut pc: u32 = 0x82EEE870;
    'dispatch: loop {
        match pc {
            0x82EEE870 => {
    //   block [0x82EEE870..0x82EEE890)
	// 82EEE870: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEE874: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEE878: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE87C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEE880: 409A0010  bne cr6, 0x82eee890
	if !ctx.cr[6].eq {
	pc = 0x82EEE890; continue 'dispatch;
	}
	// 82EEE884: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEE888: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEE88C: 48000024  b 0x82eee8b0
	pc = 0x82EEE8B0; continue 'dispatch;
            }
            0x82EEE890 => {
    //   block [0x82EEE890..0x82EEE8B0)
	// 82EEE890: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEE894: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEE898: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE89C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE8A0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEE8A4: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEE8A8: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEE8AC: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEE8B0; continue 'dispatch;
            }
            0x82EEE8B0 => {
    //   block [0x82EEE8B0..0x82EEE8B8)
	// 82EEE8B0: 8061FFF0  lwz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEE8B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE8B8 size=80
    let mut pc: u32 = 0x82EEE8B8;
    'dispatch: loop {
        match pc {
            0x82EEE8B8 => {
    //   block [0x82EEE8B8..0x82EEE8E4)
	// 82EEE8B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE8BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE8C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE8C4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEE8C8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEE8CC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE8D0: 4BFFFFA1  bl 0x82eee870
	ctx.lr = 0x82EEE8D4;
	sub_82EEE870(ctx, base);
	// 82EEE8D4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE8D8: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EEE8DC: 41980008  blt cr6, 0x82eee8e4
	if ctx.cr[6].lt {
	pc = 0x82EEE8E4; continue 'dispatch;
	}
	// 82EEE8E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEE8E4; continue 'dispatch;
            }
            0x82EEE8E4 => {
    //   block [0x82EEE8E4..0x82EEE908)
	// 82EEE8E4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE8E8: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE8EC: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 312 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EEE8F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE8F4: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEE8F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEE8FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE900: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE904: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE908 size=136
    let mut pc: u32 = 0x82EEE908;
    'dispatch: loop {
        match pc {
            0x82EEE908 => {
    //   block [0x82EEE908..0x82EEE990)
	// 82EEE908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE90C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE910: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE914: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEE918: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEE91C: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82EEE920: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEE924: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE928: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE92C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEE930: 386B0138  addi r3, r11, 0x138
	ctx.r[3].s64 = ctx.r[11].s64 + 312;
	// 82EEE934: 48000A9D  bl 0x82eef3d0
	ctx.lr = 0x82EEE938;
	sub_82EEF3D0(ctx, base);
	// 82EEE938: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE93C: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE940: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE944: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE948: 388BFEC8  addi r4, r11, -0x138
	ctx.r[4].s64 = ctx.r[11].s64 + -312;
	// 82EEE94C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE950: 480003F9  bl 0x82eeed48
	ctx.lr = 0x82EEE954;
	sub_82EEED48(ctx, base);
	// 82EEE954: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE958: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEE95C: 396BFEC8  addi r11, r11, -0x138
	ctx.r[11].s64 = ctx.r[11].s64 + -312;
	// 82EEE960: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEE964: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EEE968: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE96C: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EEE970: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEE974: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEE978: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEE97C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEE980: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEE984: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE988: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE98C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE990 size=92
    let mut pc: u32 = 0x82EEE990;
    'dispatch: loop {
        match pc {
            0x82EEE990 => {
    //   block [0x82EEE990..0x82EEE9EC)
	// 82EEE990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE998: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE99C: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEE9A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEE9A4: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE9A8: 480000E1  bl 0x82eeea88
	ctx.lr = 0x82EEE9AC;
	sub_82EEEA88(ctx, base);
	// 82EEE9AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEE9B0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EEE9B4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEE9B8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EEE9BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEE9C0: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE9C4: 48005245  bl 0x82ef3c08
	ctx.lr = 0x82EEE9C8;
	sub_82EF3C08(ctx, base);
	// 82EEE9C8: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEE9CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEE9D0: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEE9D4: E8C10068  ld r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82EEE9D8: 48000221  bl 0x82eeebf8
	ctx.lr = 0x82EEE9DC;
	sub_82EEEBF8(ctx, base);
	// 82EEE9DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEE9E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEE9E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEE9E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEE9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEE9F0 size=80
    let mut pc: u32 = 0x82EEE9F0;
    'dispatch: loop {
        match pc {
            0x82EEE9F0 => {
    //   block [0x82EEE9F0..0x82EEEA40)
	// 82EEE9F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEE9F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEE9F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEE9FC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEA00: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEEA04: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEEA08: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEA0C: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82EEEA10: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82EEEA14: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEEA18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEEA1C: 48000465  bl 0x82eeee80
	ctx.lr = 0x82EEEA20;
	sub_82EEEE80(ctx, base);
	// 82EEEA20: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEEA24: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEA28: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82EEEA2C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEA30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEA34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEA38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEA3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEEA40 size=72
    let mut pc: u32 = 0x82EEEA40;
    'dispatch: loop {
        match pc {
            0x82EEEA40 => {
    //   block [0x82EEEA40..0x82EEEA60)
	// 82EEEA40: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEEA44: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEEA48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEEA4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEEA50: 409A0010  bne cr6, 0x82eeea60
	if !ctx.cr[6].eq {
	pc = 0x82EEEA60; continue 'dispatch;
	}
	// 82EEEA54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEEA58: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEEA5C: 48000024  b 0x82eeea80
	pc = 0x82EEEA80; continue 'dispatch;
            }
            0x82EEEA60 => {
    //   block [0x82EEEA60..0x82EEEA80)
	// 82EEEA60: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEEA64: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEEA68: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEEA6C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEEA70: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEEA74: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEEA78: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEEA7C: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEEA80; continue 'dispatch;
            }
            0x82EEEA80 => {
    //   block [0x82EEEA80..0x82EEEA88)
	// 82EEEA80: 8061FFF0  lwz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEEA84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEA88 size=60
    let mut pc: u32 = 0x82EEEA88;
    'dispatch: loop {
        match pc {
            0x82EEEA88 => {
    //   block [0x82EEEA88..0x82EEEAC4)
	// 82EEEA88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEA8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEA90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEA94: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEA98: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEEA9C: 80A1007C  lwz r5, 0x7c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEAA0: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEAA4: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEEAA8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEAAC: 480058AD  bl 0x82ef4358
	ctx.lr = 0x82EEEAB0;
	sub_82EF4358(ctx, base);
	// 82EEEAB0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEAB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEAB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEAC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEAC8 size=264
    let mut pc: u32 = 0x82EEEAC8;
    'dispatch: loop {
        match pc {
            0x82EEEAC8 => {
    //   block [0x82EEEAC8..0x82EEEB50)
	// 82EEEAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEAD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EEEAD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEEAD8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEADC: 906100B4  stw r3, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 82EEEAE0: 908100BC  stw r4, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[4].u32 ) };
	// 82EEEAE4: F8A100C0  std r5, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[5].u64 ) };
	// 82EEEAE8: F8C100C8  std r6, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[6].u64 ) };
	// 82EEEAEC: F8E100D0  std r7, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[7].u64 ) };
	// 82EEEAF0: F90100D8  std r8, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[8].u64 ) };
	// 82EEEAF4: F92100E0  std r9, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[9].u64 ) };
	// 82EEEAF8: F94100E8  std r10, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[10].u64 ) };
	// 82EEEAFC: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEB00: 4BFFFD71  bl 0x82eee870
	ctx.lr = 0x82EEEB04;
	sub_82EEE870(ctx, base);
	// 82EEEB04: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEEB08: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EEEB0C: 40980044  bge cr6, 0x82eeeb50
	if !ctx.cr[6].lt {
	pc = 0x82EEEB50; continue 'dispatch;
	}
	// 82EEEB10: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 82EEEB14: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EEEB18: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEB1C: 4BFFFD55  bl 0x82eee870
	ctx.lr = 0x82EEEB20;
	sub_82EEE870(ctx, base);
	// 82EEEB20: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEEB24: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82EEEB28: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EEEB2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEEB30: 808100B4  lwz r4, 0xb4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEB34: 4BFFFF55  bl 0x82eeea88
	ctx.lr = 0x82EEEB38;
	sub_82EEEA88(ctx, base);
	// 82EEEB38: E8830000  ld r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEEB3C: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEB40: 80A1007C  lwz r5, 0x7c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEB44: 80C10078  lwz r6, 0x78(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EEEB48: 48000371  bl 0x82eeeeb8
	ctx.lr = 0x82EEEB4C;
	sub_82EEEEB8(ctx, base);
	// 82EEEB4C: 4800006C  b 0x82eeebb8
	pc = 0x82EEEBB8; continue 'dispatch;
            }
            0x82EEEB50 => {
    //   block [0x82EEEB50..0x82EEEBB8)
	// 82EEEB50: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEB54: 4BFFFD1D  bl 0x82eee870
	ctx.lr = 0x82EEEB58;
	sub_82EEE870(ctx, base);
	// 82EEEB58: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEEB5C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EEEB60: 40980058  bge cr6, 0x82eeebb8
	if !ctx.cr[6].lt {
	pc = 0x82EEEBB8; continue 'dispatch;
	}
	// 82EEEB64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEEB68: 808100B4  lwz r4, 0xb4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEB6C: 4BFFFF1D  bl 0x82eeea88
	ctx.lr = 0x82EEEB70;
	sub_82EEEA88(ctx, base);
	// 82EEEB70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEEB74: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EEEB78: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEEB7C: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEEB80: 83E100BC  lwz r31, 0xbc(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEEB84: 3BC10068  addi r30, r1, 0x68
	ctx.r[30].s64 = ctx.r[1].s64 + 104;
	// 82EEEB88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEEB8C: 808100B4  lwz r4, 0xb4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEB90: 48005079  bl 0x82ef3c08
	ctx.lr = 0x82EEEB94;
	sub_82EF3C08(ctx, base);
	// 82EEEB94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EEEB98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EEEB9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EEEBA0: 4BFFFE51  bl 0x82eee9f0
	ctx.lr = 0x82EEEBA4;
	sub_82EEE9F0(ctx, base);
	// 82EEEBA4: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEEBA8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EEEBAC: 808100B4  lwz r4, 0xb4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEEBB0: E8C10080  ld r6, 0x80(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82EEEBB4: 48000045  bl 0x82eeebf8
	ctx.lr = 0x82EEEBB8;
	sub_82EEEBF8(ctx, base);
	pc = 0x82EEEBB8; continue 'dispatch;
            }
            0x82EEEBB8 => {
    //   block [0x82EEEBB8..0x82EEEBD0)
	// 82EEEBB8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EEEBBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEBC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEBC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EEEBC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEEBCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEBD0 size=40
    let mut pc: u32 = 0x82EEEBD0;
    'dispatch: loop {
        match pc {
            0x82EEEBD0 => {
    //   block [0x82EEEBD0..0x82EEEBF8)
	// 82EEEBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEBD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEBD8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEBDC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEBE0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEBE4: 4800068D  bl 0x82eef270
	ctx.lr = 0x82EEEBE8;
	sub_82EEF270(ctx, base);
	// 82EEEBE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEBEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEBF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEBF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEBF8 size=144
    let mut pc: u32 = 0x82EEEBF8;
    'dispatch: loop {
        match pc {
            0x82EEEBF8 => {
    //   block [0x82EEEBF8..0x82EEEC60)
	// 82EEEBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEBFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEC00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEC04: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEC08: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEEC0C: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82EEEC10: F8C10088  std r6, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u64 ) };
	// 82EEEC14: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82EEEC18: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EEEC1C: 4811581D  bl 0x83004438
	ctx.lr = 0x82EEEC20;
	sub_83004438(ctx, base);
	// 82EEEC20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEEC24: 4182003C  beq 0x82eeec60
	if ctx.cr[0].eq {
	pc = 0x82EEEC60; continue 'dispatch;
	}
	// 82EEEC28: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEEC2C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEC30: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEEC34: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEEC38: 48000799  bl 0x82eef3d0
	ctx.lr = 0x82EEEC3C;
	sub_82EEF3D0(ctx, base);
	// 82EEEC3C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EEEC40: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEC44: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEEC48: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEEC4C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEC50: 480000F9  bl 0x82eeed48
	ctx.lr = 0x82EEEC54;
	sub_82EEED48(ctx, base);
	// 82EEEC54: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEC58: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEEC5C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82EEEC60; continue 'dispatch;
            }
            0x82EEEC60 => {
    //   block [0x82EEEC60..0x82EEEC88)
	// 82EEEC60: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEC64: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EEEC68: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEEC6C: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEEC70: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEEC74: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEC78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEC7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEC80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEC84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEC88 size=192
    let mut pc: u32 = 0x82EEEC88;
    'dispatch: loop {
        match pc {
            0x82EEEC88 => {
    //   block [0x82EEEC88..0x82EEECD8)
	// 82EEEC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEC8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEC90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEC94: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEC98: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEEC9C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEECA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEECA4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEECA8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEECAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEECB0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EEECB4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEECB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEECBC: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EEECC0: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEECC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEECC8: 409A0010  bne cr6, 0x82eeecd8
	if !ctx.cr[6].eq {
	pc = 0x82EEECD8; continue 'dispatch;
	}
	// 82EEECCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEECD0: 48000068  b 0x82eeed38
	pc = 0x82EEED38; continue 'dispatch;
	// 82EEECD4: 48000060  b 0x82eeed34
	pc = 0x82EEED34; continue 'dispatch;
            }
            0x82EEECD8 => {
    //   block [0x82EEECD8..0x82EEECF4)
	// 82EEECD8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEECDC: 4BFFFEF5  bl 0x82eeebd0
	ctx.lr = 0x82EEECE0;
	sub_82EEEBD0(ctx, base);
	// 82EEECE0: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEECE4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EEECE8: 4098000C  bge cr6, 0x82eeecf4
	if !ctx.cr[6].lt {
	pc = 0x82EEECF4; continue 'dispatch;
	}
	// 82EEECEC: 4BFFEA55  bl 0x82eed740
	ctx.lr = 0x82EEECF0;
	sub_82EED740(ctx, base);
	// 82EEECF0: 48000044  b 0x82eeed34
	pc = 0x82EEED34; continue 'dispatch;
            }
            0x82EEECF4 => {
    //   block [0x82EEECF4..0x82EEED34)
	// 82EEECF4: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEECF8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEECFC: 48000155  bl 0x82eeee50
	ctx.lr = 0x82EEED00;
	sub_82EEEE50(ctx, base);
	// 82EEED00: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEED04: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82EEED08: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEED0C: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEED10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEED14: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EEED18: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEED1C: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEED20: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 312 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EEED24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEED28: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEED2C: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEED30: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEED34; continue 'dispatch;
            }
            0x82EEED34 => {
    //   block [0x82EEED34..0x82EEED38)
	// 82EEED34: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EEED38; continue 'dispatch;
            }
            0x82EEED38 => {
    //   block [0x82EEED38..0x82EEED48)
	// 82EEED38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEED3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEED40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEED44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEED48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEED48 size=56
    let mut pc: u32 = 0x82EEED48;
    'dispatch: loop {
        match pc {
            0x82EEED48 => {
    //   block [0x82EEED48..0x82EEED80)
	// 82EEED48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEED4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEED50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEED54: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEED58: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEED5C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEED60: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEED64: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEED68: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEED6C: 480006FD  bl 0x82eef468
	ctx.lr = 0x82EEED70;
	sub_82EEF468(ctx, base);
	// 82EEED70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEED74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEED78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEED7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEED80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEED80 size=152
    let mut pc: u32 = 0x82EEED80;
    'dispatch: loop {
        match pc {
            0x82EEED80 => {
    //   block [0x82EEED80..0x82EEEDE4)
	// 82EEED80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEED84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEED88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEED8C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEED90: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEED94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEED98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEED9C: 419A0048  beq cr6, 0x82eeede4
	if ctx.cr[6].eq {
	pc = 0x82EEEDE4; continue 'dispatch;
	}
	// 82EEEDA0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDA4: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEEDA8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDAC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEEDB0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDB4: 4BFFFF95  bl 0x82eeed48
	ctx.lr = 0x82EEEDB8;
	sub_82EEED48(ctx, base);
	// 82EEEDB8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDBC: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDC0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEEDC4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEEDC8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEEDCC: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEEDD0: 7CAB53D6  divw r5, r11, r10
	ctx.r[5].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEEDD4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDD8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEEDDC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDE0: 48115F91  bl 0x83004d70
	ctx.lr = 0x82EEEDE4;
	sub_83004D70(ctx, base);
	pc = 0x82EEEDE4; continue 'dispatch;
            }
            0x82EEEDE4 => {
    //   block [0x82EEEDE4..0x82EEEE18)
	// 82EEEDE4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEEDEC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEEDF0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEDF4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEEDF8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EEEDFC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEE00: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEEE04: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EEEE08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEE0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEE10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEE14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEE18 size=52
    let mut pc: u32 = 0x82EEEE18;
    'dispatch: loop {
        match pc {
            0x82EEEE18 => {
    //   block [0x82EEEE18..0x82EEEE4C)
	// 82EEEE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEE1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEE20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEE24: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEE28: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEEE2C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEE30: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEE34: 4BFFE95D  bl 0x82eed790
	ctx.lr = 0x82EEEE38;
	sub_82EED790(ctx, base);
	// 82EEEE38: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEE3C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEE40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEE44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEE48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEE50 size=48
    let mut pc: u32 = 0x82EEEE50;
    'dispatch: loop {
        match pc {
            0x82EEEE50 => {
    //   block [0x82EEEE50..0x82EEEE80)
	// 82EEEE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEE54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEE58: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEE5C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEE60: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEEE64: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEEE68: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEE6C: 4800064D  bl 0x82eef4b8
	ctx.lr = 0x82EEEE70;
	sub_82EEF4B8(ctx, base);
	// 82EEEE70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEE74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEE78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEE7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEE80 size=52
    let mut pc: u32 = 0x82EEEE80;
    'dispatch: loop {
        match pc {
            0x82EEEE80 => {
    //   block [0x82EEEE80..0x82EEEEB4)
	// 82EEEE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEE84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEE88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEE8C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEEE90: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEEE94: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEEE98: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEE9C: 4800040D  bl 0x82eef2a8
	ctx.lr = 0x82EEEEA0;
	sub_82EEF2A8(ctx, base);
	// 82EEEEA0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEEEA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEEEA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEEEAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEEEB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEEEB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEEEB8 size=948
    let mut pc: u32 = 0x82EEEEB8;
    'dispatch: loop {
        match pc {
            0x82EEEEB8 => {
    //   block [0x82EEEEB8..0x82EEEF04)
	// 82EEEEB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEEEBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEEEC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEEEC4: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEEEC8: 906101C4  stw r3, 0x1c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), ctx.r[3].u32 ) };
	// 82EEEECC: F88101C8  std r4, 0x1c8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), ctx.r[4].u64 ) };
	// 82EEEED0: 90A101D4  stw r5, 0x1d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), ctx.r[5].u32 ) };
	// 82EEEED4: 90C101DC  stw r6, 0x1dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(476 as u32), ctx.r[6].u32 ) };
	// 82EEEED8: 808101DC  lwz r4, 0x1dc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(476 as u32) ) } as u64;
	// 82EEEEDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEEEE0: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEEEE4: 4BDBA59D  bl 0x82ca9480
	ctx.lr = 0x82EEEEE8;
	sub_82CA9480(ctx, base);
	// 82EEEEE8: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEEEC: 4BFFFB55  bl 0x82eeea40
	ctx.lr = 0x82EEEEF0;
	sub_82EEEA40(ctx, base);
	// 82EEEEF0: 90610188  stw r3, 0x188(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[3].u32 ) };
	// 82EEEEF4: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEEEF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEEEFC: 409A0008  bne cr6, 0x82eeef04
	if !ctx.cr[6].eq {
	pc = 0x82EEEF04; continue 'dispatch;
	}
	// 82EEEF00: 48000358  b 0x82eef258
	pc = 0x82EEF258; continue 'dispatch;
            }
            0x82EEEF04 => {
    //   block [0x82EEEF04..0x82EEEF30)
	// 82EEEF04: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEF08: 4BFFFCC9  bl 0x82eeebd0
	ctx.lr = 0x82EEEF0C;
	sub_82EEEBD0(ctx, base);
	// 82EEEF0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEEF10: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEF14: 4BFFF95D  bl 0x82eee870
	ctx.lr = 0x82EEEF18;
	sub_82EEE870(ctx, base);
	// 82EEEF18: 7D63F850  subf r11, r3, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[3].s64;
	// 82EEEF1C: 814101D4  lwz r10, 0x1d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEEF20: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEEF24: 4098000C  bge cr6, 0x82eeef30
	if !ctx.cr[6].lt {
	pc = 0x82EEEF30; continue 'dispatch;
	}
	// 82EEEF28: 4BFFE819  bl 0x82eed740
	ctx.lr = 0x82EEEF2C;
	sub_82EED740(ctx, base);
	// 82EEEF2C: 4800032C  b 0x82eef258
	pc = 0x82EEF258; continue 'dispatch;
            }
            0x82EEEF30 => {
    //   block [0x82EEEF30..0x82EEEF7C)
	// 82EEEF30: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEF34: 4BFFF93D  bl 0x82eee870
	ctx.lr = 0x82EEEF38;
	sub_82EEE870(ctx, base);
	// 82EEEF38: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEEF3C: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82EEEF40: 81410188  lwz r10, 0x188(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEEF44: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EEEF48: 409801B4  bge cr6, 0x82eef0fc
	if !ctx.cr[6].lt {
	pc = 0x82EEF0FC; continue 'dispatch;
	}
	// 82EEEF4C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEF50: 4BFFFC81  bl 0x82eeebd0
	ctx.lr = 0x82EEEF54;
	sub_82EEEBD0(ctx, base);
	// 82EEEF54: 81610188  lwz r11, 0x188(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEEF58: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EEEF5C: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82EEEF60: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82EEEF64: 81410188  lwz r10, 0x188(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEEF68: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEEF6C: 40980010  bge cr6, 0x82eeef7c
	if !ctx.cr[6].lt {
	pc = 0x82EEEF7C; continue 'dispatch;
	}
	// 82EEEF70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEEF74: 91610198  stw r11, 0x198(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EEEF78: 4800001C  b 0x82eeef94
	pc = 0x82EEEF94; continue 'dispatch;
            }
            0x82EEEF7C => {
    //   block [0x82EEEF7C..0x82EEEF94)
	// 82EEEF7C: 81610188  lwz r11, 0x188(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEEF80: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EEEF84: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82EEEF88: 81410188  lwz r10, 0x188(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEEF8C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEEF90: 91610198  stw r11, 0x198(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEEF94; continue 'dispatch;
            }
            0x82EEEF94 => {
    //   block [0x82EEEF94..0x82EEEFCC)
	// 82EEEF94: 81610198  lwz r11, 0x198(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EEEF98: 91610188  stw r11, 0x188(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 82EEEF9C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEFA0: 4BFFF8D1  bl 0x82eee870
	ctx.lr = 0x82EEEFA4;
	sub_82EEE870(ctx, base);
	// 82EEEFA4: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEEFA8: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82EEEFAC: 81410188  lwz r10, 0x188(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEEFB0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EEEFB4: 40980018  bge cr6, 0x82eeefcc
	if !ctx.cr[6].lt {
	pc = 0x82EEEFCC; continue 'dispatch;
	}
	// 82EEEFB8: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEFBC: 4BFFF8B5  bl 0x82eee870
	ctx.lr = 0x82EEEFC0;
	sub_82EEE870(ctx, base);
	// 82EEEFC0: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEEFC4: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82EEEFC8: 91610188  stw r11, 0x188(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEEFCC; continue 'dispatch;
            }
            0x82EEEFCC => {
    //   block [0x82EEEFCC..0x82EEF054)
	// 82EEEFCC: 80810188  lwz r4, 0x188(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEEFD0: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEFD4: 4BFFFE7D  bl 0x82eeee50
	ctx.lr = 0x82EEEFD8;
	sub_82EEEE50(ctx, base);
	// 82EEEFD8: 90610190  stw r3, 0x190(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), ctx.r[3].u32 ) };
	// 82EEEFDC: 81610190  lwz r11, 0x190(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EEEFE0: 9161018C  stw r11, 0x18c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 82EEEFE4: 80C10190  lwz r6, 0x190(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EEEFE8: 80A101CC  lwz r5, 0x1cc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEEFEC: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEFF0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEEFF4: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEEFF8: 48000539  bl 0x82eef530
	ctx.lr = 0x82EEEFFC;
	sub_82EEF530(ctx, base);
	// 82EEEFFC: 9061018C  stw r3, 0x18c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), ctx.r[3].u32 ) };
	// 82EEF000: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EEF004: 80A101D4  lwz r5, 0x1d4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF008: 8081018C  lwz r4, 0x18c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EEF00C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF010: 48000331  bl 0x82eef340
	ctx.lr = 0x82EEF014;
	sub_82EEF340(ctx, base);
	// 82EEF014: 9061018C  stw r3, 0x18c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), ctx.r[3].u32 ) };
	// 82EEF018: 80C1018C  lwz r6, 0x18c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EEF01C: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF020: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF024: 808101CC  lwz r4, 0x1cc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF028: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF02C: 48000505  bl 0x82eef530
	ctx.lr = 0x82EEF030;
	sub_82EEF530(ctx, base);
	// 82EEF030: 48000024  b 0x82eef054
	pc = 0x82EEF054; continue 'dispatch;
	// 82EEF034: 80A1018C  lwz r5, 0x18c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EEF038: 80810190  lwz r4, 0x190(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EEF03C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF040: 4BFFFD09  bl 0x82eeed48
	ctx.lr = 0x82EEF044;
	sub_82EEED48(ctx, base);
	// 82EEF044: 80A10188  lwz r5, 0x188(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEF048: 80810190  lwz r4, 0x190(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EEF04C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF050: 48115D21  bl 0x83004d70
	ctx.lr = 0x82EEF054;
	sub_83004D70(ctx, base);
            }
            0x82EEF054 => {
    //   block [0x82EEF054..0x82EEF0BC)
	// 82EEF054: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF058: 4BFFF819  bl 0x82eee870
	ctx.lr = 0x82EEF05C;
	sub_82EEE870(ctx, base);
	// 82EEF05C: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF060: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82EEF064: 916101D4  stw r11, 0x1d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), ctx.r[11].u32 ) };
	// 82EEF068: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF06C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEF074: 419A0048  beq cr6, 0x82eef0bc
	if ctx.cr[6].eq {
	pc = 0x82EEF0BC; continue 'dispatch;
	}
	// 82EEF078: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF07C: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF080: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF084: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF088: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF08C: 4BFFFCBD  bl 0x82eeed48
	ctx.lr = 0x82EEF090;
	sub_82EEED48(ctx, base);
	// 82EEF090: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF094: 814101C4  lwz r10, 0x1c4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF098: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEF09C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF0A0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEF0A4: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEF0A8: 7CAB53D6  divw r5, r11, r10
	ctx.r[5].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEF0AC: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF0B0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF0B4: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF0B8: 48115CB9  bl 0x83004d70
	ctx.lr = 0x82EEF0BC;
	sub_83004D70(ctx, base);
	pc = 0x82EEF0BC; continue 'dispatch;
            }
            0x82EEF0BC => {
    //   block [0x82EEF0BC..0x82EEF0FC)
	// 82EEF0BC: 81610188  lwz r11, 0x188(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EEF0C0: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 312 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EEF0C4: 81410190  lwz r10, 0x190(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EEF0C8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEF0CC: 814101C4  lwz r10, 0x1c4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF0D0: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EEF0D4: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF0D8: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 312 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EEF0DC: 81410190  lwz r10, 0x190(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EEF0E0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEF0E4: 814101C4  lwz r10, 0x1c4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF0E8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EEF0EC: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF0F0: 81410190  lwz r10, 0x190(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EEF0F4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEF0F8: 48000160  b 0x82eef258
	pc = 0x82EEF258; continue 'dispatch;
            }
            0x82EEF0FC => {
    //   block [0x82EEF0FC..0x82EEF1A8)
	// 82EEF0FC: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF100: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF104: 814101CC  lwz r10, 0x1cc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF108: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEF10C: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEF110: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEF114: 814101D4  lwz r10, 0x1d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF118: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEF11C: 409800CC  bge cr6, 0x82eef1e8
	if !ctx.cr[6].lt {
	pc = 0x82EEF1E8; continue 'dispatch;
	}
	// 82EEF120: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF124: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 312 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EEF128: 814101CC  lwz r10, 0x1cc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF12C: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEF130: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF134: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF138: 808101CC  lwz r4, 0x1cc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF13C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF140: 480003F1  bl 0x82eef530
	ctx.lr = 0x82EEF144;
	sub_82EEF530(ctx, base);
	// 82EEF144: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EEF148: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF14C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF150: 814101CC  lwz r10, 0x1cc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF154: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEF158: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEF15C: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEF160: 814101D4  lwz r10, 0x1d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF164: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EEF168: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF16C: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF170: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF174: 480001CD  bl 0x82eef340
	ctx.lr = 0x82EEF178;
	sub_82EEF340(ctx, base);
	// 82EEF178: 48000030  b 0x82eef1a8
	pc = 0x82EEF1A8; continue 'dispatch;
	// 82EEF17C: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF180: 814101D4  lwz r10, 0x1d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF184: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 312 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EEF188: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF18C: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEF190: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF194: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 312 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EEF198: 814101CC  lwz r10, 0x1cc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF19C: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEF1A0: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF1A4: 4BFFFBA5  bl 0x82eeed48
	ctx.lr = 0x82EEF1A8;
	sub_82EEED48(ctx, base);
            }
            0x82EEF1A8 => {
    //   block [0x82EEF1A8..0x82EEF1E8)
	// 82EEF1A8: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF1AC: 814101D4  lwz r10, 0x1d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF1B0: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 312 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EEF1B4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF1B8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEF1BC: 814101C4  lwz r10, 0x1c4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF1C0: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EEF1C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EEF1C8: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF1CC: 814101D4  lwz r10, 0x1d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF1D0: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 312 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EEF1D4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF1D8: 7C8A5850  subf r4, r10, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEF1DC: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF1E0: 48000391  bl 0x82eef570
	ctx.lr = 0x82EEF1E4;
	sub_82EEF570(ctx, base);
	// 82EEF1E4: 48000074  b 0x82eef258
	pc = 0x82EEF258; continue 'dispatch;
            }
            0x82EEF1E8 => {
    //   block [0x82EEF1E8..0x82EEF258)
	// 82EEF1E8: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF1EC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF1F0: 91610194  stw r11, 0x194(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82EEF1F4: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF1F8: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF1FC: 80A10194  lwz r5, 0x194(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EEF200: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF204: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 312 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EEF208: 81410194  lwz r10, 0x194(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EEF20C: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EEF210: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF214: 4800031D  bl 0x82eef530
	ctx.lr = 0x82EEF218;
	sub_82EEF530(ctx, base);
	// 82EEF218: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EEF21C: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82EEF220: 80A10194  lwz r5, 0x194(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EEF224: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF228: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 312 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EEF22C: 81410194  lwz r10, 0x194(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EEF230: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EEF234: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF238: 48000399  bl 0x82eef5d0
	ctx.lr = 0x82EEF23C;
	sub_82EEF5D0(ctx, base);
	// 82EEF23C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EEF240: 816101D4  lwz r11, 0x1d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EEF244: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 312 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EEF248: 814101CC  lwz r10, 0x1cc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF24C: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEF250: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EEF254: 4800031D  bl 0x82eef570
	ctx.lr = 0x82EEF258;
	sub_82EEF570(ctx, base);
	pc = 0x82EEF258; continue 'dispatch;
            }
            0x82EEF258 => {
    //   block [0x82EEF258..0x82EEF26C)
	// 82EEF258: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 82EEF25C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF260: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF264: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEF268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEF270 size=56
    let mut pc: u32 = 0x82EEF270;
    'dispatch: loop {
        match pc {
            0x82EEF270 => {
    //   block [0x82EEF270..0x82EEF298)
	// 82EEF270: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEF274: 3D6000D2  lis r11, 0xd2
	ctx.r[11].s64 = 13762560;
	// 82EEF278: 616B0D20  ori r11, r11, 0xd20
	ctx.r[11].u64 = ctx.r[11].u64 | 3360;
	// 82EEF27C: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEF280: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEF284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEF288: 40990010  ble cr6, 0x82eef298
	if !ctx.cr[6].gt {
	pc = 0x82EEF298; continue 'dispatch;
	}
	// 82EEF28C: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEF290: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 82EEF294: 4800000C  b 0x82eef2a0
	pc = 0x82EEF2A0; continue 'dispatch;
            }
            0x82EEF298 => {
    //   block [0x82EEF298..0x82EEF2A0)
	// 82EEF298: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EEF29C: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEF2A0; continue 'dispatch;
            }
            0x82EEF2A0 => {
    //   block [0x82EEF2A0..0x82EEF2A8)
	// 82EEF2A0: 8061FFF4  lwz r3, -0xc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EEF2A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEF2A8 size=148
    let mut pc: u32 = 0x82EEF2A8;
    'dispatch: loop {
        match pc {
            0x82EEF2A8 => {
    //   block [0x82EEF2A8..0x82EEF2C4)
	// 82EEF2A8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEF2AC: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EEF2B0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF2B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEF2B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEF2BC: 409A0008  bne cr6, 0x82eef2c4
	if !ctx.cr[6].eq {
	pc = 0x82EEF2C4; continue 'dispatch;
	}
	// 82EEF2C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEF2C4; continue 'dispatch;
            }
            0x82EEF2C4 => {
    //   block [0x82EEF2C4..0x82EEF314)
	// 82EEF2C4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF2C8: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEF2CC: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 312 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EEF2D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF2D4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEF2D8: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF2DC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEF2E0: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEF2E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEF2E8: 4199002C  bgt cr6, 0x82eef314
	if ctx.cr[6].gt {
	pc = 0x82EEF314; continue 'dispatch;
	}
	// 82EEF2EC: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF2F0: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEF2F4: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 312 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EEF2F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF2FC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEF300: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF304: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEF308: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF30C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEF310: 40980008  bge cr6, 0x82eef318
	if !ctx.cr[6].lt {
	pc = 0x82EEF318; continue 'dispatch;
	}
	pc = 0x82EEF314; continue 'dispatch;
            }
            0x82EEF314 => {
    //   block [0x82EEF314..0x82EEF318)
	// 82EEF314: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EEF318; continue 'dispatch;
            }
            0x82EEF318 => {
    //   block [0x82EEF318..0x82EEF33C)
	// 82EEF318: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF31C: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEF320: 1D4A0138  mulli r10, r10, 0x138
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 312 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EEF324: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEF328: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EEF32C: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF330: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EEF334: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEF338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF340 size=80
    let mut pc: u32 = 0x82EEF340;
    'dispatch: loop {
        match pc {
            0x82EEF340 => {
    //   block [0x82EEF340..0x82EEF390)
	// 82EEF340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF348: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF34C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF350: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF354: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEF358: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEF35C: 80C10074  lwz r6, 0x74(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF360: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEF364: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEF368: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEF36C: 480002FD  bl 0x82eef668
	ctx.lr = 0x82EEF370;
	sub_82EEF668(ctx, base);
	// 82EEF370: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEF374: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 312 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EEF378: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEF37C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEF380: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF384: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF388: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF38C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF390 size=64
    let mut pc: u32 = 0x82EEF390;
    'dispatch: loop {
        match pc {
            0x82EEF390 => {
    //   block [0x82EEF390..0x82EEF3D0)
	// 82EEF390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF398: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF39C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF3A0: F8810078  std r4, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[4].u64 ) };
	// 82EEF3A4: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82EEF3A8: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEF3AC: 80C10074  lwz r6, 0x74(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF3B0: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEF3B4: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82EEF3B8: E8610078  ld r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82EEF3BC: 4800031D  bl 0x82eef6d8
	ctx.lr = 0x82EEF3C0;
	sub_82EEF6D8(ctx, base);
	// 82EEF3C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF3C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF3C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF3CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF3D0 size=152
    let mut pc: u32 = 0x82EEF3D0;
    'dispatch: loop {
        match pc {
            0x82EEF3D0 => {
    //   block [0x82EEF3D0..0x82EEF468)
	// 82EEF3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF3D4: 4BDBA039  bl 0x82ca940c
	ctx.lr = 0x82EEF3D8;
	sub_82CA93D0(ctx, base);
	// 82EEF3D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF3DC: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEF3E0: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EEF3E4: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EEF3E8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEF3EC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEF3F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEF3F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF3F8: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF3FC: 388100A4  addi r4, r1, 0xa4
	ctx.r[4].s64 = ctx.r[1].s64 + 164;
	// 82EEF400: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82EEF404: 4800038D  bl 0x82eef790
	ctx.lr = 0x82EEF408;
	sub_82EEF790(ctx, base);
	// 82EEF408: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EEF40C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF410: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EEF414: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EEF418: 99610059  stb r11, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[11].u8 ) };
	// 82EEF41C: 38A100A4  addi r5, r1, 0xa4
	ctx.r[5].s64 = ctx.r[1].s64 + 164;
	// 82EEF420: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82EEF424: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 82EEF428: 48005811  bl 0x82ef4c38
	ctx.lr = 0x82EEF42C;
	sub_82EF4C38(ctx, base);
	// 82EEF42C: 8BE30000  lbz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEF430: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEF434: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 82EEF438: 48000329  bl 0x82eef760
	ctx.lr = 0x82EEF43C;
	sub_82EEF760(ctx, base);
	// 82EEF43C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EEF440: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82EEF444: 4800031D  bl 0x82eef760
	ctx.lr = 0x82EEF448;
	sub_82EEF760(ctx, base);
	// 82EEF448: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EEF44C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EEF450: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EEF454: 88E10059  lbz r7, 0x59(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82EEF458: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEF45C: 48000345  bl 0x82eef7a0
	ctx.lr = 0x82EEF460;
	sub_82EEF7A0(ctx, base);
	// 82EEF460: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEF464: 4BDB9FF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF468 size=76
    let mut pc: u32 = 0x82EEF468;
    'dispatch: loop {
        match pc {
            0x82EEF468 => {
    //   block [0x82EEF468..0x82EEF4B4)
	// 82EEF468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF46C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF470: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF474: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF478: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF47C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEF480: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EEF484: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EEF488: 48000309  bl 0x82eef790
	ctx.lr = 0x82EEF48C;
	sub_82EEF790(ctx, base);
	// 82EEF48C: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
	// 82EEF490: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF494: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEF498: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEF49C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF4A0: 480003C9  bl 0x82eef868
	ctx.lr = 0x82EEF4A4;
	sub_82EEF868(ctx, base);
	// 82EEF4A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF4A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF4AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF4B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF4B8 size=120
    let mut pc: u32 = 0x82EEF4B8;
    'dispatch: loop {
        match pc {
            0x82EEF4B8 => {
    //   block [0x82EEF4B8..0x82EEF4E4)
	// 82EEF4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF4BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF4C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF4C4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF4C8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF4CC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF4D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEF4D4: 41990010  bgt cr6, 0x82eef4e4
	if ctx.cr[6].gt {
	pc = 0x82EEF4E4; continue 'dispatch;
	}
	// 82EEF4D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEF4DC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EEF4E0: 48000034  b 0x82eef514
	pc = 0x82EEF514; continue 'dispatch;
            }
            0x82EEF4E4 => {
    //   block [0x82EEF4E4..0x82EEF514)
	// 82EEF4E4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF4E8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EEF4EC: 0CCB0000  twi 6, r11, 0
	// 82EEF4F0: 7D6A5B96  divwu r11, r10, r11
	ctx.r[11].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 82EEF4F4: 2B0B0138  cmplwi cr6, r11, 0x138
	ctx.cr[6].compare_u32(ctx.r[11].u32, 312 as u32, &mut ctx.xer);
	// 82EEF4F8: 4098001C  bge cr6, 0x82eef514
	if !ctx.cr[6].lt {
	pc = 0x82EEF514; continue 'dispatch;
	}
	// 82EEF4FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEF500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEF504: 4B4026F5  bl 0x822f1bf8
	ctx.lr = 0x82EEF508;
	sub_822F1BF8(ctx, base);
	// 82EEF508: 4B402919  bl 0x822f1e20
	ctx.lr = 0x82EEF50C;
	sub_822F1E20(ctx, base);
	// 82EEF50C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EEF510: 4B402689  bl 0x822f1b98
	ctx.lr = 0x82EEF514;
	sub_822F1B98(ctx, base);
	pc = 0x82EEF514; continue 'dispatch;
            }
            0x82EEF514 => {
    //   block [0x82EEF514..0x82EEF530)
	// 82EEF514: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF518: 1C6B0138  mulli r3, r11, 0x138
	ctx.r[3].s32 = ((ctx.r[11].s32 as i64 * 312 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82EEF51C: 4B3FAC9D  bl 0x822ea1b8
	ctx.lr = 0x82EEF520;
	sub_822EA1B8(ctx, base);
	// 82EEF520: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF52C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF530 size=64
    let mut pc: u32 = 0x82EEF530;
    'dispatch: loop {
        match pc {
            0x82EEF530 => {
    //   block [0x82EEF530..0x82EEF570)
	// 82EEF530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF538: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF53C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF540: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF544: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEF548: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEF54C: 80C10074  lwz r6, 0x74(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF550: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEF554: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEF558: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEF55C: 4800036D  bl 0x82eef8c8
	ctx.lr = 0x82EEF560;
	sub_82EEF8C8(ctx, base);
	// 82EEF560: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF564: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF568: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF56C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF570 size=92
    let mut pc: u32 = 0x82EEF570;
    'dispatch: loop {
        match pc {
            0x82EEF570 => {
    //   block [0x82EEF570..0x82EEF5CC)
	// 82EEF570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF578: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EEF57C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEF580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF584: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEF588: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEF58C: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82EEF590: 83E10094  lwz r31, 0x94(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEF594: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82EEF598: 480001C9  bl 0x82eef760
	ctx.lr = 0x82EEF59C;
	sub_82EEF760(ctx, base);
	// 82EEF59C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EEF5A0: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82EEF5A4: 480001BD  bl 0x82eef760
	ctx.lr = 0x82EEF5A8;
	sub_82EEF760(ctx, base);
	// 82EEF5A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EEF5AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EEF5B0: 480003A1  bl 0x82eef950
	ctx.lr = 0x82EEF5B4;
	sub_82EEF950(ctx, base);
	// 82EEF5B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEF5B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF5BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF5C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EEF5C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEF5C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF5D0 size=148
    let mut pc: u32 = 0x82EEF5D0;
    'dispatch: loop {
        match pc {
            0x82EEF5D0 => {
    //   block [0x82EEF5D0..0x82EEF664)
	// 82EEF5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF5D4: 4BDB9E39  bl 0x82ca940c
	ctx.lr = 0x82EEF5D8;
	sub_82CA93D0(ctx, base);
	// 82EEF5D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF5DC: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEF5E0: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EEF5E4: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EEF5E8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEF5EC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEF5F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEF5F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF5F8: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF5FC: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EEF600: 48005809  bl 0x82ef4e08
	ctx.lr = 0x82EEF604;
	sub_82EF4E08(ctx, base);
	// 82EEF604: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EEF608: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF60C: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EEF610: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EEF614: 99610059  stb r11, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[11].u8 ) };
	// 82EEF618: 38A100A4  addi r5, r1, 0xa4
	ctx.r[5].s64 = ctx.r[1].s64 + 164;
	// 82EEF61C: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82EEF620: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 82EEF624: 48005615  bl 0x82ef4c38
	ctx.lr = 0x82EEF628;
	sub_82EF4C38(ctx, base);
	// 82EEF628: 8BE30000  lbz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEF62C: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEF630: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 82EEF634: 4800012D  bl 0x82eef760
	ctx.lr = 0x82EEF638;
	sub_82EEF760(ctx, base);
	// 82EEF638: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EEF63C: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82EEF640: 48000121  bl 0x82eef760
	ctx.lr = 0x82EEF644;
	sub_82EEF760(ctx, base);
	// 82EEF644: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EEF648: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EEF64C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EEF650: 88E10059  lbz r7, 0x59(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82EEF654: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEF658: 48000359  bl 0x82eef9b0
	ctx.lr = 0x82EEF65C;
	sub_82EEF9B0(ctx, base);
	// 82EEF65C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEF660: 4BDB9DFC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF668 size=108
    let mut pc: u32 = 0x82EEF668;
    'dispatch: loop {
        match pc {
            0x82EEF668 => {
    //   block [0x82EEF668..0x82EEF6D4)
	// 82EEF668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF66C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF670: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF674: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF678: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF67C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEF680: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEF684: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEF688: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEF68C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEF690: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF694: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF698: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82EEF69C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EEF6A0: 480000F1  bl 0x82eef790
	ctx.lr = 0x82EEF6A4;
	sub_82EEF790(ctx, base);
	// 82EEF6A4: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EEF6A8: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF6AC: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EEF6B0: 80C1008C  lwz r6, 0x8c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEF6B4: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEF6B8: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEF6BC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF6C0: 48000369  bl 0x82eefa28
	ctx.lr = 0x82EEF6C4;
	sub_82EEFA28(ctx, base);
	// 82EEF6C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF6C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF6CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF6D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF6D8 size=132
    let mut pc: u32 = 0x82EEF6D8;
    'dispatch: loop {
        match pc {
            0x82EEF6D8 => {
    //   block [0x82EEF6D8..0x82EEF75C)
	// 82EEF6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF6DC: 4BDB9D2D  bl 0x82ca9408
	ctx.lr = 0x82EEF6E0;
	sub_82CA93D0(ctx, base);
	// 82EEF6E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF6E4: F86100A0  std r3, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[3].u64 ) };
	// 82EEF6E8: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82EEF6EC: 90A100B4  stw r5, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[5].u32 ) };
	// 82EEF6F0: 90C100BC  stw r6, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[6].u32 ) };
	// 82EEF6F4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEF6F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEF6FC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEF700: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF704: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF708: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 82EEF70C: 480056FD  bl 0x82ef4e08
	ctx.lr = 0x82EEF710;
	sub_82EF4E08(ctx, base);
	// 82EEF710: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EEF714: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF718: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EEF71C: 8BE10051  lbz r31, 0x51(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EEF720: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEF724: 83A100B4  lwz r29, 0xb4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEF728: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82EEF72C: 480003E5  bl 0x82eefb10
	ctx.lr = 0x82EEF730;
	sub_82EEFB10(ctx, base);
	// 82EEF730: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EEF734: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82EEF738: 480003D9  bl 0x82eefb10
	ctx.lr = 0x82EEF73C;
	sub_82EEFB10(ctx, base);
	// 82EEF73C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EEF740: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EEF744: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EEF748: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82EEF74C: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEF750: 480003F1  bl 0x82eefb40
	ctx.lr = 0x82EEF754;
	sub_82EEFB40(ctx, base);
	// 82EEF754: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEF758: 4BDB9D00  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF760 size=44
    let mut pc: u32 = 0x82EEF760;
    'dispatch: loop {
        match pc {
            0x82EEF760 => {
    //   block [0x82EEF760..0x82EEF78C)
	// 82EEF760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF768: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF76C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF770: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF774: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF778: 48005719  bl 0x82ef4e90
	ctx.lr = 0x82EEF77C;
	sub_82EF4E90(ctx, base);
	// 82EEF77C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF780: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF784: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF788: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEF790 size=16
    let mut pc: u32 = 0x82EEF790;
    'dispatch: loop {
        match pc {
            0x82EEF790 => {
    //   block [0x82EEF790..0x82EEF7A0)
	// 82EEF790: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEF794: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EEF798: 8861FFF0  lbz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEF79C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF7A0 size=196
    let mut pc: u32 = 0x82EEF7A0;
    'dispatch: loop {
        match pc {
            0x82EEF7A0 => {
    //   block [0x82EEF7A0..0x82EEF864)
	// 82EEF7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF7A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF7A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEF7AC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF7B0: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEF7B4: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EEF7B8: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EEF7BC: 98C100AF  stb r6, 0xaf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(175 as u32), ctx.r[6].u8 ) };
	// 82EEF7C0: 98E100B7  stb r7, 0xb7(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(183 as u32), ctx.r[7].u8 ) };
	// 82EEF7C4: 990100BF  stb r8, 0xbf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(191 as u32), ctx.r[8].u8 ) };
	// 82EEF7C8: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEF7CC: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEF7D0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEF7D4: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEF7D8: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEF7DC: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 312 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EEF7E0: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEF7E4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEF7E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEF7EC: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 82EEF7F0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEF7F4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEF7F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF7FC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF800: 39610055  addi r11, r1, 0x55
	ctx.r[11].s64 = ctx.r[1].s64 + 85;
	// 82EEF804: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EEF808: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EEF80C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF810: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF814: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEF818: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82EEF81C: 89610055  lbz r11, 0x55(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 82EEF820: 99610061  stb r11, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[11].u8 ) };
	// 82EEF824: 8BE10056  lbz r31, 0x56(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82EEF828: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EEF82C: 4BFFFF35  bl 0x82eef760
	ctx.lr = 0x82EEF830;
	sub_82EEF760(ctx, base);
	// 82EEF830: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82EEF834: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEF838: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEF83C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EEF840: 88E10061  lbz r7, 0x61(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(97 as u32) ) } as u64;
	// 82EEF844: 89010060  lbz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEF848: 48000341  bl 0x82eefb88
	ctx.lr = 0x82EEF84C;
	sub_82EEFB88(ctx, base);
	// 82EEF84C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF850: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEF854: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF858: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF85C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEF860: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF868 size=92
    let mut pc: u32 = 0x82EEF868;
    'dispatch: loop {
        match pc {
            0x82EEF868 => {
    //   block [0x82EEF868..0x82EEF888)
	// 82EEF868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF86C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF870: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF874: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF878: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF87C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEF880: 98C1008F  stb r6, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[6].u8 ) };
	// 82EEF884: 48000010  b 0x82eef894
	pc = 0x82EEF894; continue 'dispatch;
            }
            0x82EEF888 => {
    //   block [0x82EEF888..0x82EEF894)
	// 82EEF888: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF88C: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEF890: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEF894; continue 'dispatch;
            }
            0x82EEF894 => {
    //   block [0x82EEF894..0x82EEF8B4)
	// 82EEF894: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF898: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEF89C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEF8A0: 419A0014  beq cr6, 0x82eef8b4
	if ctx.cr[6].eq {
	pc = 0x82EEF8B4; continue 'dispatch;
	}
	// 82EEF8A4: 80810074  lwz r4, 0x74(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF8A8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEF8AC: 48114B0D  bl 0x830043b8
	ctx.lr = 0x82EEF8B0;
	sub_830043B8(ctx, base);
	// 82EEF8B0: 4BFFFFD8  b 0x82eef888
	pc = 0x82EEF888; continue 'dispatch;
            }
            0x82EEF8B4 => {
    //   block [0x82EEF8B4..0x82EEF8C4)
	// 82EEF8B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF8B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF8BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF8C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF8C8 size=132
    let mut pc: u32 = 0x82EEF8C8;
    'dispatch: loop {
        match pc {
            0x82EEF8C8 => {
    //   block [0x82EEF8C8..0x82EEF94C)
	// 82EEF8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF8CC: 4BDB9B3D  bl 0x82ca9408
	ctx.lr = 0x82EEF8D0;
	sub_82CA93D0(ctx, base);
	// 82EEF8D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF8D4: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EEF8D8: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82EEF8DC: 90A100B4  stw r5, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[5].u32 ) };
	// 82EEF8E0: 90C100BC  stw r6, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[6].u32 ) };
	// 82EEF8E4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEF8E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEF8EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEF8F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF8F4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF8F8: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 82EEF8FC: 4800550D  bl 0x82ef4e08
	ctx.lr = 0x82EEF900;
	sub_82EF4E08(ctx, base);
	// 82EEF900: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EEF904: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF908: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EEF90C: 8BE10051  lbz r31, 0x51(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EEF910: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEF914: 83A100B4  lwz r29, 0xb4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEF918: 386100AC  addi r3, r1, 0xac
	ctx.r[3].s64 = ctx.r[1].s64 + 172;
	// 82EEF91C: 4BFFFE45  bl 0x82eef760
	ctx.lr = 0x82EEF920;
	sub_82EEF760(ctx, base);
	// 82EEF920: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EEF924: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EEF928: 4BFFFE39  bl 0x82eef760
	ctx.lr = 0x82EEF92C;
	sub_82EEF760(ctx, base);
	// 82EEF92C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EEF930: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EEF934: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EEF938: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82EEF93C: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEF940: 48000201  bl 0x82eefb40
	ctx.lr = 0x82EEF944;
	sub_82EEFB40(ctx, base);
	// 82EEF944: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEF948: 4BDB9B10  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF950 size=92
    let mut pc: u32 = 0x82EEF950;
    'dispatch: loop {
        match pc {
            0x82EEF950 => {
    //   block [0x82EEF950..0x82EEF96C)
	// 82EEF950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF958: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF95C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF960: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF964: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEF968: 48000010  b 0x82eef978
	pc = 0x82EEF978; continue 'dispatch;
            }
            0x82EEF96C => {
    //   block [0x82EEF96C..0x82EEF978)
	// 82EEF96C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF970: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEF974: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEF978; continue 'dispatch;
            }
            0x82EEF978 => {
    //   block [0x82EEF978..0x82EEF99C)
	// 82EEF978: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF97C: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEF980: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEF984: 419A0018  beq cr6, 0x82eef99c
	if ctx.cr[6].eq {
	pc = 0x82EEF99C; continue 'dispatch;
	}
	// 82EEF988: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEF98C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEF990: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEF994: 4BDB9AED  bl 0x82ca9480
	ctx.lr = 0x82EEF998;
	sub_82CA9480(ctx, base);
	// 82EEF998: 4BFFFFD4  b 0x82eef96c
	pc = 0x82EEF96C; continue 'dispatch;
            }
            0x82EEF99C => {
    //   block [0x82EEF99C..0x82EEF9AC)
	// 82EEF99C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEF9A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEF9A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEF9A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEF9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEF9B0 size=116
    let mut pc: u32 = 0x82EEF9B0;
    'dispatch: loop {
        match pc {
            0x82EEF9B0 => {
    //   block [0x82EEF9B0..0x82EEFA24)
	// 82EEF9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEF9B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEF9B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEF9BC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEF9C0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEF9C4: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEF9C8: 98C1008F  stb r6, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[6].u8 ) };
	// 82EEF9CC: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EEF9D0: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EEF9D4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEF9D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEF9DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEF9E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEF9E4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEF9E8: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 82EEF9EC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EEF9F0: 4BFFFDA1  bl 0x82eef790
	ctx.lr = 0x82EEF9F4;
	sub_82EEF790(ctx, base);
	// 82EEF9F4: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EEF9F8: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEF9FC: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EEFA00: 88C1008F  lbz r6, 0x8f(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(143 as u32) ) } as u64;
	// 82EEFA04: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFA08: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFA0C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFA10: 480001F1  bl 0x82eefc00
	ctx.lr = 0x82EEFA14;
	sub_82EEFC00(ctx, base);
	// 82EEFA14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFA18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFA1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFA20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFA28 size=172
    let mut pc: u32 = 0x82EEFA28;
    'dispatch: loop {
        match pc {
            0x82EEFA28 => {
    //   block [0x82EEFA28..0x82EEFA58)
	// 82EEFA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFA2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFA30: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFA34: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFA38: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEFA3C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEFA40: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEFA44: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EEFA48: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EEFA4C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFA50: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEFA54: 4800001C  b 0x82eefa70
	pc = 0x82EEFA70; continue 'dispatch;
            }
            0x82EEFA58 => {
    //   block [0x82EEFA58..0x82EEFA70)
	// 82EEFA58: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFA5C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EEFA60: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EEFA64: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFA68: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEFA6C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEFA70; continue 'dispatch;
            }
            0x82EEFA70 => {
    //   block [0x82EEFA70..0x82EEFA90)
	// 82EEFA70: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFA74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEFA78: 40990018  ble cr6, 0x82eefa90
	if !ctx.cr[6].gt {
	pc = 0x82EEFA90; continue 'dispatch;
	}
	// 82EEFA7C: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFA80: 80810074  lwz r4, 0x74(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFA84: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEFA88: 48000051  bl 0x82eefad8
	ctx.lr = 0x82EEFA8C;
	sub_82EEFAD8(ctx, base);
	// 82EEFA8C: 4BFFFFCC  b 0x82eefa58
	pc = 0x82EEFA58; continue 'dispatch;
            }
            0x82EEFA90 => {
    //   block [0x82EEFA90..0x82EEFA98)
	// 82EEFA90: 48000034  b 0x82eefac4
	pc = 0x82EEFAC4; continue 'dispatch;
	// 82EEFA94: 48000010  b 0x82eefaa4
	pc = 0x82EEFAA4; continue 'dispatch;
            }
            0x82EEFA98 => {
    //   block [0x82EEFA98..0x82EEFAA4)
	// 82EEFA98: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFA9C: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEFAA0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEFAA4; continue 'dispatch;
            }
            0x82EEFAA4 => {
    //   block [0x82EEFAA4..0x82EEFAC4)
	// 82EEFAA4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFAA8: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFAAC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEFAB0: 419A0014  beq cr6, 0x82eefac4
	if ctx.cr[6].eq {
	pc = 0x82EEFAC4; continue 'dispatch;
	}
	// 82EEFAB4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFAB8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEFABC: 481148FD  bl 0x830043b8
	ctx.lr = 0x82EEFAC0;
	sub_830043B8(ctx, base);
	// 82EEFAC0: 4BFFFFD8  b 0x82eefa98
	pc = 0x82EEFA98; continue 'dispatch;
            }
            0x82EEFAC4 => {
    //   block [0x82EEFAC4..0x82EEFAD4)
	// 82EEFAC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFAC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFACC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFAD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFAD8 size=52
    let mut pc: u32 = 0x82EEFAD8;
    'dispatch: loop {
        match pc {
            0x82EEFAD8 => {
    //   block [0x82EEFAD8..0x82EEFB0C)
	// 82EEFAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFAE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFAE4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFAE8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEFAEC: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEFAF0: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFAF4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFAF8: 480001D1  bl 0x82eefcc8
	ctx.lr = 0x82EEFAFC;
	sub_82EEFCC8(ctx, base);
	// 82EEFAFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFB00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFB04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFB08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFB10 size=44
    let mut pc: u32 = 0x82EEFB10;
    'dispatch: loop {
        match pc {
            0x82EEFB10 => {
    //   block [0x82EEFB10..0x82EEFB3C)
	// 82EEFB10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFB14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFB18: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFB1C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFB20: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFB24: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFB28: 48000211  bl 0x82eefd38
	ctx.lr = 0x82EEFB2C;
	sub_82EEFD38(ctx, base);
	// 82EEFB2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFB30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFB34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFB38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFB40 size=72
    let mut pc: u32 = 0x82EEFB40;
    'dispatch: loop {
        match pc {
            0x82EEFB40 => {
    //   block [0x82EEFB40..0x82EEFB88)
	// 82EEFB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFB44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFB48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFB4C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFB50: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEFB54: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEFB58: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEFB5C: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EEFB60: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EEFB64: 80C1008C  lwz r6, 0x8c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEFB68: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFB6C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFB70: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFB74: 480001F5  bl 0x82eefd68
	ctx.lr = 0x82EEFB78;
	sub_82EEFD68(ctx, base);
	// 82EEFB78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFB7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFB80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFB84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFB88 size=120
    let mut pc: u32 = 0x82EEFB88;
    'dispatch: loop {
        match pc {
            0x82EEFB88 => {
    //   block [0x82EEFB88..0x82EEFBB0)
	// 82EEFB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFB8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFB90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFB94: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFB98: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEFB9C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEFBA0: 98C1008F  stb r6, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[6].u8 ) };
	// 82EEFBA4: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EEFBA8: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EEFBAC: 4800001C  b 0x82eefbc8
	pc = 0x82EEFBC8; continue 'dispatch;
            }
            0x82EEFBB0 => {
    //   block [0x82EEFBB0..0x82EEFBC8)
	// 82EEFBB0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFBB4: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEFBB8: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEFBBC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFBC0: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEFBC4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEFBC8; continue 'dispatch;
            }
            0x82EEFBC8 => {
    //   block [0x82EEFBC8..0x82EEFBEC)
	// 82EEFBC8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFBCC: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFBD0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEFBD4: 419A0018  beq cr6, 0x82eefbec
	if ctx.cr[6].eq {
	pc = 0x82EEFBEC; continue 'dispatch;
	}
	// 82EEFBD8: 80810074  lwz r4, 0x74(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFBDC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFBE0: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEFBE4: 4BDB989D  bl 0x82ca9480
	ctx.lr = 0x82EEFBE8;
	sub_82CA9480(ctx, base);
	// 82EEFBE8: 4BFFFFC8  b 0x82eefbb0
	pc = 0x82EEFBB0; continue 'dispatch;
            }
            0x82EEFBEC => {
    //   block [0x82EEFBEC..0x82EEFC00)
	// 82EEFBEC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFBF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFBF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFBF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFBFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFC00 size=196
    let mut pc: u32 = 0x82EEFC00;
    'dispatch: loop {
        match pc {
            0x82EEFC00 => {
    //   block [0x82EEFC00..0x82EEFCC4)
	// 82EEFC00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFC04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFC08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEFC0C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFC10: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EEFC14: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EEFC18: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EEFC1C: 98C100AF  stb r6, 0xaf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(175 as u32), ctx.r[6].u8 ) };
	// 82EEFC20: 98E100B7  stb r7, 0xb7(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(183 as u32), ctx.r[7].u8 ) };
	// 82EEFC24: 990100BF  stb r8, 0xbf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(191 as u32), ctx.r[8].u8 ) };
	// 82EEFC28: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEFC2C: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEFC30: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EEFC34: 39400138  li r10, 0x138
	ctx.r[10].s64 = 312;
	// 82EEFC38: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82EEFC3C: 1D6B0138  mulli r11, r11, 0x138
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 312 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EEFC40: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEFC44: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EEFC48: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEFC4C: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 82EEFC50: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEFC54: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEFC58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEFC5C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEFC60: 39610055  addi r11, r1, 0x55
	ctx.r[11].s64 = ctx.r[1].s64 + 85;
	// 82EEFC64: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EEFC68: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EEFC6C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEFC70: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEFC74: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEFC78: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82EEFC7C: 89610055  lbz r11, 0x55(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 82EEFC80: 99610061  stb r11, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[11].u8 ) };
	// 82EEFC84: 8BE10056  lbz r31, 0x56(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82EEFC88: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EEFC8C: 4BFFFAD5  bl 0x82eef760
	ctx.lr = 0x82EEFC90;
	sub_82EEF760(ctx, base);
	// 82EEFC90: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82EEFC94: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEFC98: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEFC9C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EEFCA0: 88E10061  lbz r7, 0x61(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(97 as u32) ) } as u64;
	// 82EEFCA4: 89010060  lbz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEFCA8: 48000149  bl 0x82eefdf0
	ctx.lr = 0x82EEFCAC;
	sub_82EEFDF0(ctx, base);
	// 82EEFCAC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFCB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EEFCB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFCB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFCBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEFCC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFCC8 size=108
    let mut pc: u32 = 0x82EEFCC8;
    'dispatch: loop {
        match pc {
            0x82EEFCC8 => {
    //   block [0x82EEFCC8..0x82EEFD1C)
	// 82EEFCC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFCCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFCD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFCD4: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEFCD8: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEFCDC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFCE0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEFCE4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFCE8: 38600138  li r3, 0x138
	ctx.r[3].s64 = 312;
	// 82EEFCEC: 4B401F25  bl 0x822f1c10
	ctx.lr = 0x82EEFCF0;
	sub_822F1C10(ctx, base);
	// 82EEFCF0: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEFCF4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEFCF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEFCFC: 419A0020  beq cr6, 0x82eefd1c
	if ctx.cr[6].eq {
	pc = 0x82EEFD1C; continue 'dispatch;
	}
	// 82EEFD00: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEFD04: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEFD08: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEFD0C: 4BDB9775  bl 0x82ca9480
	ctx.lr = 0x82EEFD10;
	sub_82CA9480(ctx, base);
	// 82EEFD10: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEFD14: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEFD18: 4800000C  b 0x82eefd24
	pc = 0x82EEFD24; continue 'dispatch;
            }
            0x82EEFD1C => {
    //   block [0x82EEFD1C..0x82EEFD24)
	// 82EEFD1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEFD20: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEFD24; continue 'dispatch;
            }
            0x82EEFD24 => {
    //   block [0x82EEFD24..0x82EEFD34)
	// 82EEFD24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEFD28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFD2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFD30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFD38 size=44
    let mut pc: u32 = 0x82EEFD38;
    'dispatch: loop {
        match pc {
            0x82EEFD38 => {
    //   block [0x82EEFD38..0x82EEFD64)
	// 82EEFD38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFD3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFD40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFD44: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFD48: 9881007F  stb r4, 0x7f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(127 as u32), ctx.r[4].u8 ) };
	// 82EEFD4C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFD50: 48113691  bl 0x830033e0
	ctx.lr = 0x82EEFD54;
	sub_830033E0(ctx, base);
	// 82EEFD54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFD58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFD5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFD60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFD68 size=136
    let mut pc: u32 = 0x82EEFD68;
    'dispatch: loop {
        match pc {
            0x82EEFD68 => {
    //   block [0x82EEFD68..0x82EEFDF0)
	// 82EEFD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFD6C: 4BDB969D  bl 0x82ca9408
	ctx.lr = 0x82EEFD70;
	sub_82CA93D0(ctx, base);
	// 82EEFD70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFD74: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EEFD78: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82EEFD7C: 90A100B4  stw r5, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[5].u32 ) };
	// 82EEFD80: 90C100BC  stw r6, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[6].u32 ) };
	// 82EEFD84: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEFD88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEFD8C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEFD90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEFD94: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEFD98: 388100B4  addi r4, r1, 0xb4
	ctx.r[4].s64 = ctx.r[1].s64 + 180;
	// 82EEFD9C: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EEFDA0: 4BFFF9F1  bl 0x82eef790
	ctx.lr = 0x82EEFDA4;
	sub_82EEF790(ctx, base);
	// 82EEFDA4: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EEFDA8: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFDAC: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EEFDB0: 8BE10051  lbz r31, 0x51(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EEFDB4: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEFDB8: 83A100B4  lwz r29, 0xb4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEFDBC: 386100AC  addi r3, r1, 0xac
	ctx.r[3].s64 = ctx.r[1].s64 + 172;
	// 82EEFDC0: 4BFFF9A1  bl 0x82eef760
	ctx.lr = 0x82EEFDC4;
	sub_82EEF760(ctx, base);
	// 82EEFDC4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EEFDC8: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EEFDCC: 4BFFF995  bl 0x82eef760
	ctx.lr = 0x82EEFDD0;
	sub_82EEF760(ctx, base);
	// 82EEFDD0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EEFDD4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EEFDD8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EEFDDC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82EEFDE0: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEFDE4: 48000085  bl 0x82eefe68
	ctx.lr = 0x82EEFDE8;
	sub_82EEFE68(ctx, base);
	// 82EEFDE8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEFDEC: 4BDB966C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFDF0 size=116
    let mut pc: u32 = 0x82EEFDF0;
    'dispatch: loop {
        match pc {
            0x82EEFDF0 => {
    //   block [0x82EEFDF0..0x82EEFE14)
	// 82EEFDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFDF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFDF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFDFC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFE00: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEFE04: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEFE08: 98C1008F  stb r6, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[6].u8 ) };
	// 82EEFE0C: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EEFE10: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	pc = 0x82EEFE14; continue 'dispatch;
            }
            0x82EEFE14 => {
    //   block [0x82EEFE14..0x82EEFE50)
	// 82EEFE14: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFE18: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFE1C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEFE20: 419A0030  beq cr6, 0x82eefe50
	if ctx.cr[6].eq {
	pc = 0x82EEFE50; continue 'dispatch;
	}
	// 82EEFE24: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFE28: 396BFEC8  addi r11, r11, -0x138
	ctx.r[11].s64 = ctx.r[11].s64 + -312;
	// 82EEFE2C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EEFE30: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFE34: 396BFEC8  addi r11, r11, -0x138
	ctx.r[11].s64 = ctx.r[11].s64 + -312;
	// 82EEFE38: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEFE3C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFE40: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFE44: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 82EEFE48: 4BDB9639  bl 0x82ca9480
	ctx.lr = 0x82EEFE4C;
	sub_82CA9480(ctx, base);
	// 82EEFE4C: 4BFFFFC8  b 0x82eefe14
	pc = 0x82EEFE14; continue 'dispatch;
            }
            0x82EEFE50 => {
    //   block [0x82EEFE50..0x82EEFE64)
	// 82EEFE50: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFE54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFE58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFE5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFE60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFE68 size=180
    let mut pc: u32 = 0x82EEFE68;
    'dispatch: loop {
        match pc {
            0x82EEFE68 => {
    //   block [0x82EEFE68..0x82EEFE98)
	// 82EEFE68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFE6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEFE70: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFE74: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEFE78: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEFE7C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEFE80: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEFE84: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EEFE88: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EEFE8C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFE90: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEFE94: 4800001C  b 0x82eefeb0
	pc = 0x82EEFEB0; continue 'dispatch;
            }
            0x82EEFE98 => {
    //   block [0x82EEFE98..0x82EEFEB0)
	// 82EEFE98: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFE9C: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEFEA0: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEFEA4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFEA8: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEFEAC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEFEB0; continue 'dispatch;
            }
            0x82EEFEB0 => {
    //   block [0x82EEFEB0..0x82EEFED4)
	// 82EEFEB0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFEB4: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEFEB8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEFEBC: 419A0018  beq cr6, 0x82eefed4
	if ctx.cr[6].eq {
	pc = 0x82EEFED4; continue 'dispatch;
	}
	// 82EEFEC0: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEFEC4: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFEC8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEFECC: 4BFFFC0D  bl 0x82eefad8
	ctx.lr = 0x82EEFED0;
	sub_82EEFAD8(ctx, base);
	// 82EEFED0: 4BFFFFC8  b 0x82eefe98
	pc = 0x82EEFE98; continue 'dispatch;
            }
            0x82EEFED4 => {
    //   block [0x82EEFED4..0x82EEFEDC)
	// 82EEFED4: 48000034  b 0x82eeff08
	pc = 0x82EEFF08; continue 'dispatch;
	// 82EEFED8: 48000010  b 0x82eefee8
	pc = 0x82EEFEE8; continue 'dispatch;
            }
            0x82EEFEDC => {
    //   block [0x82EEFEDC..0x82EEFEE8)
	// 82EEFEDC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFEE0: 396B0138  addi r11, r11, 0x138
	ctx.r[11].s64 = ctx.r[11].s64 + 312;
	// 82EEFEE4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEFEE8; continue 'dispatch;
            }
            0x82EEFEE8 => {
    //   block [0x82EEFEE8..0x82EEFF08)
	// 82EEFEE8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFEEC: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFEF0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEFEF4: 419A0014  beq cr6, 0x82eeff08
	if ctx.cr[6].eq {
	pc = 0x82EEFF08; continue 'dispatch;
	}
	// 82EEFEF8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEFEFC: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEFF00: 481144B9  bl 0x830043b8
	ctx.lr = 0x82EEFF04;
	sub_830043B8(ctx, base);
	// 82EEFF04: 4BFFFFD8  b 0x82eefedc
	pc = 0x82EEFEDC; continue 'dispatch;
            }
            0x82EEFF08 => {
    //   block [0x82EEFF08..0x82EEFF1C)
	// 82EEFF08: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEFF0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEFF10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEFF14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEFF18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEFF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEFF20 size=232
    let mut pc: u32 = 0x82EEFF20;
    'dispatch: loop {
        match pc {
            0x82EEFF20 => {
    //   block [0x82EEFF20..0x82EEFF78)
	// 82EEFF20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEFF24: 4BDB94E9  bl 0x82ca940c
	ctx.lr = 0x82EEFF28;
	sub_82CA93D0(ctx, base);
	// 82EEFF28: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEFF2C: 90610124  stw r3, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[3].u32 ) };
	// 82EEFF30: 9081012C  stw r4, 0x12c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), ctx.r[4].u32 ) };
	// 82EEFF34: 3BE100E0  addi r31, r1, 0xe0
	ctx.r[31].s64 = ctx.r[1].s64 + 224;
	// 82EEFF38: 3BC100E4  addi r30, r1, 0xe4
	ctx.r[30].s64 = ctx.r[1].s64 + 228;
	// 82EEFF3C: 83A1012C  lwz r29, 0x12c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(300 as u32) ) } as u64;
	// 82EEFF40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEFF44: 4811B9AD  bl 0x8300b8f0
	ctx.lr = 0x82EEFF48;
	sub_8300B8F0(ctx, base);
	// 82EEFF48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EEFF4C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EEFF50: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EEFF54: 4BDD86BD  bl 0x82cc8610
	ctx.lr = 0x82EEFF58;
	sub_82CC8610(ctx, base);
	// 82EEFF58: 816100E4  lwz r11, 0xe4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82EEFF5C: 916100DC  stw r11, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 82EEFF60: 816100E0  lwz r11, 0xe0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 82EEFF64: 2B0B0014  cmplwi cr6, r11, 0x14
	ctx.cr[6].compare_u32(ctx.r[11].u32, 20 as u32, &mut ctx.xer);
	// 82EEFF68: 419A0010  beq cr6, 0x82eeff78
	if ctx.cr[6].eq {
	pc = 0x82EEFF78; continue 'dispatch;
	}
	// 82EEFF6C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EEFF70: 61634005  ori r3, r11, 0x4005
	ctx.r[3].u64 = ctx.r[11].u64 | 16389;
	// 82EEFF74: 4800008C  b 0x82ef0000
	pc = 0x82EF0000; continue 'dispatch;
            }
            0x82EEFF78 => {
    //   block [0x82EEFF78..0x82EEFFF8)
	// 82EEFF78: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EEFF7C: 4811B95D  bl 0x8300b8d8
	ctx.lr = 0x82EEFF80;
	sub_8300B8D8(ctx, base);
	// 82EEFF80: 80610124  lwz r3, 0x124(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 82EEFF84: 4811345D  bl 0x830033e0
	ctx.lr = 0x82EEFF88;
	sub_830033E0(ctx, base);
	// 82EEFF88: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEFF8C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEFF90: 80610124  lwz r3, 0x124(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 82EEFF94: 4BFFD4D5  bl 0x82eed468
	ctx.lr = 0x82EEFF98;
	sub_82EED468(ctx, base);
	// 82EEFF98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EEFF9C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EEFFA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EEFFA4: 4811B93D  bl 0x8300b8e0
	ctx.lr = 0x82EEFFA8;
	sub_8300B8E0(ctx, base);
	// 82EEFFA8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEFFAC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEFFB0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82EEFFB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EEFFB8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EEFFBC: 4811B925  bl 0x8300b8e0
	ctx.lr = 0x82EEFFC0;
	sub_8300B8E0(ctx, base);
	// 82EEFFC0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EEFFC4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EEFFC8: 4811B921  bl 0x8300b8e8
	ctx.lr = 0x82EEFFCC;
	sub_8300B8E8(ctx, base);
	// 82EEFFCC: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 82EEFFD0: 808100DC  lwz r4, 0xdc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82EEFFD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEFFD8: 48119139  bl 0x83009110
	ctx.lr = 0x82EEFFDC;
	sub_83009110(ctx, base);
	// 82EEFFDC: 906100D8  stw r3, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[3].u32 ) };
	// 82EEFFE0: 816100D8  lwz r11, 0xd8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) } as u64;
	// 82EEFFE4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEFFE8: 409A0010  bne cr6, 0x82eefff8
	if !ctx.cr[6].eq {
	pc = 0x82EEFFF8; continue 'dispatch;
	}
	// 82EEFFEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEFFF0: 48000010  b 0x82ef0000
	pc = 0x82EF0000; continue 'dispatch;
	// 82EEFFF4: 4800000C  b 0x82ef0000
	pc = 0x82EF0000; continue 'dispatch;
            }
            0x82EEFFF8 => {
    //   block [0x82EEFFF8..0x82EF0000)
	// 82EEFFF8: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EEFFFC: 61634005  ori r3, r11, 0x4005
	ctx.r[3].u64 = ctx.r[11].u64 | 16389;
	pc = 0x82EF0000; continue 'dispatch;
            }
            0x82EF0000 => {
    //   block [0x82EF0000..0x82EF0008)
	// 82EF0000: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82EF0004: 4BDB9458  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0008 size=80
    let mut pc: u32 = 0x82EF0008;
    'dispatch: loop {
        match pc {
            0x82EF0008 => {
    //   block [0x82EF0008..0x82EF0058)
	// 82EF0008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF000C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0010: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF0014: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF0018: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF001C: 3880005C  li r4, 0x5c
	ctx.r[4].s64 = 92;
	// 82EF0020: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF0024: 4BDBD86D  bl 0x82cad890
	ctx.lr = 0x82EF0028;
	sub_82CAD890(ctx, base);
	// 82EF0028: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF002C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0030: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF0034: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF0038: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82EF003C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0040: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0044: 4B3DD065  bl 0x822cd0a8
	ctx.lr = 0x82EF0048;
	sub_822CD0A8(ctx, base);
	// 82EF0048: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF004C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF0050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0054: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0058 size=60
    let mut pc: u32 = 0x82EF0058;
    'dispatch: loop {
        match pc {
            0x82EF0058 => {
    //   block [0x82EF0058..0x82EF0094)
	// 82EF0058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF005C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0060: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF0064: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF0068: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF006C: 4800002D  bl 0x82ef0098
	ctx.lr = 0x82EF0070;
	sub_82EF0098(ctx, base);
	// 82EF0070: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0074: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF0078: 48003B69  bl 0x82ef3be0
	ctx.lr = 0x82EF007C;
	sub_82EF3BE0(ctx, base);
	// 82EF007C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0080: 4BFFDEF1  bl 0x82eedf70
	ctx.lr = 0x82EF0084;
	sub_82EEDF70(ctx, base);
	// 82EF0084: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF0088: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF008C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0098 size=184
    let mut pc: u32 = 0x82EF0098;
    'dispatch: loop {
        match pc {
            0x82EF0098 => {
    //   block [0x82EF0098..0x82EF00B4)
	// 82EF0098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF009C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF00A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF00A4: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF00A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF00AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF00B0: 48000010  b 0x82ef00c0
	pc = 0x82EF00C0; continue 'dispatch;
            }
            0x82EF00B4 => {
    //   block [0x82EF00B4..0x82EF00C0)
	// 82EF00B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF00B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF00BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF00C0; continue 'dispatch;
            }
            0x82EF00C0 => {
    //   block [0x82EF00C0..0x82EF0128)
	// 82EF00C0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF00C4: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF00C8: 48003B81  bl 0x82ef3c48
	ctx.lr = 0x82EF00CC;
	sub_82EF3C48(ctx, base);
	// 82EF00CC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF00D0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EF00D4: 40980060  bge cr6, 0x82ef0134
	if !ctx.cr[6].lt {
	pc = 0x82EF0134; continue 'dispatch;
	}
	// 82EF00D8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF00DC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF00E0: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF00E4: 48003BAD  bl 0x82ef3c90
	ctx.lr = 0x82EF00E8;
	sub_82EF3C90(ctx, base);
	// 82EF00E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF00EC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EF00F0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF00F4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF00F8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF00FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0100: 419A0028  beq cr6, 0x82ef0128
	if ctx.cr[6].eq {
	pc = 0x82EF0128; continue 'dispatch;
	}
	// 82EF0104: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EF0108: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF010C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0110: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0114: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0118: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF011C: 4E800421  bctrl
	ctx.lr = 0x82EF0120;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0120: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82EF0124: 4800000C  b 0x82ef0130
	pc = 0x82EF0130; continue 'dispatch;
            }
            0x82EF0128 => {
    //   block [0x82EF0128..0x82EF0130)
	// 82EF0128: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF012C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF0130; continue 'dispatch;
            }
            0x82EF0130 => {
    //   block [0x82EF0130..0x82EF0134)
	// 82EF0130: 4BFFFF84  b 0x82ef00b4
	pc = 0x82EF00B4; continue 'dispatch;
            }
            0x82EF0134 => {
    //   block [0x82EF0134..0x82EF0150)
	// 82EF0134: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0138: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF013C: 48003CC5  bl 0x82ef3e00
	ctx.lr = 0x82EF0140;
	sub_82EF3E00(ctx, base);
	// 82EF0140: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF0144: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF0148: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF014C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0150 size=364
    let mut pc: u32 = 0x82EF0150;
    'dispatch: loop {
        match pc {
            0x82EF0150 => {
    //   block [0x82EF0150..0x82EF01A4)
	// 82EF0150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF0154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0158: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF015C: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF0160: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EF0164: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0168: 4BFFE009  bl 0x82eee170
	ctx.lr = 0x82EF016C;
	sub_82EEE170(ctx, base);
	// 82EF016C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0170: 48000151  bl 0x82ef02c0
	ctx.lr = 0x82EF0174;
	sub_82EF02C0(ctx, base);
	// 82EF0174: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0178: 40820134  bne 0x82ef02ac
	if !ctx.cr[0].eq {
	pc = 0x82EF02AC; continue 'dispatch;
	}
	// 82EF017C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0180: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF0184: 48003AC5  bl 0x82ef3c48
	ctx.lr = 0x82EF0188;
	sub_82EF3C48(ctx, base);
	// 82EF0188: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EF018C: 40820120  bne 0x82ef02ac
	if !ctx.cr[0].eq {
	pc = 0x82EF02AC; continue 'dispatch;
	}
	// 82EF0190: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0194: 4BFFFF05  bl 0x82ef0098
	ctx.lr = 0x82EF0198;
	sub_82EF0098(ctx, base);
	// 82EF0198: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF019C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF01A0: 48000010  b 0x82ef01b0
	pc = 0x82EF01B0; continue 'dispatch;
            }
            0x82EF01A4 => {
    //   block [0x82EF01A4..0x82EF01B0)
	// 82EF01A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF01A8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF01AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF01B0; continue 'dispatch;
            }
            0x82EF01B0 => {
    //   block [0x82EF01B0..0x82EF020C)
	// 82EF01B0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF01B4: 4800012D  bl 0x82ef02e0
	ctx.lr = 0x82EF01B8;
	sub_82EF02E0(ctx, base);
	// 82EF01B8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF01BC: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EF01C0: 40980090  bge cr6, 0x82ef0250
	if !ctx.cr[6].lt {
	pc = 0x82EF0250; continue 'dispatch;
	}
	// 82EF01C4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF01C8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF01CC: 4BFFDDDD  bl 0x82eedfa8
	ctx.lr = 0x82EF01D0;
	sub_82EEDFA8(ctx, base);
	// 82EF01D0: 81630134  lwz r11, 0x134(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF01D4: 3D405841  lis r10, 0x5841
	ctx.r[10].s64 = 1480654848;
	// 82EF01D8: 614A091D  ori r10, r10, 0x91d
	ctx.r[10].u64 = ctx.r[10].u64 | 2333;
	// 82EF01DC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF01E0: 409A006C  bne cr6, 0x82ef024c
	if !ctx.cr[6].eq {
	pc = 0x82EF024C; continue 'dispatch;
	}
	// 82EF01E4: 38600368  li r3, 0x368
	ctx.r[3].s64 = 872;
	// 82EF01E8: 4B3F9FD1  bl 0x822ea1b8
	ctx.lr = 0x82EF01EC;
	sub_822EA1B8(ctx, base);
	// 82EF01EC: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82EF01F0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF01F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF01F8: 419A0014  beq cr6, 0x82ef020c
	if ctx.cr[6].eq {
	pc = 0x82EF020C; continue 'dispatch;
	}
	// 82EF01FC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF0200: 4BFF8129  bl 0x82ee8328
	ctx.lr = 0x82EF0204;
	sub_82EE8328(ctx, base);
	// 82EF0204: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EF0208: 4800000C  b 0x82ef0214
	pc = 0x82EF0214; continue 'dispatch;
            }
            0x82EF020C => {
    //   block [0x82EF020C..0x82EF0214)
	// 82EF020C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF0210: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF0214; continue 'dispatch;
            }
            0x82EF0214 => {
    //   block [0x82EF0214..0x82EF024C)
	// 82EF0214: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF0218: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF021C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0220: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0224: 4BFFDD85  bl 0x82eedfa8
	ctx.lr = 0x82EF0228;
	sub_82EEDFA8(ctx, base);
	// 82EF0228: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82EF022C: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF0230: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0234: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF0238: 4BFF8E39  bl 0x82ee9070
	ctx.lr = 0x82EF023C;
	sub_82EE9070(ctx, base);
	// 82EF023C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82EF0240: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0244: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF0248: 48003A99  bl 0x82ef3ce0
	ctx.lr = 0x82EF024C;
	sub_82EF3CE0(ctx, base);
	pc = 0x82EF024C; continue 'dispatch;
            }
            0x82EF024C => {
    //   block [0x82EF024C..0x82EF0250)
	// 82EF024C: 4BFFFF58  b 0x82ef01a4
	pc = 0x82EF01A4; continue 'dispatch;
            }
            0x82EF0250 => {
    //   block [0x82EF0250..0x82EF0264)
	// 82EF0250: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0254: 4800008D  bl 0x82ef02e0
	ctx.lr = 0x82EF0258;
	sub_82EF02E0(ctx, base);
	// 82EF0258: 3963FFFF  addi r11, r3, -1
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	// 82EF025C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EF0260: 48000010  b 0x82ef0270
	pc = 0x82EF0270; continue 'dispatch;
            }
            0x82EF0264 => {
    //   block [0x82EF0264..0x82EF0270)
	// 82EF0264: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0268: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EF026C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF0270; continue 'dispatch;
            }
            0x82EF0270 => {
    //   block [0x82EF0270..0x82EF02A8)
	// 82EF0270: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0274: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0278: 41980034  blt cr6, 0x82ef02ac
	if ctx.cr[6].lt {
	pc = 0x82EF02AC; continue 'dispatch;
	}
	// 82EF027C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0280: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF0284: 4BFFDD25  bl 0x82eedfa8
	ctx.lr = 0x82EF0288;
	sub_82EEDFA8(ctx, base);
	// 82EF0288: 81630134  lwz r11, 0x134(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF028C: 3D405841  lis r10, 0x5841
	ctx.r[10].s64 = 1480654848;
	// 82EF0290: 614A091D  ori r10, r10, 0x91d
	ctx.r[10].u64 = ctx.r[10].u64 | 2333;
	// 82EF0294: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF0298: 419A0010  beq cr6, 0x82ef02a8
	if ctx.cr[6].eq {
	pc = 0x82EF02A8; continue 'dispatch;
	}
	// 82EF029C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF02A0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF02A4: 4BFFDF1D  bl 0x82eee1c0
	ctx.lr = 0x82EF02A8;
	sub_82EEE1C0(ctx, base);
	pc = 0x82EF02A8; continue 'dispatch;
            }
            0x82EF02A8 => {
    //   block [0x82EF02A8..0x82EF02AC)
	// 82EF02A8: 4BFFFFBC  b 0x82ef0264
	pc = 0x82EF0264; continue 'dispatch;
            }
            0x82EF02AC => {
    //   block [0x82EF02AC..0x82EF02BC)
	// 82EF02AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF02B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF02B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF02B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF02C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF02C0 size=32
    let mut pc: u32 = 0x82EF02C0;
    'dispatch: loop {
        match pc {
            0x82EF02C0 => {
    //   block [0x82EF02C0..0x82EF02E0)
	// 82EF02C0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF02C4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF02C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF02CC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EF02D0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EF02D4: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82EF02D8: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EF02DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF02E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF02E0 size=44
    let mut pc: u32 = 0x82EF02E0;
    'dispatch: loop {
        match pc {
            0x82EF02E0 => {
    //   block [0x82EF02E0..0x82EF030C)
	// 82EF02E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF02E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF02E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF02EC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF02F0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF02F4: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82EF02F8: 4BFFE579  bl 0x82eee870
	ctx.lr = 0x82EF02FC;
	sub_82EEE870(ctx, base);
	// 82EF02FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF0300: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF0304: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0308: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0310 size=56
    let mut pc: u32 = 0x82EF0310;
    'dispatch: loop {
        match pc {
            0x82EF0310 => {
    //   block [0x82EF0310..0x82EF0348)
	// 82EF0310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF0314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0318: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF031C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF0320: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0324: 4BFFFF9D  bl 0x82ef02c0
	ctx.lr = 0x82EF0328;
	sub_82EF02C0(ctx, base);
	// 82EF0328: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EF032C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EF0330: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EF0334: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EF0338: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF033C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF0340: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0348 size=292
    let mut pc: u32 = 0x82EF0348;
    'dispatch: loop {
        match pc {
            0x82EF0348 => {
    //   block [0x82EF0348..0x82EF046C)
	// 82EF0348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF034C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0350: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF0354: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF0358: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF035C: 480FE24D  bl 0x82fee5a8
	ctx.lr = 0x82EF0360;
	sub_82FEE5A8(ctx, base);
	// 82EF0360: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0364: 396BC600  addi r11, r11, -0x3a00
	ctx.r[11].s64 = ctx.r[11].s64 + -14848;
	// 82EF0368: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF036C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EF0370: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0374: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EF0378: 394AC5F8  addi r10, r10, -0x3a08
	ctx.r[10].s64 = ctx.r[10].s64 + -14856;
	// 82EF037C: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EF0380: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0384: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF0388: 994B0030  stb r10, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 82EF038C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0390: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF0394: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82EF0398: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF039C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03A0: 914B0044  stw r10, 0x44(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	// 82EF03A4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03AC: 914B0050  stw r10, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EF03B0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03B8: 914B0054  stw r10, 0x54(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EF03BC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03C4: 994B0468  stb r10, 0x468(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1128 as u32), ctx.r[10].u8 ) };
	// 82EF03C8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03D0: 994B0469  stb r10, 0x469(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1129 as u32), ctx.r[10].u8 ) };
	// 82EF03D4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03DC: 914B046C  stw r10, 0x46c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1132 as u32), ctx.r[10].u32 ) };
	// 82EF03E0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03E8: 914B0474  stw r10, 0x474(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1140 as u32), ctx.r[10].u32 ) };
	// 82EF03EC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF03F4: 914B0478  stw r10, 0x478(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1144 as u32), ctx.r[10].u32 ) };
	// 82EF03F8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF03FC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF0400: 994B0488  stb r10, 0x488(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1160 as u32), ctx.r[10].u8 ) };
	// 82EF0404: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0408: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF040C: 994B0489  stb r10, 0x489(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1161 as u32), ctx.r[10].u8 ) };
	// 82EF0410: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0414: 394000FE  li r10, 0xfe
	ctx.r[10].s64 = 254;
	// 82EF0418: 914B0494  stw r10, 0x494(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1172 as u32), ctx.r[10].u32 ) };
	// 82EF041C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0420: 386B0498  addi r3, r11, 0x498
	ctx.r[3].s64 = ctx.r[11].s64 + 1176;
	// 82EF0424: 48201E45  bl 0x830f2268
	ctx.lr = 0x82EF0428;
	sub_830F2268(ctx, base);
	// 82EF0428: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF042C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF0430: 994B04DC  stb r10, 0x4dc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1244 as u32), ctx.r[10].u8 ) };
	// 82EF0434: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0438: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF043C: 994B04DD  stb r10, 0x4dd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1245 as u32), ctx.r[10].u8 ) };
	// 82EF0440: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0444: 386B04E0  addi r3, r11, 0x4e0
	ctx.r[3].s64 = ctx.r[11].s64 + 1248;
	// 82EF0448: 482014E1  bl 0x830f1928
	ctx.lr = 0x82EF044C;
	sub_830F1928(ctx, base);
	// 82EF044C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0450: 386B04E8  addi r3, r11, 0x4e8
	ctx.r[3].s64 = ctx.r[11].s64 + 1256;
	// 82EF0454: 482014D5  bl 0x830f1928
	ctx.lr = 0x82EF0458;
	sub_830F1928(ctx, base);
	// 82EF0458: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF045C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF0460: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF0464: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0470 size=68
    let mut pc: u32 = 0x82EF0470;
    'dispatch: loop {
        match pc {
            0x82EF0470 => {
    //   block [0x82EF0470..0x82EF04A0)
	// 82EF0470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF0474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0478: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF047C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF0480: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF0484: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0488: 48000031  bl 0x82ef04b8
	ctx.lr = 0x82EF048C;
	sub_82EF04B8(ctx, base);
	// 82EF048C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF0490: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0494: 4182000C  beq 0x82ef04a0
	if ctx.cr[0].eq {
	pc = 0x82EF04A0; continue 'dispatch;
	}
	// 82EF0498: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF049C: 4800522D  bl 0x82ef56c8
	ctx.lr = 0x82EF04A0;
	sub_82EF56C8(ctx, base);
	pc = 0x82EF04A0; continue 'dispatch;
            }
            0x82EF04A0 => {
    //   block [0x82EF04A0..0x82EF04B4)
	// 82EF04A0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF04A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF04A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF04AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF04B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF04B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF04B8 size=108
    let mut pc: u32 = 0x82EF04B8;
    'dispatch: loop {
        match pc {
            0x82EF04B8 => {
    //   block [0x82EF04B8..0x82EF0524)
	// 82EF04B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF04BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF04C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF04C4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF04C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF04CC: 396BC600  addi r11, r11, -0x3a00
	ctx.r[11].s64 = ctx.r[11].s64 + -14848;
	// 82EF04D0: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF04D4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EF04D8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF04DC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EF04E0: 394AC5F8  addi r10, r10, -0x3a08
	ctx.r[10].s64 = ctx.r[10].s64 + -14856;
	// 82EF04E4: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EF04E8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF04EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF04F0: 914B046C  stw r10, 0x46c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1132 as u32), ctx.r[10].u32 ) };
	// 82EF04F4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF04F8: 386B04E8  addi r3, r11, 0x4e8
	ctx.r[3].s64 = ctx.r[11].s64 + 1256;
	// 82EF04FC: 482014B5  bl 0x830f19b0
	ctx.lr = 0x82EF0500;
	sub_830F19B0(ctx, base);
	// 82EF0500: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0504: 386B04E0  addi r3, r11, 0x4e0
	ctx.r[3].s64 = ctx.r[11].s64 + 1248;
	// 82EF0508: 482014A9  bl 0x830f19b0
	ctx.lr = 0x82EF050C;
	sub_830F19B0(ctx, base);
	// 82EF050C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF0510: 480FE191  bl 0x82fee6a0
	ctx.lr = 0x82EF0514;
	sub_82FEE6A0(ctx, base);
	// 82EF0514: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF0518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF051C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF0528 size=1648
    let mut pc: u32 = 0x82EF0528;
    'dispatch: loop {
        match pc {
            0x82EF0528 => {
    //   block [0x82EF0528..0x82EF05B4)
	// 82EF0528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF052C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0530: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF0534: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF0538: 9421FA70  stwu r1, -0x590(r1)
	ea = ctx.r[1].u32.wrapping_add(-1424 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF053C: 906105A4  stw r3, 0x5a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1444 as u32), ctx.r[3].u32 ) };
	// 82EF0540: 908105AC  stw r4, 0x5ac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1452 as u32), ctx.r[4].u32 ) };
	// 82EF0544: 90A105B4  stw r5, 0x5b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1460 as u32), ctx.r[5].u32 ) };
	// 82EF0548: 90C105BC  stw r6, 0x5bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1468 as u32), ctx.r[6].u32 ) };
	// 82EF054C: 90E105C4  stw r7, 0x5c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1476 as u32), ctx.r[7].u32 ) };
	// 82EF0550: 910105CC  stw r8, 0x5cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1484 as u32), ctx.r[8].u32 ) };
	// 82EF0554: 912105D4  stw r9, 0x5d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1492 as u32), ctx.r[9].u32 ) };
	// 82EF0558: 914105DC  stw r10, 0x5dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1500 as u32), ctx.r[10].u32 ) };
	// 82EF055C: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0560: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF0564: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0568: 419A004C  beq cr6, 0x82ef05b4
	if ctx.cr[6].eq {
	pc = 0x82EF05B4; continue 'dispatch;
	}
	// 82EF056C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0570: 896B8F7F  lbz r11, -0x7081(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28801 as u32) ) } as u64;
	// 82EF0574: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF0578: 4082003C  bne 0x82ef05b4
	if !ctx.cr[0].eq {
	pc = 0x82EF05B4; continue 'dispatch;
	}
	// 82EF057C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0580: 3BEB8F7F  addi r31, r11, -0x7081
	ctx.r[31].s64 = ctx.r[11].s64 + -28801;
	// 82EF0584: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0588: 38CBC6D4  addi r6, r11, -0x392c
	ctx.r[6].s64 = ctx.r[11].s64 + -14636;
	// 82EF058C: 38A000D2  li r5, 0xd2
	ctx.r[5].s64 = 210;
	// 82EF0590: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0594: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF0598: 386104D8  addi r3, r1, 0x4d8
	ctx.r[3].s64 = ctx.r[1].s64 + 1240;
	// 82EF059C: 4BFFABCD  bl 0x82eeb168
	ctx.lr = 0x82EF05A0;
	sub_82EEB168(ctx, base);
	// 82EF05A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF05A4: 48201815  bl 0x830f1db8
	ctx.lr = 0x82EF05A8;
	sub_830F1DB8(ctx, base);
	// 82EF05A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF05AC: 40820008  bne 0x82ef05b4
	if !ctx.cr[0].eq {
	pc = 0x82EF05B4; continue 'dispatch;
	}
	// 82EF05B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF05B4; continue 'dispatch;
            }
            0x82EF05B4 => {
    //   block [0x82EF05B4..0x82EF0608)
	// 82EF05B4: 816105AC  lwz r11, 0x5ac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1452 as u32) ) } as u64;
	// 82EF05B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF05BC: 409A004C  bne cr6, 0x82ef0608
	if !ctx.cr[6].eq {
	pc = 0x82EF0608; continue 'dispatch;
	}
	// 82EF05C0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF05C4: 896B8F7E  lbz r11, -0x7082(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28802 as u32) ) } as u64;
	// 82EF05C8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF05CC: 4082003C  bne 0x82ef0608
	if !ctx.cr[0].eq {
	pc = 0x82EF0608; continue 'dispatch;
	}
	// 82EF05D0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF05D4: 3BEB8F7E  addi r31, r11, -0x7082
	ctx.r[31].s64 = ctx.r[11].s64 + -28802;
	// 82EF05D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF05DC: 38CBC790  addi r6, r11, -0x3870
	ctx.r[6].s64 = ctx.r[11].s64 + -14448;
	// 82EF05E0: 38A000D3  li r5, 0xd3
	ctx.r[5].s64 = 211;
	// 82EF05E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF05E8: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF05EC: 386104E8  addi r3, r1, 0x4e8
	ctx.r[3].s64 = ctx.r[1].s64 + 1256;
	// 82EF05F0: 4BFFAB79  bl 0x82eeb168
	ctx.lr = 0x82EF05F4;
	sub_82EEB168(ctx, base);
	// 82EF05F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF05F8: 482017C1  bl 0x830f1db8
	ctx.lr = 0x82EF05FC;
	sub_830F1DB8(ctx, base);
	// 82EF05FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0600: 40820008  bne 0x82ef0608
	if !ctx.cr[0].eq {
	pc = 0x82EF0608; continue 'dispatch;
	}
	// 82EF0604: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF0608; continue 'dispatch;
            }
            0x82EF0608 => {
    //   block [0x82EF0608..0x82EF065C)
	// 82EF0608: 816105B4  lwz r11, 0x5b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1460 as u32) ) } as u64;
	// 82EF060C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0610: 409A004C  bne cr6, 0x82ef065c
	if !ctx.cr[6].eq {
	pc = 0x82EF065C; continue 'dispatch;
	}
	// 82EF0614: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0618: 896B8F7D  lbz r11, -0x7083(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28803 as u32) ) } as u64;
	// 82EF061C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF0620: 4082003C  bne 0x82ef065c
	if !ctx.cr[0].eq {
	pc = 0x82EF065C; continue 'dispatch;
	}
	// 82EF0624: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0628: 3BEB8F7D  addi r31, r11, -0x7083
	ctx.r[31].s64 = ctx.r[11].s64 + -28803;
	// 82EF062C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0630: 38CBC6B8  addi r6, r11, -0x3948
	ctx.r[6].s64 = ctx.r[11].s64 + -14664;
	// 82EF0634: 38A000D4  li r5, 0xd4
	ctx.r[5].s64 = 212;
	// 82EF0638: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF063C: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF0640: 386104F8  addi r3, r1, 0x4f8
	ctx.r[3].s64 = ctx.r[1].s64 + 1272;
	// 82EF0644: 4BFFAB25  bl 0x82eeb168
	ctx.lr = 0x82EF0648;
	sub_82EEB168(ctx, base);
	// 82EF0648: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF064C: 4820176D  bl 0x830f1db8
	ctx.lr = 0x82EF0650;
	sub_830F1DB8(ctx, base);
	// 82EF0650: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0654: 40820008  bne 0x82ef065c
	if !ctx.cr[0].eq {
	pc = 0x82EF065C; continue 'dispatch;
	}
	// 82EF0658: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF065C; continue 'dispatch;
            }
            0x82EF065C => {
    //   block [0x82EF065C..0x82EF06B0)
	// 82EF065C: 816105BC  lwz r11, 0x5bc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1468 as u32) ) } as u64;
	// 82EF0660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0664: 409A004C  bne cr6, 0x82ef06b0
	if !ctx.cr[6].eq {
	pc = 0x82EF06B0; continue 'dispatch;
	}
	// 82EF0668: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF066C: 896B8F7C  lbz r11, -0x7084(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28804 as u32) ) } as u64;
	// 82EF0670: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF0674: 4082003C  bne 0x82ef06b0
	if !ctx.cr[0].eq {
	pc = 0x82EF06B0; continue 'dispatch;
	}
	// 82EF0678: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF067C: 3BEB8F7C  addi r31, r11, -0x7084
	ctx.r[31].s64 = ctx.r[11].s64 + -28804;
	// 82EF0680: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0684: 38CBC6A4  addi r6, r11, -0x395c
	ctx.r[6].s64 = ctx.r[11].s64 + -14684;
	// 82EF0688: 38A000D5  li r5, 0xd5
	ctx.r[5].s64 = 213;
	// 82EF068C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0690: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF0694: 38610508  addi r3, r1, 0x508
	ctx.r[3].s64 = ctx.r[1].s64 + 1288;
	// 82EF0698: 4BFFAAD1  bl 0x82eeb168
	ctx.lr = 0x82EF069C;
	sub_82EEB168(ctx, base);
	// 82EF069C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF06A0: 48201719  bl 0x830f1db8
	ctx.lr = 0x82EF06A4;
	sub_830F1DB8(ctx, base);
	// 82EF06A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF06A8: 40820008  bne 0x82ef06b0
	if !ctx.cr[0].eq {
	pc = 0x82EF06B0; continue 'dispatch;
	}
	// 82EF06AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF06B0; continue 'dispatch;
            }
            0x82EF06B0 => {
    //   block [0x82EF06B0..0x82EF0704)
	// 82EF06B0: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EF06B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF06B8: 409A004C  bne cr6, 0x82ef0704
	if !ctx.cr[6].eq {
	pc = 0x82EF0704; continue 'dispatch;
	}
	// 82EF06BC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF06C0: 896B8F7B  lbz r11, -0x7085(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28805 as u32) ) } as u64;
	// 82EF06C4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF06C8: 4082003C  bne 0x82ef0704
	if !ctx.cr[0].eq {
	pc = 0x82EF0704; continue 'dispatch;
	}
	// 82EF06CC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF06D0: 3BEB8F7B  addi r31, r11, -0x7085
	ctx.r[31].s64 = ctx.r[11].s64 + -28805;
	// 82EF06D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF06D8: 38CBC77C  addi r6, r11, -0x3884
	ctx.r[6].s64 = ctx.r[11].s64 + -14468;
	// 82EF06DC: 38A000D6  li r5, 0xd6
	ctx.r[5].s64 = 214;
	// 82EF06E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF06E4: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF06E8: 38610518  addi r3, r1, 0x518
	ctx.r[3].s64 = ctx.r[1].s64 + 1304;
	// 82EF06EC: 4BFFAA7D  bl 0x82eeb168
	ctx.lr = 0x82EF06F0;
	sub_82EEB168(ctx, base);
	// 82EF06F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF06F4: 482016C5  bl 0x830f1db8
	ctx.lr = 0x82EF06F8;
	sub_830F1DB8(ctx, base);
	// 82EF06F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF06FC: 40820008  bne 0x82ef0704
	if !ctx.cr[0].eq {
	pc = 0x82EF0704; continue 'dispatch;
	}
	// 82EF0700: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF0704; continue 'dispatch;
            }
            0x82EF0704 => {
    //   block [0x82EF0704..0x82EF0758)
	// 82EF0704: 816105C4  lwz r11, 0x5c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1476 as u32) ) } as u64;
	// 82EF0708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF070C: 409A004C  bne cr6, 0x82ef0758
	if !ctx.cr[6].eq {
	pc = 0x82EF0758; continue 'dispatch;
	}
	// 82EF0710: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0714: 896B8F7A  lbz r11, -0x7086(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28806 as u32) ) } as u64;
	// 82EF0718: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF071C: 4082003C  bne 0x82ef0758
	if !ctx.cr[0].eq {
	pc = 0x82EF0758; continue 'dispatch;
	}
	// 82EF0720: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0724: 3BEB8F7A  addi r31, r11, -0x7086
	ctx.r[31].s64 = ctx.r[11].s64 + -28806;
	// 82EF0728: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF072C: 38CBC690  addi r6, r11, -0x3970
	ctx.r[6].s64 = ctx.r[11].s64 + -14704;
	// 82EF0730: 38A000D7  li r5, 0xd7
	ctx.r[5].s64 = 215;
	// 82EF0734: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0738: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF073C: 38610528  addi r3, r1, 0x528
	ctx.r[3].s64 = ctx.r[1].s64 + 1320;
	// 82EF0740: 4BFFAA29  bl 0x82eeb168
	ctx.lr = 0x82EF0744;
	sub_82EEB168(ctx, base);
	// 82EF0744: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF0748: 48201671  bl 0x830f1db8
	ctx.lr = 0x82EF074C;
	sub_830F1DB8(ctx, base);
	// 82EF074C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0750: 40820008  bne 0x82ef0758
	if !ctx.cr[0].eq {
	pc = 0x82EF0758; continue 'dispatch;
	}
	// 82EF0754: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF0758; continue 'dispatch;
            }
            0x82EF0758 => {
    //   block [0x82EF0758..0x82EF07AC)
	// 82EF0758: 816105CC  lwz r11, 0x5cc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1484 as u32) ) } as u64;
	// 82EF075C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0760: 409A004C  bne cr6, 0x82ef07ac
	if !ctx.cr[6].eq {
	pc = 0x82EF07AC; continue 'dispatch;
	}
	// 82EF0764: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0768: 896B8F79  lbz r11, -0x7087(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28807 as u32) ) } as u64;
	// 82EF076C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF0770: 4082003C  bne 0x82ef07ac
	if !ctx.cr[0].eq {
	pc = 0x82EF07AC; continue 'dispatch;
	}
	// 82EF0774: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0778: 3BEB8F79  addi r31, r11, -0x7087
	ctx.r[31].s64 = ctx.r[11].s64 + -28807;
	// 82EF077C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0780: 38CBC680  addi r6, r11, -0x3980
	ctx.r[6].s64 = ctx.r[11].s64 + -14720;
	// 82EF0784: 38A000D8  li r5, 0xd8
	ctx.r[5].s64 = 216;
	// 82EF0788: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF078C: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF0790: 38610538  addi r3, r1, 0x538
	ctx.r[3].s64 = ctx.r[1].s64 + 1336;
	// 82EF0794: 4BFFA9D5  bl 0x82eeb168
	ctx.lr = 0x82EF0798;
	sub_82EEB168(ctx, base);
	// 82EF0798: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF079C: 4820161D  bl 0x830f1db8
	ctx.lr = 0x82EF07A0;
	sub_830F1DB8(ctx, base);
	// 82EF07A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF07A4: 40820008  bne 0x82ef07ac
	if !ctx.cr[0].eq {
	pc = 0x82EF07AC; continue 'dispatch;
	}
	// 82EF07A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF07AC; continue 'dispatch;
            }
            0x82EF07AC => {
    //   block [0x82EF07AC..0x82EF07FC)
	// 82EF07AC: 808105D4  lwz r4, 0x5d4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EF07B0: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF07B4: 386B0260  addi r3, r11, 0x260
	ctx.r[3].s64 = ctx.r[11].s64 + 608;
	// 82EF07B8: 48200B79  bl 0x830f1330
	ctx.lr = 0x82EF07BC;
	sub_830F1330(ctx, base);
	// 82EF07BC: 808105DC  lwz r4, 0x5dc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1500 as u32) ) } as u64;
	// 82EF07C0: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF07C4: 386B0364  addi r3, r11, 0x364
	ctx.r[3].s64 = ctx.r[11].s64 + 868;
	// 82EF07C8: 48200B69  bl 0x830f1330
	ctx.lr = 0x82EF07CC;
	sub_830F1330(ctx, base);
	// 82EF07CC: 816105AC  lwz r11, 0x5ac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1452 as u32) ) } as u64;
	// 82EF07D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF07D4: 419A0028  beq cr6, 0x82ef07fc
	if ctx.cr[6].eq {
	pc = 0x82EF07FC; continue 'dispatch;
	}
	// 82EF07D8: 816105B4  lwz r11, 0x5b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1460 as u32) ) } as u64;
	// 82EF07DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF07E0: 419A001C  beq cr6, 0x82ef07fc
	if ctx.cr[6].eq {
	pc = 0x82EF07FC; continue 'dispatch;
	}
	// 82EF07E4: 816105BC  lwz r11, 0x5bc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1468 as u32) ) } as u64;
	// 82EF07E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF07EC: 419A0010  beq cr6, 0x82ef07fc
	if ctx.cr[6].eq {
	pc = 0x82EF07FC; continue 'dispatch;
	}
	// 82EF07F0: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EF07F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF07F8: 409A0010  bne cr6, 0x82ef0808
	if !ctx.cr[6].eq {
	pc = 0x82EF0808; continue 'dispatch;
	}
	pc = 0x82EF07FC; continue 'dispatch;
            }
            0x82EF07FC => {
    //   block [0x82EF07FC..0x82EF0808)
	// 82EF07FC: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EF0800: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EF0804: 4800037C  b 0x82ef0b80
	pc = 0x82EF0B80; continue 'dispatch;
            }
            0x82EF0808 => {
    //   block [0x82EF0808..0x82EF08B4)
	// 82EF0808: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF080C: 814105BC  lwz r10, 0x5bc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1468 as u32) ) } as u64;
	// 82EF0810: 914B046C  stw r10, 0x46c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1132 as u32), ctx.r[10].u32 ) };
	// 82EF0814: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0818: 814105C4  lwz r10, 0x5c4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1476 as u32) ) } as u64;
	// 82EF081C: 914B0480  stw r10, 0x480(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1152 as u32), ctx.r[10].u32 ) };
	// 82EF0820: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0824: 814105CC  lwz r10, 0x5cc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1484 as u32) ) } as u64;
	// 82EF0828: 914B0484  stw r10, 0x484(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1156 as u32), ctx.r[10].u32 ) };
	// 82EF082C: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0830: 814105EC  lwz r10, 0x5ec(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1516 as u32) ) } as u64;
	// 82EF0834: 914B04D8  stw r10, 0x4d8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1240 as u32), ctx.r[10].u32 ) };
	// 82EF0838: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF083C: 814105F4  lwz r10, 0x5f4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1524 as u32) ) } as u64;
	// 82EF0840: 914B0470  stw r10, 0x470(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1136 as u32), ctx.r[10].u32 ) };
	// 82EF0844: 80E105E4  lwz r7, 0x5e4(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1508 as u32) ) } as u64;
	// 82EF0848: 80C105D4  lwz r6, 0x5d4(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EF084C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0850: 38ABC37C  addi r5, r11, -0x3c84
	ctx.r[5].s64 = ctx.r[11].s64 + -15492;
	// 82EF0854: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF0858: 386102D0  addi r3, r1, 0x2d0
	ctx.r[3].s64 = ctx.r[1].s64 + 720;
	// 82EF085C: 4BFFA98D  bl 0x82eeb1e8
	ctx.lr = 0x82EF0860;
	sub_82EEB1E8(ctx, base);
	// 82EF0860: 388102D0  addi r4, r1, 0x2d0
	ctx.r[4].s64 = ctx.r[1].s64 + 720;
	// 82EF0864: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0868: 814105A4  lwz r10, 0x5a4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF086C: 386A04E0  addi r3, r10, 0x4e0
	ctx.r[3].s64 = ctx.r[10].s64 + 1248;
	// 82EF0870: 816B04E0  lwz r11, 0x4e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1248 as u32) ) } as u64;
	// 82EF0874: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF0878: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF087C: 4E800421  bctrl
	ctx.lr = 0x82EF0880;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0880: 9061015C  stw r3, 0x15c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), ctx.r[3].u32 ) };
	// 82EF0884: 8161015C  lwz r11, 0x15c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 82EF0888: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF088C: 41980028  blt cr6, 0x82ef08b4
	if ctx.cr[6].lt {
	pc = 0x82EF08B4; continue 'dispatch;
	}
	// 82EF0890: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0894: 814105A4  lwz r10, 0x5a4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0898: 386A04E0  addi r3, r10, 0x4e0
	ctx.r[3].s64 = ctx.r[10].s64 + 1248;
	// 82EF089C: 816B04E0  lwz r11, 0x4e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1248 as u32) ) } as u64;
	// 82EF08A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF08A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF08A8: 4E800421  bctrl
	ctx.lr = 0x82EF08AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF08AC: 90610570  stw r3, 0x570(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1392 as u32), ctx.r[3].u32 ) };
	// 82EF08B0: 4800000C  b 0x82ef08bc
	pc = 0x82EF08BC; continue 'dispatch;
            }
            0x82EF08B4 => {
    //   block [0x82EF08B4..0x82EF08BC)
	// 82EF08B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF08B8: 91610570  stw r11, 0x570(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1392 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF08BC; continue 'dispatch;
            }
            0x82EF08BC => {
    //   block [0x82EF08BC..0x82EF0968)
	// 82EF08BC: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF08C0: 81410570  lwz r10, 0x570(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1392 as u32) ) } as u64;
	// 82EF08C4: 914B0474  stw r10, 0x474(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1140 as u32), ctx.r[10].u32 ) };
	// 82EF08C8: 80C105D4  lwz r6, 0x5d4(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EF08CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF08D0: 38ABC3B4  addi r5, r11, -0x3c4c
	ctx.r[5].s64 = ctx.r[11].s64 + -15436;
	// 82EF08D4: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF08D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF08DC: 4BFFA76D  bl 0x82eeb048
	ctx.lr = 0x82EF08E0;
	sub_82EEB048(ctx, base);
	// 82EF08E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF08E4: 996101C0  stb r11, 0x1c0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[11].u8 ) };
	// 82EF08E8: 38A00103  li r5, 0x103
	ctx.r[5].s64 = 259;
	// 82EF08EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF08F0: 386101C1  addi r3, r1, 0x1c1
	ctx.r[3].s64 = ctx.r[1].s64 + 449;
	// 82EF08F4: 4BDB90BD  bl 0x82ca99b0
	ctx.lr = 0x82EF08F8;
	sub_82CA99B0(ctx, base);
	// 82EF08F8: 808105D4  lwz r4, 0x5d4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EF08FC: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 82EF0900: 4BFFF709  bl 0x82ef0008
	ctx.lr = 0x82EF0904;
	sub_82EF0008(ctx, base);
	// 82EF0904: 39610544  addi r11, r1, 0x544
	ctx.r[11].s64 = ctx.r[1].s64 + 1348;
	// 82EF0908: 91610548  stw r11, 0x548(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1352 as u32), ctx.r[11].u32 ) };
	// 82EF090C: 80610548  lwz r3, 0x548(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1352 as u32) ) } as u64;
	// 82EF0910: 4BFFCB89  bl 0x82eed498
	ctx.lr = 0x82EF0914;
	sub_82EED498(ctx, base);
	// 82EF0914: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF0918: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82EF091C: 4BFFC905  bl 0x82eed220
	ctx.lr = 0x82EF0920;
	sub_82EED220(ctx, base);
	// 82EF0920: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0924: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EF0928: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82EF092C: 4BFFC985  bl 0x82eed2b0
	ctx.lr = 0x82EF0930;
	sub_82EED2B0(ctx, base);
	// 82EF0930: 388101C0  addi r4, r1, 0x1c0
	ctx.r[4].s64 = ctx.r[1].s64 + 448;
	// 82EF0934: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82EF0938: 4BFFF5E9  bl 0x82eeff20
	ctx.lr = 0x82EF093C;
	sub_82EEFF20(ctx, base);
	// 82EF093C: 90610158  stw r3, 0x158(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.r[3].u32 ) };
	// 82EF0940: 81610158  lwz r11, 0x158(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(344 as u32) ) } as u64;
	// 82EF0944: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0948: 40980020  bge cr6, 0x82ef0968
	if !ctx.cr[6].lt {
	pc = 0x82EF0968; continue 'dispatch;
	}
	// 82EF094C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EF0950: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EF0954: 9161054C  stw r11, 0x54c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1356 as u32), ctx.r[11].u32 ) };
	// 82EF0958: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82EF095C: 4BFFC91D  bl 0x82eed278
	ctx.lr = 0x82EF0960;
	sub_82EED278(ctx, base);
	// 82EF0960: 8061054C  lwz r3, 0x54c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82EF0964: 4800021C  b 0x82ef0b80
	pc = 0x82EF0B80; continue 'dispatch;
            }
            0x82EF0968 => {
    //   block [0x82EF0968..0x82EF0A44)
	// 82EF0968: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82EF096C: 4BFFCAFD  bl 0x82eed468
	ctx.lr = 0x82EF0970;
	sub_82EED468(ctx, base);
	// 82EF0970: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF0974: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0978: 814105A4  lwz r10, 0x5a4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF097C: 386A04E8  addi r3, r10, 0x4e8
	ctx.r[3].s64 = ctx.r[10].s64 + 1256;
	// 82EF0980: 816B04E8  lwz r11, 0x4e8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1256 as u32) ) } as u64;
	// 82EF0984: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF0988: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF098C: 4E800421  bctrl
	ctx.lr = 0x82EF0990;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0990: 9061015C  stw r3, 0x15c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), ctx.r[3].u32 ) };
	// 82EF0994: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0998: 814105A4  lwz r10, 0x5a4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF099C: 386A04E8  addi r3, r10, 0x4e8
	ctx.r[3].s64 = ctx.r[10].s64 + 1256;
	// 82EF09A0: 816B04E8  lwz r11, 0x4e8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1256 as u32) ) } as u64;
	// 82EF09A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF09A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF09AC: 4E800421  bctrl
	ctx.lr = 0x82EF09B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF09B0: 90610154  stw r3, 0x154(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), ctx.r[3].u32 ) };
	// 82EF09B4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF09B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF09BC: 388BC668  addi r4, r11, -0x3998
	ctx.r[4].s64 = ctx.r[11].s64 + -14744;
	// 82EF09C0: 81610154  lwz r11, 0x154(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EF09C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF09C8: 80610154  lwz r3, 0x154(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EF09CC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF09D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF09D4: 4E800421  bctrl
	ctx.lr = 0x82EF09D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF09D8: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF09DC: 906B0478  stw r3, 0x478(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1144 as u32), ctx.r[3].u32 ) };
	// 82EF09E0: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF09E4: 816B0478  lwz r11, 0x478(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1144 as u32) ) } as u64;
	// 82EF09E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF09EC: 409A0058  bne cr6, 0x82ef0a44
	if !ctx.cr[6].eq {
	pc = 0x82EF0A44; continue 'dispatch;
	}
	// 82EF09F0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF09F4: 896B8F78  lbz r11, -0x7088(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28808 as u32) ) } as u64;
	// 82EF09F8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF09FC: 40820048  bne 0x82ef0a44
	if !ctx.cr[0].eq {
	pc = 0x82EF0A44; continue 'dispatch;
	}
	// 82EF0A00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0A04: 3BEBC750  addi r31, r11, -0x38b0
	ctx.r[31].s64 = ctx.r[11].s64 + -14512;
	// 82EF0A08: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0A0C: 3BCB8F78  addi r30, r11, -0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + -28808;
	// 82EF0A10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0A14: 38CBC73C  addi r6, r11, -0x38c4
	ctx.r[6].s64 = ctx.r[11].s64 + -14532;
	// 82EF0A18: 38A00107  li r5, 0x107
	ctx.r[5].s64 = 263;
	// 82EF0A1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0A20: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF0A24: 38610550  addi r3, r1, 0x550
	ctx.r[3].s64 = ctx.r[1].s64 + 1360;
	// 82EF0A28: 4BFFA741  bl 0x82eeb168
	ctx.lr = 0x82EF0A2C;
	sub_82EEB168(ctx, base);
	// 82EF0A2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF0A30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF0A34: 4820145D  bl 0x830f1e90
	ctx.lr = 0x82EF0A38;
	sub_830F1E90(ctx, base);
	// 82EF0A38: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0A3C: 40820008  bne 0x82ef0a44
	if !ctx.cr[0].eq {
	pc = 0x82EF0A44; continue 'dispatch;
	}
	// 82EF0A40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
            }
            0x82EF0A44 => {
    //   block [0x82EF0A44..0x82EF0AD4)
	// 82EF0A44: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF0A48: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0A4C: 388BC654  addi r4, r11, -0x39ac
	ctx.r[4].s64 = ctx.r[11].s64 + -14764;
	// 82EF0A50: 81610154  lwz r11, 0x154(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EF0A54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0A58: 80610154  lwz r3, 0x154(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EF0A5C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF0A60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0A64: 4E800421  bctrl
	ctx.lr = 0x82EF0A68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0A68: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0A6C: 906B047C  stw r3, 0x47c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1148 as u32), ctx.r[3].u32 ) };
	// 82EF0A70: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0A74: 816B047C  lwz r11, 0x47c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1148 as u32) ) } as u64;
	// 82EF0A78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0A7C: 409A0058  bne cr6, 0x82ef0ad4
	if !ctx.cr[6].eq {
	pc = 0x82EF0AD4; continue 'dispatch;
	}
	// 82EF0A80: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0A84: 896B8F77  lbz r11, -0x7089(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28809 as u32) ) } as u64;
	// 82EF0A88: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF0A8C: 40820048  bne 0x82ef0ad4
	if !ctx.cr[0].eq {
	pc = 0x82EF0AD4; continue 'dispatch;
	}
	// 82EF0A90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0A94: 3BEBC710  addi r31, r11, -0x38f0
	ctx.r[31].s64 = ctx.r[11].s64 + -14576;
	// 82EF0A98: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF0A9C: 3BCB8F77  addi r30, r11, -0x7089
	ctx.r[30].s64 = ctx.r[11].s64 + -28809;
	// 82EF0AA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0AA4: 38CBC6F8  addi r6, r11, -0x3908
	ctx.r[6].s64 = ctx.r[11].s64 + -14600;
	// 82EF0AA8: 38A0010A  li r5, 0x10a
	ctx.r[5].s64 = 266;
	// 82EF0AAC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0AB0: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF0AB4: 38610560  addi r3, r1, 0x560
	ctx.r[3].s64 = ctx.r[1].s64 + 1376;
	// 82EF0AB8: 4BFFA6B1  bl 0x82eeb168
	ctx.lr = 0x82EF0ABC;
	sub_82EEB168(ctx, base);
	// 82EF0ABC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF0AC0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF0AC4: 482013CD  bl 0x830f1e90
	ctx.lr = 0x82EF0AC8;
	sub_830F1E90(ctx, base);
	// 82EF0AC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0ACC: 40820008  bne 0x82ef0ad4
	if !ctx.cr[0].eq {
	pc = 0x82EF0AD4; continue 'dispatch;
	}
	// 82EF0AD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
            }
            0x82EF0AD4 => {
    //   block [0x82EF0AD4..0x82EF0B18)
	// 82EF0AD4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0AD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0ADC: 388BC640  addi r4, r11, -0x39c0
	ctx.r[4].s64 = ctx.r[11].s64 + -14784;
	// 82EF0AE0: 81610154  lwz r11, 0x154(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EF0AE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0AE8: 80610154  lwz r3, 0x154(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EF0AEC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF0AF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0AF4: 4E800421  bctrl
	ctx.lr = 0x82EF0AF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0AF8: 90610160  stw r3, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[3].u32 ) };
	// 82EF0AFC: 81610160  lwz r11, 0x160(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EF0B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0B04: 419A0014  beq cr6, 0x82ef0b18
	if ctx.cr[6].eq {
	pc = 0x82EF0B18; continue 'dispatch;
	}
	// 82EF0B08: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0B0C: 388B0050  addi r4, r11, 0x50
	ctx.r[4].s64 = ctx.r[11].s64 + 80;
	// 82EF0B10: 80610160  lwz r3, 0x160(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EF0B14: 4BFFA35D  bl 0x82eeae70
	ctx.lr = 0x82EF0B18;
	sub_82EEAE70(ctx, base);
            }
            0x82EF0B18 => {
    //   block [0x82EF0B18..0x82EF0B80)
	// 82EF0B18: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF0B1C: 80A105B4  lwz r5, 0x5b4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1460 as u32) ) } as u64;
	// 82EF0B20: 808105AC  lwz r4, 0x5ac(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1452 as u32) ) } as u64;
	// 82EF0B24: 806105A4  lwz r3, 0x5a4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0B28: 480FDC21  bl 0x82fee748
	ctx.lr = 0x82EF0B2C;
	sub_82FEE748(ctx, base);
	// 82EF0B2C: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0B30: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EF0B34: 914B0044  stw r10, 0x44(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	// 82EF0B38: 4B375579  bl 0x822660b0
	ctx.lr = 0x82EF0B3C;
	sub_822660B0(ctx, base);
	// 82EF0B3C: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0B40: 906B0048  stw r3, 0x48(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[3].u32 ) };
	// 82EF0B44: 816105A4  lwz r11, 0x5a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0B48: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EF0B4C: 994B0468  stb r10, 0x468(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1128 as u32), ctx.r[10].u8 ) };
	// 82EF0B50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0B54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF0B58: C02B0AA0  lfs f1, 0xaa0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2720 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EF0B5C: 806105A4  lwz r3, 0x5a4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0B60: 480FD891  bl 0x82fee3f0
	ctx.lr = 0x82EF0B64;
	sub_82FEE3F0(ctx, base);
	// 82EF0B64: 806105A4  lwz r3, 0x5a4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EF0B68: 48002D91  bl 0x82ef38f8
	ctx.lr = 0x82EF0B6C;
	sub_82EF38F8(ctx, base);
	// 82EF0B6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF0B70: 9161056C  stw r11, 0x56c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1388 as u32), ctx.r[11].u32 ) };
	// 82EF0B74: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82EF0B78: 4BFFC701  bl 0x82eed278
	ctx.lr = 0x82EF0B7C;
	sub_82EED278(ctx, base);
	// 82EF0B7C: 8061056C  lwz r3, 0x56c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1388 as u32) ) } as u64;
	pc = 0x82EF0B80; continue 'dispatch;
            }
            0x82EF0B80 => {
    //   block [0x82EF0B80..0x82EF0B98)
	// 82EF0B80: 38210590  addi r1, r1, 0x590
	ctx.r[1].s64 = ctx.r[1].s64 + 1424;
	// 82EF0B84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF0B88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0B8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF0B90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF0B94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0B98 size=596
    let mut pc: u32 = 0x82EF0B98;
    'dispatch: loop {
        match pc {
            0x82EF0B98 => {
    //   block [0x82EF0B98..0x82EF0BC4)
	// 82EF0B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF0B9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0BA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF0BA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF0BA8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF0BAC: 906100E4  stw r3, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[3].u32 ) };
	// 82EF0BB0: 908100EC  stw r4, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[4].u32 ) };
	// 82EF0BB4: 816100EC  lwz r11, 0xec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82EF0BB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0BBC: 409A0008  bne cr6, 0x82ef0bc4
	if !ctx.cr[6].eq {
	pc = 0x82EF0BC4; continue 'dispatch;
	}
	// 82EF0BC0: 48000214  b 0x82ef0dd4
	pc = 0x82EF0DD4; continue 'dispatch;
            }
            0x82EF0BC4 => {
    //   block [0x82EF0BC4..0x82EF0BEC)
	// 82EF0BC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0BC8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EF0BCC: 388B17CC  addi r4, r11, 0x17cc
	ctx.r[4].s64 = ctx.r[11].s64 + 6092;
	// 82EF0BD0: 816100EC  lwz r11, 0xec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82EF0BD4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0BD8: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82EF0BDC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF0BE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0BE4: 4E800421  bctrl
	ctx.lr = 0x82EF0BE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0BE8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
            }
            0x82EF0BEC => {
    //   block [0x82EF0BEC..0x82EF0C4C)
	// 82EF0BEC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0BF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0BF4: 419A01E0  beq cr6, 0x82ef0dd4
	if ctx.cr[6].eq {
	pc = 0x82EF0DD4; continue 'dispatch;
	}
	// 82EF0BF8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0BFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0C00: 388BC7E4  addi r4, r11, -0x381c
	ctx.r[4].s64 = ctx.r[11].s64 + -14364;
	// 82EF0C04: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0C08: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0C0C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0C10: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF0C14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0C18: 4E800421  bctrl
	ctx.lr = 0x82EF0C1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0C1C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EF0C20: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0C24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0C28: 419A0180  beq cr6, 0x82ef0da8
	if ctx.cr[6].eq {
	pc = 0x82EF0DA8; continue 'dispatch;
	}
	// 82EF0C2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF0C30: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0C34: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0C38: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0C3C: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EF0C40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0C44: 4E800421  bctrl
	ctx.lr = 0x82EF0C48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0C48: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
            }
            0x82EF0C4C => {
    //   block [0x82EF0C4C..0x82EF0D08)
	// 82EF0C4C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0C54: 419A0154  beq cr6, 0x82ef0da8
	if ctx.cr[6].eq {
	pc = 0x82EF0DA8; continue 'dispatch;
	}
	// 82EF0C58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF0C5C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0C60: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0C64: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0C68: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EF0C6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0C70: 4E800421  bctrl
	ctx.lr = 0x82EF0C74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0C74: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82EF0C78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0C7C: 3BEBC7D8  addi r31, r11, -0x3828
	ctx.r[31].s64 = ctx.r[11].s64 + -14376;
	// 82EF0C80: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0C84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0C88: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0C8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF0C90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0C94: 4E800421  bctrl
	ctx.lr = 0x82EF0C98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0C98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF0C9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0CA0: 48003C79  bl 0x82ef4918
	ctx.lr = 0x82EF0CA4;
	sub_82EF4918(ctx, base);
	// 82EF0CA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF0CA8: 41820060  beq 0x82ef0d08
	if ctx.cr[0].eq {
	pc = 0x82EF0D08; continue 'dispatch;
	}
	// 82EF0CAC: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF0CB0: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF0CB4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EF0CB8: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF0CBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EF0CC0: 4B32EE49  bl 0x8221fb08
	ctx.lr = 0x82EF0CC4;
	sub_8221FB08(ctx, base);
	// 82EF0CC4: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0CC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EF0CCC: 48004B45  bl 0x82ef5810
	ctx.lr = 0x82EF0CD0;
	sub_82EF5810(ctx, base);
	// 82EF0CD0: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF0CD4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82EF0CD8: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EF0CDC: 48004B35  bl 0x82ef5810
	ctx.lr = 0x82EF0CE0;
	sub_82EF5810(ctx, base);
	// 82EF0CE0: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 82EF0CE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0CE8: 3BCBC7BC  addi r30, r11, -0x3844
	ctx.r[30].s64 = ctx.r[11].s64 + -14404;
	// 82EF0CEC: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82EF0CF0: 48004C49  bl 0x82ef5938
	ctx.lr = 0x82EF0CF4;
	sub_82EF5938(ctx, base);
	// 82EF0CF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF0CF8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF0CFC: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 82EF0D00: 48004B39  bl 0x82ef5838
	ctx.lr = 0x82EF0D04;
	sub_82EF5838(ctx, base);
	// 82EF0D04: 48000084  b 0x82ef0d88
	pc = 0x82EF0D88; continue 'dispatch;
            }
            0x82EF0D08 => {
    //   block [0x82EF0D08..0x82EF0D88)
	// 82EF0D08: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF0D0C: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF0D10: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82EF0D14: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF0D18: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EF0D1C: 4B32EDED  bl 0x8221fb08
	ctx.lr = 0x82EF0D20;
	sub_8221FB08(ctx, base);
	// 82EF0D20: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0D24: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EF0D28: 48004AE9  bl 0x82ef5810
	ctx.lr = 0x82EF0D2C;
	sub_82EF5810(ctx, base);
	// 82EF0D2C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0D30: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0D34: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0D38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF0D3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0D40: 4E800421  bctrl
	ctx.lr = 0x82EF0D44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0D44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF0D48: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82EF0D4C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EF0D50: 48004AC1  bl 0x82ef5810
	ctx.lr = 0x82EF0D54;
	sub_82EF5810(ctx, base);
	// 82EF0D54: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF0D58: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82EF0D5C: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 82EF0D60: 48004AB1  bl 0x82ef5810
	ctx.lr = 0x82EF0D64;
	sub_82EF5810(ctx, base);
	// 82EF0D64: 3BE10080  addi r31, r1, 0x80
	ctx.r[31].s64 = ctx.r[1].s64 + 128;
	// 82EF0D68: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0D6C: 3BCBC79C  addi r30, r11, -0x3864
	ctx.r[30].s64 = ctx.r[11].s64 + -14436;
	// 82EF0D70: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82EF0D74: 48004BC5  bl 0x82ef5938
	ctx.lr = 0x82EF0D78;
	sub_82EF5938(ctx, base);
	// 82EF0D78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF0D7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF0D80: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82EF0D84: 48004AB5  bl 0x82ef5838
	ctx.lr = 0x82EF0D88;
	sub_82EF5838(ctx, base);
            }
            0x82EF0D88 => {
    //   block [0x82EF0D88..0x82EF0DA8)
	// 82EF0D88: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0D8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0D90: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF0D94: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EF0D98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0D9C: 4E800421  bctrl
	ctx.lr = 0x82EF0DA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0DA0: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EF0DA4: 4BFFFEA8  b 0x82ef0c4c
	pc = 0x82EF0C4C; continue 'dispatch;
            }
            0x82EF0DA8 => {
    //   block [0x82EF0DA8..0x82EF0DD4)
	// 82EF0DA8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0DAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EF0DB0: 388B17CC  addi r4, r11, 0x17cc
	ctx.r[4].s64 = ctx.r[11].s64 + 6092;
	// 82EF0DB4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0DB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0DBC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0DC0: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF0DC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0DC8: 4E800421  bctrl
	ctx.lr = 0x82EF0DCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0DCC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF0DD0: 4BFFFE1C  b 0x82ef0bec
	pc = 0x82EF0BEC; continue 'dispatch;
            }
            0x82EF0DD4 => {
    //   block [0x82EF0DD4..0x82EF0DEC)
	// 82EF0DD4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EF0DD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF0DDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF0DE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF0DE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF0DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF0DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF0DF0 size=2140
    let mut pc: u32 = 0x82EF0DF0;
    'dispatch: loop {
        match pc {
            0x82EF0DF0 => {
    //   block [0x82EF0DF0..0x82EF0E1C)
	// 82EF0DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF0DF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF0DF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF0DFC: 3BE1FBC0  addi r31, r1, -0x440
	ctx.r[31].s64 = ctx.r[1].s64 + -1088;
	// 82EF0E00: 9421FBC0  stwu r1, -0x440(r1)
	ea = ctx.r[1].u32.wrapping_add(-1088 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF0E04: 907F0454  stw r3, 0x454(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1108 as u32), ctx.r[3].u32 ) };
	// 82EF0E08: 909F045C  stw r4, 0x45c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1116 as u32), ctx.r[4].u32 ) };
	// 82EF0E0C: 817F045C  lwz r11, 0x45c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF0E10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0E14: 409A0008  bne cr6, 0x82ef0e1c
	if !ctx.cr[6].eq {
	pc = 0x82EF0E1C; continue 'dispatch;
	}
	// 82EF0E18: 48000820  b 0x82ef1638
	pc = 0x82EF1638; continue 'dispatch;
            }
            0x82EF0E1C => {
    //   block [0x82EF0E1C..0x82EF0E60)
	// 82EF0E1C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0E20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0E24: 388BC898  addi r4, r11, -0x3768
	ctx.r[4].s64 = ctx.r[11].s64 + -14184;
	// 82EF0E28: 817F045C  lwz r11, 0x45c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF0E2C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0E30: 807F045C  lwz r3, 0x45c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF0E34: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF0E38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0E3C: 4E800421  bctrl
	ctx.lr = 0x82EF0E40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0E40: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF0E44: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0E48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0E4C: 409A0014  bne cr6, 0x82ef0e60
	if !ctx.cr[6].eq {
	pc = 0x82EF0E60; continue 'dispatch;
	}
	// 82EF0E50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF0E54: 396B0AF8  addi r11, r11, 0xaf8
	ctx.r[11].s64 = ctx.r[11].s64 + 2808;
	// 82EF0E58: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF0E5C: 4800014C  b 0x82ef0fa8
	pc = 0x82EF0FA8; continue 'dispatch;
            }
            0x82EF0E60 => {
    //   block [0x82EF0E60..0x82EF0FA8)
	// 82EF0E60: 387F0170  addi r3, r31, 0x170
	ctx.r[3].s64 = ctx.r[31].s64 + 368;
	// 82EF0E64: 4800491D  bl 0x82ef5780
	ctx.lr = 0x82EF0E68;
	sub_82EF5780(ctx, base);
	// 82EF0E68: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0E6C: 387F0170  addi r3, r31, 0x170
	ctx.r[3].s64 = ctx.r[31].s64 + 368;
	// 82EF0E70: 480049A1  bl 0x82ef5810
	ctx.lr = 0x82EF0E74;
	sub_82EF5810(ctx, base);
	// 82EF0E74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0E78: 38CBC880  addi r6, r11, -0x3780
	ctx.r[6].s64 = ctx.r[11].s64 + -14208;
	// 82EF0E7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0E80: 38ABC874  addi r5, r11, -0x378c
	ctx.r[5].s64 = ctx.r[11].s64 + -14220;
	// 82EF0E84: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF0E88: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82EF0E8C: 4BFFA1BD  bl 0x82eeb048
	ctx.lr = 0x82EF0E90;
	sub_82EEB048(ctx, base);
	// 82EF0E90: 807F0454  lwz r3, 0x454(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EF0E94: 48004AA5  bl 0x82ef5938
	ctx.lr = 0x82EF0E98;
	sub_82EF5938(ctx, base);
	// 82EF0E98: 907F040C  stw r3, 0x40c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1036 as u32), ctx.r[3].u32 ) };
	// 82EF0E9C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF0EA0: 38BF0170  addi r5, r31, 0x170
	ctx.r[5].s64 = ctx.r[31].s64 + 368;
	// 82EF0EA4: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 82EF0EA8: 807F040C  lwz r3, 0x40c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1036 as u32) ) } as u64;
	// 82EF0EAC: 817F040C  lwz r11, 0x40c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1036 as u32) ) } as u64;
	// 82EF0EB0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0EB4: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF0EB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0EBC: 4E800421  bctrl
	ctx.lr = 0x82EF0EC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0EC0: 817F0454  lwz r11, 0x454(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EF0EC4: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF0EC8: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82EF0ECC: F97F0410  std r11, 0x410(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), ctx.r[11].u64 ) };
	// 82EF0ED0: C81F0410  lfd f0, 0x410(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	// 82EF0ED4: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF0ED8: 387F0170  addi r3, r31, 0x170
	ctx.r[3].s64 = ctx.r[31].s64 + 368;
	// 82EF0EDC: 4800490D  bl 0x82ef57e8
	ctx.lr = 0x82EF0EE0;
	sub_82EF57E8(ctx, base);
	// 82EF0EE0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0EE4: 38CBC640  addi r6, r11, -0x39c0
	ctx.r[6].s64 = ctx.r[11].s64 + -14784;
	// 82EF0EE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0EEC: 38ABC874  addi r5, r11, -0x378c
	ctx.r[5].s64 = ctx.r[11].s64 + -14220;
	// 82EF0EF0: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF0EF4: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82EF0EF8: 4BFFA151  bl 0x82eeb048
	ctx.lr = 0x82EF0EFC;
	sub_82EEB048(ctx, base);
	// 82EF0EFC: 807F0454  lwz r3, 0x454(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EF0F00: 48004A39  bl 0x82ef5938
	ctx.lr = 0x82EF0F04;
	sub_82EF5938(ctx, base);
	// 82EF0F04: 907F0418  stw r3, 0x418(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1048 as u32), ctx.r[3].u32 ) };
	// 82EF0F08: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF0F0C: 38BF0170  addi r5, r31, 0x170
	ctx.r[5].s64 = ctx.r[31].s64 + 368;
	// 82EF0F10: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 82EF0F14: 807F0418  lwz r3, 0x418(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1048 as u32) ) } as u64;
	// 82EF0F18: 817F0418  lwz r11, 0x418(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1048 as u32) ) } as u64;
	// 82EF0F1C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0F20: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF0F24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0F28: 4E800421  bctrl
	ctx.lr = 0x82EF0F2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0F2C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EF0F30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0F34: 38CBC860  addi r6, r11, -0x37a0
	ctx.r[6].s64 = ctx.r[11].s64 + -14240;
	// 82EF0F38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0F3C: 38ABC898  addi r5, r11, -0x3768
	ctx.r[5].s64 = ctx.r[11].s64 + -14184;
	// 82EF0F40: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0F44: 388BC850  addi r4, r11, -0x37b0
	ctx.r[4].s64 = ctx.r[11].s64 + -14256;
	// 82EF0F48: 817F045C  lwz r11, 0x45c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF0F4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0F50: 807F045C  lwz r3, 0x45c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF0F54: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF0F58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0F5C: 4E800421  bctrl
	ctx.lr = 0x82EF0F60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0F60: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EF0F64: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0F68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0F6C: 419A003C  beq cr6, 0x82ef0fa8
	if ctx.cr[6].eq {
	pc = 0x82EF0FA8; continue 'dispatch;
	}
	// 82EF0F70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0F74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0F78: 388BC7D8  addi r4, r11, -0x3828
	ctx.r[4].s64 = ctx.r[11].s64 + -14376;
	// 82EF0F7C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0F80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0F84: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF0F88: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF0F8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0F90: 4E800421  bctrl
	ctx.lr = 0x82EF0F94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0F94: 907F0180  stw r3, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[3].u32 ) };
	// 82EF0F98: 817F0454  lwz r11, 0x454(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EF0F9C: 388B0054  addi r4, r11, 0x54
	ctx.r[4].s64 = ctx.r[11].s64 + 84;
	// 82EF0FA0: 807F0180  lwz r3, 0x180(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EF0FA4: 4BFF9ECD  bl 0x82eeae70
	ctx.lr = 0x82EF0FA8;
	sub_82EEAE70(ctx, base);
            }
            0x82EF0FA8 => {
    //   block [0x82EF0FA8..0x82EF0FD8)
	// 82EF0FA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF0FAC: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 82EF0FB0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0FB4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0FB8: 388BC850  addi r4, r11, -0x37b0
	ctx.r[4].s64 = ctx.r[11].s64 + -14256;
	// 82EF0FBC: 817F045C  lwz r11, 0x45c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF0FC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0FC4: 807F045C  lwz r3, 0x45c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF0FC8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF0FCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF0FD0: 4E800421  bctrl
	ctx.lr = 0x82EF0FD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF0FD4: 907F0188  stw r3, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[3].u32 ) };
            }
            0x82EF0FD8 => {
    //   block [0x82EF0FD8..0x82EF10DC)
	// 82EF0FD8: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF0FDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF0FE0: 419A021C  beq cr6, 0x82ef11fc
	if ctx.cr[6].eq {
	pc = 0x82EF11FC; continue 'dispatch;
	}
	// 82EF0FE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF0FE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF0FEC: 388BC898  addi r4, r11, -0x3768
	ctx.r[4].s64 = ctx.r[11].s64 + -14184;
	// 82EF0FF0: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF0FF4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF0FF8: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF0FFC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF1000: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1004: 4E800421  bctrl
	ctx.lr = 0x82EF1008;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1008: 907F0194  stw r3, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[3].u32 ) };
	// 82EF100C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1010: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1014: 388BC844  addi r4, r11, -0x37bc
	ctx.r[4].s64 = ctx.r[11].s64 + -14268;
	// 82EF1018: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF101C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1020: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF1024: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF1028: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF102C: 4E800421  bctrl
	ctx.lr = 0x82EF1030;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1030: 907F018C  stw r3, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[3].u32 ) };
	// 82EF1034: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1038: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF103C: 388BC7D8  addi r4, r11, -0x3828
	ctx.r[4].s64 = ctx.r[11].s64 + -14376;
	// 82EF1040: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF1044: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1048: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF104C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF1050: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1054: 4E800421  bctrl
	ctx.lr = 0x82EF1058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1058: 907F0190  stw r3, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[3].u32 ) };
	// 82EF105C: 817F018C  lwz r11, 0x18c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EF1060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1064: 419A0160  beq cr6, 0x82ef11c4
	if ctx.cr[6].eq {
	pc = 0x82EF11C4; continue 'dispatch;
	}
	// 82EF1068: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EF106C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1070: 419A0154  beq cr6, 0x82ef11c4
	if ctx.cr[6].eq {
	pc = 0x82EF11C4; continue 'dispatch;
	}
	// 82EF1074: 817F0194  lwz r11, 0x194(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EF1078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF107C: 419A0148  beq cr6, 0x82ef11c4
	if ctx.cr[6].eq {
	pc = 0x82EF11C4; continue 'dispatch;
	}
	// 82EF1080: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF1084: 997F0199  stb r11, 0x199(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(409 as u32), ctx.r[11].u8 ) };
	// 82EF1088: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EF108C: 997F0198  stb r11, 0x198(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u8 ) };
	// 82EF1090: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82EF1094: 480046ED  bl 0x82ef5780
	ctx.lr = 0x82EF1098;
	sub_82EF5780(ctx, base);
	// 82EF1098: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF109C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF10A0: 388BC834  addi r4, r11, -0x37cc
	ctx.r[4].s64 = ctx.r[11].s64 + -14284;
	// 82EF10A4: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EF10A8: 48003871  bl 0x82ef4918
	ctx.lr = 0x82EF10AC;
	sub_82EF4918(ctx, base);
	// 82EF10AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF10B0: 41820030  beq 0x82ef10e0
	if ctx.cr[0].eq {
	pc = 0x82EF10E0; continue 'dispatch;
	}
	// 82EF10B4: 389F01B0  addi r4, r31, 0x1b0
	ctx.r[4].s64 = ctx.r[31].s64 + 432;
	// 82EF10B8: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EF10BC: 4800433D  bl 0x82ef53f8
	ctx.lr = 0x82EF10C0;
	sub_82EF53F8(ctx, base);
	// 82EF10C0: 987F0199  stb r3, 0x199(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(409 as u32), ctx.r[3].u8 ) };
	// 82EF10C4: 897F0199  lbz r11, 0x199(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(409 as u32) ) } as u64;
	// 82EF10C8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF10CC: 41820010  beq 0x82ef10dc
	if ctx.cr[0].eq {
	pc = 0x82EF10DC; continue 'dispatch;
	}
	// 82EF10D0: C83F01B0  lfd f1, 0x1b0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) };
	// 82EF10D4: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82EF10D8: 48004711  bl 0x82ef57e8
	ctx.lr = 0x82EF10DC;
	sub_82EF57E8(ctx, base);
            }
            0x82EF10DC => {
    //   block [0x82EF10DC..0x82EF10E0)
	// 82EF10DC: 48000088  b 0x82ef1164
	pc = 0x82EF1164; continue 'dispatch;
            }
            0x82EF10E0 => {
    //   block [0x82EF10E0..0x82EF1124)
	// 82EF10E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF10E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF10E8: 388BC824  addi r4, r11, -0x37dc
	ctx.r[4].s64 = ctx.r[11].s64 + -14300;
	// 82EF10EC: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EF10F0: 48003829  bl 0x82ef4918
	ctx.lr = 0x82EF10F4;
	sub_82EF4918(ctx, base);
	// 82EF10F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF10F8: 41820030  beq 0x82ef1128
	if ctx.cr[0].eq {
	pc = 0x82EF1128; continue 'dispatch;
	}
	// 82EF10FC: 389F01B8  addi r4, r31, 0x1b8
	ctx.r[4].s64 = ctx.r[31].s64 + 440;
	// 82EF1100: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EF1104: 4BFF9EAD  bl 0x82eeafb0
	ctx.lr = 0x82EF1108;
	sub_82EEAFB0(ctx, base);
	// 82EF1108: 987F0199  stb r3, 0x199(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(409 as u32), ctx.r[3].u8 ) };
	// 82EF110C: 897F0199  lbz r11, 0x199(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(409 as u32) ) } as u64;
	// 82EF1110: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF1114: 41820010  beq 0x82ef1124
	if ctx.cr[0].eq {
	pc = 0x82EF1124; continue 'dispatch;
	}
	// 82EF1118: 889F01B8  lbz r4, 0x1b8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EF111C: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82EF1120: 480046A1  bl 0x82ef57c0
	ctx.lr = 0x82EF1124;
	sub_82EF57C0(ctx, base);
	pc = 0x82EF1124; continue 'dispatch;
            }
            0x82EF1124 => {
    //   block [0x82EF1124..0x82EF1128)
	// 82EF1124: 48000040  b 0x82ef1164
	pc = 0x82EF1164; continue 'dispatch;
            }
            0x82EF1128 => {
    //   block [0x82EF1128..0x82EF115C)
	// 82EF1128: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF112C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1130: 388BC814  addi r4, r11, -0x37ec
	ctx.r[4].s64 = ctx.r[11].s64 + -14316;
	// 82EF1134: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EF1138: 480037E1  bl 0x82ef4918
	ctx.lr = 0x82EF113C;
	sub_82EF4918(ctx, base);
	// 82EF113C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF1140: 4182001C  beq 0x82ef115c
	if ctx.cr[0].eq {
	pc = 0x82EF115C; continue 'dispatch;
	}
	// 82EF1144: 809F0190  lwz r4, 0x190(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EF1148: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82EF114C: 480046C5  bl 0x82ef5810
	ctx.lr = 0x82EF1150;
	sub_82EF5810(ctx, base);
	// 82EF1150: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EF1154: 997F0199  stb r11, 0x199(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(409 as u32), ctx.r[11].u8 ) };
	// 82EF1158: 4800000C  b 0x82ef1164
	pc = 0x82EF1164; continue 'dispatch;
            }
            0x82EF115C => {
    //   block [0x82EF115C..0x82EF1164)
	// 82EF115C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF1160: 997F0198  stb r11, 0x198(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u8 ) };
	pc = 0x82EF1164; continue 'dispatch;
            }
            0x82EF1164 => {
    //   block [0x82EF1164..0x82EF11C4)
	// 82EF1164: 897F0199  lbz r11, 0x199(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(409 as u32) ) } as u64;
	// 82EF1168: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF116C: 41820058  beq 0x82ef11c4
	if ctx.cr[0].eq {
	pc = 0x82EF11C4; continue 'dispatch;
	}
	// 82EF1170: 897F0198  lbz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EF1174: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF1178: 4182004C  beq 0x82ef11c4
	if ctx.cr[0].eq {
	pc = 0x82EF11C4; continue 'dispatch;
	}
	// 82EF117C: 80DF0194  lwz r6, 0x194(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EF1180: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1184: 38ABC874  addi r5, r11, -0x378c
	ctx.r[5].s64 = ctx.r[11].s64 + -14220;
	// 82EF1188: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF118C: 387F01C0  addi r3, r31, 0x1c0
	ctx.r[3].s64 = ctx.r[31].s64 + 448;
	// 82EF1190: 4BFF9EB9  bl 0x82eeb048
	ctx.lr = 0x82EF1194;
	sub_82EEB048(ctx, base);
	// 82EF1194: 807F0454  lwz r3, 0x454(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EF1198: 480047A1  bl 0x82ef5938
	ctx.lr = 0x82EF119C;
	sub_82EF5938(ctx, base);
	// 82EF119C: 907F041C  stw r3, 0x41c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1052 as u32), ctx.r[3].u32 ) };
	// 82EF11A0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF11A4: 38BF01A0  addi r5, r31, 0x1a0
	ctx.r[5].s64 = ctx.r[31].s64 + 416;
	// 82EF11A8: 389F01C0  addi r4, r31, 0x1c0
	ctx.r[4].s64 = ctx.r[31].s64 + 448;
	// 82EF11AC: 807F041C  lwz r3, 0x41c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1052 as u32) ) } as u64;
	// 82EF11B0: 817F041C  lwz r11, 0x41c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1052 as u32) ) } as u64;
	// 82EF11B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF11B8: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF11BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF11C0: 4E800421  bctrl
	ctx.lr = 0x82EF11C4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF11C4 => {
    //   block [0x82EF11C4..0x82EF11FC)
	// 82EF11C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF11C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF11CC: 388BC850  addi r4, r11, -0x37b0
	ctx.r[4].s64 = ctx.r[11].s64 + -14256;
	// 82EF11D0: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF11D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF11D8: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EF11DC: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF11E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF11E4: 4E800421  bctrl
	ctx.lr = 0x82EF11E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF11E8: 907F0188  stw r3, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[3].u32 ) };
	// 82EF11EC: 817F0184  lwz r11, 0x184(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 82EF11F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF11F4: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 82EF11F8: 4BFFFDE0  b 0x82ef0fd8
	pc = 0x82EF0FD8; continue 'dispatch;
            }
            0x82EF11FC => {
    //   block [0x82EF11FC..0x82EF122C)
	// 82EF11FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF1200: 917F02C4  stw r11, 0x2c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(708 as u32), ctx.r[11].u32 ) };
	// 82EF1204: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1208: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF120C: 388BC7F8  addi r4, r11, -0x3808
	ctx.r[4].s64 = ctx.r[11].s64 + -14344;
	// 82EF1210: 817F045C  lwz r11, 0x45c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF1214: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1218: 807F045C  lwz r3, 0x45c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EF121C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF1220: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1224: 4E800421  bctrl
	ctx.lr = 0x82EF1228;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1228: 907F02C8  stw r3, 0x2c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(712 as u32), ctx.r[3].u32 ) };
            }
            0x82EF122C => {
    //   block [0x82EF122C..0x82EF12F0)
	// 82EF122C: 817F02C8  lwz r11, 0x2c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1234: 419A0404  beq cr6, 0x82ef1638
	if ctx.cr[6].eq {
	pc = 0x82EF1638; continue 'dispatch;
	}
	// 82EF1238: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF123C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1240: 388BC898  addi r4, r11, -0x3768
	ctx.r[4].s64 = ctx.r[11].s64 + -14184;
	// 82EF1244: 817F02C8  lwz r11, 0x2c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1248: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF124C: 807F02C8  lwz r3, 0x2c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1250: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF1254: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1258: 4E800421  bctrl
	ctx.lr = 0x82EF125C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF125C: 907F02D0  stw r3, 0x2d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(720 as u32), ctx.r[3].u32 ) };
	// 82EF1260: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1264: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1268: 388BC844  addi r4, r11, -0x37bc
	ctx.r[4].s64 = ctx.r[11].s64 + -14268;
	// 82EF126C: 817F02C8  lwz r11, 0x2c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1270: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1274: 807F02C8  lwz r3, 0x2c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1278: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF127C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1280: 4E800421  bctrl
	ctx.lr = 0x82EF1284;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1284: 907F02CC  stw r3, 0x2cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(716 as u32), ctx.r[3].u32 ) };
	// 82EF1288: 817F02CC  lwz r11, 0x2cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(716 as u32) ) } as u64;
	// 82EF128C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1290: 419A0370  beq cr6, 0x82ef1600
	if ctx.cr[6].eq {
	pc = 0x82EF1600; continue 'dispatch;
	}
	// 82EF1294: 817F02D0  lwz r11, 0x2d0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(720 as u32) ) } as u64;
	// 82EF1298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF129C: 419A0364  beq cr6, 0x82ef1600
	if ctx.cr[6].eq {
	pc = 0x82EF1600; continue 'dispatch;
	}
	// 82EF12A0: 80DF02D0  lwz r6, 0x2d0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(720 as u32) ) } as u64;
	// 82EF12A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF12A8: 38ABC874  addi r5, r11, -0x378c
	ctx.r[5].s64 = ctx.r[11].s64 + -14220;
	// 82EF12AC: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF12B0: 387F02E0  addi r3, r31, 0x2e0
	ctx.r[3].s64 = ctx.r[31].s64 + 736;
	// 82EF12B4: 4BFF9D95  bl 0x82eeb048
	ctx.lr = 0x82EF12B8;
	sub_82EEB048(ctx, base);
	// 82EF12B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF12BC: 997F02D4  stb r11, 0x2d4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(724 as u32), ctx.r[11].u8 ) };
	// 82EF12C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF12C4: 917F02D8  stw r11, 0x2d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(728 as u32), ctx.r[11].u32 ) };
	// 82EF12C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF12CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF12D0: 388BC7EC  addi r4, r11, -0x3814
	ctx.r[4].s64 = ctx.r[11].s64 + -14356;
	// 82EF12D4: 817F02C8  lwz r11, 0x2c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF12D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF12DC: 807F02C8  lwz r3, 0x2c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF12E0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF12E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF12E8: 4E800421  bctrl
	ctx.lr = 0x82EF12EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF12EC: 907F03E4  stw r3, 0x3e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(996 as u32), ctx.r[3].u32 ) };
            }
            0x82EF12F0 => {
    //   block [0x82EF12F0..0x82EF1334)
	// 82EF12F0: 817F03E4  lwz r11, 0x3e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(996 as u32) ) } as u64;
	// 82EF12F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF12F8: 419A003C  beq cr6, 0x82ef1334
	if ctx.cr[6].eq {
	pc = 0x82EF1334; continue 'dispatch;
	}
	// 82EF12FC: 817F02D8  lwz r11, 0x2d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF1300: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF1304: 917F02D8  stw r11, 0x2d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(728 as u32), ctx.r[11].u32 ) };
	// 82EF1308: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF130C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1310: 388BC7EC  addi r4, r11, -0x3814
	ctx.r[4].s64 = ctx.r[11].s64 + -14356;
	// 82EF1314: 817F03E4  lwz r11, 0x3e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(996 as u32) ) } as u64;
	// 82EF1318: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF131C: 807F03E4  lwz r3, 0x3e4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(996 as u32) ) } as u64;
	// 82EF1320: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF1324: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1328: 4E800421  bctrl
	ctx.lr = 0x82EF132C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF132C: 907F03E4  stw r3, 0x3e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(996 as u32), ctx.r[3].u32 ) };
	// 82EF1330: 4BFFFFC0  b 0x82ef12f0
	pc = 0x82EF12F0; continue 'dispatch;
            }
            0x82EF1334 => {
    //   block [0x82EF1334..0x82EF13C4)
	// 82EF1334: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1338: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF133C: 388BC834  addi r4, r11, -0x37cc
	ctx.r[4].s64 = ctx.r[11].s64 + -14284;
	// 82EF1340: 807F02CC  lwz r3, 0x2cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(716 as u32) ) } as u64;
	// 82EF1344: 480035D5  bl 0x82ef4918
	ctx.lr = 0x82EF1348;
	sub_82EF4918(ctx, base);
	// 82EF1348: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF134C: 4182015C  beq 0x82ef14a8
	if ctx.cr[0].eq {
	pc = 0x82EF14A8; continue 'dispatch;
	}
	// 82EF1350: 817F02D8  lwz r11, 0x2d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF1354: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF1358: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 82EF135C: 556C0036  rlwinm r12, r11, 0, 0, 0x1b
	ctx.r[12].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82EF1360: 4BDBF2F5  bl 0x82cb0654
	ctx.lr = 0x82EF1364;
	sub_82CB0654(ctx, base);
	// 82EF1364: 81610000  lwz r11, 0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1368: 7D61616E  stwux r11, r1, r12
	ea = ctx.r[1].u32.wrapping_add(ctx.r[12].u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[1].u32 = ea;
	// 82EF136C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1370: 917F0420  stw r11, 0x420(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1056 as u32), ctx.r[11].u32 ) };
	// 82EF1374: 817F0420  lwz r11, 0x420(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1056 as u32) ) } as u64;
	// 82EF1378: 917F03E8  stw r11, 0x3e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1000 as u32), ctx.r[11].u32 ) };
	// 82EF137C: 817F02D8  lwz r11, 0x2d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF1380: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82EF1384: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF1388: 807F03E8  lwz r3, 0x3e8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1000 as u32) ) } as u64;
	// 82EF138C: 4BDB8625  bl 0x82ca99b0
	ctx.lr = 0x82EF1390;
	sub_82CA99B0(ctx, base);
	// 82EF1390: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1394: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1398: 388BC7EC  addi r4, r11, -0x3814
	ctx.r[4].s64 = ctx.r[11].s64 + -14356;
	// 82EF139C: 817F02C8  lwz r11, 0x2c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF13A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF13A4: 807F02C8  lwz r3, 0x2c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF13A8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF13AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF13B0: 4E800421  bctrl
	ctx.lr = 0x82EF13B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF13B4: 907F03F0  stw r3, 0x3f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), ctx.r[3].u32 ) };
	// 82EF13B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF13BC: 917F03F4  stw r11, 0x3f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1012 as u32), ctx.r[11].u32 ) };
	// 82EF13C0: 48000038  b 0x82ef13f8
	pc = 0x82EF13F8; continue 'dispatch;
            }
            0x82EF13C4 => {
    //   block [0x82EF13C4..0x82EF13F8)
	// 82EF13C4: 817F03F4  lwz r11, 0x3f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) } as u64;
	// 82EF13C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF13CC: 917F03F4  stw r11, 0x3f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1012 as u32), ctx.r[11].u32 ) };
	// 82EF13D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF13D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF13D8: 388BC7EC  addi r4, r11, -0x3814
	ctx.r[4].s64 = ctx.r[11].s64 + -14356;
	// 82EF13DC: 817F03F0  lwz r11, 0x3f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 82EF13E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF13E4: 807F03F0  lwz r3, 0x3f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 82EF13E8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF13EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF13F0: 4E800421  bctrl
	ctx.lr = 0x82EF13F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF13F4: 907F03F0  stw r3, 0x3f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), ctx.r[3].u32 ) };
            }
            0x82EF13F8 => {
    //   block [0x82EF13F8..0x82EF1460)
	// 82EF13F8: 817F03F0  lwz r11, 0x3f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 82EF13FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1400: 419A0064  beq cr6, 0x82ef1464
	if ctx.cr[6].eq {
	pc = 0x82EF1464; continue 'dispatch;
	}
	// 82EF1404: 817F03F4  lwz r11, 0x3f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) } as u64;
	// 82EF1408: 815F02D8  lwz r10, 0x2d8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF140C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EF1410: 40980054  bge cr6, 0x82ef1464
	if !ctx.cr[6].lt {
	pc = 0x82EF1464; continue 'dispatch;
	}
	// 82EF1414: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1418: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF141C: 388BC7D8  addi r4, r11, -0x3828
	ctx.r[4].s64 = ctx.r[11].s64 + -14376;
	// 82EF1420: 817F03F0  lwz r11, 0x3f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 82EF1424: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1428: 807F03F0  lwz r3, 0x3f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 82EF142C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF1430: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1434: 4E800421  bctrl
	ctx.lr = 0x82EF1438;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1438: 907F03F8  stw r3, 0x3f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[3].u32 ) };
	// 82EF143C: 817F03F8  lwz r11, 0x3f8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1016 as u32) ) } as u64;
	// 82EF1440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1444: 419A001C  beq cr6, 0x82ef1460
	if ctx.cr[6].eq {
	pc = 0x82EF1460; continue 'dispatch;
	}
	// 82EF1448: 817F03F4  lwz r11, 0x3f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) } as u64;
	// 82EF144C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF1450: 815F03E8  lwz r10, 0x3e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1000 as u32) ) } as u64;
	// 82EF1454: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF1458: 807F03F8  lwz r3, 0x3f8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1016 as u32) ) } as u64;
	// 82EF145C: 48003F9D  bl 0x82ef53f8
	ctx.lr = 0x82EF1460;
	sub_82EF53F8(ctx, base);
            }
            0x82EF1460 => {
    //   block [0x82EF1460..0x82EF1464)
	// 82EF1460: 4BFFFF64  b 0x82ef13c4
	pc = 0x82EF13C4; continue 'dispatch;
            }
            0x82EF1464 => {
    //   block [0x82EF1464..0x82EF14A8)
	// 82EF1464: 807F0454  lwz r3, 0x454(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EF1468: 480044D1  bl 0x82ef5938
	ctx.lr = 0x82EF146C;
	sub_82EF5938(ctx, base);
	// 82EF146C: 907F0424  stw r3, 0x424(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1060 as u32), ctx.r[3].u32 ) };
	// 82EF1470: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EF1474: 811F02D8  lwz r8, 0x2d8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF1478: 80FF03E8  lwz r7, 0x3e8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1000 as u32) ) } as u64;
	// 82EF147C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF1480: 38BF02E0  addi r5, r31, 0x2e0
	ctx.r[5].s64 = ctx.r[31].s64 + 736;
	// 82EF1484: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EF1488: 807F0424  lwz r3, 0x424(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1060 as u32) ) } as u64;
	// 82EF148C: 817F0424  lwz r11, 0x424(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1060 as u32) ) } as u64;
	// 82EF1490: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1494: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF1498: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF149C: 4E800421  bctrl
	ctx.lr = 0x82EF14A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF14A0: 987F03EC  stb r3, 0x3ec(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1004 as u32), ctx.r[3].u8 ) };
	// 82EF14A4: 4800015C  b 0x82ef1600
	pc = 0x82EF1600; continue 'dispatch;
            }
            0x82EF14A8 => {
    //   block [0x82EF14A8..0x82EF1538)
	// 82EF14A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF14AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF14B0: 388BC814  addi r4, r11, -0x37ec
	ctx.r[4].s64 = ctx.r[11].s64 + -14316;
	// 82EF14B4: 807F02CC  lwz r3, 0x2cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(716 as u32) ) } as u64;
	// 82EF14B8: 48003461  bl 0x82ef4918
	ctx.lr = 0x82EF14BC;
	sub_82EF4918(ctx, base);
	// 82EF14BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF14C0: 41820140  beq 0x82ef1600
	if ctx.cr[0].eq {
	pc = 0x82EF1600; continue 'dispatch;
	}
	// 82EF14C4: 817F02D8  lwz r11, 0x2d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF14C8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF14CC: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 82EF14D0: 556C0036  rlwinm r12, r11, 0, 0, 0x1b
	ctx.r[12].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82EF14D4: 4BDBF181  bl 0x82cb0654
	ctx.lr = 0x82EF14D8;
	sub_82CB0654(ctx, base);
	// 82EF14D8: 81610000  lwz r11, 0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF14DC: 7D61616E  stwux r11, r1, r12
	ea = ctx.r[1].u32.wrapping_add(ctx.r[12].u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[1].u32 = ea;
	// 82EF14E0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF14E4: 917F0428  stw r11, 0x428(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1064 as u32), ctx.r[11].u32 ) };
	// 82EF14E8: 817F0428  lwz r11, 0x428(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1064 as u32) ) } as u64;
	// 82EF14EC: 917F03FC  stw r11, 0x3fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1020 as u32), ctx.r[11].u32 ) };
	// 82EF14F0: 817F02D8  lwz r11, 0x2d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF14F4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82EF14F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF14FC: 807F03FC  lwz r3, 0x3fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1020 as u32) ) } as u64;
	// 82EF1500: 4BDB84B1  bl 0x82ca99b0
	ctx.lr = 0x82EF1504;
	sub_82CA99B0(ctx, base);
	// 82EF1504: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1508: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF150C: 388BC7EC  addi r4, r11, -0x3814
	ctx.r[4].s64 = ctx.r[11].s64 + -14356;
	// 82EF1510: 817F02C8  lwz r11, 0x2c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1514: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1518: 807F02C8  lwz r3, 0x2c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF151C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF1520: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1524: 4E800421  bctrl
	ctx.lr = 0x82EF1528;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1528: 907F0404  stw r3, 0x404(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), ctx.r[3].u32 ) };
	// 82EF152C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF1530: 917F0408  stw r11, 0x408(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), ctx.r[11].u32 ) };
	// 82EF1534: 48000038  b 0x82ef156c
	pc = 0x82EF156C; continue 'dispatch;
            }
            0x82EF1538 => {
    //   block [0x82EF1538..0x82EF156C)
	// 82EF1538: 817F0408  lwz r11, 0x408(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82EF153C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF1540: 917F0408  stw r11, 0x408(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), ctx.r[11].u32 ) };
	// 82EF1544: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1548: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF154C: 388BC7EC  addi r4, r11, -0x3814
	ctx.r[4].s64 = ctx.r[11].s64 + -14356;
	// 82EF1550: 817F0404  lwz r11, 0x404(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82EF1554: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1558: 807F0404  lwz r3, 0x404(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82EF155C: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF1560: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1564: 4E800421  bctrl
	ctx.lr = 0x82EF1568;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1568: 907F0404  stw r3, 0x404(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), ctx.r[3].u32 ) };
            }
            0x82EF156C => {
    //   block [0x82EF156C..0x82EF15C0)
	// 82EF156C: 817F0404  lwz r11, 0x404(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82EF1570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1574: 419A004C  beq cr6, 0x82ef15c0
	if ctx.cr[6].eq {
	pc = 0x82EF15C0; continue 'dispatch;
	}
	// 82EF1578: 817F0408  lwz r11, 0x408(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82EF157C: 815F02D8  lwz r10, 0x2d8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF1580: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EF1584: 4098003C  bge cr6, 0x82ef15c0
	if !ctx.cr[6].lt {
	pc = 0x82EF15C0; continue 'dispatch;
	}
	// 82EF1588: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF158C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1590: 388BC7D8  addi r4, r11, -0x3828
	ctx.r[4].s64 = ctx.r[11].s64 + -14376;
	// 82EF1594: 817F0404  lwz r11, 0x404(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82EF1598: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF159C: 807F0404  lwz r3, 0x404(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82EF15A0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF15A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF15A8: 4E800421  bctrl
	ctx.lr = 0x82EF15AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF15AC: 817F0408  lwz r11, 0x408(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82EF15B0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF15B4: 815F03FC  lwz r10, 0x3fc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1020 as u32) ) } as u64;
	// 82EF15B8: 7C6A592E  stwx r3, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 82EF15BC: 4BFFFF7C  b 0x82ef1538
	pc = 0x82EF1538; continue 'dispatch;
            }
            0x82EF15C0 => {
    //   block [0x82EF15C0..0x82EF1600)
	// 82EF15C0: 807F0454  lwz r3, 0x454(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EF15C4: 48004375  bl 0x82ef5938
	ctx.lr = 0x82EF15C8;
	sub_82EF5938(ctx, base);
	// 82EF15C8: 907F042C  stw r3, 0x42c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1068 as u32), ctx.r[3].u32 ) };
	// 82EF15CC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EF15D0: 811F02D8  lwz r8, 0x2d8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 82EF15D4: 80FF03FC  lwz r7, 0x3fc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1020 as u32) ) } as u64;
	// 82EF15D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF15DC: 38BF02E0  addi r5, r31, 0x2e0
	ctx.r[5].s64 = ctx.r[31].s64 + 736;
	// 82EF15E0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EF15E4: 807F042C  lwz r3, 0x42c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1068 as u32) ) } as u64;
	// 82EF15E8: 817F042C  lwz r11, 0x42c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1068 as u32) ) } as u64;
	// 82EF15EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF15F0: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF15F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF15F8: 4E800421  bctrl
	ctx.lr = 0x82EF15FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF15FC: 987F0400  stb r3, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[3].u8 ) };
            }
            0x82EF1600 => {
    //   block [0x82EF1600..0x82EF1638)
	// 82EF1600: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF1604: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1608: 388BC7F8  addi r4, r11, -0x3808
	ctx.r[4].s64 = ctx.r[11].s64 + -14344;
	// 82EF160C: 817F02C8  lwz r11, 0x2c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1610: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1614: 807F02C8  lwz r3, 0x2c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(712 as u32) ) } as u64;
	// 82EF1618: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF161C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1620: 4E800421  bctrl
	ctx.lr = 0x82EF1624;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1624: 907F02C8  stw r3, 0x2c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(712 as u32), ctx.r[3].u32 ) };
	// 82EF1628: 817F02C4  lwz r11, 0x2c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(708 as u32) ) } as u64;
	// 82EF162C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF1630: 917F02C4  stw r11, 0x2c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(708 as u32), ctx.r[11].u32 ) };
	// 82EF1634: 4BFFFBF8  b 0x82ef122c
	pc = 0x82EF122C; continue 'dispatch;
            }
            0x82EF1638 => {
    //   block [0x82EF1638..0x82EF164C)
	// 82EF1638: 383F0440  addi r1, r31, 0x440
	ctx.r[1].s64 = ctx.r[31].s64 + 1088;
	// 82EF163C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF1640: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF1644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF1648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF1650 size=508
    let mut pc: u32 = 0x82EF1650;
    'dispatch: loop {
        match pc {
            0x82EF1650 => {
    //   block [0x82EF1650..0x82EF1698)
	// 82EF1650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF1654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF1658: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF165C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF1660: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF1664: 90610134  stw r3, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[3].u32 ) };
	// 82EF1668: 9081013C  stw r4, 0x13c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), ctx.r[4].u32 ) };
	// 82EF166C: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF1670: 896B0468  lbz r11, 0x468(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1128 as u32) ) } as u64;
	// 82EF1674: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF1678: 40820020  bne 0x82ef1698
	if !ctx.cr[0].eq {
	pc = 0x82EF1698; continue 'dispatch;
	}
	// 82EF167C: 8061013C  lwz r3, 0x13c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF1680: 48000211  bl 0x82ef1890
	ctx.lr = 0x82EF1684;
	sub_82EF1890(ctx, base);
	// 82EF1684: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF1688: 40820010  bne 0x82ef1698
	if !ctx.cr[0].eq {
	pc = 0x82EF1698; continue 'dispatch;
	}
	// 82EF168C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EF1690: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF1694: 48000B9D  bl 0x82ef2230
	ctx.lr = 0x82EF1698;
	sub_82EF2230(ctx, base);
	pc = 0x82EF1698; continue 'dispatch;
            }
            0x82EF1698 => {
    //   block [0x82EF1698..0x82EF1718)
	// 82EF1698: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF169C: 896B0468  lbz r11, 0x468(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1128 as u32) ) } as u64;
	// 82EF16A0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF16A4: 41820074  beq 0x82ef1718
	if ctx.cr[0].eq {
	pc = 0x82EF1718; continue 'dispatch;
	}
	// 82EF16A8: 8061013C  lwz r3, 0x13c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF16AC: 480001D5  bl 0x82ef1880
	ctx.lr = 0x82EF16B0;
	sub_82EF1880(ctx, base);
	// 82EF16B0: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 82EF16B4: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF16B8: 41820060  beq 0x82ef1718
	if ctx.cr[0].eq {
	pc = 0x82EF1718; continue 'dispatch;
	}
	// 82EF16BC: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF16C0: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF16C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF16C8: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF16CC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82EF16D0: 4B32E439  bl 0x8221fb08
	ctx.lr = 0x82EF16D4;
	sub_8221FB08(ctx, base);
	// 82EF16D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF16D8: C82B0D38  lfd f1, 0xd38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82EF16DC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82EF16E0: 48004109  bl 0x82ef57e8
	ctx.lr = 0x82EF16E4;
	sub_82EF57E8(ctx, base);
	// 82EF16E4: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF16E8: 48004251  bl 0x82ef5938
	ctx.lr = 0x82EF16EC;
	sub_82EF5938(ctx, base);
	// 82EF16EC: 906100E0  stw r3, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[3].u32 ) };
	// 82EF16F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF16F4: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 82EF16F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF16FC: 388BC8B8  addi r4, r11, -0x3748
	ctx.r[4].s64 = ctx.r[11].s64 + -14152;
	// 82EF1700: 806100E0  lwz r3, 0xe0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 82EF1704: 816100E0  lwz r11, 0xe0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 82EF1708: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF170C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF1710: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1714: 4E800421  bctrl
	ctx.lr = 0x82EF1718;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF1718 => {
    //   block [0x82EF1718..0x82EF184C)
	// 82EF1718: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF171C: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF1720: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82EF1724: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF1728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF172C: 4B32E3DD  bl 0x8221fb08
	ctx.lr = 0x82EF1730;
	sub_8221FB08(ctx, base);
	// 82EF1730: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF1734: C82B0D38  lfd f1, 0xd38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82EF1738: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF173C: 480040AD  bl 0x82ef57e8
	ctx.lr = 0x82EF1740;
	sub_82EF57E8(ctx, base);
	// 82EF1740: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF1744: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82EF1748: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF174C: F96100E8  std r11, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[11].u64 ) };
	// 82EF1750: C80100E8  lfd f0, 0xe8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	// 82EF1754: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1758: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF175C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EF1760: 48004089  bl 0x82ef57e8
	ctx.lr = 0x82EF1764;
	sub_82EF57E8(ctx, base);
	// 82EF1764: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF1768: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82EF176C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF1770: F96100F0  std r11, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u64 ) };
	// 82EF1774: C80100F0  lfd f0, 0xf0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) };
	// 82EF1778: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF177C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1780: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 82EF1784: 48004065  bl 0x82ef57e8
	ctx.lr = 0x82EF1788;
	sub_82EF57E8(ctx, base);
	// 82EF1788: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF178C: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EF1790: 480000C1  bl 0x82ef1850
	ctx.lr = 0x82EF1794;
	sub_82EF1850(ctx, base);
	// 82EF1794: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1798: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 82EF179C: 4800404D  bl 0x82ef57e8
	ctx.lr = 0x82EF17A0;
	sub_82EF57E8(ctx, base);
	// 82EF17A0: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF17A4: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EF17A8: 480000B9  bl 0x82ef1860
	ctx.lr = 0x82EF17AC;
	sub_82EF1860(ctx, base);
	// 82EF17AC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF17B0: 386B0040  addi r3, r11, 0x40
	ctx.r[3].s64 = ctx.r[11].s64 + 64;
	// 82EF17B4: 48004035  bl 0x82ef57e8
	ctx.lr = 0x82EF17B8;
	sub_82EF57E8(ctx, base);
	// 82EF17B8: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF17BC: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 82EF17C0: 48000091  bl 0x82ef1850
	ctx.lr = 0x82EF17C4;
	sub_82EF1850(ctx, base);
	// 82EF17C4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF17C8: 386B0050  addi r3, r11, 0x50
	ctx.r[3].s64 = ctx.r[11].s64 + 80;
	// 82EF17CC: 4800401D  bl 0x82ef57e8
	ctx.lr = 0x82EF17D0;
	sub_82EF57E8(ctx, base);
	// 82EF17D0: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF17D4: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 82EF17D8: 48000089  bl 0x82ef1860
	ctx.lr = 0x82EF17DC;
	sub_82EF1860(ctx, base);
	// 82EF17DC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF17E0: 386B0060  addi r3, r11, 0x60
	ctx.r[3].s64 = ctx.r[11].s64 + 96;
	// 82EF17E4: 48004005  bl 0x82ef57e8
	ctx.lr = 0x82EF17E8;
	sub_82EF57E8(ctx, base);
	// 82EF17E8: 8061013C  lwz r3, 0x13c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EF17EC: 48000085  bl 0x82ef1870
	ctx.lr = 0x82EF17F0;
	sub_82EF1870(ctx, base);
	// 82EF17F0: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 82EF17F4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF17F8: F96100F8  std r11, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[11].u64 ) };
	// 82EF17FC: C80100F8  lfd f0, 0xf8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 82EF1800: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1804: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1808: 386B0070  addi r3, r11, 0x70
	ctx.r[3].s64 = ctx.r[11].s64 + 112;
	// 82EF180C: 48003FDD  bl 0x82ef57e8
	ctx.lr = 0x82EF1810;
	sub_82EF57E8(ctx, base);
	// 82EF1810: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82EF1814: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1818: 3BCBC8A4  addi r30, r11, -0x375c
	ctx.r[30].s64 = ctx.r[11].s64 + -14172;
	// 82EF181C: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF1820: 48004119  bl 0x82ef5938
	ctx.lr = 0x82EF1824;
	sub_82EF5938(ctx, base);
	// 82EF1824: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF1828: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF182C: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 82EF1830: 48004009  bl 0x82ef5838
	ctx.lr = 0x82EF1834;
	sub_82EF5838(ctx, base);
	// 82EF1834: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82EF1838: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF183C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF1840: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF1844: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF1848: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EF1850 size=16
    let mut pc: u32 = 0x82EF1850;
    'dispatch: loop {
        match pc {
            0x82EF1850 => {
    //   block [0x82EF1850..0x82EF1860)
	// 82EF1850: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF1854: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF1858: C02B0000  lfs f1, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EF185C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EF1860 size=16
    let mut pc: u32 = 0x82EF1860;
    'dispatch: loop {
        match pc {
            0x82EF1860 => {
    //   block [0x82EF1860..0x82EF1870)
	// 82EF1860: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF1864: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF1868: C02B0004  lfs f1, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EF186C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF1870 size=16
    let mut pc: u32 = 0x82EF1870;
    'dispatch: loop {
        match pc {
            0x82EF1870 => {
    //   block [0x82EF1870..0x82EF1880)
	// 82EF1870: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF1874: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF1878: A06B0000  lhz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF187C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF1880 size=16
    let mut pc: u32 = 0x82EF1880;
    'dispatch: loop {
        match pc {
            0x82EF1880 => {
    //   block [0x82EF1880..0x82EF1890)
	// 82EF1880: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF1884: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF1888: A06B0024  lhz r3, 0x24(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EF188C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF1890 size=16
    let mut pc: u32 = 0x82EF1890;
    'dispatch: loop {
        match pc {
            0x82EF1890 => {
    //   block [0x82EF1890..0x82EF18A0)
	// 82EF1890: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF1894: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF1898: 886B003C  lbz r3, 0x3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EF189C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF18A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF18A0 size=1144
    let mut pc: u32 = 0x82EF18A0;
    'dispatch: loop {
        match pc {
            0x82EF18A0 => {
    //   block [0x82EF18A0..0x82EF1A08)
	// 82EF18A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF18A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF18A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF18AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF18B0: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF18B4: 90610224  stw r3, 0x224(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(548 as u32), ctx.r[3].u32 ) };
	// 82EF18B8: 9081022C  stw r4, 0x22c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(556 as u32), ctx.r[4].u32 ) };
	// 82EF18BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF18C0: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82EF18C4: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF18C8: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF18CC: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 82EF18D0: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF18D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF18D8: 4B32E231  bl 0x8221fb08
	ctx.lr = 0x82EF18DC;
	sub_8221FB08(ctx, base);
	// 82EF18DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF18E0: C82B0D38  lfd f1, 0xd38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82EF18E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF18E8: 48003F01  bl 0x82ef57e8
	ctx.lr = 0x82EF18EC;
	sub_82EF57E8(ctx, base);
	// 82EF18EC: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF18F0: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF18F4: 4BFF6C45  bl 0x82ee8538
	ctx.lr = 0x82EF18F8;
	sub_82EE8538(ctx, base);
	// 82EF18F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF18FC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1900: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EF1904: 48003F0D  bl 0x82ef5810
	ctx.lr = 0x82EF1908;
	sub_82EF5810(ctx, base);
	// 82EF1908: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF190C: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF1910: 4BFF6D21  bl 0x82ee8630
	ctx.lr = 0x82EF1914;
	sub_82EE8630(ctx, base);
	// 82EF1914: F8610160  std r3, 0x160(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[3].u64 ) };
	// 82EF1918: C8010160  lfd f0, 0x160(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) };
	// 82EF191C: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1920: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1924: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 82EF1928: 48003EC1  bl 0x82ef57e8
	ctx.lr = 0x82EF192C;
	sub_82EF57E8(ctx, base);
	// 82EF192C: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1930: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF1934: 4BFF6ECD  bl 0x82ee8800
	ctx.lr = 0x82EF1938;
	sub_82EE8800(ctx, base);
	// 82EF1938: F8610168  std r3, 0x168(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), ctx.r[3].u64 ) };
	// 82EF193C: C8010168  lfd f0, 0x168(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(360 as u32) ) };
	// 82EF1940: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1944: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1948: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 82EF194C: 48003E9D  bl 0x82ef57e8
	ctx.lr = 0x82EF1950;
	sub_82EF57E8(ctx, base);
	// 82EF1950: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1954: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF1958: 4BFF6D49  bl 0x82ee86a0
	ctx.lr = 0x82EF195C;
	sub_82EE86A0(ctx, base);
	// 82EF195C: F8610170  std r3, 0x170(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[3].u64 ) };
	// 82EF1960: C8010170  lfd f0, 0x170(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 82EF1964: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1968: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF196C: 386B0040  addi r3, r11, 0x40
	ctx.r[3].s64 = ctx.r[11].s64 + 64;
	// 82EF1970: 48003E79  bl 0x82ef57e8
	ctx.lr = 0x82EF1974;
	sub_82EF57E8(ctx, base);
	// 82EF1974: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1978: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF197C: 4800039D  bl 0x82ef1d18
	ctx.lr = 0x82EF1980;
	sub_82EF1D18(ctx, base);
	// 82EF1980: F8610178  std r3, 0x178(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[3].u64 ) };
	// 82EF1984: C8010178  lfd f0, 0x178(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) };
	// 82EF1988: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF198C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF1990: 386B0050  addi r3, r11, 0x50
	ctx.r[3].s64 = ctx.r[11].s64 + 80;
	// 82EF1994: 48003E55  bl 0x82ef57e8
	ctx.lr = 0x82EF1998;
	sub_82EF57E8(ctx, base);
	// 82EF1998: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF199C: 808B0050  lwz r4, 0x50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF19A0: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF19A4: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF19A8: 4BFF6DC9  bl 0x82ee8770
	ctx.lr = 0x82EF19AC;
	sub_82EE8770(ctx, base);
	// 82EF19AC: F8610180  std r3, 0x180(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[3].u64 ) };
	// 82EF19B0: C8010180  lfd f0, 0x180(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(384 as u32) ) };
	// 82EF19B4: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF19B8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF19BC: 386B0060  addi r3, r11, 0x60
	ctx.r[3].s64 = ctx.r[11].s64 + 96;
	// 82EF19C0: 48003E29  bl 0x82ef57e8
	ctx.lr = 0x82EF19C4;
	sub_82EF57E8(ctx, base);
	// 82EF19C4: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82EF19C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF19CC: 3BCBC978  addi r30, r11, -0x3688
	ctx.r[30].s64 = ctx.r[11].s64 + -13960;
	// 82EF19D0: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF19D4: 48003F65  bl 0x82ef5938
	ctx.lr = 0x82EF19D8;
	sub_82EF5938(ctx, base);
	// 82EF19D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF19DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF19E0: 38C00007  li r6, 7
	ctx.r[6].s64 = 7;
	// 82EF19E4: 48003E55  bl 0x82ef5838
	ctx.lr = 0x82EF19E8;
	sub_82EF5838(ctx, base);
	// 82EF19E8: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF19EC: 816B0478  lwz r11, 0x478(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1144 as u32) ) } as u64;
	// 82EF19F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF19F4: 419A0014  beq cr6, 0x82ef1a08
	if ctx.cr[6].eq {
	pc = 0x82EF1A08; continue 'dispatch;
	}
	// 82EF19F8: 8081022C  lwz r4, 0x22c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(556 as u32) ) } as u64;
	// 82EF19FC: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1A00: 48000B09  bl 0x82ef2508
	ctx.lr = 0x82EF1A04;
	sub_82EF2508(ctx, base);
	// 82EF1A04: 906100F0  stw r3, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[3].u32 ) };
	pc = 0x82EF1A08; continue 'dispatch;
            }
            0x82EF1A08 => {
    //   block [0x82EF1A08..0x82EF1A1C)
	// 82EF1A08: 816100F0  lwz r11, 0xf0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) } as u64;
	// 82EF1A0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF1A10: 4098000C  bge cr6, 0x82ef1a1c
	if !ctx.cr[6].lt {
	pc = 0x82EF1A1C; continue 'dispatch;
	}
	// 82EF1A14: 806100F0  lwz r3, 0xf0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) } as u64;
	// 82EF1A18: 480002E8  b 0x82ef1d00
	pc = 0x82EF1D00; continue 'dispatch;
            }
            0x82EF1A1C => {
    //   block [0x82EF1A1C..0x82EF1A28)
	// 82EF1A1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF1A20: 916100F4  stw r11, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82EF1A24: 48000010  b 0x82ef1a34
	pc = 0x82EF1A34; continue 'dispatch;
            }
            0x82EF1A28 => {
    //   block [0x82EF1A28..0x82EF1A34)
	// 82EF1A28: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EF1A2C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF1A30: 916100F4  stw r11, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF1A34; continue 'dispatch;
            }
            0x82EF1A34 => {
    //   block [0x82EF1A34..0x82EF1AB0)
	// 82EF1A34: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EF1A38: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82EF1A3C: 40980078  bge cr6, 0x82ef1ab4
	if !ctx.cr[6].lt {
	pc = 0x82EF1AB4; continue 'dispatch;
	}
	// 82EF1A40: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF1A44: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF1A48: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF1A4C: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF1A50: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82EF1A54: 4B32E0B5  bl 0x8221fb08
	ctx.lr = 0x82EF1A58;
	sub_8221FB08(ctx, base);
	// 82EF1A58: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EF1A5C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF1A60: F9610188  std r11, 0x188(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[11].u64 ) };
	// 82EF1A64: C8010188  lfd f0, 0x188(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) };
	// 82EF1A68: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1A6C: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82EF1A70: 48003D79  bl 0x82ef57e8
	ctx.lr = 0x82EF1A74;
	sub_82EF57E8(ctx, base);
	// 82EF1A74: 808100F4  lwz r4, 0xf4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EF1A78: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1A7C: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF1A80: 4BFF6E71  bl 0x82ee88f0
	ctx.lr = 0x82EF1A84;
	sub_82EE88F0(ctx, base);
	// 82EF1A84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF1A88: 41820028  beq 0x82ef1ab0
	if ctx.cr[0].eq {
	pc = 0x82EF1AB0; continue 'dispatch;
	}
	// 82EF1A8C: 3BE10100  addi r31, r1, 0x100
	ctx.r[31].s64 = ctx.r[1].s64 + 256;
	// 82EF1A90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1A94: 3BCBC95C  addi r30, r11, -0x36a4
	ctx.r[30].s64 = ctx.r[11].s64 + -13988;
	// 82EF1A98: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1A9C: 48003E9D  bl 0x82ef5938
	ctx.lr = 0x82EF1AA0;
	sub_82EF5938(ctx, base);
	// 82EF1AA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF1AA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF1AA8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF1AAC: 48003D8D  bl 0x82ef5838
	ctx.lr = 0x82EF1AB0;
	sub_82EF5838(ctx, base);
	pc = 0x82EF1AB0; continue 'dispatch;
            }
            0x82EF1AB0 => {
    //   block [0x82EF1AB0..0x82EF1AB4)
	// 82EF1AB0: 4BFFFF78  b 0x82ef1a28
	pc = 0x82EF1A28; continue 'dispatch;
            }
            0x82EF1AB4 => {
    //   block [0x82EF1AB4..0x82EF1AE4)
	// 82EF1AB4: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1AB8: 816B0474  lwz r11, 0x474(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EF1ABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF1AC0: 419A0024  beq cr6, 0x82ef1ae4
	if ctx.cr[6].eq {
	pc = 0x82EF1AE4; continue 'dispatch;
	}
	// 82EF1AC4: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1AC8: 808B0484  lwz r4, 0x484(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1156 as u32) ) } as u64;
	// 82EF1ACC: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1AD0: 4BFFF0C9  bl 0x82ef0b98
	ctx.lr = 0x82EF1AD4;
	sub_82EF0B98(ctx, base);
	// 82EF1AD4: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1AD8: 808B0474  lwz r4, 0x474(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1140 as u32) ) } as u64;
	// 82EF1ADC: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1AE0: 4BFFF0B9  bl 0x82ef0b98
	ctx.lr = 0x82EF1AE4;
	sub_82EF0B98(ctx, base);
	pc = 0x82EF1AE4; continue 'dispatch;
            }
            0x82EF1AE4 => {
    //   block [0x82EF1AE4..0x82EF1D00)
	// 82EF1AE4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82EF1AE8: 483C7ECD  bl 0x832b99b4
	ctx.lr = 0x82EF1AEC;
	// extern call 0x832B99B4 → crate::xboxkrnl::XGetVideoMode
	crate::xboxkrnl::XGetVideoMode(ctx, base);
	// 82EF1AEC: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EF1AF0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EF1AF4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EF1AF8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82EF1AFC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF1B00: F9610190  std r11, 0x190(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), ctx.r[11].u64 ) };
	// 82EF1B04: C8010190  lfd f0, 0x190(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) };
	// 82EF1B08: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1B0C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82EF1B10: 48003C89  bl 0x82ef5798
	ctx.lr = 0x82EF1B14;
	sub_82EF5798(ctx, base);
	// 82EF1B14: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1B18: 48003E21  bl 0x82ef5938
	ctx.lr = 0x82EF1B1C;
	sub_82EF5938(ctx, base);
	// 82EF1B1C: 90610198  stw r3, 0x198(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), ctx.r[3].u32 ) };
	// 82EF1B20: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF1B24: 38A10110  addi r5, r1, 0x110
	ctx.r[5].s64 = ctx.r[1].s64 + 272;
	// 82EF1B28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1B2C: 388BC948  addi r4, r11, -0x36b8
	ctx.r[4].s64 = ctx.r[11].s64 + -14008;
	// 82EF1B30: 80610198  lwz r3, 0x198(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EF1B34: 81610198  lwz r11, 0x198(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EF1B38: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1B3C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF1B40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1B44: 4E800421  bctrl
	ctx.lr = 0x82EF1B48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1B48: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1B4C: 896B0468  lbz r11, 0x468(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1128 as u32) ) } as u64;
	// 82EF1B50: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF1B54: F96101A0  std r11, 0x1a0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), ctx.r[11].u64 ) };
	// 82EF1B58: C80101A0  lfd f0, 0x1a0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(416 as u32) ) };
	// 82EF1B5C: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1B60: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82EF1B64: 48003C35  bl 0x82ef5798
	ctx.lr = 0x82EF1B68;
	sub_82EF5798(ctx, base);
	// 82EF1B68: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1B6C: 48003DCD  bl 0x82ef5938
	ctx.lr = 0x82EF1B70;
	sub_82EF5938(ctx, base);
	// 82EF1B70: 906101A8  stw r3, 0x1a8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), ctx.r[3].u32 ) };
	// 82EF1B74: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF1B78: 38A10120  addi r5, r1, 0x120
	ctx.r[5].s64 = ctx.r[1].s64 + 288;
	// 82EF1B7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1B80: 388BC934  addi r4, r11, -0x36cc
	ctx.r[4].s64 = ctx.r[11].s64 + -14028;
	// 82EF1B84: 806101A8  lwz r3, 0x1a8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(424 as u32) ) } as u64;
	// 82EF1B88: 816101A8  lwz r11, 0x1a8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(424 as u32) ) } as u64;
	// 82EF1B8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1B90: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF1B94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1B98: 4E800421  bctrl
	ctx.lr = 0x82EF1B9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1B9C: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1BA0: 896B0469  lbz r11, 0x469(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1129 as u32) ) } as u64;
	// 82EF1BA4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF1BA8: F96101B0  std r11, 0x1b0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), ctx.r[11].u64 ) };
	// 82EF1BAC: C80101B0  lfd f0, 0x1b0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(432 as u32) ) };
	// 82EF1BB0: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1BB4: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82EF1BB8: 48003BE1  bl 0x82ef5798
	ctx.lr = 0x82EF1BBC;
	sub_82EF5798(ctx, base);
	// 82EF1BBC: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1BC0: 48003D79  bl 0x82ef5938
	ctx.lr = 0x82EF1BC4;
	sub_82EF5938(ctx, base);
	// 82EF1BC4: 906101B8  stw r3, 0x1b8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), ctx.r[3].u32 ) };
	// 82EF1BC8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF1BCC: 38A10130  addi r5, r1, 0x130
	ctx.r[5].s64 = ctx.r[1].s64 + 304;
	// 82EF1BD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1BD4: 388BC91C  addi r4, r11, -0x36e4
	ctx.r[4].s64 = ctx.r[11].s64 + -14052;
	// 82EF1BD8: 806101B8  lwz r3, 0x1b8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EF1BDC: 816101B8  lwz r11, 0x1b8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EF1BE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1BE4: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF1BE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1BEC: 4E800421  bctrl
	ctx.lr = 0x82EF1BF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1BF0: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1BF4: C00B048C  lfs f0, 0x48c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF1BF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF1BFC: C1AB0A54  lfs f13, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EF1C00: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EF1C04: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82EF1C08: D80101C0  stfd f0, 0x1c0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.f[0].u64 ) };
	// 82EF1C0C: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF1C10: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF1C14: F96101C8  std r11, 0x1c8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), ctx.r[11].u64 ) };
	// 82EF1C18: C80101C8  lfd f0, 0x1c8(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(456 as u32) ) };
	// 82EF1C1C: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1C20: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82EF1C24: 48003B75  bl 0x82ef5798
	ctx.lr = 0x82EF1C28;
	sub_82EF5798(ctx, base);
	// 82EF1C28: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1C2C: 48003D0D  bl 0x82ef5938
	ctx.lr = 0x82EF1C30;
	sub_82EF5938(ctx, base);
	// 82EF1C30: 906101D0  stw r3, 0x1d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), ctx.r[3].u32 ) };
	// 82EF1C34: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF1C38: 38A10140  addi r5, r1, 0x140
	ctx.r[5].s64 = ctx.r[1].s64 + 320;
	// 82EF1C3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1C40: 388BC908  addi r4, r11, -0x36f8
	ctx.r[4].s64 = ctx.r[11].s64 + -14072;
	// 82EF1C44: 806101D0  lwz r3, 0x1d0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) } as u64;
	// 82EF1C48: 816101D0  lwz r11, 0x1d0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) } as u64;
	// 82EF1C4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1C50: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF1C54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1C58: 4E800421  bctrl
	ctx.lr = 0x82EF1C5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1C5C: 81610224  lwz r11, 0x224(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1C60: C00B0490  lfs f0, 0x490(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF1C64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF1C68: C1AB0A54  lfs f13, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EF1C6C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EF1C70: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82EF1C74: D80101D8  stfd f0, 0x1d8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.f[0].u64 ) };
	// 82EF1C78: 816101DC  lwz r11, 0x1dc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(476 as u32) ) } as u64;
	// 82EF1C7C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF1C80: F96101E0  std r11, 0x1e0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[11].u64 ) };
	// 82EF1C84: C80101E0  lfd f0, 0x1e0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(480 as u32) ) };
	// 82EF1C88: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF1C8C: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 82EF1C90: 48003B09  bl 0x82ef5798
	ctx.lr = 0x82EF1C94;
	sub_82EF5798(ctx, base);
	// 82EF1C94: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1C98: 48003CA1  bl 0x82ef5938
	ctx.lr = 0x82EF1C9C;
	sub_82EF5938(ctx, base);
	// 82EF1C9C: 906101E8  stw r3, 0x1e8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), ctx.r[3].u32 ) };
	// 82EF1CA0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF1CA4: 38A10150  addi r5, r1, 0x150
	ctx.r[5].s64 = ctx.r[1].s64 + 336;
	// 82EF1CA8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1CAC: 388BC8F4  addi r4, r11, -0x370c
	ctx.r[4].s64 = ctx.r[11].s64 + -14092;
	// 82EF1CB0: 806101E8  lwz r3, 0x1e8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EF1CB4: 816101E8  lwz r11, 0x1e8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EF1CB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1CBC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF1CC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1CC4: 4E800421  bctrl
	ctx.lr = 0x82EF1CC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1CC8: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EF1CCC: 48003C6D  bl 0x82ef5938
	ctx.lr = 0x82EF1CD0;
	sub_82EF5938(ctx, base);
	// 82EF1CD0: 906101EC  stw r3, 0x1ec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), ctx.r[3].u32 ) };
	// 82EF1CD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF1CD8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF1CDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1CE0: 388BC8E8  addi r4, r11, -0x3718
	ctx.r[4].s64 = ctx.r[11].s64 + -14104;
	// 82EF1CE4: 806101EC  lwz r3, 0x1ec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EF1CE8: 816101EC  lwz r11, 0x1ec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EF1CEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1CF0: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF1CF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1CF8: 4E800421  bctrl
	ctx.lr = 0x82EF1CFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1CFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
            }
            0x82EF1D00 => {
    //   block [0x82EF1D00..0x82EF1D18)
	// 82EF1D00: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 82EF1D04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF1D08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF1D0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF1D10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF1D14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF1D18 size=40
    let mut pc: u32 = 0x82EF1D18;
    'dispatch: loop {
        match pc {
            0x82EF1D18 => {
    //   block [0x82EF1D18..0x82EF1D40)
	// 82EF1D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF1D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF1D20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF1D24: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF1D28: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF1D2C: 4BFF69E5  bl 0x82ee8710
	ctx.lr = 0x82EF1D30;
	sub_82EE8710(ctx, base);
	// 82EF1D30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF1D34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF1D38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF1D3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF1D40 size=368
    let mut pc: u32 = 0x82EF1D40;
    'dispatch: loop {
        match pc {
            0x82EF1D40 => {
    //   block [0x82EF1D40..0x82EF1DD8)
	// 82EF1D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF1D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF1D48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF1D4C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF1D50: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EF1D54: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EF1D58: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EF1D5C: 90C100AC  stw r6, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[6].u32 ) };
	// 82EF1D60: 90E100B4  stw r7, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[7].u32 ) };
	// 82EF1D64: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EF1D68: 48003A19  bl 0x82ef5780
	ctx.lr = 0x82EF1D6C;
	sub_82EF5780(ctx, base);
	// 82EF1D6C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF1D70: 48003BC9  bl 0x82ef5938
	ctx.lr = 0x82EF1D74;
	sub_82EF5938(ctx, base);
	// 82EF1D74: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EF1D78: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF1D7C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF1D80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1D84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF1D88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1D8C: 4E800421  bctrl
	ctx.lr = 0x82EF1D90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1D90: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82EF1D94: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF1D98: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EF1D9C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EF1DA0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1DA4: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF1DA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1DAC: 4E800421  bctrl
	ctx.lr = 0x82EF1DB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1DB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF1DB4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EF1DB8: 480020E9  bl 0x82ef3ea0
	ctx.lr = 0x82EF1DBC;
	sub_82EF3EA0(ctx, base);
	// 82EF1DBC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EF1DC0: 4BFFB401  bl 0x82eed1c0
	ctx.lr = 0x82EF1DC4;
	sub_82EED1C0(ctx, base);
	// 82EF1DC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EF1DC8: 40820010  bne 0x82ef1dd8
	if !ctx.cr[0].eq {
	pc = 0x82EF1DD8; continue 'dispatch;
	}
	// 82EF1DCC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EF1DD0: 48002091  bl 0x82ef3e60
	ctx.lr = 0x82EF1DD4;
	sub_82EF3E60(ctx, base);
	// 82EF1DD4: 480000C8  b 0x82ef1e9c
	pc = 0x82EF1E9C; continue 'dispatch;
            }
            0x82EF1DD8 => {
    //   block [0x82EF1DD8..0x82EF1E00)
	// 82EF1DD8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EF1DDC: 4BFFB3E5  bl 0x82eed1c0
	ctx.lr = 0x82EF1DE0;
	sub_82EED1C0(ctx, base);
	// 82EF1DE0: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EF1DE4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF1DE8: 480000C9  bl 0x82ef1eb0
	ctx.lr = 0x82EF1DEC;
	sub_82EF1EB0(ctx, base);
	// 82EF1DEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EF1DF0: 40820010  bne 0x82ef1e00
	if !ctx.cr[0].eq {
	pc = 0x82EF1E00; continue 'dispatch;
	}
	// 82EF1DF4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EF1DF8: 48002069  bl 0x82ef3e60
	ctx.lr = 0x82EF1DFC;
	sub_82EF3E60(ctx, base);
	// 82EF1DFC: 480000A0  b 0x82ef1e9c
	pc = 0x82EF1E9C; continue 'dispatch;
            }
            0x82EF1E00 => {
    //   block [0x82EF1E00..0x82EF1E9C)
	// 82EF1E00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1E04: 4800397D  bl 0x82ef5780
	ctx.lr = 0x82EF1E08;
	sub_82EF5780(ctx, base);
	// 82EF1E08: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF1E0C: 480000A5  bl 0x82ef1eb0
	ctx.lr = 0x82EF1E10;
	sub_82EF1EB0(ctx, base);
	// 82EF1E10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF1E14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1E18: 48002139  bl 0x82ef3f50
	ctx.lr = 0x82EF1E1C;
	sub_82EF3F50(ctx, base);
	// 82EF1E1C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF1E20: 806B0470  lwz r3, 0x470(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1136 as u32) ) } as u64;
	// 82EF1E24: 48003AD5  bl 0x82ef58f8
	ctx.lr = 0x82EF1E28;
	sub_82EF58F8(ctx, base);
	// 82EF1E28: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF1E2C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF1E30: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1E34: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF1E38: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF1E3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1E40: 4E800421  bctrl
	ctx.lr = 0x82EF1E44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1E44: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EF1E48: 80C100B4  lwz r6, 0xb4(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EF1E4C: 80A100AC  lwz r5, 0xac(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EF1E50: 808100A4  lwz r4, 0xa4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF1E54: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF1E58: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF1E5C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF1E60: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF1E64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF1E68: 4E800421  bctrl
	ctx.lr = 0x82EF1E6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF1E6C: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF1E70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1E74: 4BFFB34D  bl 0x82eed1c0
	ctx.lr = 0x82EF1E78;
	sub_82EED1C0(ctx, base);
	// 82EF1E78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EF1E7C: 4800A71D  bl 0x82efc598
	ctx.lr = 0x82EF1E80;
	sub_82EFC598(ctx, base);
	// 82EF1E80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF1E84: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF1E88: 4BFFBCA9  bl 0x82eedb30
	ctx.lr = 0x82EF1E8C;
	sub_82EEDB30(ctx, base);
	// 82EF1E8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1E90: 48002081  bl 0x82ef3f10
	ctx.lr = 0x82EF1E94;
	sub_82EF3F10(ctx, base);
	// 82EF1E94: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EF1E98: 48001FC9  bl 0x82ef3e60
	ctx.lr = 0x82EF1E9C;
	sub_82EF3E60(ctx, base);
            }
            0x82EF1E9C => {
    //   block [0x82EF1E9C..0x82EF1EB0)
	// 82EF1E9C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EF1EA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF1EA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF1EA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF1EAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF1EB0 size=44
    let mut pc: u32 = 0x82EF1EB0;
    'dispatch: loop {
        match pc {
            0x82EF1EB0 => {
    //   block [0x82EF1EB0..0x82EF1EDC)
	// 82EF1EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF1EB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF1EB8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF1EBC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF1EC0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF1EC4: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EF1EC8: 4BFFB2F9  bl 0x82eed1c0
	ctx.lr = 0x82EF1ECC;
	sub_82EED1C0(ctx, base);
	// 82EF1ECC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF1ED0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF1ED4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF1ED8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF1EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF1EE0 size=416
    let mut pc: u32 = 0x82EF1EE0;
    'dispatch: loop {
        match pc {
            0x82EF1EE0 => {
    //   block [0x82EF1EE0..0x82EF2080)
	// 82EF1EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF1EE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF1EE8: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF1EEC: 90610174  stw r3, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[3].u32 ) };
	// 82EF1EF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1EF4: 38EBCAAC  addi r7, r11, -0x3554
	ctx.r[7].s64 = ctx.r[11].s64 + -13652;
	// 82EF1EF8: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1EFC: 38CB0364  addi r6, r11, 0x364
	ctx.r[6].s64 = ctx.r[11].s64 + 868;
	// 82EF1F00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1F04: 38ABCAA4  addi r5, r11, -0x355c
	ctx.r[5].s64 = ctx.r[11].s64 + -13660;
	// 82EF1F08: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF1F0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1F10: 4BFF9139  bl 0x82eeb048
	ctx.lr = 0x82EF1F14;
	sub_82EEB048(ctx, base);
	// 82EF1F14: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EF1F18: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82EF1F1C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF1F20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1F24: 388BCA84  addi r4, r11, -0x357c
	ctx.r[4].s64 = ctx.r[11].s64 + -13692;
	// 82EF1F28: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1F2C: 4BFFFE15  bl 0x82ef1d40
	ctx.lr = 0x82EF1F30;
	sub_82EF1D40(ctx, base);
	// 82EF1F30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1F34: 38EBCA6C  addi r7, r11, -0x3594
	ctx.r[7].s64 = ctx.r[11].s64 + -13716;
	// 82EF1F38: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1F3C: 38CB0364  addi r6, r11, 0x364
	ctx.r[6].s64 = ctx.r[11].s64 + 868;
	// 82EF1F40: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1F44: 38ABCAA4  addi r5, r11, -0x355c
	ctx.r[5].s64 = ctx.r[11].s64 + -13660;
	// 82EF1F48: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF1F4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1F50: 4BFF90F9  bl 0x82eeb048
	ctx.lr = 0x82EF1F54;
	sub_82EEB048(ctx, base);
	// 82EF1F54: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EF1F58: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82EF1F5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF1F60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1F64: 388BCA50  addi r4, r11, -0x35b0
	ctx.r[4].s64 = ctx.r[11].s64 + -13744;
	// 82EF1F68: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1F6C: 4BFFFDD5  bl 0x82ef1d40
	ctx.lr = 0x82EF1F70;
	sub_82EF1D40(ctx, base);
	// 82EF1F70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1F74: 38EBCA34  addi r7, r11, -0x35cc
	ctx.r[7].s64 = ctx.r[11].s64 + -13772;
	// 82EF1F78: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1F7C: 38CB0364  addi r6, r11, 0x364
	ctx.r[6].s64 = ctx.r[11].s64 + 868;
	// 82EF1F80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1F84: 38ABCAA4  addi r5, r11, -0x355c
	ctx.r[5].s64 = ctx.r[11].s64 + -13660;
	// 82EF1F88: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF1F8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1F90: 4BFF90B9  bl 0x82eeb048
	ctx.lr = 0x82EF1F94;
	sub_82EEB048(ctx, base);
	// 82EF1F94: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EF1F98: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82EF1F9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF1FA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1FA4: 388BCA1C  addi r4, r11, -0x35e4
	ctx.r[4].s64 = ctx.r[11].s64 + -13796;
	// 82EF1FA8: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1FAC: 4BFFFD95  bl 0x82ef1d40
	ctx.lr = 0x82EF1FB0;
	sub_82EF1D40(ctx, base);
	// 82EF1FB0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1FB4: 38EBC9F4  addi r7, r11, -0x360c
	ctx.r[7].s64 = ctx.r[11].s64 + -13836;
	// 82EF1FB8: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1FBC: 38CB0364  addi r6, r11, 0x364
	ctx.r[6].s64 = ctx.r[11].s64 + 868;
	// 82EF1FC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1FC4: 38ABCAA4  addi r5, r11, -0x355c
	ctx.r[5].s64 = ctx.r[11].s64 + -13660;
	// 82EF1FC8: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF1FCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF1FD0: 4BFF9079  bl 0x82eeb048
	ctx.lr = 0x82EF1FD4;
	sub_82EEB048(ctx, base);
	// 82EF1FD4: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EF1FD8: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82EF1FDC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF1FE0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1FE4: 388BC9D0  addi r4, r11, -0x3630
	ctx.r[4].s64 = ctx.r[11].s64 + -13872;
	// 82EF1FE8: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1FEC: 4BFFFD55  bl 0x82ef1d40
	ctx.lr = 0x82EF1FF0;
	sub_82EF1D40(ctx, base);
	// 82EF1FF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF1FF4: 38EBC9C0  addi r7, r11, -0x3640
	ctx.r[7].s64 = ctx.r[11].s64 + -13888;
	// 82EF1FF8: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF1FFC: 38CB0364  addi r6, r11, 0x364
	ctx.r[6].s64 = ctx.r[11].s64 + 868;
	// 82EF2000: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2004: 38ABCAA4  addi r5, r11, -0x355c
	ctx.r[5].s64 = ctx.r[11].s64 + -13660;
	// 82EF2008: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF200C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF2010: 4BFF9039  bl 0x82eeb048
	ctx.lr = 0x82EF2014;
	sub_82EEB048(ctx, base);
	// 82EF2014: 38E00068  li r7, 0x68
	ctx.r[7].s64 = 104;
	// 82EF2018: 38C001CC  li r6, 0x1cc
	ctx.r[6].s64 = 460;
	// 82EF201C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF2020: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2024: 388BC9B4  addi r4, r11, -0x364c
	ctx.r[4].s64 = ctx.r[11].s64 + -13900;
	// 82EF2028: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF202C: 4BFFFD15  bl 0x82ef1d40
	ctx.lr = 0x82EF2030;
	sub_82EF1D40(ctx, base);
	// 82EF2030: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF2034: 80EB0054  lwz r7, 0x54(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF2038: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF203C: 38CB0260  addi r6, r11, 0x260
	ctx.r[6].s64 = ctx.r[11].s64 + 608;
	// 82EF2040: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2044: 38ABC9A0  addi r5, r11, -0x3660
	ctx.r[5].s64 = ctx.r[11].s64 + -13920;
	// 82EF2048: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF204C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF2050: 4BFF8FF9  bl 0x82eeb048
	ctx.lr = 0x82EF2054;
	sub_82EEB048(ctx, base);
	// 82EF2054: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EF2058: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82EF205C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF2060: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2064: 388BC990  addi r4, r11, -0x3670
	ctx.r[4].s64 = ctx.r[11].s64 + -13936;
	// 82EF2068: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF206C: 4BFFFCD5  bl 0x82ef1d40
	ctx.lr = 0x82EF2070;
	sub_82EF1D40(ctx, base);
	// 82EF2070: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82EF2074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF2078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF207C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF2080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF2080 size=92
    let mut pc: u32 = 0x82EF2080;
    'dispatch: loop {
        match pc {
            0x82EF2080 => {
    //   block [0x82EF2080..0x82EF20DC)
	// 82EF2080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF2084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF2088: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF208C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF2090: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF2094: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF2098: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EF209C: D0210094  stfs f1, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EF20A0: D041009C  stfs f2, 0x9c(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EF20A4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF20A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF20AC: 994B0469  stb r10, 0x469(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1129 as u32), ctx.r[10].u8 ) };
	// 82EF20B0: C041009C  lfs f2, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EF20B4: C0210094  lfs f1, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EF20B8: 80C1008C  lwz r6, 0x8c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF20BC: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF20C0: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF20C4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF20C8: 48000019  bl 0x82ef20e0
	ctx.lr = 0x82EF20CC;
	sub_82EF20E0(ctx, base);
	// 82EF20CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF20D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF20D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF20D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF20E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF20E0 size=332
    let mut pc: u32 = 0x82EF20E0;
    'dispatch: loop {
        match pc {
            0x82EF20E0 => {
    //   block [0x82EF20E0..0x82EF2140)
	// 82EF20E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF20E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF20E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF20EC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF20F0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF20F4: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF20F8: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EF20FC: D0210094  stfs f1, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EF2100: D041009C  stfs f2, 0x9c(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EF2104: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2108: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF210C: 914B0494  stw r10, 0x494(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1172 as u32), ctx.r[10].u32 ) };
	// 82EF2110: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2114: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF2118: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82EF211C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82EF2120: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF2124: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF2128: 4BFFB901  bl 0x82eeda28
	ctx.lr = 0x82EF212C;
	sub_82EEDA28(ctx, base);
	// 82EF212C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF2130: 41820010  beq 0x82ef2140
	if ctx.cr[0].eq {
	pc = 0x82EF2140; continue 'dispatch;
	}
	// 82EF2134: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF2138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF213C: 409A0010  bne cr6, 0x82ef214c
	if !ctx.cr[6].eq {
	pc = 0x82EF214C; continue 'dispatch;
	}
	pc = 0x82EF2140; continue 'dispatch;
            }
            0x82EF2140 => {
    //   block [0x82EF2140..0x82EF214C)
	// 82EF2140: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EF2144: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EF2148: 480000D4  b 0x82ef221c
	pc = 0x82EF221C; continue 'dispatch;
            }
            0x82EF214C => {
    //   block [0x82EF214C..0x82EF219C)
	// 82EF214C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2150: 896B0468  lbz r11, 0x468(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1128 as u32) ) } as u64;
	// 82EF2154: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF2158: 4182006C  beq 0x82ef21c4
	if ctx.cr[0].eq {
	pc = 0x82EF21C4; continue 'dispatch;
	}
	// 82EF215C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF2160: 48003481  bl 0x82ef55e0
	ctx.lr = 0x82EF2164;
	sub_82EF55E0(ctx, base);
	// 82EF2164: 3963FFFF  addi r11, r3, -1
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	// 82EF2168: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF216C: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF2170: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EF2174: 2F0B0030  cmpwi cr6, r11, 0x30
	ctx.cr[6].compare_i32(ctx.r[11].s32, 48, &mut ctx.xer);
	// 82EF2178: 41980024  blt cr6, 0x82ef219c
	if ctx.cr[6].lt {
	pc = 0x82EF219C; continue 'dispatch;
	}
	// 82EF217C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF2180: 48003461  bl 0x82ef55e0
	ctx.lr = 0x82EF2184;
	sub_82EF55E0(ctx, base);
	// 82EF2184: 3963FFFF  addi r11, r3, -1
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	// 82EF2188: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF218C: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF2190: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EF2194: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 82EF2198: 4099002C  ble cr6, 0x82ef21c4
	if !ctx.cr[6].gt {
	pc = 0x82EF21C4; continue 'dispatch;
	}
	pc = 0x82EF219C; continue 'dispatch;
            }
            0x82EF219C => {
    //   block [0x82EF219C..0x82EF21C4)
	// 82EF219C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF21A0: 4BFF6501  bl 0x82ee86a0
	ctx.lr = 0x82EF21A4;
	sub_82EE86A0(ctx, base);
	// 82EF21A4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EF21A8: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF21AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF21B0: 388BCAD0  addi r4, r11, -0x3530
	ctx.r[4].s64 = ctx.r[11].s64 + -13616;
	// 82EF21B4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF21B8: 386B0058  addi r3, r11, 0x58
	ctx.r[3].s64 = ctx.r[11].s64 + 88;
	// 82EF21BC: 4800346D  bl 0x82ef5628
	ctx.lr = 0x82EF21C0;
	sub_82EF5628(ctx, base);
	// 82EF21C0: 48000014  b 0x82ef21d4
	pc = 0x82EF21D4; continue 'dispatch;
            }
            0x82EF21C4 => {
    //   block [0x82EF21C4..0x82EF21D4)
	// 82EF21C4: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF21C8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF21CC: 386B0058  addi r3, r11, 0x58
	ctx.r[3].s64 = ctx.r[11].s64 + 88;
	// 82EF21D0: 481FF199  bl 0x830f1368
	ctx.lr = 0x82EF21D4;
	sub_830F1368(ctx, base);
	pc = 0x82EF21D4; continue 'dispatch;
            }
            0x82EF21D4 => {
    //   block [0x82EF21D4..0x82EF2218)
	// 82EF21D4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF21D8: C0010094  lfs f0, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF21DC: D00B048C  stfs f0, 0x48c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1164 as u32), tmp.u32 ) };
	// 82EF21E0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF21E4: C001009C  lfs f0, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF21E8: D00B0490  stfs f0, 0x490(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1168 as u32), tmp.u32 ) };
	// 82EF21EC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF21F0: 388B0058  addi r4, r11, 0x58
	ctx.r[4].s64 = ctx.r[11].s64 + 88;
	// 82EF21F4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF21F8: 4BFFF6A9  bl 0x82ef18a0
	ctx.lr = 0x82EF21FC;
	sub_82EF18A0(ctx, base);
	// 82EF21FC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF2200: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2204: 896B0468  lbz r11, 0x468(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1128 as u32) ) } as u64;
	// 82EF2208: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF220C: 4182000C  beq 0x82ef2218
	if ctx.cr[0].eq {
	pc = 0x82EF2218; continue 'dispatch;
	}
	// 82EF2210: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2214: 4BFFFCCD  bl 0x82ef1ee0
	ctx.lr = 0x82EF2218;
	sub_82EF1EE0(ctx, base);
	pc = 0x82EF2218; continue 'dispatch;
            }
            0x82EF2218 => {
    //   block [0x82EF2218..0x82EF221C)
	// 82EF2218: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82EF221C; continue 'dispatch;
            }
            0x82EF221C => {
    //   block [0x82EF221C..0x82EF222C)
	// 82EF221C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF2220: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF2224: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF2228: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF2230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF2230 size=208
    let mut pc: u32 = 0x82EF2230;
    'dispatch: loop {
        match pc {
            0x82EF2230 => {
    //   block [0x82EF2230..0x82EF2290)
	// 82EF2230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF2234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF2238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF223C: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF2240: 9881008F  stb r4, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[4].u8 ) };
	// 82EF2244: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF2248: 896B0030  lbz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EF224C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF2250: 4082009C  bne 0x82ef22ec
	if !ctx.cr[0].eq {
	pc = 0x82EF22EC; continue 'dispatch;
	}
	// 82EF2254: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF2258: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EF225C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF2260: 4B373E51  bl 0x822660b0
	ctx.lr = 0x82EF2264;
	sub_822660B0(ctx, base);
	// 82EF2264: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EF2268: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF226C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF2270: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF2274: 4098001C  bge cr6, 0x82ef2290
	if !ctx.cr[6].lt {
	pc = 0x82EF2290; continue 'dispatch;
	}
	// 82EF2278: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF227C: 216BFFFF  subfic r11, r11, -1
	ctx.xer.ca = ctx.r[11].u32 <= -1 as u32;
	ctx.r[11].s64 = (-1 as i64) - ctx.r[11].s64;
	// 82EF2280: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF2284: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF2288: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EF228C: 48000014  b 0x82ef22a0
	pc = 0x82EF22A0; continue 'dispatch;
            }
            0x82EF2290 => {
    //   block [0x82EF2290..0x82EF22A0)
	// 82EF2290: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF2294: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF2298: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EF229C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF22A0; continue 'dispatch;
            }
            0x82EF22A0 => {
    //   block [0x82EF22A0..0x82EF22EC)
	// 82EF22A0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF22A4: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF22A8: F96A0038  std r11, 0x38(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), ctx.r[11].u64 ) };
	// 82EF22AC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF22B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EF22B4: 994B0030  stb r10, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 82EF22B8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF22BC: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF22C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF22C4: 419A0028  beq cr6, 0x82ef22ec
	if ctx.cr[6].eq {
	pc = 0x82EF22EC; continue 'dispatch;
	}
	// 82EF22C8: 8881008F  lbz r4, 0x8f(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(143 as u32) ) } as u64;
	// 82EF22CC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF22D0: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF22D4: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF22D8: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF22DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF22E0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF22E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF22E8: 4E800421  bctrl
	ctx.lr = 0x82EF22EC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF22EC => {
    //   block [0x82EF22EC..0x82EF2300)
	// 82EF22EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF22F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF22F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF22F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF22FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF2300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF2300 size=272
    let mut pc: u32 = 0x82EF2300;
    'dispatch: loop {
        match pc {
            0x82EF2300 => {
    //   block [0x82EF2300..0x82EF2360)
	// 82EF2300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF2304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF2308: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF230C: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EF2310: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF2314: 896B0030  lbz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EF2318: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF231C: 418200E0  beq 0x82ef23fc
	if ctx.cr[0].eq {
	pc = 0x82EF23FC; continue 'dispatch;
	}
	// 82EF2320: 4B373D91  bl 0x822660b0
	ctx.lr = 0x82EF2324;
	sub_822660B0(ctx, base);
	// 82EF2324: 786B0020  clrldi r11, r3, 0x20
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 82EF2328: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82EF232C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF2330: E9410060  ld r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EF2334: E96B0038  ld r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	// 82EF2338: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EF233C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82EF2340: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EF2344: 2F2B0000  cmpdi cr6, r11, 0
	ctx.cr[6].compare_i64(ctx.r[11].s64, 0, &mut ctx.xer);
	// 82EF2348: 40980018  bge cr6, 0x82ef2360
	if !ctx.cr[6].lt {
	pc = 0x82EF2360; continue 'dispatch;
	}
	// 82EF234C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EF2350: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EF2354: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82EF2358: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EF235C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	pc = 0x82EF2360; continue 'dispatch;
            }
            0x82EF2360 => {
    //   block [0x82EF2360..0x82EF23C8)
	// 82EF2360: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EF2364: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF2368: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF236C: 916A0048  stw r11, 0x48(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82EF2370: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF2374: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF2378: 994B0030  stb r10, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 82EF237C: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF2380: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF2384: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF2388: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF238C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF2390: 4B32D779  bl 0x8221fb08
	ctx.lr = 0x82EF2394;
	sub_8221FB08(ctx, base);
	// 82EF2394: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF2398: 816B0494  lwz r11, 0x494(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1172 as u32) ) } as u64;
	// 82EF239C: 2B0B00FE  cmplwi cr6, r11, 0xfe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 254 as u32, &mut ctx.xer);
	// 82EF23A0: 419A0028  beq cr6, 0x82ef23c8
	if ctx.cr[6].eq {
	pc = 0x82EF23C8; continue 'dispatch;
	}
	// 82EF23A4: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF23A8: 808B0494  lwz r4, 0x494(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1172 as u32) ) } as u64;
	// 82EF23AC: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF23B0: 386B0498  addi r3, r11, 0x498
	ctx.r[3].s64 = ctx.r[11].s64 + 1176;
	// 82EF23B4: 481FFF05  bl 0x830f22b8
	ctx.lr = 0x82EF23B8;
	sub_830F22B8(ctx, base);
	// 82EF23B8: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF23BC: 388B0498  addi r4, r11, 0x498
	ctx.r[4].s64 = ctx.r[11].s64 + 1176;
	// 82EF23C0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF23C4: 4BFFF28D  bl 0x82ef1650
	ctx.lr = 0x82EF23C8;
	sub_82EF1650(ctx, base);
	pc = 0x82EF23C8; continue 'dispatch;
            }
            0x82EF23C8 => {
    //   block [0x82EF23C8..0x82EF23FC)
	// 82EF23C8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF23CC: 4800356D  bl 0x82ef5938
	ctx.lr = 0x82EF23D0;
	sub_82EF5938(ctx, base);
	// 82EF23D0: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF23D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF23D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF23DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF23E0: 388BCADC  addi r4, r11, -0x3524
	ctx.r[4].s64 = ctx.r[11].s64 + -13604;
	// 82EF23E4: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF23E8: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF23EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF23F0: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF23F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF23F8: 4E800421  bctrl
	ctx.lr = 0x82EF23FC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF23FC => {
    //   block [0x82EF23FC..0x82EF2410)
	// 82EF23FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2400: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EF2404: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF2408: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF240C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF2410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF2410 size=248
    let mut pc: u32 = 0x82EF2410;
    'dispatch: loop {
        match pc {
            0x82EF2410 => {
    //   block [0x82EF2410..0x82EF24C0)
	// 82EF2410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF2414: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF2418: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF241C: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EF2420: 9881009F  stb r4, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[4].u8 ) };
	// 82EF2424: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF2428: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EF242C: 994B04DD  stb r10, 0x4dd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1245 as u32), ctx.r[10].u8 ) };
	// 82EF2430: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF2434: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF2438: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF243C: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF2440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF2444: 4B32D6C5  bl 0x8221fb08
	ctx.lr = 0x82EF2448;
	sub_8221FB08(ctx, base);
	// 82EF2448: 8961009F  lbz r11, 0x9f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(159 as u32) ) } as u64;
	// 82EF244C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF2450: 41820070  beq 0x82ef24c0
	if ctx.cr[0].eq {
	pc = 0x82EF24C0; continue 'dispatch;
	}
	// 82EF2454: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF2458: 480034E1  bl 0x82ef5938
	ctx.lr = 0x82EF245C;
	sub_82EF5938(ctx, base);
	// 82EF245C: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EF2460: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF2464: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF2468: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF246C: 388BCB20  addi r4, r11, -0x34e0
	ctx.r[4].s64 = ctx.r[11].s64 + -13536;
	// 82EF2470: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF2474: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF2478: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF247C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF2480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF2484: 4E800421  bctrl
	ctx.lr = 0x82EF2488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF2488: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF248C: 480034AD  bl 0x82ef5938
	ctx.lr = 0x82EF2490;
	sub_82EF5938(ctx, base);
	// 82EF2490: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82EF2494: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF2498: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF249C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF24A0: 388BCB08  addi r4, r11, -0x34f8
	ctx.r[4].s64 = ctx.r[11].s64 + -13560;
	// 82EF24A4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EF24A8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EF24AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF24B0: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF24B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF24B8: 4E800421  bctrl
	ctx.lr = 0x82EF24BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF24BC: 48000038  b 0x82ef24f4
	pc = 0x82EF24F4; continue 'dispatch;
            }
            0x82EF24C0 => {
    //   block [0x82EF24C0..0x82EF24F4)
	// 82EF24C0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF24C4: 48003475  bl 0x82ef5938
	ctx.lr = 0x82EF24C8;
	sub_82EF5938(ctx, base);
	// 82EF24C8: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF24CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF24D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF24D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF24D8: 388BCAF8  addi r4, r11, -0x3508
	ctx.r[4].s64 = ctx.r[11].s64 + -13576;
	// 82EF24DC: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF24E0: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF24E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF24E8: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF24EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF24F0: 4E800421  bctrl
	ctx.lr = 0x82EF24F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF24F4 => {
    //   block [0x82EF24F4..0x82EF2508)
	// 82EF24F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF24F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EF24FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF2500: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF2504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF2508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF2508 size=192
    let mut pc: u32 = 0x82EF2508;
    'dispatch: loop {
        match pc {
            0x82EF2508 => {
    //   block [0x82EF2508..0x82EF2554)
	// 82EF2508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF250C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF2510: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF2514: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF2518: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF251C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2520: 808B0480  lwz r4, 0x480(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1152 as u32) ) } as u64;
	// 82EF2524: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2528: 4BFFE8C9  bl 0x82ef0df0
	ctx.lr = 0x82EF252C;
	sub_82EF0DF0(ctx, base);
	// 82EF252C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2530: 808B047C  lwz r4, 0x47c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1148 as u32) ) } as u64;
	// 82EF2534: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2538: 4BFFE8B9  bl 0x82ef0df0
	ctx.lr = 0x82EF253C;
	sub_82EF0DF0(ctx, base);
	// 82EF253C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF2540: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF2544: 409A0010  bne cr6, 0x82ef2554
	if !ctx.cr[6].eq {
	pc = 0x82EF2554; continue 'dispatch;
	}
	// 82EF2548: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EF254C: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EF2550: 48000068  b 0x82ef25b8
	pc = 0x82EF25B8; continue 'dispatch;
            }
            0x82EF2554 => {
    //   block [0x82EF2554..0x82EF25A8)
	// 82EF2554: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EF2558: 80C1007C  lwz r6, 0x7c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF255C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2560: 38ABC898  addi r5, r11, -0x3768
	ctx.r[5].s64 = ctx.r[11].s64 + -14184;
	// 82EF2564: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2568: 388BCB34  addi r4, r11, -0x34cc
	ctx.r[4].s64 = ctx.r[11].s64 + -13516;
	// 82EF256C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2570: 816B0478  lwz r11, 0x478(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1144 as u32) ) } as u64;
	// 82EF2574: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2578: 806A0478  lwz r3, 0x478(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1144 as u32) ) } as u64;
	// 82EF257C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF2580: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF2584: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF2588: 4E800421  bctrl
	ctx.lr = 0x82EF258C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF258C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF2590: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF2594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF2598: 409A0010  bne cr6, 0x82ef25a8
	if !ctx.cr[6].eq {
	pc = 0x82EF25A8; continue 'dispatch;
	}
	// 82EF259C: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 82EF25A0: 61630057  ori r3, r11, 0x57
	ctx.r[3].u64 = ctx.r[11].u64 | 87;
	// 82EF25A4: 48000014  b 0x82ef25b8
	pc = 0x82EF25B8; continue 'dispatch;
            }
            0x82EF25A8 => {
    //   block [0x82EF25A8..0x82EF25B8)
	// 82EF25A8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF25AC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF25B0: 4BFFE841  bl 0x82ef0df0
	ctx.lr = 0x82EF25B4;
	sub_82EF0DF0(ctx, base);
	// 82EF25B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EF25B8; continue 'dispatch;
            }
            0x82EF25B8 => {
    //   block [0x82EF25B8..0x82EF25C8)
	// 82EF25B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF25BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF25C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF25C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF25C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF25C8 size=316
    let mut pc: u32 = 0x82EF25C8;
    'dispatch: loop {
        match pc {
            0x82EF25C8 => {
    //   block [0x82EF25C8..0x82EF2704)
	// 82EF25C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF25CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF25D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF25D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF25D8: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF25DC: 906101C4  stw r3, 0x1c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), ctx.r[3].u32 ) };
	// 82EF25E0: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF25E4: 48003385  bl 0x82ef5968
	ctx.lr = 0x82EF25E8;
	sub_82EF5968(ctx, base);
	// 82EF25E8: 480057D1  bl 0x82ef7db8
	ctx.lr = 0x82EF25EC;
	sub_82EF7DB8(ctx, base);
	// 82EF25EC: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF25F0: 48003349  bl 0x82ef5938
	ctx.lr = 0x82EF25F4;
	sub_82EF5938(ctx, base);
	// 82EF25F4: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82EF25F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF25FC: 4800313D  bl 0x82ef5738
	ctx.lr = 0x82EF2600;
	sub_82EF5738(ctx, base);
	// 82EF2600: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2604: 48003335  bl 0x82ef5938
	ctx.lr = 0x82EF2608;
	sub_82EF5938(ctx, base);
	// 82EF2608: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82EF260C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF2610: 480030E1  bl 0x82ef56f0
	ctx.lr = 0x82EF2614;
	sub_82EF56F0(ctx, base);
	// 82EF2614: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2618: 38CB0260  addi r6, r11, 0x260
	ctx.r[6].s64 = ctx.r[11].s64 + 608;
	// 82EF261C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2620: 38ABC47C  addi r5, r11, -0x3b84
	ctx.r[5].s64 = ctx.r[11].s64 + -15236;
	// 82EF2624: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EF2628: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82EF262C: 4BFF8A1D  bl 0x82eeb048
	ctx.lr = 0x82EF2630;
	sub_82EEB048(ctx, base);
	// 82EF2630: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 82EF2634: 3BC10090  addi r30, r1, 0x90
	ctx.r[30].s64 = ctx.r[1].s64 + 144;
	// 82EF2638: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF263C: 806B0470  lwz r3, 0x470(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1136 as u32) ) } as u64;
	// 82EF2640: 480032E9  bl 0x82ef5928
	ctx.lr = 0x82EF2644;
	sub_82EF5928(ctx, base);
	// 82EF2644: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF2648: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF264C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF2650: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EF2654: 4800A81D  bl 0x82efce70
	ctx.lr = 0x82EF2658;
	sub_82EFCE70(ctx, base);
	// 82EF2658: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF265C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF2660: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82EF2664: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2668: 48003301  bl 0x82ef5968
	ctx.lr = 0x82EF266C;
	sub_82EF5968(ctx, base);
	// 82EF266C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82EF2670: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EF2674: 816101C4  lwz r11, 0x1c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2678: 816B0470  lwz r11, 0x470(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1136 as u32) ) } as u64;
	// 82EF267C: 814101C4  lwz r10, 0x1c4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2680: 806A0470  lwz r3, 0x470(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1136 as u32) ) } as u64;
	// 82EF2684: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF2688: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EF268C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF2690: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF2694: 4E800421  bctrl
	ctx.lr = 0x82EF2698;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF2698: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF269C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF26A0: 480032C9  bl 0x82ef5968
	ctx.lr = 0x82EF26A4;
	sub_82EF5968(ctx, base);
	// 82EF26A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF26A8: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF26AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF26B0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF26B4: 480FC095  bl 0x82fee748
	ctx.lr = 0x82EF26B8;
	sub_82FEE748(ctx, base);
	// 82EF26B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF26BC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF26C0: 4BFFB471  bl 0x82eedb30
	ctx.lr = 0x82EF26C4;
	sub_82EEDB30(ctx, base);
	// 82EF26C4: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF26C8: 480032A1  bl 0x82ef5968
	ctx.lr = 0x82EF26CC;
	sub_82EF5968(ctx, base);
	// 82EF26CC: 48005BCD  bl 0x82ef8298
	ctx.lr = 0x82EF26D0;
	sub_82EF8298(ctx, base);
	// 82EF26D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF26D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF26D8: C02B0AA0  lfs f1, 0xaa0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2720 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EF26DC: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF26E0: 480FBD11  bl 0x82fee3f0
	ctx.lr = 0x82EF26E4;
	sub_82FEE3F0(ctx, base);
	// 82EF26E4: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF26E8: 48001211  bl 0x82ef38f8
	ctx.lr = 0x82EF26EC;
	sub_82EF38F8(ctx, base);
	// 82EF26EC: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 82EF26F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF26F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF26F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF26FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF2700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF2708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF2708 size=904
    let mut pc: u32 = 0x82EF2708;
    'dispatch: loop {
        match pc {
            0x82EF2708 => {
    //   block [0x82EF2708..0x82EF275C)
	// 82EF2708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF270C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF2710: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF2714: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF2718: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF271C: 90610134  stw r3, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[3].u32 ) };
	// 82EF2720: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2724: 896B0488  lbz r11, 0x488(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EF2728: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF272C: 41820030  beq 0x82ef275c
	if ctx.cr[0].eq {
	pc = 0x82EF275C; continue 'dispatch;
	}
	// 82EF2730: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2734: 4BFFFE95  bl 0x82ef25c8
	ctx.lr = 0x82EF2738;
	sub_82EF25C8(ctx, base);
	// 82EF2738: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF273C: 388BCB84  addi r4, r11, -0x347c
	ctx.r[4].s64 = ctx.r[11].s64 + -13436;
	// 82EF2740: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2744: 4BFFF15D  bl 0x82ef18a0
	ctx.lr = 0x82EF2748;
	sub_82EF18A0(ctx, base);
	// 82EF2748: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF274C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF2750: 994B0488  stb r10, 0x488(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1160 as u32), ctx.r[10].u8 ) };
	// 82EF2754: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2758: 48000320  b 0x82ef2a78
	pc = 0x82EF2A78; continue 'dispatch;
            }
            0x82EF275C => {
    //   block [0x82EF275C..0x82EF2798)
	// 82EF275C: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2760: 896B0489  lbz r11, 0x489(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1161 as u32) ) } as u64;
	// 82EF2764: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF2768: 41820030  beq 0x82ef2798
	if ctx.cr[0].eq {
	pc = 0x82EF2798; continue 'dispatch;
	}
	// 82EF276C: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2770: 4BFFFE59  bl 0x82ef25c8
	ctx.lr = 0x82EF2774;
	sub_82EF25C8(ctx, base);
	// 82EF2774: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2778: 388B0058  addi r4, r11, 0x58
	ctx.r[4].s64 = ctx.r[11].s64 + 88;
	// 82EF277C: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2780: 4BFFF121  bl 0x82ef18a0
	ctx.lr = 0x82EF2784;
	sub_82EF18A0(ctx, base);
	// 82EF2784: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2788: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF278C: 994B0489  stb r10, 0x489(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1161 as u32), ctx.r[10].u8 ) };
	// 82EF2790: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2794: 480002E4  b 0x82ef2a78
	pc = 0x82EF2A78; continue 'dispatch;
            }
            0x82EF2798 => {
    //   block [0x82EF2798..0x82EF27B8)
	// 82EF2798: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF279C: 896B0030  lbz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EF27A0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF27A4: 40820014  bne 0x82ef27b8
	if !ctx.cr[0].eq {
	pc = 0x82EF27B8; continue 'dispatch;
	}
	// 82EF27A8: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF27AC: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF27B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF27B4: 409A000C  bne cr6, 0x82ef27c0
	if !ctx.cr[6].eq {
	pc = 0x82EF27C0; continue 'dispatch;
	}
	pc = 0x82EF27B8; continue 'dispatch;
            }
            0x82EF27B8 => {
    //   block [0x82EF27B8..0x82EF27C0)
	// 82EF27B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF27BC: 480002BC  b 0x82ef2a78
	pc = 0x82EF2A78; continue 'dispatch;
            }
            0x82EF27C0 => {
    //   block [0x82EF27C0..0x82EF27FC)
	// 82EF27C0: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF27C4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EF27C8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EF27CC: 4B3738E5  bl 0x822660b0
	ctx.lr = 0x82EF27D0;
	sub_822660B0(ctx, base);
	// 82EF27D0: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82EF27D4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF27D8: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF27DC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF27E0: 4098001C  bge cr6, 0x82ef27fc
	if !ctx.cr[6].lt {
	pc = 0x82EF27FC; continue 'dispatch;
	}
	// 82EF27E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF27E8: 216BFFFF  subfic r11, r11, -1
	ctx.xer.ca = ctx.r[11].u32 <= -1 as u32;
	ctx.r[11].s64 = (-1 as i64) - ctx.r[11].s64;
	// 82EF27EC: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF27F0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF27F4: 916100D4  stw r11, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 82EF27F8: 48000014  b 0x82ef280c
	pc = 0x82EF280C; continue 'dispatch;
            }
            0x82EF27FC => {
    //   block [0x82EF27FC..0x82EF280C)
	// 82EF27FC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF2800: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF2804: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EF2808: 916100D4  stw r11, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF280C; continue 'dispatch;
            }
            0x82EF280C => {
    //   block [0x82EF280C..0x82EF2828)
	// 82EF280C: 816100D4  lwz r11, 0xd4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EF2810: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF2814: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF2818: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 82EF281C: 4098000C  bge cr6, 0x82ef2828
	if !ctx.cr[6].lt {
	pc = 0x82EF2828; continue 'dispatch;
	}
	// 82EF2820: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EF2824: 48000254  b 0x82ef2a78
	pc = 0x82EF2A78; continue 'dispatch;
            }
            0x82EF2828 => {
    //   block [0x82EF2828..0x82EF2884)
	// 82EF2828: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF282C: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82EF2830: F96100D8  std r11, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u64 ) };
	// 82EF2834: C80100D8  lfd f0, 0xd8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 82EF2838: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82EF283C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82EF2840: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82EF2844: C1AB9404  lfs f13, -0x6bfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EF2848: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EF284C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EF2850: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2854: 816B0494  lwz r11, 0x494(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1172 as u32) ) } as u64;
	// 82EF2858: 2B0B00FE  cmplwi cr6, r11, 0xfe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 254 as u32, &mut ctx.xer);
	// 82EF285C: 419A0028  beq cr6, 0x82ef2884
	if ctx.cr[6].eq {
	pc = 0x82EF2884; continue 'dispatch;
	}
	// 82EF2860: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2864: 808B0494  lwz r4, 0x494(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1172 as u32) ) } as u64;
	// 82EF2868: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF286C: 386B0498  addi r3, r11, 0x498
	ctx.r[3].s64 = ctx.r[11].s64 + 1176;
	// 82EF2870: 481FFA49  bl 0x830f22b8
	ctx.lr = 0x82EF2874;
	sub_830F22B8(ctx, base);
	// 82EF2874: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2878: 388B0498  addi r4, r11, 0x498
	ctx.r[4].s64 = ctx.r[11].s64 + 1176;
	// 82EF287C: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2880: 4BFFEDD1  bl 0x82ef1650
	ctx.lr = 0x82EF2884;
	sub_82EF1650(ctx, base);
	pc = 0x82EF2884; continue 'dispatch;
            }
            0x82EF2884 => {
    //   block [0x82EF2884..0x82EF28E4)
	// 82EF2884: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2888: 816B04D8  lwz r11, 0x4d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82EF288C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF2890: 419A01B8  beq cr6, 0x82ef2a48
	if ctx.cr[6].eq {
	pc = 0x82EF2A48; continue 'dispatch;
	}
	// 82EF2894: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2898: 808B0494  lwz r4, 0x494(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1172 as u32) ) } as u64;
	// 82EF289C: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF28A0: 806B04D8  lwz r3, 0x4d8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82EF28A4: 4BFFD8AD  bl 0x82ef0150
	ctx.lr = 0x82EF28A8;
	sub_82EF0150(ctx, base);
	// 82EF28A8: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF28AC: 806B04D8  lwz r3, 0x4d8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82EF28B0: 4BFFDA61  bl 0x82ef0310
	ctx.lr = 0x82EF28B4;
	sub_82EF0310(ctx, base);
	// 82EF28B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF28B8: 41820190  beq 0x82ef2a48
	if ctx.cr[0].eq {
	pc = 0x82EF2A48; continue 'dispatch;
	}
	// 82EF28BC: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF28C0: 896B04DC  lbz r11, 0x4dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1244 as u32) ) } as u64;
	// 82EF28C4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF28C8: 40820180  bne 0x82ef2a48
	if !ctx.cr[0].eq {
	pc = 0x82EF2A48; continue 'dispatch;
	}
	// 82EF28CC: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF28D0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EF28D4: 994B04DC  stb r10, 0x4dc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1244 as u32), ctx.r[10].u8 ) };
	// 82EF28D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF28DC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EF28E0: 48000010  b 0x82ef28f0
	pc = 0x82EF28F0; continue 'dispatch;
            }
            0x82EF28E4 => {
    //   block [0x82EF28E4..0x82EF28F0)
	// 82EF28E4: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EF28E8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EF28EC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF28F0; continue 'dispatch;
            }
            0x82EF28F0 => {
    //   block [0x82EF28F0..0x82EF29FC)
	// 82EF28F0: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF28F4: 816B04D8  lwz r11, 0x4d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82EF28F8: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF28FC: 4800134D  bl 0x82ef3c48
	ctx.lr = 0x82EF2900;
	sub_82EF3C48(ctx, base);
	// 82EF2900: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EF2904: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EF2908: 409800F4  bge cr6, 0x82ef29fc
	if !ctx.cr[6].lt {
	pc = 0x82EF29FC; continue 'dispatch;
	}
	// 82EF290C: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EF2910: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2914: 816B04D8  lwz r11, 0x4d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82EF2918: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF291C: 48001375  bl 0x82ef3c90
	ctx.lr = 0x82EF2920;
	sub_82EF3C90(ctx, base);
	// 82EF2920: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF2924: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82EF2928: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF292C: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF2930: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 82EF2934: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF2938: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EF293C: 4B32D1CD  bl 0x8221fb08
	ctx.lr = 0x82EF2940;
	sub_8221FB08(ctx, base);
	// 82EF2940: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EF2944: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82EF2948: F96100E0  std r11, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u64 ) };
	// 82EF294C: C80100E0  lfd f0, 0xe0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 82EF2950: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF2954: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EF2958: 48002E91  bl 0x82ef57e8
	ctx.lr = 0x82EF295C;
	sub_82EF57E8(ctx, base);
	// 82EF295C: 806100D0  lwz r3, 0xd0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EF2960: 4BFF5BD9  bl 0x82ee8538
	ctx.lr = 0x82EF2964;
	sub_82EE8538(ctx, base);
	// 82EF2964: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF2968: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82EF296C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82EF2970: 48002EA1  bl 0x82ef5810
	ctx.lr = 0x82EF2974;
	sub_82EF5810(ctx, base);
	// 82EF2974: 806100D0  lwz r3, 0xd0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EF2978: 4BFF5CB9  bl 0x82ee8630
	ctx.lr = 0x82EF297C;
	sub_82EE8630(ctx, base);
	// 82EF297C: F86100E8  std r3, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[3].u64 ) };
	// 82EF2980: C80100E8  lfd f0, 0xe8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	// 82EF2984: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF2988: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82EF298C: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 82EF2990: 48002E59  bl 0x82ef57e8
	ctx.lr = 0x82EF2994;
	sub_82EF57E8(ctx, base);
	// 82EF2994: 806100D0  lwz r3, 0xd0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EF2998: 4BFF5E69  bl 0x82ee8800
	ctx.lr = 0x82EF299C;
	sub_82EE8800(ctx, base);
	// 82EF299C: F86100F0  std r3, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[3].u64 ) };
	// 82EF29A0: C80100F0  lfd f0, 0xf0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) };
	// 82EF29A4: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF29A8: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82EF29AC: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 82EF29B0: 48002E39  bl 0x82ef57e8
	ctx.lr = 0x82EF29B4;
	sub_82EF57E8(ctx, base);
	// 82EF29B4: 806100D0  lwz r3, 0xd0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EF29B8: 4BFFF361  bl 0x82ef1d18
	ctx.lr = 0x82EF29BC;
	sub_82EF1D18(ctx, base);
	// 82EF29BC: F86100F8  std r3, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[3].u64 ) };
	// 82EF29C0: C80100F8  lfd f0, 0xf8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 82EF29C4: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF29C8: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82EF29CC: 386B0040  addi r3, r11, 0x40
	ctx.r[3].s64 = ctx.r[11].s64 + 64;
	// 82EF29D0: 48002E19  bl 0x82ef57e8
	ctx.lr = 0x82EF29D4;
	sub_82EF57E8(ctx, base);
	// 82EF29D4: 3BE10080  addi r31, r1, 0x80
	ctx.r[31].s64 = ctx.r[1].s64 + 128;
	// 82EF29D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF29DC: 3BCBCB64  addi r30, r11, -0x349c
	ctx.r[30].s64 = ctx.r[11].s64 + -13468;
	// 82EF29E0: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF29E4: 48002F55  bl 0x82ef5938
	ctx.lr = 0x82EF29E8;
	sub_82EF5938(ctx, base);
	// 82EF29E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF29EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF29F0: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 82EF29F4: 48002E45  bl 0x82ef5838
	ctx.lr = 0x82EF29F8;
	sub_82EF5838(ctx, base);
	// 82EF29F8: 4BFFFEEC  b 0x82ef28e4
	pc = 0x82EF28E4; continue 'dispatch;
            }
            0x82EF29FC => {
    //   block [0x82EF29FC..0x82EF2A48)
	// 82EF29FC: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF2A00: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF2A04: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF2A08: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF2A0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EF2A10: 4B32D0F9  bl 0x8221fb08
	ctx.lr = 0x82EF2A14;
	sub_8221FB08(ctx, base);
	// 82EF2A14: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2A18: 48002F21  bl 0x82ef5938
	ctx.lr = 0x82EF2A1C;
	sub_82EF5938(ctx, base);
	// 82EF2A1C: 90610100  stw r3, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[3].u32 ) };
	// 82EF2A20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF2A24: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EF2A28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2A2C: 388BCB48  addi r4, r11, -0x34b8
	ctx.r[4].s64 = ctx.r[11].s64 + -13496;
	// 82EF2A30: 80610100  lwz r3, 0x100(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) } as u64;
	// 82EF2A34: 81610100  lwz r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) } as u64;
	// 82EF2A38: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF2A3C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF2A40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF2A44: 4E800421  bctrl
	ctx.lr = 0x82EF2A48;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF2A48 => {
    //   block [0x82EF2A48..0x82EF2A68)
	// 82EF2A48: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2A4C: 48002EED  bl 0x82ef5938
	ctx.lr = 0x82EF2A50;
	sub_82EF5938(ctx, base);
	// 82EF2A50: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EF2A54: 41820014  beq 0x82ef2a68
	if ctx.cr[0].eq {
	pc = 0x82EF2A68; continue 'dispatch;
	}
	// 82EF2A58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF2A5C: C0210054  lfs f1, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EF2A60: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2A64: 480FB98D  bl 0x82fee3f0
	ctx.lr = 0x82EF2A68;
	sub_82FEE3F0(ctx, base);
	pc = 0x82EF2A68; continue 'dispatch;
            }
            0x82EF2A68 => {
    //   block [0x82EF2A68..0x82EF2A78)
	// 82EF2A68: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2A6C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF2A70: 914B0048  stw r10, 0x48(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 82EF2A74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EF2A78; continue 'dispatch;
            }
            0x82EF2A78 => {
    //   block [0x82EF2A78..0x82EF2A90)
	// 82EF2A78: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82EF2A7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF2A80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF2A84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF2A88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF2A8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF2A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF2A90 size=44
    let mut pc: u32 = 0x82EF2A90;
    'dispatch: loop {
        match pc {
            0x82EF2A90 => {
    //   block [0x82EF2A90..0x82EF2ABC)
	// 82EF2A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF2A94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF2A98: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF2A9C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF2AA0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF2AA4: 480FBA05  bl 0x82fee4a8
	ctx.lr = 0x82EF2AA8;
	sub_82FEE4A8(ctx, base);
	// 82EF2AA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2AAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF2AB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF2AB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF2AB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF2AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF2AC0 size=3148
    let mut pc: u32 = 0x82EF2AC0;
    'dispatch: loop {
        match pc {
            0x82EF2AC0 => {
    //   block [0x82EF2AC0..0x82EF2B10)
	// 82EF2AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF2AC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF2AC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF2ACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF2AD0: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF2AD4: 906101B4  stw r3, 0x1b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(436 as u32), ctx.r[3].u32 ) };
	// 82EF2AD8: 908101BC  stw r4, 0x1bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(444 as u32), ctx.r[4].u32 ) };
	// 82EF2ADC: 90A101C4  stw r5, 0x1c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), ctx.r[5].u32 ) };
	// 82EF2AE0: 90C101CC  stw r6, 0x1cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), ctx.r[6].u32 ) };
	// 82EF2AE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF2AE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2AEC: 388BCCC8  addi r4, r11, -0x3338
	ctx.r[4].s64 = ctx.r[11].s64 + -13112;
	// 82EF2AF0: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2AF4: 48001E6D  bl 0x82ef4960
	ctx.lr = 0x82EF2AF8;
	sub_82EF4960(ctx, base);
	// 82EF2AF8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF2AFC: 41820014  beq 0x82ef2b10
	if ctx.cr[0].eq {
	pc = 0x82EF2B10; continue 'dispatch;
	}
	// 82EF2B00: 808101CC  lwz r4, 0x1cc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF2B04: 806101B4  lwz r3, 0x1b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2B08: 48000C09  bl 0x82ef3710
	ctx.lr = 0x82EF2B0C;
	sub_82EF3710(ctx, base);
	// 82EF2B0C: 48000BE8  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF2B10 => {
    //   block [0x82EF2B10..0x82EF2B3C)
	// 82EF2B10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF2B14: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EF2B18: 388B29C8  addi r4, r11, 0x29c8
	ctx.r[4].s64 = ctx.r[11].s64 + 10696;
	// 82EF2B1C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2B20: 48001E41  bl 0x82ef4960
	ctx.lr = 0x82EF2B24;
	sub_82EF4960(ctx, base);
	// 82EF2B24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF2B28: 41820014  beq 0x82ef2b3c
	if ctx.cr[0].eq {
	pc = 0x82EF2B3C; continue 'dispatch;
	}
	// 82EF2B2C: 808101CC  lwz r4, 0x1cc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF2B30: 806101B4  lwz r3, 0x1b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2B34: 48000CDD  bl 0x82ef3810
	ctx.lr = 0x82EF2B38;
	sub_82EF3810(ctx, base);
	// 82EF2B38: 48000BBC  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF2B3C => {
    //   block [0x82EF2B3C..0x82EF2B64)
	// 82EF2B3C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF2B40: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2B44: 388BCCC0  addi r4, r11, -0x3340
	ctx.r[4].s64 = ctx.r[11].s64 + -13120;
	// 82EF2B48: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2B4C: 48001E15  bl 0x82ef4960
	ctx.lr = 0x82EF2B50;
	sub_82EF4960(ctx, base);
	// 82EF2B50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF2B54: 41820010  beq 0x82ef2b64
	if ctx.cr[0].eq {
	pc = 0x82EF2B64; continue 'dispatch;
	}
	// 82EF2B58: 806101B4  lwz r3, 0x1b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2B5C: 48000D9D  bl 0x82ef38f8
	ctx.lr = 0x82EF2B60;
	sub_82EF38F8(ctx, base);
	// 82EF2B60: 48000B94  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF2B64 => {
    //   block [0x82EF2B64..0x82EF2B8C)
	// 82EF2B64: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF2B68: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2B6C: 388BCCB4  addi r4, r11, -0x334c
	ctx.r[4].s64 = ctx.r[11].s64 + -13132;
	// 82EF2B70: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2B74: 48001DED  bl 0x82ef4960
	ctx.lr = 0x82EF2B78;
	sub_82EF4960(ctx, base);
	// 82EF2B78: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF2B7C: 41820010  beq 0x82ef2b8c
	if ctx.cr[0].eq {
	pc = 0x82EF2B8C; continue 'dispatch;
	}
	// 82EF2B80: 806101B4  lwz r3, 0x1b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2B84: 48000EE5  bl 0x82ef3a68
	ctx.lr = 0x82EF2B88;
	sub_82EF3A68(ctx, base);
	// 82EF2B88: 48000B6C  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF2B8C => {
    //   block [0x82EF2B8C..0x82EF2BAC)
	// 82EF2B8C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF2B90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2B94: 388BCCAC  addi r4, r11, -0x3354
	ctx.r[4].s64 = ctx.r[11].s64 + -13140;
	// 82EF2B98: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2B9C: 48001DC5  bl 0x82ef4960
	ctx.lr = 0x82EF2BA0;
	sub_82EF4960(ctx, base);
	// 82EF2BA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF2BA4: 41820008  beq 0x82ef2bac
	if ctx.cr[0].eq {
	pc = 0x82EF2BAC; continue 'dispatch;
	}
	// 82EF2BA8: 48000B4C  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF2BAC => {
    //   block [0x82EF2BAC..0x82EF2CB0)
	// 82EF2BAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF2BB0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2BB4: 388BCC94  addi r4, r11, -0x336c
	ctx.r[4].s64 = ctx.r[11].s64 + -13164;
	// 82EF2BB8: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2BBC: 48001DA5  bl 0x82ef4960
	ctx.lr = 0x82EF2BC0;
	sub_82EF4960(ctx, base);
	// 82EF2BC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF2BC4: 418200FC  beq 0x82ef2cc0
	if ctx.cr[0].eq {
	pc = 0x82EF2CC0; continue 'dispatch;
	}
	// 82EF2BC8: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82EF2BCC: 91610130  stw r11, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 82EF2BD0: 81610130  lwz r11, 0x130(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(304 as u32) ) } as u64;
	// 82EF2BD4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EF2BD8: 814ACC90  lwz r10, -0x3370(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13168 as u32) ) } as u64;
	// 82EF2BDC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF2BE0: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82EF2BE4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EF2BE8: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF2BEC: 4BDB9FBD  bl 0x82cacba8
	ctx.lr = 0x82EF2BF0;
	sub_82CACBA8(ctx, base);
	// 82EF2BF0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF2BF4: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82EF2BF8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EF2BFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2C00: 4BDB9FA9  bl 0x82cacba8
	ctx.lr = 0x82EF2C04;
	sub_82CACBA8(ctx, base);
	// 82EF2C04: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF2C08: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EF2C0C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF2C10: 48002679  bl 0x82ef5288
	ctx.lr = 0x82EF2C14;
	sub_82EF5288(ctx, base);
	// 82EF2C14: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82EF2C18: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EF2C1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2C20: 4BDB9F89  bl 0x82cacba8
	ctx.lr = 0x82EF2C24;
	sub_82CACBA8(ctx, base);
	// 82EF2C24: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF2C28: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82EF2C2C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EF2C30: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2C34: 4BDB9F75  bl 0x82cacba8
	ctx.lr = 0x82EF2C38;
	sub_82CACBA8(ctx, base);
	// 82EF2C38: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF2C3C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82EF2C40: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF2C44: 48002645  bl 0x82ef5288
	ctx.lr = 0x82EF2C48;
	sub_82EF5288(ctx, base);
	// 82EF2C48: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF2C4C: 7D6407B4  extsw r4, r11
	ctx.r[4].s64 = ctx.r[11].s32 as i64;
	// 82EF2C50: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2C54: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF2C58: 4BFF59E9  bl 0x82ee8640
	ctx.lr = 0x82EF2C5C;
	sub_82EE8640(ctx, base);
	// 82EF2C5C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF2C60: 7D6407B4  extsw r4, r11
	ctx.r[4].s64 = ctx.r[11].s32 as i64;
	// 82EF2C64: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2C68: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF2C6C: 4BFF5BA5  bl 0x82ee8810
	ctx.lr = 0x82EF2C70;
	sub_82EE8810(ctx, base);
	// 82EF2C70: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2C74: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF2C78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF2C7C: 419A0034  beq cr6, 0x82ef2cb0
	if ctx.cr[6].eq {
	pc = 0x82EF2CB0; continue 'dispatch;
	}
	// 82EF2C80: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF2C84: 7D6507B4  extsw r5, r11
	ctx.r[5].s64 = ctx.r[11].s32 as i64;
	// 82EF2C88: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF2C8C: 7D6407B4  extsw r4, r11
	ctx.r[4].s64 = ctx.r[11].s32 as i64;
	// 82EF2C90: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2C94: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF2C98: 814101B4  lwz r10, 0x1b4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2C9C: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF2CA0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF2CA4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF2CA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF2CAC: 4E800421  bctrl
	ctx.lr = 0x82EF2CB0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF2CB0 => {
    //   block [0x82EF2CB0..0x82EF2CC0)
	// 82EF2CB0: 808101CC  lwz r4, 0x1cc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF2CB4: 806101B4  lwz r3, 0x1b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2CB8: 48000A59  bl 0x82ef3710
	ctx.lr = 0x82EF2CBC;
	sub_82EF3710(ctx, base);
	// 82EF2CBC: 48000A38  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF2CC0 => {
    //   block [0x82EF2CC0..0x82EF2D28)
	// 82EF2CC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF2CC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2CC8: 388BCC80  addi r4, r11, -0x3380
	ctx.r[4].s64 = ctx.r[11].s64 + -13184;
	// 82EF2CCC: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2CD0: 48001C91  bl 0x82ef4960
	ctx.lr = 0x82EF2CD4;
	sub_82EF4960(ctx, base);
	// 82EF2CD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF2CD8: 41820054  beq 0x82ef2d2c
	if ctx.cr[0].eq {
	pc = 0x82EF2D2C; continue 'dispatch;
	}
	// 82EF2CDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF2CE0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EF2CE4: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82EF2CE8: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF2CEC: 4800259D  bl 0x82ef5288
	ctx.lr = 0x82EF2CF0;
	sub_82EF5288(ctx, base);
	// 82EF2CF0: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2CF4: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF2CF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF2CFC: 419A002C  beq cr6, 0x82ef2d28
	if ctx.cr[6].eq {
	pc = 0x82EF2D28; continue 'dispatch;
	}
	// 82EF2D00: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EF2D04: 7D6407B4  extsw r4, r11
	ctx.r[4].s64 = ctx.r[11].s32 as i64;
	// 82EF2D08: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2D0C: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF2D10: 814101B4  lwz r10, 0x1b4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2D14: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF2D18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF2D1C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EF2D20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF2D24: 4E800421  bctrl
	ctx.lr = 0x82EF2D28;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF2D28 => {
    //   block [0x82EF2D28..0x82EF2D2C)
	// 82EF2D28: 480009CC  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF2D2C => {
    //   block [0x82EF2D2C..0x82EF2ED4)
	// 82EF2D2C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF2D30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2D34: 388BCC6C  addi r4, r11, -0x3394
	ctx.r[4].s64 = ctx.r[11].s64 + -13204;
	// 82EF2D38: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2D3C: 48001C25  bl 0x82ef4960
	ctx.lr = 0x82EF2D40;
	sub_82EF4960(ctx, base);
	// 82EF2D40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF2D44: 418201A0  beq 0x82ef2ee4
	if ctx.cr[0].eq {
	pc = 0x82EF2EE4; continue 'dispatch;
	}
	// 82EF2D48: 3961007C  addi r11, r1, 0x7c
	ctx.r[11].s64 = ctx.r[1].s64 + 124;
	// 82EF2D4C: 91610134  stw r11, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 82EF2D50: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EF2D54: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EF2D58: 814ACC90  lwz r10, -0x3370(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13168 as u32) ) } as u64;
	// 82EF2D5C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF2D60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF2D64: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EF2D68: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EF2D6C: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EF2D70: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF2D74: 4BDB9E35  bl 0x82cacba8
	ctx.lr = 0x82EF2D78;
	sub_82CACBA8(ctx, base);
	// 82EF2D78: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF2D7C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EF2D80: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EF2D84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2D88: 4BDB9E21  bl 0x82cacba8
	ctx.lr = 0x82EF2D8C;
	sub_82CACBA8(ctx, base);
	// 82EF2D8C: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF2D90: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EF2D94: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF2D98: 480024F1  bl 0x82ef5288
	ctx.lr = 0x82EF2D9C;
	sub_82EF5288(ctx, base);
	// 82EF2D9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF2DA0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EF2DA4: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EF2DA8: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EF2DAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2DB0: 4BDB9DF9  bl 0x82cacba8
	ctx.lr = 0x82EF2DB4;
	sub_82CACBA8(ctx, base);
	// 82EF2DB4: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF2DB8: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EF2DBC: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EF2DC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2DC4: 4BDB9DE5  bl 0x82cacba8
	ctx.lr = 0x82EF2DC8;
	sub_82CACBA8(ctx, base);
	// 82EF2DC8: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF2DCC: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 82EF2DD0: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF2DD4: 480024B5  bl 0x82ef5288
	ctx.lr = 0x82EF2DD8;
	sub_82EF5288(ctx, base);
	// 82EF2DD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF2DDC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EF2DE0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EF2DE4: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EF2DE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2DEC: 4BDB9DBD  bl 0x82cacba8
	ctx.lr = 0x82EF2DF0;
	sub_82CACBA8(ctx, base);
	// 82EF2DF0: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF2DF4: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EF2DF8: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EF2DFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2E00: 4BDB9DA9  bl 0x82cacba8
	ctx.lr = 0x82EF2E04;
	sub_82CACBA8(ctx, base);
	// 82EF2E04: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF2E08: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82EF2E0C: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF2E10: 48002479  bl 0x82ef5288
	ctx.lr = 0x82EF2E14;
	sub_82EF5288(ctx, base);
	// 82EF2E14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF2E18: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EF2E1C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EF2E20: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EF2E24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2E28: 4BDB9D81  bl 0x82cacba8
	ctx.lr = 0x82EF2E2C;
	sub_82CACBA8(ctx, base);
	// 82EF2E2C: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF2E30: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EF2E34: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EF2E38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2E3C: 4BDB9D6D  bl 0x82cacba8
	ctx.lr = 0x82EF2E40;
	sub_82CACBA8(ctx, base);
	// 82EF2E40: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF2E44: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82EF2E48: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF2E4C: 4800243D  bl 0x82ef5288
	ctx.lr = 0x82EF2E50;
	sub_82EF5288(ctx, base);
	// 82EF2E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF2E54: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EF2E58: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EF2E5C: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EF2E60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2E64: 4BDB9D45  bl 0x82cacba8
	ctx.lr = 0x82EF2E68;
	sub_82CACBA8(ctx, base);
	// 82EF2E68: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF2E6C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EF2E70: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EF2E74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2E78: 4BDB9D31  bl 0x82cacba8
	ctx.lr = 0x82EF2E7C;
	sub_82CACBA8(ctx, base);
	// 82EF2E7C: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EF2E80: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 82EF2E84: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF2E88: 48002401  bl 0x82ef5288
	ctx.lr = 0x82EF2E8C;
	sub_82EF5288(ctx, base);
	// 82EF2E8C: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2E90: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF2E94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF2E98: 419A003C  beq cr6, 0x82ef2ed4
	if ctx.cr[6].eq {
	pc = 0x82EF2ED4; continue 'dispatch;
	}
	// 82EF2E9C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF2EA0: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 82EF2EA4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EF2EA8: 7D6607B4  extsw r6, r11
	ctx.r[6].s64 = ctx.r[11].s32 as i64;
	// 82EF2EAC: 80A1006C  lwz r5, 0x6c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EF2EB0: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EF2EB4: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2EB8: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF2EBC: 814101B4  lwz r10, 0x1b4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2EC0: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF2EC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF2EC8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EF2ECC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF2ED0: 4E800421  bctrl
	ctx.lr = 0x82EF2ED4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF2ED4 => {
    //   block [0x82EF2ED4..0x82EF2EE4)
	// 82EF2ED4: 808101CC  lwz r4, 0x1cc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF2ED8: 806101B4  lwz r3, 0x1b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2EDC: 48000835  bl 0x82ef3710
	ctx.lr = 0x82EF2EE0;
	sub_82EF3710(ctx, base);
	// 82EF2EE0: 48000814  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF2EE4 => {
    //   block [0x82EF2EE4..0x82EF2FBC)
	// 82EF2EE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF2EE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2EEC: 388BCC5C  addi r4, r11, -0x33a4
	ctx.r[4].s64 = ctx.r[11].s64 + -13220;
	// 82EF2EF0: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2EF4: 48001A6D  bl 0x82ef4960
	ctx.lr = 0x82EF2EF8;
	sub_82EF4960(ctx, base);
	// 82EF2EF8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF2EFC: 418200D0  beq 0x82ef2fcc
	if ctx.cr[0].eq {
	pc = 0x82EF2FCC; continue 'dispatch;
	}
	// 82EF2F00: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 82EF2F04: 91610138  stw r11, 0x138(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 82EF2F08: 81610138  lwz r11, 0x138(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EF2F0C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EF2F10: 814ACC90  lwz r10, -0x3370(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13168 as u32) ) } as u64;
	// 82EF2F14: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF2F18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF2F1C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF2F20: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EF2F24: 38A10094  addi r5, r1, 0x94
	ctx.r[5].s64 = ctx.r[1].s64 + 148;
	// 82EF2F28: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82EF2F2C: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF2F30: 4BDB9C79  bl 0x82cacba8
	ctx.lr = 0x82EF2F34;
	sub_82CACBA8(ctx, base);
	// 82EF2F34: 90610088  stw r3, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[3].u32 ) };
	// 82EF2F38: 38A10094  addi r5, r1, 0x94
	ctx.r[5].s64 = ctx.r[1].s64 + 148;
	// 82EF2F3C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82EF2F40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF2F44: 4BDB9C65  bl 0x82cacba8
	ctx.lr = 0x82EF2F48;
	sub_82CACBA8(ctx, base);
	// 82EF2F48: 90610088  stw r3, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[3].u32 ) };
	// 82EF2F4C: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 82EF2F50: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EF2F54: 48002545  bl 0x82ef5498
	ctx.lr = 0x82EF2F58;
	sub_82EF5498(ctx, base);
	// 82EF2F58: C001008C  lfs f0, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF2F5C: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82EF2F60: D8010140  stfd f0, 0x140(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.f[0].u64 ) };
	// 82EF2F64: E8A10140  ld r5, 0x140(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) };
	// 82EF2F68: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2F6C: 808B0050  lwz r4, 0x50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF2F70: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2F74: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF2F78: 4BFF5831  bl 0x82ee87a8
	ctx.lr = 0x82EF2F7C;
	sub_82EE87A8(ctx, base);
	// 82EF2F7C: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2F80: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF2F84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF2F88: 419A0034  beq cr6, 0x82ef2fbc
	if ctx.cr[6].eq {
	pc = 0x82EF2FBC; continue 'dispatch;
	}
	// 82EF2F8C: C001008C  lfs f0, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF2F90: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82EF2F94: D8010148  stfd f0, 0x148(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.f[0].u64 ) };
	// 82EF2F98: E8810148  ld r4, 0x148(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) };
	// 82EF2F9C: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2FA0: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF2FA4: 814101B4  lwz r10, 0x1b4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2FA8: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF2FAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF2FB0: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EF2FB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF2FB8: 4E800421  bctrl
	ctx.lr = 0x82EF2FBC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF2FBC => {
    //   block [0x82EF2FBC..0x82EF2FCC)
	// 82EF2FBC: 808101CC  lwz r4, 0x1cc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF2FC0: 806101B4  lwz r3, 0x1b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF2FC4: 4800074D  bl 0x82ef3710
	ctx.lr = 0x82EF2FC8;
	sub_82EF3710(ctx, base);
	// 82EF2FC8: 4800072C  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF2FCC => {
    //   block [0x82EF2FCC..0x82EF30A0)
	// 82EF2FCC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF2FD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF2FD4: 388BCC54  addi r4, r11, -0x33ac
	ctx.r[4].s64 = ctx.r[11].s64 + -13228;
	// 82EF2FD8: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF2FDC: 48001985  bl 0x82ef4960
	ctx.lr = 0x82EF2FE0;
	sub_82EF4960(ctx, base);
	// 82EF2FE0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF2FE4: 418200CC  beq 0x82ef30b0
	if ctx.cr[0].eq {
	pc = 0x82EF30B0; continue 'dispatch;
	}
	// 82EF2FE8: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 82EF2FEC: 91610150  stw r11, 0x150(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82EF2FF0: 81610150  lwz r11, 0x150(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(336 as u32) ) } as u64;
	// 82EF2FF4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EF2FF8: 814ACC90  lwz r10, -0x3370(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13168 as u32) ) } as u64;
	// 82EF2FFC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF3000: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF3004: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF3008: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EF300C: 38A100A4  addi r5, r1, 0xa4
	ctx.r[5].s64 = ctx.r[1].s64 + 164;
	// 82EF3010: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82EF3014: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF3018: 4BDB9B91  bl 0x82cacba8
	ctx.lr = 0x82EF301C;
	sub_82CACBA8(ctx, base);
	// 82EF301C: 90610098  stw r3, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[3].u32 ) };
	// 82EF3020: 38A100A4  addi r5, r1, 0xa4
	ctx.r[5].s64 = ctx.r[1].s64 + 164;
	// 82EF3024: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82EF3028: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF302C: 4BDB9B7D  bl 0x82cacba8
	ctx.lr = 0x82EF3030;
	sub_82CACBA8(ctx, base);
	// 82EF3030: 90610098  stw r3, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[3].u32 ) };
	// 82EF3034: 3881009C  addi r4, r1, 0x9c
	ctx.r[4].s64 = ctx.r[1].s64 + 156;
	// 82EF3038: 80610098  lwz r3, 0x98(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EF303C: 4800245D  bl 0x82ef5498
	ctx.lr = 0x82EF3040;
	sub_82EF5498(ctx, base);
	// 82EF3040: C001009C  lfs f0, 0x9c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF3044: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82EF3048: D8010158  stfd f0, 0x158(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.f[0].u64 ) };
	// 82EF304C: 8161015C  lwz r11, 0x15c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 82EF3050: 7D6407B4  extsw r4, r11
	ctx.r[4].s64 = ctx.r[11].s32 as i64;
	// 82EF3054: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3058: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF305C: 4BFF5655  bl 0x82ee86b0
	ctx.lr = 0x82EF3060;
	sub_82EE86B0(ctx, base);
	// 82EF3060: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3064: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF306C: 419A0034  beq cr6, 0x82ef30a0
	if ctx.cr[6].eq {
	pc = 0x82EF30A0; continue 'dispatch;
	}
	// 82EF3070: C001009C  lfs f0, 0x9c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF3074: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82EF3078: D8010160  stfd f0, 0x160(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.f[0].u64 ) };
	// 82EF307C: E8810160  ld r4, 0x160(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) };
	// 82EF3080: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3084: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3088: 814101B4  lwz r10, 0x1b4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF308C: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3090: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3094: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EF3098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF309C: 4E800421  bctrl
	ctx.lr = 0x82EF30A0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF30A0 => {
    //   block [0x82EF30A0..0x82EF30B0)
	// 82EF30A0: 808101CC  lwz r4, 0x1cc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF30A4: 806101B4  lwz r3, 0x1b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF30A8: 48000669  bl 0x82ef3710
	ctx.lr = 0x82EF30AC;
	sub_82EF3710(ctx, base);
	// 82EF30AC: 48000648  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF30B0 => {
    //   block [0x82EF30B0..0x82EF30DC)
	// 82EF30B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF30B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF30B8: 388BCC4C  addi r4, r11, -0x33b4
	ctx.r[4].s64 = ctx.r[11].s64 + -13236;
	// 82EF30BC: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF30C0: 480018A1  bl 0x82ef4960
	ctx.lr = 0x82EF30C4;
	sub_82EF4960(ctx, base);
	// 82EF30C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF30C8: 41820014  beq 0x82ef30dc
	if ctx.cr[0].eq {
	pc = 0x82EF30DC; continue 'dispatch;
	}
	// 82EF30CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EF30D0: 806101B4  lwz r3, 0x1b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF30D4: 4BFFF15D  bl 0x82ef2230
	ctx.lr = 0x82EF30D8;
	sub_82EF2230(ctx, base);
	// 82EF30D8: 4800061C  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF30DC => {
    //   block [0x82EF30DC..0x82EF3230)
	// 82EF30DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF30E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EF30E4: 388B3B9C  addi r4, r11, 0x3b9c
	ctx.r[4].s64 = ctx.r[11].s64 + 15260;
	// 82EF30E8: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF30EC: 48001875  bl 0x82ef4960
	ctx.lr = 0x82EF30F0;
	sub_82EF4960(ctx, base);
	// 82EF30F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF30F4: 41820140  beq 0x82ef3234
	if ctx.cr[0].eq {
	pc = 0x82EF3234; continue 'dispatch;
	}
	// 82EF30F8: 396100BC  addi r11, r1, 0xbc
	ctx.r[11].s64 = ctx.r[1].s64 + 188;
	// 82EF30FC: 91610168  stw r11, 0x168(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 82EF3100: 81610168  lwz r11, 0x168(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EF3104: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EF3108: 394ACC44  addi r10, r10, -0x33bc
	ctx.r[10].s64 = ctx.r[10].s64 + -13244;
	// 82EF310C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3110: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EF3114: 894A0004  lbz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF3118: 994B0004  stb r10, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82EF311C: 38A100C4  addi r5, r1, 0xc4
	ctx.r[5].s64 = ctx.r[1].s64 + 196;
	// 82EF3120: 388100BC  addi r4, r1, 0xbc
	ctx.r[4].s64 = ctx.r[1].s64 + 188;
	// 82EF3124: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF3128: 4BDB9A81  bl 0x82cacba8
	ctx.lr = 0x82EF312C;
	sub_82CACBA8(ctx, base);
	// 82EF312C: 906100B4  stw r3, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 82EF3130: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF3134: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF3138: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EF313C: 38A100C4  addi r5, r1, 0xc4
	ctx.r[5].s64 = ctx.r[1].s64 + 196;
	// 82EF3140: 388100BC  addi r4, r1, 0xbc
	ctx.r[4].s64 = ctx.r[1].s64 + 188;
	// 82EF3144: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF3148: 4BDB9A61  bl 0x82cacba8
	ctx.lr = 0x82EF314C;
	sub_82CACBA8(ctx, base);
	// 82EF314C: 906100B0  stw r3, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 82EF3150: 38A100C4  addi r5, r1, 0xc4
	ctx.r[5].s64 = ctx.r[1].s64 + 196;
	// 82EF3154: 388100BC  addi r4, r1, 0xbc
	ctx.r[4].s64 = ctx.r[1].s64 + 188;
	// 82EF3158: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF315C: 4BDB9A4D  bl 0x82cacba8
	ctx.lr = 0x82EF3160;
	sub_82CACBA8(ctx, base);
	// 82EF3160: 906100B0  stw r3, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 82EF3164: 388100AC  addi r4, r1, 0xac
	ctx.r[4].s64 = ctx.r[1].s64 + 172;
	// 82EF3168: 806100B0  lwz r3, 0xb0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EF316C: 4800232D  bl 0x82ef5498
	ctx.lr = 0x82EF3170;
	sub_82EF5498(ctx, base);
	// 82EF3170: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF3174: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF3178: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EF317C: 38A100C4  addi r5, r1, 0xc4
	ctx.r[5].s64 = ctx.r[1].s64 + 196;
	// 82EF3180: 388100BC  addi r4, r1, 0xbc
	ctx.r[4].s64 = ctx.r[1].s64 + 188;
	// 82EF3184: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF3188: 4BDB9A21  bl 0x82cacba8
	ctx.lr = 0x82EF318C;
	sub_82CACBA8(ctx, base);
	// 82EF318C: 906100B0  stw r3, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 82EF3190: 38A100C4  addi r5, r1, 0xc4
	ctx.r[5].s64 = ctx.r[1].s64 + 196;
	// 82EF3194: 388100BC  addi r4, r1, 0xbc
	ctx.r[4].s64 = ctx.r[1].s64 + 188;
	// 82EF3198: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF319C: 4BDB9A0D  bl 0x82cacba8
	ctx.lr = 0x82EF31A0;
	sub_82CACBA8(ctx, base);
	// 82EF31A0: 906100B0  stw r3, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 82EF31A4: 388100A8  addi r4, r1, 0xa8
	ctx.r[4].s64 = ctx.r[1].s64 + 168;
	// 82EF31A8: 806100B0  lwz r3, 0xb0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EF31AC: 480022ED  bl 0x82ef5498
	ctx.lr = 0x82EF31B0;
	sub_82EF5498(ctx, base);
	// 82EF31B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF31B4: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF31B8: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EF31BC: 38A100C4  addi r5, r1, 0xc4
	ctx.r[5].s64 = ctx.r[1].s64 + 196;
	// 82EF31C0: 388100BC  addi r4, r1, 0xbc
	ctx.r[4].s64 = ctx.r[1].s64 + 188;
	// 82EF31C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF31C8: 4BDB99E1  bl 0x82cacba8
	ctx.lr = 0x82EF31CC;
	sub_82CACBA8(ctx, base);
	// 82EF31CC: 906100B0  stw r3, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 82EF31D0: 38A100C4  addi r5, r1, 0xc4
	ctx.r[5].s64 = ctx.r[1].s64 + 196;
	// 82EF31D4: 388100BC  addi r4, r1, 0xbc
	ctx.r[4].s64 = ctx.r[1].s64 + 188;
	// 82EF31D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF31DC: 4BDB99CD  bl 0x82cacba8
	ctx.lr = 0x82EF31E0;
	sub_82CACBA8(ctx, base);
	// 82EF31E0: 906100B0  stw r3, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 82EF31E4: 388100B8  addi r4, r1, 0xb8
	ctx.r[4].s64 = ctx.r[1].s64 + 184;
	// 82EF31E8: 806100B0  lwz r3, 0xb0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EF31EC: 480022AD  bl 0x82ef5498
	ctx.lr = 0x82EF31F0;
	sub_82EF5498(ctx, base);
	// 82EF31F0: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF31F4: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF31F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF31FC: 419A0034  beq cr6, 0x82ef3230
	if ctx.cr[6].eq {
	pc = 0x82EF3230; continue 'dispatch;
	}
	// 82EF3200: C06100B8  lfs f3, 0xb8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EF3204: C04100A8  lfs f2, 0xa8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EF3208: C02100AC  lfs f1, 0xac(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EF320C: 808100B4  lwz r4, 0xb4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EF3210: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3214: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3218: 814101B4  lwz r10, 0x1b4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF321C: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3220: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3224: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EF3228: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF322C: 4E800421  bctrl
	ctx.lr = 0x82EF3230;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF3230 => {
    //   block [0x82EF3230..0x82EF3234)
	// 82EF3230: 480004C4  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF3234 => {
    //   block [0x82EF3234..0x82EF32E8)
	// 82EF3234: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF3238: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF323C: 388BCC30  addi r4, r11, -0x33d0
	ctx.r[4].s64 = ctx.r[11].s64 + -13264;
	// 82EF3240: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF3244: 4800171D  bl 0x82ef4960
	ctx.lr = 0x82EF3248;
	sub_82EF4960(ctx, base);
	// 82EF3248: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF324C: 418200A0  beq 0x82ef32ec
	if ctx.cr[0].eq {
	pc = 0x82EF32EC; continue 'dispatch;
	}
	// 82EF3250: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 82EF3254: 9161016C  stw r11, 0x16c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 82EF3258: 8161016C  lwz r11, 0x16c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EF325C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EF3260: 814ACC90  lwz r10, -0x3370(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13168 as u32) ) } as u64;
	// 82EF3264: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF3268: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF326C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF3270: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EF3274: 38A100D4  addi r5, r1, 0xd4
	ctx.r[5].s64 = ctx.r[1].s64 + 212;
	// 82EF3278: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82EF327C: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF3280: 4BDB9929  bl 0x82cacba8
	ctx.lr = 0x82EF3284;
	sub_82CACBA8(ctx, base);
	// 82EF3284: 906100C8  stw r3, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[3].u32 ) };
	// 82EF3288: 38A100D4  addi r5, r1, 0xd4
	ctx.r[5].s64 = ctx.r[1].s64 + 212;
	// 82EF328C: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82EF3290: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF3294: 4BDB9915  bl 0x82cacba8
	ctx.lr = 0x82EF3298;
	sub_82CACBA8(ctx, base);
	// 82EF3298: 906100C8  stw r3, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[3].u32 ) };
	// 82EF329C: 388100CC  addi r4, r1, 0xcc
	ctx.r[4].s64 = ctx.r[1].s64 + 204;
	// 82EF32A0: 806100C8  lwz r3, 0xc8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EF32A4: 480021F5  bl 0x82ef5498
	ctx.lr = 0x82EF32A8;
	sub_82EF5498(ctx, base);
	// 82EF32A8: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF32AC: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF32B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF32B4: 419A0034  beq cr6, 0x82ef32e8
	if ctx.cr[6].eq {
	pc = 0x82EF32E8; continue 'dispatch;
	}
	// 82EF32B8: C00100CC  lfs f0, 0xcc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF32BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF32C0: C1AB0A54  lfs f13, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EF32C4: EC206824  fdivs f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EF32C8: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF32CC: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF32D0: 814101B4  lwz r10, 0x1b4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF32D4: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF32D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF32DC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF32E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF32E4: 4E800421  bctrl
	ctx.lr = 0x82EF32E8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF32E8 => {
    //   block [0x82EF32E8..0x82EF32EC)
	// 82EF32E8: 4800040C  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF32EC => {
    //   block [0x82EF32EC..0x82EF33A0)
	// 82EF32EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF32F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF32F4: 388BCC1C  addi r4, r11, -0x33e4
	ctx.r[4].s64 = ctx.r[11].s64 + -13284;
	// 82EF32F8: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF32FC: 48001665  bl 0x82ef4960
	ctx.lr = 0x82EF3300;
	sub_82EF4960(ctx, base);
	// 82EF3300: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF3304: 418200A0  beq 0x82ef33a4
	if ctx.cr[0].eq {
	pc = 0x82EF33A4; continue 'dispatch;
	}
	// 82EF3308: 396100E0  addi r11, r1, 0xe0
	ctx.r[11].s64 = ctx.r[1].s64 + 224;
	// 82EF330C: 91610170  stw r11, 0x170(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 82EF3310: 81610170  lwz r11, 0x170(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) } as u64;
	// 82EF3314: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EF3318: 814ACC90  lwz r10, -0x3370(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13168 as u32) ) } as u64;
	// 82EF331C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF3320: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF3324: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF3328: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EF332C: 38A100E4  addi r5, r1, 0xe4
	ctx.r[5].s64 = ctx.r[1].s64 + 228;
	// 82EF3330: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82EF3334: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF3338: 4BDB9871  bl 0x82cacba8
	ctx.lr = 0x82EF333C;
	sub_82CACBA8(ctx, base);
	// 82EF333C: 906100D8  stw r3, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[3].u32 ) };
	// 82EF3340: 38A100E4  addi r5, r1, 0xe4
	ctx.r[5].s64 = ctx.r[1].s64 + 228;
	// 82EF3344: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82EF3348: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF334C: 4BDB985D  bl 0x82cacba8
	ctx.lr = 0x82EF3350;
	sub_82CACBA8(ctx, base);
	// 82EF3350: 906100D8  stw r3, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[3].u32 ) };
	// 82EF3354: 388100DC  addi r4, r1, 0xdc
	ctx.r[4].s64 = ctx.r[1].s64 + 220;
	// 82EF3358: 806100D8  lwz r3, 0xd8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) } as u64;
	// 82EF335C: 4800213D  bl 0x82ef5498
	ctx.lr = 0x82EF3360;
	sub_82EF5498(ctx, base);
	// 82EF3360: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3364: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF336C: 419A0034  beq cr6, 0x82ef33a0
	if ctx.cr[6].eq {
	pc = 0x82EF33A0; continue 'dispatch;
	}
	// 82EF3370: C00100DC  lfs f0, 0xdc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF3374: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF3378: C1AB0A54  lfs f13, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EF337C: EC206824  fdivs f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EF3380: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3384: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3388: 814101B4  lwz r10, 0x1b4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF338C: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3390: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3394: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EF3398: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF339C: 4E800421  bctrl
	ctx.lr = 0x82EF33A0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF33A0 => {
    //   block [0x82EF33A0..0x82EF33A4)
	// 82EF33A0: 48000354  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF33A4 => {
    //   block [0x82EF33A4..0x82EF33F4)
	// 82EF33A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF33A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF33AC: 388BCC4C  addi r4, r11, -0x33b4
	ctx.r[4].s64 = ctx.r[11].s64 + -13236;
	// 82EF33B0: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF33B4: 480015AD  bl 0x82ef4960
	ctx.lr = 0x82EF33B8;
	sub_82EF4960(ctx, base);
	// 82EF33B8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF33BC: 4182003C  beq 0x82ef33f8
	if ctx.cr[0].eq {
	pc = 0x82EF33F8; continue 'dispatch;
	}
	// 82EF33C0: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF33C4: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF33C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF33CC: 419A0028  beq cr6, 0x82ef33f4
	if ctx.cr[6].eq {
	pc = 0x82EF33F4; continue 'dispatch;
	}
	// 82EF33D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EF33D4: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF33D8: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF33DC: 814101B4  lwz r10, 0x1b4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF33E0: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF33E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF33E8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF33EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF33F0: 4E800421  bctrl
	ctx.lr = 0x82EF33F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF33F4 => {
    //   block [0x82EF33F4..0x82EF33F8)
	// 82EF33F4: 48000300  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF33F8 => {
    //   block [0x82EF33F8..0x82EF3488)
	// 82EF33F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF33FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF3400: 388BCC08  addi r4, r11, -0x33f8
	ctx.r[4].s64 = ctx.r[11].s64 + -13304;
	// 82EF3404: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF3408: 48001559  bl 0x82ef4960
	ctx.lr = 0x82EF340C;
	sub_82EF4960(ctx, base);
	// 82EF340C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF3410: 4182007C  beq 0x82ef348c
	if ctx.cr[0].eq {
	pc = 0x82EF348C; continue 'dispatch;
	}
	// 82EF3414: 396100EC  addi r11, r1, 0xec
	ctx.r[11].s64 = ctx.r[1].s64 + 236;
	// 82EF3418: 91610174  stw r11, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 82EF341C: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EF3420: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EF3424: 814ACC90  lwz r10, -0x3370(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13168 as u32) ) } as u64;
	// 82EF3428: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF342C: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 82EF3430: 388100EC  addi r4, r1, 0xec
	ctx.r[4].s64 = ctx.r[1].s64 + 236;
	// 82EF3434: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF3438: 4BDB9771  bl 0x82cacba8
	ctx.lr = 0x82EF343C;
	sub_82CACBA8(ctx, base);
	// 82EF343C: 906100E8  stw r3, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[3].u32 ) };
	// 82EF3440: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 82EF3444: 388100EC  addi r4, r1, 0xec
	ctx.r[4].s64 = ctx.r[1].s64 + 236;
	// 82EF3448: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF344C: 4BDB975D  bl 0x82cacba8
	ctx.lr = 0x82EF3450;
	sub_82CACBA8(ctx, base);
	// 82EF3450: 906100E8  stw r3, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[3].u32 ) };
	// 82EF3454: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3458: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF345C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF3460: 419A0028  beq cr6, 0x82ef3488
	if ctx.cr[6].eq {
	pc = 0x82EF3488; continue 'dispatch;
	}
	// 82EF3464: 808100E8  lwz r4, 0xe8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) } as u64;
	// 82EF3468: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF346C: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3470: 814101B4  lwz r10, 0x1b4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3474: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3478: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF347C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EF3480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF3484: 4E800421  bctrl
	ctx.lr = 0x82EF3488;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF3488 => {
    //   block [0x82EF3488..0x82EF348C)
	// 82EF3488: 4800026C  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF348C => {
    //   block [0x82EF348C..0x82EF34E4)
	// 82EF348C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF3490: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF3494: 388BCBFC  addi r4, r11, -0x3404
	ctx.r[4].s64 = ctx.r[11].s64 + -13316;
	// 82EF3498: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF349C: 480014C5  bl 0x82ef4960
	ctx.lr = 0x82EF34A0;
	sub_82EF4960(ctx, base);
	// 82EF34A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF34A4: 41820040  beq 0x82ef34e4
	if ctx.cr[0].eq {
	pc = 0x82EF34E4; continue 'dispatch;
	}
	// 82EF34A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF34AC: 996100F4  stb r11, 0xf4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[11].u8 ) };
	// 82EF34B0: 388100F4  addi r4, r1, 0xf4
	ctx.r[4].s64 = ctx.r[1].s64 + 244;
	// 82EF34B4: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF34B8: 48002089  bl 0x82ef5540
	ctx.lr = 0x82EF34BC;
	sub_82EF5540(ctx, base);
	// 82EF34BC: 888100F4  lbz r4, 0xf4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EF34C0: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF34C4: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF34C8: 814101B4  lwz r10, 0x1b4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF34CC: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF34D0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF34D4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF34D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF34DC: 4E800421  bctrl
	ctx.lr = 0x82EF34E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF34E0: 48000214  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF34E4 => {
    //   block [0x82EF34E4..0x82EF3510)
	// 82EF34E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF34E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF34EC: 388BCBE4  addi r4, r11, -0x341c
	ctx.r[4].s64 = ctx.r[11].s64 + -13340;
	// 82EF34F0: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF34F4: 4800146D  bl 0x82ef4960
	ctx.lr = 0x82EF34F8;
	sub_82EF4960(ctx, base);
	// 82EF34F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF34FC: 41820014  beq 0x82ef3510
	if ctx.cr[0].eq {
	pc = 0x82EF3510; continue 'dispatch;
	}
	// 82EF3500: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3504: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EF3508: 994B0488  stb r10, 0x488(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1160 as u32), ctx.r[10].u8 ) };
	// 82EF350C: 480001E8  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF3510 => {
    //   block [0x82EF3510..0x82EF353C)
	// 82EF3510: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF3514: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF3518: 388BCBD0  addi r4, r11, -0x3430
	ctx.r[4].s64 = ctx.r[11].s64 + -13360;
	// 82EF351C: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF3520: 48001441  bl 0x82ef4960
	ctx.lr = 0x82EF3524;
	sub_82EF4960(ctx, base);
	// 82EF3524: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF3528: 41820014  beq 0x82ef353c
	if ctx.cr[0].eq {
	pc = 0x82EF353C; continue 'dispatch;
	}
	// 82EF352C: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3530: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EF3534: 994B0489  stb r10, 0x489(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1161 as u32), ctx.r[10].u8 ) };
	// 82EF3538: 480001BC  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF353C => {
    //   block [0x82EF353C..0x82EF3630)
	// 82EF353C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF3540: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF3544: 388BCBBC  addi r4, r11, -0x3444
	ctx.r[4].s64 = ctx.r[11].s64 + -13380;
	// 82EF3548: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF354C: 48001415  bl 0x82ef4960
	ctx.lr = 0x82EF3550;
	sub_82EF4960(ctx, base);
	// 82EF3550: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF3554: 41820140  beq 0x82ef3694
	if ctx.cr[0].eq {
	pc = 0x82EF3694; continue 'dispatch;
	}
	// 82EF3558: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF355C: 916100F8  stw r11, 0xf8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82EF3560: 388100F8  addi r4, r1, 0xf8
	ctx.r[4].s64 = ctx.r[1].s64 + 248;
	// 82EF3564: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF3568: 48001DF1  bl 0x82ef5358
	ctx.lr = 0x82EF356C;
	sub_82EF5358(ctx, base);
	// 82EF356C: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3570: 816B04D8  lwz r11, 0x4d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82EF3574: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF3578: 480006D1  bl 0x82ef3c48
	ctx.lr = 0x82EF357C;
	sub_82EF3C48(ctx, base);
	// 82EF357C: 816100F8  lwz r11, 0xf8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) } as u64;
	// 82EF3580: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EF3584: 4098010C  bge cr6, 0x82ef3690
	if !ctx.cr[6].lt {
	pc = 0x82EF3690; continue 'dispatch;
	}
	// 82EF3588: 808100F8  lwz r4, 0xf8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) } as u64;
	// 82EF358C: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3590: 806B04D8  lwz r3, 0x4d8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82EF3594: 4BFFAA15  bl 0x82eedfa8
	ctx.lr = 0x82EF3598;
	sub_82EEDFA8(ctx, base);
	// 82EF3598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EF359C: 808100F8  lwz r4, 0xf8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) } as u64;
	// 82EF35A0: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF35A4: 816B04D8  lwz r11, 0x4d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82EF35A8: 386B016C  addi r3, r11, 0x16c
	ctx.r[3].s64 = ctx.r[11].s64 + 364;
	// 82EF35AC: 480006E5  bl 0x82ef3c90
	ctx.lr = 0x82EF35B0;
	sub_82EF3C90(ctx, base);
	// 82EF35B0: 80A30000  lwz r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF35B4: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF35B8: 808B0494  lwz r4, 0x494(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1172 as u32) ) } as u64;
	// 82EF35BC: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF35C0: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EF35C4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EF35C8: 4BFF6481  bl 0x82ee9a48
	ctx.lr = 0x82EF35CC;
	sub_82EE9A48(ctx, base);
	// 82EF35CC: 906100FC  stw r3, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[3].u32 ) };
	// 82EF35D0: 816100FC  lwz r11, 0xfc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82EF35D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF35D8: 41980058  blt cr6, 0x82ef3630
	if ctx.cr[6].lt {
	pc = 0x82EF3630; continue 'dispatch;
	}
	// 82EF35DC: 83E100F8  lwz r31, 0xf8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) } as u64;
	// 82EF35E0: 3BC10100  addi r30, r1, 0x100
	ctx.r[30].s64 = ctx.r[1].s64 + 256;
	// 82EF35E4: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82EF35E8: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF35EC: 816B04D8  lwz r11, 0x4d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82EF35F0: 388B016C  addi r4, r11, 0x16c
	ctx.r[4].s64 = ctx.r[11].s64 + 364;
	// 82EF35F4: 48000615  bl 0x82ef3c08
	ctx.lr = 0x82EF35F8;
	sub_82EF3C08(ctx, base);
	// 82EF35F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF35FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EF3600: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF3604: 480009BD  bl 0x82ef3fc0
	ctx.lr = 0x82EF3608;
	sub_82EF3FC0(ctx, base);
	// 82EF3608: E8A10100  ld r5, 0x100(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82EF360C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82EF3610: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3614: 816B04D8  lwz r11, 0x4d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82EF3618: 388B016C  addi r4, r11, 0x16c
	ctx.r[4].s64 = ctx.r[11].s64 + 364;
	// 82EF361C: 4800075D  bl 0x82ef3d78
	ctx.lr = 0x82EF3620;
	sub_82EF3D78(ctx, base);
	// 82EF3620: 808100F8  lwz r4, 0xf8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) } as u64;
	// 82EF3624: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3628: 806B04D8  lwz r3, 0x4d8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82EF362C: 4BFFAB95  bl 0x82eee1c0
	ctx.lr = 0x82EF3630;
	sub_82EEE1C0(ctx, base);
	pc = 0x82EF3630; continue 'dispatch;
            }
            0x82EF3630 => {
    //   block [0x82EF3630..0x82EF3690)
	// 82EF3630: 816100FC  lwz r11, 0xfc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82EF3634: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EF3638: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EF363C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EF3640: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82EF3644: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EF3648: F9610178  std r11, 0x178(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[11].u64 ) };
	// 82EF364C: C8010178  lfd f0, 0x178(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) };
	// 82EF3650: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82EF3654: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82EF3658: 48002141  bl 0x82ef5798
	ctx.lr = 0x82EF365C;
	sub_82EF5798(ctx, base);
	// 82EF365C: 806101B4  lwz r3, 0x1b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF3660: 480022D9  bl 0x82ef5938
	ctx.lr = 0x82EF3664;
	sub_82EF5938(ctx, base);
	// 82EF3664: 90610180  stw r3, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[3].u32 ) };
	// 82EF3668: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EF366C: 38A10120  addi r5, r1, 0x120
	ctx.r[5].s64 = ctx.r[1].s64 + 288;
	// 82EF3670: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF3674: 388BCBA4  addi r4, r11, -0x345c
	ctx.r[4].s64 = ctx.r[11].s64 + -13404;
	// 82EF3678: 80610180  lwz r3, 0x180(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EF367C: 81610180  lwz r11, 0x180(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EF3680: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3684: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF3688: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF368C: 4E800421  bctrl
	ctx.lr = 0x82EF3690;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF3690 => {
    //   block [0x82EF3690..0x82EF3694)
	// 82EF3690: 48000064  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF3694 => {
    //   block [0x82EF3694..0x82EF36BC)
	// 82EF3694: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF3698: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF369C: 388BCB98  addi r4, r11, -0x3468
	ctx.r[4].s64 = ctx.r[11].s64 + -13416;
	// 82EF36A0: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF36A4: 480012BD  bl 0x82ef4960
	ctx.lr = 0x82EF36A8;
	sub_82EF4960(ctx, base);
	// 82EF36A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF36AC: 41820010  beq 0x82ef36bc
	if ctx.cr[0].eq {
	pc = 0x82EF36BC; continue 'dispatch;
	}
	// 82EF36B0: 806101B4  lwz r3, 0x1b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF36B4: 480004AD  bl 0x82ef3b60
	ctx.lr = 0x82EF36B8;
	sub_82EF3B60(ctx, base);
	// 82EF36B8: 4800003C  b 0x82ef36f4
	pc = 0x82EF36F4; continue 'dispatch;
            }
            0x82EF36BC => {
    //   block [0x82EF36BC..0x82EF36F4)
	// 82EF36BC: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF36C0: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF36C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF36C8: 419A002C  beq cr6, 0x82ef36f4
	if ctx.cr[6].eq {
	pc = 0x82EF36F4; continue 'dispatch;
	}
	// 82EF36CC: 80A101CC  lwz r5, 0x1cc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EF36D0: 808101C4  lwz r4, 0x1c4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EF36D4: 816101B4  lwz r11, 0x1b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF36D8: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF36DC: 814101B4  lwz r10, 0x1b4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EF36E0: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF36E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF36E8: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EF36EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF36F0: 4E800421  bctrl
	ctx.lr = 0x82EF36F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF36F4 => {
    //   block [0x82EF36F4..0x82EF370C)
	// 82EF36F4: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 82EF36F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF36FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3700: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF3704: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF3708: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3710 size=256
    let mut pc: u32 = 0x82EF3710;
    'dispatch: loop {
        match pc {
            0x82EF3710 => {
    //   block [0x82EF3710..0x82EF378C)
	// 82EF3710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3718: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF371C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF3720: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3724: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EF3728: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EF372C: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF3730: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF3734: 409A0058  bne cr6, 0x82ef378c
	if !ctx.cr[6].eq {
	pc = 0x82EF378C; continue 'dispatch;
	}
	// 82EF3738: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF373C: 896B8F80  lbz r11, -0x7080(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28800 as u32) ) } as u64;
	// 82EF3740: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF3744: 40820048  bne 0x82ef378c
	if !ctx.cr[0].eq {
	pc = 0x82EF378C; continue 'dispatch;
	}
	// 82EF3748: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF374C: 3BEBCCDC  addi r31, r11, -0x3324
	ctx.r[31].s64 = ctx.r[11].s64 + -13092;
	// 82EF3750: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF3754: 3BCB8F80  addi r30, r11, -0x7080
	ctx.r[30].s64 = ctx.r[11].s64 + -28800;
	// 82EF3758: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF375C: 38CBCCD0  addi r6, r11, -0x3330
	ctx.r[6].s64 = ctx.r[11].s64 + -13104;
	// 82EF3760: 38A004A8  li r5, 0x4a8
	ctx.r[5].s64 = 1192;
	// 82EF3764: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF3768: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF376C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EF3770: 4BFF79F9  bl 0x82eeb168
	ctx.lr = 0x82EF3774;
	sub_82EEB168(ctx, base);
	// 82EF3774: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF3778: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF377C: 481FE715  bl 0x830f1e90
	ctx.lr = 0x82EF3780;
	sub_830F1E90(ctx, base);
	// 82EF3780: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF3784: 40820008  bne 0x82ef378c
	if !ctx.cr[0].eq {
	pc = 0x82EF378C; continue 'dispatch;
	}
	// 82EF3788: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF378C; continue 'dispatch;
            }
            0x82EF378C => {
    //   block [0x82EF378C..0x82EF379C)
	// 82EF378C: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF3790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF3794: 409A0008  bne cr6, 0x82ef379c
	if !ctx.cr[6].eq {
	pc = 0x82EF379C; continue 'dispatch;
	}
	// 82EF3798: 48000060  b 0x82ef37f8
	pc = 0x82EF37F8; continue 'dispatch;
            }
            0x82EF379C => {
    //   block [0x82EF379C..0x82EF37DC)
	// 82EF379C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF37A0: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82EF37A4: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF37A8: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF37AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF37B0: 419A002C  beq cr6, 0x82ef37dc
	if ctx.cr[6].eq {
	pc = 0x82EF37DC; continue 'dispatch;
	}
	// 82EF37B4: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF37B8: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF37BC: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF37C0: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF37C4: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF37C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF37CC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EF37D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF37D4: 4E800421  bctrl
	ctx.lr = 0x82EF37D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF37D8: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
            }
            0x82EF37DC => {
    //   block [0x82EF37DC..0x82EF37F8)
	// 82EF37DC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF37E0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF37E4: 40820014  bne 0x82ef37f8
	if !ctx.cr[0].eq {
	pc = 0x82EF37F8; continue 'dispatch;
	}
	// 82EF37E8: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF37EC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82EF37F0: 386B231C  addi r3, r11, 0x231c
	ctx.r[3].s64 = ctx.r[11].s64 + 8988;
	// 82EF37F4: 480019CD  bl 0x82ef51c0
	ctx.lr = 0x82EF37F8;
	sub_82EF51C0(ctx, base);
	pc = 0x82EF37F8; continue 'dispatch;
            }
            0x82EF37F8 => {
    //   block [0x82EF37F8..0x82EF3810)
	// 82EF37F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EF37FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF3800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3804: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF3808: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF380C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3810 size=232
    let mut pc: u32 = 0x82EF3810;
    'dispatch: loop {
        match pc {
            0x82EF3810 => {
    //   block [0x82EF3810..0x82EF3864)
	// 82EF3810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3814: 4BDB5BF9  bl 0x82ca940c
	ctx.lr = 0x82EF3818;
	sub_82CA93D0(ctx, base);
	// 82EF3818: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF381C: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EF3820: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82EF3824: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF3828: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82EF382C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF3830: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3834: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF3838: 419A002C  beq cr6, 0x82ef3864
	if ctx.cr[6].eq {
	pc = 0x82EF3864; continue 'dispatch;
	}
	// 82EF383C: 808100AC  lwz r4, 0xac(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EF3840: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF3844: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3848: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF384C: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3850: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3854: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EF3858: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF385C: 4E800421  bctrl
	ctx.lr = 0x82EF3860;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF3860: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
            }
            0x82EF3864 => {
    //   block [0x82EF3864..0x82EF389C)
	// 82EF3864: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF3868: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF386C: 40820084  bne 0x82ef38f0
	if !ctx.cr[0].eq {
	pc = 0x82EF38F0; continue 'dispatch;
	}
	// 82EF3870: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF3874: 896B8F81  lbz r11, -0x707f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28799 as u32) ) } as u64;
	// 82EF3878: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF387C: 40820074  bne 0x82ef38f0
	if !ctx.cr[0].eq {
	pc = 0x82EF38F0; continue 'dispatch;
	}
	// 82EF3880: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EF3884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF3888: 409A0014  bne cr6, 0x82ef389c
	if !ctx.cr[6].eq {
	pc = 0x82EF389C; continue 'dispatch;
	}
	// 82EF388C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EF3890: 396B8034  addi r11, r11, -0x7fcc
	ctx.r[11].s64 = ctx.r[11].s64 + -32716;
	// 82EF3894: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EF3898: 4800000C  b 0x82ef38a4
	pc = 0x82EF38A4; continue 'dispatch;
            }
            0x82EF389C => {
    //   block [0x82EF389C..0x82EF38A4)
	// 82EF389C: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EF38A0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF38A4; continue 'dispatch;
            }
            0x82EF38A4 => {
    //   block [0x82EF38A4..0x82EF38F0)
	// 82EF38A4: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EF38A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF38AC: 3BCBCD28  addi r30, r11, -0x32d8
	ctx.r[30].s64 = ctx.r[11].s64 + -13016;
	// 82EF38B0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF38B4: 3BAB8F81  addi r29, r11, -0x707f
	ctx.r[29].s64 = ctx.r[11].s64 + -28799;
	// 82EF38B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF38BC: 38CBCD1C  addi r6, r11, -0x32e4
	ctx.r[6].s64 = ctx.r[11].s64 + -13028;
	// 82EF38C0: 38A004BB  li r5, 0x4bb
	ctx.r[5].s64 = 1211;
	// 82EF38C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF38C8: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF38CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EF38D0: 4BFF7899  bl 0x82eeb168
	ctx.lr = 0x82EF38D4;
	sub_82EEB168(ctx, base);
	// 82EF38D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EF38D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EF38DC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EF38E0: 481FE5B1  bl 0x830f1e90
	ctx.lr = 0x82EF38E4;
	sub_830F1E90(ctx, base);
	// 82EF38E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF38E8: 40820008  bne 0x82ef38f0
	if !ctx.cr[0].eq {
	pc = 0x82EF38F0; continue 'dispatch;
	}
	// 82EF38EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF38F0; continue 'dispatch;
            }
            0x82EF38F0 => {
    //   block [0x82EF38F0..0x82EF38F8)
	// 82EF38F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EF38F4: 4BDB5B68  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF38F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF38F8 size=108
    let mut pc: u32 = 0x82EF38F8;
    'dispatch: loop {
        match pc {
            0x82EF38F8 => {
    //   block [0x82EF38F8..0x82EF3964)
	// 82EF38F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF38FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3900: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3904: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF3908: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF390C: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF3910: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF3914: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF3918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF391C: 4B32C1ED  bl 0x8221fb08
	ctx.lr = 0x82EF3920;
	sub_8221FB08(ctx, base);
	// 82EF3920: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF3924: 48002015  bl 0x82ef5938
	ctx.lr = 0x82EF3928;
	sub_82EF5938(ctx, base);
	// 82EF3928: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EF392C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF3930: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF3934: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF3938: 388BC8D4  addi r4, r11, -0x372c
	ctx.r[4].s64 = ctx.r[11].s64 + -14124;
	// 82EF393C: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF3940: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF3944: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3948: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF394C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF3950: 4E800421  bctrl
	ctx.lr = 0x82EF3954;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF3954: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF3958: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF395C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3960: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3968 size=124
    let mut pc: u32 = 0x82EF3968;
    'dispatch: loop {
        match pc {
            0x82EF3968 => {
    //   block [0x82EF3968..0x82EF39E4)
	// 82EF3968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF396C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3970: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3974: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF3978: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF397C: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF3980: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF3984: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF3988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF398C: 4B32C17D  bl 0x8221fb08
	ctx.lr = 0x82EF3990;
	sub_8221FB08(ctx, base);
	// 82EF3990: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF3994: C82B0D38  lfd f1, 0xd38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82EF3998: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF399C: 48001E4D  bl 0x82ef57e8
	ctx.lr = 0x82EF39A0;
	sub_82EF57E8(ctx, base);
	// 82EF39A0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF39A4: 48001F95  bl 0x82ef5938
	ctx.lr = 0x82EF39A8;
	sub_82EF5938(ctx, base);
	// 82EF39A8: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EF39AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF39B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF39B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF39B8: 388BCD4C  addi r4, r11, -0x32b4
	ctx.r[4].s64 = ctx.r[11].s64 + -12980;
	// 82EF39BC: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF39C0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF39C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF39C8: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF39CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF39D0: 4E800421  bctrl
	ctx.lr = 0x82EF39D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF39D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF39D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF39DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF39E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF39E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF39E8 size=124
    let mut pc: u32 = 0x82EF39E8;
    'dispatch: loop {
        match pc {
            0x82EF39E8 => {
    //   block [0x82EF39E8..0x82EF3A64)
	// 82EF39E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF39EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF39F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF39F4: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF39F8: 3D6082EF  lis r11, -0x7d11
	ctx.r[11].s64 = -2098266112;
	// 82EF39FC: 38CB5780  addi r6, r11, 0x5780
	ctx.r[6].s64 = ctx.r[11].s64 + 22400;
	// 82EF3A00: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF3A04: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82EF3A08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF3A0C: 4B32C0FD  bl 0x8221fb08
	ctx.lr = 0x82EF3A10;
	sub_8221FB08(ctx, base);
	// 82EF3A10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF3A14: C82B0D38  lfd f1, 0xd38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82EF3A18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF3A1C: 48001DCD  bl 0x82ef57e8
	ctx.lr = 0x82EF3A20;
	sub_82EF57E8(ctx, base);
	// 82EF3A20: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF3A24: 48001F15  bl 0x82ef5938
	ctx.lr = 0x82EF3A28;
	sub_82EF5938(ctx, base);
	// 82EF3A28: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EF3A2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EF3A30: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF3A34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF3A38: 388BCD60  addi r4, r11, -0x32a0
	ctx.r[4].s64 = ctx.r[11].s64 + -12960;
	// 82EF3A3C: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF3A40: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF3A44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3A48: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF3A4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF3A50: 4E800421  bctrl
	ctx.lr = 0x82EF3A54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF3A54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF3A58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF3A5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3A60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF3A68 size=244
    let mut pc: u32 = 0x82EF3A68;
    'dispatch: loop {
        match pc {
            0x82EF3A68 => {
    //   block [0x82EF3A68..0x82EF3AE4)
	// 82EF3A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3A6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3A70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF3A74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF3A78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3A7C: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EF3A80: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3A84: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF3A88: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EF3A8C: 419A0058  beq cr6, 0x82ef3ae4
	if ctx.cr[6].eq {
	pc = 0x82EF3AE4; continue 'dispatch;
	}
	// 82EF3A90: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF3A94: 896B8F82  lbz r11, -0x707e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28798 as u32) ) } as u64;
	// 82EF3A98: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF3A9C: 40820048  bne 0x82ef3ae4
	if !ctx.cr[0].eq {
	pc = 0x82EF3AE4; continue 'dispatch;
	}
	// 82EF3AA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF3AA4: 3BEBCD98  addi r31, r11, -0x3268
	ctx.r[31].s64 = ctx.r[11].s64 + -12904;
	// 82EF3AA8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EF3AAC: 3BCB8F82  addi r30, r11, -0x707e
	ctx.r[30].s64 = ctx.r[11].s64 + -28798;
	// 82EF3AB0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF3AB4: 38CBCD70  addi r6, r11, -0x3290
	ctx.r[6].s64 = ctx.r[11].s64 + -12944;
	// 82EF3AB8: 38A004DB  li r5, 0x4db
	ctx.r[5].s64 = 1243;
	// 82EF3ABC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF3AC0: 388BC6C8  addi r4, r11, -0x3938
	ctx.r[4].s64 = ctx.r[11].s64 + -14648;
	// 82EF3AC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF3AC8: 4BFF76A1  bl 0x82eeb168
	ctx.lr = 0x82EF3ACC;
	sub_82EEB168(ctx, base);
	// 82EF3ACC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF3AD0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF3AD4: 481FE3BD  bl 0x830f1e90
	ctx.lr = 0x82EF3AD8;
	sub_830F1E90(ctx, base);
	// 82EF3AD8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF3ADC: 40820008  bne 0x82ef3ae4
	if !ctx.cr[0].eq {
	pc = 0x82EF3AE4; continue 'dispatch;
	}
	// 82EF3AE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF3AE4; continue 'dispatch;
            }
            0x82EF3AE4 => {
    //   block [0x82EF3AE4..0x82EF3B24)
	// 82EF3AE4: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3AE8: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF3AEC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EF3AF0: 409A0054  bne cr6, 0x82ef3b44
	if !ctx.cr[6].eq {
	pc = 0x82EF3B44; continue 'dispatch;
	}
	// 82EF3AF4: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3AF8: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3AFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF3B00: 419A0024  beq cr6, 0x82ef3b24
	if ctx.cr[6].eq {
	pc = 0x82EF3B24; continue 'dispatch;
	}
	// 82EF3B04: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3B08: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3B0C: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3B10: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3B14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3B18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF3B1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF3B20: 4E800421  bctrl
	ctx.lr = 0x82EF3B24;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF3B24 => {
    //   block [0x82EF3B24..0x82EF3B44)
	// 82EF3B24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF3B28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF3B2C: C02B0C18  lfs f1, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EF3B30: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3B34: 480FA8BD  bl 0x82fee3f0
	ctx.lr = 0x82EF3B38;
	sub_82FEE3F0(ctx, base);
	// 82EF3B38: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3B3C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EF3B40: 914B0044  stw r10, 0x44(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	pc = 0x82EF3B44; continue 'dispatch;
            }
            0x82EF3B44 => {
    //   block [0x82EF3B44..0x82EF3B5C)
	// 82EF3B44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EF3B48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF3B4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3B50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF3B54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF3B58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3B60 size=128
    let mut pc: u32 = 0x82EF3B60;
    'dispatch: loop {
        match pc {
            0x82EF3B60 => {
    //   block [0x82EF3B60..0x82EF3B84)
	// 82EF3B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3B68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3B6C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF3B70: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3B74: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EF3B78: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EF3B7C: 409A0008  bne cr6, 0x82ef3b84
	if !ctx.cr[6].eq {
	pc = 0x82EF3B84; continue 'dispatch;
	}
	// 82EF3B80: 48000050  b 0x82ef3bd0
	pc = 0x82EF3BD0; continue 'dispatch;
            }
            0x82EF3B84 => {
    //   block [0x82EF3B84..0x82EF3BD0)
	// 82EF3B84: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3B88: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82EF3B8C: 914B0044  stw r10, 0x44(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	// 82EF3B90: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3B94: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3B98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF3B9C: 419A0034  beq cr6, 0x82ef3bd0
	if ctx.cr[6].eq {
	pc = 0x82EF3BD0; continue 'dispatch;
	}
	// 82EF3BA0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3BA4: 896B04DD  lbz r11, 0x4dd(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1245 as u32) ) } as u64;
	// 82EF3BA8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EF3BAC: 5564DFFE  rlwinm r4, r11, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EF3BB0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3BB4: 816B046C  lwz r11, 0x46c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3BB8: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3BBC: 806A046C  lwz r3, 0x46c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1132 as u32) ) } as u64;
	// 82EF3BC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3BC4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF3BC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF3BCC: 4E800421  bctrl
	ctx.lr = 0x82EF3BD0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EF3BD0 => {
    //   block [0x82EF3BD0..0x82EF3BE0)
	// 82EF3BD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF3BD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF3BD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3BDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3BE0 size=40
    let mut pc: u32 = 0x82EF3BE0;
    'dispatch: loop {
        match pc {
            0x82EF3BE0 => {
    //   block [0x82EF3BE0..0x82EF3C08)
	// 82EF3BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3BE8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3BEC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF3BF0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3BF4: 480005E5  bl 0x82ef41d8
	ctx.lr = 0x82EF3BF8;
	sub_82EF41D8(ctx, base);
	// 82EF3BF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF3BFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF3C00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3C04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3C08 size=60
    let mut pc: u32 = 0x82EF3C08;
    'dispatch: loop {
        match pc {
            0x82EF3C08 => {
    //   block [0x82EF3C08..0x82EF3C44)
	// 82EF3C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3C0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3C10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3C14: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF3C18: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF3C1C: 80A1007C  lwz r5, 0x7c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3C20: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3C24: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF3C28: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3C2C: 4800072D  bl 0x82ef4358
	ctx.lr = 0x82EF3C30;
	sub_82EF4358(ctx, base);
	// 82EF3C30: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3C34: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF3C38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF3C3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3C40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF3C48 size=68
    let mut pc: u32 = 0x82EF3C48;
    'dispatch: loop {
        match pc {
            0x82EF3C48 => {
    //   block [0x82EF3C48..0x82EF3C68)
	// 82EF3C48: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF3C4C: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF3C50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF3C54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF3C58: 409A0010  bne cr6, 0x82ef3c68
	if !ctx.cr[6].eq {
	pc = 0x82EF3C68; continue 'dispatch;
	}
	// 82EF3C5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF3C60: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EF3C64: 48000020  b 0x82ef3c84
	pc = 0x82EF3C84; continue 'dispatch;
            }
            0x82EF3C68 => {
    //   block [0x82EF3C68..0x82EF3C84)
	// 82EF3C68: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF3C6C: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF3C70: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF3C74: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF3C78: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EF3C7C: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82EF3C80: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF3C84; continue 'dispatch;
            }
            0x82EF3C84 => {
    //   block [0x82EF3C84..0x82EF3C8C)
	// 82EF3C84: 8061FFF0  lwz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EF3C88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3C90 size=80
    let mut pc: u32 = 0x82EF3C90;
    'dispatch: loop {
        match pc {
            0x82EF3C90 => {
    //   block [0x82EF3C90..0x82EF3CBC)
	// 82EF3C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3C94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3C98: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3C9C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF3CA0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF3CA4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3CA8: 4BFFFFA1  bl 0x82ef3c48
	ctx.lr = 0x82EF3CAC;
	sub_82EF3C48(ctx, base);
	// 82EF3CAC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3CB0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EF3CB4: 41980008  blt cr6, 0x82ef3cbc
	if ctx.cr[6].lt {
	pc = 0x82EF3CBC; continue 'dispatch;
	}
	// 82EF3CB8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF3CBC; continue 'dispatch;
            }
            0x82EF3CBC => {
    //   block [0x82EF3CBC..0x82EF3CE0)
	// 82EF3CBC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3CC0: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3CC4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EF3CC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF3CCC: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EF3CD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF3CD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF3CD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3CDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3CE0 size=148
    let mut pc: u32 = 0x82EF3CE0;
    'dispatch: loop {
        match pc {
            0x82EF3CE0 => {
    //   block [0x82EF3CE0..0x82EF3D38)
	// 82EF3CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3CE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3CE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF3CEC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3CF0: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EF3CF4: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EF3CF8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3CFC: 4BFFFF4D  bl 0x82ef3c48
	ctx.lr = 0x82EF3D00;
	sub_82EF3C48(ctx, base);
	// 82EF3D00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EF3D04: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3D08: 48000309  bl 0x82ef4010
	ctx.lr = 0x82EF3D0C;
	sub_82EF4010(ctx, base);
	// 82EF3D0C: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EF3D10: 40980028  bge cr6, 0x82ef3d38
	if !ctx.cr[6].lt {
	pc = 0x82EF3D38; continue 'dispatch;
	}
	// 82EF3D14: 80C1009C  lwz r6, 0x9c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF3D18: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF3D1C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3D20: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF3D24: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3D28: 48000549  bl 0x82ef4270
	ctx.lr = 0x82EF3D2C;
	sub_82EF4270(ctx, base);
	// 82EF3D2C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3D30: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82EF3D34: 4800002C  b 0x82ef3d60
	pc = 0x82EF3D60; continue 'dispatch;
            }
            0x82EF3D38 => {
    //   block [0x82EF3D38..0x82EF3D60)
	// 82EF3D38: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF3D3C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EF3D40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF3D44: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3D48: 4BFFAD41  bl 0x82eeea88
	ctx.lr = 0x82EF3D4C;
	sub_82EEEA88(ctx, base);
	// 82EF3D4C: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EF3D50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EF3D54: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3D58: 80C10060  lwz r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF3D5C: 480002FD  bl 0x82ef4058
	ctx.lr = 0x82EF3D60;
	sub_82EF4058(ctx, base);
	pc = 0x82EF3D60; continue 'dispatch;
            }
            0x82EF3D60 => {
    //   block [0x82EF3D60..0x82EF3D74)
	// 82EF3D60: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EF3D64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF3D68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3D6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF3D70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3D78 size=136
    let mut pc: u32 = 0x82EF3D78;
    'dispatch: loop {
        match pc {
            0x82EF3D78 => {
    //   block [0x82EF3D78..0x82EF3E00)
	// 82EF3D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3D7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3D80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3D84: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF3D88: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF3D8C: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82EF3D90: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF3D94: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3D98: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF3D9C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF3DA0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82EF3DA4: 48000C05  bl 0x82ef49a8
	ctx.lr = 0x82EF3DA8;
	sub_82EF49A8(ctx, base);
	// 82EF3DA8: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3DAC: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF3DB0: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3DB4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF3DB8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82EF3DBC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3DC0: 480003E1  bl 0x82ef41a0
	ctx.lr = 0x82EF3DC4;
	sub_82EF41A0(ctx, base);
	// 82EF3DC4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3DC8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF3DCC: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82EF3DD0: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3DD4: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EF3DD8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3DDC: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EF3DE0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF3DE4: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF3DE8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EF3DEC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3DF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF3DF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF3DF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3DFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3E00 size=92
    let mut pc: u32 = 0x82EF3E00;
    'dispatch: loop {
        match pc {
            0x82EF3E00 => {
    //   block [0x82EF3E00..0x82EF3E5C)
	// 82EF3E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3E04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3E08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3E0C: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EF3E10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF3E14: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3E18: 4BFFAC71  bl 0x82eeea88
	ctx.lr = 0x82EF3E1C;
	sub_82EEEA88(ctx, base);
	// 82EF3E1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3E20: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EF3E24: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF3E28: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EF3E2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EF3E30: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3E34: 4BFFFDD5  bl 0x82ef3c08
	ctx.lr = 0x82EF3E38;
	sub_82EF3C08(ctx, base);
	// 82EF3E38: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EF3E3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EF3E40: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF3E44: E8C10068  ld r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82EF3E48: 480002C9  bl 0x82ef4110
	ctx.lr = 0x82EF3E4C;
	sub_82EF4110(ctx, base);
	// 82EF3E4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EF3E50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF3E54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3E58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3E60 size=60
    let mut pc: u32 = 0x82EF3E60;
    'dispatch: loop {
        match pc {
            0x82EF3E60 => {
    //   block [0x82EF3E60..0x82EF3E8C)
	// 82EF3E60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3E64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3E68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3E6C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF3E70: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3E74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF3E7C: 419A0010  beq cr6, 0x82ef3e8c
	if ctx.cr[6].eq {
	pc = 0x82EF3E8C; continue 'dispatch;
	}
	// 82EF3E80: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3E84: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3E88: 48004411  bl 0x82ef8298
	ctx.lr = 0x82EF3E8C;
	sub_82EF8298(ctx, base);
	pc = 0x82EF3E8C; continue 'dispatch;
            }
            0x82EF3E8C => {
    //   block [0x82EF3E8C..0x82EF3E9C)
	// 82EF3E8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF3E90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF3E94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3E98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3EA0 size=108
    let mut pc: u32 = 0x82EF3EA0;
    'dispatch: loop {
        match pc {
            0x82EF3EA0 => {
    //   block [0x82EF3EA0..0x82EF3EF8)
	// 82EF3EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3EA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3EA8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3EAC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF3EB0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF3EB4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3EB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3EBC: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3EC0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF3EC4: 419A0034  beq cr6, 0x82ef3ef8
	if ctx.cr[6].eq {
	pc = 0x82EF3EF8; continue 'dispatch;
	}
	// 82EF3EC8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3ECC: 480003F5  bl 0x82ef42c0
	ctx.lr = 0x82EF3ED0;
	sub_82EF42C0(ctx, base);
	// 82EF3ED0: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3ED4: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3ED8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EF3EDC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3EE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF3EE8: 419A0010  beq cr6, 0x82ef3ef8
	if ctx.cr[6].eq {
	pc = 0x82EF3EF8; continue 'dispatch;
	}
	// 82EF3EEC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3EF0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3EF4: 48003EC5  bl 0x82ef7db8
	ctx.lr = 0x82EF3EF8;
	sub_82EF7DB8(ctx, base);
	pc = 0x82EF3EF8; continue 'dispatch;
            }
            0x82EF3EF8 => {
    //   block [0x82EF3EF8..0x82EF3F0C)
	// 82EF3EF8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3EFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF3F00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF3F04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3F08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3F10 size=64
    let mut pc: u32 = 0x82EF3F10;
    'dispatch: loop {
        match pc {
            0x82EF3F10 => {
    //   block [0x82EF3F10..0x82EF3F40)
	// 82EF3F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3F14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3F18: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3F1C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF3F20: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3F24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3F28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF3F2C: 419A0014  beq cr6, 0x82ef3f40
	if ctx.cr[6].eq {
	pc = 0x82EF3F40; continue 'dispatch;
	}
	// 82EF3F30: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF3F34: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3F38: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3F3C: 4BFF9BF5  bl 0x82eedb30
	ctx.lr = 0x82EF3F40;
	sub_82EEDB30(ctx, base);
	pc = 0x82EF3F40; continue 'dispatch;
            }
            0x82EF3F40 => {
    //   block [0x82EF3F40..0x82EF3F50)
	// 82EF3F40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF3F44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF3F48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3F4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3F50 size=108
    let mut pc: u32 = 0x82EF3F50;
    'dispatch: loop {
        match pc {
            0x82EF3F50 => {
    //   block [0x82EF3F50..0x82EF3FA8)
	// 82EF3F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3F54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3F58: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3F5C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF3F60: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF3F64: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3F68: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3F6C: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3F70: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF3F74: 419A0034  beq cr6, 0x82ef3fa8
	if ctx.cr[6].eq {
	pc = 0x82EF3FA8; continue 'dispatch;
	}
	// 82EF3F78: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3F7C: 4800038D  bl 0x82ef4308
	ctx.lr = 0x82EF3F80;
	sub_82EF4308(ctx, base);
	// 82EF3F80: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3F84: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3F88: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EF3F8C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3F90: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3F94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF3F98: 419A0010  beq cr6, 0x82ef3fa8
	if ctx.cr[6].eq {
	pc = 0x82EF3FA8; continue 'dispatch;
	}
	// 82EF3F9C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3FA0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF3FA4: 480016ED  bl 0x82ef5690
	ctx.lr = 0x82EF3FA8;
	sub_82EF5690(ctx, base);
	pc = 0x82EF3FA8; continue 'dispatch;
            }
            0x82EF3FA8 => {
    //   block [0x82EF3FA8..0x82EF3FBC)
	// 82EF3FA8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3FAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF3FB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF3FB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF3FB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF3FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF3FC0 size=80
    let mut pc: u32 = 0x82EF3FC0;
    'dispatch: loop {
        match pc {
            0x82EF3FC0 => {
    //   block [0x82EF3FC0..0x82EF4010)
	// 82EF3FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF3FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF3FC8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF3FCC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF3FD0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF3FD4: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF3FD8: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF3FDC: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82EF3FE0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82EF3FE4: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF3FE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF3FEC: 480003AD  bl 0x82ef4398
	ctx.lr = 0x82EF3FF0;
	sub_82EF4398(ctx, base);
	// 82EF3FF0: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EF3FF4: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF3FF8: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82EF3FFC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4000: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4004: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4008: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF400C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF4010 size=68
    let mut pc: u32 = 0x82EF4010;
    'dispatch: loop {
        match pc {
            0x82EF4010 => {
    //   block [0x82EF4010..0x82EF4030)
	// 82EF4010: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF4014: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF4018: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF401C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF4020: 409A0010  bne cr6, 0x82ef4030
	if !ctx.cr[6].eq {
	pc = 0x82EF4030; continue 'dispatch;
	}
	// 82EF4024: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF4028: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EF402C: 48000020  b 0x82ef404c
	pc = 0x82EF404C; continue 'dispatch;
            }
            0x82EF4030 => {
    //   block [0x82EF4030..0x82EF404C)
	// 82EF4030: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF4034: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF4038: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF403C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF4040: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EF4044: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82EF4048: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF404C; continue 'dispatch;
            }
            0x82EF404C => {
    //   block [0x82EF404C..0x82EF4054)
	// 82EF404C: 8061FFF0  lwz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EF4050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4058 size=184
    let mut pc: u32 = 0x82EF4058;
    'dispatch: loop {
        match pc {
            0x82EF4058 => {
    //   block [0x82EF4058..0x82EF4098)
	// 82EF4058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF405C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4060: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF4064: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF4068: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF406C: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EF4070: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82EF4074: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82EF4078: 90C100BC  stw r6, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[6].u32 ) };
	// 82EF407C: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EF4080: 4BFFFBC9  bl 0x82ef3c48
	ctx.lr = 0x82EF4084;
	sub_82EF3C48(ctx, base);
	// 82EF4084: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EF4088: 40820010  bne 0x82ef4098
	if !ctx.cr[0].eq {
	pc = 0x82EF4098; continue 'dispatch;
	}
	// 82EF408C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF4090: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EF4094: 48000020  b 0x82ef40b4
	pc = 0x82EF40B4; continue 'dispatch;
            }
            0x82EF4098 => {
    //   block [0x82EF4098..0x82EF40B4)
	// 82EF4098: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EF409C: 808100AC  lwz r4, 0xac(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EF40A0: 4BFFFB69  bl 0x82ef3c08
	ctx.lr = 0x82EF40A4;
	sub_82EF3C08(ctx, base);
	// 82EF40A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF40A8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82EF40AC: 480006CD  bl 0x82ef4778
	ctx.lr = 0x82EF40B0;
	sub_82EF4778(ctx, base);
	// 82EF40B0: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	pc = 0x82EF40B4; continue 'dispatch;
            }
            0x82EF40B4 => {
    //   block [0x82EF40B4..0x82EF4110)
	// 82EF40B4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EF40B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF40BC: 80C100BC  lwz r6, 0xbc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EF40C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EF40C4: E88100B0  ld r4, 0xb0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82EF40C8: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EF40CC: 48000305  bl 0x82ef43d0
	ctx.lr = 0x82EF40D0;
	sub_82EF43D0(ctx, base);
	// 82EF40D0: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF40D4: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF40D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EF40DC: 808100AC  lwz r4, 0xac(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EF40E0: 4BFFFB29  bl 0x82ef3c08
	ctx.lr = 0x82EF40E4;
	sub_82EF3C08(ctx, base);
	// 82EF40E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EF40E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EF40EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF40F0: 4BFFFED1  bl 0x82ef3fc0
	ctx.lr = 0x82EF40F4;
	sub_82EF3FC0(ctx, base);
	// 82EF40F4: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF40F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EF40FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4100: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4104: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF4108: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF410C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4110 size=144
    let mut pc: u32 = 0x82EF4110;
    'dispatch: loop {
        match pc {
            0x82EF4110 => {
    //   block [0x82EF4110..0x82EF4178)
	// 82EF4110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4118: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF411C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4120: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF4124: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82EF4128: F8C10088  std r6, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u64 ) };
	// 82EF412C: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82EF4130: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EF4134: 48110305  bl 0x83004438
	ctx.lr = 0x82EF4138;
	sub_83004438(ctx, base);
	// 82EF4138: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF413C: 4182003C  beq 0x82ef4178
	if ctx.cr[0].eq {
	pc = 0x82EF4178; continue 'dispatch;
	}
	// 82EF4140: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4144: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4148: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF414C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF4150: 48000859  bl 0x82ef49a8
	ctx.lr = 0x82EF4154;
	sub_82EF49A8(ctx, base);
	// 82EF4154: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EF4158: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF415C: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF4160: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF4164: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4168: 48000039  bl 0x82ef41a0
	ctx.lr = 0x82EF416C;
	sub_82EF41A0(ctx, base);
	// 82EF416C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4170: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF4174: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82EF4178; continue 'dispatch;
            }
            0x82EF4178 => {
    //   block [0x82EF4178..0x82EF41A0)
	// 82EF4178: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF417C: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EF4180: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF4184: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4188: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EF418C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4190: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4194: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4198: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF419C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF41A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF41A0 size=56
    let mut pc: u32 = 0x82EF41A0;
    'dispatch: loop {
        match pc {
            0x82EF41A0 => {
    //   block [0x82EF41A0..0x82EF41D8)
	// 82EF41A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF41A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF41A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF41AC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF41B0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF41B4: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF41B8: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF41BC: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF41C0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF41C4: 4800087D  bl 0x82ef4a40
	ctx.lr = 0x82EF41C8;
	sub_82EF4A40(ctx, base);
	// 82EF41C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF41CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF41D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF41D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF41D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF41D8 size=148
    let mut pc: u32 = 0x82EF41D8;
    'dispatch: loop {
        match pc {
            0x82EF41D8 => {
    //   block [0x82EF41D8..0x82EF4238)
	// 82EF41D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF41DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF41E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF41E4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF41E8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF41EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF41F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF41F4: 419A0044  beq cr6, 0x82ef4238
	if ctx.cr[6].eq {
	pc = 0x82EF4238; continue 'dispatch;
	}
	// 82EF41F8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF41FC: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF4200: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4204: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF4208: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF420C: 4BFFFF95  bl 0x82ef41a0
	ctx.lr = 0x82EF4210;
	sub_82EF41A0(ctx, base);
	// 82EF4210: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4214: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4218: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF421C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF4220: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EF4224: 7D651670  srawi r5, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82EF4228: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF422C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF4230: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4234: 48110B3D  bl 0x83004d70
	ctx.lr = 0x82EF4238;
	sub_83004D70(ctx, base);
	pc = 0x82EF4238; continue 'dispatch;
            }
            0x82EF4238 => {
    //   block [0x82EF4238..0x82EF426C)
	// 82EF4238: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF423C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF4240: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EF4244: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4248: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF424C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EF4250: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4254: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF4258: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EF425C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4270 size=80
    let mut pc: u32 = 0x82EF4270;
    'dispatch: loop {
        match pc {
            0x82EF4270 => {
    //   block [0x82EF4270..0x82EF42C0)
	// 82EF4270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4278: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF427C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4280: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF4284: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF4288: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EF428C: 80C10074  lwz r6, 0x74(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4290: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF4294: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4298: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF429C: 480007F5  bl 0x82ef4a90
	ctx.lr = 0x82EF42A0;
	sub_82EF4A90(ctx, base);
	// 82EF42A0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF42A4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF42A8: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF42AC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF42B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF42B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF42B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF42BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF42C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF42C0 size=72
    let mut pc: u32 = 0x82EF42C0;
    'dispatch: loop {
        match pc {
            0x82EF42C0 => {
    //   block [0x82EF42C0..0x82EF42EC)
	// 82EF42C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF42C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF42C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF42CC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF42D0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF42D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF42D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF42DC: 419A0010  beq cr6, 0x82ef42ec
	if ctx.cr[6].eq {
	pc = 0x82EF42EC; continue 'dispatch;
	}
	// 82EF42E0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF42E4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF42E8: 48003FB1  bl 0x82ef8298
	ctx.lr = 0x82EF42EC;
	sub_82EF8298(ctx, base);
	pc = 0x82EF42EC; continue 'dispatch;
            }
            0x82EF42EC => {
    //   block [0x82EF42EC..0x82EF4308)
	// 82EF42EC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF42F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF42F4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF42F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF42FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4300: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4304: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4308 size=76
    let mut pc: u32 = 0x82EF4308;
    'dispatch: loop {
        match pc {
            0x82EF4308 => {
    //   block [0x82EF4308..0x82EF4338)
	// 82EF4308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF430C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4310: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4314: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4318: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF431C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF4320: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF4324: 419A0014  beq cr6, 0x82ef4338
	if ctx.cr[6].eq {
	pc = 0x82EF4338; continue 'dispatch;
	}
	// 82EF4328: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EF432C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4330: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF4334: 4BFF97FD  bl 0x82eedb30
	ctx.lr = 0x82EF4338;
	sub_82EEDB30(ctx, base);
	pc = 0x82EF4338; continue 'dispatch;
            }
            0x82EF4338 => {
    //   block [0x82EF4338..0x82EF4354)
	// 82EF4338: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF433C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF4340: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF4344: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4348: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF434C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4358 size=60
    let mut pc: u32 = 0x82EF4358;
    'dispatch: loop {
        match pc {
            0x82EF4358 => {
    //   block [0x82EF4358..0x82EF4394)
	// 82EF4358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF435C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4360: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4364: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4368: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF436C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF4370: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4374: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4378: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF437C: 4800042D  bl 0x82ef47a8
	ctx.lr = 0x82EF4380;
	sub_82EF47A8(ctx, base);
	// 82EF4380: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4384: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4388: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF438C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4398 size=52
    let mut pc: u32 = 0x82EF4398;
    'dispatch: loop {
        match pc {
            0x82EF4398 => {
    //   block [0x82EF4398..0x82EF43CC)
	// 82EF4398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF439C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF43A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF43A4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF43A8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF43AC: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF43B0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF43B4: 4800047D  bl 0x82ef4830
	ctx.lr = 0x82EF43B8;
	sub_82EF4830(ctx, base);
	// 82EF43B8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF43BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF43C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF43C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF43C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF43D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF43D0 size=932
    let mut pc: u32 = 0x82EF43D0;
    'dispatch: loop {
        match pc {
            0x82EF43D0 => {
    //   block [0x82EF43D0..0x82EF4418)
	// 82EF43D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF43D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF43D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF43DC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF43E0: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EF43E4: F8810098  std r4, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[4].u64 ) };
	// 82EF43E8: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EF43EC: 90C100AC  stw r6, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[6].u32 ) };
	// 82EF43F0: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EF43F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF43F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF43FC: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4400: 4BFFFC11  bl 0x82ef4010
	ctx.lr = 0x82EF4404;
	sub_82EF4010(ctx, base);
	// 82EF4404: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EF4408: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF440C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF4410: 409A0008  bne cr6, 0x82ef4418
	if !ctx.cr[6].eq {
	pc = 0x82EF4418; continue 'dispatch;
	}
	// 82EF4414: 4800034C  b 0x82ef4760
	pc = 0x82EF4760; continue 'dispatch;
            }
            0x82EF4418 => {
    //   block [0x82EF4418..0x82EF4444)
	// 82EF4418: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF441C: 4BFF92FD  bl 0x82eed718
	ctx.lr = 0x82EF4420;
	sub_82EED718(ctx, base);
	// 82EF4420: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EF4424: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4428: 4BFFF821  bl 0x82ef3c48
	ctx.lr = 0x82EF442C;
	sub_82EF3C48(ctx, base);
	// 82EF442C: 7D63F850  subf r11, r3, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[3].s64;
	// 82EF4430: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF4434: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF4438: 4098000C  bge cr6, 0x82ef4444
	if !ctx.cr[6].lt {
	pc = 0x82EF4444; continue 'dispatch;
	}
	// 82EF443C: 4BFF9305  bl 0x82eed740
	ctx.lr = 0x82EF4440;
	sub_82EED740(ctx, base);
	// 82EF4440: 48000320  b 0x82ef4760
	pc = 0x82EF4760; continue 'dispatch;
            }
            0x82EF4444 => {
    //   block [0x82EF4444..0x82EF4490)
	// 82EF4444: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4448: 4BFFF801  bl 0x82ef3c48
	ctx.lr = 0x82EF444C;
	sub_82EF3C48(ctx, base);
	// 82EF444C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF4450: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82EF4454: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4458: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EF445C: 409801B0  bge cr6, 0x82ef460c
	if !ctx.cr[6].lt {
	pc = 0x82EF460C; continue 'dispatch;
	}
	// 82EF4460: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4464: 4BFF92B5  bl 0x82eed718
	ctx.lr = 0x82EF4468;
	sub_82EED718(ctx, base);
	// 82EF4468: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF446C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EF4470: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82EF4474: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82EF4478: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF447C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF4480: 40980010  bge cr6, 0x82ef4490
	if !ctx.cr[6].lt {
	pc = 0x82EF4490; continue 'dispatch;
	}
	// 82EF4484: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF4488: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EF448C: 4800001C  b 0x82ef44a8
	pc = 0x82EF44A8; continue 'dispatch;
            }
            0x82EF4490 => {
    //   block [0x82EF4490..0x82EF44A8)
	// 82EF4490: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4494: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EF4498: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82EF449C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF44A0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF44A4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF44A8; continue 'dispatch;
            }
            0x82EF44A8 => {
    //   block [0x82EF44A8..0x82EF44E0)
	// 82EF44A8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EF44AC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF44B0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF44B4: 4BFFF795  bl 0x82ef3c48
	ctx.lr = 0x82EF44B8;
	sub_82EF3C48(ctx, base);
	// 82EF44B8: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF44BC: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82EF44C0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF44C4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EF44C8: 40980018  bge cr6, 0x82ef44e0
	if !ctx.cr[6].lt {
	pc = 0x82EF44E0; continue 'dispatch;
	}
	// 82EF44CC: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF44D0: 4BFFF779  bl 0x82ef3c48
	ctx.lr = 0x82EF44D4;
	sub_82EF3C48(ctx, base);
	// 82EF44D4: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF44D8: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82EF44DC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF44E0; continue 'dispatch;
            }
            0x82EF44E0 => {
    //   block [0x82EF44E0..0x82EF4568)
	// 82EF44E0: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF44E4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF44E8: 4BFF92B9  bl 0x82eed7a0
	ctx.lr = 0x82EF44EC;
	sub_82EED7A0(ctx, base);
	// 82EF44EC: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82EF44F0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF44F4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EF44F8: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF44FC: 80A1009C  lwz r5, 0x9c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF4500: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4504: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF4508: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF450C: 480005F5  bl 0x82ef4b00
	ctx.lr = 0x82EF4510;
	sub_82EF4B00(ctx, base);
	// 82EF4510: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EF4514: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EF4518: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF451C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF4520: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4524: 4BFFFD4D  bl 0x82ef4270
	ctx.lr = 0x82EF4528;
	sub_82EF4270(ctx, base);
	// 82EF4528: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EF452C: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF4530: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4534: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF4538: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF453C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4540: 480005C1  bl 0x82ef4b00
	ctx.lr = 0x82EF4544;
	sub_82EF4B00(ctx, base);
	// 82EF4544: 48000024  b 0x82ef4568
	pc = 0x82EF4568; continue 'dispatch;
	// 82EF4548: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF454C: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF4550: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4554: 4BFFFC4D  bl 0x82ef41a0
	ctx.lr = 0x82EF4558;
	sub_82EF41A0(ctx, base);
	// 82EF4558: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF455C: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF4560: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4564: 4811080D  bl 0x83004d70
	ctx.lr = 0x82EF4568;
	sub_83004D70(ctx, base);
            }
            0x82EF4568 => {
    //   block [0x82EF4568..0x82EF45CC)
	// 82EF4568: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF456C: 4BFFF6DD  bl 0x82ef3c48
	ctx.lr = 0x82EF4570;
	sub_82EF3C48(ctx, base);
	// 82EF4570: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF4574: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82EF4578: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EF457C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4580: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF4584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF4588: 419A0044  beq cr6, 0x82ef45cc
	if ctx.cr[6].eq {
	pc = 0x82EF45CC; continue 'dispatch;
	}
	// 82EF458C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4590: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF4594: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4598: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF459C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF45A0: 4BFFFC01  bl 0x82ef41a0
	ctx.lr = 0x82EF45A4;
	sub_82EF41A0(ctx, base);
	// 82EF45A4: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF45A8: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF45AC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EF45B0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF45B4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EF45B8: 7D651670  srawi r5, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82EF45BC: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF45C0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF45C4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF45C8: 481107A9  bl 0x83004d70
	ctx.lr = 0x82EF45CC;
	sub_83004D70(ctx, base);
	pc = 0x82EF45CC; continue 'dispatch;
            }
            0x82EF45CC => {
    //   block [0x82EF45CC..0x82EF460C)
	// 82EF45CC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF45D0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF45D4: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF45D8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF45DC: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF45E0: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EF45E4: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF45E8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF45EC: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF45F0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF45F4: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF45F8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EF45FC: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4600: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF4604: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EF4608: 48000158  b 0x82ef4760
	pc = 0x82EF4760; continue 'dispatch;
            }
            0x82EF460C => {
    //   block [0x82EF460C..0x82EF46B0)
	// 82EF460C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4610: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF4614: 8141009C  lwz r10, 0x9c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF4618: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EF461C: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82EF4620: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF4624: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF4628: 409800C8  bge cr6, 0x82ef46f0
	if !ctx.cr[6].lt {
	pc = 0x82EF46F0; continue 'dispatch;
	}
	// 82EF462C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF4630: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF4634: 8141009C  lwz r10, 0x9c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF4638: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF463C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4640: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF4644: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF4648: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF464C: 480004B5  bl 0x82ef4b00
	ctx.lr = 0x82EF4650;
	sub_82EF4B00(ctx, base);
	// 82EF4650: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EF4654: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4658: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF465C: 8141009C  lwz r10, 0x9c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF4660: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EF4664: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82EF4668: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF466C: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EF4670: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4674: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF4678: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF467C: 4BFFFBF5  bl 0x82ef4270
	ctx.lr = 0x82EF4680;
	sub_82EF4270(ctx, base);
	// 82EF4680: 48000030  b 0x82ef46b0
	pc = 0x82EF46B0; continue 'dispatch;
	// 82EF4684: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4688: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF468C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EF4690: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF4694: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EF4698: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF469C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF46A0: 8141009C  lwz r10, 0x9c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF46A4: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF46A8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF46AC: 4BFFFAF5  bl 0x82ef41a0
	ctx.lr = 0x82EF46B0;
	sub_82EF41A0(ctx, base);
            }
            0x82EF46B0 => {
    //   block [0x82EF46B0..0x82EF46F0)
	// 82EF46B0: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF46B4: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF46B8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EF46BC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF46C0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EF46C4: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF46C8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EF46CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF46D0: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF46D4: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF46D8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EF46DC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF46E0: 7C8A5850  subf r4, r10, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EF46E4: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF46E8: 48000459  bl 0x82ef4b40
	ctx.lr = 0x82EF46EC;
	sub_82EF4B40(ctx, base);
	// 82EF46EC: 48000074  b 0x82ef4760
	pc = 0x82EF4760; continue 'dispatch;
            }
            0x82EF46F0 => {
    //   block [0x82EF46F0..0x82EF4760)
	// 82EF46F0: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF46F4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF46F8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EF46FC: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4700: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF4704: 80A10060  lwz r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF4708: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF470C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF4710: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF4714: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EF4718: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF471C: 480003E5  bl 0x82ef4b00
	ctx.lr = 0x82EF4720;
	sub_82EF4B00(ctx, base);
	// 82EF4720: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4724: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82EF4728: 80A10060  lwz r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF472C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF4730: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF4734: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF4738: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EF473C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF4740: 48000461  bl 0x82ef4ba0
	ctx.lr = 0x82EF4744;
	sub_82EF4BA0(ctx, base);
	// 82EF4744: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF4748: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF474C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF4750: 8141009C  lwz r10, 0x9c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF4754: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF4758: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF475C: 480003E5  bl 0x82ef4b40
	ctx.lr = 0x82EF4760;
	sub_82EF4B40(ctx, base);
	pc = 0x82EF4760; continue 'dispatch;
            }
            0x82EF4760 => {
    //   block [0x82EF4760..0x82EF4774)
	// 82EF4760: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EF4764: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4768: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF476C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF4770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4778 size=48
    let mut pc: u32 = 0x82EF4778;
    'dispatch: loop {
        match pc {
            0x82EF4778 => {
    //   block [0x82EF4778..0x82EF47A8)
	// 82EF4778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF477C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4780: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4784: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4788: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF478C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4790: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4794: 48000135  bl 0x82ef48c8
	ctx.lr = 0x82EF4798;
	sub_82EF48C8(ctx, base);
	// 82EF4798: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF479C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF47A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF47A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF47A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF47A8 size=132
    let mut pc: u32 = 0x82EF47A8;
    'dispatch: loop {
        match pc {
            0x82EF47A8 => {
    //   block [0x82EF47A8..0x82EF47FC)
	// 82EF47A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF47AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF47B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF47B4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF47B8: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF47BC: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF47C0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF47C4: 4811054D  bl 0x83004d10
	ctx.lr = 0x82EF47C8;
	sub_83004D10(ctx, base);
	// 82EF47C8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF47CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF47D0: 419A002C  beq cr6, 0x82ef47fc
	if ctx.cr[6].eq {
	pc = 0x82EF47FC; continue 'dispatch;
	}
	// 82EF47D4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF47D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF47DC: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF47E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF47E4: 41990018  bgt cr6, 0x82ef47fc
	if ctx.cr[6].gt {
	pc = 0x82EF47FC; continue 'dispatch;
	}
	// 82EF47E8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF47EC: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF47F0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF47F4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EF47F8: 40990008  ble cr6, 0x82ef4800
	if !ctx.cr[6].gt {
	pc = 0x82EF4800; continue 'dispatch;
	}
	pc = 0x82EF47FC; continue 'dispatch;
            }
            0x82EF47FC => {
    //   block [0x82EF47FC..0x82EF4800)
	// 82EF47FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF4800; continue 'dispatch;
            }
            0x82EF4800 => {
    //   block [0x82EF4800..0x82EF482C)
	// 82EF4800: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4804: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4808: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EF480C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4810: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4814: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EF4818: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF481C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4820: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4824: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4828: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF4830 size=148
    let mut pc: u32 = 0x82EF4830;
    'dispatch: loop {
        match pc {
            0x82EF4830 => {
    //   block [0x82EF4830..0x82EF484C)
	// 82EF4830: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF4834: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EF4838: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF483C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF4840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF4844: 409A0008  bne cr6, 0x82ef484c
	if !ctx.cr[6].eq {
	pc = 0x82EF484C; continue 'dispatch;
	}
	// 82EF4848: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF484C; continue 'dispatch;
            }
            0x82EF484C => {
    //   block [0x82EF484C..0x82EF489C)
	// 82EF484C: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF4850: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF4854: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EF4858: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF485C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EF4860: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF4864: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF4868: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF486C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF4870: 4199002C  bgt cr6, 0x82ef489c
	if ctx.cr[6].gt {
	pc = 0x82EF489C; continue 'dispatch;
	}
	// 82EF4874: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF4878: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF487C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EF4880: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF4884: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EF4888: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF488C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF4890: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF4894: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF4898: 40980008  bge cr6, 0x82ef48a0
	if !ctx.cr[6].lt {
	pc = 0x82EF48A0; continue 'dispatch;
	}
	pc = 0x82EF489C; continue 'dispatch;
            }
            0x82EF489C => {
    //   block [0x82EF489C..0x82EF48A0)
	// 82EF489C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF48A0; continue 'dispatch;
            }
            0x82EF48A0 => {
    //   block [0x82EF48A0..0x82EF48C4)
	// 82EF48A0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF48A4: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF48A8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EF48AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF48B0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EF48B4: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF48B8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EF48BC: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF48C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF48C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF48C8 size=80
    let mut pc: u32 = 0x82EF48C8;
    'dispatch: loop {
        match pc {
            0x82EF48C8 => {
    //   block [0x82EF48C8..0x82EF48F8)
	// 82EF48C8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF48CC: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EF48D0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF48D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF48D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF48DC: 419A001C  beq cr6, 0x82ef48f8
	if ctx.cr[6].eq {
	pc = 0x82EF48F8; continue 'dispatch;
	}
	// 82EF48E0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF48E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF48E8: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF48EC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF48F0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF48F4: 419A0008  beq cr6, 0x82ef48fc
	if ctx.cr[6].eq {
	pc = 0x82EF48FC; continue 'dispatch;
	}
	pc = 0x82EF48F8; continue 'dispatch;
            }
            0x82EF48F8 => {
    //   block [0x82EF48F8..0x82EF48FC)
	// 82EF48F8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82EF48FC; continue 'dispatch;
            }
            0x82EF48FC => {
    //   block [0x82EF48FC..0x82EF4918)
	// 82EF48FC: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF4900: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF4904: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF4908: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EF490C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EF4910: 7D631670  srawi r3, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82EF4914: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4918 size=72
    let mut pc: u32 = 0x82EF4918;
    'dispatch: loop {
        match pc {
            0x82EF4918 => {
    //   block [0x82EF4918..0x82EF4960)
	// 82EF4918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF491C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4920: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4924: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4928: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF492C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF4930: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF4934: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4938: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF493C: 480008E5  bl 0x82ef5220
	ctx.lr = 0x82EF4940;
	sub_82EF5220(ctx, base);
	// 82EF4940: 39630000  addi r11, r3, 0
	ctx.r[11].s64 = ctx.r[3].s64 + 0;
	// 82EF4944: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EF4948: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EF494C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EF4950: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4954: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4958: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF495C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4960 size=72
    let mut pc: u32 = 0x82EF4960;
    'dispatch: loop {
        match pc {
            0x82EF4960 => {
    //   block [0x82EF4960..0x82EF49A8)
	// 82EF4960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4968: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF496C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4970: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF4974: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF4978: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EF497C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4980: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4984: 4BFF903D  bl 0x82eed9c0
	ctx.lr = 0x82EF4988;
	sub_82EED9C0(ctx, base);
	// 82EF4988: 39630000  addi r11, r3, 0
	ctx.r[11].s64 = ctx.r[3].s64 + 0;
	// 82EF498C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EF4990: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EF4994: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EF4998: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF499C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF49A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF49A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF49A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF49A8 size=152
    let mut pc: u32 = 0x82EF49A8;
    'dispatch: loop {
        match pc {
            0x82EF49A8 => {
    //   block [0x82EF49A8..0x82EF4A40)
	// 82EF49A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF49AC: 4BDB4A61  bl 0x82ca940c
	ctx.lr = 0x82EF49B0;
	sub_82CA93D0(ctx, base);
	// 82EF49B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF49B4: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EF49B8: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EF49BC: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EF49C0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF49C4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF49C8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF49CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF49D0: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EF49D4: 388100A4  addi r4, r1, 0xa4
	ctx.r[4].s64 = ctx.r[1].s64 + 164;
	// 82EF49D8: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82EF49DC: 4BFFADB5  bl 0x82eef790
	ctx.lr = 0x82EF49E0;
	sub_82EEF790(ctx, base);
	// 82EF49E0: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EF49E4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF49E8: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EF49EC: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EF49F0: 99610059  stb r11, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[11].u8 ) };
	// 82EF49F4: 38A100A4  addi r5, r1, 0xa4
	ctx.r[5].s64 = ctx.r[1].s64 + 164;
	// 82EF49F8: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82EF49FC: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 82EF4A00: 48000239  bl 0x82ef4c38
	ctx.lr = 0x82EF4A04;
	sub_82EF4C38(ctx, base);
	// 82EF4A04: 8BE30000  lbz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF4A08: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF4A0C: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 82EF4A10: 4BFFAD51  bl 0x82eef760
	ctx.lr = 0x82EF4A14;
	sub_82EEF760(ctx, base);
	// 82EF4A14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EF4A18: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82EF4A1C: 4BFFAD45  bl 0x82eef760
	ctx.lr = 0x82EF4A20;
	sub_82EEF760(ctx, base);
	// 82EF4A20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EF4A24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EF4A28: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EF4A2C: 88E10059  lbz r7, 0x59(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82EF4A30: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF4A34: 4800021D  bl 0x82ef4c50
	ctx.lr = 0x82EF4A38;
	sub_82EF4C50(ctx, base);
	// 82EF4A38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EF4A3C: 4BDB4A20  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4A40 size=76
    let mut pc: u32 = 0x82EF4A40;
    'dispatch: loop {
        match pc {
            0x82EF4A40 => {
    //   block [0x82EF4A40..0x82EF4A8C)
	// 82EF4A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4A44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4A48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4A4C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4A50: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF4A54: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF4A58: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82EF4A5C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EF4A60: 4BFFAD31  bl 0x82eef790
	ctx.lr = 0x82EF4A64;
	sub_82EEF790(ctx, base);
	// 82EF4A64: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
	// 82EF4A68: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF4A6C: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4A70: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4A74: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4A78: 48000261  bl 0x82ef4cd8
	ctx.lr = 0x82EF4A7C;
	sub_82EF4CD8(ctx, base);
	// 82EF4A7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4A80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4A84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4A88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4A90 size=108
    let mut pc: u32 = 0x82EF4A90;
    'dispatch: loop {
        match pc {
            0x82EF4A90 => {
    //   block [0x82EF4A90..0x82EF4AFC)
	// 82EF4A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4A94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4A98: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4A9C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4AA0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF4AA4: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF4AA8: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EF4AAC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF4AB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF4AB4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4AB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF4ABC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EF4AC0: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82EF4AC4: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EF4AC8: 4BFFACC9  bl 0x82eef790
	ctx.lr = 0x82EF4ACC;
	sub_82EEF790(ctx, base);
	// 82EF4ACC: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EF4AD0: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF4AD4: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EF4AD8: 80C1008C  lwz r6, 0x8c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF4ADC: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4AE0: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4AE4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4AE8: 48000209  bl 0x82ef4cf0
	ctx.lr = 0x82EF4AEC;
	sub_82EF4CF0(ctx, base);
	// 82EF4AEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4AF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4AF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4AF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4B00 size=64
    let mut pc: u32 = 0x82EF4B00;
    'dispatch: loop {
        match pc {
            0x82EF4B00 => {
    //   block [0x82EF4B00..0x82EF4B40)
	// 82EF4B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4B04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4B08: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4B0C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4B10: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF4B14: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF4B18: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EF4B1C: 80C10074  lwz r6, 0x74(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4B20: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF4B24: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4B28: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4B2C: 4800020D  bl 0x82ef4d38
	ctx.lr = 0x82EF4B30;
	sub_82EF4D38(ctx, base);
	// 82EF4B30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4B34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4B38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4B3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4B40 size=92
    let mut pc: u32 = 0x82EF4B40;
    'dispatch: loop {
        match pc {
            0x82EF4B40 => {
    //   block [0x82EF4B40..0x82EF4B9C)
	// 82EF4B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4B44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4B48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EF4B4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EF4B50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4B54: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF4B58: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EF4B5C: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82EF4B60: 83E10094  lwz r31, 0x94(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4B64: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82EF4B68: 4BFFABF9  bl 0x82eef760
	ctx.lr = 0x82EF4B6C;
	sub_82EEF760(ctx, base);
	// 82EF4B6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EF4B70: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82EF4B74: 4BFFABED  bl 0x82eef760
	ctx.lr = 0x82EF4B78;
	sub_82EEF760(ctx, base);
	// 82EF4B78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EF4B7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EF4B80: 48000241  bl 0x82ef4dc0
	ctx.lr = 0x82EF4B84;
	sub_82EF4DC0(ctx, base);
	// 82EF4B84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF4B88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4B8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4B90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EF4B94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EF4B98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4BA0 size=148
    let mut pc: u32 = 0x82EF4BA0;
    'dispatch: loop {
        match pc {
            0x82EF4BA0 => {
    //   block [0x82EF4BA0..0x82EF4C34)
	// 82EF4BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4BA4: 4BDB4869  bl 0x82ca940c
	ctx.lr = 0x82EF4BA8;
	sub_82CA93D0(ctx, base);
	// 82EF4BA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4BAC: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EF4BB0: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EF4BB4: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EF4BB8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF4BBC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF4BC0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4BC4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF4BC8: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EF4BCC: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EF4BD0: 48000239  bl 0x82ef4e08
	ctx.lr = 0x82EF4BD4;
	sub_82EF4E08(ctx, base);
	// 82EF4BD4: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EF4BD8: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF4BDC: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EF4BE0: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EF4BE4: 99610059  stb r11, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[11].u8 ) };
	// 82EF4BE8: 38A100A4  addi r5, r1, 0xa4
	ctx.r[5].s64 = ctx.r[1].s64 + 164;
	// 82EF4BEC: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82EF4BF0: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 82EF4BF4: 48000045  bl 0x82ef4c38
	ctx.lr = 0x82EF4BF8;
	sub_82EF4C38(ctx, base);
	// 82EF4BF8: 8BE30000  lbz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF4BFC: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF4C00: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 82EF4C04: 4BFFAB5D  bl 0x82eef760
	ctx.lr = 0x82EF4C08;
	sub_82EEF760(ctx, base);
	// 82EF4C08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EF4C0C: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82EF4C10: 4BFFAB51  bl 0x82eef760
	ctx.lr = 0x82EF4C14;
	sub_82EEF760(ctx, base);
	// 82EF4C14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EF4C18: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EF4C1C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EF4C20: 88E10059  lbz r7, 0x59(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82EF4C24: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF4C28: 480001F1  bl 0x82ef4e18
	ctx.lr = 0x82EF4C2C;
	sub_82EF4E18(ctx, base);
	// 82EF4C2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EF4C30: 4BDB482C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF4C38 size=20
    let mut pc: u32 = 0x82EF4C38;
    'dispatch: loop {
        match pc {
            0x82EF4C38 => {
    //   block [0x82EF4C38..0x82EF4C4C)
	// 82EF4C38: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF4C3C: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EF4C40: 90A10024  stw r5, 0x24(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), ctx.r[5].u32 ) };
	// 82EF4C44: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF4C48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4C50 size=136
    let mut pc: u32 = 0x82EF4C50;
    'dispatch: loop {
        match pc {
            0x82EF4C50 => {
    //   block [0x82EF4C50..0x82EF4CC4)
	// 82EF4C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4C54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4C58: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4C5C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4C60: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF4C64: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF4C68: 98C1008F  stb r6, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[6].u8 ) };
	// 82EF4C6C: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EF4C70: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EF4C74: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4C78: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4C7C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EF4C80: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82EF4C84: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF4C88: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4C8C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF4C90: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4C94: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF4C98: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF4C9C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4CA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF4CA4: 40990020  ble cr6, 0x82ef4cc4
	if !ctx.cr[6].gt {
	pc = 0x82EF4CC4; continue 'dispatch;
	}
	// 82EF4CA8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4CAC: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EF4CB0: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4CB4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4CB8: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82EF4CBC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4CC0: 4BDB5369  bl 0x82caa028
	ctx.lr = 0x82EF4CC4;
	sub_82CAA028(ctx, base);
	pc = 0x82EF4CC4; continue 'dispatch;
            }
            0x82EF4CC4 => {
    //   block [0x82EF4CC4..0x82EF4CD8)
	// 82EF4CC4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF4CC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4CCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4CD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4CD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF4CD8 size=20
    let mut pc: u32 = 0x82EF4CD8;
    'dispatch: loop {
        match pc {
            0x82EF4CD8 => {
    //   block [0x82EF4CD8..0x82EF4CEC)
	// 82EF4CD8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF4CDC: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EF4CE0: 90A10024  stw r5, 0x24(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), ctx.r[5].u32 ) };
	// 82EF4CE4: 98C1002F  stb r6, 0x2f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(47 as u32), ctx.r[6].u8 ) };
	// 82EF4CE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4CF0 size=68
    let mut pc: u32 = 0x82EF4CF0;
    'dispatch: loop {
        match pc {
            0x82EF4CF0 => {
    //   block [0x82EF4CF0..0x82EF4D34)
	// 82EF4CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4CF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4CFC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4D00: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF4D04: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF4D08: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EF4D0C: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EF4D10: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EF4D14: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4D18: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4D1C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4D20: 48000189  bl 0x82ef4ea8
	ctx.lr = 0x82EF4D24;
	sub_82EF4EA8(ctx, base);
	// 82EF4D24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4D28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4D2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4D30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4D38 size=132
    let mut pc: u32 = 0x82EF4D38;
    'dispatch: loop {
        match pc {
            0x82EF4D38 => {
    //   block [0x82EF4D38..0x82EF4DBC)
	// 82EF4D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4D3C: 4BDB46CD  bl 0x82ca9408
	ctx.lr = 0x82EF4D40;
	sub_82CA93D0(ctx, base);
	// 82EF4D40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4D44: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EF4D48: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82EF4D4C: 90A100B4  stw r5, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[5].u32 ) };
	// 82EF4D50: 90C100BC  stw r6, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[6].u32 ) };
	// 82EF4D54: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF4D58: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF4D5C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4D60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF4D64: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EF4D68: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 82EF4D6C: 4800009D  bl 0x82ef4e08
	ctx.lr = 0x82EF4D70;
	sub_82EF4E08(ctx, base);
	// 82EF4D70: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EF4D74: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF4D78: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EF4D7C: 8BE10051  lbz r31, 0x51(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EF4D80: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EF4D84: 83A100B4  lwz r29, 0xb4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EF4D88: 386100AC  addi r3, r1, 0xac
	ctx.r[3].s64 = ctx.r[1].s64 + 172;
	// 82EF4D8C: 4BFFA9D5  bl 0x82eef760
	ctx.lr = 0x82EF4D90;
	sub_82EEF760(ctx, base);
	// 82EF4D90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EF4D94: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EF4D98: 4BFFA9C9  bl 0x82eef760
	ctx.lr = 0x82EF4D9C;
	sub_82EEF760(ctx, base);
	// 82EF4D9C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EF4DA0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EF4DA4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EF4DA8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82EF4DAC: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF4DB0: 48000161  bl 0x82ef4f10
	ctx.lr = 0x82EF4DB4;
	sub_82EF4F10(ctx, base);
	// 82EF4DB4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EF4DB8: 4BDB46A0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF4DC0 size=68
    let mut pc: u32 = 0x82EF4DC0;
    'dispatch: loop {
        match pc {
            0x82EF4DC0 => {
    //   block [0x82EF4DC0..0x82EF4DD0)
	// 82EF4DC0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF4DC4: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EF4DC8: 90A10024  stw r5, 0x24(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), ctx.r[5].u32 ) };
	// 82EF4DCC: 48000010  b 0x82ef4ddc
	pc = 0x82EF4DDC; continue 'dispatch;
            }
            0x82EF4DD0 => {
    //   block [0x82EF4DD0..0x82EF4DDC)
	// 82EF4DD0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF4DD4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EF4DD8: 91610014  stw r11, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF4DDC; continue 'dispatch;
            }
            0x82EF4DDC => {
    //   block [0x82EF4DDC..0x82EF4E00)
	// 82EF4DDC: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF4DE0: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF4DE4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF4DE8: 419A0018  beq cr6, 0x82ef4e00
	if ctx.cr[6].eq {
	pc = 0x82EF4E00; continue 'dispatch;
	}
	// 82EF4DEC: 81610024  lwz r11, 0x24(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EF4DF0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF4DF4: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF4DF8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EF4DFC: 4BFFFFD4  b 0x82ef4dd0
	pc = 0x82EF4DD0; continue 'dispatch;
            }
            0x82EF4E00 => {
    //   block [0x82EF4E00..0x82EF4E04)
	// 82EF4E00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF4E08 size=12
    let mut pc: u32 = 0x82EF4E08;
    'dispatch: loop {
        match pc {
            0x82EF4E08 => {
    //   block [0x82EF4E08..0x82EF4E14)
	// 82EF4E08: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF4E0C: 8861FFF0  lbz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EF4E10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4E18 size=116
    let mut pc: u32 = 0x82EF4E18;
    'dispatch: loop {
        match pc {
            0x82EF4E18 => {
    //   block [0x82EF4E18..0x82EF4E8C)
	// 82EF4E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4E20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4E24: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4E28: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF4E2C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF4E30: 98C1008F  stb r6, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[6].u8 ) };
	// 82EF4E34: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EF4E38: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EF4E3C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF4E40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF4E44: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4E48: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF4E4C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EF4E50: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 82EF4E54: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EF4E58: 4BFFA939  bl 0x82eef790
	ctx.lr = 0x82EF4E5C;
	sub_82EEF790(ctx, base);
	// 82EF4E5C: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EF4E60: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF4E64: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EF4E68: 88C1008F  lbz r6, 0x8f(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(143 as u32) ) } as u64;
	// 82EF4E6C: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4E70: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4E74: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4E78: 480000E1  bl 0x82ef4f58
	ctx.lr = 0x82EF4E7C;
	sub_82EF4F58(ctx, base);
	// 82EF4E7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4E80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4E84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4E88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF4E90 size=20
    let mut pc: u32 = 0x82EF4E90;
    'dispatch: loop {
        match pc {
            0x82EF4E90 => {
    //   block [0x82EF4E90..0x82EF4EA4)
	// 82EF4E90: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF4E94: 9881001F  stb r4, 0x1f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(31 as u32), ctx.r[4].u8 ) };
	// 82EF4E98: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF4E9C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF4EA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4EA8 size=104
    let mut pc: u32 = 0x82EF4EA8;
    'dispatch: loop {
        match pc {
            0x82EF4EA8 => {
    //   block [0x82EF4EA8..0x82EF4F10)
	// 82EF4EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4EAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4EB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4EB4: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF4EB8: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EF4EBC: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82EF4EC0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF4EC4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF4EC8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4ECC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF4ED0: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EF4ED4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF4ED8: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EF4EDC: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 82EF4EE0: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 82EF4EE4: 4BFF88AD  bl 0x82eed790
	ctx.lr = 0x82EF4EE8;
	sub_82EED790(ctx, base);
	// 82EF4EE8: 88C30000  lbz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF4EEC: 80A10094  lwz r5, 0x94(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF4EF0: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF4EF4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4EF8: 88E10058  lbz r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF4EFC: 480000E5  bl 0x82ef4fe0
	ctx.lr = 0x82EF4F00;
	sub_82EF4FE0(ctx, base);
	// 82EF4F00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF4F04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4F08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4F0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4F10 size=72
    let mut pc: u32 = 0x82EF4F10;
    'dispatch: loop {
        match pc {
            0x82EF4F10 => {
    //   block [0x82EF4F10..0x82EF4F58)
	// 82EF4F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4F14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4F18: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4F1C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4F20: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF4F24: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF4F28: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EF4F2C: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EF4F30: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EF4F34: 80C1008C  lwz r6, 0x8c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF4F38: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4F3C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4F40: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4F44: 48000115  bl 0x82ef5058
	ctx.lr = 0x82EF4F48;
	sub_82EF5058(ctx, base);
	// 82EF4F48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4F4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4F50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4F54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4F58 size=136
    let mut pc: u32 = 0x82EF4F58;
    'dispatch: loop {
        match pc {
            0x82EF4F58 => {
    //   block [0x82EF4F58..0x82EF4FCC)
	// 82EF4F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4F5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF4F60: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4F64: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF4F68: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF4F6C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF4F70: 98C1008F  stb r6, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[6].u8 ) };
	// 82EF4F74: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EF4F78: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EF4F7C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF4F80: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4F84: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EF4F88: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82EF4F8C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF4F90: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4F94: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF4F98: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF4F9C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EF4FA0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF4FA4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4FA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF4FAC: 40990020  ble cr6, 0x82ef4fcc
	if !ctx.cr[6].gt {
	pc = 0x82EF4FCC; continue 'dispatch;
	}
	// 82EF4FB0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4FB4: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EF4FB8: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF4FBC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF4FC0: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82EF4FC4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF4FC8: 4BDB5061  bl 0x82caa028
	ctx.lr = 0x82EF4FCC;
	sub_82CAA028(ctx, base);
	pc = 0x82EF4FCC; continue 'dispatch;
            }
            0x82EF4FCC => {
    //   block [0x82EF4FCC..0x82EF4FE0)
	// 82EF4FCC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF4FD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF4FD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF4FD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF4FDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF4FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF4FE0 size=116
    let mut pc: u32 = 0x82EF4FE0;
    'dispatch: loop {
        match pc {
            0x82EF4FE0 => {
    //   block [0x82EF4FE0..0x82EF5054)
	// 82EF4FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF4FE4: 4BDB4429  bl 0x82ca940c
	ctx.lr = 0x82EF4FE8;
	sub_82CA93D0(ctx, base);
	// 82EF4FE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF4FEC: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EF4FF0: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82EF4FF4: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82EF4FF8: 98C100AF  stb r6, 0xaf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(175 as u32), ctx.r[6].u8 ) };
	// 82EF4FFC: 98E100B7  stb r7, 0xb7(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(183 as u32), ctx.r[7].u8 ) };
	// 82EF5000: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF5004: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF5008: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF500C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF5010: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF5014: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 82EF5018: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EF501C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF5020: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF5024: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EF5028: 8BE10054  lbz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF502C: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EF5030: 83A1009C  lwz r29, 0x9c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF5034: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82EF5038: 4BFFA729  bl 0x82eef760
	ctx.lr = 0x82EF503C;
	sub_82EEF760(ctx, base);
	// 82EF503C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EF5040: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EF5044: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EF5048: 48000099  bl 0x82ef50e0
	ctx.lr = 0x82EF504C;
	sub_82EF50E0(ctx, base);
	// 82EF504C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EF5050: 4BDB440C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF5058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF5058 size=136
    let mut pc: u32 = 0x82EF5058;
    'dispatch: loop {
        match pc {
            0x82EF5058 => {
    //   block [0x82EF5058..0x82EF50E0)
	// 82EF5058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF505C: 4BDB43AD  bl 0x82ca9408
	ctx.lr = 0x82EF5060;
	sub_82CA93D0(ctx, base);
	// 82EF5060: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF5064: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EF5068: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82EF506C: 90A100B4  stw r5, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[5].u32 ) };
	// 82EF5070: 90C100BC  stw r6, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[6].u32 ) };
	// 82EF5074: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF5078: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF507C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF5080: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF5084: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EF5088: 388100B4  addi r4, r1, 0xb4
	ctx.r[4].s64 = ctx.r[1].s64 + 180;
	// 82EF508C: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EF5090: 4BFFA701  bl 0x82eef790
	ctx.lr = 0x82EF5094;
	sub_82EEF790(ctx, base);
	// 82EF5094: 98610051  stb r3, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[3].u8 ) };
	// 82EF5098: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF509C: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EF50A0: 8BE10051  lbz r31, 0x51(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82EF50A4: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EF50A8: 83A100B4  lwz r29, 0xb4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EF50AC: 386100AC  addi r3, r1, 0xac
	ctx.r[3].s64 = ctx.r[1].s64 + 172;
	// 82EF50B0: 4BFFA6B1  bl 0x82eef760
	ctx.lr = 0x82EF50B4;
	sub_82EEF760(ctx, base);
	// 82EF50B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EF50B8: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82EF50BC: 4BFFA6A5  bl 0x82eef760
	ctx.lr = 0x82EF50C0;
	sub_82EEF760(ctx, base);
	// 82EF50C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EF50C4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EF50C8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EF50CC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82EF50D0: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF50D4: 4800005D  bl 0x82ef5130
	ctx.lr = 0x82EF50D8;
	sub_82EF5130(ctx, base);
	// 82EF50D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EF50DC: 4BDB437C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF50E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF50E0 size=80
    let mut pc: u32 = 0x82EF50E0;
    'dispatch: loop {
        match pc {
            0x82EF50E0 => {
    //   block [0x82EF50E0..0x82EF50F4)
	// 82EF50E0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF50E4: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EF50E8: 90A10024  stw r5, 0x24(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), ctx.r[5].u32 ) };
	// 82EF50EC: 98C1002F  stb r6, 0x2f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(47 as u32), ctx.r[6].u8 ) };
	// 82EF50F0: 4800001C  b 0x82ef510c
	pc = 0x82EF510C; continue 'dispatch;
            }
            0x82EF50F4 => {
    //   block [0x82EF50F4..0x82EF510C)
	// 82EF50F4: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF50F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EF50FC: 9161001C  stw r11, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EF5100: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF5104: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EF5108: 91610014  stw r11, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF510C; continue 'dispatch;
            }
            0x82EF510C => {
    //   block [0x82EF510C..0x82EF512C)
	// 82EF510C: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF5110: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF5114: 40990018  ble cr6, 0x82ef512c
	if !ctx.cr[6].gt {
	pc = 0x82EF512C; continue 'dispatch;
	}
	// 82EF5118: 81610024  lwz r11, 0x24(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EF511C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF5120: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF5124: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EF5128: 4BFFFFCC  b 0x82ef50f4
	pc = 0x82EF50F4; continue 'dispatch;
            }
            0x82EF512C => {
    //   block [0x82EF512C..0x82EF5130)
	// 82EF512C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF5130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF5130 size=136
    let mut pc: u32 = 0x82EF5130;
    'dispatch: loop {
        match pc {
            0x82EF5130 => {
    //   block [0x82EF5130..0x82EF51A4)
	// 82EF5130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF5134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF5138: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF513C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF5140: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF5144: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF5148: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EF514C: 98E10097  stb r7, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[7].u8 ) };
	// 82EF5150: 9901009F  stb r8, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[8].u8 ) };
	// 82EF5154: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF5158: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF515C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EF5160: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82EF5164: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF5168: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF516C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EF5170: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF5174: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EF5178: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF517C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF5180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF5184: 40990020  ble cr6, 0x82ef51a4
	if !ctx.cr[6].gt {
	pc = 0x82EF51A4; continue 'dispatch;
	}
	// 82EF5188: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF518C: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EF5190: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF5194: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF5198: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82EF519C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF51A0: 4BDB4E89  bl 0x82caa028
	ctx.lr = 0x82EF51A4;
	sub_82CAA028(ctx, base);
	pc = 0x82EF51A4; continue 'dispatch;
            }
            0x82EF51A4 => {
    //   block [0x82EF51A4..0x82EF51B8)
	// 82EF51A4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF51A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF51AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF51B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF51B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF51B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF51B8 size=8
    let mut pc: u32 = 0x82EF51B8;
    'dispatch: loop {
        match pc {
            0x82EF51B8 => {
    //   block [0x82EF51B8..0x82EF51C0)
	// 82EF51B8: 3863FFEC  addi r3, r3, -0x14
	ctx.r[3].s64 = ctx.r[3].s64 + -20;
	// 82EF51BC: 4BFFB2B4  b 0x82ef0470
	sub_82EF0470(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF51C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF51C0 size=96
    let mut pc: u32 = 0x82EF51C0;
    'dispatch: loop {
        match pc {
            0x82EF51C0 => {
    //   block [0x82EF51C0..0x82EF5220)
	// 82EF51C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF51C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF51C8: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82EF51CC: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82EF51D0: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82EF51D4: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 82EF51D8: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 82EF51DC: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 82EF51E0: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 82EF51E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF51E8: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF51EC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF51F0: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 82EF51F4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF51F8: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF51FC: 80810074  lwz r4, 0x74(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF5200: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EF5204: 481FD225  bl 0x830f2428
	ctx.lr = 0x82EF5208;
	sub_830F2428(ctx, base);
	// 82EF5208: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF520C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF5210: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF5214: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF5218: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF521C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF5220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF5220 size=100
    let mut pc: u32 = 0x82EF5220;
    'dispatch: loop {
        match pc {
            0x82EF5220 => {
    //   block [0x82EF5220..0x82EF5254)
	// 82EF5220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF5224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF5228: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF522C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF5230: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF5234: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EF5238: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF523C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF5240: 409A0014  bne cr6, 0x82ef5254
	if !ctx.cr[6].eq {
	pc = 0x82EF5254; continue 'dispatch;
	}
	// 82EF5244: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF5248: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 82EF524C: 7C6B5910  subfe r3, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[3].u32 = res;
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82EF5250: 48000024  b 0x82ef5274
	pc = 0x82EF5274; continue 'dispatch;
            }
            0x82EF5254 => {
    //   block [0x82EF5254..0x82EF5268)
	// 82EF5254: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF5258: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF525C: 409A000C  bne cr6, 0x82ef5268
	if !ctx.cr[6].eq {
	pc = 0x82EF5268; continue 'dispatch;
	}
	// 82EF5260: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EF5264: 48000010  b 0x82ef5274
	pc = 0x82EF5274; continue 'dispatch;
            }
            0x82EF5268 => {
    //   block [0x82EF5268..0x82EF5274)
	// 82EF5268: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF526C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF5270: 48113F31  bl 0x830091a0
	ctx.lr = 0x82EF5274;
	sub_830091A0(ctx, base);
	pc = 0x82EF5274; continue 'dispatch;
            }
            0x82EF5274 => {
    //   block [0x82EF5274..0x82EF5284)
	// 82EF5274: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF5278: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF527C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF5280: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF5288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF5288 size=204
    let mut pc: u32 = 0x82EF5288;
    'dispatch: loop {
        match pc {
            0x82EF5288 => {
    //   block [0x82EF5288..0x82EF52BC)
	// 82EF5288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF528C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF5290: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF5294: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF5298: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EF529C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF52A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF52A4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF52A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF52AC: 409A0010  bne cr6, 0x82ef52bc
	if !ctx.cr[6].eq {
	pc = 0x82EF52BC; continue 'dispatch;
	}
	// 82EF52B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF52B4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EF52B8: 48000018  b 0x82ef52d0
	pc = 0x82EF52D0; continue 'dispatch;
            }
            0x82EF52BC => {
    //   block [0x82EF52BC..0x82EF52D0)
	// 82EF52BC: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 82EF52C0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82EF52C4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF52C8: 4BDB7841  bl 0x82cacb08
	ctx.lr = 0x82EF52CC;
	sub_82CACB08(ctx, base);
	// 82EF52CC: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	pc = 0x82EF52D0; continue 'dispatch;
            }
            0x82EF52D0 => {
    //   block [0x82EF52D0..0x82EF5334)
	// 82EF52D0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF52D4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF52D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF52DC: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF52E0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EF52E4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF52E8: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF52EC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF52F0: 419A0044  beq cr6, 0x82ef5334
	if ctx.cr[6].eq {
	pc = 0x82EF5334; continue 'dispatch;
	}
	// 82EF52F4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF52F8: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF52FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF5300: 409A0034  bne cr6, 0x82ef5334
	if !ctx.cr[6].eq {
	pc = 0x82EF5334; continue 'dispatch;
	}
	// 82EF5304: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF5308: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 82EF530C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EF5310: 41980024  blt cr6, 0x82ef5334
	if ctx.cr[6].lt {
	pc = 0x82EF5334; continue 'dispatch;
	}
	// 82EF5314: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF5318: 3D407FFF  lis r10, 0x7fff
	ctx.r[10].s64 = 2147418112;
	// 82EF531C: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82EF5320: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EF5324: 41990010  bgt cr6, 0x82ef5334
	if ctx.cr[6].gt {
	pc = 0x82EF5334; continue 'dispatch;
	}
	// 82EF5328: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EF532C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EF5330: 4800000C  b 0x82ef533c
	pc = 0x82EF533C; continue 'dispatch;
            }
            0x82EF5334 => {
    //   block [0x82EF5334..0x82EF533C)
	// 82EF5334: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF5338: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF533C; continue 'dispatch;
            }
            0x82EF533C => {
    //   block [0x82EF533C..0x82EF5354)
	// 82EF533C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EF5340: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EF5344: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF5348: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF534C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF5350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF5358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF5358 size=160
    let mut pc: u32 = 0x82EF5358;
    'dispatch: loop {
        match pc {
            0x82EF5358 => {
    //   block [0x82EF5358..0x82EF538C)
	// 82EF5358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF535C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF5360: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF5364: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF5368: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EF536C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF5370: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF5374: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF5378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF537C: 409A0010  bne cr6, 0x82ef538c
	if !ctx.cr[6].eq {
	pc = 0x82EF538C; continue 'dispatch;
	}
	// 82EF5380: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF5384: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EF5388: 48000018  b 0x82ef53a0
	pc = 0x82EF53A0; continue 'dispatch;
            }
            0x82EF538C => {
    //   block [0x82EF538C..0x82EF53A0)
	// 82EF538C: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 82EF5390: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EF5394: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF5398: 4BDB7791  bl 0x82cacb28
	ctx.lr = 0x82EF539C;
	sub_82CACB28(ctx, base);
	// 82EF539C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	pc = 0x82EF53A0; continue 'dispatch;
            }
            0x82EF53A0 => {
    //   block [0x82EF53A0..0x82EF53D8)
	// 82EF53A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF53A4: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF53A8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EF53AC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF53B0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF53B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF53B8: 419A0020  beq cr6, 0x82ef53d8
	if ctx.cr[6].eq {
	pc = 0x82EF53D8; continue 'dispatch;
	}
	// 82EF53BC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF53C0: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF53C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF53C8: 409A0010  bne cr6, 0x82ef53d8
	if !ctx.cr[6].eq {
	pc = 0x82EF53D8; continue 'dispatch;
	}
	// 82EF53CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EF53D0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EF53D4: 4800000C  b 0x82ef53e0
	pc = 0x82EF53E0; continue 'dispatch;
            }
            0x82EF53D8 => {
    //   block [0x82EF53D8..0x82EF53E0)
	// 82EF53D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF53DC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF53E0; continue 'dispatch;
            }
            0x82EF53E0 => {
    //   block [0x82EF53E0..0x82EF53F8)
	// 82EF53E0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF53E4: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EF53E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF53EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF53F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF53F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF53F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF53F8 size=160
    let mut pc: u32 = 0x82EF53F8;
    'dispatch: loop {
        match pc {
            0x82EF53F8 => {
    //   block [0x82EF53F8..0x82EF5430)
	// 82EF53F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF53FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF5400: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF5404: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF5408: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EF540C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF5410: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF5414: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF5418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF541C: 409A0014  bne cr6, 0x82ef5430
	if !ctx.cr[6].eq {
	pc = 0x82EF5430; continue 'dispatch;
	}
	// 82EF5420: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF5424: C80B0D38  lfd f0, 0xd38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82EF5428: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82EF542C: 48000014  b 0x82ef5440
	pc = 0x82EF5440; continue 'dispatch;
            }
            0x82EF5430 => {
    //   block [0x82EF5430..0x82EF5440)
	// 82EF5430: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EF5434: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF5438: 48113F91  bl 0x830093c8
	ctx.lr = 0x82EF543C;
	sub_830093C8(ctx, base);
	// 82EF543C: D8210058  stfd f1, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[1].u64 ) };
	pc = 0x82EF5440; continue 'dispatch;
            }
            0x82EF5440 => {
    //   block [0x82EF5440..0x82EF5478)
	// 82EF5440: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82EF5444: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF5448: D80B0000  stfd f0, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.f[0].u64 ) };
	// 82EF544C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF5450: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF5454: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF5458: 419A0020  beq cr6, 0x82ef5478
	if ctx.cr[6].eq {
	pc = 0x82EF5478; continue 'dispatch;
	}
	// 82EF545C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF5460: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF5464: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EF5468: 40820010  bne 0x82ef5478
	if !ctx.cr[0].eq {
	pc = 0x82EF5478; continue 'dispatch;
	}
	// 82EF546C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EF5470: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EF5474: 4800000C  b 0x82ef5480
	pc = 0x82EF5480; continue 'dispatch;
            }
            0x82EF5478 => {
    //   block [0x82EF5478..0x82EF5480)
	// 82EF5478: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF547C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF5480; continue 'dispatch;
            }
            0x82EF5480 => {
    //   block [0x82EF5480..0x82EF5498)
	// 82EF5480: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF5484: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EF5488: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF548C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF5490: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF5494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF5498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EF5498 size=164
    let mut pc: u32 = 0x82EF5498;
    'dispatch: loop {
        match pc {
            0x82EF5498 => {
    //   block [0x82EF5498..0x82EF54D0)
	// 82EF5498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF549C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF54A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF54A4: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF54A8: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EF54AC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF54B0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF54B4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF54B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF54BC: 409A0014  bne cr6, 0x82ef54d0
	if !ctx.cr[6].eq {
	pc = 0x82EF54D0; continue 'dispatch;
	}
	// 82EF54C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EF54C4: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF54C8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EF54CC: 48000018  b 0x82ef54e4
	pc = 0x82EF54E4; continue 'dispatch;
            }
            0x82EF54D0 => {
    //   block [0x82EF54D0..0x82EF54E4)
	// 82EF54D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EF54D4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF54D8: 4BDBACB9  bl 0x82cb0190
	ctx.lr = 0x82EF54DC;
	sub_82CB0190(ctx, base);
	// 82EF54DC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EF54E0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x82EF54E4; continue 'dispatch;
            }
            0x82EF54E4 => {
    //   block [0x82EF54E4..0x82EF551C)
	// 82EF54E4: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EF54E8: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF54EC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EF54F0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF54F4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF54F8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EF54FC: 419A0020  beq cr6, 0x82ef551c
	if ctx.cr[6].eq {
	pc = 0x82EF551C; continue 'dispatch;
	}
	// 82EF5500: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF5504: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF5508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF550C: 409A0010  bne cr6, 0x82ef551c
	if !ctx.cr[6].eq {
	pc = 0x82EF551C; continue 'dispatch;
	}
	// 82EF5510: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EF5514: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EF5518: 4800000C  b 0x82ef5524
	pc = 0x82EF5524; continue 'dispatch;
            }
            0x82EF551C => {
    //   block [0x82EF551C..0x82EF5524)
	// 82EF551C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF5520: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF5524; continue 'dispatch;
            }
            0x82EF5524 => {
    //   block [0x82EF5524..0x82EF553C)
	// 82EF5524: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EF5528: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EF552C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF5530: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF5534: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF5538: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF5540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF5540 size=160
    let mut pc: u32 = 0x82EF5540;
    'dispatch: loop {
        match pc {
            0x82EF5540 => {
    //   block [0x82EF5540..0x82EF5598)
	// 82EF5540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF5544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF5548: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF554C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF5550: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF5554: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF5558: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF555C: 419A0070  beq cr6, 0x82ef55cc
	if ctx.cr[6].eq {
	pc = 0x82EF55CC; continue 'dispatch;
	}
	// 82EF5560: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF5564: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF5568: 7D640774  extsb r4, r11
	ctx.r[4].s64 = ctx.r[11].s8 as i64;
	// 82EF556C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF5570: 386BCE14  addi r3, r11, -0x31ec
	ctx.r[3].s64 = ctx.r[11].s64 + -12780;
	// 82EF5574: 4BDB4C9D  bl 0x82caa210
	ctx.lr = 0x82EF5578;
	sub_82CAA210(ctx, base);
	// 82EF5578: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EF557C: 4182001C  beq 0x82ef5598
	if ctx.cr[0].eq {
	pc = 0x82EF5598; continue 'dispatch;
	}
	// 82EF5580: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF5584: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EF5588: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EF558C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EF5590: 48000040  b 0x82ef55d0
	pc = 0x82EF55D0; continue 'dispatch;
	// 82EF5594: 48000038  b 0x82ef55cc
	pc = 0x82EF55CC; continue 'dispatch;
            }
            0x82EF5598 => {
    //   block [0x82EF5598..0x82EF55CC)
	// 82EF5598: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF559C: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF55A0: 7D640774  extsb r4, r11
	ctx.r[4].s64 = ctx.r[11].s8 as i64;
	// 82EF55A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EF55A8: 386BCE0C  addi r3, r11, -0x31f4
	ctx.r[3].s64 = ctx.r[11].s64 + -12788;
	// 82EF55AC: 4BDB4C65  bl 0x82caa210
	ctx.lr = 0x82EF55B0;
	sub_82CAA210(ctx, base);
	// 82EF55B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EF55B4: 41820018  beq 0x82ef55cc
	if ctx.cr[0].eq {
	pc = 0x82EF55CC; continue 'dispatch;
	}
	// 82EF55B8: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF55BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF55C0: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EF55C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EF55C8: 48000008  b 0x82ef55d0
	pc = 0x82EF55D0; continue 'dispatch;
            }
            0x82EF55CC => {
    //   block [0x82EF55CC..0x82EF55D0)
	// 82EF55CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EF55D0; continue 'dispatch;
            }
            0x82EF55D0 => {
    //   block [0x82EF55D0..0x82EF55E0)
	// 82EF55D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF55D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF55D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF55DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF55E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF55E0 size=72
    let mut pc: u32 = 0x82EF55E0;
    'dispatch: loop {
        match pc {
            0x82EF55E0 => {
    //   block [0x82EF55E0..0x82EF5608)
	// 82EF55E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF55E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF55E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF55EC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF55F0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF55F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EF55F8: 409A0010  bne cr6, 0x82ef5608
	if !ctx.cr[6].eq {
	pc = 0x82EF5608; continue 'dispatch;
	}
	// 82EF55FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF5600: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF5604: 48000010  b 0x82ef5614
	pc = 0x82EF5614; continue 'dispatch;
            }
            0x82EF5608 => {
    //   block [0x82EF5608..0x82EF5614)
	// 82EF5608: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF560C: 4B285A75  bl 0x8217b080
	ctx.lr = 0x82EF5610;
	sub_8217B080(ctx, base);
	// 82EF5610: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	pc = 0x82EF5614; continue 'dispatch;
            }
            0x82EF5614 => {
    //   block [0x82EF5614..0x82EF5628)
	// 82EF5614: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF5618: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF561C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF5620: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF5624: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF5628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF5628 size=104
    let mut pc: u32 = 0x82EF5628;
    'dispatch: loop {
        match pc {
            0x82EF5628 => {
    //   block [0x82EF5628..0x82EF5690)
	// 82EF5628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF562C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF5630: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82EF5634: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82EF5638: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 82EF563C: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 82EF5640: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 82EF5644: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 82EF5648: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF564C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF5650: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF5654: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EF5658: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82EF565C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF5660: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EF5664: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF5668: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF566C: 481162C5  bl 0x8300b930
	ctx.lr = 0x82EF5670;
	sub_8300B930(ctx, base);
	// 82EF5670: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EF5674: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF5678: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EF567C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EF5680: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF5684: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF5688: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF568C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF5690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF5690 size=56
    let mut pc: u32 = 0x82EF5690;
    'dispatch: loop {
        match pc {
            0x82EF5690 => {
    //   block [0x82EF5690..0x82EF56C8)
	// 82EF5690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF5694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF5698: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF569C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF56A0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF56A4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF56A8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF56AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF56B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF56B4: 4E800421  bctrl
	ctx.lr = 0x82EF56B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF56B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF56BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF56C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF56C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF56C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF56C8 size=40
    let mut pc: u32 = 0x82EF56C8;
    'dispatch: loop {
        match pc {
            0x82EF56C8 => {
    //   block [0x82EF56C8..0x82EF56F0)
	// 82EF56C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF56CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF56D0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF56D4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF56D8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF56DC: 480081C5  bl 0x82efd8a0
	ctx.lr = 0x82EF56E0;
	sub_82EFD8A0(ctx, base);
	// 82EF56E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF56E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF56E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF56EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF56F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF56F0 size=68
    let mut pc: u32 = 0x82EF56F0;
    'dispatch: loop {
        match pc {
            0x82EF56F0 => {
    //   block [0x82EF56F0..0x82EF5734)
	// 82EF56F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF56F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF56F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF56FC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF5700: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF5704: 80A1007C  lwz r5, 0x7c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF5708: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 82EF570C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF5710: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF5714: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF5718: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF571C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF5720: 4E800421  bctrl
	ctx.lr = 0x82EF5724;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF5724: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF5728: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF572C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF5730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF5738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF5738 size=68
    let mut pc: u32 = 0x82EF5738;
    'dispatch: loop {
        match pc {
            0x82EF5738 => {
    //   block [0x82EF5738..0x82EF577C)
	// 82EF5738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF573C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF5740: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF5744: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EF5748: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EF574C: 80A1007C  lwz r5, 0x7c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EF5750: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82EF5754: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF5758: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF575C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EF5760: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EF5764: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF5768: 4E800421  bctrl
	ctx.lr = 0x82EF576C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF576C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EF5770: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF5774: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF5778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF5780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF5780 size=24
    let mut pc: u32 = 0x82EF5780;
    'dispatch: loop {
        match pc {
            0x82EF5780 => {
    //   block [0x82EF5780..0x82EF5798)
	// 82EF5780: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF5784: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF5788: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF578C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF5790: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF5794: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF5798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF5798 size=40
    let mut pc: u32 = 0x82EF5798;
    'dispatch: loop {
        match pc {
            0x82EF5798 => {
    //   block [0x82EF5798..0x82EF57C0)
	// 82EF5798: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF579C: D8210018  stfd f1, 0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 82EF57A0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF57A4: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82EF57A8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF57AC: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF57B0: C8010018  lfd f0, 0x18(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82EF57B4: D80B0008  stfd f0, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.f[0].u64 ) };
	// 82EF57B8: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF57BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF57C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF57C0 size=36
    let mut pc: u32 = 0x82EF57C0;
    'dispatch: loop {
        match pc {
            0x82EF57C0 => {
    //   block [0x82EF57C0..0x82EF57E4)
	// 82EF57C0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF57C4: 9881001F  stb r4, 0x1f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(31 as u32), ctx.r[4].u8 ) };
	// 82EF57C8: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF57CC: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EF57D0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF57D4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF57D8: 8941001F  lbz r10, 0x1f(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(31 as u32) ) } as u64;
	// 82EF57DC: 994B0008  stb r10, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82EF57E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF57E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF57E8 size=36
    let mut pc: u32 = 0x82EF57E8;
    'dispatch: loop {
        match pc {
            0x82EF57E8 => {
    //   block [0x82EF57E8..0x82EF580C)
	// 82EF57E8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF57EC: D8210018  stfd f1, 0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 82EF57F0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF57F4: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82EF57F8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF57FC: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF5800: C8010018  lfd f0, 0x18(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82EF5804: D80B0008  stfd f0, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.f[0].u64 ) };
	// 82EF5808: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF5810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF5810 size=36
    let mut pc: u32 = 0x82EF5810;
    'dispatch: loop {
        match pc {
            0x82EF5810 => {
    //   block [0x82EF5810..0x82EF5834)
	// 82EF5810: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF5814: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EF5818: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF581C: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82EF5820: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EF5824: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF5828: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF582C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EF5830: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF5838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EF5838 size=132
    let mut pc: u32 = 0x82EF5838;
    'dispatch: loop {
        match pc {
            0x82EF5838 => {
    //   block [0x82EF5838..0x82EF58A0)
	// 82EF5838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EF583C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EF5840: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EF5844: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EF5848: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EF584C: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82EF5850: 90C1009C  stw r6, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[6].u32 ) };
	// 82EF5854: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 82EF5858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF585C: 48000065  bl 0x82ef58c0
	ctx.lr = 0x82EF5860;
	sub_82EF58C0(ctx, base);
	// 82EF5860: 80E1009C  lwz r7, 0x9c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EF5864: 80C10094  lwz r6, 0x94(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EF5868: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EF586C: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EF5870: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF5874: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EF5878: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EF587C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EF5880: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EF5884: 4E800421  bctrl
	ctx.lr = 0x82EF5888;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EF5888: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EF588C: 41820014  beq 0x82ef58a0
	if ctx.cr[0].eq {
	pc = 0x82EF58A0; continue 'dispatch;
	}
	// 82EF5890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EF5894: 48000055  bl 0x82ef58e8
	ctx.lr = 0x82EF5898;
	sub_82EF58E8(ctx, base);
	// 82EF5898: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EF589C: 4800000C  b 0x82ef58a8
	pc = 0x82EF58A8; continue 'dispatch;
            }
            0x82EF58A0 => {
    //   block [0x82EF58A0..0x82EF58A8)
	// 82EF58A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EF58A4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x82EF58A8; continue 'dispatch;
            }
            0x82EF58A8 => {
    //   block [0x82EF58A8..0x82EF58BC)
	// 82EF58A8: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EF58AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EF58B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EF58B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EF58B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EF58C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EF58C0 size=40
    let mut pc: u32 = 0x82EF58C0;
    'dispatch: loop {
        match pc {
            0x82EF58C0 => {
    //   block [0x82EF58C0..0x82EF58E8)
	// 82EF58C0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EF58C4: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EF58C8: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EF58CC: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF58D0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EF58D4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF58D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EF58DC: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EF58E0: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EF58E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


