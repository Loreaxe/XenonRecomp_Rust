pub fn sub_82388E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82388E60 size=60
    let mut pc: u32 = 0x82388E60;
    'dispatch: loop {
        match pc {
            0x82388E60 => {
    //   block [0x82388E60..0x82388E9C)
	// 82388E60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82388E64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82388E68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82388E6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82388E70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82388E74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82388E78: 48054359  bl 0x823dd1d0
	ctx.lr = 0x82388E7C;
	sub_823DD1D0(ctx, base);
	// 82388E7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82388E80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82388E84: 48053DF5  bl 0x823dcc78
	ctx.lr = 0x82388E88;
	sub_823DCC78(ctx, base);
	// 82388E88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82388E8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82388E90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82388E94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82388E98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82388EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82388EA0 size=60
    let mut pc: u32 = 0x82388EA0;
    'dispatch: loop {
        match pc {
            0x82388EA0 => {
    //   block [0x82388EA0..0x82388EDC)
	// 82388EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82388EA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82388EA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82388EAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82388EB0: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 82388EB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82388EB8: 48054319  bl 0x823dd1d0
	ctx.lr = 0x82388EBC;
	sub_823DD1D0(ctx, base);
	// 82388EBC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82388EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82388EC4: 48053DB5  bl 0x823dcc78
	ctx.lr = 0x82388EC8;
	sub_823DCC78(ctx, base);
	// 82388EC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82388ECC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82388ED0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82388ED4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82388ED8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82388EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82388EE0 size=308
    let mut pc: u32 = 0x82388EE0;
    'dispatch: loop {
        match pc {
            0x82388EE0 => {
    //   block [0x82388EE0..0x82389014)
	// 82388EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82388EE4: 481AC1B9  bl 0x8253509c
	ctx.lr = 0x82388EE8;
	sub_82535080(ctx, base);
	// 82388EE8: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 82388EEC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82388EF0: 83ED0000  lwz r31, 0(r13)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82388EF4: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 82388EF8: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82389018 size=324
    let mut pc: u32 = 0x82389018;
    'dispatch: loop {
        match pc {
            0x82389018 => {
    //   block [0x82389018..0x8238915C)
	// 82389018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238901C: 481AC07D  bl 0x82535098
	ctx.lr = 0x82389020;
	sub_82535080(ctx, base);
	// 82389020: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82389024: 83ED0000  lwz r31, 0(r13)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82389028: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 8238902C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82389160 size=460
    let mut pc: u32 = 0x82389160;
    'dispatch: loop {
        match pc {
            0x82389160 => {
    //   block [0x82389160..0x823891DC)
	// 82389160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82389164: 481ABF31  bl 0x82535094
	ctx.lr = 0x82389168;
	sub_82535080(ctx, base);
	// 82389168: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 8238916C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82389170: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82389174: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 82389178: 3CC082C0  lis r6, -0x7d40
	ctx.r[6].s64 = -2101346304;
	// 8238917C: 392ABA70  addi r9, r10, -0x4590
	ctx.r[9].s64 = ctx.r[10].s64 + -17808;
	// 82389180: 3CE082B6  lis r7, -0x7d4a
	ctx.r[7].s64 = -2102001664;
	// 82389184: 816BBF90  lwz r11, -0x4070(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16496 as u32) ) } as u64;
	// 82389188: 3E8082B6  lis r20, -0x7d4a
	ctx.r[20].s64 = -2102001664;
	// 8238918C: 38E7B660  addi r7, r7, -0x49a0
	ctx.r[7].s64 = ctx.r[7].s64 + -18848;
	// 82389190: 390B02E0  addi r8, r11, 0x2e0
	ctx.r[8].s64 = ctx.r[11].s64 + 736;
	// 82389194: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82389198: 390B02F0  addi r8, r11, 0x2f0
	ctx.r[8].s64 = ctx.r[11].s64 + 752;
	// 8238919C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 823891A0: 9166BFB0  stw r11, -0x4050(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(-16464 as u32), ctx.r[11].u32 ) };
	// 823891A4: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 823891A8: E8CA0000  ld r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 823891AC: 80F4B65C  lwz r7, -0x49a4(r20)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-18852 as u32) ) } as u64;
	// 823891B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 823891B4: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 823891B8: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 823891BC: F9490008  std r10, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 823891C0: E9480000  ld r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 823891C4: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 823891C8: E9480008  ld r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 823891CC: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 823891D0: 419A000C  beq cr6, 0x823891dc
	if ctx.cr[6].eq {
	pc = 0x823891DC; continue 'dispatch;
	}
	// 823891D4: C3E70000  lfs f31, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823891D8: 4800000C  b 0x823891e4
	pc = 0x823891E4; continue 'dispatch;
            }
            0x823891DC => {
    //   block [0x823891DC..0x823891E4)
	// 823891DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823891E0: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x823891E4; continue 'dispatch;
            }
            0x823891E4 => {
    //   block [0x823891E4..0x8238932C)
	// 823891E4: 83ED0000  lwz r31, 0(r13)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 823891E8: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 823891EC: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389330 size=16
    let mut pc: u32 = 0x82389330;
    'dispatch: loop {
        match pc {
            0x82389330 => {
    //   block [0x82389330..0x82389340)
	// 82389330: 3964FFFC  addi r11, r4, -4
	ctx.r[11].s64 = ctx.r[4].s64 + -4;
	// 82389334: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82389338: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8238933C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389340 size=16
    let mut pc: u32 = 0x82389340;
    'dispatch: loop {
        match pc {
            0x82389340 => {
    //   block [0x82389340..0x82389350)
	// 82389340: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82389344: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82389348: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8238934C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389350 size=8
    let mut pc: u32 = 0x82389350;
    'dispatch: loop {
        match pc {
            0x82389350 => {
    //   block [0x82389350..0x82389358)
	// 82389350: 548307FE  clrlwi r3, r4, 0x1f
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82389354: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389358 size=8
    let mut pc: u32 = 0x82389358;
    'dispatch: loop {
        match pc {
            0x82389358 => {
    //   block [0x82389358..0x82389360)
	// 82389358: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 8238935C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389360 size=12
    let mut pc: u32 = 0x82389360;
    'dispatch: loop {
        match pc {
            0x82389360 => {
    //   block [0x82389360..0x8238936C)
	// 82389360: 7C8B0034  cntlzw r11, r4
	ctx.r[11].u64 = if ctx.r[4].u32 == 0 { 32 } else { ctx.r[4].u32.leading_zeros() as u64 };
	// 82389364: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82389368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389370 size=16
    let mut pc: u32 = 0x82389370;
    'dispatch: loop {
        match pc {
            0x82389370 => {
    //   block [0x82389370..0x82389380)
	// 82389370: 3964FFF8  addi r11, r4, -8
	ctx.r[11].s64 = ctx.r[4].s64 + -8;
	// 82389374: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82389378: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8238937C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82389380 size=20
    let mut pc: u32 = 0x82389380;
    'dispatch: loop {
        match pc {
            0x82389380 => {
    //   block [0x82389380..0x82389394)
	// 82389380: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82389384: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389388: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8238938C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82389390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82389398 size=12
    let mut pc: u32 = 0x82389398;
    'dispatch: loop {
        match pc {
            0x82389398 => {
    //   block [0x82389398..0x823893A4)
	// 82389398: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238939C: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 823893A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823893A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823893A8 size=20
    let mut pc: u32 = 0x823893A8;
    'dispatch: loop {
        match pc {
            0x823893A8 => {
    //   block [0x823893A8..0x823893BC)
	// 823893A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823893AC: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823893B0: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 823893B4: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823893B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823893C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823893C0 size=12
    let mut pc: u32 = 0x823893C0;
    'dispatch: loop {
        match pc {
            0x823893C0 => {
    //   block [0x823893C0..0x823893CC)
	// 823893C0: C0030034  lfs f0, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823893C4: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 823893C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823893D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823893D0 size=8
    let mut pc: u32 = 0x823893D0;
    'dispatch: loop {
        match pc {
            0x823893D0 => {
    //   block [0x823893D0..0x823893D8)
	// 823893D0: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 823893D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823893D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823893D8 size=16
    let mut pc: u32 = 0x823893D8;
    'dispatch: loop {
        match pc {
            0x823893D8 => {
    //   block [0x823893D8..0x823893E8)
	// 823893D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823893DC: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823893E0: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 823893E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823893E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823893E8 size=28
    let mut pc: u32 = 0x823893E8;
    'dispatch: loop {
        match pc {
            0x823893E8 => {
    //   block [0x823893E8..0x823893FC)
	// 823893E8: 2F040004  cmpwi cr6, r4, 4
	ctx.cr[6].compare_i32(ctx.r[4].s32, 4, &mut ctx.xer);
	// 823893EC: 419A0010  beq cr6, 0x823893fc
	if ctx.cr[6].eq {
	pc = 0x823893FC; continue 'dispatch;
	}
	// 823893F0: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 823893F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823893F8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x823893FC; continue 'dispatch;
            }
            0x823893FC => {
    //   block [0x823893FC..0x82389404)
	// 823893FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82389400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389408 size=8
    let mut pc: u32 = 0x82389408;
    'dispatch: loop {
        match pc {
            0x82389408 => {
    //   block [0x82389408..0x82389410)
	// 82389408: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 8238940C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389410 size=8
    let mut pc: u32 = 0x82389410;
    'dispatch: loop {
        match pc {
            0x82389410 => {
    //   block [0x82389410..0x82389418)
	// 82389410: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 82389414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389418 size=8
    let mut pc: u32 = 0x82389418;
    'dispatch: loop {
        match pc {
            0x82389418 => {
    //   block [0x82389418..0x82389420)
	// 82389418: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 8238941C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389420 size=16
    let mut pc: u32 = 0x82389420;
    'dispatch: loop {
        match pc {
            0x82389420 => {
    //   block [0x82389420..0x82389430)
	// 82389420: 3964FFF0  addi r11, r4, -0x10
	ctx.r[11].s64 = ctx.r[4].s64 + -16;
	// 82389424: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82389428: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8238942C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389430 size=16
    let mut pc: u32 = 0x82389430;
    'dispatch: loop {
        match pc {
            0x82389430 => {
    //   block [0x82389430..0x82389440)
	// 82389430: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82389434: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82389438: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238943C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389440 size=28
    let mut pc: u32 = 0x82389440;
    'dispatch: loop {
        match pc {
            0x82389440 => {
    //   block [0x82389440..0x82389454)
	// 82389440: 2F040010  cmpwi cr6, r4, 0x10
	ctx.cr[6].compare_i32(ctx.r[4].s32, 16, &mut ctx.xer);
	// 82389444: 419A0010  beq cr6, 0x82389454
	if ctx.cr[6].eq {
	pc = 0x82389454; continue 'dispatch;
	}
	// 82389448: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 8238944C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82389450: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x82389454; continue 'dispatch;
            }
            0x82389454 => {
    //   block [0x82389454..0x8238945C)
	// 82389454: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82389458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389460 size=8
    let mut pc: u32 = 0x82389460;
    'dispatch: loop {
        match pc {
            0x82389460 => {
    //   block [0x82389460..0x82389468)
	// 82389460: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82389464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389468 size=28
    let mut pc: u32 = 0x82389468;
    'dispatch: loop {
        match pc {
            0x82389468 => {
    //   block [0x82389468..0x8238947C)
	// 82389468: 2F040004  cmpwi cr6, r4, 4
	ctx.cr[6].compare_i32(ctx.r[4].s32, 4, &mut ctx.xer);
	// 8238946C: 419A0010  beq cr6, 0x8238947c
	if ctx.cr[6].eq {
	pc = 0x8238947C; continue 'dispatch;
	}
	// 82389470: 2F040024  cmpwi cr6, r4, 0x24
	ctx.cr[6].compare_i32(ctx.r[4].s32, 36, &mut ctx.xer);
	// 82389474: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82389478: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x8238947C; continue 'dispatch;
            }
            0x8238947C => {
    //   block [0x8238947C..0x82389484)
	// 8238947C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82389480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389488 size=8
    let mut pc: u32 = 0x82389488;
    'dispatch: loop {
        match pc {
            0x82389488 => {
    //   block [0x82389488..0x82389490)
	// 82389488: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 8238948C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389490 size=16
    let mut pc: u32 = 0x82389490;
    'dispatch: loop {
        match pc {
            0x82389490 => {
    //   block [0x82389490..0x823894A0)
	// 82389490: 3964FFC0  addi r11, r4, -0x40
	ctx.r[11].s64 = ctx.r[4].s64 + -64;
	// 82389494: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82389498: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8238949C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823894A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823894A0 size=120
    let mut pc: u32 = 0x823894A0;
    'dispatch: loop {
        match pc {
            0x823894A0 => {
    //   block [0x823894A0..0x823894B8)
	// 823894A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823894A4: 481ABC19  bl 0x825350bc
	ctx.lr = 0x823894A8;
	sub_82535080(ctx, base);
	// 823894A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823894AC: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823894B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823894B4: 48000048  b 0x823894fc
	pc = 0x823894FC; continue 'dispatch;
            }
            0x823894B8 => {
    //   block [0x823894B8..0x823894F8)
	// 823894B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823894BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823894C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823894C4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 823894C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823894CC: 4E800421  bctrl
	ctx.lr = 0x823894D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823894D0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823894D4: 41820024  beq 0x823894f8
	if ctx.cr[0].eq {
	pc = 0x823894F8; continue 'dispatch;
	}
	// 823894D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823894DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823894E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823894E4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823894E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823894EC: 4E800421  bctrl
	ctx.lr = 0x823894F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823894F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823894F4: 4082001C  bne 0x82389510
	if !ctx.cr[0].eq {
	pc = 0x82389510; continue 'dispatch;
	}
            }
            0x823894F8 => {
    //   block [0x823894F8..0x823894FC)
	// 823894F8: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823894FC; continue 'dispatch;
            }
            0x823894FC => {
    //   block [0x823894FC..0x82389508)
	// 823894FC: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82389500: 4082FFB8  bne 0x823894b8
	if !ctx.cr[0].eq {
	pc = 0x823894B8; continue 'dispatch;
	}
	// 82389504: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82389508; continue 'dispatch;
            }
            0x82389508 => {
    //   block [0x82389508..0x82389510)
	// 82389508: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238950C: 481ABC00  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82389510 => {
    //   block [0x82389510..0x82389518)
	// 82389510: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82389514: 4BFFFFF4  b 0x82389508
	pc = 0x82389508; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389518 size=100
    let mut pc: u32 = 0x82389518;
    'dispatch: loop {
        match pc {
            0x82389518 => {
    //   block [0x82389518..0x8238957C)
	// 82389518: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 8238951C: 816A3C44  lwz r11, 0x3c44(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15428 as u32) ) } as u64;
	// 82389520: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82389524: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 82389528: 38693B70  addi r3, r9, 0x3b70
	ctx.r[3].s64 = ctx.r[9].s64 + 15216;
	// 8238952C: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	// 82389530: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82389534: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82389538: 916A3C44  stw r11, 0x3c44(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15428 as u32), ctx.r[11].u32 ) };
	// 8238953C: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82389580 size=120
    let mut pc: u32 = 0x82389580;
    'dispatch: loop {
        match pc {
            0x82389580 => {
    //   block [0x82389580..0x823895E0)
	// 82389580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82389584: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82389588: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238958C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82389590: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82389594: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82389598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238959C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 823895A0: 394AFD28  addi r10, r10, -0x2d8
	ctx.r[10].s64 = ctx.r[10].s64 + -728;
	// 823895A4: C0091FF8  lfs f0, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823895A8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 823895AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823895B0: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823895B4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823895B8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823895BC: C1A9BA38  lfs f13, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823895C0: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 823895C4: 4BFFFEDD  bl 0x823894a0
	ctx.lr = 0x823895C8;
	sub_823894A0(ctx, base);
	// 823895C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823895CC: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 823895D0: 40820010  bne 0x823895e0
	if !ctx.cr[0].eq {
	pc = 0x823895E0; continue 'dispatch;
	}
	// 823895D4: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 823895D8: 816BC8BC  lwz r11, -0x3744(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14148 as u32) ) } as u64;
	// 823895DC: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x823895E0; continue 'dispatch;
            }
            0x823895E0 => {
    //   block [0x823895E0..0x823895F8)
	// 823895E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823895E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823895E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823895EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823895F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823895F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823895F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823895F8 size=24
    let mut pc: u32 = 0x823895F8;
    'dispatch: loop {
        match pc {
            0x823895F8 => {
    //   block [0x823895F8..0x82389610)
	// 823895F8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823895FC: C003000C  lfs f0, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389600: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82389604: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82389608: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8238960C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82389610 size=100
    let mut pc: u32 = 0x82389610;
    'dispatch: loop {
        match pc {
            0x82389610 => {
    //   block [0x82389610..0x8238965C)
	// 82389610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82389614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82389618: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238961C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82389620: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82389624: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82389628: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8238962C: 394AFD54  addi r10, r10, -0x2ac
	ctx.r[10].s64 = ctx.r[10].s64 + -684;
	// 82389630: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82389634: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82389638: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8238963C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82389640: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82389644: 4BFFFE5D  bl 0x823894a0
	ctx.lr = 0x82389648;
	sub_823894A0(ctx, base);
	// 82389648: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238964C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82389650: 4082000C  bne 0x8238965c
	if !ctx.cr[0].eq {
	pc = 0x8238965C; continue 'dispatch;
	}
	// 82389654: 4BFFFEC5  bl 0x82389518
	ctx.lr = 0x82389658;
	sub_82389518(ctx, base);
	// 82389658: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x8238965C; continue 'dispatch;
            }
            0x8238965C => {
    //   block [0x8238965C..0x82389674)
	// 8238965C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82389660: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82389664: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82389668: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238966C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82389670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389678 size=16
    let mut pc: u32 = 0x82389678;
    'dispatch: loop {
        match pc {
            0x82389678 => {
    //   block [0x82389678..0x82389688)
	// 82389678: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238967C: 38A30050  addi r5, r3, 0x50
	ctx.r[5].s64 = ctx.r[3].s64 + 80;
	// 82389680: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82389684: 4BFDE6AC  b 0x82367d30
	sub_82367D30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389688 size=16
    let mut pc: u32 = 0x82389688;
    'dispatch: loop {
        match pc {
            0x82389688 => {
    //   block [0x82389688..0x82389698)
	// 82389688: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 8238968C: 38630050  addi r3, r3, 0x50
	ctx.r[3].s64 = ctx.r[3].s64 + 80;
	// 82389690: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 82389694: 481AB4BC  b 0x82534b50
	sub_82534B50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389698 size=44
    let mut pc: u32 = 0x82389698;
    'dispatch: loop {
        match pc {
            0x82389698 => {
    //   block [0x82389698..0x823896C4)
	// 82389698: A1430050  lhz r10, 0x50(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238969C: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823896A0: A1230052  lhz r9, 0x52(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(82 as u32) ) } as u64;
	// 823896A4: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 823896A8: 5548103E  rotlwi r8, r10, 2
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 823896AC: 396BB670  addi r11, r11, -0x4990
	ctx.r[11].s64 = ctx.r[11].s64 + -18832;
	// 823896B0: 552A303E  rotlwi r10, r9, 6
	ctx.r[10].u64 = ((ctx.r[9].u32).rotate_left(6)) as u64;
	// 823896B4: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 823896B8: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823896BC: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823896C0: 481AB490  b 0x82534b50
	sub_82534B50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823896C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823896C8 size=20
    let mut pc: u32 = 0x823896C8;
    'dispatch: loop {
        match pc {
            0x823896C8 => {
    //   block [0x823896C8..0x823896DC)
	// 823896C8: A1640012  lhz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 823896CC: B1630050  sth r11, 0x50(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u16 ) };
	// 823896D0: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 823896D4: B1630052  sth r11, 0x52(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 823896D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823896E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823896E0 size=60
    let mut pc: u32 = 0x823896E0;
    'dispatch: loop {
        match pc {
            0x823896E0 => {
    //   block [0x823896E0..0x8238971C)
	// 823896E0: A1430052  lhz r10, 0x52(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(82 as u32) ) } as u64;
	// 823896E4: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823896E8: A1230050  lhz r9, 0x50(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 823896EC: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 823896F0: 5548083E  rotlwi r8, r10, 1
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 823896F4: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 823896F8: 396BB670  addi r11, r11, -0x4990
	ctx.r[11].s64 = ctx.r[11].s64 + -18832;
	// 823896FC: 5529103E  rotlwi r9, r9, 2
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(2)) as u64;
	// 82389700: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82389704: 814AB60C  lwz r10, -0x49f4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18932 as u32) ) } as u64;
	// 82389708: 7D08522E  lhzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8238970C: 7D49582E  lwzx r10, r9, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82389710: 550B303E  rotlwi r11, r8, 6
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(6)) as u64;
	// 82389714: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82389718: 481AB438  b 0x82534b50
	sub_82534B50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82389720 size=316
    let mut pc: u32 = 0x82389720;
    'dispatch: loop {
        match pc {
            0x82389720 => {
    //   block [0x82389720..0x82389788)
	// 82389720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82389724: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82389728: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238972C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82389730: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82389734: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82389738: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238973C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389740: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82389744: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82389748: C1AB2150  lfs f13, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238974C: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82389750: 419800F0  blt cr6, 0x82389840
	if ctx.cr[6].lt {
	pc = 0x82389840; continue 'dispatch;
	}
	// 82389754: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82389758: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 8238975C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82389760: 419A00E0  beq cr6, 0x82389840
	if ctx.cr[6].eq {
	pc = 0x82389840; continue 'dispatch;
	}
	// 82389764: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82389768: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238976C: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82389770: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82389774: 816BB65C  lwz r11, -0x49a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18852 as u32) ) } as u64;
	// 82389778: 4099003C  ble cr6, 0x823897b4
	if !ctx.cr[6].gt {
	pc = 0x823897B4; continue 'dispatch;
	}
	// 8238977C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82389780: 419A0008  beq cr6, 0x82389788
	if ctx.cr[6].eq {
	pc = 0x82389788; continue 'dispatch;
	}
	// 82389784: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82389788; continue 'dispatch;
            }
            0x82389788 => {
    //   block [0x82389788..0x823897B4)
	// 82389788: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238978C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82389790: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82389794: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82389798: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	pc = 0x823897B4; continue 'dispatch;
            }
            0x823897B4 => {
    //   block [0x823897B4..0x82389840)
	// 823897B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823897B8: 419A000C  beq cr6, 0x823897c4
	if ctx.cr[6].eq {
	pc = 0x823897C4; continue 'dispatch;
	}
	// 823897BC: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 823897C0: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823897C4: 80C30010  lwz r6, 0x10(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823897C8: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 823897CC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823897D0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 823897D4: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 823897D8: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823897DC: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 823897E0: 3BEA9580  addi r31, r10, -0x6a80
	ctx.r[31].s64 = ctx.r[10].s64 + -27264;
	// 823897E4: C0060000  lfs f0, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823897E8: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	pc = 0x82389840; continue 'dispatch;
            }
            0x82389840 => {
    //   block [0x82389840..0x8238985C)
	// 82389840: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82389844: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82389848: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238984C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82389850: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82389854: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82389858: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389860 size=20
    let mut pc: u32 = 0x82389860;
    'dispatch: loop {
        match pc {
            0x82389860 => {
    //   block [0x82389860..0x82389874)
	// 82389860: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82389864: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82389868: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8238986C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82389870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389878 size=12
    let mut pc: u32 = 0x82389878;
    'dispatch: loop {
        match pc {
            0x82389878 => {
    //   block [0x82389878..0x82389884)
	// 82389878: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8238987C: B1630016  sth r11, 0x16(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(22 as u32), ctx.r[11].u16 ) };
	// 82389880: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82389888 size=456
    let mut pc: u32 = 0x82389888;
    'dispatch: loop {
        match pc {
            0x82389888 => {
    //   block [0x82389888..0x823898DC)
	// 82389888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238988C: 481AB82D  bl 0x825350b8
	ctx.lr = 0x82389890;
	sub_82535080(ctx, base);
	// 82389890: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82389894: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82389898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238989C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823898A0: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823898A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823898A8: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 823898AC: C1AB2150  lfs f13, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823898B0: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 823898B4: 41980190  blt cr6, 0x82389a44
	if ctx.cr[6].lt {
	pc = 0x82389A44; continue 'dispatch;
	}
	// 823898B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823898BC: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823898C0: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823898C4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823898C8: 816BB65C  lwz r11, -0x49a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18852 as u32) ) } as u64;
	// 823898CC: 40990074  ble cr6, 0x82389940
	if !ctx.cr[6].gt {
	pc = 0x82389940; continue 'dispatch;
	}
	// 823898D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823898D4: 419A0008  beq cr6, 0x823898dc
	if ctx.cr[6].eq {
	pc = 0x823898DC; continue 'dispatch;
	}
	// 823898D8: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823898DC; continue 'dispatch;
            }
            0x823898DC => {
    //   block [0x823898DC..0x82389940)
	// 823898DC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823898E0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 823898E4: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 823898E8: A11F0016  lhz r8, 0x16(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 823898EC: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 823898F0: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	pc = 0x82389940; continue 'dispatch;
            }
            0x82389940 => {
    //   block [0x82389940..0x82389A44)
	// 82389940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82389944: 419A000C  beq cr6, 0x82389950
	if ctx.cr[6].eq {
	pc = 0x82389950; continue 'dispatch;
	}
	// 82389948: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 8238994C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82389950: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82389954: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82389958: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8238995C: A11F0016  lhz r8, 0x16(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 82389960: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 82389964: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	pc = 0x82389A44; continue 'dispatch;
            }
            0x82389A44 => {
    //   block [0x82389A44..0x82389A50)
	// 82389A44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82389A48: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82389A4C: 481AB6BC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389A50 size=36
    let mut pc: u32 = 0x82389A50;
    'dispatch: loop {
        match pc {
            0x82389A50 => {
    //   block [0x82389A50..0x82389A74)
	// 82389A50: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82389A54: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82389A58: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82389A5C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82389A60: A1640016  lhz r11, 0x16(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(22 as u32) ) } as u64;
	// 82389A64: B1630014  sth r11, 0x14(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 82389A68: 89640014  lbz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82389A6C: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82389A70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82389A78 size=324
    let mut pc: u32 = 0x82389A78;
    'dispatch: loop {
        match pc {
            0x82389A78 => {
    //   block [0x82389A78..0x82389A90)
	// 82389A78: A163000A  lhz r11, 0xa(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(10 as u32) ) } as u64;
	// 82389A7C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82389A80: 39230020  addi r9, r3, 0x20
	ctx.r[9].s64 = ctx.r[3].s64 + 32;
	// 82389A84: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82389A88: 4C810020  blelr
	if !ctx.cr[0].gt { return; }
	// 82389A8C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82389A90; continue 'dispatch;
            }
            0x82389A90 => {
    //   block [0x82389A90..0x82389AA0)
	// 82389A90: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82389A94: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82389A98: 409A0008  bne cr6, 0x82389aa0
	if !ctx.cr[6].eq {
	pc = 0x82389AA0; continue 'dispatch;
	}
	// 82389A9C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	pc = 0x82389AA0; continue 'dispatch;
            }
            0x82389AA0 => {
    //   block [0x82389AA0..0x82389AC4)
	// 82389AA0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82389AA4: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 82389AA8: 4082FFE8  bne 0x82389a90
	if !ctx.cr[0].eq {
	pc = 0x82389A90; continue 'dispatch;
	}
	// 82389AAC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82389AB0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82389AB4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82389AB8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82389ABC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82389AC0: 38ABFD20  addi r5, r11, -0x2e0
	ctx.r[5].s64 = ctx.r[11].s64 + -736;
	pc = 0x82389AC4; continue 'dispatch;
            }
            0x82389AC4 => {
    //   block [0x82389AC4..0x82389AC8)
	// 82389AC4: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	pc = 0x82389AC8; continue 'dispatch;
            }
            0x82389AC8 => {
    //   block [0x82389AC8..0x82389AD0)
	// 82389AC8: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82389ACC: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82389AD0; continue 'dispatch;
            }
            0x82389AD0 => {
    //   block [0x82389AD0..0x82389AF4)
	// 82389AD0: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82389AD4: 88EA0000  lbz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82389AD8: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82389ADC: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82389AE0: 41820014  beq 0x82389af4
	if ctx.cr[0].eq {
	pc = 0x82389AF4; continue 'dispatch;
	}
	// 82389AE4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82389AE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82389AEC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82389AF0: 419AFFE0  beq cr6, 0x82389ad0
	if ctx.cr[6].eq {
	pc = 0x82389AD0; continue 'dispatch;
	}
	pc = 0x82389AF4; continue 'dispatch;
            }
            0x82389AF4 => {
    //   block [0x82389AF4..0x82389B34)
	// 82389AF4: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82389AF8: 4082009C  bne 0x82389b94
	if !ctx.cr[0].eq {
	pc = 0x82389B94; continue 'dispatch;
	}
	// 82389AFC: A1490008  lhz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82389B00: 554B0631  rlwinm. r11, r10, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82389B04: 41820030  beq 0x82389b34
	if ctx.cr[0].eq {
	pc = 0x82389B34; continue 'dispatch;
	}
	// 82389B08: A1640008  lhz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82389B0C: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 82389B10: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82389B14: 409A0080  bne cr6, 0x82389b94
	if !ctx.cr[6].eq {
	pc = 0x82389B94; continue 'dispatch;
	}
	// 82389B18: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82389B1C: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82389B20: A10B0012  lhz r8, 0x12(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82389B24: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82389B28: 4098006C  bge cr6, 0x82389b94
	if !ctx.cr[6].lt {
	pc = 0x82389B94; continue 'dispatch;
	}
	// 82389B2C: 39090018  addi r8, r9, 0x18
	ctx.r[8].s64 = ctx.r[9].s64 + 24;
	// 82389B30: 48000048  b 0x82389b78
	pc = 0x82389B78; continue 'dispatch;
            }
            0x82389B34 => {
    //   block [0x82389B34..0x82389B78)
	// 82389B34: C0090018  lfs f0, 0x18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389B38: A0E40008  lhz r7, 8(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82389B3C: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82389B40: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 82389B44: 39090018  addi r8, r9, 0x18
	ctx.r[8].s64 = ctx.r[9].s64 + 24;
	// 82389B48: A161FFF6  lhz r11, -0xa(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(-10 as u32) ) } as u64;
	// 82389B4C: 556B067E  clrlwi r11, r11, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 82389B50: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82389B54: 409A0040  bne cr6, 0x82389b94
	if !ctx.cr[6].eq {
	pc = 0x82389B94; continue 'dispatch;
	}
	// 82389B58: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82389B5C: 616B0080  ori r11, r11, 0x80
	ctx.r[11].u64 = ctx.r[11].u64 | 128;
	// 82389B60: B1690008  sth r11, 8(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u16 ) };
	// 82389B64: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82389B68: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82389B6C: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82389B70: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82389B74: 40980020  bge cr6, 0x82389b94
	if !ctx.cr[6].lt {
	pc = 0x82389B94; continue 'dispatch;
	}
	pc = 0x82389B78; continue 'dispatch;
            }
            0x82389B78 => {
    //   block [0x82389B78..0x82389B94)
	// 82389B78: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82389B7C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82389B80: 7D0A592E  stwx r8, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 82389B84: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82389B88: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82389B8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82389B90: B14B0010  sth r10, 0x10(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u16 ) };
	pc = 0x82389B94; continue 'dispatch;
            }
            0x82389B94 => {
    //   block [0x82389B94..0x82389BBC)
	// 82389B94: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82389B98: 39650008  addi r11, r5, 8
	ctx.r[11].s64 = ctx.r[5].s64 + 8;
	// 82389B9C: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82389BA0: 4198FF28  blt cr6, 0x82389ac8
	if ctx.cr[6].lt {
	pc = 0x82389AC8; continue 'dispatch;
	}
	// 82389BA4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82389BA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82389BAC: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82389BB0: 7D2B4A15  add. r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82389BB4: 4082FF10  bne 0x82389ac4
	if !ctx.cr[0].eq {
	pc = 0x82389AC4; continue 'dispatch;
	}
	// 82389BB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82389BC0 size=80
    let mut pc: u32 = 0x82389BC0;
    'dispatch: loop {
        match pc {
            0x82389BC0 => {
    //   block [0x82389BC0..0x82389BD0)
	// 82389BC0: A1630010  lhz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82389BC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82389BC8: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82389BCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82389BD0; continue 'dispatch;
            }
            0x82389BD0 => {
    //   block [0x82389BD0..0x82389C10)
	// 82389BD0: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82389BD4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82389BD8: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82389BDC: C0030008  lfs f0, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389BE0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82389BE4: 7D2A402E  lwzx r9, r10, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82389BE8: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82389BEC: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82389BF0: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82389BF4: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389BF8: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82389BFC: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82389C00: A1430010  lhz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82389C04: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82389C08: 4198FFC8  blt cr6, 0x82389bd0
	if ctx.cr[6].lt {
	pc = 0x82389BD0; continue 'dispatch;
	}
	// 82389C0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389C10 size=16
    let mut pc: u32 = 0x82389C10;
    'dispatch: loop {
        match pc {
            0x82389C10 => {
    //   block [0x82389C10..0x82389C20)
	// 82389C10: A1630012  lhz r11, 0x12(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(18 as u32) ) } as u64;
	// 82389C14: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82389C18: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82389C1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82389C20 size=148
    let mut pc: u32 = 0x82389C20;
    'dispatch: loop {
        match pc {
            0x82389C20 => {
    //   block [0x82389C20..0x82389C7C)
	// 82389C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82389C24: 481AB495  bl 0x825350b8
	ctx.lr = 0x82389C28;
	sub_82535080(ctx, base);
	// 82389C28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82389C2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82389C30: 83830014  lwz r28, 0x14(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82389C34: 39430020  addi r10, r3, 0x20
	ctx.r[10].s64 = ctx.r[3].s64 + 32;
	// 82389C38: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82389C3C: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 82389C40: A17F0016  lhz r11, 0x16(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 82389C44: B1630012  sth r11, 0x12(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82389C48: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389C4C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82389C50: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389C54: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82389C58: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82389C5C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82389C60: A17F0014  lhz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82389C64: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82389C68: B1610058  sth r11, 0x58(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u16 ) };
	// 82389C6C: A17F0010  lhz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82389C70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82389C74: 41820038  beq 0x82389cac
	if ctx.cr[0].eq {
	pc = 0x82389CAC; continue 'dispatch;
	}
	// 82389C78: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82389C7C; continue 'dispatch;
            }
            0x82389C7C => {
    //   block [0x82389C7C..0x82389CAC)
	// 82389C7C: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82389C80: 3D408239  lis r10, -0x7dc7
	ctx.r[10].s64 = -2110193664;
	// 82389C84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82389C88: 388A9A78  addi r4, r10, -0x6588
	ctx.r[4].s64 = ctx.r[10].s64 + -25992;
	// 82389C8C: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82389C90: 480126C1  bl 0x8239c350
	ctx.lr = 0x82389C94;
	sub_8239C350(ctx, base);
	// 82389C94: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 82389C98: A15F0010  lhz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82389C9C: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 82389CA0: 557D043E  clrlwi r29, r11, 0x10
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82389CA4: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82389CA8: 4198FFD4  blt cr6, 0x82389c7c
	if ctx.cr[6].lt {
	pc = 0x82389C7C; continue 'dispatch;
	}
	pc = 0x82389CAC; continue 'dispatch;
            }
            0x82389CAC => {
    //   block [0x82389CAC..0x82389CB4)
	// 82389CAC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82389CB0: 481AB458  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82389CB8 size=116
    let mut pc: u32 = 0x82389CB8;
    'dispatch: loop {
        match pc {
            0x82389CB8 => {
    //   block [0x82389CB8..0x82389D2C)
	// 82389CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82389CBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82389CC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82389CC4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82389CC8: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82389CCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82389CD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82389CD4: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82389CD8: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82389CDC: C17F000C  lfs f11, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82389CE0: C15F001C  lfs f10, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82389CE4: EC2C683A  fmadds f1, f12, f0, f13
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82389CE8: D03F0008  stfs f1, 8(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82389CEC: EC0A583A  fmadds f0, f10, f0, f11
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82389CF0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82389CF4: 481AA3DD  bl 0x825340d0
	ctx.lr = 0x82389CF8;
	sub_825340D0(ctx, base);
	// 82389CF8: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389CFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82389D00: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82389D04: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82389D08: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82389D0C: 481AA3C5  bl 0x825340d0
	ctx.lr = 0x82389D10;
	sub_825340D0(ctx, base);
	// 82389D10: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82389D14: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82389D18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82389D1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82389D20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82389D24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82389D28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389D30 size=16
    let mut pc: u32 = 0x82389D30;
    'dispatch: loop {
        match pc {
            0x82389D30 => {
    //   block [0x82389D30..0x82389D40)
	// 82389D30: A1630012  lhz r11, 0x12(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(18 as u32) ) } as u64;
	// 82389D34: 396B000D  addi r11, r11, 0xd
	ctx.r[11].s64 = ctx.r[11].s64 + 13;
	// 82389D38: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82389D3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82389D40 size=268
    let mut pc: u32 = 0x82389D40;
    'dispatch: loop {
        match pc {
            0x82389D40 => {
    //   block [0x82389D40..0x82389E14)
	// 82389D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82389D44: 481AB375  bl 0x825350b8
	ctx.lr = 0x82389D48;
	sub_82535080(ctx, base);
	// 82389D48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82389D4C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82389D50: 83830014  lwz r28, 0x14(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82389D54: 39430034  addi r10, r3, 0x34
	ctx.r[10].s64 = ctx.r[3].s64 + 52;
	// 82389D58: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82389D5C: 3BDF0024  addi r30, r31, 0x24
	ctx.r[30].s64 = ctx.r[31].s64 + 36;
	// 82389D60: A17F0016  lhz r11, 0x16(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 82389D64: B1630012  sth r11, 0x12(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82389D68: A17F0018  lhz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82389D6C: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82389D70: A17F001A  lhz r11, 0x1a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 82389D74: A13F0018  lhz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82389D78: 7D6B49D6  mullw r11, r11, r9
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82389D7C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82389D80: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82389D84: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82389D88: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82389D8C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82389D90: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82389D94: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389D98: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82389D9C: A17F0018  lhz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82389DA0: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82389DA4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82389DA8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82389DAC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82389DB0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82389DB4: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82389DB8: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389DBC: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82389DC0: D1A30020  stfs f13, 0x20(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82389DC4: A17F001A  lhz r11, 0x1a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 82389DC8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82389DCC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82389DD0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82389DD4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82389DD8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82389DDC: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82389DE0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82389DE4: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389DE8: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82389DEC: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82389DF0: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82389DF4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82389DF8: A17F0014  lhz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82389DFC: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82389E00: B1610060  sth r11, 0x60(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u16 ) };
	// 82389E04: A17F0010  lhz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82389E08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82389E0C: 41820038  beq 0x82389e44
	if ctx.cr[0].eq {
	pc = 0x82389E44; continue 'dispatch;
	}
	// 82389E10: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82389E14; continue 'dispatch;
            }
            0x82389E14 => {
    //   block [0x82389E14..0x82389E44)
	// 82389E14: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82389E18: 3D408239  lis r10, -0x7dc7
	ctx.r[10].s64 = -2110193664;
	// 82389E1C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82389E20: 388A9A78  addi r4, r10, -0x6588
	ctx.r[4].s64 = ctx.r[10].s64 + -25992;
	// 82389E24: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82389E28: 48012529  bl 0x8239c350
	ctx.lr = 0x82389E2C;
	sub_8239C350(ctx, base);
	// 82389E2C: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 82389E30: A15F0010  lhz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82389E34: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 82389E38: 557D043E  clrlwi r29, r11, 0x10
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82389E3C: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82389E40: 4198FFD4  blt cr6, 0x82389e14
	if ctx.cr[6].lt {
	pc = 0x82389E14; continue 'dispatch;
	}
	pc = 0x82389E44; continue 'dispatch;
            }
            0x82389E44 => {
    //   block [0x82389E44..0x82389E4C)
	// 82389E44: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82389E48: 481AB2C0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82389E50 size=152
    let mut pc: u32 = 0x82389E50;
    'dispatch: loop {
        match pc {
            0x82389E50 => {
    //   block [0x82389E50..0x82389EE8)
	// 82389E50: C003002C  lfs f0, 0x2c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389E54: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 82389E58: C1A30028  lfs f13, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82389E5C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82389E60: EC0D007A  fmadds f0, f13, f1, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 82389E64: C183001C  lfs f12, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82389E68: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82389E6C: C1430024  lfs f10, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82389E70: C1630020  lfs f11, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82389E74: EDA06028  fsubs f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82389E78: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82389E7C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82389E80: FD806028  fsub f12, f0, f12
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[12].f64;
	// 82389E84: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 82389E88: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82389E8C: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82389E90: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82389E94: 7DA057AE  stfiwx f13, 0, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82389E98: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82389E9C: 7D2A5B96  divwu r9, r10, r11
	ctx.r[9].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 82389EA0: 7D0A5B96  divwu r8, r10, r11
	ctx.r[8].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 82389EA4: 7D6959D6  mullw r11, r9, r11
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82389EA8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82389EAC: 790A0020  clrldi r10, r8, 0x20
	ctx.r[10].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 82389EB0: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82389EB4: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82389EB8: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82389EBC: F961FFF8  std r11, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u64 ) };
	// 82389EC0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82389EC4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82389EC8: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82389ECC: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82389ED0: C9A1FFF8  lfd f13, -8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82389ED4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82389ED8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82389EDC: EC0D02F2  fmuls f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82389EE0: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82389EE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82389EE8 size=16
    let mut pc: u32 = 0x82389EE8;
    'dispatch: loop {
        match pc {
            0x82389EE8 => {
    //   block [0x82389EE8..0x82389EF8)
	// 82389EE8: A1630012  lhz r11, 0x12(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(18 as u32) ) } as u64;
	// 82389EEC: 396B000A  addi r11, r11, 0xa
	ctx.r[11].s64 = ctx.r[11].s64 + 10;
	// 82389EF0: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82389EF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82389EF8 size=156
    let mut pc: u32 = 0x82389EF8;
    'dispatch: loop {
        match pc {
            0x82389EF8 => {
    //   block [0x82389EF8..0x82389F5C)
	// 82389EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82389EFC: 481AB1BD  bl 0x825350b8
	ctx.lr = 0x82389F00;
	sub_82535080(ctx, base);
	// 82389F00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82389F04: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82389F08: 83830014  lwz r28, 0x14(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82389F0C: 39430028  addi r10, r3, 0x28
	ctx.r[10].s64 = ctx.r[3].s64 + 40;
	// 82389F10: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82389F14: 3BDF0024  addi r30, r31, 0x24
	ctx.r[30].s64 = ctx.r[31].s64 + 36;
	// 82389F18: A17F0016  lhz r11, 0x16(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 82389F1C: B1630012  sth r11, 0x12(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82389F20: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389F24: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82389F28: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389F2C: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82389F30: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389F34: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82389F38: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82389F3C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82389F40: A17F0014  lhz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82389F44: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82389F48: B1610058  sth r11, 0x58(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u16 ) };
	// 82389F4C: A17F0010  lhz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82389F50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82389F54: 41820038  beq 0x82389f8c
	if ctx.cr[0].eq {
	pc = 0x82389F8C; continue 'dispatch;
	}
	// 82389F58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82389F5C; continue 'dispatch;
            }
            0x82389F5C => {
    //   block [0x82389F5C..0x82389F8C)
	// 82389F5C: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82389F60: 3D408239  lis r10, -0x7dc7
	ctx.r[10].s64 = -2110193664;
	// 82389F64: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82389F68: 388A9A78  addi r4, r10, -0x6588
	ctx.r[4].s64 = ctx.r[10].s64 + -25992;
	// 82389F6C: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82389F70: 480123E1  bl 0x8239c350
	ctx.lr = 0x82389F74;
	sub_8239C350(ctx, base);
	// 82389F74: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 82389F78: A15F0010  lhz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82389F7C: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 82389F80: 557D043E  clrlwi r29, r11, 0x10
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82389F84: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82389F88: 4198FFD4  blt cr6, 0x82389f5c
	if ctx.cr[6].lt {
	pc = 0x82389F5C; continue 'dispatch;
	}
	pc = 0x82389F8C; continue 'dispatch;
            }
            0x82389F8C => {
    //   block [0x82389F8C..0x82389F94)
	// 82389F8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82389F90: 481AB178  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82389F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82389F98 size=152
    let mut pc: u32 = 0x82389F98;
    'dispatch: loop {
        match pc {
            0x82389F98 => {
    //   block [0x82389F98..0x8238A030)
	// 82389F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82389F9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82389FA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82389FA4: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82389FA8: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82389FAC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82389FB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82389FB4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82389FB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82389FBC: C3DF001C  lfs f30, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82389FC0: C00B2490  lfs f0, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389FC4: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82389FC8: 4BD93501  bl 0x8211d4c8
	ctx.lr = 0x82389FCC;
	sub_8211D4C8(ctx, base);
	// 82389FCC: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82389FD0: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82389FD4: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82389FD8: EC0D07FA  fmadds f0, f13, f31, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82389FDC: EDACF7FA  fmadds f13, f12, f31, f30
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64);
	// 82389FE0: C17F0020  lfs f11, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82389FE4: ED8102F2  fmuls f12, f1, f11
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82389FE8: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82389FEC: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82389FF0: FD606E5E  fctidz f11, f13
	ctx.f[11].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 82389FF4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82389FF8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82389FFC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8238A000: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8238A004: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8238A008: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8238A00C: EC0D5828  fsubs f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 8238A010: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8238A014: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238A018: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238A01C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238A020: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8238A024: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238A028: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238A02C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238A030 size=16
    let mut pc: u32 = 0x8238A030;
    'dispatch: loop {
        match pc {
            0x8238A030 => {
    //   block [0x8238A030..0x8238A040)
	// 8238A030: A1630012  lhz r11, 0x12(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(18 as u32) ) } as u64;
	// 8238A034: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 8238A038: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8238A03C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238A040 size=220
    let mut pc: u32 = 0x8238A040;
    'dispatch: loop {
        match pc {
            0x8238A040 => {
    //   block [0x8238A040..0x8238A080)
	// 8238A040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238A044: 481AB075  bl 0x825350b8
	ctx.lr = 0x8238A048;
	sub_82535080(ctx, base);
	// 8238A048: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238A04C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8238A050: A17F0016  lhz r11, 0x16(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 8238A054: B1630012  sth r11, 0x12(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 8238A058: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238A05C: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A060: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8238A064: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A068: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8238A06C: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A070: C1AB2150  lfs f13, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A074: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8238A078: 41990008  bgt cr6, 0x8238a080
	if ctx.cr[6].gt {
	pc = 0x8238A080; continue 'dispatch;
	}
	// 8238A07C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x8238A080; continue 'dispatch;
            }
            0x8238A080 => {
    //   block [0x8238A080..0x8238A0E4)
	// 8238A080: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238A084: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8238A088: 83830014  lwz r28, 0x14(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8238A08C: 3BDF002C  addi r30, r31, 0x2c
	ctx.r[30].s64 = ctx.r[31].s64 + 44;
	// 8238A090: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8238A094: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A098: 39630038  addi r11, r3, 0x38
	ctx.r[11].s64 = ctx.r[3].s64 + 56;
	// 8238A09C: EDAD0024  fdivs f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 8238A0A0: D1A30020  stfs f13, 0x20(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8238A0A4: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A0A8: D1A30028  stfs f13, 0x28(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8238A0AC: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A0B0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238A0B4: D1A30034  stfs f13, 0x34(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8238A0B8: D1A3002C  stfs f13, 0x2c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8238A0BC: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8238A0C0: A15F0012  lhz r10, 0x12(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 8238A0C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8238A0C8: A15F0014  lhz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8238A0CC: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 8238A0D0: A17F0010  lhz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238A0D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238A0D8: B1410058  sth r10, 0x58(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u16 ) };
	// 8238A0DC: 41820038  beq 0x8238a114
	if ctx.cr[0].eq {
	pc = 0x8238A114; continue 'dispatch;
	}
	// 8238A0E0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8238A0E4; continue 'dispatch;
            }
            0x8238A0E4 => {
    //   block [0x8238A0E4..0x8238A114)
	// 8238A0E4: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238A0E8: 3D408239  lis r10, -0x7dc7
	ctx.r[10].s64 = -2110193664;
	// 8238A0EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8238A0F0: 388A9A78  addi r4, r10, -0x6588
	ctx.r[4].s64 = ctx.r[10].s64 + -25992;
	// 8238A0F4: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 8238A0F8: 48012259  bl 0x8239c350
	ctx.lr = 0x8238A0FC;
	sub_8239C350(ctx, base);
	// 8238A0FC: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 8238A100: A15F0010  lhz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238A104: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 8238A108: 557D043E  clrlwi r29, r11, 0x10
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 8238A10C: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8238A110: 4198FFD4  blt cr6, 0x8238a0e4
	if ctx.cr[6].lt {
	pc = 0x8238A0E4; continue 'dispatch;
	}
	pc = 0x8238A114; continue 'dispatch;
            }
            0x8238A114 => {
    //   block [0x8238A114..0x8238A11C)
	// 8238A114: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8238A118: 481AAFF0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238A120 size=24
    let mut pc: u32 = 0x8238A120;
    'dispatch: loop {
        match pc {
            0x8238A120 => {
    //   block [0x8238A120..0x8238A138)
	// 8238A120: C0030034  lfs f0, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A124: C1A30024  lfs f13, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A128: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8238A12C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238A130: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8238A134: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238A138 size=192
    let mut pc: u32 = 0x8238A138;
    'dispatch: loop {
        match pc {
            0x8238A138 => {
    //   block [0x8238A138..0x8238A164)
	// 8238A138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238A13C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238A140: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238A144: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238A148: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238A14C: C01F002C  lfs f0, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A150: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8238A154: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A158: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8238A15C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8238A160: 41990010  bgt cr6, 0x8238a170
	if ctx.cr[6].gt {
	pc = 0x8238A170; continue 'dispatch;
	}
	pc = 0x8238A164; continue 'dispatch;
            }
            0x8238A164 => {
    //   block [0x8238A164..0x8238A170)
	// 8238A164: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A168: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238A16C: 48000028  b 0x8238a194
	pc = 0x8238A194; continue 'dispatch;
            }
            0x8238A170 => {
    //   block [0x8238A170..0x8238A18C)
	// 8238A170: C19F0028  lfs f12, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238A174: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 8238A178: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8238A17C: 40990010  ble cr6, 0x8238a18c
	if !ctx.cr[6].gt {
	pc = 0x8238A18C; continue 'dispatch;
	}
	// 8238A180: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238A184: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8238A188: 4BFFFFDC  b 0x8238a164
	pc = 0x8238A164; continue 'dispatch;
            }
            0x8238A18C => {
    //   block [0x8238A18C..0x8238A194)
	// 8238A18C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238A190: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8238A194; continue 'dispatch;
            }
            0x8238A194 => {
    //   block [0x8238A194..0x8238A1F8)
	// 8238A194: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8238A198: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238A19C: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8238A1A0: C00B2490  lfs f0, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A1A4: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238A1A8: 4BD93321  bl 0x8211d4c8
	ctx.lr = 0x8238A1AC;
	sub_8211D4C8(ctx, base);
	// 8238A1AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238A1B0: C1BF0018  lfs f13, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A1B4: C19F001C  lfs f12, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238A1B8: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A1BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238A1C0: ED41002A  fadds f10, f1, f0
	ctx.f[10].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8238A1C4: C16BBFFC  lfs f11, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238A1C8: ED6A02F2  fmuls f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 8238A1CC: ED406828  fsubs f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238A1D0: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8238A1D4: EDAA6AFA  fmadds f13, f10, f11, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 8238A1D8: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8238A1DC: EC0062FA  fmadds f0, f0, f11, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 8238A1E0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8238A1E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8238A1E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238A1EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238A1F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238A1F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A1F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238A1F8 size=16
    let mut pc: u32 = 0x8238A1F8;
    'dispatch: loop {
        match pc {
            0x8238A1F8 => {
    //   block [0x8238A1F8..0x8238A208)
	// 8238A1F8: A1630012  lhz r11, 0x12(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(18 as u32) ) } as u64;
	// 8238A1FC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 8238A200: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8238A204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238A208 size=300
    let mut pc: u32 = 0x8238A208;
    'dispatch: loop {
        match pc {
            0x8238A208 => {
    //   block [0x8238A208..0x8238A2FC)
	// 8238A208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238A20C: 481AAEAD  bl 0x825350b8
	ctx.lr = 0x8238A210;
	sub_82535080(ctx, base);
	// 8238A210: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238A214: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8238A218: 83830014  lwz r28, 0x14(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8238A21C: 39430040  addi r10, r3, 0x40
	ctx.r[10].s64 = ctx.r[3].s64 + 64;
	// 8238A220: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 8238A224: 3BDF002C  addi r30, r31, 0x2c
	ctx.r[30].s64 = ctx.r[31].s64 + 44;
	// 8238A228: A17F0016  lhz r11, 0x16(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 8238A22C: B1630012  sth r11, 0x12(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 8238A230: A17F0018  lhz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8238A234: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8238A238: A17F001A  lhz r11, 0x1a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 8238A23C: A13F0018  lhz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8238A240: 7D6B49D6  mullw r11, r11, r9
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8238A244: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8238A248: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8238A24C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8238A250: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8238A254: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8238A258: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8238A25C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8238A260: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8238A264: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8238A268: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8238A26C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8238A270: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8238A274: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A278: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8238A27C: A17F0018  lhz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8238A280: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8238A284: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8238A288: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238A28C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8238A290: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8238A294: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8238A298: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A29C: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8238A2A0: D1A30024  stfs f13, 0x24(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8238A2A4: A17F001A  lhz r11, 0x1a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 8238A2A8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8238A2AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8238A2B0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8238A2B4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8238A2B8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8238A2BC: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8238A2C0: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8238A2C4: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A2C8: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8238A2CC: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8238A2D0: C01F0028  lfs f0, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A2D4: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8238A2D8: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 8238A2DC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8238A2E0: A17F0014  lhz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8238A2E4: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 8238A2E8: B1610060  sth r11, 0x60(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u16 ) };
	// 8238A2EC: A17F0010  lhz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238A2F0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238A2F4: 41820038  beq 0x8238a32c
	if ctx.cr[0].eq {
	pc = 0x8238A32C; continue 'dispatch;
	}
	// 8238A2F8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8238A2FC; continue 'dispatch;
            }
            0x8238A2FC => {
    //   block [0x8238A2FC..0x8238A32C)
	// 8238A2FC: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238A300: 3D408239  lis r10, -0x7dc7
	ctx.r[10].s64 = -2110193664;
	// 8238A304: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8238A308: 388A9A78  addi r4, r10, -0x6588
	ctx.r[4].s64 = ctx.r[10].s64 + -25992;
	// 8238A30C: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 8238A310: 48012041  bl 0x8239c350
	ctx.lr = 0x8238A314;
	sub_8239C350(ctx, base);
	// 8238A314: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 8238A318: A15F0010  lhz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238A31C: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 8238A320: 557D043E  clrlwi r29, r11, 0x10
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 8238A324: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8238A328: 4198FFD4  blt cr6, 0x8238a2fc
	if ctx.cr[6].lt {
	pc = 0x8238A2FC; continue 'dispatch;
	}
	pc = 0x8238A32C; continue 'dispatch;
            }
            0x8238A32C => {
    //   block [0x8238A32C..0x8238A334)
	// 8238A32C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8238A330: 481AADD8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238A338 size=260
    let mut pc: u32 = 0x8238A338;
    'dispatch: loop {
        match pc {
            0x8238A338 => {
    //   block [0x8238A338..0x8238A394)
	// 8238A338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238A33C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238A340: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238A344: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238A348: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238A34C: C01F0030  lfs f0, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A350: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 8238A354: C1BF002C  lfs f13, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A358: EC0D007A  fmadds f0, f13, f1, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 8238A35C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8238A360: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8238A364: 419A0030  beq cr6, 0x8238a394
	if ctx.cr[6].eq {
	pc = 0x8238A394; continue 'dispatch;
	}
	// 8238A368: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A36C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8238A370: 41980050  blt cr6, 0x8238a3c0
	if ctx.cr[6].lt {
	pc = 0x8238A3C0; continue 'dispatch;
	}
	// 8238A374: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238A378: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8238A37C: 4BFDD0CD  bl 0x82367448
	ctx.lr = 0x8238A380;
	sub_82367448(ctx, base);
	// 8238A380: C01F0038  lfs f0, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A384: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8238A388: 40980038  bge cr6, 0x8238a3c0
	if !ctx.cr[6].lt {
	pc = 0x8238A3C0; continue 'dispatch;
	}
	// 8238A38C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8238A390: 4800002C  b 0x8238a3bc
	pc = 0x8238A3BC; continue 'dispatch;
            }
            0x8238A394 => {
    //   block [0x8238A394..0x8238A3BC)
	// 8238A394: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A398: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8238A39C: 41980024  blt cr6, 0x8238a3c0
	if ctx.cr[6].lt {
	pc = 0x8238A3C0; continue 'dispatch;
	}
	// 8238A3A0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238A3A4: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8238A3A8: 4BFDD0A1  bl 0x82367448
	ctx.lr = 0x8238A3AC;
	sub_82367448(ctx, base);
	// 8238A3AC: C01F0038  lfs f0, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A3B0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8238A3B4: 4198000C  blt cr6, 0x8238a3c0
	if ctx.cr[6].lt {
	pc = 0x8238A3C0; continue 'dispatch;
	}
	// 8238A3B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x8238A3BC; continue 'dispatch;
            }
            0x8238A3BC => {
    //   block [0x8238A3BC..0x8238A3C0)
	// 8238A3BC: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	pc = 0x8238A3C0; continue 'dispatch;
            }
            0x8238A3C0 => {
    //   block [0x8238A3C0..0x8238A43C)
	// 8238A3C0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8238A3C4: C01F0030  lfs f0, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A3C8: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8238A3CC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8238A3D0: C19F0028  lfs f12, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238A3D4: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A3D8: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 8238A3DC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238A3E0: 7D2A5B96  divwu r9, r10, r11
	ctx.r[9].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 8238A3E4: 7D0A5B96  divwu r8, r10, r11
	ctx.r[8].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 8238A3E8: 7D6959D6  mullw r11, r9, r11
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8238A3EC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8238A3F0: 790A0020  clrldi r10, r8, 0x20
	ctx.r[10].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 8238A3F4: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 8238A3F8: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 8238A3FC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8238A400: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8238A404: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8238A408: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8238A40C: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 8238A410: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8238A414: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8238A418: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 8238A41C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8238A420: EC0B0372  fmuls f0, f11, f13
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 8238A424: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8238A428: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238A42C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238A430: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238A434: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238A438: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238A440 size=272
    let mut pc: u32 = 0x8238A440;
    'dispatch: loop {
        match pc {
            0x8238A440 => {
    //   block [0x8238A440..0x8238A47C)
	// 8238A440: 8963001D  lbz r11, 0x1d(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(29 as u32) ) } as u64;
	// 8238A444: 8943001C  lbz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 8238A448: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238A44C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238A450: 41820058  beq 0x8238a4a8
	if ctx.cr[0].eq {
	pc = 0x8238A4A8; continue 'dispatch;
	}
	// 8238A454: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A458: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238A45C: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8238A460: 418200D8  beq 0x8238a538
	if ctx.cr[0].eq {
	pc = 0x8238A538; continue 'dispatch;
	}
	// 8238A464: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8238A468: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8238A46C: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 8238A470: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8238A474: C0091FF8  lfs f0, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A478: 814ABA80  lwz r10, -0x4580(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17792 as u32) ) } as u64;
	pc = 0x8238A47C; continue 'dispatch;
            }
            0x8238A47C => {
    //   block [0x8238A47C..0x8238A4A8)
	// 8238A47C: 7D2858AE  lbzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8238A480: 5529103E  rotlwi r9, r9, 2
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(2)) as u64;
	// 8238A484: 7DA9542E  lfsx f13, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A488: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8238A48C: 409800A8  bge cr6, 0x8238a534
	if !ctx.cr[6].lt {
	pc = 0x8238A534; continue 'dispatch;
	}
	// 8238A490: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8238A494: 8923001C  lbz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 8238A498: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8238A49C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8238A4A0: 4198FFDC  blt cr6, 0x8238a47c
	if ctx.cr[6].lt {
	pc = 0x8238A47C; continue 'dispatch;
	}
	// 8238A4A4: 48000094  b 0x8238a538
	pc = 0x8238A538; continue 'dispatch;
            }
            0x8238A4A8 => {
    //   block [0x8238A4A8..0x8238A4D4)
	// 8238A4A8: C18BBA38  lfs f12, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238A4AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238A4B0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8238A4B4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238A4B8: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A4BC: 41820054  beq 0x8238a510
	if ctx.cr[0].eq {
	pc = 0x8238A510; continue 'dispatch;
	}
	// 8238A4C0: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 8238A4C4: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8238A4C8: 8903001C  lbz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 8238A4CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8238A4D0: 814ABA80  lwz r10, -0x4580(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17792 as u32) ) } as u64;
	pc = 0x8238A4D4; continue 'dispatch;
            }
            0x8238A4D4 => {
    //   block [0x8238A4D4..0x8238A4F8)
	// 8238A4D4: 7CCB48AE  lbzx r6, r11, r9
	ctx.r[6].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8238A4D8: 54C6103E  rotlwi r6, r6, 2
	ctx.r[6].u64 = ((ctx.r[6].u32).rotate_left(2)) as u64;
	// 8238A4DC: 7C06542E  lfsx f0, r6, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A4E0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8238A4E4: 41980014  blt cr6, 0x8238a4f8
	if ctx.cr[6].lt {
	pc = 0x8238A4F8; continue 'dispatch;
	}
	// 8238A4E8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8238A4EC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 8238A4F0: 40990008  ble cr6, 0x8238a4f8
	if !ctx.cr[6].gt {
	pc = 0x8238A4F8; continue 'dispatch;
	}
	// 8238A4F4: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	pc = 0x8238A4F8; continue 'dispatch;
            }
            0x8238A4F8 => {
    //   block [0x8238A4F8..0x8238A510)
	// 8238A4F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8238A4FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8238A500: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8238A504: 4198FFD0  blt cr6, 0x8238a4d4
	if ctx.cr[6].lt {
	pc = 0x8238A4D4; continue 'dispatch;
	}
	// 8238A508: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8238A50C: 409A0010  bne cr6, 0x8238a51c
	if !ctx.cr[6].eq {
	pc = 0x8238A51C; continue 'dispatch;
	}
	pc = 0x8238A510; continue 'dispatch;
            }
            0x8238A510 => {
    //   block [0x8238A510..0x8238A51C)
	// 8238A510: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8238A514: D1A30014  stfs f13, 0x14(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8238A518: 48000020  b 0x8238a538
	pc = 0x8238A538; continue 'dispatch;
            }
            0x8238A51C => {
    //   block [0x8238A51C..0x8238A534)
	// 8238A51C: C0030014  lfs f0, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A520: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8238A524: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 8238A528: C1ABD560  lfs f13, -0x2aa0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A52C: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 8238A530: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x8238A534; continue 'dispatch;
            }
            0x8238A534 => {
    //   block [0x8238A534..0x8238A538)
	// 8238A534: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x8238A538; continue 'dispatch;
            }
            0x8238A538 => {
    //   block [0x8238A538..0x8238A550)
	// 8238A538: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238A53C: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A540: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A544: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238A548: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8238A54C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238A550 size=36
    let mut pc: u32 = 0x8238A550;
    'dispatch: loop {
        match pc {
            0x8238A550 => {
    //   block [0x8238A550..0x8238A574)
	// 8238A550: 39640014  addi r11, r4, 0x14
	ctx.r[11].s64 = ctx.r[4].s64 + 20;
	// 8238A554: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8238A558: 89640013  lbz r11, 0x13(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(19 as u32) ) } as u64;
	// 8238A55C: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 8238A560: 89640011  lbz r11, 0x11(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(17 as u32) ) } as u64;
	// 8238A564: 9963001D  stb r11, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[11].u8 ) };
	// 8238A568: 89640012  lbz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 8238A56C: 9963001E  stb r11, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[11].u8 ) };
	// 8238A570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238A578 size=220
    let mut pc: u32 = 0x8238A578;
    'dispatch: loop {
        match pc {
            0x8238A578 => {
    //   block [0x8238A578..0x8238A654)
	// 8238A578: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8238A57C: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 8238A580: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8238A584: C1630014  lfs f11, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238A588: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238A658 size=52
    let mut pc: u32 = 0x8238A658;
    'dispatch: loop {
        match pc {
            0x8238A658 => {
    //   block [0x8238A658..0x8238A68C)
	// 8238A658: 89240011  lbz r9, 0x11(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(17 as u32) ) } as u64;
	// 8238A65C: 39640020  addi r11, r4, 0x20
	ctx.r[11].s64 = ctx.r[4].s64 + 32;
	// 8238A660: 39430020  addi r10, r3, 0x20
	ctx.r[10].s64 = ctx.r[3].s64 + 32;
	// 8238A664: 9123001C  stw r9, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 8238A668: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A66C: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8238A670: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A674: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8238A678: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8238A67C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8238A680: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8238A684: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8238A688: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238A690 size=252
    let mut pc: u32 = 0x8238A690;
    'dispatch: loop {
        match pc {
            0x8238A690 => {
    //   block [0x8238A690..0x8238A78C)
	// 8238A690: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8238A694: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 8238A698: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 8238A69C: A0E3001E  lhz r7, 0x1e(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(30 as u32) ) } as u64;
	// 8238A6A0: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 8238A6A4: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238A6A8: 394AB660  addi r10, r10, -0x49a0
	ctx.r[10].s64 = ctx.r[10].s64 + -18848;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238A790 size=60
    let mut pc: u32 = 0x8238A790;
    'dispatch: loop {
        match pc {
            0x8238A790 => {
    //   block [0x8238A790..0x8238A7CC)
	// 8238A790: 89240011  lbz r9, 0x11(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(17 as u32) ) } as u64;
	// 8238A794: 39640020  addi r11, r4, 0x20
	ctx.r[11].s64 = ctx.r[4].s64 + 32;
	// 8238A798: 39430020  addi r10, r3, 0x20
	ctx.r[10].s64 = ctx.r[3].s64 + 32;
	// 8238A79C: B123001C  sth r9, 0x1c(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u16 ) };
	// 8238A7A0: 89240012  lbz r9, 0x12(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 8238A7A4: B123001E  sth r9, 0x1e(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[9].u16 ) };
	// 8238A7A8: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A7AC: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8238A7B0: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A7B4: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8238A7B8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8238A7BC: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8238A7C0: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8238A7C4: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8238A7C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238A7D0 size=44
    let mut pc: u32 = 0x8238A7D0;
    'dispatch: loop {
        match pc {
            0x8238A7D0 => {
    //   block [0x8238A7D0..0x8238A7FC)
	// 8238A7D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8238A7D4: 386B0050  addi r3, r11, 0x50
	ctx.r[3].s64 = ctx.r[11].s64 + 80;
	// 8238A7D8: C00B0094  lfs f0, 0x94(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A7DC: C1AB0090  lfs f13, 0x90(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A7E0: EC0D007A  fmadds f0, f13, f1, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 8238A7E4: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8238A7E8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8238A7EC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8238A7F0: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238A7F4: D02B0094  stfs f1, 0x94(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8238A7F8: 4BFDD7C0  b 0x82367fb8
	sub_82367FB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238A800 size=68
    let mut pc: u32 = 0x8238A800;
    'dispatch: loop {
        match pc {
            0x8238A800 => {
    //   block [0x8238A800..0x8238A844)
	// 8238A800: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8238A804: 39630050  addi r11, r3, 0x50
	ctx.r[11].s64 = ctx.r[3].s64 + 80;
	// 8238A808: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8238A80C: C0040010  lfs f0, 0x10(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238A810: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8238A814: D0030090  stfs f0, 0x90(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8238A818: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8238A81C: 3D403F80  lis r10, 0x3f80
	ctx.r[10].s64 = 1065353216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238A848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238A848 size=528
    let mut pc: u32 = 0x8238A848;
    'dispatch: loop {
        match pc {
            0x8238A848 => {
    //   block [0x8238A848..0x8238AA58)
	// 8238A848: 3D2082B6  lis r9, -0x7d4a
	ctx.r[9].s64 = -2102001664;
	// 8238A84C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238A850: 8141FFDC  lwz r10, -0x24(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-36 as u32) ) } as u64;
	// 8238A854: 11A1038C  vspltisw v13, 1
	for i in 0..4 {
		ctx.v[13].u32[i] = 1;
	}
	// 8238A858: 3929BA70  addi r9, r9, -0x4590
	ctx.r[9].s64 = ctx.r[9].s64 + -17808;
	// 8238A85C: C1AB0030  lfs f13, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238A860: 10016B4A  vcfsx v0, v13, 1
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (1 as u32)) << 23));
	for i in 0..4 {
		ctx.v[0].f32[i] = (ctx.v[13].s32[i] as f32) * scale;
	}
	// 8238A864: C18B0034  lfs f12, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238A868: 11A06B4A  vcfsx v13, v13, 0
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (0 as u32)) << 23));
	for i in 0..4 {
		ctx.v[13].f32[i] = (ctx.v[13].s32[i] as f32) * scale;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238AA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238AA58 size=156
    let mut pc: u32 = 0x8238AA58;
    'dispatch: loop {
        match pc {
            0x8238AA58 => {
    //   block [0x8238AA58..0x8238AAF4)
	// 8238AA58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238AA5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238AA60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238AA64: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 8238AA68: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 8238AA6C: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8238AA70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238AA74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238AA78: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238AA7C: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238AA80: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8238AA84: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8238AA88: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8238AA8C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8238AA90: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238AA94: C00B2608  lfs f0, 0x2608(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9736 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238AA98: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8238AA9C: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238AAA0: 4BD92A29  bl 0x8211d4c8
	ctx.lr = 0x8238AAA4;
	sub_8211D4C8(ctx, base);
	// 8238AAA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238AAA8: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 8238AAAC: C3BF0018  lfs f29, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8238AAB0: C00B2490  lfs f0, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238AAB4: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238AAB8: 4BD92A11  bl 0x8211d4c8
	ctx.lr = 0x8238AABC;
	sub_8211D4C8(ctx, base);
	// 8238AABC: C01F001C  lfs f0, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238AAC0: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238AAC4: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238AAC8: EC1E077A  fmadds f0, f30, f29, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64);
	// 8238AACC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8238AAD0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8238AAD4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8238AAD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238AADC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238AAE0: CBA1FFD8  lfd f29, -0x28(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8238AAE4: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8238AAE8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238AAEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238AAF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238AAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238AAF8 size=12
    let mut pc: u32 = 0x8238AAF8;
    'dispatch: loop {
        match pc {
            0x8238AAF8 => {
    //   block [0x8238AAF8..0x8238AB04)
	// 8238AAF8: C0030020  lfs f0, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238AAFC: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8238AB00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238AB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238AB08 size=60
    let mut pc: u32 = 0x8238AB08;
    'dispatch: loop {
        match pc {
            0x8238AB08 => {
    //   block [0x8238AB08..0x8238AB44)
	// 8238AB08: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238AB0C: C0040014  lfs f0, 0x14(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238AB10: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8238AB14: C1830018  lfs f12, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238AB18: C0040018  lfs f0, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238AB1C: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8238AB20: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238AB24: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8238AB28: C183001C  lfs f12, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238AB2C: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238AB30: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8238AB34: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8238AB38: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8238AB3C: D1A30024  stfs f13, 0x24(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8238AB40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238AB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238AB48 size=180
    let mut pc: u32 = 0x8238AB48;
    'dispatch: loop {
        match pc {
            0x8238AB48 => {
    //   block [0x8238AB48..0x8238AB6C)
	// 8238AB48: C003008C  lfs f0, 0x8c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238AB4C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238AB50: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8238AB54: C1830090  lfs f12, 0x90(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238AB58: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8238AB5C: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238AB60: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8238AB64: 40990008  ble cr6, 0x8238ab6c
	if !ctx.cr[6].gt {
	pc = 0x8238AB6C; continue 'dispatch;
	}
	// 8238AB68: D1A3008C  stfs f13, 0x8c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	pc = 0x8238AB6C; continue 'dispatch;
            }
            0x8238AB6C => {
    //   block [0x8238AB6C..0x8238AB8C)
	// 8238AB6C: C003008C  lfs f0, 0x8c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238AB70: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8238AB74: 41980038  blt cr6, 0x8238abac
	if ctx.cr[6].lt {
	pc = 0x8238ABAC; continue 'dispatch;
	}
	// 8238AB78: C1A30094  lfs f13, 0x94(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238AB7C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8238AB80: 4098000C  bge cr6, 0x8238ab8c
	if !ctx.cr[6].lt {
	pc = 0x8238AB8C; continue 'dispatch;
	}
	// 8238AB84: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8238AB88: 48000024  b 0x8238abac
	pc = 0x8238ABAC; continue 'dispatch;
            }
            0x8238AB8C => {
    //   block [0x8238AB8C..0x8238ABA4)
	// 8238AB8C: ED6C6828  fsubs f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238AB90: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 8238AB94: 40990010  ble cr6, 0x8238aba4
	if !ctx.cr[6].gt {
	pc = 0x8238ABA4; continue 'dispatch;
	}
	// 8238AB98: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 8238AB9C: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 8238ABA0: 4800000C  b 0x8238abac
	pc = 0x8238ABAC; continue 'dispatch;
            }
            0x8238ABA4 => {
    //   block [0x8238ABA4..0x8238ABAC)
	// 8238ABA4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238ABA8: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x8238ABAC; continue 'dispatch;
            }
            0x8238ABAC => {
    //   block [0x8238ABAC..0x8238ABFC)
	// 8238ABAC: 39630050  addi r11, r3, 0x50
	ctx.r[11].s64 = ctx.r[3].s64 + 80;
	// 8238ABB0: D1A30088  stfs f13, 0x88(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8238ABB4: C1A30070  lfs f13, 0x70(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238ABB8: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 8238ABBC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238ABC0: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8238ABC4: C1A30074  lfs f13, 0x74(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238ABC8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238ABCC: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8238ABD0: C1A30078  lfs f13, 0x78(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238ABD4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238ABD8: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8238ABDC: C1A3007C  lfs f13, 0x7c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238ABE0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238ABE4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238AC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238AC00 size=156
    let mut pc: u32 = 0x8238AC00;
    'dispatch: loop {
        match pc {
            0x8238AC00 => {
    //   block [0x8238AC00..0x8238AC9C)
	// 8238AC00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238AC04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238AC08: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238AC0C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238AC10: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8238AC14: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8238AC18: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 8238AC1C: 38A80010  addi r5, r8, 0x10
	ctx.r[5].s64 = ctx.r[8].s64 + 16;
	// 8238AC20: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8238AC24: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238AC28: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8238AC2C: 3D603F80  lis r11, 0x3f80
	ctx.r[11].s64 = 1065353216;
	// 8238AC30: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238ACA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238ACA0 size=16
    let mut pc: u32 = 0x8238ACA0;
    'dispatch: loop {
        match pc {
            0x8238ACA0 => {
    //   block [0x8238ACA0..0x8238ACB0)
	// 8238ACA0: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 8238ACA4: 409A000C  bne cr6, 0x8238acb0
	if !ctx.cr[6].eq {
		sub_8238ACB0(ctx, base);
		return;
	}
	// 8238ACA8: 38630084  addi r3, r3, 0x84
	ctx.r[3].s64 = ctx.r[3].s64 + 132;
	// 8238ACAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238ACB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238ACB0 size=20
    let mut pc: u32 = 0x8238ACB0;
    'dispatch: loop {
        match pc {
            0x8238ACB0 => {
    //   block [0x8238ACB0..0x8238ACC4)
	// 8238ACB0: 2F040004  cmpwi cr6, r4, 4
	ctx.cr[6].compare_i32(ctx.r[4].s32, 4, &mut ctx.xer);
	// 8238ACB4: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 8238ACB8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8238ACBC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8238ACC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238ACC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238ACC8 size=32
    let mut pc: u32 = 0x8238ACC8;
    'dispatch: loop {
        match pc {
            0x8238ACC8 => {
    //   block [0x8238ACC8..0x8238ACE8)
	// 8238ACC8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238ACCC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238ACD0: C0030098  lfs f0, 0x98(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238ACD4: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8238ACD8: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8238ACDC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238ACE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238ACE4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238ACE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238ACE8 size=80
    let mut pc: u32 = 0x8238ACE8;
    'dispatch: loop {
        match pc {
            0x8238ACE8 => {
    //   block [0x8238ACE8..0x8238AD38)
	// 8238ACE8: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238ACEC: 39640020  addi r11, r4, 0x20
	ctx.r[11].s64 = ctx.r[4].s64 + 32;
	// 8238ACF0: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8238ACF4: 39430060  addi r10, r3, 0x60
	ctx.r[10].s64 = ctx.r[3].s64 + 96;
	// 8238ACF8: C0040014  lfs f0, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238ACFC: 39240030  addi r9, r4, 0x30
	ctx.r[9].s64 = ctx.r[4].s64 + 48;
	// 8238AD00: D0030090  stfs f0, 0x90(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8238AD04: 39030070  addi r8, r3, 0x70
	ctx.r[8].s64 = ctx.r[3].s64 + 112;
	// 8238AD08: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238AD0C: D0030098  stfs f0, 0x98(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8238AD10: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8238AD14: E8EB0000  ld r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8238AD18: F8EA0000  std r7, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 8238AD1C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8238AD20: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8238AD24: E9690000  ld r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 8238AD28: F9680000  std r11, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8238AD2C: E9690008  ld r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 8238AD30: F9680008  std r11, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8238AD34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238AD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238AD38 size=388
    let mut pc: u32 = 0x8238AD38;
    'dispatch: loop {
        match pc {
            0x8238AD38 => {
    //   block [0x8238AD38..0x8238AEBC)
	// 8238AD38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238AD3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238AD40: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238AD44: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8238AD48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8238AD4C: 80880020  lwz r4, 0x20(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 8238AD50: 4BFDCF39  bl 0x82367c88
	ctx.lr = 0x8238AD54;
	sub_82367C88(ctx, base);
	// 8238AD54: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 8238AD58: 81280014  lwz r9, 0x14(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 8238AD5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8238AD60: 396BBA70  addi r11, r11, -0x4590
	ctx.r[11].s64 = ctx.r[11].s64 + -17808;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238AEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238AEC0 size=40
    let mut pc: u32 = 0x8238AEC0;
    'dispatch: loop {
        match pc {
            0x8238AEC0 => {
    //   block [0x8238AEC0..0x8238AEE8)
	// 8238AEC0: 89640011  lbz r11, 0x11(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(17 as u32) ) } as u64;
	// 8238AEC4: 39440020  addi r10, r4, 0x20
	ctx.r[10].s64 = ctx.r[4].s64 + 32;
	// 8238AEC8: 89240012  lbz r9, 0x12(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 8238AECC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 8238AED0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 8238AED4: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 8238AED8: 89640013  lbz r11, 0x13(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(19 as u32) ) } as u64;
	// 8238AEDC: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 8238AEE0: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8238AEE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238AEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238AEE8 size=444
    let mut pc: u32 = 0x8238AEE8;
    'dispatch: loop {
        match pc {
            0x8238AEE8 => {
    //   block [0x8238AEE8..0x8238B06C)
	// 8238AEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238AEEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238AEF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238AEF4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 8238AEF8: 481AB0F1  bl 0x82535fe8
	ctx.lr = 0x8238AEFC;
	sub_82535FB0(ctx, base);
	// 8238AEFC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238AF00: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238AF04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238AF08: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238AF0C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8238AF10: 4099015C  ble cr6, 0x8238b06c
	if !ctx.cr[6].gt {
	pc = 0x8238B06C; continue 'dispatch;
	}
	// 8238AF14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238AF18: C15F00C0  lfs f10, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8238AF1C: C17F00D4  lfs f11, 0xd4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238AF20: C13F00C4  lfs f9, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8238AF24: ECEB0072  fmuls f7, f11, f1
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[1].f64) as f32) as f64);
	// 8238AF28: C11F00C8  lfs f8, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8238AF2C: C0DF00D8  lfs f6, 0xd8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 8238AF30: C00B2054  lfs f0, 0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238AF34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238AF38: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238AF3C: C0BF00CC  lfs f5, 0xcc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 8238AF40: C07F00D0  lfs f3, 0xd0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8238AF44: ECC60072  fmuls f6, f6, f1
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[1].f64) as f32) as f64);
	// 8238AF48: C09F00DC  lfs f4, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8238AF4C: C05F00E0  lfs f2, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8238AF50: EC840072  fmuls f4, f4, f1
	ctx.f[4].f64 = (((ctx.f[4].f64 * ctx.f[1].f64) as f32) as f64);
	// 8238AF54: C18B20B0  lfs f12, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238AF58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238AF5C: EC420072  fmuls f2, f2, f1
	ctx.f[2].f64 = (((ctx.f[2].f64 * ctx.f[1].f64) as f32) as f64);
	// 8238AF60: C3FF00B8  lfs f31, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8238AF64: C03F00B4  lfs f1, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8238AF68: C3DF00BC  lfs f30, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8238AF6C: C1AB2238  lfs f13, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238AF70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238AF74: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 8238AF78: C15F00B0  lfs f10, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8238AF7C: C16B21A4  lfs f11, 0x21a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8612 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238AF80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238AF84: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238AF88: ED080032  fmuls f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238AF8C: ECA50032  fmuls f5, f5, f0
	ctx.f[5].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238AF90: EC030032  fmuls f0, f3, f0
	ctx.f[0].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238AF94: ED893B3A  fmadds f12, f9, f12, f7
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[12].f64 + ctx.f[7].f64) as f32) as f64);
	// 8238AF98: ED28337A  fmadds f9, f8, f13, f6
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[6].f64) as f32) as f64);
	// 8238AF9C: ED05237A  fmadds f8, f5, f13, f4
	ctx.f[8].f64 = (((ctx.f[5].f64 * ctx.f[13].f64 + ctx.f[4].f64) as f32) as f64);
	// 8238AFA0: ED6012FA  fmadds f11, f0, f11, f2
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[2].f64) as f32) as f64);
	// 8238AFA4: EC0C502A  fadds f0, f12, f10
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64;
	// 8238AFA8: EDA9082A  fadds f13, f9, f1
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[1].f64) as f32) as f64;
	// 8238AFAC: ED88F82A  fadds f12, f8, f31
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[31].f64) as f32) as f64;
	// 8238AFB0: C3EB2490  lfs f31, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8238AFB4: ED6BF02A  fadds f11, f11, f30
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[30].f64) as f32) as f64;
	// 8238AFB8: FD40065E  fctidz f10, f0
	ctx.f[10].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8238AFBC: FD206E5E  fctidz f9, f13
	ctx.f[9].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 8238AFC0: FD00665E  fctidz f8, f12
	ctx.f[8].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 8238AFC4: FCE05E5E  fctidz f7, f11
	ctx.f[7].s64 = if ctx.f[11].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[11].f64.trunc() as i64 };
	// 8238AFC8: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 8238AFCC: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 8238AFD0: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 8238AFD4: FCE03E9C  fcfid f7, f7
	ctx.f[7].f64 = (ctx.f[7].s64 as f64);
	// 8238AFD8: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 8238AFDC: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 8238AFE0: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 8238AFE4: FCE03818  frsp f7, f7
	ctx.f[7].f64 = (ctx.f[7].f64 as f32) as f64;
	// 8238AFE8: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 8238AFEC: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8238AFF0: EFCD4828  fsubs f30, f13, f9
	ctx.f[30].f64 = (((ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 8238AFF4: D3DF00B4  stfs f30, 0xb4(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8238AFF8: EFAC4028  fsubs f29, f12, f8
	ctx.f[29].f64 = (((ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 8238AFFC: D3BF00B8  stfs f29, 0xb8(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8238B000: EF8B3828  fsubs f28, f11, f7
	ctx.f[28].f64 = (((ctx.f[11].f64 - ctx.f[7].f64) as f32) as f64);
	// 8238B004: D39F00BC  stfs f28, 0xbc(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 8238B008: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8238B00C: 4BD924BD  bl 0x8211d4c8
	ctx.lr = 0x8238B010;
	sub_8211D4C8(ctx, base);
	// 8238B010: FDA00890  fmr f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ctx.f[1].f64;
	// 8238B014: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8238B018: C19F0090  lfs f12, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238B01C: EC3E07F2  fmuls f1, f30, f31
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[31].f64) as f32) as f64);
	// 8238B020: C00BD5BC  lfs f0, -0x2a44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10820 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B024: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238B028: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 8238B02C: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8238B030: 4BD92499  bl 0x8211d4c8
	ctx.lr = 0x8238B034;
	sub_8211D4C8(ctx, base);
	// 8238B034: C01F0094  lfs f0, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B038: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238B03C: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8238B040: EC3D07F2  fmuls f1, f29, f31
	ctx.f[1].f64 = (((ctx.f[29].f64 * ctx.f[31].f64) as f32) as f64);
	// 8238B044: 4BD92485  bl 0x8211d4c8
	ctx.lr = 0x8238B048;
	sub_8211D4C8(ctx, base);
	// 8238B048: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8238B04C: C1BF0098  lfs f13, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B050: EC3C07F2  fmuls f1, f28, f31
	ctx.f[1].f64 = (((ctx.f[28].f64 * ctx.f[31].f64) as f32) as f64);
	// 8238B054: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8238B058: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8238B05C: 4BD9246D  bl 0x8211d4c8
	ctx.lr = 0x8238B060;
	sub_8211D4C8(ctx, base);
	// 8238B060: C01F009C  lfs f0, 0x9c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B064: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238B068: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	pc = 0x8238B06C; continue 'dispatch;
            }
            0x8238B06C => {
    //   block [0x8238B06C..0x8238B0A4)
	// 8238B06C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 8238B070: C07F00AC  lfs f3, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8238B074: C05F00A8  lfs f2, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8238B078: C03F00A4  lfs f1, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8238B07C: 4BFDD19D  bl 0x82368218
	ctx.lr = 0x8238B080;
	sub_82368218(ctx, base);
	// 8238B080: C01F00A0  lfs f0, 0xa0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B084: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8238B088: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8238B08C: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 8238B090: 481AAFA5  bl 0x82536034
	ctx.lr = 0x8238B094;
	sub_82535FFC(ctx, base);
	// 8238B094: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238B098: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238B09C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238B0A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238B0A8 size=100
    let mut pc: u32 = 0x8238B0A8;
    'dispatch: loop {
        match pc {
            0x8238B0A8 => {
    //   block [0x8238B0A8..0x8238B10C)
	// 8238B0A8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8238B0AC: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8238B0B0: 39630050  addi r11, r3, 0x50
	ctx.r[11].s64 = ctx.r[3].s64 + 80;
	// 8238B0B4: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8238B0B8: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8238B0BC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8238B0C0: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B0C4: 3D403F80  lis r10, 0x3f80
	ctx.r[10].s64 = 1065353216;
	// 8238B0C8: D00300AC  stfs f0, 0xac(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8238B0CC: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8238B0D0: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8238B0D4: D00300A0  stfs f0, 0xa0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8238B0D8: D00300BC  stfs f0, 0xbc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 8238B0DC: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8238B0E0: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8238B0E4: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238B110 size=248
    let mut pc: u32 = 0x8238B110;
    'dispatch: loop {
        match pc {
            0x8238B110 => {
    //   block [0x8238B110..0x8238B184)
	// 8238B110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238B114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238B118: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238B11C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238B120: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238B124: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8238B128: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238B12C: C01E0014  lfs f0, 0x14(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B130: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8238B134: C01E0018  lfs f0, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B138: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8238B13C: C01E001C  lfs f0, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B140: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8238B144: C01E0020  lfs f0, 0x20(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B148: D01F0098  stfs f0, 0x98(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8238B14C: C01E0024  lfs f0, 0x24(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B150: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8238B154: 897E0010  lbz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238B158: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238B15C: 40820028  bne 0x8238b184
	if !ctx.cr[0].eq {
	pc = 0x8238B184; continue 'dispatch;
	}
	// 8238B160: 4BFDC2E9  bl 0x82367448
	ctx.lr = 0x8238B164;
	sub_82367448(ctx, base);
	// 8238B164: D03F00C4  stfs f1, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8238B168: 4BFDC2E1  bl 0x82367448
	ctx.lr = 0x8238B16C;
	sub_82367448(ctx, base);
	// 8238B16C: D03F00C8  stfs f1, 0xc8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8238B170: 4BFDC2D9  bl 0x82367448
	ctx.lr = 0x8238B174;
	sub_82367448(ctx, base);
	// 8238B174: D03F00CC  stfs f1, 0xcc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 8238B178: 4BFDC2D1  bl 0x82367448
	ctx.lr = 0x8238B17C;
	sub_82367448(ctx, base);
	// 8238B17C: D03F00D0  stfs f1, 0xd0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 8238B180: 4800001C  b 0x8238b19c
	pc = 0x8238B19C; continue 'dispatch;
            }
            0x8238B184 => {
    //   block [0x8238B184..0x8238B19C)
	// 8238B184: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B188: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B18C: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8238B190: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8238B194: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 8238B198: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	pc = 0x8238B19C; continue 'dispatch;
            }
            0x8238B19C => {
    //   block [0x8238B19C..0x8238B1C8)
	// 8238B19C: 897E0010  lbz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238B1A0: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238B1A4: 41820024  beq 0x8238b1c8
	if ctx.cr[0].eq {
	pc = 0x8238B1C8; continue 'dispatch;
	}
	// 8238B1A8: C01E0028  lfs f0, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B1AC: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8238B1B0: C01E002C  lfs f0, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B1B4: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 8238B1B8: C01E0030  lfs f0, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B1BC: D01F00DC  stfs f0, 0xdc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 8238B1C0: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B1C4: 48000028  b 0x8238b1ec
	pc = 0x8238B1EC; continue 'dispatch;
            }
            0x8238B1C8 => {
    //   block [0x8238B1C8..0x8238B1EC)
	// 8238B1C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B1CC: C00B2230  lfs f0, 0x2230(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B1D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B1D4: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8238B1D8: C00B222C  lfs f0, 0x222c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8748 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B1DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B1E0: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 8238B1E4: C00B2228  lfs f0, 0x2228(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8744 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B1E8: D01F00DC  stfs f0, 0xdc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	pc = 0x8238B1EC; continue 'dispatch;
            }
            0x8238B1EC => {
    //   block [0x8238B1EC..0x8238B208)
	// 8238B1EC: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8238B1F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238B1F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238B1F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238B1FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238B200: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238B204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238B208 size=232
    let mut pc: u32 = 0x8238B208;
    'dispatch: loop {
        match pc {
            0x8238B208 => {
    //   block [0x8238B208..0x8238B278)
	// 8238B208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238B20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238B210: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238B214: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 8238B218: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8238B21C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238B220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238B224: C01F00A4  lfs f0, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B228: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8238B22C: C19F00A0  lfs f12, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238B230: D1BF00A4  stfs f13, 0xa4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8238B234: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 8238B238: 40990040  ble cr6, 0x8238b278
	if !ctx.cr[6].gt {
	pc = 0x8238B278; continue 'dispatch;
	}
	// 8238B23C: C01F009C  lfs f0, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B240: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B244: ED80602A  fadds f12, f0, f12
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 8238B248: C15F00A8  lfs f10, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8238B24C: EC010024  fdivs f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 8238B250: C16BBFFC  lfs f11, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238B254: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 8238B258: EC0052FA  fmadds f0, f0, f11, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64);
	// 8238B25C: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8238B260: 40990018  ble cr6, 0x8238b278
	if !ctx.cr[6].gt {
	pc = 0x8238B278; continue 'dispatch;
	}
	// 8238B264: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B268: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8238B26C: D1BF00A4  stfs f13, 0xa4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8238B270: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B274: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	pc = 0x8238B278; continue 'dispatch;
            }
            0x8238B278 => {
    //   block [0x8238B278..0x8238B2F0)
	// 8238B278: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B27C: C1BF00A8  lfs f13, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B280: C00B2490  lfs f0, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B284: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238B288: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8238B28C: 4BD9223D  bl 0x8211d4c8
	ctx.lr = 0x8238B290;
	sub_8211D4C8(ctx, base);
	// 8238B290: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8238B294: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238B298: C1BF0090  lfs f13, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B29C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8238B2A0: C3CBBA38  lfs f30, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8238B2A4: EC00F37A  fmadds f0, f0, f13, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64);
	// 8238B2A8: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238B2AC: 4BD9221D  bl 0x8211d4c8
	ctx.lr = 0x8238B2B0;
	sub_8211D4C8(ctx, base);
	// 8238B2B0: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8238B2B4: C1BF0094  lfs f13, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B2B8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8238B2BC: EC00F37A  fmadds f0, f0, f13, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64);
	// 8238B2C0: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8238B2C4: 4BD92205  bl 0x8211d4c8
	ctx.lr = 0x8238B2C8;
	sub_8211D4C8(ctx, base);
	// 8238B2C8: C01F0098  lfs f0, 0x98(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B2CC: EC01F03A  fmadds f0, f1, f0, f30
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64);
	// 8238B2D0: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8238B2D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238B2D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238B2DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238B2E0: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8238B2E4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238B2E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238B2EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238B2F0 size=80
    let mut pc: u32 = 0x8238B2F0;
    'dispatch: loop {
        match pc {
            0x8238B2F0 => {
    //   block [0x8238B2F0..0x8238B340)
	// 8238B2F0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8238B2F4: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8238B2F8: 39630050  addi r11, r3, 0x50
	ctx.r[11].s64 = ctx.r[3].s64 + 80;
	// 8238B2FC: C1A300AC  lfs f13, 0xac(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B300: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8238B304: D1A300A4  stfs f13, 0xa4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8238B308: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8238B30C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8238B310: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B314: 3D403F80  lis r10, 0x3f80
	ctx.r[10].s64 = 1065353216;
	// 8238B318: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238B340 size=56
    let mut pc: u32 = 0x8238B340;
    'dispatch: loop {
        match pc {
            0x8238B340 => {
    //   block [0x8238B340..0x8238B378)
	// 8238B340: C0040010  lfs f0, 0x10(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B344: D003009C  stfs f0, 0x9c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8238B348: C0040014  lfs f0, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B34C: D00300A0  stfs f0, 0xa0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8238B350: C0040018  lfs f0, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B354: D00300AC  stfs f0, 0xac(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8238B358: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8238B35C: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B360: D0030090  stfs f0, 0x90(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8238B364: C0040020  lfs f0, 0x20(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B368: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8238B36C: C0040024  lfs f0, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B370: D0030098  stfs f0, 0x98(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8238B374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238B378 size=152
    let mut pc: u32 = 0x8238B378;
    'dispatch: loop {
        match pc {
            0x8238B378 => {
    //   block [0x8238B378..0x8238B410)
	// 8238B378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238B37C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238B380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238B384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238B388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238B38C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238B390: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 8238B394: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8238B398: C01F0090  lfs f0, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B39C: C1BF009C  lfs f13, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B3A0: EC0D007A  fmadds f0, f13, f1, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 8238B3A4: C07F0098  lfs f3, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8238B3A8: C05F0094  lfs f2, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8238B3AC: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8238B3B0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8238B3B4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8238B3B8: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238B3BC: D03F0090  stfs f1, 0x90(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8238B3C0: 4BFDCE59  bl 0x82368218
	ctx.lr = 0x8238B3C4;
	sub_82368218(ctx, base);
	// 8238B3C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238B3C8: C1BF00A0  lfs f13, 0xa0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B3CC: 38BF00B0  addi r5, r31, 0xb0
	ctx.r[5].s64 = ctx.r[31].s64 + 176;
	// 8238B3D0: D1BE0030  stfs f13, 0x30(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8238B3D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8238B3D8: C1BF00A4  lfs f13, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B3DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8238B3E0: D1BE0034  stfs f13, 0x34(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8238B3E4: C1BF00A8  lfs f13, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B3E8: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B3EC: D1BE0038  stfs f13, 0x38(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8238B3F0: D01E003C  stfs f0, 0x3c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8238B3F4: 4BFDC93D  bl 0x82367d30
	ctx.lr = 0x8238B3F8;
	sub_82367D30(ctx, base);
	// 8238B3F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238B3FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238B400: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238B404: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238B408: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238B40C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238B410 size=12
    let mut pc: u32 = 0x8238B410;
    'dispatch: loop {
        match pc {
            0x8238B410 => {
    //   block [0x8238B410..0x8238B41C)
	// 8238B410: C00300F0  lfs f0, 0xf0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B414: D0030090  stfs f0, 0x90(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8238B418: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238B420 size=184
    let mut pc: u32 = 0x8238B420;
    'dispatch: loop {
        match pc {
            0x8238B420 => {
    //   block [0x8238B420..0x8238B4D8)
	// 8238B420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238B424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238B428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238B42C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238B430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238B434: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238B438: C0040014  lfs f0, 0x14(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B43C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B440: 39440020  addi r10, r4, 0x20
	ctx.r[10].s64 = ctx.r[4].s64 + 32;
	// 8238B444: 3BDF00B0  addi r30, r31, 0xb0
	ctx.r[30].s64 = ctx.r[31].s64 + 176;
	// 8238B448: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 8238B44C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8238B450: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8238B454: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8238B458: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8238B45C: C0040018  lfs f0, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B460: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8238B464: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B468: D01F0098  stfs f0, 0x98(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8238B46C: C0040010  lfs f0, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B470: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8238B474: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8238B478: C07F0098  lfs f3, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8238B47C: C05F0094  lfs f2, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8238B480: F95F00A0  std r10, 0xa0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[10].u64 ) };
	// 8238B484: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8238B488: F97F00A8  std r11, 0xa8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 8238B48C: 4BFDCD8D  bl 0x82368218
	ctx.lr = 0x8238B490;
	sub_82368218(ctx, base);
	// 8238B490: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238B494: C1BF00A0  lfs f13, 0xa0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B498: D1BE0030  stfs f13, 0x30(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8238B49C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8238B4A0: C1BF00A4  lfs f13, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B4A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8238B4A8: D1BE0034  stfs f13, 0x34(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8238B4AC: C1BF00A8  lfs f13, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B4B0: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B4B4: D1BE0038  stfs f13, 0x38(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8238B4B8: D01E003C  stfs f0, 0x3c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8238B4BC: 4BFDC7CD  bl 0x82367c88
	ctx.lr = 0x8238B4C0;
	sub_82367C88(ctx, base);
	// 8238B4C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238B4C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238B4C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238B4CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238B4D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238B4D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238B4D8 size=464
    let mut pc: u32 = 0x8238B4D8;
    'dispatch: loop {
        match pc {
            0x8238B4D8 => {
    //   block [0x8238B4D8..0x8238B54C)
	// 8238B4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238B4DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238B4E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238B4E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238B4E8: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 8238B4EC: 481AAAF5  bl 0x82535fe0
	ctx.lr = 0x8238B4F0;
	sub_82535FB0(ctx, base);
	// 8238B4F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238B4F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238B4F8: C01F0094  lfs f0, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B4FC: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8238B500: C15F009C  lfs f10, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8238B504: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8238B508: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 8238B50C: 41990040  bgt cr6, 0x8238b54c
	if ctx.cr[6].gt {
	pc = 0x8238B54C; continue 'dispatch;
	}
	// 8238B510: C1BF0090  lfs f13, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B514: C19F0098  lfs f12, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238B518: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 8238B51C: C19F00A0  lfs f12, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238B520: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238B524: FD80665E  fctidz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 8238B528: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8238B52C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8238B530: EC0C02BC  fnmsubs f0, f12, f10, f0
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 8238B534: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8238B538: FC006E5E  fctidz f0, f13
	ctx.f[0].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 8238B53C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8238B540: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8238B544: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8238B548: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	pc = 0x8238B54C; continue 'dispatch;
            }
            0x8238B54C => {
    //   block [0x8238B54C..0x8238B5A8)
	// 8238B54C: 83DF00B0  lwz r30, 0xb0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 8238B550: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B554: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238B558: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238B55C: C36BBA38  lfs f27, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 8238B560: 40820070  bne 0x8238b5d0
	if !ctx.cr[0].eq {
	pc = 0x8238B5D0; continue 'dispatch;
	}
	// 8238B564: C1BF00A4  lfs f13, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B568: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8238B56C: 41980070  blt cr6, 0x8238b5dc
	if ctx.cr[6].lt {
	pc = 0x8238B5DC; continue 'dispatch;
	}
	// 8238B570: C17F00A8  lfs f11, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238B574: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 8238B578: 419A00E8  beq cr6, 0x8238b660
	if ctx.cr[6].eq {
	pc = 0x8238B660; continue 'dispatch;
	}
	// 8238B57C: ED8B6828  fsubs f12, f11, f13
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238B580: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8238B584: ED9B6024  fdivs f12, f27, f12
	ctx.f[12].f64 = ((ctx.f[27].f64 / ctx.f[12].f64) as f32) as f64;
	// 8238B588: 41990020  bgt cr6, 0x8238b5a8
	if ctx.cr[6].gt {
	pc = 0x8238B5A8; continue 'dispatch;
	}
	// 8238B58C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 8238B590: 40980018  bge cr6, 0x8238b5a8
	if !ctx.cr[6].lt {
	pc = 0x8238B5A8; continue 'dispatch;
	}
	// 8238B594: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238B598: C1BF0098  lfs f13, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B59C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8238B5A0: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 8238B5A4: 480000C0  b 0x8238b664
	pc = 0x8238B664; continue 'dispatch;
            }
            0x8238B5A8 => {
    //   block [0x8238B5A8..0x8238B5BC)
	// 8238B5A8: C1BF00AC  lfs f13, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B5AC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8238B5B0: C1BF0098  lfs f13, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B5B4: 40980014  bge cr6, 0x8238b5c8
	if !ctx.cr[6].lt {
	pc = 0x8238B5C8; continue 'dispatch;
	}
	// 8238B5B8: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	pc = 0x8238B5BC; continue 'dispatch;
            }
            0x8238B5BC => {
    //   block [0x8238B5BC..0x8238B5C8)
	// 8238B5BC: EC00DB3A  fmadds f0, f0, f12, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[27].f64) as f32) as f64);
	// 8238B5C0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8238B5C4: 480000A0  b 0x8238b664
	pc = 0x8238B664; continue 'dispatch;
            }
            0x8238B5C8 => {
    //   block [0x8238B5C8..0x8238B5D0)
	// 8238B5C8: EC0A0028  fsubs f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 8238B5CC: 4BFFFFF0  b 0x8238b5bc
	pc = 0x8238B5BC; continue 'dispatch;
            }
            0x8238B5D0 => {
    //   block [0x8238B5D0..0x8238B5DC)
	// 8238B5D0: C3FF00A4  lfs f31, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8238B5D4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8238B5D8: 40980010  bge cr6, 0x8238b5e8
	if !ctx.cr[6].lt {
	pc = 0x8238B5E8; continue 'dispatch;
	}
	pc = 0x8238B5DC; continue 'dispatch;
            }
            0x8238B5DC => {
    //   block [0x8238B5DC..0x8238B5E8)
	// 8238B5DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B5E0: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B5E4: 48000080  b 0x8238b664
	pc = 0x8238B664; continue 'dispatch;
            }
            0x8238B5E8 => {
    //   block [0x8238B5E8..0x8238B660)
	// 8238B5E8: C35F00A8  lfs f26, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8238B5EC: FF1A5000  fcmpu cr6, f26, f10
	ctx.cr[6].compare_f64(ctx.f[26].f64, ctx.f[10].f64);
	// 8238B5F0: 419A0070  beq cr6, 0x8238b660
	if ctx.cr[6].eq {
	pc = 0x8238B660; continue 'dispatch;
	}
	// 8238B5F4: FF1AF800  fcmpu cr6, f26, f31
	ctx.cr[6].compare_f64(ctx.f[26].f64, ctx.f[31].f64);
	// 8238B5F8: 419A0068  beq cr6, 0x8238b660
	if ctx.cr[6].eq {
	pc = 0x8238B660; continue 'dispatch;
	}
	// 8238B5FC: C1BF00AC  lfs f13, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B600: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8238B604: EDADF828  fsubs f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 8238B608: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B60C: C3CB24B4  lfs f30, 0x24b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9396 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8238B610: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B614: EFBB6824  fdivs f29, f27, f13
	ctx.f[29].f64 = ((ctx.f[27].f64 / ctx.f[13].f64) as f32) as f64;
	// 8238B618: C38B2648  lfs f28, 0x2648(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9800 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8238B61C: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8238B620: EC20E7BA  fmadds f1, f0, f30, f28
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[28].f64) as f32) as f64);
	// 8238B624: 4BD91EA5  bl 0x8211d4c8
	ctx.lr = 0x8238B628;
	sub_8211D4C8(ctx, base);
	// 8238B628: EC1AF828  fsubs f0, f26, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[31].f64) as f32) as f64);
	// 8238B62C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B630: EDA1D82A  fadds f13, f1, f27
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[27].f64) as f32) as f64;
	// 8238B634: C3EBBFFC  lfs f31, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8238B638: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8238B63C: EFAD07F2  fmuls f29, f13, f31
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 8238B640: EC20E7BA  fmadds f1, f0, f30, f28
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[28].f64) as f32) as f64);
	// 8238B644: 4BD91E85  bl 0x8211d4c8
	ctx.lr = 0x8238B648;
	sub_8211D4C8(ctx, base);
	// 8238B648: EDA1D82A  fadds f13, f1, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[27].f64) as f32) as f64;
	// 8238B64C: C01F0098  lfs f0, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B650: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 8238B654: EDBD6824  fdivs f13, f29, f13
	ctx.f[13].f64 = ((ctx.f[29].f64 / ctx.f[13].f64) as f32) as f64;
	// 8238B658: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238B65C: 48000008  b 0x8238b664
	pc = 0x8238B664; continue 'dispatch;
            }
            0x8238B660 => {
    //   block [0x8238B660..0x8238B664)
	// 8238B660: C01F0098  lfs f0, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8238B664; continue 'dispatch;
            }
            0x8238B664 => {
    //   block [0x8238B664..0x8238B680)
	// 8238B664: C1BF0090  lfs f13, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B668: 57CB07BD  rlwinm. r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238B66C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 8238B670: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8238B674: 4182000C  beq 0x8238b680
	if ctx.cr[0].eq {
	pc = 0x8238B680; continue 'dispatch;
	}
	// 8238B678: EC20D82A  fadds f1, f0, f27
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	// 8238B67C: 48000008  b 0x8238b684
	pc = 0x8238B684; continue 'dispatch;
            }
            0x8238B680 => {
    //   block [0x8238B680..0x8238B684)
	// 8238B680: EC3B0028  fsubs f1, f27, f0
	ctx.f[1].f64 = (((ctx.f[27].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x8238B684; continue 'dispatch;
            }
            0x8238B684 => {
    //   block [0x8238B684..0x8238B6A8)
	// 8238B684: 4BFDC935  bl 0x82367fb8
	ctx.lr = 0x8238B688;
	sub_82367FB8(ctx, base);
	// 8238B688: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8238B68C: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 8238B690: 481AA99D  bl 0x8253602c
	ctx.lr = 0x8238B694;
	sub_82535FFC(ctx, base);
	// 8238B694: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238B698: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238B69C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238B6A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238B6A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238B6A8 size=76
    let mut pc: u32 = 0x8238B6A8;
    'dispatch: loop {
        match pc {
            0x8238B6A8 => {
    //   block [0x8238B6A8..0x8238B6F4)
	// 8238B6A8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8238B6AC: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8238B6B0: 39630050  addi r11, r3, 0x50
	ctx.r[11].s64 = ctx.r[3].s64 + 80;
	// 8238B6B4: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8238B6B8: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8238B6BC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8238B6C0: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B6C4: 3D403F80  lis r10, 0x3f80
	ctx.r[10].s64 = 1065353216;
	// 8238B6C8: D0030090  stfs f0, 0x90(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8238B6CC: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238B6F8 size=88
    let mut pc: u32 = 0x8238B6F8;
    'dispatch: loop {
        match pc {
            0x8238B6F8 => {
    //   block [0x8238B6F8..0x8238B750)
	// 8238B6F8: C0040014  lfs f0, 0x14(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B6FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B700: D0030098  stfs f0, 0x98(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8238B704: C0040018  lfs f0, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B708: D003009C  stfs f0, 0x9c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8238B70C: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B710: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8238B714: C0040020  lfs f0, 0x20(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B718: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238B71C: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8238B720: 89640010  lbz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238B724: C003009C  lfs f0, 0x9c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B728: C1A300A8  lfs f13, 0xa8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B72C: 916300B0  stw r11, 0xb0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 8238B730: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238B734: C16BBA38  lfs f11, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238B738: ED6B0024  fdivs f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 8238B73C: D16300A0  stfs f11, 0xa0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8238B740: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238B744: EC006B3A  fmadds f0, f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 8238B748: D00300AC  stfs f0, 0xac(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8238B74C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238B750 size=312
    let mut pc: u32 = 0x8238B750;
    'dispatch: loop {
        match pc {
            0x8238B750 => {
    //   block [0x8238B750..0x8238B79C)
	// 8238B750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238B754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238B758: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238B75C: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 8238B760: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8238B764: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238B768: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238B76C: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B770: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8238B774: C1BF0018  lfs f13, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B778: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8238B77C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8238B780: 41980024  blt cr6, 0x8238b7a4
	if ctx.cr[6].lt {
	pc = 0x8238B7A4; continue 'dispatch;
	}
	// 8238B784: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8238B788: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8238B78C: 419A0010  beq cr6, 0x8238b79c
	if ctx.cr[6].eq {
	pc = 0x8238B79C; continue 'dispatch;
	}
	// 8238B790: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B794: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B798: 48000008  b 0x8238b7a0
	pc = 0x8238B7A0; continue 'dispatch;
            }
            0x8238B79C => {
    //   block [0x8238B79C..0x8238B7A0)
	// 8238B79C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x8238B7A0; continue 'dispatch;
            }
            0x8238B7A0 => {
    //   block [0x8238B7A0..0x8238B7A4)
	// 8238B7A0: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x8238B7A4; continue 'dispatch;
            }
            0x8238B7A4 => {
    //   block [0x8238B7A4..0x8238B7EC)
	// 8238B7A4: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B7A8: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B7AC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8238B7B0: 419800B4  blt cr6, 0x8238b864
	if ctx.cr[6].lt {
	pc = 0x8238B864; continue 'dispatch;
	}
	// 8238B7B4: C19F0028  lfs f12, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238B7B8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8238B7BC: 40980058  bge cr6, 0x8238b814
	if !ctx.cr[6].lt {
	pc = 0x8238B814; continue 'dispatch;
	}
	// 8238B7C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B7C4: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238B7C8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238B7CC: C00B2490  lfs f0, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B7D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B7D4: C3CBBFFC  lfs f30, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8238B7D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B7DC: ED8B07B2  fmuls f12, f11, f30
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[30].f64) as f32) as f64);
	// 8238B7E0: ED8C6824  fdivs f12, f12, f13
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 8238B7E4: C1AB2604  lfs f13, 0x2604(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9732 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B7E8: EC2C6838  fmsubs f1, f12, f0, f13
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x8238B7EC; continue 'dispatch;
            }
            0x8238B7EC => {
    //   block [0x8238B7EC..0x8238B814)
	// 8238B7EC: C3FF001C  lfs f31, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8238B7F0: 4BD91CD9  bl 0x8211d4c8
	ctx.lr = 0x8238B7F4;
	sub_8211D4C8(ctx, base);
	// 8238B7F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238B7F8: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B7FC: EDA0F828  fsubs f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8238B800: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B804: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8238B808: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8238B80C: EC00FFBA  fmadds f0, f0, f30, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64);
	// 8238B810: 48000058  b 0x8238b868
	pc = 0x8238B868; continue 'dispatch;
            }
            0x8238B814 => {
    //   block [0x8238B814..0x8238B828)
	// 8238B814: C1BF002C  lfs f13, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B818: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8238B81C: 4098000C  bge cr6, 0x8238b828
	if !ctx.cr[6].lt {
	pc = 0x8238B828; continue 'dispatch;
	}
	// 8238B820: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B824: 48000044  b 0x8238b868
	pc = 0x8238B868; continue 'dispatch;
            }
            0x8238B828 => {
    //   block [0x8238B828..0x8238B864)
	// 8238B828: C19F0030  lfs f12, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238B82C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8238B830: 40980034  bge cr6, 0x8238b864
	if !ctx.cr[6].lt {
	pc = 0x8238B864; continue 'dispatch;
	}
	// 8238B834: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B838: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238B83C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238B840: C00B2490  lfs f0, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B844: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B848: C3CBBFFC  lfs f30, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8238B84C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238B850: ED8B07B2  fmuls f12, f11, f30
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[30].f64) as f32) as f64);
	// 8238B854: ED8C6824  fdivs f12, f12, f13
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 8238B858: C1AB2604  lfs f13, 0x2604(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9732 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238B85C: EC2C683A  fmadds f1, f12, f0, f13
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8238B860: 4BFFFF8C  b 0x8238b7ec
	pc = 0x8238B7EC; continue 'dispatch;
            }
            0x8238B864 => {
    //   block [0x8238B864..0x8238B868)
	// 8238B864: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8238B868; continue 'dispatch;
            }
            0x8238B868 => {
    //   block [0x8238B868..0x8238B888)
	// 8238B868: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8238B86C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238B870: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238B874: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238B878: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8238B87C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238B880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238B884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238B888 size=12
    let mut pc: u32 = 0x8238B888;
    'dispatch: loop {
        match pc {
            0x8238B888 => {
    //   block [0x8238B888..0x8238B894)
	// 8238B888: C0030034  lfs f0, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B88C: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8238B890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238B898 size=80
    let mut pc: u32 = 0x8238B898;
    'dispatch: loop {
        match pc {
            0x8238B898 => {
    //   block [0x8238B898..0x8238B8E8)
	// 8238B898: 89640011  lbz r11, 0x11(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(17 as u32) ) } as u64;
	// 8238B89C: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 8238B8A0: C0040014  lfs f0, 0x14(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B8A4: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8238B8A8: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8238B8AC: C0040018  lfs f0, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B8B0: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8238B8B4: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B8B8: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8238B8BC: C0040020  lfs f0, 0x20(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B8C0: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8238B8C4: C0040024  lfs f0, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B8C8: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8238B8CC: C0040028  lfs f0, 0x28(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B8D0: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8238B8D4: C004002C  lfs f0, 0x2c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B8D8: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8238B8DC: C0040030  lfs f0, 0x30(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B8E0: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8238B8E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238B8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238B8E8 size=640
    let mut pc: u32 = 0x8238B8E8;
    'dispatch: loop {
        match pc {
            0x8238B8E8 => {
    //   block [0x8238B8E8..0x8238BB68)
	// 8238B8E8: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 8238B8EC: 3D2082B6  lis r9, -0x7d4a
	ctx.r[9].s64 = -2102001664;
	// 8238B8F0: A1030026  lhz r8, 0x26(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(38 as u32) ) } as u64;
	// 8238B8F4: 3929BA70  addi r9, r9, -0x4590
	ctx.r[9].s64 = ctx.r[9].s64 + -17808;
	// 8238B8F8: 8141FFEC  lwz r10, -0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 8238B8FC: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B900: D001FFE0  stfs f0, -0x20(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 8238B904: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B908: D001FFE4  stfs f0, -0x1c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 8238B90C: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238B910: D001FFE8  stfs f0, -0x18(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), tmp.u32 ) };
	// 8238B914: 3961FFE0  addi r11, r1, -0x20
	ctx.r[11].s64 = ctx.r[1].s64 + -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238BB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238BB68 size=60
    let mut pc: u32 = 0x8238BB68;
    'dispatch: loop {
        match pc {
            0x8238BB68 => {
    //   block [0x8238BB68..0x8238BBA4)
	// 8238BB68: 89640012  lbz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 8238BB6C: B1630026  sth r11, 0x26(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(38 as u32), ctx.r[11].u16 ) };
	// 8238BB70: 89640011  lbz r11, 0x11(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(17 as u32) ) } as u64;
	// 8238BB74: B1630024  sth r11, 0x24(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u16 ) };
	// 8238BB78: C0040014  lfs f0, 0x14(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238BB7C: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8238BB80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238BB84: C0040018  lfs f0, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238BB88: C1A30014  lfs f13, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238BB8C: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8238BB90: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8238BB94: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238BB98: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8238BB9C: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8238BBA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238BBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238BBA8 size=200
    let mut pc: u32 = 0x8238BBA8;
    'dispatch: loop {
        match pc {
            0x8238BBA8 => {
    //   block [0x8238BBA8..0x8238BC08)
	// 8238BBA8: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 8238BBAC: C163001C  lfs f11, 0x1c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238BBB0: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238BBB4: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238BBB8: C18B0030  lfs f12, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238BBBC: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 8238BBC0: 396BBA70  addi r11, r11, -0x4590
	ctx.r[11].s64 = ctx.r[11].s64 + -17808;
	// 8238BBC4: C14B0004  lfs f10, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8238BBC8: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 8238BBCC: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8238BBD0: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 8238BBD4: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8238BBD8: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 8238BBDC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238BBE0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 8238BBE4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 8238BBE8: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 8238BBEC: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 8238BBF0: 41980060  blt cr6, 0x8238bc50
	if ctx.cr[6].lt {
	pc = 0x8238BC50; continue 'dispatch;
	}
	// 8238BBF4: C1830020  lfs f12, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238BBF8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8238BBFC: 40980028  bge cr6, 0x8238bc24
	if !ctx.cr[6].lt {
	pc = 0x8238BC24; continue 'dispatch;
	}
	// 8238BC00: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 8238BC04: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	pc = 0x8238BC08; continue 'dispatch;
            }
            0x8238BC08 => {
    //   block [0x8238BC08..0x8238BC24)
	// 8238BC08: C1A30014  lfs f13, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238BC0C: C1430018  lfs f10, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8238BC10: ED6A6828  fsubs f11, f10, f13
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 8238BC14: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238BC18: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 8238BC1C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8238BC20: 48000034  b 0x8238bc54
	pc = 0x8238BC54; continue 'dispatch;
            }
            0x8238BC24 => {
    //   block [0x8238BC24..0x8238BC38)
	// 8238BC24: C1630024  lfs f11, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238BC28: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 8238BC2C: 4098000C  bge cr6, 0x8238bc38
	if !ctx.cr[6].lt {
	pc = 0x8238BC38; continue 'dispatch;
	}
	// 8238BC30: C0030018  lfs f0, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238BC34: 48000020  b 0x8238bc54
	pc = 0x8238BC54; continue 'dispatch;
            }
            0x8238BC38 => {
    //   block [0x8238BC38..0x8238BC50)
	// 8238BC38: C1830028  lfs f12, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238BC3C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8238BC40: 40980010  bge cr6, 0x8238bc50
	if !ctx.cr[6].lt {
	pc = 0x8238BC50; continue 'dispatch;
	}
	// 8238BC44: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8238BC48: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 8238BC4C: 4BFFFFBC  b 0x8238bc08
	pc = 0x8238BC08; continue 'dispatch;
            }
            0x8238BC50 => {
    //   block [0x8238BC50..0x8238BC54)
	// 8238BC50: C0030014  lfs f0, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8238BC54; continue 'dispatch;
            }
            0x8238BC54 => {
    //   block [0x8238BC54..0x8238BC70)
	// 8238BC54: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238BC58: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8238BC5C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238BC60: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8238BC64: FC0C682E  fsel f0, f12, f0, f13
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8238BC68: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8238BC6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238BC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238BC70 size=80
    let mut pc: u32 = 0x8238BC70;
    'dispatch: loop {
        match pc {
            0x8238BC70 => {
    //   block [0x8238BC70..0x8238BC8C)
	// 8238BC70: 89640011  lbz r11, 0x11(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(17 as u32) ) } as u64;
	// 8238BC74: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238BC78: 40820014  bne 0x8238bc8c
	if !ctx.cr[0].eq {
	pc = 0x8238BC8C; continue 'dispatch;
	}
	// 8238BC7C: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238BC80: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8238BC84: C0040014  lfs f0, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238BC88: 48000010  b 0x8238bc98
	pc = 0x8238BC98; continue 'dispatch;
            }
            0x8238BC8C => {
    //   block [0x8238BC8C..0x8238BC98)
	// 8238BC8C: C0040014  lfs f0, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238BC90: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8238BC94: C0040018  lfs f0, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8238BC98; continue 'dispatch;
            }
            0x8238BC98 => {
    //   block [0x8238BC98..0x8238BCC0)
	// 8238BC98: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8238BC9C: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238BCA0: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8238BCA4: C0040020  lfs f0, 0x20(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238BCA8: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8238BCAC: C0040024  lfs f0, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238BCB0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8238BCB4: C0040028  lfs f0, 0x28(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238BCB8: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8238BCBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238BCC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238BCC0 size=16
    let mut pc: u32 = 0x8238BCC0;
    'dispatch: loop {
        match pc {
            0x8238BCC0 => {
    //   block [0x8238BCC0..0x8238BCD0)
	// 8238BCC0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238BCC4: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 8238BCC8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8238BCCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238BCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238BCD0 size=16
    let mut pc: u32 = 0x8238BCD0;
    'dispatch: loop {
        match pc {
            0x8238BCD0 => {
    //   block [0x8238BCD0..0x8238BCE0)
	// 8238BCD0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238BCD4: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 8238BCD8: 916ABA80  stw r11, -0x4580(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17792 as u32), ctx.r[11].u32 ) };
	// 8238BCDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238BCE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238BCE0 size=84
    let mut pc: u32 = 0x8238BCE0;
    'dispatch: loop {
        match pc {
            0x8238BCE0 => {
    //   block [0x8238BCE0..0x8238BD0C)
	// 8238BCE0: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238BCE4: 39230014  addi r9, r3, 0x14
	ctx.r[9].s64 = ctx.r[3].s64 + 20;
	// 8238BCE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8238BCEC: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8238BCF0: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8238BCF4: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8238BCF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8238BCFC: 4099002C  ble cr6, 0x8238bd28
	if !ctx.cr[6].gt {
	pc = 0x8238BD28; continue 'dispatch;
	}
	// 8238BD00: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8238BD04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8238BD08: C0091FF8  lfs f0, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8238BD0C; continue 'dispatch;
            }
            0x8238BD0C => {
    //   block [0x8238BD0C..0x8238BD28)
	// 8238BD0C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238BD10: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8238BD14: 7C09552E  stfsx f0, r9, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 8238BD18: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238BD1C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8238BD20: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8238BD24: 4198FFE8  blt cr6, 0x8238bd0c
	if ctx.cr[6].lt {
	pc = 0x8238BD0C; continue 'dispatch;
	}
	pc = 0x8238BD28; continue 'dispatch;
            }
            0x8238BD28 => {
    //   block [0x8238BD28..0x8238BD34)
	// 8238BD28: 39640014  addi r11, r4, 0x14
	ctx.r[11].s64 = ctx.r[4].s64 + 20;
	// 8238BD2C: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8238BD30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238BD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238BD38 size=68
    let mut pc: u32 = 0x8238BD38;
    'dispatch: loop {
        match pc {
            0x8238BD38 => {
    //   block [0x8238BD38..0x8238BD64)
	// 8238BD38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238BD3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238BD40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238BD44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238BD48: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8238BD4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238BD50: 396B3BF8  addi r11, r11, 0x3bf8
	ctx.r[11].s64 = ctx.r[11].s64 + 15352;
	// 8238BD54: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8238BD58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238BD5C: 41820008  beq 0x8238bd64
	if ctx.cr[0].eq {
	pc = 0x8238BD64; continue 'dispatch;
	}
	// 8238BD60: 481A6E59  bl 0x82532bb8
	ctx.lr = 0x8238BD64;
	sub_82532BB8(ctx, base);
	pc = 0x8238BD64; continue 'dispatch;
            }
            0x8238BD64 => {
    //   block [0x8238BD64..0x8238BD7C)
	// 8238BD64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238BD68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8238BD6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238BD70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238BD74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238BD78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238BD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238BD80 size=1008
    let mut pc: u32 = 0x8238BD80;
    'dispatch: loop {
        match pc {
            0x8238BD80 => {
    //   block [0x8238BD80..0x8238C170)
	// 8238BD80: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8238BD84: 11A1038C  vspltisw v13, 1
	for i in 0..4 {
		ctx.v[13].u32[i] = 1;
	}
	// 8238BD88: 10016B4A  vcfsx v0, v13, 1
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (1 as u32)) << 23));
	for i in 0..4 {
		ctx.v[0].f32[i] = (ctx.v[13].s32[i] as f32) * scale;
	}
	// 8238BD8C: 814BBF90  lwz r10, -0x4070(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16496 as u32) ) } as u64;
	// 8238BD90: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238BD94: 11A06B4A  vcfsx v13, v13, 0
	let scale = f32::from_bits(((127u32 - (0 as u32)) << 23));
	for i in 0..4 {
		ctx.v[13].f32[i] = (ctx.v[13].s32[i] as f32) * scale;
	}
	// 8238BD98: C1AA00C0  lfs f13, 0xc0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238BD9C: C18BBA38  lfs f12, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238BDA0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238BDA4: ED2C6824  fdivs f9, f12, f13
	ctx.f[9].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 8238BDA8: C16A00EC  lfs f11, 0xec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(236 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238BDAC: C14A00E0  lfs f10, 0xe0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8238BDB0: C10A00E4  lfs f8, 0xe4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(228 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8238BDB4: ECAA5828  fsubs f5, f10, f11
	ctx.f[5].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 8238BDB8: C1AA00D4  lfs f13, 0xd4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238BDBC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8238BDC0: ECEC6824  fdivs f7, f12, f13
	ctx.f[7].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 8238BDC4: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238BDC8: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8238BDCC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8238BDD0: D181FFF0  stfs f12, -0x10(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8238BDD4: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 8238BDD8: C1AA2074  lfs f13, 0x2074(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238BDDC: ECCB0372  fmuls f6, f11, f13
	ctx.f[6].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 8238BDE0: ED685828  fsubs f11, f8, f11
	ctx.f[11].f64 = (((ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 8238BDE4: 816BBFB0  lwz r11, -0x4050(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16464 as u32) ) } as u64;
	// 8238BDE8: ECA50272  fmuls f5, f5, f9
	ctx.f[5].f64 = (((ctx.f[5].f64 * ctx.f[9].f64) as f32) as f64);
	// 8238BDEC: C06B0008  lfs f3, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8238BDF0: C04B0000  lfs f2, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8238BDF4: C02B0004  lfs f1, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8238BDF8: EC8B01F2  fmuls f4, f11, f7
	ctx.f[4].f64 = (((ctx.f[11].f64 * ctx.f[7].f64) as f32) as f64);
	// 8238BDFC: ED6A3028  fsubs f11, f10, f6
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[6].f64) as f32) as f64);
	// 8238BE00: ED483028  fsubs f10, f8, f6
	ctx.f[10].f64 = (((ctx.f[8].f64 - ctx.f[6].f64) as f32) as f64);
	// 8238BE04: ED6B0272  fmuls f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[9].f64) as f32) as f64);
	// 8238BE08: D161FFF8  stfs f11, -8(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 8238BE0C: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8238BE10: ED0A01F2  fmuls f8, f10, f7
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[7].f64) as f32) as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238C170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238C170 size=108
    let mut pc: u32 = 0x8238C170;
    'dispatch: loop {
        match pc {
            0x8238C170 => {
    //   block [0x8238C170..0x8238C194)
	// 8238C170: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8238C174: C0040008  lfs f0, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238C178: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8238C17C: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238C180: C1840000  lfs f12, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238C184: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8238C188: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8238C18C: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 8238C190: C1691FF8  lfs f11, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x8238C194; continue 'dispatch;
            }
            0x8238C194 => {
    //   block [0x8238C194..0x8238C1C8)
	// 8238C194: C14A0004  lfs f10, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8238C198: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238C19C: C12AFFFC  lfs f9, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8238C1A0: C10A0000  lfs f8, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8238C1A4: C0EA0008  lfs f7, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8238C1A8: ED49533A  fmadds f10, f9, f12, f10
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64);
	// 8238C1AC: ED48537A  fmadds f10, f8, f13, f10
	ctx.f[10].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64);
	// 8238C1B0: ED4A382A  fadds f10, f10, f7
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[7].f64) as f32) as f64;
	// 8238C1B4: FF0A5800  fcmpu cr6, f10, f11
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[11].f64);
	// 8238C1B8: 40980010  bge cr6, 0x8238c1c8
	if !ctx.cr[6].lt {
	pc = 0x8238C1C8; continue 'dispatch;
	}
	// 8238C1BC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8238C1C0: 7D295830  slw r9, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 8238C1C4: 7D231B78  or r3, r9, r3
	ctx.r[3].u64 = ctx.r[9].u64 | ctx.r[3].u64;
	pc = 0x8238C1C8; continue 'dispatch;
            }
            0x8238C1C8 => {
    //   block [0x8238C1C8..0x8238C1DC)
	// 8238C1C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8238C1CC: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 8238C1D0: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 8238C1D4: 4198FFC0  blt cr6, 0x8238c194
	if ctx.cr[6].lt {
	pc = 0x8238C194; continue 'dispatch;
	}
	// 8238C1D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238C1E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238C1E0 size=1364
    let mut pc: u32 = 0x8238C1E0;
    'dispatch: loop {
        match pc {
            0x8238C1E0 => {
    //   block [0x8238C1E0..0x8238C2A0)
	// 8238C1E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238C1E4: 481A8EB5  bl 0x82535098
	ctx.lr = 0x8238C1E8;
	sub_82535080(ctx, base);
	// 8238C1E8: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238C1EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8238C1F0: 4BFFFB91  bl 0x8238bd80
	ctx.lr = 0x8238C1F4;
	sub_8238BD80(ctx, base);
	// 8238C1F4: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238C1F8: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 8238C1FC: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 8238C200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8238C204: 40990528  ble cr6, 0x8238c72c
	if !ctx.cr[6].gt {
	pc = 0x8238C72C; continue 'dispatch;
	}
	// 8238C208: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 8238C20C: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 8238C210: 3B6BBA70  addi r27, r11, -0x4590
	ctx.r[27].s64 = ctx.r[11].s64 + -17808;
	// 8238C214: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 8238C218: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 8238C21C: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 8238C220: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8238C224: C085BA38  lfs f4, -0x45c8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8238C228: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8238C22C: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 8238C230: 3B4B5C40  addi r26, r11, 0x5c40
	ctx.r[26].s64 = ctx.r[11].s64 + 23616;
	// 8238C234: C0462048  lfs f2, 0x2048(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8264 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8238C238: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 8238C23C: C0A7BFFC  lfs f5, -0x4004(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 8238C240: C0C81FF8  lfs f6, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 8238C244: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 8238C248: C0292074  lfs f1, 0x2074(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8308 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8238C24C: 3BEBB620  addi r31, r11, -0x49e0
	ctx.r[31].s64 = ctx.r[11].s64 + -18912;
	// 8238C250: 832ABA80  lwz r25, -0x4580(r10)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17792 as u32) ) } as u64;
	// 8238C254: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 8238C258: 3AE00030  li r23, 0x30
	ctx.r[23].s64 = 48;
	// 8238C25C: 3B000020  li r24, 0x20
	ctx.r[24].s64 = 32;
	// 8238C260: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238C264: FC600890  fmr f3, f1
	ctx.f[3].f64 = ctx.f[1].f64;
	// 8238C268: 7FD65A14  add r30, r22, r11
	ctx.r[30].u64 = ctx.r[22].u64 + ctx.r[11].u64;
	// 8238C26C: 897E0040  lbz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 8238C270: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238C274: 40820334  bne 0x8238c5a8
	if !ctx.cr[0].eq {
	pc = 0x8238C5A8; continue 'dispatch;
	}
	// 8238C278: 897E0041  lbz r11, 0x41(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(65 as u32) ) } as u64;
	// 8238C27C: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 8238C280: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238C284: 41820030  beq 0x8238c2b4
	if ctx.cr[0].eq {
	pc = 0x8238C2B4; continue 'dispatch;
	}
	// 8238C288: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 8238C28C: 409A0014  bne cr6, 0x8238c2a0
	if !ctx.cr[6].eq {
	pc = 0x8238C2A0; continue 'dispatch;
	}
	// 8238C290: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 8238C294: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8238C298: 4BFDB9F1  bl 0x82367c88
	ctx.lr = 0x8238C29C;
	sub_82367C88(ctx, base);
	// 8238C29C: 3A810120  addi r20, r1, 0x120
	ctx.r[20].s64 = ctx.r[1].s64 + 288;
	pc = 0x8238C2A0; continue 'dispatch;
            }
            0x8238C2A0 => {
    //   block [0x8238C2A0..0x8238C2B4)
	// 8238C2A0: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 8238C2A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8238C2A8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8238C2AC: 4BFDBA85  bl 0x82367d30
	ctx.lr = 0x8238C2B0;
	sub_82367D30(ctx, base);
	// 8238C2B0: 392100E0  addi r9, r1, 0xe0
	ctx.r[9].s64 = ctx.r[1].s64 + 224;
	pc = 0x8238C2B4; continue 'dispatch;
            }
            0x8238C2B4 => {
    //   block [0x8238C2B4..0x8238C5A8)
	// 8238C2B4: 38890030  addi r4, r9, 0x30
	ctx.r[4].s64 = ctx.r[9].s64 + 48;
	pc = 0x8238C5A8; continue 'dispatch;
            }
            0x8238C5A8 => {
    //   block [0x8238C5A8..0x8238C72C)
	// 8238C5A8: 895E0041  lbz r10, 0x41(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(65 as u32) ) } as u64;
	// 8238C5AC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8238C5B0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238C5B4: 41820018  beq 0x8238c5cc
	if ctx.cr[0].eq {
	pc = 0x8238C5CC; continue 'dispatch;
	}
	// 8238C5B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8238C5BC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8238C5C0: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8238C5C4: 4BFDB76D  bl 0x82367d30
	ctx.lr = 0x8238C5C8;
	sub_82367D30(ctx, base);
	// 8238C5C8: 396100E0  addi r11, r1, 0xe0
	ctx.r[11].s64 = ctx.r[1].s64 + 224;
	pc = 0x8238C72C; continue 'dispatch;
            }
            0x8238C72C => {
    //   block [0x8238C72C..0x8238C734)
	// 8238C72C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 8238C730: 481A89B8  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238C738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238C738 size=20
    let mut pc: u32 = 0x8238C738;
    'dispatch: loop {
        match pc {
            0x8238C738 => {
    //   block [0x8238C738..0x8238C74C)
	// 8238C738: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238C73C: 39440020  addi r10, r4, 0x20
	ctx.r[10].s64 = ctx.r[4].s64 + 32;
	// 8238C740: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8238C744: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8238C748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238C750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238C750 size=40
    let mut pc: u32 = 0x8238C750;
    'dispatch: loop {
        match pc {
            0x8238C750 => {
    //   block [0x8238C750..0x8238C778)
	// 8238C750: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238C754: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238C758: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8238C75C: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 8238C760: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238C764: 816BBA80  lwz r11, -0x4580(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) } as u64;
	// 8238C768: 7DA95C2E  lfsx f13, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238C76C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238C770: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8238C774: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238C778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238C778 size=12
    let mut pc: u32 = 0x8238C778;
    'dispatch: loop {
        match pc {
            0x8238C778 => {
    //   block [0x8238C778..0x8238C784)
	// 8238C778: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238C77C: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8238C780: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238C788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238C788 size=36
    let mut pc: u32 = 0x8238C788;
    'dispatch: loop {
        match pc {
            0x8238C788 => {
    //   block [0x8238C788..0x8238C7AC)
	// 8238C788: 81630090  lwz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8238C78C: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 8238C790: 38630050  addi r3, r3, 0x50
	ctx.r[3].s64 = ctx.r[3].s64 + 80;
	// 8238C794: 1D4B0070  mulli r10, r11, 0x70
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 112 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8238C798: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 8238C79C: 816BBA88  lwz r11, -0x4578(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17784 as u32) ) } as u64;
	// 8238C7A0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8238C7A4: 388B0030  addi r4, r11, 0x30
	ctx.r[4].s64 = ctx.r[11].s64 + 48;
	// 8238C7A8: 481A83A8  b 0x82534b50
	sub_82534B50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238C7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238C7B0 size=152
    let mut pc: u32 = 0x8238C7B0;
    'dispatch: loop {
        match pc {
            0x8238C7B0 => {
    //   block [0x8238C7B0..0x8238C7E8)
	// 8238C7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238C7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238C7B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238C7BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238C7C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238C7C4: 89640010  lbz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238C7C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238C7CC: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 8238C7D0: 89640011  lbz r11, 0x11(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(17 as u32) ) } as u64;
	// 8238C7D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238C7D8: 40820010  bne 0x8238c7e8
	if !ctx.cr[0].eq {
	pc = 0x8238C7E8; continue 'dispatch;
	}
	// 8238C7DC: 4BFFCD3D  bl 0x82389518
	ctx.lr = 0x8238C7E0;
	sub_82389518(ctx, base);
	// 8238C7E0: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 8238C7E4: 4800004C  b 0x8238c830
	pc = 0x8238C830; continue 'dispatch;
            }
            0x8238C7E8 => {
    //   block [0x8238C7E8..0x8238C830)
	// 8238C7E8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8238C7EC: 409A0044  bne cr6, 0x8238c830
	if !ctx.cr[6].eq {
	pc = 0x8238C830; continue 'dispatch;
	}
	// 8238C7F0: 89640001  lbz r11, 1(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(1 as u32) ) } as u64;
	// 8238C7F4: 2B0B000E  cmplwi cr6, r11, 0xe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 14 as u32, &mut ctx.xer);
	// 8238C7F8: 41980038  blt cr6, 0x8238c830
	if ctx.cr[6].lt {
	pc = 0x8238C830; continue 'dispatch;
	}
	// 8238C7FC: 3BDF00A0  addi r30, r31, 0xa0
	ctx.r[30].s64 = ctx.r[31].s64 + 160;
	// 8238C800: C0240014  lfs f1, 0x14(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8238C804: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8238C808: 4BFDB7B1  bl 0x82367fb8
	ctx.lr = 0x8238C80C;
	sub_82367FB8(ctx, base);
	// 8238C80C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238C810: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 8238C814: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238C818: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238C81C: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 8238C820: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8238C824: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 8238C828: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238C82C: D01F00DC  stfs f0, 0xdc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	pc = 0x8238C830; continue 'dispatch;
            }
            0x8238C830 => {
    //   block [0x8238C830..0x8238C848)
	// 8238C830: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238C834: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238C838: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238C83C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238C840: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238C844: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238C848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238C848 size=64
    let mut pc: u32 = 0x8238C848;
    'dispatch: loop {
        match pc {
            0x8238C848 => {
    //   block [0x8238C848..0x8238C870)
	// 8238C848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238C84C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238C850: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238C854: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238C858: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238C85C: 4800002D  bl 0x8238c888
	ctx.lr = 0x8238C860;
	sub_8238C888(ctx, base);
	// 8238C860: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238C864: 4182000C  beq 0x8238c870
	if ctx.cr[0].eq {
	pc = 0x8238C870; continue 'dispatch;
	}
	// 8238C868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238C86C: 481A634D  bl 0x82532bb8
	ctx.lr = 0x8238C870;
	sub_82532BB8(ctx, base);
	pc = 0x8238C870; continue 'dispatch;
            }
            0x8238C870 => {
    //   block [0x8238C870..0x8238C888)
	// 8238C870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238C874: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8238C878: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238C87C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238C880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238C884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238C888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238C888 size=96
    let mut pc: u32 = 0x8238C888;
    'dispatch: loop {
        match pc {
            0x8238C888 => {
    //   block [0x8238C888..0x8238C8B8)
	// 8238C888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238C88C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238C890: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238C894: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238C898: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8238C89C: 396B0250  addi r11, r11, 0x250
	ctx.r[11].s64 = ctx.r[11].s64 + 592;
	// 8238C8A0: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238C8A4: 4BFFCC75  bl 0x82389518
	ctx.lr = 0x8238C8A8;
	sub_82389518(ctx, base);
	// 8238C8A8: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 8238C8AC: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 8238C8B0: 396B5C40  addi r11, r11, 0x5c40
	ctx.r[11].s64 = ctx.r[11].s64 + 23616;
	// 8238C8B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x8238C8B8; continue 'dispatch;
            }
            0x8238C8B8 => {
    //   block [0x8238C8B8..0x8238C8E8)
	// 8238C8B8: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8238C8BC: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 8238C8C0: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 8238C8C4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8238C8C8: 4200FFF0  bdnz 0x8238c8b8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8238C8B8; continue 'dispatch;
	}
	// 8238C8CC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8238C8D0: 396B3BF8  addi r11, r11, 0x3bf8
	ctx.r[11].s64 = ctx.r[11].s64 + 15352;
	// 8238C8D4: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238C8D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8238C8DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238C8E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238C8E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238C8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238C8E8 size=84
    let mut pc: u32 = 0x8238C8E8;
    'dispatch: loop {
        match pc {
            0x8238C8E8 => {
    //   block [0x8238C8E8..0x8238C918)
	// 8238C8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238C8EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238C8F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238C8F4: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238C8F8: 38A30010  addi r5, r3, 0x10
	ctx.r[5].s64 = ctx.r[3].s64 + 16;
	// 8238C8FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238C900: 4BFDB431  bl 0x82367d30
	ctx.lr = 0x8238C904;
	sub_82367D30(ctx, base);
	// 8238C904: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 8238C908: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 8238C90C: 394B5C40  addi r10, r11, 0x5c40
	ctx.r[10].s64 = ctx.r[11].s64 + 23616;
	// 8238C910: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8238C914: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8238C918; continue 'dispatch;
            }
            0x8238C918 => {
    //   block [0x8238C918..0x8238C93C)
	// 8238C918: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8238C91C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8238C920: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8238C924: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8238C928: 4200FFF0  bdnz 0x8238c918
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8238C918; continue 'dispatch;
	}
	// 8238C92C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8238C930: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238C934: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238C938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238C940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238C940 size=28
    let mut pc: u32 = 0x8238C940;
    'dispatch: loop {
        match pc {
            0x8238C940 => {
    //   block [0x8238C940..0x8238C95C)
	// 8238C940: 89640001  lbz r11, 1(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(1 as u32) ) } as u64;
	// 8238C944: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 8238C948: 41980014  blt cr6, 0x8238c95c
	if ctx.cr[6].lt {
		sub_8238C95C(ctx, base);
		return;
	}
	// 8238C94C: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 8238C950: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 8238C954: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 8238C958: 481A81F8  b 0x82534b50
	sub_82534B50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238C95C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238C95C size=60
    let mut pc: u32 = 0x8238C95C;
    'dispatch: loop {
        match pc {
            0x8238C95C => {
    //   block [0x8238C95C..0x8238C998)
	// 8238C95C: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8238C960: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 8238C964: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8238C968: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8238C96C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8238C970: 3D403F80  lis r10, 0x3f80
	ctx.r[10].s64 = 1065353216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238C998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238C998 size=92
    let mut pc: u32 = 0x8238C998;
    'dispatch: loop {
        match pc {
            0x8238C998 => {
    //   block [0x8238C998..0x8238C9DC)
	// 8238C998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238C99C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238C9A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238C9A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238C9A8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8238C9AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238C9B0: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 8238C9B4: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8238C9B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238C9BC: 41820020  beq 0x8238c9dc
	if ctx.cr[0].eq {
	pc = 0x8238C9DC; continue 'dispatch;
	}
	// 8238C9C0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238C9C4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8238C9C8: 38C00015  li r6, 0x15
	ctx.r[6].s64 = 21;
	// 8238C9CC: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238C9D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8238C9D4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8238C9D8: 480D76E1  bl 0x824640b8
	ctx.lr = 0x8238C9DC;
	sub_824640B8(ctx, base);
	pc = 0x8238C9DC; continue 'dispatch;
            }
            0x8238C9DC => {
    //   block [0x8238C9DC..0x8238C9F4)
	// 8238C9DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238C9E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8238C9E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238C9E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238C9EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238C9F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238C9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238C9F8 size=80
    let mut pc: u32 = 0x8238C9F8;
    'dispatch: loop {
        match pc {
            0x8238C9F8 => {
    //   block [0x8238C9F8..0x8238CA48)
	// 8238C9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238C9FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238CA00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238CA04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238CA08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238CA0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238CA10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8238CA14: 481017ED  bl 0x8248e200
	ctx.lr = 0x8238CA18;
	sub_8248E200(ctx, base);
	// 8238CA18: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8238CA1C: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 8238CA20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8238CA24: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8238CA28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CA2C: 4E800421  bctrl
	ctx.lr = 0x8238CA30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CA30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238CA34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238CA38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238CA3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238CA40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238CA44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238CA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238CA48 size=80
    let mut pc: u32 = 0x8238CA48;
    'dispatch: loop {
        match pc {
            0x8238CA48 => {
    //   block [0x8238CA48..0x8238CA98)
	// 8238CA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238CA4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238CA50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238CA54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238CA58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238CA5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238CA60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8238CA64: 4810179D  bl 0x8248e200
	ctx.lr = 0x8238CA68;
	sub_8248E200(ctx, base);
	// 8238CA68: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8238CA6C: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 8238CA70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8238CA74: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8238CA78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CA7C: 4E800421  bctrl
	ctx.lr = 0x8238CA80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CA80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238CA84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238CA88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238CA8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238CA90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238CA94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238CA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238CA98 size=80
    let mut pc: u32 = 0x8238CA98;
    'dispatch: loop {
        match pc {
            0x8238CA98 => {
    //   block [0x8238CA98..0x8238CAE8)
	// 8238CA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238CA9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238CAA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238CAA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238CAA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238CAAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238CAB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8238CAB4: 4810174D  bl 0x8248e200
	ctx.lr = 0x8238CAB8;
	sub_8248E200(ctx, base);
	// 8238CAB8: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8238CABC: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 8238CAC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8238CAC4: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 8238CAC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CACC: 4E800421  bctrl
	ctx.lr = 0x8238CAD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CAD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238CAD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238CAD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238CADC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238CAE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238CAE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238CAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238CAE8 size=76
    let mut pc: u32 = 0x8238CAE8;
    'dispatch: loop {
        match pc {
            0x8238CAE8 => {
    //   block [0x8238CAE8..0x8238CB18)
	// 8238CAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238CAEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238CAF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238CAF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238CAF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238CAFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238CB00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8238CB04: 48001F45  bl 0x8238ea48
	ctx.lr = 0x8238CB08;
	sub_8238EA48(ctx, base);
	// 8238CB08: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238CB0C: 4182000C  beq 0x8238cb18
	if ctx.cr[0].eq {
	pc = 0x8238CB18; continue 'dispatch;
	}
	// 8238CB10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238CB14: 481A60A5  bl 0x82532bb8
	ctx.lr = 0x8238CB18;
	sub_82532BB8(ctx, base);
	pc = 0x8238CB18; continue 'dispatch;
            }
            0x8238CB18 => {
    //   block [0x8238CB18..0x8238CB34)
	// 8238CB18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238CB1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238CB20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238CB24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238CB28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238CB2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238CB30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238CB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238CB38 size=324
    let mut pc: u32 = 0x8238CB38;
    'dispatch: loop {
        match pc {
            0x8238CB38 => {
    //   block [0x8238CB38..0x8238CB94)
	// 8238CB38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238CB3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238CB40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238CB44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238CB48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238CB4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238CB50: 3FC08273  lis r30, -0x7d8d
	ctx.r[30].s64 = -2106392576;
	// 8238CB54: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 8238CB58: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 8238CB5C: 917E49AC  stw r11, 0x49ac(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(18860 as u32), ctx.r[11].u32 ) };
	// 8238CB60: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238CB64: 38600D80  li r3, 0xd80
	ctx.r[3].s64 = 3456;
	// 8238CB68: 916A49B0  stw r11, 0x49b0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(18864 as u32), ctx.r[11].u32 ) };
	// 8238CB6C: 817E49AC  lwz r11, 0x49ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(18860 as u32) ) } as u64;
	// 8238CB70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CB74: 4E800421  bctrl
	ctx.lr = 0x8238CB78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CB78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238CB7C: 41820018  beq 0x8238cb94
	if ctx.cr[0].eq {
	pc = 0x8238CB94; continue 'dispatch;
	}
	// 8238CB80: 480D8EB9  bl 0x82465a38
	ctx.lr = 0x8238CB84;
	sub_82465A38(ctx, base);
	// 8238CB84: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8238CB88: 3BEBBFBC  addi r31, r11, -0x4044
	ctx.r[31].s64 = ctx.r[11].s64 + -16452;
	// 8238CB8C: 907FFFF8  stw r3, -8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[3].u32 ) };
	// 8238CB90: 48000014  b 0x8238cba4
	pc = 0x8238CBA4; continue 'dispatch;
            }
            0x8238CB94 => {
    //   block [0x8238CB94..0x8238CBA4)
	// 8238CB94: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8238CB98: 3BEBBFBC  addi r31, r11, -0x4044
	ctx.r[31].s64 = ctx.r[11].s64 + -16452;
	// 8238CB9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8238CBA0: 917FFFF8  stw r11, -8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	pc = 0x8238CBA4; continue 'dispatch;
            }
            0x8238CBA4 => {
    //   block [0x8238CBA4..0x8238CBD4)
	// 8238CBA4: 817E49AC  lwz r11, 0x49ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(18860 as u32) ) } as u64;
	// 8238CBA8: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 8238CBAC: 38600330  li r3, 0x330
	ctx.r[3].s64 = 816;
	// 8238CBB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CBB4: 4E800421  bctrl
	ctx.lr = 0x8238CBB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CBB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238CBBC: 41820018  beq 0x8238cbd4
	if ctx.cr[0].eq {
	pc = 0x8238CBD4; continue 'dispatch;
	}
	// 8238CBC0: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 8238CBC4: 809FFFF8  lwz r4, -8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238CBC8: 480D6F29  bl 0x82463af0
	ctx.lr = 0x8238CBCC;
	sub_82463AF0(ctx, base);
	// 8238CBCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8238CBD0: 48000008  b 0x8238cbd8
	pc = 0x8238CBD8; continue 'dispatch;
            }
            0x8238CBD4 => {
    //   block [0x8238CBD4..0x8238CBD8)
	// 8238CBD4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8238CBD8; continue 'dispatch;
            }
            0x8238CBD8 => {
    //   block [0x8238CBD8..0x8238CC20)
	// 8238CBD8: 807FFFF8  lwz r3, -8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238CBDC: 3D400060  lis r10, 0x60
	ctx.r[10].s64 = 6291456;
	// 8238CBE0: 3D60822B  lis r11, -0x7dd5
	ctx.r[11].s64 = -2111111168;
	// 8238CBE4: 909FFFFC  stw r4, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[4].u32 ) };
	// 8238CBE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8238CBEC: 38AB2F80  addi r5, r11, 0x2f80
	ctx.r[5].s64 = ctx.r[11].s64 + 12160;
	// 8238CBF0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8238CBF4: 480DAA25  bl 0x82467618
	ctx.lr = 0x8238CBF8;
	sub_82467618(ctx, base);
	// 8238CBF8: 807FFFF8  lwz r3, -8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238CBFC: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238CC00: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238CC04: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8238CC08: 40820018  bne 0x8238cc20
	if !ctx.cr[0].eq {
	pc = 0x8238CC20; continue 'dispatch;
	}
	// 8238CC0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238CC10: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8238CC14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238CC18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CC1C: 4E800421  bctrl
	ctx.lr = 0x8238CC20;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8238CC20 => {
    //   block [0x8238CC20..0x8238CC7C)
	// 8238CC20: 807FFFFC  lwz r3, -4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8238CC24: 480D6CFD  bl 0x82463920
	ctx.lr = 0x8238CC28;
	sub_82463920(ctx, base);
	// 8238CC28: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238CC2C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8238CC30: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8238CC34: 3C800020  lis r4, 0x20
	ctx.r[4].s64 = 2097152;
	// 8238CC38: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8238CC3C: 480D762D  bl 0x82464268
	ctx.lr = 0x8238CC40;
	sub_82464268(ctx, base);
	// 8238CC40: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8238CC44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8238CC48: 3CA00020  lis r5, 0x20
	ctx.r[5].s64 = 2097152;
	// 8238CC4C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8238CC50: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238CC54: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 8238CC58: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238CC5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CC60: 4E800421  bctrl
	ctx.lr = 0x8238CC64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CC64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238CC68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238CC6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238CC70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238CC74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238CC78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238CC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238CC80 size=228
    let mut pc: u32 = 0x8238CC80;
    'dispatch: loop {
        match pc {
            0x8238CC80 => {
    //   block [0x8238CC80..0x8238CD64)
	// 8238CC80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238CC84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238CC88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238CC8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238CC90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238CC94: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8238CC98: 3BEBBFBC  addi r31, r11, -0x4044
	ctx.r[31].s64 = ctx.r[11].s64 + -16452;
	// 8238CC9C: 807FFFFC  lwz r3, -4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8238CCA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238CCA4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238CCA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CCAC: 4E800421  bctrl
	ctx.lr = 0x8238CCB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CCB0: 807FFFF8  lwz r3, -8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238CCB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238CCB8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8238CCBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CCC0: 4E800421  bctrl
	ctx.lr = 0x8238CCC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CCC4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238CCC8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8238CCCC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238CCD0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8238CCD4: 480D75ED  bl 0x824642c0
	ctx.lr = 0x8238CCD8;
	sub_824642C0(ctx, base);
	// 8238CCD8: 480DAA79  bl 0x82467750
	ctx.lr = 0x8238CCDC;
	sub_82467750(ctx, base);
	// 8238CCDC: 807FFFFC  lwz r3, -4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8238CCE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8238CCE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238CCE8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238CCEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CCF0: 4E800421  bctrl
	ctx.lr = 0x8238CCF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CCF4: 807FFFF8  lwz r3, -8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238CCF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8238CCFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238CD00: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238CD04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CD08: 4E800421  bctrl
	ctx.lr = 0x8238CD0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CD0C: 3FC08273  lis r30, -0x7d8d
	ctx.r[30].s64 = -2106392576;
	// 8238CD10: 807FFFFC  lwz r3, -4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8238CD14: 817E49B0  lwz r11, 0x49b0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(18864 as u32) ) } as u64;
	// 8238CD18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CD1C: 4E800421  bctrl
	ctx.lr = 0x8238CD20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CD20: 807FFFF8  lwz r3, -8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238CD24: 817E49B0  lwz r11, 0x49b0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(18864 as u32) ) } as u64;
	// 8238CD28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CD2C: 4E800421  bctrl
	ctx.lr = 0x8238CD30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CD30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8238CD34: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 8238CD38: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238CD3C: 917FFFFC  stw r11, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 8238CD40: 917FFFF8  stw r11, -8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 8238CD44: 916A49AC  stw r11, 0x49ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(18860 as u32), ctx.r[11].u32 ) };
	// 8238CD48: 917E49B0  stw r11, 0x49b0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(18864 as u32), ctx.r[11].u32 ) };
	// 8238CD4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238CD50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238CD54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238CD58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238CD5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238CD60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238CD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238CD68 size=272
    let mut pc: u32 = 0x8238CD68;
    'dispatch: loop {
        match pc {
            0x8238CD68 => {
    //   block [0x8238CD68..0x8238CE04)
	// 8238CD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238CD6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238CD70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238CD74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238CD78: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238CD7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8238CD80: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 8238CD84: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8238CD88: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238CD8C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238CD90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238CD94: 419A0070  beq cr6, 0x8238ce04
	if ctx.cr[6].eq {
	pc = 0x8238CE04; continue 'dispatch;
	}
	// 8238CD98: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 8238CD9C: 816B49AC  lwz r11, 0x49ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18860 as u32) ) } as u64;
	// 8238CDA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CDA4: 4E800421  bctrl
	ctx.lr = 0x8238CDA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CDA8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8238CDAC: 418200B0  beq 0x8238ce5c
	if ctx.cr[0].eq {
	pc = 0x8238CE5C; continue 'dispatch;
	}
	// 8238CDB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238CDB4: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238CDB8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8238CDBC: 396B0290  addi r11, r11, 0x290
	ctx.r[11].s64 = ctx.r[11].s64 + 656;
	// 8238CDC0: 38A0002F  li r5, 0x2f
	ctx.r[5].s64 = 47;
	// 8238CDC4: 38800310  li r4, 0x310
	ctx.r[4].s64 = 784;
	// 8238CDC8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8238CDCC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238CDD0: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238CDD4: 480D7265  bl 0x82464038
	ctx.lr = 0x8238CDD8;
	sub_82464038(ctx, base);
	// 8238CDD8: 39600310  li r11, 0x310
	ctx.r[11].s64 = 784;
	// 8238CDDC: 3CA00000  lis r5, 0
	ctx.r[5].s64 = 0;
	// 8238CDE0: 60A5C544  ori r5, r5, 0xc544
	ctx.r[5].u64 = ctx.r[5].u64 | 50500;
	// 8238CDE4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 8238CDE8: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238CDEC: 48108EA5  bl 0x82495c90
	ctx.lr = 0x8238CDF0;
	sub_82495C90(ctx, base);
	// 8238CDF0: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8238CDF4: 80630074  lwz r3, 0x74(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) } as u64;
	// 8238CDF8: 4816FD81  bl 0x824fcb78
	ctx.lr = 0x8238CDFC;
	sub_824FCB78(ctx, base);
	// 8238CDFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238CE00: 48000060  b 0x8238ce60
	pc = 0x8238CE60; continue 'dispatch;
            }
            0x8238CE04 => {
    //   block [0x8238CE04..0x8238CE5C)
	// 8238CE04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238CE08: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 8238CE0C: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238CE10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238CE14: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238CE18: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238CE1C: C1AB2224  lfs f13, 0x2224(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8740 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238CE20: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238CE24: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238CE28: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238CE2C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238CE30: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238CE34: C00B204C  lfs f0, 0x204c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238CE38: 816A49AC  lwz r11, 0x49ac(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(18860 as u32) ) } as u64;
	// 8238CE3C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8238CE40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CE44: 4E800421  bctrl
	ctx.lr = 0x8238CE48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CE48: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238CE4C: 41820010  beq 0x8238ce5c
	if ctx.cr[0].eq {
	pc = 0x8238CE5C; continue 'dispatch;
	}
	// 8238CE50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8238CE54: 4800085D  bl 0x8238d6b0
	ctx.lr = 0x8238CE58;
	sub_8238D6B0(ctx, base);
	// 8238CE58: 48000008  b 0x8238ce60
	pc = 0x8238CE60; continue 'dispatch;
            }
            0x8238CE5C => {
    //   block [0x8238CE5C..0x8238CE60)
	// 8238CE5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8238CE60; continue 'dispatch;
            }
            0x8238CE60 => {
    //   block [0x8238CE60..0x8238CE78)
	// 8238CE60: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8238CE64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238CE68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238CE6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238CE70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238CE74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238CE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238CE78 size=244
    let mut pc: u32 = 0x8238CE78;
    'dispatch: loop {
        match pc {
            0x8238CE78 => {
    //   block [0x8238CE78..0x8238CED4)
	// 8238CE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238CE7C: 481A8241  bl 0x825350bc
	ctx.lr = 0x8238CE80;
	sub_82535080(ctx, base);
	// 8238CE80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238CE84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8238CE88: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8238CE8C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 8238CE90: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 8238CE94: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8238CE98: 41980068  blt cr6, 0x8238cf00
	if ctx.cr[6].lt {
	pc = 0x8238CF00; continue 'dispatch;
	}
	// 8238CE9C: 419A0038  beq cr6, 0x8238ced4
	if ctx.cr[6].eq {
	pc = 0x8238CED4; continue 'dispatch;
	}
	// 8238CEA0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8238CEA4: 409800BC  bge cr6, 0x8238cf60
	if !ctx.cr[6].lt {
	pc = 0x8238CF60; continue 'dispatch;
	}
	// 8238CEA8: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 8238CEAC: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 8238CEB0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8238CEB4: 816B49AC  lwz r11, 0x49ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18860 as u32) ) } as u64;
	// 8238CEB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CEBC: 4E800421  bctrl
	ctx.lr = 0x8238CEC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CEC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238CEC4: 41820078  beq 0x8238cf3c
	if ctx.cr[0].eq {
	pc = 0x8238CF3C; continue 'dispatch;
	}
	// 8238CEC8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238CECC: 396B02BC  addi r11, r11, 0x2bc
	ctx.r[11].s64 = ctx.r[11].s64 + 700;
	// 8238CED0: 48000058  b 0x8238cf28
	pc = 0x8238CF28; continue 'dispatch;
            }
            0x8238CED4 => {
    //   block [0x8238CED4..0x8238CF00)
	// 8238CED4: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 8238CED8: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 8238CEDC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8238CEE0: 816B49AC  lwz r11, 0x49ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18860 as u32) ) } as u64;
	// 8238CEE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CEE8: 4E800421  bctrl
	ctx.lr = 0x8238CEEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CEEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238CEF0: 4182004C  beq 0x8238cf3c
	if ctx.cr[0].eq {
	pc = 0x8238CF3C; continue 'dispatch;
	}
	// 8238CEF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238CEF8: 396B02A8  addi r11, r11, 0x2a8
	ctx.r[11].s64 = ctx.r[11].s64 + 680;
	// 8238CEFC: 4800002C  b 0x8238cf28
	pc = 0x8238CF28; continue 'dispatch;
            }
            0x8238CF00 => {
    //   block [0x8238CF00..0x8238CF28)
	// 8238CF00: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 8238CF04: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 8238CF08: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8238CF0C: 816B49AC  lwz r11, 0x49ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18860 as u32) ) } as u64;
	// 8238CF10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CF14: 4E800421  bctrl
	ctx.lr = 0x8238CF18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238CF18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238CF1C: 41820020  beq 0x8238cf3c
	if ctx.cr[0].eq {
	pc = 0x8238CF3C; continue 'dispatch;
	}
	// 8238CF20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238CF24: 396B0294  addi r11, r11, 0x294
	ctx.r[11].s64 = ctx.r[11].s64 + 660;
            }
            0x8238CF28 => {
    //   block [0x8238CF28..0x8238CF3C)
	// 8238CF28: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238CF2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238CF30: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 8238CF34: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8238CF38: 48000008  b 0x8238cf40
	pc = 0x8238CF40; continue 'dispatch;
            }
            0x8238CF3C => {
    //   block [0x8238CF3C..0x8238CF40)
	// 8238CF3C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x8238CF40; continue 'dispatch;
            }
            0x8238CF40 => {
    //   block [0x8238CF40..0x8238CF60)
	// 8238CF40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8238CF44: 419A001C  beq cr6, 0x8238cf60
	if ctx.cr[6].eq {
	pc = 0x8238CF60; continue 'dispatch;
	}
	// 8238CF48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238CF4C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8238CF50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238CF54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238CF58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238CF5C: 4E800421  bctrl
	ctx.lr = 0x8238CF60;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8238CF60 => {
    //   block [0x8238CF60..0x8238CF6C)
	// 8238CF60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238CF64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238CF68: 481A81A4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238CF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238CF70 size=76
    let mut pc: u32 = 0x8238CF70;
    'dispatch: loop {
        match pc {
            0x8238CF70 => {
    //   block [0x8238CF70..0x8238CFA0)
	// 8238CF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238CF74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238CF78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238CF7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238CF80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238CF84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238CF88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8238CF8C: 480009C5  bl 0x8238d950
	ctx.lr = 0x8238CF90;
	sub_8238D950(ctx, base);
	// 8238CF90: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238CF94: 4182000C  beq 0x8238cfa0
	if ctx.cr[0].eq {
	pc = 0x8238CFA0; continue 'dispatch;
	}
	// 8238CF98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238CF9C: 481A5C1D  bl 0x82532bb8
	ctx.lr = 0x8238CFA0;
	sub_82532BB8(ctx, base);
	pc = 0x8238CFA0; continue 'dispatch;
            }
            0x8238CFA0 => {
    //   block [0x8238CFA0..0x8238CFBC)
	// 8238CFA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238CFA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238CFA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238CFAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238CFB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238CFB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238CFB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238CFC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238CFC0 size=412
    let mut pc: u32 = 0x8238CFC0;
    'dispatch: loop {
        match pc {
            0x8238CFC0 => {
    //   block [0x8238CFC0..0x8238D0C4)
	// 8238CFC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238CFC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238CFC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238CFCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238CFD0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238CFD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238CFD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8238CFDC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238CFE0: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 8238CFE4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238CFE8: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238CFEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8238CFF0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8238CFF4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8238CFF8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8238CFFC: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8238D000: 916100AC  stw r11, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 8238D004: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 8238D008: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8238D00C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8238D010: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8238D014: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8238D018: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 8238D01C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8238D020: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8238D024: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 8238D028: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238D02C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238D030: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8238D034: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8238D038: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8238D03C: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8238D040: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8238D044: 916100B4  stw r11, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 8238D048: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238D04C: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8238D050: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8238D054: D1A1009C  stfs f13, 0x9c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8238D058: D1A100A8  stfs f13, 0xa8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8238D05C: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D060: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8238D064: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8238D068: C00BD218  lfs f0, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D06C: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8238D070: 4BFFFE09  bl 0x8238ce78
	ctx.lr = 0x8238D074;
	sub_8238CE78(ctx, base);
	// 8238D074: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8238D078: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238D07C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238D080: C00B01A0  lfs f0, 0x1a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D084: C1AB01A4  lfs f13, 0x1a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(420 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238D088: C18B01A8  lfs f12, 0x1a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(424 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238D08C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8238D090: C16B01AC  lfs f11, 0x1ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(428 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238D094: 419A0030  beq cr6, 0x8238d0c4
	if ctx.cr[6].eq {
	pc = 0x8238D0C4; continue 'dispatch;
	}
	// 8238D098: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238D09C: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 8238D0A0: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238D0A4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 8238D0A8: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238D0AC: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238D0B0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	pc = 0x8238D0C4; continue 'dispatch;
            }
            0x8238D0C4 => {
    //   block [0x8238D0C4..0x8238D15C)
	// 8238D0C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238D0C8: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238D0CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8238D0D0: C00B01B0  lfs f0, 0x1b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D0D4: C1AB01B4  lfs f13, 0x1b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(436 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238D0D8: C18B01B8  lfs f12, 0x1b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238D0DC: C16B01BC  lfs f11, 0x1bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(444 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238D0E0: 419A0030  beq cr6, 0x8238d110
	if ctx.cr[6].eq {
	pc = 0x8238D110; continue 'dispatch;
	}
	// 8238D0E4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238D0E8: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 8238D0EC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238D0F0: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 8238D0F4: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238D0F8: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238D0FC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238D160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238D160 size=80
    let mut pc: u32 = 0x8238D160;
    'dispatch: loop {
        match pc {
            0x8238D160 => {
    //   block [0x8238D160..0x8238D1B0)
	// 8238D160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238D164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238D168: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238D16C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238D170: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238D174: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8238D178: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238D17C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238D180: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238D184: 4E800421  bctrl
	ctx.lr = 0x8238D188;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238D188: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 8238D18C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238D190: 816B49B0  lwz r11, 0x49b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18864 as u32) ) } as u64;
	// 8238D194: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238D198: 4E800421  bctrl
	ctx.lr = 0x8238D19C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238D19C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8238D1A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238D1A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238D1A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238D1AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238D1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238D1B0 size=168
    let mut pc: u32 = 0x8238D1B0;
    'dispatch: loop {
        match pc {
            0x8238D1B0 => {
    //   block [0x8238D1B0..0x8238D200)
	// 8238D1B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238D1B4: 481A7F05  bl 0x825350b8
	ctx.lr = 0x8238D1B8;
	sub_82535080(ctx, base);
	// 8238D1B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238D1BC: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 8238D1C0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8238D1C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8238D1C8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8238D1CC: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 8238D1D0: 816B49AC  lwz r11, 0x49ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18860 as u32) ) } as u64;
	// 8238D1D4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8238D1D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238D1DC: 4E800421  bctrl
	ctx.lr = 0x8238D1E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238D1E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8238D1E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238D1E8: 41820018  beq 0x8238d200
	if ctx.cr[0].eq {
	pc = 0x8238D200; continue 'dispatch;
	}
	// 8238D1EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238D1F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238D1F4: 396B0290  addi r11, r11, 0x290
	ctx.r[11].s64 = ctx.r[11].s64 + 656;
	// 8238D1F8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238D1FC: 48000008  b 0x8238d204
	pc = 0x8238D204; continue 'dispatch;
            }
            0x8238D200 => {
    //   block [0x8238D200..0x8238D204)
	// 8238D200: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	pc = 0x8238D204; continue 'dispatch;
            }
            0x8238D204 => {
    //   block [0x8238D204..0x8238D220)
	// 8238D204: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 8238D208: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8238D20C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8238D210: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8238D214: 419A000C  beq cr6, 0x8238d220
	if ctx.cr[6].eq {
	pc = 0x8238D220; continue 'dispatch;
	}
	// 8238D218: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238D21C: 48000008  b 0x8238d224
	pc = 0x8238D224; continue 'dispatch;
            }
            0x8238D220 => {
    //   block [0x8238D220..0x8238D224)
	// 8238D220: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8238D224; continue 'dispatch;
            }
            0x8238D224 => {
    //   block [0x8238D224..0x8238D234)
	// 8238D224: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8238D228: 419A000C  beq cr6, 0x8238d234
	if ctx.cr[6].eq {
	pc = 0x8238D234; continue 'dispatch;
	}
	// 8238D22C: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238D230: 48000008  b 0x8238d238
	pc = 0x8238D238; continue 'dispatch;
            }
            0x8238D234 => {
    //   block [0x8238D234..0x8238D238)
	// 8238D234: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x8238D238; continue 'dispatch;
            }
            0x8238D238 => {
    //   block [0x8238D238..0x8238D258)
	// 8238D238: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8238D23C: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238D240: 48104FA1  bl 0x824921e0
	ctx.lr = 0x8238D244;
	sub_824921E0(ctx, base);
	// 8238D244: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8238D248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238D24C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8238D250: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8238D254: 481A7EB4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238D258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238D258 size=144
    let mut pc: u32 = 0x8238D258;
    'dispatch: loop {
        match pc {
            0x8238D258 => {
    //   block [0x8238D258..0x8238D2B4)
	// 8238D258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238D25C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238D260: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238D264: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238D268: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238D26C: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 8238D270: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8238D274: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 8238D278: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8238D27C: 816B49AC  lwz r11, 0x49ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18860 as u32) ) } as u64;
	// 8238D280: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238D284: 4E800421  bctrl
	ctx.lr = 0x8238D288;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238D288: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238D28C: 41820028  beq 0x8238d2b4
	if ctx.cr[0].eq {
	pc = 0x8238D2B4; continue 'dispatch;
	}
	// 8238D290: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238D294: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238D298: 394B02D0  addi r10, r11, 0x2d0
	ctx.r[10].s64 = ctx.r[11].s64 + 720;
	// 8238D29C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8238D2A0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8238D2A4: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8238D2A8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8238D2AC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8238D2B0: 48000008  b 0x8238d2b8
	pc = 0x8238D2B8; continue 'dispatch;
            }
            0x8238D2B4 => {
    //   block [0x8238D2B4..0x8238D2B8)
	// 8238D2B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x8238D2B8; continue 'dispatch;
            }
            0x8238D2B8 => {
    //   block [0x8238D2B8..0x8238D2CC)
	// 8238D2B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8238D2BC: 419A0010  beq cr6, 0x8238d2cc
	if ctx.cr[6].eq {
	pc = 0x8238D2CC; continue 'dispatch;
	}
	// 8238D2C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8238D2C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238D2C8: 48001221  bl 0x8238e4e8
	ctx.lr = 0x8238D2CC;
	sub_8238E4E8(ctx, base);
	pc = 0x8238D2CC; continue 'dispatch;
            }
            0x8238D2CC => {
    //   block [0x8238D2CC..0x8238D2E8)
	// 8238D2CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238D2D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238D2D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238D2D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238D2DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238D2E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238D2E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238D2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238D2E8 size=276
    let mut pc: u32 = 0x8238D2E8;
    'dispatch: loop {
        match pc {
            0x8238D2E8 => {
    //   block [0x8238D2E8..0x8238D304)
	// 8238D2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238D2EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238D2F0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238D2F4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8238D2F8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8238D2FC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 8238D300: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8238D304; continue 'dispatch;
            }
            0x8238D304 => {
    //   block [0x8238D304..0x8238D3EC)
	// 8238D304: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8238D308: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8238D30C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8238D310: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8238D314: 4200FFF0  bdnz 0x8238d304
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8238D304; continue 'dispatch;
	}
	// 8238D318: C0010070  lfs f0, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D31C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8238D320: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 8238D324: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8238D328: C0010074  lfs f0, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D32C: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 8238D330: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8238D334: C0010078  lfs f0, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D338: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 8238D33C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8238D340: C0010080  lfs f0, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D344: 816BBFA0  lwz r11, -0x4060(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16480 as u32) ) } as u64;
	// 8238D348: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 8238D34C: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8238D350: C0010084  lfs f0, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D354: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8238D358: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 8238D35C: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8238D360: C0010088  lfs f0, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D364: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 8238D368: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8238D36C: C0010090  lfs f0, 0x90(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D370: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 8238D374: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8238D378: C0010094  lfs f0, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D37C: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 8238D380: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8238D384: C0010098  lfs f0, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D388: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 8238D38C: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8238D390: 419A005C  beq cr6, 0x8238d3ec
	if ctx.cr[6].eq {
	pc = 0x8238D3EC; continue 'dispatch;
	}
	// 8238D394: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8238D398: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 8238D39C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8238D3A0: 396BBF80  addi r11, r11, -0x4080
	ctx.r[11].s64 = ctx.r[11].s64 + -16512;
	// 8238D3A4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8238D3A8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	pc = 0x8238D3EC; continue 'dispatch;
            }
            0x8238D3EC => {
    //   block [0x8238D3EC..0x8238D3FC)
	// 8238D3EC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8238D3F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238D3F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238D3F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238D400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238D400 size=688
    let mut pc: u32 = 0x8238D400;
    'dispatch: loop {
        match pc {
            0x8238D400 => {
    //   block [0x8238D400..0x8238D428)
	// 8238D400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238D404: 481A7CB9  bl 0x825350bc
	ctx.lr = 0x8238D408;
	sub_82535080(ctx, base);
	// 8238D408: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8238D40C: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238D410: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8238D414: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8238D418: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 8238D41C: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 8238D420: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 8238D424: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x8238D428; continue 'dispatch;
            }
            0x8238D428 => {
    //   block [0x8238D428..0x8238D6B0)
	// 8238D428: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8238D42C: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 8238D430: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8238D434: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8238D438: 4200FFF0  bdnz 0x8238d428
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8238D428; continue 'dispatch;
	}
	// 8238D43C: E9040000  ld r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 8238D440: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 8238D444: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8238D448: E8E40008  ld r7, 8(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	// 8238D44C: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 8238D450: F90B0000  std r8, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 8238D454: C00ABA38  lfs f0, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D458: F8EB0008  std r7, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 8238D45C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238D460: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8238D464: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8238D468: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8238D46C: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8238D470: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8238D474: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8238D478: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 8238D47C: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 8238D480: C00100D0  lfs f0, 0xd0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D484: C18100D4  lfs f12, 0xd4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238D488: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8238D48C: C14100D8  lfs f10, 0xd8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8238D490: FD606050  fneg f11, f12
	ctx.f[11].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8238D494: FD205050  fneg f9, f10
	ctx.f[9].u64 = ctx.f[10].u64 ^ 0x8000_0000_0000_0000u64;
	// 8238D498: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8238D49C: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8238D4A0: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8238D4A4: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8238D4A8: D1410098  stfs f10, 0x98(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8238D4AC: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8238D4B0: D14100A8  stfs f10, 0xa8(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8238D4B4: D18100B4  stfs f12, 0xb4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8238D4B8: D14100B8  stfs f10, 0xb8(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8238D4BC: D00100C0  stfs f0, 0xc0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8238D4C0: D18100C4  stfs f12, 0xc4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8238D4C4: D14100C8  stfs f10, 0xc8(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8238D4C8: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238D4CC: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238D4D0: D1210058  stfs f9, 0x58(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238D4D4: D1610064  stfs f11, 0x64(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8238D4D8: D1210068  stfs f9, 0x68(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8238D4DC: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8238D4E0: D1210078  stfs f9, 0x78(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8238D4E4: D1210088  stfs f9, 0x88(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8238D4E8: D1A10090  stfs f13, 0x90(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8238D4EC: D1610094  stfs f11, 0x94(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8238D4F0: D16100A4  stfs f11, 0xa4(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8238D4F4: D1A100B0  stfs f13, 0xb0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8238D4F8: 39610110  addi r11, r1, 0x110
	ctx.r[11].s64 = ctx.r[1].s64 + 272;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238D6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238D6B0 size=236
    let mut pc: u32 = 0x8238D6B0;
    'dispatch: loop {
        match pc {
            0x8238D6B0 => {
    //   block [0x8238D6B0..0x8238D79C)
	// 8238D6B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238D6B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238D6B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238D6BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238D6C0: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238D6C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8238D6C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238D6CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238D6D0: 396B0290  addi r11, r11, 0x290
	ctx.r[11].s64 = ctx.r[11].s64 + 656;
	// 8238D6D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8238D6D8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D6DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8238D6E0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238D6E4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D6E8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238D6EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238D6F0: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D6F4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8238D6F8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238D6FC: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D700: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238D704: 4810D98D  bl 0x8249b090
	ctx.lr = 0x8238D708;
	sub_8249B090(ctx, base);
	// 8238D708: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8238D70C: C03E0010  lfs f1, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8238D710: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8238D714: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8238D718: 9961011D  stb r11, 0x11d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(285 as u32), ctx.r[11].u8 ) };
	// 8238D71C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238D7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238D7A0 size=284
    let mut pc: u32 = 0x8238D7A0;
    'dispatch: loop {
        match pc {
            0x8238D7A0 => {
    //   block [0x8238D7A0..0x8238D7F4)
	// 8238D7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238D7A4: 481A790D  bl 0x825350b0
	ctx.lr = 0x8238D7A8;
	sub_82535080(ctx, base);
	// 8238D7A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238D7AC: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238D7B0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8238D7B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8238D7B8: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8238D7BC: 38800100  li r4, 0x100
	ctx.r[4].s64 = 256;
	// 8238D7C0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8238D7C4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8238D7C8: 480D6871  bl 0x82464038
	ctx.lr = 0x8238D7CC;
	sub_82464038(ctx, base);
	// 8238D7CC: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	// 8238D7D0: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 8238D7D4: 4816FFA5  bl 0x824fd778
	ctx.lr = 0x8238D7D8;
	sub_824FD778(ctx, base);
	// 8238D7D8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238D7DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8238D7E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8238D7E4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8238D7E8: 40810070  ble 0x8238d858
	if !ctx.cr[0].gt {
	pc = 0x8238D858; continue 'dispatch;
	}
	// 8238D7EC: 3B7E0004  addi r27, r30, 4
	ctx.r[27].s64 = ctx.r[30].s64 + 4;
	// 8238D7F0: 3B9E0048  addi r28, r30, 0x48
	ctx.r[28].s64 = ctx.r[30].s64 + 72;
	pc = 0x8238D7F4; continue 'dispatch;
            }
            0x8238D7F4 => {
    //   block [0x8238D7F4..0x8238D804)
	// 8238D7F4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8238D7F8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8238D7FC: 40980008  bge cr6, 0x8238d804
	if !ctx.cr[6].lt {
	pc = 0x8238D804; continue 'dispatch;
	}
	// 8238D800: E95C0000  ld r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	pc = 0x8238D804; continue 'dispatch;
            }
            0x8238D804 => {
    //   block [0x8238D804..0x8238D820)
	// 8238D804: 79490022  rldicl r9, r10, 0x20, 0x20
	ctx.r[9].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 8238D808: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8238D80C: 5545003E  slwi r5, r10, 0
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8238D810: 5524003E  slwi r4, r9, 0
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8238D814: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8238D818: 40980008  bge cr6, 0x8238d820
	if !ctx.cr[6].lt {
	pc = 0x8238D820; continue 'dispatch;
	}
	// 8238D81C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8238D820; continue 'dispatch;
            }
            0x8238D820 => {
    //   block [0x8238D820..0x8238D838)
	// 8238D820: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8238D824: 41980014  blt cr6, 0x8238d838
	if ctx.cr[6].lt {
	pc = 0x8238D838; continue 'dispatch;
	}
	// 8238D828: 409A0018  bne cr6, 0x8238d840
	if !ctx.cr[6].eq {
	pc = 0x8238D840; continue 'dispatch;
	}
	// 8238D82C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8238D830: 4816FEF1  bl 0x824fd720
	ctx.lr = 0x8238D834;
	sub_824FD720(ctx, base);
	// 8238D834: 4800000C  b 0x8238d840
	pc = 0x8238D840; continue 'dispatch;
            }
            0x8238D838 => {
    //   block [0x8238D838..0x8238D840)
	// 8238D838: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8238D83C: 4816FE1D  bl 0x824fd658
	ctx.lr = 0x8238D840;
	sub_824FD658(ctx, base);
	pc = 0x8238D840; continue 'dispatch;
            }
            0x8238D840 => {
    //   block [0x8238D840..0x8238D858)
	// 8238D840: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238D844: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8238D848: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 8238D84C: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 8238D850: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8238D854: 4198FFA0  blt cr6, 0x8238d7f4
	if ctx.cr[6].lt {
	pc = 0x8238D7F4; continue 'dispatch;
	}
	pc = 0x8238D858; continue 'dispatch;
            }
            0x8238D858 => {
    //   block [0x8238D858..0x8238D8B4)
	// 8238D858: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8238D85C: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238D860: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8238D864: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8238D868: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8238D86C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8238D870: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 8238D874: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238D878: 4810D179  bl 0x8249a9f0
	ctx.lr = 0x8238D87C;
	sub_8249A9F0(ctx, base);
	// 8238D87C: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238D880: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238D884: 41820030  beq 0x8238d8b4
	if ctx.cr[0].eq {
	pc = 0x8238D8B4; continue 'dispatch;
	}
	// 8238D888: A17D0006  lhz r11, 6(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(6 as u32) ) } as u64;
	// 8238D88C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238D890: 7D6B0735  extsh. r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238D894: B17D0006  sth r11, 6(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 8238D898: 4082001C  bne 0x8238d8b4
	if !ctx.cr[0].eq {
	pc = 0x8238D8B4; continue 'dispatch;
	}
	// 8238D89C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238D8A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8238D8A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8238D8A8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238D8AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238D8B0: 4E800421  bctrl
	ctx.lr = 0x8238D8B4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8238D8B4 => {
    //   block [0x8238D8B4..0x8238D8BC)
	// 8238D8B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8238D8B8: 481A7848  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238D8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238D8C0 size=140
    let mut pc: u32 = 0x8238D8C0;
    'dispatch: loop {
        match pc {
            0x8238D8C0 => {
    //   block [0x8238D8C0..0x8238D94C)
	// 8238D8C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238D8C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8238D8C8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8238D8CC: 39000007  li r8, 7
	ctx.r[8].s64 = 7;
	// 8238D8D0: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238D8D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238D8D8: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8238D8DC: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8238D8E0: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8238D8E4: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238D8E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238D8EC: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8238D8F0: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8238D8F4: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8238D8F8: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8238D8FC: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238D900: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8238D904: D1A3001C  stfs f13, 0x1c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8238D908: D1A30020  stfs f13, 0x20(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8238D90C: D1A30024  stfs f13, 0x24(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8238D910: D1A30028  stfs f13, 0x28(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8238D914: D1A3002C  stfs f13, 0x2c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8238D918: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8238D91C: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8238D920: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8238D924: D1A3003C  stfs f13, 0x3c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8238D928: 9123004C  stw r9, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[9].u32 ) };
	// 8238D92C: C16BD218  lfs f11, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238D930: 91030050  stw r8, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 8238D934: D1A30048  stfs f13, 0x48(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8238D938: 91430054  stw r10, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8238D93C: D1830044  stfs f12, 0x44(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8238D940: 91430058  stw r10, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8238D944: D1630040  stfs f11, 0x40(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8238D948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238D950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238D950 size=152
    let mut pc: u32 = 0x8238D950;
    'dispatch: loop {
        match pc {
            0x8238D950 => {
    //   block [0x8238D950..0x8238D98C)
	// 8238D950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238D954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238D958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238D95C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238D960: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238D964: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238D968: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238D96C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8238D970: 396B027C  addi r11, r11, 0x27c
	ctx.r[11].s64 = ctx.r[11].s64 + 636;
	// 8238D974: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238D978: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238D97C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238D980: 4182000C  beq 0x8238d98c
	if ctx.cr[0].eq {
	pc = 0x8238D98C; continue 'dispatch;
	}
	// 8238D984: 4810E0CD  bl 0x8249ba50
	ctx.lr = 0x8238D988;
	sub_8249BA50(ctx, base);
	// 8238D988: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x8238D98C; continue 'dispatch;
            }
            0x8238D98C => {
    //   block [0x8238D98C..0x8238D9CC)
	// 8238D98C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238D990: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238D994: 4182003C  beq 0x8238d9d0
	if ctx.cr[0].eq {
	pc = 0x8238D9D0; continue 'dispatch;
	}
	// 8238D998: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238D99C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238D9A0: 4182002C  beq 0x8238d9cc
	if ctx.cr[0].eq {
	pc = 0x8238D9CC; continue 'dispatch;
	}
	// 8238D9A4: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8238D9A8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238D9AC: 7D6B0735  extsh. r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238D9B0: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 8238D9B4: 40820018  bne 0x8238d9cc
	if !ctx.cr[0].eq {
	pc = 0x8238D9CC; continue 'dispatch;
	}
	// 8238D9B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238D9BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8238D9C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238D9C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238D9C8: 4E800421  bctrl
	ctx.lr = 0x8238D9CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8238D9CC => {
    //   block [0x8238D9CC..0x8238D9D0)
	// 8238D9CC: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x8238D9D0; continue 'dispatch;
            }
            0x8238D9D0 => {
    //   block [0x8238D9D0..0x8238D9E8)
	// 8238D9D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238D9D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238D9D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238D9DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238D9E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238D9E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238D9E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238D9E8 size=100
    let mut pc: u32 = 0x8238D9E8;
    'dispatch: loop {
        match pc {
            0x8238D9E8 => {
    //   block [0x8238D9E8..0x8238DA3C)
	// 8238D9E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238D9EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238D9F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238D9F4: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238D9F8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8238D9FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238DA00: 4182003C  beq 0x8238da3c
	if ctx.cr[0].eq {
	pc = 0x8238DA3C; continue 'dispatch;
	}
	// 8238DA04: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DA08: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8238DA0C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238DA10: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DA14: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238DA18: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DA1C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238DA20: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DA24: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 8238DA28: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238DA2C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	pc = 0x8238DA3C; continue 'dispatch;
            }
            0x8238DA3C => {
    //   block [0x8238DA3C..0x8238DA4C)
	// 8238DA3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8238DA40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238DA44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238DA48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238DA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238DA50 size=160
    let mut pc: u32 = 0x8238DA50;
    'dispatch: loop {
        match pc {
            0x8238DA50 => {
    //   block [0x8238DA50..0x8238DAE0)
	// 8238DA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238DA54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238DA58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238DA5C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238DA60: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238DA64: 4182007C  beq 0x8238dae0
	if ctx.cr[0].eq {
	pc = 0x8238DAE0; continue 'dispatch;
	}
	// 8238DA68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238DA6C: C1240030  lfs f9, 0x30(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8238DA70: C1040034  lfs f8, 0x34(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8238DA74: C0E40038  lfs f7, 0x38(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8238DA78: 4BFE6929  bl 0x823743a0
	ctx.lr = 0x8238DA7C;
	sub_823743A0(ctx, base);
	// 8238DA7C: C001008C  lfs f0, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DA80: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 8238DA84: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8238DA88: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 8238DA8C: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DA90: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8238DA94: D1210060  stfs f9, 0x60(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8238DA98: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8238DA9C: D1010064  stfs f8, 0x64(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8238DAA0: D0E10068  stfs f7, 0x68(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8238DAA4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8238DAA8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8238DAAC: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DAB0: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8238DAB4: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DAB8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8238DABC: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8238DAE0; continue 'dispatch;
            }
            0x8238DAE0 => {
    //   block [0x8238DAE0..0x8238DAF0)
	// 8238DAE0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8238DAE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238DAE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238DAEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238DAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238DAF0 size=100
    let mut pc: u32 = 0x8238DAF0;
    'dispatch: loop {
        match pc {
            0x8238DAF0 => {
    //   block [0x8238DAF0..0x8238DB44)
	// 8238DAF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238DAF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238DAF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238DAFC: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238DB00: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8238DB04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238DB08: 4182003C  beq 0x8238db44
	if ctx.cr[0].eq {
	pc = 0x8238DB44; continue 'dispatch;
	}
	// 8238DB0C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DB10: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8238DB14: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238DB18: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DB1C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238DB20: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DB24: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238DB28: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DB2C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 8238DB30: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238DB34: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	pc = 0x8238DB44; continue 'dispatch;
            }
            0x8238DB44 => {
    //   block [0x8238DB44..0x8238DB54)
	// 8238DB44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8238DB48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238DB4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238DB50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238DB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238DB58 size=100
    let mut pc: u32 = 0x8238DB58;
    'dispatch: loop {
        match pc {
            0x8238DB58 => {
    //   block [0x8238DB58..0x8238DBAC)
	// 8238DB58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238DB5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238DB60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238DB64: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238DB68: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8238DB6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238DB70: 4182003C  beq 0x8238dbac
	if ctx.cr[0].eq {
	pc = 0x8238DBAC; continue 'dispatch;
	}
	// 8238DB74: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DB78: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8238DB7C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238DB80: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DB84: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238DB88: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DB8C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238DB90: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DB94: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 8238DB98: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238DB9C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	pc = 0x8238DBAC; continue 'dispatch;
            }
            0x8238DBAC => {
    //   block [0x8238DBAC..0x8238DBBC)
	// 8238DBAC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8238DBB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238DBB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238DBB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238DBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238DBC0 size=104
    let mut pc: u32 = 0x8238DBC0;
    'dispatch: loop {
        match pc {
            0x8238DBC0 => {
    //   block [0x8238DBC0..0x8238DC14)
	// 8238DBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238DBC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238DBC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238DBCC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238DBD0: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238DBD4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8238DBD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238DBDC: 41820038  beq 0x8238dc14
	if ctx.cr[0].eq {
	pc = 0x8238DC14; continue 'dispatch;
	}
	// 8238DBE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238DBE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8238DBE8: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8238DBEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238DBF0: 4E800421  bctrl
	ctx.lr = 0x8238DBF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238DBF4: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DBF8: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238DBFC: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8238DC00: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8238DC04: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DC08: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238DC0C: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8238DC10: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
            }
            0x8238DC14 => {
    //   block [0x8238DC14..0x8238DC28)
	// 8238DC14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238DC18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238DC1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238DC20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238DC24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238DC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238DC28 size=100
    let mut pc: u32 = 0x8238DC28;
    'dispatch: loop {
        match pc {
            0x8238DC28 => {
    //   block [0x8238DC28..0x8238DC8C)
	// 8238DC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238DC2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238DC30: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238DC34: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238DC38: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 8238DC3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8238DC40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8238DC44: C00B0150  lfs f0, 0x150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DC48: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238DC4C: C00B0154  lfs f0, 0x154(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DC50: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238DC54: C00B0158  lfs f0, 0x158(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DC58: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238DC5C: C00B015C  lfs f0, 0x15c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DC60: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238DC64: 4BFDA8D5  bl 0x82368538
	ctx.lr = 0x8238DC68;
	sub_82368538(ctx, base);
	// 8238DC68: 38CA0008  addi r6, r10, 8
	ctx.r[6].s64 = ctx.r[10].s64 + 8;
	// 8238DC6C: 38AA0004  addi r5, r10, 4
	ctx.r[5].s64 = ctx.r[10].s64 + 4;
	// 8238DC70: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 8238DC74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8238DC78: 4BFDA999  bl 0x82368610
	ctx.lr = 0x8238DC7C;
	sub_82368610(ctx, base);
	// 8238DC7C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8238DC80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238DC84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238DC88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238DC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238DC90 size=120
    let mut pc: u32 = 0x8238DC90;
    'dispatch: loop {
        match pc {
            0x8238DC90 => {
    //   block [0x8238DC90..0x8238DD08)
	// 8238DC90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238DC94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238DC98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238DC9C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8238DCA0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8238DCA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8238DCA8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238DCAC: C00B0150  lfs f0, 0x150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DCB0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238DCB4: C00B0154  lfs f0, 0x154(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DCB8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238DCBC: C00B0158  lfs f0, 0x158(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DCC0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238DCC4: C00B015C  lfs f0, 0x15c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DCC8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238DCCC: 4BFDA86D  bl 0x82368538
	ctx.lr = 0x8238DCD0;
	sub_82368538(ctx, base);
	// 8238DCD0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238DCD4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8238DCD8: C1AB0110  lfs f13, 0x110(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238DCDC: C18B0114  lfs f12, 0x114(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238DCE0: C16B0118  lfs f11, 0x118(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(280 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238DCE4: C00ABA38  lfs f0, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DCE8: D003003C  stfs f0, 0x3c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8238DCEC: D1A30030  stfs f13, 0x30(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8238DCF0: D1830034  stfs f12, 0x34(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8238DCF4: D1630038  stfs f11, 0x38(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8238DCF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238DCFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238DD00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238DD04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238DD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238DD08 size=576
    let mut pc: u32 = 0x8238DD08;
    'dispatch: loop {
        match pc {
            0x8238DD08 => {
    //   block [0x8238DD08..0x8238DF48)
	// 8238DD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238DD0C: 481A73AD  bl 0x825350b8
	ctx.lr = 0x8238DD10;
	sub_82535080(ctx, base);
	// 8238DD10: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8238DD14: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238DD18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8238DD1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8238DD20: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8238DD24: C07F0018  lfs f3, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8238DD28: C05F0014  lfs f2, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8238DD2C: C03F0010  lfs f1, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8238DD30: 4BFDA4E9  bl 0x82368218
	ctx.lr = 0x8238DD34;
	sub_82368218(ctx, base);
	// 8238DD34: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8238DD38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238DD3C: 4BFE6665  bl 0x823743a0
	ctx.lr = 0x8238DD40;
	sub_823743A0(ctx, base);
	// 8238DD40: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DD44: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8238DD48: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 8238DD4C: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DD50: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238DD54: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8238DD58: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 8238DD5C: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DD60: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8238DD64: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8238DD68: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 8238DD6C: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DD70: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8238DD74: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DD78: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 8238DD7C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8238DD80: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DD84: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8238DD88: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DD8C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8238DD90: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DD94: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8238DD98: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DD9C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238DDA0: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DDA4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238DDA8: C01F0028  lfs f0, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DDAC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238DDB0: C01F002C  lfs f0, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DDB4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238DDB8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238DF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238DF48 size=440
    let mut pc: u32 = 0x8238DF48;
    'dispatch: loop {
        match pc {
            0x8238DF48 => {
    //   block [0x8238DF48..0x8238E100)
	// 8238DF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238DF4C: 481A716D  bl 0x825350b8
	ctx.lr = 0x8238DF50;
	sub_82535080(ctx, base);
	// 8238DF50: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8238DF54: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238DF58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8238DF5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8238DF60: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8238DF64: C07F0018  lfs f3, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8238DF68: C05F0014  lfs f2, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8238DF6C: C03F0010  lfs f1, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8238DF70: 4BFDA2A9  bl 0x82368218
	ctx.lr = 0x8238DF74;
	sub_82368218(ctx, base);
	// 8238DF74: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8238DF78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8238DF7C: 4BFE6425  bl 0x823743a0
	ctx.lr = 0x8238DF80;
	sub_823743A0(ctx, base);
	// 8238DF80: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DF84: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8238DF88: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238DF8C: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DF90: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 8238DF94: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8238DF98: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8238DF9C: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DFA0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8238DFA4: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8238DFA8: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DFAC: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8238DFB0: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 8238DFB4: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DFB8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238DFBC: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DFC0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238DFC4: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DFC8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238DFCC: C001006C  lfs f0, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238DFD0: C3FF0020  lfs f31, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8238DFD4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238DFD8: 480D6061  bl 0x82464038
	ctx.lr = 0x8238DFDC;
	sub_82464038(ctx, base);
	// 8238DFDC: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 8238DFE0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8238DFE4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 8238DFE8: 4816CB89  bl 0x824fab70
	ctx.lr = 0x8238DFEC;
	sub_824FAB70(ctx, base);
	// 8238DFEC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8238DFF0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8238DFF4: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8238DFF8: 48103F01  bl 0x82491ef8
	ctx.lr = 0x8238DFFC;
	sub_82491EF8(ctx, base);
	// 8238DFFC: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 8238E000: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238E004: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8238E008: C01F0044  lfs f0, 0x44(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238E00C: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 8238E010: D001016C  stfs f0, 0x16c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 8238E014: C01F0040  lfs f0, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238E018: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8238E01C: C05F0048  lfs f2, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8238E020: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238E100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238E100 size=44
    let mut pc: u32 = 0x8238E100;
    'dispatch: loop {
        match pc {
            0x8238E100 => {
    //   block [0x8238E100..0x8238E12C)
	// 8238E100: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238E104: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238E108: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 8238E10C: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238E110: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238E114: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8238E118: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8238E11C: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8238E120: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238E124: D1A4000C  stfs f13, 0xc(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8238E128: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238E130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238E130 size=136
    let mut pc: u32 = 0x8238E130;
    'dispatch: loop {
        match pc {
            0x8238E130 => {
    //   block [0x8238E130..0x8238E1B8)
	// 8238E130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238E134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238E138: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238E13C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238E140: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238E144: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238E148: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238E14C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8238E150: 48103DA9  bl 0x82491ef8
	ctx.lr = 0x8238E154;
	sub_82491EF8(ctx, base);
	// 8238E154: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8238E158: 807E005C  lwz r3, 0x5c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 8238E15C: 48102B6D  bl 0x82490cc8
	ctx.lr = 0x8238E160;
	sub_82490CC8(ctx, base);
	// 8238E160: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238E164: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8238E168: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 8238E16C: 38800200  li r4, 0x200
	ctx.r[4].s64 = 512;
	// 8238E170: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8238E174: 480D5EC5  bl 0x82464038
	ctx.lr = 0x8238E178;
	sub_82464038(ctx, base);
	// 8238E178: 39600200  li r11, 0x200
	ctx.r[11].s64 = 512;
	// 8238E17C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8238E180: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 8238E184: 48101E95  bl 0x82490018
	ctx.lr = 0x8238E188;
	sub_82490018(ctx, base);
	// 8238E188: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8238E18C: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8238E190: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8238E194: 817E005C  lwz r11, 0x5c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 8238E198: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8238E19C: 91630070  stw r11, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8238E1A0: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 8238E1A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238E1A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238E1AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238E1B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238E1B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238E1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238E1B8 size=556
    let mut pc: u32 = 0x8238E1B8;
    'dispatch: loop {
        match pc {
            0x8238E1B8 => {
    //   block [0x8238E1B8..0x8238E238)
	// 8238E1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238E1BC: 481A6F01  bl 0x825350bc
	ctx.lr = 0x8238E1C0;
	sub_82535080(ctx, base);
	// 8238E1C0: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 8238E1C4: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 8238E1C8: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8238E1CC: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238E1D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8238E1D4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8238E1D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8238E1DC: 4BFFFAB5  bl 0x8238dc90
	ctx.lr = 0x8238E1E0;
	sub_8238DC90(ctx, base);
	// 8238E1E0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238E1E4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8238E1E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8238E1EC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238E1F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238E1F4: 4E800421  bctrl
	ctx.lr = 0x8238E1F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238E1F8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238E1FC: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238E200: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238E204: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8238E208: 419A01B8  beq cr6, 0x8238e3c0
	if ctx.cr[6].eq {
	pc = 0x8238E3C0; continue 'dispatch;
	}
	// 8238E20C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 8238E210: 419A0160  beq cr6, 0x8238e370
	if ctx.cr[6].eq {
	pc = 0x8238E370; continue 'dispatch;
	}
	// 8238E214: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 8238E218: 419A0020  beq cr6, 0x8238e238
	if ctx.cr[6].eq {
	pc = 0x8238E238; continue 'dispatch;
	}
	// 8238E21C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8238E220: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8238E224: C00BD4DC  lfs f0, -0x2b24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238E228: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238E22C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238E230: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238E234: 48000174  b 0x8238e3a8
	pc = 0x8238E3A8; continue 'dispatch;
            }
            0x8238E238 => {
    //   block [0x8238E238..0x8238E344)
	// 8238E238: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8238E23C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 8238E240: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8238E244: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 8238E248: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 8238E24C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8238E250: 4816DD79  bl 0x824fbfc8
	ctx.lr = 0x8238E254;
	sub_824FBFC8(ctx, base);
	// 8238E254: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8238E258: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 8238E25C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238E260: 409900E4  ble cr6, 0x8238e344
	if !ctx.cr[6].gt {
	pc = 0x8238E344; continue 'dispatch;
	}
	// 8238E264: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8238E268: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8238E26C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238E270: C3E9BA38  lfs f31, -0x45c8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8238E274: C3AA1FF8  lfs f29, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8238E278: C3CB2090  lfs f30, 0x2090(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8336 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8238E27C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8238E280: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238E284: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8238E288: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8238E28C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 8238E290: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 8238E294: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8238E298: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8238E29C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8238E2A0: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238E2A4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 8238E2A8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238E2AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238E2B0: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238E2B4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238E2B8: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238E2BC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238E2C0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	pc = 0x8238E344; continue 'dispatch;
            }
            0x8238E344 => {
    //   block [0x8238E344..0x8238E370)
	// 8238E344: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8238E348: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8238E34C: 40820084  bne 0x8238e3d0
	if !ctx.cr[0].eq {
	pc = 0x8238E3D0; continue 'dispatch;
	}
	// 8238E350: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238E354: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8238E358: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 8238E35C: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8238E360: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8238E364: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8238E368: 480D5D51  bl 0x824640b8
	ctx.lr = 0x8238E36C;
	sub_824640B8(ctx, base);
	// 8238E36C: 48000064  b 0x8238e3d0
	pc = 0x8238E3D0; continue 'dispatch;
            }
            0x8238E370 => {
    //   block [0x8238E370..0x8238E3A8)
	// 8238E370: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238E374: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8238E378: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8238E37C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238E380: 4E800421  bctrl
	ctx.lr = 0x8238E384;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238E384: C0010080  lfs f0, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238E388: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8238E38C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8238E390: C0010084  lfs f0, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238E394: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8238E398: C0010088  lfs f0, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238E39C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8238E3A0: C001008C  lfs f0, 0x8c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238E3A4: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
            }
            0x8238E3A8 => {
    //   block [0x8238E3A8..0x8238E3C0)
	// 8238E3A8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8238E3AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8238E3B0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8238E3B4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 8238E3B8: 4BFFF049  bl 0x8238d400
	ctx.lr = 0x8238E3BC;
	sub_8238D400(ctx, base);
	// 8238E3BC: 48000014  b 0x8238e3d0
	pc = 0x8238E3D0; continue 'dispatch;
            }
            0x8238E3C0 => {
    //   block [0x8238E3C0..0x8238E3E4)
	// 8238E3C0: C0230010  lfs f1, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8238E3C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8238E3C8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8238E3CC: 4BFFEF1D  bl 0x8238d2e8
	ctx.lr = 0x8238E3D0;
	sub_8238D2E8(ctx, base);
	// 8238E3D0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 8238E3D4: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8238E3D8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8238E3DC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8238E3E0: 481A6D2C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238E3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238E3E8 size=76
    let mut pc: u32 = 0x8238E3E8;
    'dispatch: loop {
        match pc {
            0x8238E3E8 => {
    //   block [0x8238E3E8..0x8238E418)
	// 8238E3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238E3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238E3F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238E3F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238E3F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238E3FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238E400: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8238E404: 48000035  bl 0x8238e438
	ctx.lr = 0x8238E408;
	sub_8238E438(ctx, base);
	// 8238E408: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238E40C: 4182000C  beq 0x8238e418
	if ctx.cr[0].eq {
	pc = 0x8238E418; continue 'dispatch;
	}
	// 8238E410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238E414: 481A47A5  bl 0x82532bb8
	ctx.lr = 0x8238E418;
	sub_82532BB8(ctx, base);
	pc = 0x8238E418; continue 'dispatch;
            }
            0x8238E418 => {
    //   block [0x8238E418..0x8238E434)
	// 8238E418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238E41C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238E420: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238E424: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238E428: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238E42C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238E430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238E438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238E438 size=172
    let mut pc: u32 = 0x8238E438;
    'dispatch: loop {
        match pc {
            0x8238E438 => {
    //   block [0x8238E438..0x8238E498)
	// 8238E438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238E43C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238E440: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238E444: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238E448: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238E44C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238E450: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8238E454: 396B02D0  addi r11, r11, 0x2d0
	ctx.r[11].s64 = ctx.r[11].s64 + 720;
	// 8238E458: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238E45C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8238E460: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238E464: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238E468: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238E46C: 4182002C  beq 0x8238e498
	if ctx.cr[0].eq {
	pc = 0x8238E498; continue 'dispatch;
	}
	// 8238E470: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8238E474: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238E478: 7D6B0735  extsh. r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238E47C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 8238E480: 40820018  bne 0x8238e498
	if !ctx.cr[0].eq {
	pc = 0x8238E498; continue 'dispatch;
	}
	// 8238E484: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238E488: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8238E48C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238E490: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238E494: 4E800421  bctrl
	ctx.lr = 0x8238E498;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8238E498 => {
    //   block [0x8238E498..0x8238E4D0)
	// 8238E498: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238E49C: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238E4A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238E4A4: 4182002C  beq 0x8238e4d0
	if ctx.cr[0].eq {
	pc = 0x8238E4D0; continue 'dispatch;
	}
	// 8238E4A8: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8238E4AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238E4B0: 7D6B0735  extsh. r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238E4B4: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 8238E4B8: 40820018  bne 0x8238e4d0
	if !ctx.cr[0].eq {
	pc = 0x8238E4D0; continue 'dispatch;
	}
	// 8238E4BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238E4C0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8238E4C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238E4C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238E4CC: 4E800421  bctrl
	ctx.lr = 0x8238E4D0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8238E4D0 => {
    //   block [0x8238E4D0..0x8238E4E4)
	// 8238E4D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8238E4D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238E4D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238E4DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238E4E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238E4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238E4E8 size=204
    let mut pc: u32 = 0x8238E4E8;
    'dispatch: loop {
        match pc {
            0x8238E4E8 => {
    //   block [0x8238E4E8..0x8238E550)
	// 8238E4E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238E4EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238E4F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238E4F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238E4F8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238E4FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238E500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238E504: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8238E508: 480E3C11  bl 0x82472118
	ctx.lr = 0x8238E50C;
	sub_82472118(ctx, base);
	// 8238E50C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238E510: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238E514: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238E518: 480E5639  bl 0x82473b50
	ctx.lr = 0x8238E51C;
	sub_82473B50(ctx, base);
	// 8238E51C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8238E520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238E524: 808B92F0  lwz r4, -0x6d10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27920 as u32) ) } as u64;
	// 8238E528: 480E9239  bl 0x82477760
	ctx.lr = 0x8238E52C;
	sub_82477760(ctx, base);
	// 8238E52C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238E530: 480E2F11  bl 0x82471440
	ctx.lr = 0x8238E534;
	sub_82471440(ctx, base);
	// 8238E534: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8238E538: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238E53C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238E540: 41820010  beq 0x8238e550
	if ctx.cr[0].eq {
	pc = 0x8238E550; continue 'dispatch;
	}
	// 8238E544: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8238E548: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8238E54C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x8238E550; continue 'dispatch;
            }
            0x8238E550 => {
    //   block [0x8238E550..0x8238E5B4)
	// 8238E550: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8238E554: 386B9244  addi r3, r11, -0x6dbc
	ctx.r[3].s64 = ctx.r[11].s64 + -28092;
	// 8238E558: 480D8301  bl 0x82466858
	ctx.lr = 0x8238E55C;
	sub_82466858(ctx, base);
	// 8238E55C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8238E560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238E564: 480E6335  bl 0x82474898
	ctx.lr = 0x8238E568;
	sub_82474898(ctx, base);
	// 8238E568: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8238E56C: 3D60829A  lis r11, -0x7d66
	ctx.r[11].s64 = -2103836672;
	// 8238E570: 386B14F8  addi r3, r11, 0x14f8
	ctx.r[3].s64 = ctx.r[11].s64 + 5368;
	// 8238E574: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8238E578: 480D82E1  bl 0x82466858
	ctx.lr = 0x8238E57C;
	sub_82466858(ctx, base);
	// 8238E57C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8238E580: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238E584: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8238E588: 480EC1F1  bl 0x8247a778
	ctx.lr = 0x8238E58C;
	sub_8247A778(ctx, base);
	// 8238E58C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8238E590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238E594: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8238E598: 480E3C41  bl 0x824721d8
	ctx.lr = 0x8238E59C;
	sub_824721D8(ctx, base);
	// 8238E59C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 8238E5A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238E5A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238E5A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238E5AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238E5B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238E5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238E5B8 size=224
    let mut pc: u32 = 0x8238E5B8;
    'dispatch: loop {
        match pc {
            0x8238E5B8 => {
    //   block [0x8238E5B8..0x8238E5F0)
	// 8238E5B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238E5BC: 481A6AE1  bl 0x8253509c
	ctx.lr = 0x8238E5C0;
	sub_82535080(ctx, base);
	// 8238E5C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238E5C4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8238E5C8: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 8238E5CC: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 8238E5D0: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 8238E5D4: 8379000C  lwz r27, 0xc(r25)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238E5D8: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238E5DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238E5E0: 409900AC  ble cr6, 0x8238e68c
	if !ctx.cr[6].gt {
	pc = 0x8238E68C; continue 'dispatch;
	}
	// 8238E5E4: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8238E5E8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8238E5EC: 3AEB9684  addi r23, r11, -0x697c
	ctx.r[23].s64 = ctx.r[11].s64 + -27004;
	pc = 0x8238E5F0; continue 'dispatch;
            }
            0x8238E5F0 => {
    //   block [0x8238E5F0..0x8238E60C)
	// 8238E5F0: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238E5F4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8238E5F8: 7FDA582E  lwzx r30, r26, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8238E5FC: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238E600: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238E604: 40990074  ble cr6, 0x8238e678
	if !ctx.cr[6].gt {
	pc = 0x8238E678; continue 'dispatch;
	}
	// 8238E608: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8238E60C; continue 'dispatch;
            }
            0x8238E60C => {
    //   block [0x8238E60C..0x8238E644)
	// 8238E60C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238E610: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 8238E614: 83EB0070  lwz r31, 0x70(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8238E618: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238E61C: 41820028  beq 0x8238e644
	if ctx.cr[0].eq {
	pc = 0x8238E644; continue 'dispatch;
	}
	// 8238E620: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 8238E624: 480D8235  bl 0x82466858
	ctx.lr = 0x8238E628;
	sub_82466858(ctx, base);
	// 8238E628: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8238E62C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8238E630: 80790008  lwz r3, 8(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238E634: 480EC145  bl 0x8247a778
	ctx.lr = 0x8238E638;
	sub_8247A778(ctx, base);
	// 8238E638: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8238E63C: 480F1FED  bl 0x82480628
	ctx.lr = 0x8238E640;
	sub_82480628(ctx, base);
	// 8238E640: 48000008  b 0x8238e648
	pc = 0x8238E648; continue 'dispatch;
            }
            0x8238E644 => {
    //   block [0x8238E644..0x8238E648)
	// 8238E644: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8238E648; continue 'dispatch;
            }
            0x8238E648 => {
    //   block [0x8238E648..0x8238E664)
	// 8238E648: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8238E64C: 419A0018  beq cr6, 0x8238e664
	if ctx.cr[6].eq {
	pc = 0x8238E664; continue 'dispatch;
	}
	// 8238E650: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 8238E654: 480F1D0D  bl 0x82480360
	ctx.lr = 0x8238E658;
	sub_82480360(ctx, base);
	// 8238E658: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238E65C: 41820008  beq 0x8238e664
	if ctx.cr[0].eq {
	pc = 0x8238E664; continue 'dispatch;
	}
	// 8238E660: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	pc = 0x8238E664; continue 'dispatch;
            }
            0x8238E664 => {
    //   block [0x8238E664..0x8238E678)
	// 8238E664: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238E668: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 8238E66C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8238E670: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8238E674: 4198FF98  blt cr6, 0x8238e60c
	if ctx.cr[6].lt {
	pc = 0x8238E60C; continue 'dispatch;
	}
	pc = 0x8238E678; continue 'dispatch;
            }
            0x8238E678 => {
    //   block [0x8238E678..0x8238E68C)
	// 8238E678: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238E67C: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 8238E680: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 8238E684: 7F185800  cmpw cr6, r24, r11
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8238E688: 4198FF68  blt cr6, 0x8238e5f0
	if ctx.cr[6].lt {
	pc = 0x8238E5F0; continue 'dispatch;
	}
	pc = 0x8238E68C; continue 'dispatch;
            }
            0x8238E68C => {
    //   block [0x8238E68C..0x8238E698)
	// 8238E68C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 8238E690: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8238E694: 481A6A58  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238E698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238E698 size=412
    let mut pc: u32 = 0x8238E698;
    'dispatch: loop {
        match pc {
            0x8238E698 => {
    //   block [0x8238E698..0x8238E6FC)
	// 8238E698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238E69C: 481A69F5  bl 0x82535090
	ctx.lr = 0x8238E6A0;
	sub_82535080(ctx, base);
	// 8238E6A0: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 8238E6A4: 481A7945  bl 0x82535fe8
	ctx.lr = 0x8238E6A8;
	sub_82535FB0(ctx, base);
	// 8238E6A8: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238E6AC: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 8238E6B0: 7C922378  mr r18, r4
	ctx.r[18].u64 = ctx.r[4].u64;
	// 8238E6B4: 7CB32B78  mr r19, r5
	ctx.r[19].u64 = ctx.r[5].u64;
	// 8238E6B8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8238E6BC: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 8238E6C0: 8316000C  lwz r24, 0xc(r22)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238E6C4: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238E6C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238E6CC: 40990154  ble cr6, 0x8238e820
	if !ctx.cr[6].gt {
	pc = 0x8238E820; continue 'dispatch;
	}
	// 8238E6D0: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 8238E6D4: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 8238E6D8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8238E6DC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8238E6E0: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8238E6E4: C3C7BA38  lfs f30, -0x45c8(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8238E6E8: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 8238E6EC: C388D218  lfs f28, -0x2de8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8238E6F0: 3AEB9684  addi r23, r11, -0x697c
	ctx.r[23].s64 = ctx.r[11].s64 + -27004;
	// 8238E6F4: C3A9BFFC  lfs f29, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8238E6F8: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x8238E6FC; continue 'dispatch;
            }
            0x8238E6FC => {
    //   block [0x8238E6FC..0x8238E720)
	// 8238E6FC: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238E700: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8238E704: 7F75582E  lwzx r27, r21, r11
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8238E708: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238E70C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238E710: 409900FC  ble cr6, 0x8238e80c
	if !ctx.cr[6].gt {
	pc = 0x8238E80C; continue 'dispatch;
	}
	// 8238E714: 572B103A  slwi r11, r25, 2
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8238E718: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8238E71C: 7F8B9A14  add r28, r11, r19
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	pc = 0x8238E720; continue 'dispatch;
            }
            0x8238E720 => {
    //   block [0x8238E720..0x8238E758)
	// 8238E720: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238E724: 7FABF02E  lwzx r29, r11, r30
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8238E728: 83FD0070  lwz r31, 0x70(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 8238E72C: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238E730: 41820028  beq 0x8238e758
	if ctx.cr[0].eq {
	pc = 0x8238E758; continue 'dispatch;
	}
	// 8238E734: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 8238E738: 480D8121  bl 0x82466858
	ctx.lr = 0x8238E73C;
	sub_82466858(ctx, base);
	// 8238E73C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8238E740: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8238E744: 80760008  lwz r3, 8(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238E748: 480EC031  bl 0x8247a778
	ctx.lr = 0x8238E74C;
	sub_8247A778(ctx, base);
	// 8238E74C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8238E750: 480F1ED9  bl 0x82480628
	ctx.lr = 0x8238E754;
	sub_82480628(ctx, base);
	// 8238E754: 48000008  b 0x8238e75c
	pc = 0x8238E75C; continue 'dispatch;
            }
            0x8238E758 => {
    //   block [0x8238E758..0x8238E75C)
	// 8238E758: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8238E75C; continue 'dispatch;
            }
            0x8238E75C => {
    //   block [0x8238E75C..0x8238E7F8)
	// 8238E75C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8238E760: 419A0098  beq cr6, 0x8238e7f8
	if ctx.cr[6].eq {
	pc = 0x8238E7F8; continue 'dispatch;
	}
	// 8238E764: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 8238E768: 480F1BF9  bl 0x82480360
	ctx.lr = 0x8238E76C;
	sub_82480360(ctx, base);
	// 8238E76C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238E770: 41820088  beq 0x8238e7f8
	if ctx.cr[0].eq {
	pc = 0x8238E7F8; continue 'dispatch;
	}
	// 8238E774: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8238E778: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238E77C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238E780: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238E784: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238E788: 93A100AC  stw r29, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[29].u32 ) };
	// 8238E78C: D3C1005C  stfs f30, 0x5c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238E790: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8238E794: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 8238E798: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 8238E79C: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8238E7A0: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8238E7A4: D3C1006C  stfs f30, 0x6c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8238E7A8: D3C10070  stfs f30, 0x70(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8238E7AC: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 8238E7B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8238E7B4: D3C10074  stfs f30, 0x74(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8238E7B8: D3C10078  stfs f30, 0x78(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8238E7BC: D3C1007C  stfs f30, 0x7c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8238E7C0: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8238E7C4: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 8238E7C8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8238E7CC: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8238E7D0: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8238E7D4: D3C1008C  stfs f30, 0x8c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8238E7D8: D3C10098  stfs f30, 0x98(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8238E7DC: D3A10094  stfs f29, 0x94(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8238E7E0: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 8238E7E4: D3810090  stfs f28, 0x90(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8238E7E8: 4BFFE691  bl 0x8238ce78
	ctx.lr = 0x8238E7EC;
	sub_8238CE78(ctx, base);
	// 8238E7EC: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 8238E7F0: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 8238E7F4: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	pc = 0x8238E7F8; continue 'dispatch;
            }
            0x8238E7F8 => {
    //   block [0x8238E7F8..0x8238E80C)
	// 8238E7F8: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238E7FC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 8238E800: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 8238E804: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8238E808: 4198FF18  blt cr6, 0x8238e720
	if ctx.cr[6].lt {
	pc = 0x8238E720; continue 'dispatch;
	}
	pc = 0x8238E80C; continue 'dispatch;
            }
            0x8238E80C => {
    //   block [0x8238E80C..0x8238E820)
	// 8238E80C: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238E810: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 8238E814: 3AB50004  addi r21, r21, 4
	ctx.r[21].s64 = ctx.r[21].s64 + 4;
	// 8238E818: 7F145800  cmpw cr6, r20, r11
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8238E81C: 4198FEE0  blt cr6, 0x8238e6fc
	if ctx.cr[6].lt {
	pc = 0x8238E6FC; continue 'dispatch;
	}
	pc = 0x8238E820; continue 'dispatch;
            }
            0x8238E820 => {
    //   block [0x8238E820..0x8238E834)
	// 8238E820: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8238E824: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 8238E828: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 8238E82C: 481A7809  bl 0x82536034
	ctx.lr = 0x8238E830;
	sub_82535FFC(ctx, base);
	// 8238E830: 481A68B0  b 0x825350e0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238E838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238E838 size=224
    let mut pc: u32 = 0x8238E838;
    'dispatch: loop {
        match pc {
            0x8238E838 => {
    //   block [0x8238E838..0x8238E870)
	// 8238E838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238E83C: 481A6861  bl 0x8253509c
	ctx.lr = 0x8238E840;
	sub_82535080(ctx, base);
	// 8238E840: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238E844: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8238E848: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 8238E84C: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 8238E850: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 8238E854: 8379000C  lwz r27, 0xc(r25)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238E858: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238E85C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238E860: 409900AC  ble cr6, 0x8238e90c
	if !ctx.cr[6].gt {
	pc = 0x8238E90C; continue 'dispatch;
	}
	// 8238E864: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8238E868: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8238E86C: 3AEB9684  addi r23, r11, -0x697c
	ctx.r[23].s64 = ctx.r[11].s64 + -27004;
	pc = 0x8238E870; continue 'dispatch;
            }
            0x8238E870 => {
    //   block [0x8238E870..0x8238E88C)
	// 8238E870: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238E874: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8238E878: 7FDA582E  lwzx r30, r26, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8238E87C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8238E880: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238E884: 40990074  ble cr6, 0x8238e8f8
	if !ctx.cr[6].gt {
	pc = 0x8238E8F8; continue 'dispatch;
	}
	// 8238E888: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8238E88C; continue 'dispatch;
            }
            0x8238E88C => {
    //   block [0x8238E88C..0x8238E8C4)
	// 8238E88C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8238E890: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 8238E894: 83EB0020  lwz r31, 0x20(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8238E898: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238E89C: 41820028  beq 0x8238e8c4
	if ctx.cr[0].eq {
	pc = 0x8238E8C4; continue 'dispatch;
	}
	// 8238E8A0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 8238E8A4: 480D7FB5  bl 0x82466858
	ctx.lr = 0x8238E8A8;
	sub_82466858(ctx, base);
	// 8238E8A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8238E8AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8238E8B0: 80790008  lwz r3, 8(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238E8B4: 480EBEC5  bl 0x8247a778
	ctx.lr = 0x8238E8B8;
	sub_8247A778(ctx, base);
	// 8238E8B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8238E8BC: 480F1D6D  bl 0x82480628
	ctx.lr = 0x8238E8C0;
	sub_82480628(ctx, base);
	// 8238E8C0: 48000008  b 0x8238e8c8
	pc = 0x8238E8C8; continue 'dispatch;
            }
            0x8238E8C4 => {
    //   block [0x8238E8C4..0x8238E8C8)
	// 8238E8C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8238E8C8; continue 'dispatch;
            }
            0x8238E8C8 => {
    //   block [0x8238E8C8..0x8238E8E4)
	// 8238E8C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8238E8CC: 419A0018  beq cr6, 0x8238e8e4
	if ctx.cr[6].eq {
	pc = 0x8238E8E4; continue 'dispatch;
	}
	// 8238E8D0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 8238E8D4: 480F1A8D  bl 0x82480360
	ctx.lr = 0x8238E8D8;
	sub_82480360(ctx, base);
	// 8238E8D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238E8DC: 41820008  beq 0x8238e8e4
	if ctx.cr[0].eq {
	pc = 0x8238E8E4; continue 'dispatch;
	}
	// 8238E8E0: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	pc = 0x8238E8E4; continue 'dispatch;
            }
            0x8238E8E4 => {
    //   block [0x8238E8E4..0x8238E8F8)
	// 8238E8E4: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8238E8E8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 8238E8EC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8238E8F0: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8238E8F4: 4198FF98  blt cr6, 0x8238e88c
	if ctx.cr[6].lt {
	pc = 0x8238E88C; continue 'dispatch;
	}
	pc = 0x8238E8F8; continue 'dispatch;
            }
            0x8238E8F8 => {
    //   block [0x8238E8F8..0x8238E90C)
	// 8238E8F8: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238E8FC: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 8238E900: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 8238E904: 7F185800  cmpw cr6, r24, r11
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8238E908: 4198FF68  blt cr6, 0x8238e870
	if ctx.cr[6].lt {
	pc = 0x8238E870; continue 'dispatch;
	}
	pc = 0x8238E90C; continue 'dispatch;
            }
            0x8238E90C => {
    //   block [0x8238E90C..0x8238E918)
	// 8238E90C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 8238E910: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8238E914: 481A67D8  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238E918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238E918 size=300
    let mut pc: u32 = 0x8238E918;
    'dispatch: loop {
        match pc {
            0x8238E918 => {
    //   block [0x8238E918..0x8238E960)
	// 8238E918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238E91C: 481A676D  bl 0x82535088
	ctx.lr = 0x8238E920;
	sub_82535080(ctx, base);
	// 8238E920: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238E924: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 8238E928: 7C902378  mr r16, r4
	ctx.r[16].u64 = ctx.r[4].u64;
	// 8238E92C: 7CB32B78  mr r19, r5
	ctx.r[19].u64 = ctx.r[5].u64;
	// 8238E930: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8238E934: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 8238E938: 8317000C  lwz r24, 0xc(r23)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238E93C: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238E940: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238E944: 409900F4  ble cr6, 0x8238ea38
	if !ctx.cr[6].gt {
	pc = 0x8238EA38; continue 'dispatch;
	}
	// 8238E948: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238E94C: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 8238E950: 3A4B0290  addi r18, r11, 0x290
	ctx.r[18].s64 = ctx.r[11].s64 + 656;
	// 8238E954: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8238E958: 3E208273  lis r17, -0x7d8d
	ctx.r[17].s64 = -2106392576;
	// 8238E95C: 3AAB9684  addi r21, r11, -0x697c
	ctx.r[21].s64 = ctx.r[11].s64 + -27004;
	pc = 0x8238E960; continue 'dispatch;
            }
            0x8238E960 => {
    //   block [0x8238E960..0x8238E984)
	// 8238E960: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238E964: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8238E968: 7F76582E  lwzx r27, r22, r11
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8238E96C: 817B0018  lwz r11, 0x18(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 8238E970: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238E974: 409900B0  ble cr6, 0x8238ea24
	if !ctx.cr[6].gt {
	pc = 0x8238EA24; continue 'dispatch;
	}
	// 8238E978: 572B103A  slwi r11, r25, 2
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8238E97C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8238E980: 7F8B9A14  add r28, r11, r19
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	pc = 0x8238E984; continue 'dispatch;
            }
            0x8238E984 => {
    //   block [0x8238E984..0x8238E9BC)
	// 8238E984: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8238E988: 7FABF02E  lwzx r29, r11, r30
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8238E98C: 83FD0020  lwz r31, 0x20(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 8238E990: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238E994: 41820028  beq 0x8238e9bc
	if ctx.cr[0].eq {
	pc = 0x8238E9BC; continue 'dispatch;
	}
	// 8238E998: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 8238E99C: 480D7EBD  bl 0x82466858
	ctx.lr = 0x8238E9A0;
	sub_82466858(ctx, base);
	// 8238E9A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8238E9A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8238E9A8: 80770008  lwz r3, 8(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238E9AC: 480EBDCD  bl 0x8247a778
	ctx.lr = 0x8238E9B0;
	sub_8247A778(ctx, base);
	// 8238E9B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8238E9B4: 480F1C75  bl 0x82480628
	ctx.lr = 0x8238E9B8;
	sub_82480628(ctx, base);
	// 8238E9B8: 48000008  b 0x8238e9c0
	pc = 0x8238E9C0; continue 'dispatch;
            }
            0x8238E9BC => {
    //   block [0x8238E9BC..0x8238E9C0)
	// 8238E9BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8238E9C0; continue 'dispatch;
            }
            0x8238E9C0 => {
    //   block [0x8238E9C0..0x8238E9FC)
	// 8238E9C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8238E9C4: 419A004C  beq cr6, 0x8238ea10
	if ctx.cr[6].eq {
	pc = 0x8238EA10; continue 'dispatch;
	}
	// 8238E9C8: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 8238E9CC: 480F1995  bl 0x82480360
	ctx.lr = 0x8238E9D0;
	sub_82480360(ctx, base);
	// 8238E9D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238E9D4: 4182003C  beq 0x8238ea10
	if ctx.cr[0].eq {
	pc = 0x8238EA10; continue 'dispatch;
	}
	// 8238E9D8: 817149AC  lwz r11, 0x49ac(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(18860 as u32) ) } as u64;
	// 8238E9DC: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 8238E9E0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8238E9E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238E9E8: 4E800421  bctrl
	ctx.lr = 0x8238E9EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238E9EC: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238E9F0: 4182000C  beq 0x8238e9fc
	if ctx.cr[0].eq {
	pc = 0x8238E9FC; continue 'dispatch;
	}
	// 8238E9F4: 924B0000  stw r18, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[18].u32 ) };
	// 8238E9F8: 48000008  b 0x8238ea00
	pc = 0x8238EA00; continue 'dispatch;
            }
            0x8238E9FC => {
    //   block [0x8238E9FC..0x8238EA00)
	// 8238E9FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8238EA00; continue 'dispatch;
            }
            0x8238EA00 => {
    //   block [0x8238EA00..0x8238EA10)
	// 8238EA00: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8238EA04: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 8238EA08: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238EA0C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	pc = 0x8238EA10; continue 'dispatch;
            }
            0x8238EA10 => {
    //   block [0x8238EA10..0x8238EA24)
	// 8238EA10: 817B0018  lwz r11, 0x18(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 8238EA14: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 8238EA18: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 8238EA1C: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8238EA20: 4198FF64  blt cr6, 0x8238e984
	if ctx.cr[6].lt {
	pc = 0x8238E984; continue 'dispatch;
	}
	pc = 0x8238EA24; continue 'dispatch;
            }
            0x8238EA24 => {
    //   block [0x8238EA24..0x8238EA38)
	// 8238EA24: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238EA28: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 8238EA2C: 3AD60004  addi r22, r22, 4
	ctx.r[22].s64 = ctx.r[22].s64 + 4;
	// 8238EA30: 7F145800  cmpw cr6, r20, r11
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8238EA34: 4198FF2C  blt cr6, 0x8238e960
	if ctx.cr[6].lt {
	pc = 0x8238E960; continue 'dispatch;
	}
	pc = 0x8238EA38; continue 'dispatch;
            }
            0x8238EA38 => {
    //   block [0x8238EA38..0x8238EA44)
	// 8238EA38: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8238EA3C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8238EA40: 481A6698  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238EA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238EA48 size=124
    let mut pc: u32 = 0x8238EA48;
    'dispatch: loop {
        match pc {
            0x8238EA48 => {
    //   block [0x8238EA48..0x8238EAA8)
	// 8238EA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238EA4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238EA50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238EA54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238EA58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238EA5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238EA60: 396B0290  addi r11, r11, 0x290
	ctx.r[11].s64 = ctx.r[11].s64 + 656;
	// 8238EA64: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238EA68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238EA6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238EA70: 41820040  beq 0x8238eab0
	if ctx.cr[0].eq {
	pc = 0x8238EAB0; continue 'dispatch;
	}
	// 8238EA74: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238EA78: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238EA7C: 4182002C  beq 0x8238eaa8
	if ctx.cr[0].eq {
	pc = 0x8238EAA8; continue 'dispatch;
	}
	// 8238EA80: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8238EA84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238EA88: 7D6B0735  extsh. r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238EA8C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 8238EA90: 40820018  bne 0x8238eaa8
	if !ctx.cr[0].eq {
	pc = 0x8238EAA8; continue 'dispatch;
	}
	// 8238EA94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238EA98: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8238EA9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238EAA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238EAA4: 4E800421  bctrl
	ctx.lr = 0x8238EAA8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8238EAA8 => {
    //   block [0x8238EAA8..0x8238EAB0)
	// 8238EAA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8238EAAC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x8238EAB0; continue 'dispatch;
            }
            0x8238EAB0 => {
    //   block [0x8238EAB0..0x8238EAC4)
	// 8238EAB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8238EAB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238EAB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238EABC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238EAC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238EAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238EAC8 size=188
    let mut pc: u32 = 0x8238EAC8;
    'dispatch: loop {
        match pc {
            0x8238EAC8 => {
    //   block [0x8238EAC8..0x8238EB44)
	// 8238EAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238EACC: 481A65E9  bl 0x825350b4
	ctx.lr = 0x8238EAD0;
	sub_82535080(ctx, base);
	// 8238EAD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238EAD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8238EAD8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8238EADC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8238EAE0: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 8238EAE4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8238EAE8: 419A0090  beq cr6, 0x8238eb78
	if ctx.cr[6].eq {
	pc = 0x8238EB78; continue 'dispatch;
	}
	// 8238EAEC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8238EAF0: 419A0088  beq cr6, 0x8238eb78
	if ctx.cr[6].eq {
	pc = 0x8238EB78; continue 'dispatch;
	}
	// 8238EAF4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8238EAF8: 419A0080  beq cr6, 0x8238eb78
	if ctx.cr[6].eq {
	pc = 0x8238EB78; continue 'dispatch;
	}
	// 8238EAFC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8238EB00: 419A0078  beq cr6, 0x8238eb78
	if ctx.cr[6].eq {
	pc = 0x8238EB78; continue 'dispatch;
	}
	// 8238EB04: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238EB08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238EB0C: 41820038  beq 0x8238eb44
	if ctx.cr[0].eq {
	pc = 0x8238EB44; continue 'dispatch;
	}
	// 8238EB10: 83EB0070  lwz r31, 0x70(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8238EB14: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238EB18: 4182002C  beq 0x8238eb44
	if ctx.cr[0].eq {
	pc = 0x8238EB44; continue 'dispatch;
	}
	// 8238EB1C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8238EB20: 386B9684  addi r3, r11, -0x697c
	ctx.r[3].s64 = ctx.r[11].s64 + -27004;
	// 8238EB24: 480D7D35  bl 0x82466858
	ctx.lr = 0x8238EB28;
	sub_82466858(ctx, base);
	// 8238EB28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8238EB2C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8238EB30: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238EB34: 480EBC45  bl 0x8247a778
	ctx.lr = 0x8238EB38;
	sub_8247A778(ctx, base);
	// 8238EB38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8238EB3C: 480F1AED  bl 0x82480628
	ctx.lr = 0x8238EB40;
	sub_82480628(ctx, base);
	// 8238EB40: 48000008  b 0x8238eb48
	pc = 0x8238EB48; continue 'dispatch;
            }
            0x8238EB44 => {
    //   block [0x8238EB44..0x8238EB48)
	// 8238EB44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8238EB48; continue 'dispatch;
            }
            0x8238EB48 => {
    //   block [0x8238EB48..0x8238EB78)
	// 8238EB48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8238EB4C: 419A002C  beq cr6, 0x8238eb78
	if ctx.cr[6].eq {
	pc = 0x8238EB78; continue 'dispatch;
	}
	// 8238EB50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8238EB54: 480F180D  bl 0x82480360
	ctx.lr = 0x8238EB58;
	sub_82480360(ctx, base);
	// 8238EB58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238EB5C: 4182001C  beq 0x8238eb78
	if ctx.cr[0].eq {
	pc = 0x8238EB78; continue 'dispatch;
	}
	// 8238EB60: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8238EB64: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8238EB68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8238EB6C: 480F1165  bl 0x8247fcd0
	ctx.lr = 0x8238EB70;
	sub_8247FCD0(ctx, base);
	// 8238EB70: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8238EB74: 48000008  b 0x8238eb7c
	pc = 0x8238EB7C; continue 'dispatch;
            }
            0x8238EB78 => {
    //   block [0x8238EB78..0x8238EB7C)
	// 8238EB78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8238EB7C; continue 'dispatch;
            }
            0x8238EB7C => {
    //   block [0x8238EB7C..0x8238EB84)
	// 8238EB7C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8238EB80: 481A6584  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238EB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238EB88 size=188
    let mut pc: u32 = 0x8238EB88;
    'dispatch: loop {
        match pc {
            0x8238EB88 => {
    //   block [0x8238EB88..0x8238EC04)
	// 8238EB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238EB8C: 481A6529  bl 0x825350b4
	ctx.lr = 0x8238EB90;
	sub_82535080(ctx, base);
	// 8238EB90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238EB94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8238EB98: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8238EB9C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8238EBA0: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 8238EBA4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8238EBA8: 419A0090  beq cr6, 0x8238ec38
	if ctx.cr[6].eq {
	pc = 0x8238EC38; continue 'dispatch;
	}
	// 8238EBAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8238EBB0: 419A0088  beq cr6, 0x8238ec38
	if ctx.cr[6].eq {
	pc = 0x8238EC38; continue 'dispatch;
	}
	// 8238EBB4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8238EBB8: 419A0080  beq cr6, 0x8238ec38
	if ctx.cr[6].eq {
	pc = 0x8238EC38; continue 'dispatch;
	}
	// 8238EBBC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8238EBC0: 419A0078  beq cr6, 0x8238ec38
	if ctx.cr[6].eq {
	pc = 0x8238EC38; continue 'dispatch;
	}
	// 8238EBC4: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238EBC8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238EBCC: 41820038  beq 0x8238ec04
	if ctx.cr[0].eq {
	pc = 0x8238EC04; continue 'dispatch;
	}
	// 8238EBD0: 83EB0020  lwz r31, 0x20(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8238EBD4: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238EBD8: 4182002C  beq 0x8238ec04
	if ctx.cr[0].eq {
	pc = 0x8238EC04; continue 'dispatch;
	}
	// 8238EBDC: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8238EBE0: 386B9684  addi r3, r11, -0x697c
	ctx.r[3].s64 = ctx.r[11].s64 + -27004;
	// 8238EBE4: 480D7C75  bl 0x82466858
	ctx.lr = 0x8238EBE8;
	sub_82466858(ctx, base);
	// 8238EBE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8238EBEC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8238EBF0: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238EBF4: 480EBB85  bl 0x8247a778
	ctx.lr = 0x8238EBF8;
	sub_8247A778(ctx, base);
	// 8238EBF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8238EBFC: 480F1A2D  bl 0x82480628
	ctx.lr = 0x8238EC00;
	sub_82480628(ctx, base);
	// 8238EC00: 48000008  b 0x8238ec08
	pc = 0x8238EC08; continue 'dispatch;
            }
            0x8238EC04 => {
    //   block [0x8238EC04..0x8238EC08)
	// 8238EC04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8238EC08; continue 'dispatch;
            }
            0x8238EC08 => {
    //   block [0x8238EC08..0x8238EC38)
	// 8238EC08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8238EC0C: 419A002C  beq cr6, 0x8238ec38
	if ctx.cr[6].eq {
	pc = 0x8238EC38; continue 'dispatch;
	}
	// 8238EC10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8238EC14: 480F174D  bl 0x82480360
	ctx.lr = 0x8238EC18;
	sub_82480360(ctx, base);
	// 8238EC18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238EC1C: 4182001C  beq 0x8238ec38
	if ctx.cr[0].eq {
	pc = 0x8238EC38; continue 'dispatch;
	}
	// 8238EC20: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8238EC24: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8238EC28: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8238EC2C: 480F10A5  bl 0x8247fcd0
	ctx.lr = 0x8238EC30;
	sub_8247FCD0(ctx, base);
	// 8238EC30: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8238EC34: 48000008  b 0x8238ec3c
	pc = 0x8238EC3C; continue 'dispatch;
            }
            0x8238EC38 => {
    //   block [0x8238EC38..0x8238EC3C)
	// 8238EC38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8238EC3C; continue 'dispatch;
            }
            0x8238EC3C => {
    //   block [0x8238EC3C..0x8238EC44)
	// 8238EC3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8238EC40: 481A64C4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238EC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238EC48 size=156
    let mut pc: u32 = 0x8238EC48;
    'dispatch: loop {
        match pc {
            0x8238EC48 => {
    //   block [0x8238EC48..0x8238ECA0)
	// 8238EC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238EC4C: 481A646D  bl 0x825350b8
	ctx.lr = 0x8238EC50;
	sub_82535080(ctx, base);
	// 8238EC50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238EC54: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238EC58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8238EC5C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8238EC60: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 8238EC64: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238EC68: 41820038  beq 0x8238eca0
	if ctx.cr[0].eq {
	pc = 0x8238ECA0; continue 'dispatch;
	}
	// 8238EC6C: 83EB0070  lwz r31, 0x70(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8238EC70: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238EC74: 4182002C  beq 0x8238eca0
	if ctx.cr[0].eq {
	pc = 0x8238ECA0; continue 'dispatch;
	}
	// 8238EC78: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8238EC7C: 386B9684  addi r3, r11, -0x697c
	ctx.r[3].s64 = ctx.r[11].s64 + -27004;
	// 8238EC80: 480D7BD9  bl 0x82466858
	ctx.lr = 0x8238EC84;
	sub_82466858(ctx, base);
	// 8238EC84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8238EC88: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8238EC8C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238EC90: 480EBAE9  bl 0x8247a778
	ctx.lr = 0x8238EC94;
	sub_8247A778(ctx, base);
	// 8238EC94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8238EC98: 480F1991  bl 0x82480628
	ctx.lr = 0x8238EC9C;
	sub_82480628(ctx, base);
	// 8238EC9C: 48000008  b 0x8238eca4
	pc = 0x8238ECA4; continue 'dispatch;
            }
            0x8238ECA0 => {
    //   block [0x8238ECA0..0x8238ECA4)
	// 8238ECA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8238ECA4; continue 'dispatch;
            }
            0x8238ECA4 => {
    //   block [0x8238ECA4..0x8238ECAC)
	// 8238ECA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8238ECA8: 409A000C  bne cr6, 0x8238ecb4
	if !ctx.cr[6].eq {
	pc = 0x8238ECB4; continue 'dispatch;
	}
	pc = 0x8238ECAC; continue 'dispatch;
            }
            0x8238ECAC => {
    //   block [0x8238ECAC..0x8238ECB4)
	// 8238ECAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8238ECB0: 4800002C  b 0x8238ecdc
	pc = 0x8238ECDC; continue 'dispatch;
            }
            0x8238ECB4 => {
    //   block [0x8238ECB4..0x8238ECDC)
	// 8238ECB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8238ECB8: 480F16A9  bl 0x82480360
	ctx.lr = 0x8238ECBC;
	sub_82480360(ctx, base);
	// 8238ECBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238ECC0: 4182FFEC  beq 0x8238ecac
	if ctx.cr[0].eq {
	pc = 0x8238ECAC; continue 'dispatch;
	}
	// 8238ECC4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238ECC8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8238ECCC: 388BC4D4  addi r4, r11, -0x3b2c
	ctx.r[4].s64 = ctx.r[11].s64 + -15148;
	// 8238ECD0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8238ECD4: 480F1285  bl 0x8247ff58
	ctx.lr = 0x8238ECD8;
	sub_8247FF58(ctx, base);
	// 8238ECD8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x8238ECDC; continue 'dispatch;
            }
            0x8238ECDC => {
    //   block [0x8238ECDC..0x8238ECE4)
	// 8238ECDC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8238ECE0: 481A6428  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238ECE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238ECE8 size=116
    let mut pc: u32 = 0x8238ECE8;
    'dispatch: loop {
        match pc {
            0x8238ECE8 => {
    //   block [0x8238ECE8..0x8238ED5C)
	// 8238ECE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238ECEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238ECF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238ECF4: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238ECF8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8238ECFC: 81040004  lwz r8, 4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238ED00: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8238ED04: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238ED08: 386AFFF8  addi r3, r10, -8
	ctx.r[3].s64 = ctx.r[10].s64 + -8;
	// 8238ED0C: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238ED10: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238ED14: 814AFFF8  lwz r10, -8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238ED18: C00B001C  lfs f0, 0x1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238ED1C: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238ED20: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238ED24: 80890008  lwz r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238ED28: C16B0010  lfs f11, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8238ED2C: 80A80008  lwz r5, 8(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 8238ED30: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238ED34: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8238ED38: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238ED3C: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238ED40: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238ED44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8238ED48: 4E800421  bctrl
	ctx.lr = 0x8238ED4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238ED4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238ED50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238ED54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238ED58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238ED60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238ED60 size=152
    let mut pc: u32 = 0x8238ED60;
    'dispatch: loop {
        match pc {
            0x8238ED60 => {
    //   block [0x8238ED60..0x8238ED7C)
	// 8238ED60: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 8238ED64: 54C807FE  clrlwi r8, r6, 0x1f
	ctx.r[8].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 8238ED68: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238ED6C: 409A0020  bne cr6, 0x8238ed8c
	if !ctx.cr[6].eq {
	pc = 0x8238ED8C; continue 'dispatch;
	}
	// 8238ED70: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8238ED74: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8238ED78: 40990014  ble cr6, 0x8238ed8c
	if !ctx.cr[6].gt {
	pc = 0x8238ED8C; continue 'dispatch;
	}
	pc = 0x8238ED7C; continue 'dispatch;
            }
            0x8238ED7C => {
    //   block [0x8238ED7C..0x8238ED8C)
	// 8238ED7C: 796BF842  rldicl r11, r11, 0x3f, 1
	ctx.r[11].u64 = ctx.r[11].u64 & 0x0000000000000001u64;
	// 8238ED80: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 8238ED84: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 8238ED88: 4199FFF4  bgt cr6, 0x8238ed7c
	if ctx.cr[6].gt {
	pc = 0x8238ED7C; continue 'dispatch;
	}
	pc = 0x8238ED8C; continue 'dispatch;
            }
            0x8238ED8C => {
    //   block [0x8238ED8C..0x8238ED9C)
	// 8238ED8C: 7D632A14  add r11, r3, r5
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[5].u64;
	// 8238ED90: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8238ED94: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8238ED98: 4800001C  b 0x8238edb4
	pc = 0x8238EDB4; continue 'dispatch;
            }
            0x8238ED9C => {
    //   block [0x8238ED9C..0x8238EDB4)
	// 8238ED9C: 2F2A0000  cmpdi cr6, r10, 0
	ctx.cr[6].compare_i64(ctx.r[10].s64, 0, &mut ctx.xer);
	// 8238EDA0: 419A002C  beq cr6, 0x8238edcc
	if ctx.cr[6].eq {
	pc = 0x8238EDCC; continue 'dispatch;
	}
	// 8238EDA4: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8238EDA8: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 8238EDAC: 7D4A0E74  sradi r10, r10, 1
	ctx.xer.ca = (ctx.r[10].s64 < 0) && ((ctx.r[10].u64 & ((1u64 << 1) - 1)) != 0);
	ctx.r[10].s64 = ctx.r[10].s64 >> 1;
	// 8238EDB0: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	pc = 0x8238EDB4; continue 'dispatch;
            }
            0x8238EDB4 => {
    //   block [0x8238EDB4..0x8238EDCC)
	// 8238EDB4: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 8238EDB8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8238EDBC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238EDC0: 4199FFDC  bgt cr6, 0x8238ed9c
	if ctx.cr[6].gt {
	pc = 0x8238ED9C; continue 'dispatch;
	}
	// 8238EDC4: 2F2A0000  cmpdi cr6, r10, 0
	ctx.cr[6].compare_i64(ctx.r[10].s64, 0, &mut ctx.xer);
	// 8238EDC8: 409A0030  bne cr6, 0x8238edf8
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8238EDF8);
		return;
	}
	pc = 0x8238EDCC; continue 'dispatch;
            }
            0x8238EDCC => {
    //   block [0x8238EDCC..0x8238EDE4)
	// 8238EDCC: 21480000  subfic r10, r8, 0
	ctx.xer.ca = ctx.r[8].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[8].s64;
	// 8238EDD0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238EDD4: 7D4A5110  subfe r10, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 8238EDD8: 554A06F6  rlwinm r10, r10, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8238EDDC: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 8238EDE0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x8238EDE4; continue 'dispatch;
            }
            0x8238EDE4 => {
    //   block [0x8238EDE4..0x8238EDF8)
	// 8238EDE4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8238EDE8: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238EDEC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238EDF0: 4181FFF4  bgt 0x8238ede4
	if ctx.cr[0].gt {
	pc = 0x8238EDE4; continue 'dispatch;
	}
	// 8238EDF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238EE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238EE28 size=164
    let mut pc: u32 = 0x8238EE28;
    'dispatch: loop {
        match pc {
            0x8238EE28 => {
    //   block [0x8238EE28..0x8238EE44)
	// 8238EE28: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 8238EE2C: 54C907FE  clrlwi r9, r6, 0x1f
	ctx.r[9].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 8238EE30: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238EE34: 409A002C  bne cr6, 0x8238ee60
	if !ctx.cr[6].eq {
	pc = 0x8238EE60; continue 'dispatch;
	}
	// 8238EE38: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8238EE3C: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8238EE40: 4099001C  ble cr6, 0x8238ee5c
	if !ctx.cr[6].gt {
	pc = 0x8238EE5C; continue 'dispatch;
	}
	pc = 0x8238EE44; continue 'dispatch;
            }
            0x8238EE44 => {
    //   block [0x8238EE44..0x8238EE5C)
	// 8238EE44: 796BE102  rldicl r11, r11, 0x3c, 4
	ctx.r[11].u64 = ctx.r[11].u64 & 0x000000000000000Fu64;
	// 8238EE48: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 8238EE4C: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 8238EE50: 4199FFF4  bgt cr6, 0x8238ee44
	if ctx.cr[6].gt {
	pc = 0x8238EE44; continue 'dispatch;
	}
	// 8238EE54: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238EE58: 409A0008  bne cr6, 0x8238ee60
	if !ctx.cr[6].eq {
	pc = 0x8238EE60; continue 'dispatch;
	}
	pc = 0x8238EE5C; continue 'dispatch;
            }
            0x8238EE5C => {
    //   block [0x8238EE5C..0x8238EE60)
	// 8238EE5C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	pc = 0x8238EE60; continue 'dispatch;
            }
            0x8238EE60 => {
    //   block [0x8238EE60..0x8238EE70)
	// 8238EE60: 7D632A14  add r11, r3, r5
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[5].u64;
	// 8238EE64: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8238EE68: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8238EE6C: 4800001C  b 0x8238ee88
	pc = 0x8238EE88; continue 'dispatch;
            }
            0x8238EE70 => {
    //   block [0x8238EE70..0x8238EE88)
	// 8238EE70: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8238EE74: 419A002C  beq cr6, 0x8238eea0
	if ctx.cr[6].eq {
	pc = 0x8238EEA0; continue 'dispatch;
	}
	// 8238EE78: 5548073E  clrlwi r8, r10, 0x1c
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 8238EE7C: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 8238EE80: 794AE102  rldicl r10, r10, 0x3c, 4
	ctx.r[10].u64 = ctx.r[10].u64 & 0x000000000000000Fu64;
	// 8238EE84: 7D0838AE  lbzx r8, r8, r7
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	pc = 0x8238EE88; continue 'dispatch;
            }
            0x8238EE88 => {
    //   block [0x8238EE88..0x8238EEA0)
	// 8238EE88: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 8238EE8C: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8238EE90: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238EE94: 4199FFDC  bgt cr6, 0x8238ee70
	if ctx.cr[6].gt {
	pc = 0x8238EE70; continue 'dispatch;
	}
	// 8238EE98: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8238EE9C: 409A0030  bne cr6, 0x8238eecc
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8238EECC);
		return;
	}
	pc = 0x8238EEA0; continue 'dispatch;
            }
            0x8238EEA0 => {
    //   block [0x8238EEA0..0x8238EEB8)
	// 8238EEA0: 21490000  subfic r10, r9, 0
	ctx.xer.ca = ctx.r[9].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[9].s64;
	// 8238EEA4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238EEA8: 7D4A5110  subfe r10, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 8238EEAC: 554A06F6  rlwinm r10, r10, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8238EEB0: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 8238EEB4: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x8238EEB8; continue 'dispatch;
            }
            0x8238EEB8 => {
    //   block [0x8238EEB8..0x8238EECC)
	// 8238EEB8: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8238EEBC: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238EEC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238EEC4: 4181FFF4  bgt 0x8238eeb8
	if ctx.cr[0].gt {
	pc = 0x8238EEB8; continue 'dispatch;
	}
	// 8238EEC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238EEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238EEF8 size=440
    let mut pc: u32 = 0x8238EEF8;
    'dispatch: loop {
        match pc {
            0x8238EEF8 => {
    //   block [0x8238EEF8..0x8238EF1C)
	// 8238EEF8: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 8238EEFC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8238EF00: 409A001C  bne cr6, 0x8238ef1c
	if !ctx.cr[6].eq {
	pc = 0x8238EF1C; continue 'dispatch;
	}
	// 8238EF04: 2F2A0000  cmpdi cr6, r10, 0
	ctx.cr[6].compare_i64(ctx.r[10].s64, 0, &mut ctx.xer);
	// 8238EF08: 40980014  bge cr6, 0x8238ef1c
	if !ctx.cr[6].lt {
	pc = 0x8238EF1C; continue 'dispatch;
	}
	// 8238EF0C: 7D4A00D0  neg r10, r10
	ctx.r[10].s64 = -ctx.r[10].s64;
	// 8238EF10: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8238EF14: 3880002D  li r4, 0x2d
	ctx.r[4].s64 = 45;
	// 8238EF18: 48000020  b 0x8238ef38
	pc = 0x8238EF38; continue 'dispatch;
            }
            0x8238EF1C => {
    //   block [0x8238EF1C..0x8238EF30)
	// 8238EF1C: 54CB07BD  rlwinm. r11, r6, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238EF20: 41820010  beq 0x8238ef30
	if ctx.cr[0].eq {
	pc = 0x8238EF30; continue 'dispatch;
	}
	// 8238EF24: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8238EF28: 3880002B  li r4, 0x2b
	ctx.r[4].s64 = 43;
	// 8238EF2C: 4800000C  b 0x8238ef38
	pc = 0x8238EF38; continue 'dispatch;
            }
            0x8238EF30 => {
    //   block [0x8238EF30..0x8238EF38)
	// 8238EF30: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8238EF34: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8238EF38; continue 'dispatch;
            }
            0x8238EF38 => {
    //   block [0x8238EF38..0x8238EF60)
	// 8238EF38: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8238EF3C: 54C607FE  clrlwi r6, r6, 0x1f
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 8238EF40: 79690020  clrldi r9, r11, 0x20
	ctx.r[9].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 8238EF44: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 8238EF48: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8238EF4C: 409A0058  bne cr6, 0x8238efa4
	if !ctx.cr[6].eq {
	pc = 0x8238EFA4; continue 'dispatch;
	}
	// 8238EF50: 7F2A4840  cmpld cr6, r10, r9
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[9].u64, &mut ctx.xer);
	// 8238EF54: 41990024  bgt cr6, 0x8238ef78
	if ctx.cr[6].gt {
	pc = 0x8238EF78; continue 'dispatch;
	}
	// 8238EF58: 554B003F  rotlwi. r11, r10, 0
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(0)) as u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238EF5C: 41820040  beq 0x8238ef9c
	if ctx.cr[0].eq {
	pc = 0x8238EF9C; continue 'dispatch;
	}
	pc = 0x8238EF60; continue 'dispatch;
            }
            0x8238EF60 => {
    //   block [0x8238EF60..0x8238EF78)
	// 8238EF60: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 8238EF64: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 8238EF68: 7D6B3BD2  divd r11, r11, r7
	ctx.r[11].s64 = ctx.r[11].s64 / ctx.r[7].s64;
	// 8238EF6C: 556B003F  rotlwi. r11, r11, 0
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(0)) as u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238EF70: 4082FFF0  bne 0x8238ef60
	if !ctx.cr[0].eq {
	pc = 0x8238EF60; continue 'dispatch;
	}
	// 8238EF74: 48000020  b 0x8238ef94
	pc = 0x8238EF94; continue 'dispatch;
            }
            0x8238EF78 => {
    //   block [0x8238EF78..0x8238EF84)
	// 8238EF78: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8238EF7C: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8238EF80: 4099001C  ble cr6, 0x8238ef9c
	if !ctx.cr[6].gt {
	pc = 0x8238EF9C; continue 'dispatch;
	}
	pc = 0x8238EF84; continue 'dispatch;
            }
            0x8238EF84 => {
    //   block [0x8238EF84..0x8238EF94)
	// 8238EF84: 7D6B3B92  divdu r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 / ctx.r[7].u64;
	// 8238EF88: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 8238EF8C: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 8238EF90: 4199FFF4  bgt cr6, 0x8238ef84
	if ctx.cr[6].gt {
	pc = 0x8238EF84; continue 'dispatch;
	}
	pc = 0x8238EF94; continue 'dispatch;
            }
            0x8238EF94 => {
    //   block [0x8238EF94..0x8238EF9C)
	// 8238EF94: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8238EF98: 409A0010  bne cr6, 0x8238efa8
	if !ctx.cr[6].eq {
	pc = 0x8238EFA8; continue 'dispatch;
	}
	pc = 0x8238EF9C; continue 'dispatch;
            }
            0x8238EF9C => {
    //   block [0x8238EF9C..0x8238EFA4)
	// 8238EF9C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8238EFA0: 48000008  b 0x8238efa8
	pc = 0x8238EFA8; continue 'dispatch;
            }
            0x8238EFA4 => {
    //   block [0x8238EFA4..0x8238EFA8)
	// 8238EFA4: 7CA82850  subf r5, r8, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	pc = 0x8238EFA8; continue 'dispatch;
            }
            0x8238EFA8 => {
    //   block [0x8238EFA8..0x8238EFD0)
	// 8238EFA8: 7D681A14  add r11, r8, r3
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 8238EFAC: 7F2A4840  cmpld cr6, r10, r9
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[9].u64, &mut ctx.xer);
	// 8238EFB0: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 8238EFB4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8238EFB8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8238EFBC: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 8238EFC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238EFC4: 4199006C  bgt cr6, 0x8238f030
	if ctx.cr[6].gt {
	pc = 0x8238F030; continue 'dispatch;
	}
	// 8238EFC8: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8238EFCC: 4800002C  b 0x8238eff8
	pc = 0x8238EFF8; continue 'dispatch;
            }
            0x8238EFD0 => {
    //   block [0x8238EFD0..0x8238EFF8)
	// 8238EFD0: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 8238EFD4: 4198002C  blt cr6, 0x8238f000
	if ctx.cr[6].lt {
	pc = 0x8238F000; continue 'dispatch;
	}
	// 8238EFD8: 7D2A3B96  divwu r9, r10, r7
	ctx.r[9].u32 = ctx.r[10].u32 / ctx.r[7].u32;
	// 8238EFDC: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 8238EFE0: 1D29000A  mulli r9, r9, 0xa
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 10 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8238EFE4: 7D295050  subf r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 8238EFE8: 7D4A3B96  divwu r10, r10, r7
	ctx.r[10].u32 = ctx.r[10].u32 / ctx.r[7].u32;
	// 8238EFEC: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 8238EFF0: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 8238EFF4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x8238EFF8; continue 'dispatch;
            }
            0x8238EFF8 => {
    //   block [0x8238EFF8..0x8238F000)
	// 8238EFF8: 2B050001  cmplwi cr6, r5, 1
	ctx.cr[6].compare_u32(ctx.r[5].u32, 1 as u32, &mut ctx.xer);
	// 8238EFFC: 4199FFD4  bgt cr6, 0x8238efd0
	if ctx.cr[6].gt {
	pc = 0x8238EFD0; continue 'dispatch;
	}
	pc = 0x8238F000; continue 'dispatch;
            }
            0x8238F000 => {
    //   block [0x8238F000..0x8238F008)
	// 8238F000: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 8238F004: 48000034  b 0x8238f038
	pc = 0x8238F038; continue 'dispatch;
            }
            0x8238F008 => {
    //   block [0x8238F008..0x8238F030)
	// 8238F008: 2B2A000A  cmpldi cr6, r10, 0xa
	ctx.cr[6].compare_u64(ctx.r[10].u64, 10, &mut ctx.xer);
	// 8238F00C: 4198002C  blt cr6, 0x8238f038
	if ctx.cr[6].lt {
	pc = 0x8238F038; continue 'dispatch;
	}
	// 8238F010: 7D2A3B92  divdu r9, r10, r7
	ctx.r[9].u64 = ctx.r[10].u64 / ctx.r[7].u64;
	// 8238F014: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 8238F018: 1D29000A  mulli r9, r9, 0xa
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 10 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8238F01C: 7D295050  subf r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 8238F020: 7D4A3B92  divdu r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 / ctx.r[7].u64;
	// 8238F024: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 8238F028: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 8238F02C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x8238F030; continue 'dispatch;
            }
            0x8238F030 => {
    //   block [0x8238F030..0x8238F038)
	// 8238F030: 2B050001  cmplwi cr6, r5, 1
	ctx.cr[6].compare_u32(ctx.r[5].u32, 1 as u32, &mut ctx.xer);
	// 8238F034: 4199FFD4  bgt cr6, 0x8238f008
	if ctx.cr[6].gt {
	pc = 0x8238F008; continue 'dispatch;
	}
	pc = 0x8238F038; continue 'dispatch;
            }
            0x8238F038 => {
    //   block [0x8238F038..0x8238F048)
	// 8238F038: 2F2A0009  cmpdi cr6, r10, 9
	ctx.cr[6].compare_i64(ctx.r[10].s64, 9, &mut ctx.xer);
	// 8238F03C: 4099000C  ble cr6, 0x8238f048
	if !ctx.cr[6].gt {
	pc = 0x8238F048; continue 'dispatch;
	}
	// 8238F040: 39400056  li r10, 0x56
	ctx.r[10].s64 = 86;
	// 8238F044: 48000008  b 0x8238f04c
	pc = 0x8238F04C; continue 'dispatch;
            }
            0x8238F048 => {
    //   block [0x8238F048..0x8238F04C)
	// 8238F048: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	pc = 0x8238F04C; continue 'dispatch;
            }
            0x8238F04C => {
    //   block [0x8238F04C..0x8238F070)
	// 8238F04C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8238F050: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 8238F054: 3965FFFF  addi r11, r5, -1
	ctx.r[11].s64 = ctx.r[5].s64 + -1;
	// 8238F058: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8238F05C: 409A0014  bne cr6, 0x8238f070
	if !ctx.cr[6].eq {
	pc = 0x8238F070; continue 'dispatch;
	}
	// 8238F060: 5489063F  clrlwi. r9, r4, 0x18
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8238F064: 4182000C  beq 0x8238f070
	if ctx.cr[0].eq {
	pc = 0x8238F070; continue 'dispatch;
	}
	// 8238F068: 988A0000  stb r4, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 8238F06C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	pc = 0x8238F070; continue 'dispatch;
            }
            0x8238F070 => {
    //   block [0x8238F070..0x8238F088)
	// 8238F070: 21260000  subfic r9, r6, 0
	ctx.xer.ca = ctx.r[6].u32 <= 0 as u32;
	ctx.r[9].s64 = (0 as i64) - ctx.r[6].s64;
	// 8238F074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8238F078: 7D294910  subfe r9, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 8238F07C: 552906F6  rlwinm r9, r9, 0, 0x1b, 0x1b
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8238F080: 39290020  addi r9, r9, 0x20
	ctx.r[9].s64 = ctx.r[9].s64 + 32;
	// 8238F084: 419A0014  beq cr6, 0x8238f098
	if ctx.cr[6].eq {
	pc = 0x8238F098; continue 'dispatch;
	}
	pc = 0x8238F088; continue 'dispatch;
            }
            0x8238F088 => {
    //   block [0x8238F088..0x8238F098)
	// 8238F088: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 8238F08C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238F090: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8238F094: 4082FFF4  bne 0x8238f088
	if !ctx.cr[0].eq {
	pc = 0x8238F088; continue 'dispatch;
	}
	pc = 0x8238F098; continue 'dispatch;
            }
            0x8238F098 => {
    //   block [0x8238F098..0x8238F0B0)
	// 8238F098: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8238F09C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8238F0A0: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238F0A4: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 8238F0A8: 988A0000  stb r4, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 8238F0AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238F0B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238F0B0 size=580
    let mut pc: u32 = 0x8238F0B0;
    'dispatch: loop {
        match pc {
            0x8238F0B0 => {
    //   block [0x8238F0B0..0x8238F0D8)
	// 8238F0B0: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 8238F0B4: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 8238F0B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238F0BC: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238F0C0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8238F0C4: 40980014  bge cr6, 0x8238f0d8
	if !ctx.cr[6].lt {
	pc = 0x8238F0D8; continue 'dispatch;
	}
	// 8238F0C8: FC200850  fneg f1, f1
	ctx.f[1].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 8238F0CC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 8238F0D0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 8238F0D4: 48000010  b 0x8238f0e4
	pc = 0x8238F0E4; continue 'dispatch;
            }
            0x8238F0D8 => {
    //   block [0x8238F0D8..0x8238F0E4)
	// 8238F0D8: 54EBFFFE  rlwinm r11, r7, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 8238F0DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8238F0E0: 616A0002  ori r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u64 | 2;
	pc = 0x8238F0E4; continue 'dispatch;
            }
            0x8238F0E4 => {
    //   block [0x8238F0E4..0x8238F0F8)
	// 8238F0E4: 54FE07FE  clrlwi r30, r7, 0x1f
	ctx.r[30].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 8238F0E8: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238F0EC: 409A000C  bne cr6, 0x8238f0f8
	if !ctx.cr[6].eq {
	pc = 0x8238F0F8; continue 'dispatch;
	}
	// 8238F0F0: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 8238F0F4: 48000024  b 0x8238f118
	pc = 0x8238F118; continue 'dispatch;
            }
            0x8238F0F8 => {
    //   block [0x8238F0F8..0x8238F104)
	// 8238F0F8: 2F060009  cmpwi cr6, r6, 9
	ctx.cr[6].compare_i32(ctx.r[6].s32, 9, &mut ctx.xer);
	// 8238F0FC: 40990008  ble cr6, 0x8238f104
	if !ctx.cr[6].gt {
	pc = 0x8238F104; continue 'dispatch;
	}
	// 8238F100: 38C00009  li r6, 9
	ctx.r[6].s64 = 9;
	pc = 0x8238F104; continue 'dispatch;
            }
            0x8238F104 => {
    //   block [0x8238F104..0x8238F118)
	// 8238F104: 7D662850  subf r11, r6, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[6].s64;
	// 8238F108: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8238F10C: 4098000C  bge cr6, 0x8238f118
	if !ctx.cr[6].lt {
	pc = 0x8238F118; continue 'dispatch;
	}
	// 8238F110: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 8238F114: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	pc = 0x8238F118; continue 'dispatch;
            }
            0x8238F118 => {
    //   block [0x8238F118..0x8238F194)
	// 8238F118: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 8238F11C: FC00081E  fctiwz f0, f1
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 8238F120: 3921FFE0  addi r9, r1, -0x20
	ctx.r[9].s64 = ctx.r[1].s64 + -32;
	// 8238F124: 396BD570  addi r11, r11, -0x2a90
	ctx.r[11].s64 = ctx.r[11].s64 + -10896;
	// 8238F128: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8238F12C: 3881FFE0  addi r4, r1, -0x20
	ctx.r[4].s64 = ctx.r[1].s64 + -32;
	// 8238F130: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 8238F134: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 8238F138: 3921FFE8  addi r9, r1, -0x18
	ctx.r[9].s64 = ctx.r[1].s64 + -24;
	// 8238F13C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238F140: 7DA85C2E  lfsx f13, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238F144: E961FFE2  lwa r11, -0x20(r1)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as i32) as i64;
	// 8238F148: F961FFE8  std r11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[11].u64 ) };
	// 8238F14C: C801FFE8  lfd f0, -0x18(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238F150: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8238F154: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238F158: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8238F15C: ED810028  fsubs f12, f1, f0
	ctx.f[12].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 8238F160: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8238F164: 7C0027AE  stfiwx f0, 0, r4
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32, tmp.u32) };
	// 8238F168: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238F16C: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 8238F170: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 8238F174: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8238F178: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 8238F17C: 8121FFE0  lwz r9, -0x20(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 8238F180: 409A0030  bne cr6, 0x8238f1b0
	if !ctx.cr[6].eq {
	pc = 0x8238F1B0; continue 'dispatch;
	}
	// 8238F184: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8238F188: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8238F18C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8238F190: 40990018  ble cr6, 0x8238f1a8
	if !ctx.cr[6].gt {
	pc = 0x8238F1A8; continue 'dispatch;
	}
	pc = 0x8238F194; continue 'dispatch;
            }
            0x8238F194 => {
    //   block [0x8238F194..0x8238F1A8)
	// 8238F194: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8238F198: 7D6B23D7  divw. r11, r11, r4
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[4].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238F19C: 4181FFF8  bgt 0x8238f194
	if ctx.cr[0].gt {
	pc = 0x8238F194; continue 'dispatch;
	}
	// 8238F1A0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8238F1A4: 409A0014  bne cr6, 0x8238f1b8
	if !ctx.cr[6].eq {
	pc = 0x8238F1B8; continue 'dispatch;
	}
	pc = 0x8238F1A8; continue 'dispatch;
            }
            0x8238F1A8 => {
    //   block [0x8238F1A8..0x8238F1B0)
	// 8238F1A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8238F1AC: 4800000C  b 0x8238f1b8
	pc = 0x8238F1B8; continue 'dispatch;
            }
            0x8238F1B0 => {
    //   block [0x8238F1B0..0x8238F1B8)
	// 8238F1B0: 7D672850  subf r11, r7, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[7].s64;
	// 8238F1B4: 7D465850  subf r10, r6, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	pc = 0x8238F1B8; continue 'dispatch;
            }
            0x8238F1B8 => {
    //   block [0x8238F1B8..0x8238F1DC)
	// 8238F1B8: 7D6A3A14  add r11, r10, r7
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 8238F1BC: 3900002E  li r8, 0x2e
	ctx.r[8].s64 = 46;
	// 8238F1C0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 8238F1C4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8238F1C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238F1CC: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 8238F1D0: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 8238F1D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238F1D8: 419A004C  beq cr6, 0x8238f224
	if ctx.cr[6].eq {
	pc = 0x8238F224; continue 'dispatch;
	}
	pc = 0x8238F1DC; continue 'dispatch;
            }
            0x8238F1DC => {
    //   block [0x8238F1DC..0x8238F210)
	// 8238F1DC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8238F1E0: 419A0030  beq cr6, 0x8238f210
	if ctx.cr[6].eq {
	pc = 0x8238F210; continue 'dispatch;
	}
	// 8238F1E4: 7D0923D6  divw r8, r9, r4
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[4].s32;
	// 8238F1E8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8238F1EC: 1D08000A  mulli r8, r8, 0xa
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * 10 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 8238F1F0: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 8238F1F4: 7D2923D7  divw. r9, r9, r4
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[4].s32;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8238F1F8: 39080030  addi r8, r8, 0x30
	ctx.r[8].s64 = ctx.r[8].s64 + 48;
	// 8238F1FC: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 8238F200: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238F204: 4082FFD8  bne 0x8238f1dc
	if !ctx.cr[0].eq {
	pc = 0x8238F1DC; continue 'dispatch;
	}
	// 8238F208: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8238F20C: 409A0028  bne cr6, 0x8238f234
	if !ctx.cr[6].eq {
	pc = 0x8238F234; continue 'dispatch;
	}
	pc = 0x8238F210; continue 'dispatch;
            }
            0x8238F210 => {
    //   block [0x8238F210..0x8238F224)
	// 8238F210: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8238F214: 419A0020  beq cr6, 0x8238f234
	if ctx.cr[6].eq {
	pc = 0x8238F234; continue 'dispatch;
	}
	// 8238F218: 39200056  li r9, 0x56
	ctx.r[9].s64 = 86;
	// 8238F21C: 992B0001  stb r9, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[9].u8 ) };
	// 8238F220: 48000014  b 0x8238f234
	pc = 0x8238F234; continue 'dispatch;
            }
            0x8238F224 => {
    //   block [0x8238F224..0x8238F234)
	// 8238F224: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8238F228: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8238F22C: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 8238F230: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x8238F234; continue 'dispatch;
            }
            0x8238F234 => {
    //   block [0x8238F234..0x8238F260)
	// 8238F234: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8238F238: 409A0028  bne cr6, 0x8238f260
	if !ctx.cr[6].eq {
	pc = 0x8238F260; continue 'dispatch;
	}
	// 8238F23C: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 8238F240: 40990020  ble cr6, 0x8238f260
	if !ctx.cr[6].gt {
	pc = 0x8238F260; continue 'dispatch;
	}
	// 8238F244: 213F0000  subfic r9, r31, 0
	ctx.xer.ca = ctx.r[31].u32 <= 0 as u32;
	ctx.r[9].s64 = (0 as i64) - ctx.r[31].s64;
	// 8238F248: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8238F24C: 7D294910  subfe r9, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 8238F250: 552907BC  rlwinm r9, r9, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8238F254: 3929002B  addi r9, r9, 0x2b
	ctx.r[9].s64 = ctx.r[9].s64 + 43;
	// 8238F258: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 8238F25C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x8238F260; continue 'dispatch;
            }
            0x8238F260 => {
    //   block [0x8238F260..0x8238F274)
	// 8238F260: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8238F264: 419A0020  beq cr6, 0x8238f284
	if ctx.cr[6].eq {
	pc = 0x8238F284; continue 'dispatch;
	}
	// 8238F268: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8238F26C: 53C926F6  rlwimi r9, r30, 4, 0x1b, 0x1b
	ctx.r[9].u64 = (((ctx.r[30].u32).rotate_left(4) as u64) & 0x0000000000000010) | (ctx.r[9].u64 & 0xFFFFFFFFFFFFFFEF);
	// 8238F270: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	pc = 0x8238F274; continue 'dispatch;
            }
            0x8238F274 => {
    //   block [0x8238F274..0x8238F284)
	// 8238F274: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 8238F278: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8238F27C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238F280: 4082FFF4  bne 0x8238f274
	if !ctx.cr[0].eq {
	pc = 0x8238F274; continue 'dispatch;
	}
	pc = 0x8238F284; continue 'dispatch;
            }
            0x8238F284 => {
    //   block [0x8238F284..0x8238F2A0)
	// 8238F284: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 8238F288: 419A0018  beq cr6, 0x8238f2a0
	if ctx.cr[6].eq {
	pc = 0x8238F2A0; continue 'dispatch;
	}
	// 8238F28C: 215F0000  subfic r10, r31, 0
	ctx.xer.ca = ctx.r[31].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[31].s64;
	// 8238F290: 7D4A5110  subfe r10, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 8238F294: 554A07BC  rlwinm r10, r10, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8238F298: 394A002B  addi r10, r10, 0x2b
	ctx.r[10].s64 = ctx.r[10].s64 + 43;
	// 8238F29C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	pc = 0x8238F2A0; continue 'dispatch;
            }
            0x8238F2A0 => {
    //   block [0x8238F2A0..0x8238F2C4)
	// 8238F2A0: 7D653214  add r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[6].u64;
	// 8238F2A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8238F2A8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8238F2AC: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 8238F2B0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8238F2B4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8238F2B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238F2BC: 4099002C  ble cr6, 0x8238f2e8
	if !ctx.cr[6].gt {
	pc = 0x8238F2E8; continue 'dispatch;
	}
	// 8238F2C0: 8141FFE8  lwz r10, -0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) } as u64;
	pc = 0x8238F2C4; continue 'dispatch;
            }
            0x8238F2C4 => {
    //   block [0x8238F2C4..0x8238F2E8)
	// 8238F2C4: 7D2A23D6  divw r9, r10, r4
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[4].s32;
	// 8238F2C8: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 8238F2CC: 1D29000A  mulli r9, r9, 0xa
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 10 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8238F2D0: 7D295050  subf r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 8238F2D4: 7D4A23D6  divw r10, r10, r4
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[4].s32;
	// 8238F2D8: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 8238F2DC: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 8238F2E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238F2E4: 4181FFE0  bgt 0x8238f2c4
	if ctx.cr[0].gt {
	pc = 0x8238F2C4; continue 'dispatch;
	}
	pc = 0x8238F2E8; continue 'dispatch;
            }
            0x8238F2E8 => {
    //   block [0x8238F2E8..0x8238F2F4)
	// 8238F2E8: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238F2EC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 8238F2F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238F2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238F2F8 size=116
    let mut pc: u32 = 0x8238F2F8;
    'dispatch: loop {
        match pc {
            0x8238F2F8 => {
    //   block [0x8238F2F8..0x8238F314)
	// 8238F2F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8238F2FC: 54CA07BD  rlwinm. r10, r6, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8238F300: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 8238F304: 40820068  bne 0x8238f36c
	if !ctx.cr[0].eq {
		sub_8238F36C(ctx, base);
		return;
	}
	// 8238F308: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238F30C: 40990050  ble cr6, 0x8238f35c
	if !ctx.cr[6].gt {
	pc = 0x8238F35C; continue 'dispatch;
	}
	// 8238F310: 7D2B2050  subf r9, r11, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	pc = 0x8238F314; continue 'dispatch;
            }
            0x8238F314 => {
    //   block [0x8238F314..0x8238F330)
	// 8238F314: 7D4958AE  lbzx r10, r9, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8238F318: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238F31C: 41820014  beq 0x8238f330
	if ctx.cr[0].eq {
	pc = 0x8238F330; continue 'dispatch;
	}
	// 8238F320: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8238F324: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238F328: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8238F32C: 4181FFE8  bgt 0x8238f314
	if ctx.cr[0].gt {
	pc = 0x8238F314; continue 'dispatch;
	}
	pc = 0x8238F330; continue 'dispatch;
            }
            0x8238F330 => {
    //   block [0x8238F330..0x8238F34C)
	// 8238F330: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238F334: 40990028  ble cr6, 0x8238f35c
	if !ctx.cr[6].gt {
	pc = 0x8238F35C; continue 'dispatch;
	}
	// 8238F338: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8238F33C: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8238F340: 28050000  cmplwi r5, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238F344: 41820014  beq 0x8238f358
	if ctx.cr[0].eq {
	pc = 0x8238F358; continue 'dispatch;
	}
	// 8238F348: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	pc = 0x8238F34C; continue 'dispatch;
            }
            0x8238F34C => {
    //   block [0x8238F34C..0x8238F358)
	// 8238F34C: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 8238F350: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8238F354: 4200FFF8  bdnz 0x8238f34c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8238F34C; continue 'dispatch;
	}
	pc = 0x8238F358; continue 'dispatch;
            }
            0x8238F358 => {
    //   block [0x8238F358..0x8238F35C)
	// 8238F358: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	pc = 0x8238F35C; continue 'dispatch;
            }
            0x8238F35C => {
    //   block [0x8238F35C..0x8238F36C)
	// 8238F35C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8238F360: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8238F364: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8238F368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238F36C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238F36C size=128
    let mut pc: u32 = 0x8238F36C;
    'dispatch: loop {
        match pc {
            0x8238F36C => {
    //   block [0x8238F36C..0x8238F388)
	// 8238F36C: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 8238F370: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8238F374: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8238F378: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8238F37C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238F380: 89040000  lbz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238F384: 48000010  b 0x8238f394
	pc = 0x8238F394; continue 'dispatch;
            }
            0x8238F388 => {
    //   block [0x8238F388..0x8238F394)
	// 8238F388: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8238F38C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8238F390: 89090000  lbz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8238F394; continue 'dispatch;
            }
            0x8238F394 => {
    //   block [0x8238F394..0x8238F3A8)
	// 8238F394: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238F398: 4082FFF0  bne 0x8238f388
	if !ctx.cr[0].eq {
	pc = 0x8238F388; continue 'dispatch;
	}
	// 8238F39C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 8238F3A0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238F3A4: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x8238F3A8; continue 'dispatch;
            }
            0x8238F3A8 => {
    //   block [0x8238F3A8..0x8238F3CC)
	// 8238F3A8: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8238F3AC: 40990020  ble cr6, 0x8238f3cc
	if !ctx.cr[6].gt {
	pc = 0x8238F3CC; continue 'dispatch;
	}
	// 8238F3B0: 89090000  lbz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238F3B4: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238F3B8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8238F3BC: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 8238F3C0: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 8238F3C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238F3C8: 4181FFE0  bgt 0x8238f3a8
	if ctx.cr[0].gt {
	pc = 0x8238F3A8; continue 'dispatch;
	}
	pc = 0x8238F3CC; continue 'dispatch;
            }
            0x8238F3CC => {
    //   block [0x8238F3CC..0x8238F3D4)
	// 8238F3CC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238F3D0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x8238F3D4; continue 'dispatch;
            }
            0x8238F3D4 => {
    //   block [0x8238F3D4..0x8238F3EC)
	// 8238F3D4: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8238F3D8: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238F3DC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8238F3E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238F3E4: 4181FFF0  bgt 0x8238f3d4
	if ctx.cr[0].gt {
	pc = 0x8238F3D4; continue 'dispatch;
	}
	// 8238F3E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238F3F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238F3F0 size=272
    let mut pc: u32 = 0x8238F3F0;
    'dispatch: loop {
        match pc {
            0x8238F3F0 => {
    //   block [0x8238F3F0..0x8238F43C)
	// 8238F3F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238F3F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238F3F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8238F3FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238F400: 9421FD80  stwu r1, -0x280(r1)
	ea = ctx.r[1].u32.wrapping_add(-640 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238F404: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8238F408: 90A102A4  stw r5, 0x2a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(676 as u32), ctx.r[5].u32 ) };
	// 8238F40C: 54EB07BD  rlwinm. r11, r7, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8238F410: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 8238F414: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 8238F418: 817E007C  lwz r11, 0x7c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 8238F41C: 40820044  bne 0x8238f460
	if !ctx.cr[0].eq {
	pc = 0x8238F460; continue 'dispatch;
	}
	// 8238F420: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8238F424: 388102A4  addi r4, r1, 0x2a4
	ctx.r[4].s64 = ctx.r[1].s64 + 676;
	// 8238F428: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238F42C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238F430: 4E800421  bctrl
	ctx.lr = 0x8238F434;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238F434: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8238F438: 408100A0  ble 0x8238f4d8
	if !ctx.cr[0].gt {
	pc = 0x8238F4D8; continue 'dispatch;
	}
            }
            0x8238F43C => {
    //   block [0x8238F43C..0x8238F460)
	// 8238F43C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238F440: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 8238F444: 3463FFFF  addic. r3, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8238F448: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8238F44C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238F450: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8238F454: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8238F458: 4181FFE4  bgt 0x8238f43c
	if ctx.cr[0].gt {
	pc = 0x8238F43C; continue 'dispatch;
	}
	// 8238F45C: 4800007C  b 0x8238f4d8
	pc = 0x8238F4D8; continue 'dispatch;
            }
            0x8238F460 => {
    //   block [0x8238F460..0x8238F498)
	// 8238F460: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8238F464: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 8238F468: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 8238F46C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8238F470: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8238F474: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8238F478: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238F47C: 4E800421  bctrl
	ctx.lr = 0x8238F480;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238F480: 20A30080  subfic r5, r3, 0x80
	ctx.xer.ca = ctx.r[3].u32 <= 128 as u32;
	ctx.r[5].s64 = (128 as i64) - ctx.r[3].s64;
	// 8238F484: 7F05F840  cmplw cr6, r5, r31
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8238F488: 40980038  bge cr6, 0x8238f4c0
	if !ctx.cr[6].lt {
	pc = 0x8238F4C0; continue 'dispatch;
	}
	// 8238F48C: 7D65F850  subf r11, r5, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 8238F490: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 8238F494: 48000020  b 0x8238f4b4
	pc = 0x8238F4B4; continue 'dispatch;
            }
            0x8238F498 => {
    //   block [0x8238F498..0x8238F4B4)
	// 8238F498: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238F49C: 39200009  li r9, 9
	ctx.r[9].s64 = 9;
	// 8238F4A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8238F4A4: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 8238F4A8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238F4AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8238F4B0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	pc = 0x8238F4B4; continue 'dispatch;
            }
            0x8238F4B4 => {
    //   block [0x8238F4B4..0x8238F4C0)
	// 8238F4B4: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 8238F4B8: 4199FFE0  bgt cr6, 0x8238f498
	if ctx.cr[6].gt {
	pc = 0x8238F498; continue 'dispatch;
	}
	// 8238F4BC: 48000008  b 0x8238f4c4
	pc = 0x8238F4C4; continue 'dispatch;
            }
            0x8238F4C0 => {
    //   block [0x8238F4C0..0x8238F4C4)
	// 8238F4C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	pc = 0x8238F4C4; continue 'dispatch;
            }
            0x8238F4C4 => {
    //   block [0x8238F4C4..0x8238F4D8)
	// 8238F4C4: 817E007C  lwz r11, 0x7c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 8238F4C8: 388102A4  addi r4, r1, 0x2a4
	ctx.r[4].s64 = ctx.r[1].s64 + 676;
	// 8238F4CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238F4D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238F4D4: 4E800421  bctrl
	ctx.lr = 0x8238F4D8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8238F4D8 => {
    //   block [0x8238F4D8..0x8238F500)
	// 8238F4D8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238F4DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8238F4E0: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 8238F4E4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238F4E8: 38210280  addi r1, r1, 0x280
	ctx.r[1].s64 = ctx.r[1].s64 + 640;
	// 8238F4EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238F4F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238F4F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8238F4F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238F4FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238F500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238F500 size=128
    let mut pc: u32 = 0x8238F500;
    'dispatch: loop {
        match pc {
            0x8238F500 => {
    //   block [0x8238F500..0x8238F510)
	// 8238F500: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8238F504: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8238F508: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8238F50C: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8238F510; continue 'dispatch;
            }
            0x8238F510 => {
    //   block [0x8238F510..0x8238F52C)
	// 8238F510: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238F514: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8238F518: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238F51C: 41820010  beq 0x8238f52c
	if ctx.cr[0].eq {
	pc = 0x8238F52C; continue 'dispatch;
	}
	// 8238F520: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 8238F524: 2B090020  cmplwi cr6, r9, 0x20
	ctx.cr[6].compare_u32(ctx.r[9].u32, 32 as u32, &mut ctx.xer);
	// 8238F528: 4198FFE8  blt cr6, 0x8238f510
	if ctx.cr[6].lt {
	pc = 0x8238F510; continue 'dispatch;
	}
	pc = 0x8238F52C; continue 'dispatch;
            }
            0x8238F52C => {
    //   block [0x8238F52C..0x8238F550)
	// 8238F52C: 2B0B002D  cmplwi cr6, r11, 0x2d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 45 as u32, &mut ctx.xer);
	// 8238F530: 419A0020  beq cr6, 0x8238f550
	if ctx.cr[6].eq {
	pc = 0x8238F550; continue 'dispatch;
	}
	// 8238F534: 392BFFD0  addi r9, r11, -0x30
	ctx.r[9].s64 = ctx.r[11].s64 + -48;
	// 8238F538: 2B090009  cmplwi cr6, r9, 9
	ctx.cr[6].compare_u32(ctx.r[9].u32, 9 as u32, &mut ctx.xer);
	// 8238F53C: 41990024  bgt cr6, 0x8238f560
	if ctx.cr[6].gt {
	pc = 0x8238F560; continue 'dispatch;
	}
	// 8238F540: 1D23000A  mulli r9, r3, 0xa
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * 10 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8238F544: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8238F548: 386BFFD0  addi r3, r11, -0x30
	ctx.r[3].s64 = ctx.r[11].s64 + -48;
	// 8238F54C: 48000008  b 0x8238f554
	pc = 0x8238F554; continue 'dispatch;
            }
            0x8238F550 => {
    //   block [0x8238F550..0x8238F554)
	// 8238F550: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	pc = 0x8238F554; continue 'dispatch;
            }
            0x8238F554 => {
    //   block [0x8238F554..0x8238F560)
	// 8238F554: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238F558: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8238F55C: 4BFFFFD0  b 0x8238f52c
	pc = 0x8238F52C; continue 'dispatch;
            }
            0x8238F560 => {
    //   block [0x8238F560..0x8238F56C)
	// 8238F560: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8238F564: 419A0008  beq cr6, 0x8238f56c
	if ctx.cr[6].eq {
	pc = 0x8238F56C; continue 'dispatch;
	}
	// 8238F568: 7C6300D0  neg r3, r3
	ctx.r[3].s64 = -ctx.r[3].s64;
	pc = 0x8238F56C; continue 'dispatch;
            }
            0x8238F56C => {
    //   block [0x8238F56C..0x8238F578)
	// 8238F56C: 2B0B002F  cmplwi cr6, r11, 0x2f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 47 as u32, &mut ctx.xer);
	// 8238F570: 419A0008  beq cr6, 0x8238f578
	if ctx.cr[6].eq {
	pc = 0x8238F578; continue 'dispatch;
	}
	// 8238F574: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	pc = 0x8238F578; continue 'dispatch;
            }
            0x8238F578 => {
    //   block [0x8238F578..0x8238F580)
	// 8238F578: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8238F57C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238F580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238F580 size=284
    let mut pc: u32 = 0x8238F580;
    'dispatch: loop {
        match pc {
            0x8238F580 => {
    //   block [0x8238F580..0x8238F5D0)
	// 8238F580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238F584: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238F588: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238F58C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8238F590: 4BFFFF71  bl 0x8238f500
	ctx.lr = 0x8238F594;
	sub_8238F500(ctx, base);
	// 8238F594: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8238F598: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238F59C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8238F5A0: C1AABA38  lfs f13, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238F5A4: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238F5A8: 2B0A002E  cmplwi cr6, r10, 0x2e
	ctx.cr[6].compare_u32(ctx.r[10].u32, 46 as u32, &mut ctx.xer);
	// 8238F5AC: 409A008C  bne cr6, 0x8238f638
	if !ctx.cr[6].eq {
	pc = 0x8238F638; continue 'dispatch;
	}
	// 8238F5B0: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 8238F5B4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8238F5B8: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238F5BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8238F5C0: 2B0B0030  cmplwi cr6, r11, 0x30
	ctx.cr[6].compare_u32(ctx.r[11].u32, 48 as u32, &mut ctx.xer);
	// 8238F5C4: 41980064  blt cr6, 0x8238f628
	if ctx.cr[6].lt {
	pc = 0x8238F628; continue 'dispatch;
	}
	// 8238F5C8: 3D008288  lis r8, -0x7d78
	ctx.r[8].s64 = -2105016320;
	// 8238F5CC: C008D4DC  lfs f0, -0x2b24(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8238F5D0; continue 'dispatch;
            }
            0x8238F5D0 => {
    //   block [0x8238F5D0..0x8238F604)
	// 8238F5D0: 2B0B0039  cmplwi cr6, r11, 0x39
	ctx.cr[6].compare_u32(ctx.r[11].u32, 57 as u32, &mut ctx.xer);
	// 8238F5D4: 41990030  bgt cr6, 0x8238f604
	if ctx.cr[6].gt {
	pc = 0x8238F604; continue 'dispatch;
	}
	// 8238F5D8: 2B090007  cmplwi cr6, r9, 7
	ctx.cr[6].compare_u32(ctx.r[9].u32, 7 as u32, &mut ctx.xer);
	// 8238F5DC: 40980044  bge cr6, 0x8238f620
	if !ctx.cr[6].lt {
	pc = 0x8238F620; continue 'dispatch;
	}
	// 8238F5E0: 1D07000A  mulli r8, r7, 0xa
	ctx.r[8].s32 = ((ctx.r[7].s32 as i64 * 10 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 8238F5E4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238F5E8: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 8238F5EC: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238F5F0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8238F5F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8238F5F8: 38E8FFD0  addi r7, r8, -0x30
	ctx.r[7].s64 = ctx.r[8].s64 + -48;
	// 8238F5FC: 2B0B0030  cmplwi cr6, r11, 0x30
	ctx.cr[6].compare_u32(ctx.r[11].u32, 48 as u32, &mut ctx.xer);
	// 8238F600: 4098FFD0  bge cr6, 0x8238f5d0
	if !ctx.cr[6].lt {
	pc = 0x8238F5D0; continue 'dispatch;
	}
	pc = 0x8238F604; continue 'dispatch;
            }
            0x8238F604 => {
    //   block [0x8238F604..0x8238F610)
	// 8238F604: 2B090007  cmplwi cr6, r9, 7
	ctx.cr[6].compare_u32(ctx.r[9].u32, 7 as u32, &mut ctx.xer);
	// 8238F608: 41980020  blt cr6, 0x8238f628
	if ctx.cr[6].lt {
	pc = 0x8238F628; continue 'dispatch;
	}
	// 8238F60C: 48000014  b 0x8238f620
	pc = 0x8238F620; continue 'dispatch;
            }
            0x8238F610 => {
    //   block [0x8238F610..0x8238F620)
	// 8238F610: 2B0B0039  cmplwi cr6, r11, 0x39
	ctx.cr[6].compare_u32(ctx.r[11].u32, 57 as u32, &mut ctx.xer);
	// 8238F614: 41990014  bgt cr6, 0x8238f628
	if ctx.cr[6].gt {
	pc = 0x8238F628; continue 'dispatch;
	}
	// 8238F618: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238F61C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	pc = 0x8238F620; continue 'dispatch;
            }
            0x8238F620 => {
    //   block [0x8238F620..0x8238F628)
	// 8238F620: 2B0B0030  cmplwi cr6, r11, 0x30
	ctx.cr[6].compare_u32(ctx.r[11].u32, 48 as u32, &mut ctx.xer);
	// 8238F624: 4098FFEC  bge cr6, 0x8238f610
	if !ctx.cr[6].lt {
	pc = 0x8238F610; continue 'dispatch;
	}
	pc = 0x8238F628; continue 'dispatch;
            }
            0x8238F628 => {
    //   block [0x8238F628..0x8238F634)
	// 8238F628: 2B0B002F  cmplwi cr6, r11, 0x2f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 47 as u32, &mut ctx.xer);
	// 8238F62C: 419A0008  beq cr6, 0x8238f634
	if ctx.cr[6].eq {
	pc = 0x8238F634; continue 'dispatch;
	}
	// 8238F630: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	pc = 0x8238F634; continue 'dispatch;
            }
            0x8238F634 => {
    //   block [0x8238F634..0x8238F638)
	// 8238F634: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8238F638; continue 'dispatch;
            }
            0x8238F638 => {
    //   block [0x8238F638..0x8238F678)
	// 8238F638: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 8238F63C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8238F640: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238F644: C18B1FF8  lfs f12, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8238F648: 7CEB07B4  extsw r11, r7
	ctx.r[11].s64 = ctx.r[7].s32 as i64;
	// 8238F64C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8238F650: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8238F654: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8238F658: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8238F65C: 4098001C  bge cr6, 0x8238f678
	if !ctx.cr[6].lt {
	pc = 0x8238F678; continue 'dispatch;
	}
	// 8238F660: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8238F664: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8238F668: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8238F66C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8238F670: EC2C037C  fnmsubs f1, f12, f13, f0
	ctx.f[1].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8238F674: 48000018  b 0x8238f68c
	pc = 0x8238F68C; continue 'dispatch;
            }
            0x8238F678 => {
    //   block [0x8238F678..0x8238F68C)
	// 8238F678: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8238F67C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8238F680: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8238F684: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8238F688: EC2C037A  fmadds f1, f12, f13, f0
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	pc = 0x8238F68C; continue 'dispatch;
            }
            0x8238F68C => {
    //   block [0x8238F68C..0x8238F69C)
	// 8238F68C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8238F690: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238F694: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238F698: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238F6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238F6A0 size=172
    let mut pc: u32 = 0x8238F6A0;
    'dispatch: loop {
        match pc {
            0x8238F6A0 => {
    //   block [0x8238F6A0..0x8238F6C8)
	// 8238F6A0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8238F6A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8238F6A8: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238F6AC: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238F6B0: 2B0B0030  cmplwi cr6, r11, 0x30
	ctx.cr[6].compare_u32(ctx.r[11].u32, 48 as u32, &mut ctx.xer);
	// 8238F6B4: 409A0014  bne cr6, 0x8238f6c8
	if !ctx.cr[6].eq {
	pc = 0x8238F6C8; continue 'dispatch;
	}
	// 8238F6B8: 896A0001  lbz r11, 1(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 8238F6BC: 2B0B0078  cmplwi cr6, r11, 0x78
	ctx.cr[6].compare_u32(ctx.r[11].u32, 120 as u32, &mut ctx.xer);
	// 8238F6C0: 409A0008  bne cr6, 0x8238f6c8
	if !ctx.cr[6].eq {
	pc = 0x8238F6C8; continue 'dispatch;
	}
	// 8238F6C4: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	pc = 0x8238F6C8; continue 'dispatch;
            }
            0x8238F6C8 => {
    //   block [0x8238F6C8..0x8238F6E4)
	// 8238F6C8: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238F6CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8238F6D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238F6D4: 41820010  beq 0x8238f6e4
	if ctx.cr[0].eq {
	pc = 0x8238F6E4; continue 'dispatch;
	}
	// 8238F6D8: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 8238F6DC: 2B090020  cmplwi cr6, r9, 0x20
	ctx.cr[6].compare_u32(ctx.r[9].u32, 32 as u32, &mut ctx.xer);
	// 8238F6E0: 4198FFE8  blt cr6, 0x8238f6c8
	if ctx.cr[6].lt {
	pc = 0x8238F6C8; continue 'dispatch;
	}
	pc = 0x8238F6E4; continue 'dispatch;
            }
            0x8238F6E4 => {
    //   block [0x8238F6E4..0x8238F6F0)
	// 8238F6E4: 2B0B0061  cmplwi cr6, r11, 0x61
	ctx.cr[6].compare_u32(ctx.r[11].u32, 97 as u32, &mut ctx.xer);
	// 8238F6E8: 41980008  blt cr6, 0x8238f6f0
	if ctx.cr[6].lt {
	pc = 0x8238F6F0; continue 'dispatch;
	}
	// 8238F6EC: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	pc = 0x8238F6F0; continue 'dispatch;
            }
            0x8238F6F0 => {
    //   block [0x8238F6F0..0x8238F700)
	// 8238F6F0: 2B0B0030  cmplwi cr6, r11, 0x30
	ctx.cr[6].compare_u32(ctx.r[11].u32, 48 as u32, &mut ctx.xer);
	// 8238F6F4: 4198000C  blt cr6, 0x8238f700
	if ctx.cr[6].lt {
	pc = 0x8238F700; continue 'dispatch;
	}
	// 8238F6F8: 2B0B0039  cmplwi cr6, r11, 0x39
	ctx.cr[6].compare_u32(ctx.r[11].u32, 57 as u32, &mut ctx.xer);
	// 8238F6FC: 40990010  ble cr6, 0x8238f70c
	if !ctx.cr[6].gt {
	pc = 0x8238F70C; continue 'dispatch;
	}
	pc = 0x8238F700; continue 'dispatch;
            }
            0x8238F700 => {
    //   block [0x8238F700..0x8238F70C)
	// 8238F700: 392BFFBF  addi r9, r11, -0x41
	ctx.r[9].s64 = ctx.r[11].s64 + -65;
	// 8238F704: 2B090005  cmplwi cr6, r9, 5
	ctx.cr[6].compare_u32(ctx.r[9].u32, 5 as u32, &mut ctx.xer);
	// 8238F708: 41990030  bgt cr6, 0x8238f738
	if ctx.cr[6].gt {
	pc = 0x8238F738; continue 'dispatch;
	}
	pc = 0x8238F70C; continue 'dispatch;
            }
            0x8238F70C => {
    //   block [0x8238F70C..0x8238F738)
	// 8238F70C: 39200041  li r9, 0x41
	ctx.r[9].s64 = 65;
	// 8238F710: 54672036  slwi r7, r3, 4
	ctx.r[7].u32 = ctx.r[3].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8238F714: 7D295810  subfc r9, r9, r11
	ctx.xer.ca = ctx.r[11].u32 >= ctx.r[9].u32;
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8238F718: 7D294910  subfe r9, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 8238F71C: 552907F8  rlwinm r9, r9, 0, 0x1f, 0x1c
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8238F720: 39290037  addi r9, r9, 0x37
	ctx.r[9].s64 = ctx.r[9].s64 + 55;
	// 8238F724: 7D295850  subf r9, r9, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8238F728: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238F72C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8238F730: 7D233B78  or r3, r9, r7
	ctx.r[3].u64 = ctx.r[9].u64 | ctx.r[7].u64;
	// 8238F734: 4BFFFFB0  b 0x8238f6e4
	pc = 0x8238F6E4; continue 'dispatch;
            }
            0x8238F738 => {
    //   block [0x8238F738..0x8238F744)
	// 8238F738: 2B0B002F  cmplwi cr6, r11, 0x2f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 47 as u32, &mut ctx.xer);
	// 8238F73C: 419A0008  beq cr6, 0x8238f744
	if ctx.cr[6].eq {
	pc = 0x8238F744; continue 'dispatch;
	}
	// 8238F740: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	pc = 0x8238F744; continue 'dispatch;
            }
            0x8238F744 => {
    //   block [0x8238F744..0x8238F74C)
	// 8238F744: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8238F748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238F750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8238F750 size=284
    let mut pc: u32 = 0x8238F750;
    'dispatch: loop {
        match pc {
            0x8238F750 => {
    //   block [0x8238F750..0x8238F76C)
	// 8238F750: 89430019  lbz r10, 0x19(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(25 as u32) ) } as u64;
	// 8238F754: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8238F758: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8238F75C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8238F760: 4098000C  bge cr6, 0x8238f76c
	if !ctx.cr[6].lt {
	pc = 0x8238F76C; continue 'dispatch;
	}
	// 8238F764: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8238F768: 48000010  b 0x8238f778
	pc = 0x8238F778; continue 'dispatch;
            }
            0x8238F76C => {
    //   block [0x8238F76C..0x8238F778)
	// 8238F76C: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8238F770: 40990008  ble cr6, 0x8238f778
	if !ctx.cr[6].gt {
	pc = 0x8238F778; continue 'dispatch;
	}
	// 8238F774: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x8238F778; continue 'dispatch;
            }
            0x8238F778 => {
    //   block [0x8238F778..0x8238F86C)
	// 8238F778: 81430020  lwz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 8238F77C: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 8238F780: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238F784: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 8238F788: 1D6B0038  mulli r11, r11, 0x38
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 56 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8238F78C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8238F790: 3D408283  lis r10, -0x7d7d
	ctx.r[10].s64 = -2105344000;
	// 8238F794: 394A524C  addi r10, r10, 0x524c
	ctx.r[10].s64 = ctx.r[10].s64 + 21068;
	// 8238F798: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8238F79C: A12B0004  lhz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8238F7A0: 99230015  stb r9, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[9].u8 ) };
	// 8238F7A4: A12B0018  lhz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8238F7A8: 89030015  lbz r8, 0x15(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(21 as u32) ) } as u64;
	// 8238F7AC: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8238F7B0: 5508103E  rotlwi r8, r8, 2
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(2)) as u64;
	// 8238F7B4: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 8238F7B8: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238F7BC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8238F7C0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8238F7C4: D0030058  stfs f0, 0x58(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238F7C8: A12B001A  lhz r9, 0x1a(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(26 as u32) ) } as u64;
	// 8238F7CC: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8238F7D0: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 8238F7D4: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8238F7D8: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238F7DC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8238F7E0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8238F7E4: D003005C  stfs f0, 0x5c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238F7E8: A12B0022  lhz r9, 0x22(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(34 as u32) ) } as u64;
	// 8238F7EC: B123001A  sth r9, 0x1a(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(26 as u32), ctx.r[9].u16 ) };
	// 8238F7F0: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8238F7F4: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 8238F7F8: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8238F7FC: A12B001C  lhz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8238F800: A14B001E  lhz r10, 0x1e(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(30 as u32) ) } as u64;
	// 8238F804: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8238F808: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8238F80C: F921FFF8  std r9, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[9].u64 ) };
	// 8238F810: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 8238F814: C961FFF8  lfd f11, -8(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 8238F818: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238F81C: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 8238F820: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8238F824: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8238F828: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8238F82C: ED6B6824  fdivs f11, f11, f13
	ctx.f[11].f64 = ((ctx.f[11].f64 / ctx.f[13].f64) as f32) as f64;
	// 8238F830: D1630024  stfs f11, 0x24(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8238F834: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 8238F838: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8238F83C: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 8238F840: D1A3002C  stfs f13, 0x2c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8238F844: EDAC0032  fmuls f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8238F848: D1A30030  stfs f13, 0x30(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8238F84C: A96B0020  lha r11, 0x20(r11)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as i16) as i64;
	// 8238F850: F961FFF8  std r11, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u64 ) };
	// 8238F854: C981FFF8  lfd f12, -8(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 8238F858: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8238F85C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8238F860: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8238F864: D0030080  stfs f0, 0x80(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8238F868: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238F870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8238F870 size=8
    let mut pc: u32 = 0x8238F870;
    'dispatch: loop {
        match pc {
            0x8238F870 => {
    //   block [0x8238F870..0x8238F878)
	// 8238F870: 98830018  stb r4, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[4].u8 ) };
	// 8238F874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238F878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238F878 size=180
    let mut pc: u32 = 0x8238F878;
    'dispatch: loop {
        match pc {
            0x8238F878 => {
    //   block [0x8238F878..0x8238F92C)
	// 8238F878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238F87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238F880: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238F884: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238F888: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8238F88C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8238F890: 392B8C60  addi r9, r11, -0x73a0
	ctx.r[9].s64 = ctx.r[11].s64 + -29600;
	// 8238F894: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8238F898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8238F89C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8238F8A0: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238F8A4: 395F0060  addi r10, r31, 0x60
	ctx.r[10].s64 = ctx.r[31].s64 + 96;
	// 8238F8A8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8238F8AC: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8238F8B0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8238F8B4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8238F8B8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 8238F8BC: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8238F8C0: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 8238F8C4: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8238F8C8: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238F930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8238F930 size=384
    let mut pc: u32 = 0x8238F930;
    'dispatch: loop {
        match pc {
            0x8238F930 => {
    //   block [0x8238F930..0x8238F98C)
	// 8238F930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238F934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8238F938: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8238F93C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238F940: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8238F944: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238F948: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8238F94C: 40990150  ble cr6, 0x8238fa9c
	if !ctx.cr[6].gt {
	pc = 0x8238FA9C; continue 'dispatch;
	}
	// 8238F950: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 8238F954: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8238F958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8238F95C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238F960: 4E800421  bctrl
	ctx.lr = 0x8238F964;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238F964: 397F007F  addi r11, r31, 0x7f
	ctx.r[11].s64 = ctx.r[31].s64 + 127;
	// 8238F968: 395F0180  addi r10, r31, 0x180
	ctx.r[10].s64 = ctx.r[31].s64 + 384;
	// 8238F96C: 55690030  rlwinm r9, r11, 0, 0, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8238F970: 554A0030  rlwinm r10, r10, 0, 0, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8238F974: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8238F978: 7D695050  subf r11, r9, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 8238F97C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8238F980: 419A007C  beq cr6, 0x8238f9fc
	if ctx.cr[6].eq {
	pc = 0x8238F9FC; continue 'dispatch;
	}
	// 8238F984: 7C00FA2C  dcbt 0, r31
	// 8238F988: 48000074  b 0x8238f9fc
	pc = 0x8238F9FC; continue 'dispatch;
            }
            0x8238F98C => {
    //   block [0x8238F98C..0x8238F9FC)
	// 8238F98C: 3960FF80  li r11, -0x80
	ctx.r[11].s64 = -128;
	// 8238F990: 7C0B57EC  dcbz r11, r10
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[10].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8238F994: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238F998: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 8238F99C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8238F9A0: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 8238F9A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238F9A8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8238F9AC: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 8238F9B0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238F9B4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8238F9B8: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 8238F9BC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238F9C0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8238F9C4: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 8238F9C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238F9CC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8238F9D0: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 8238F9D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238F9D8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8238F9DC: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 8238F9E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238F9E4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8238F9E8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8238F9EC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238F9F0: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 8238F9F4: 394AFC00  addi r10, r10, -0x400
	ctx.r[10].s64 = ctx.r[10].s64 + -1024;
	// 8238F9F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x8238F9FC; continue 'dispatch;
            }
            0x8238F9FC => {
    //   block [0x8238F9FC..0x8238FA50)
	// 8238F9FC: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 8238FA00: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8238FA04: 4098FF88  bge cr6, 0x8238f98c
	if !ctx.cr[6].lt {
	pc = 0x8238F98C; continue 'dispatch;
	}
	// 8238FA08: 556BCF7E  rlwinm r11, r11, 0x19, 0x1d, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 8238FA0C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8238FA10: 419A007C  beq cr6, 0x8238fa8c
	if ctx.cr[6].eq {
	pc = 0x8238FA8C; continue 'dispatch;
	}
	// 8238FA14: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8238FA18: 419A0068  beq cr6, 0x8238fa80
	if ctx.cr[6].eq {
	pc = 0x8238FA80; continue 'dispatch;
	}
	// 8238FA1C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8238FA20: 419A0054  beq cr6, 0x8238fa74
	if ctx.cr[6].eq {
	pc = 0x8238FA74; continue 'dispatch;
	}
	// 8238FA24: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 8238FA28: 419A0040  beq cr6, 0x8238fa68
	if ctx.cr[6].eq {
	pc = 0x8238FA68; continue 'dispatch;
	}
	// 8238FA2C: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 8238FA30: 419A002C  beq cr6, 0x8238fa5c
	if ctx.cr[6].eq {
	pc = 0x8238FA5C; continue 'dispatch;
	}
	// 8238FA34: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 8238FA38: 419A0018  beq cr6, 0x8238fa50
	if ctx.cr[6].eq {
	pc = 0x8238FA50; continue 'dispatch;
	}
	// 8238FA3C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 8238FA40: 409A0054  bne cr6, 0x8238fa94
	if !ctx.cr[6].eq {
	pc = 0x8238FA94; continue 'dispatch;
	}
	// 8238FA44: 3960FC80  li r11, -0x380
	ctx.r[11].s64 = -896;
	// 8238FA48: 7C0B57EC  dcbz r11, r10
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[10].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8238FA4C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8238FA50; continue 'dispatch;
            }
            0x8238FA50 => {
    //   block [0x8238FA50..0x8238FA5C)
	// 8238FA50: 3960FD00  li r11, -0x300
	ctx.r[11].s64 = -768;
	// 8238FA54: 7C0B57EC  dcbz r11, r10
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[10].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8238FA58: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8238FA5C; continue 'dispatch;
            }
            0x8238FA5C => {
    //   block [0x8238FA5C..0x8238FA68)
	// 8238FA5C: 3960FD80  li r11, -0x280
	ctx.r[11].s64 = -640;
	// 8238FA60: 7C0B57EC  dcbz r11, r10
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[10].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8238FA64: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8238FA68; continue 'dispatch;
            }
            0x8238FA68 => {
    //   block [0x8238FA68..0x8238FA74)
	// 8238FA68: 3960FE00  li r11, -0x200
	ctx.r[11].s64 = -512;
	// 8238FA6C: 7C0B57EC  dcbz r11, r10
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[10].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8238FA70: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8238FA74; continue 'dispatch;
            }
            0x8238FA74 => {
    //   block [0x8238FA74..0x8238FA80)
	// 8238FA74: 3960FE80  li r11, -0x180
	ctx.r[11].s64 = -384;
	// 8238FA78: 7C0B57EC  dcbz r11, r10
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[10].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8238FA7C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8238FA80; continue 'dispatch;
            }
            0x8238FA80 => {
    //   block [0x8238FA80..0x8238FA8C)
	// 8238FA80: 3960FF00  li r11, -0x100
	ctx.r[11].s64 = -256;
	// 8238FA84: 7C0B57EC  dcbz r11, r10
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[10].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 8238FA88: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8238FA8C; continue 'dispatch;
            }
            0x8238FA8C => {
    //   block [0x8238FA8C..0x8238FA94)
	// 8238FA8C: 3960FF80  li r11, -0x80
	ctx.r[11].s64 = -128;
	// 8238FA90: 7C0B57EC  dcbz r11, r10
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[10].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	pc = 0x8238FA94; continue 'dispatch;
            }
            0x8238FA94 => {
    //   block [0x8238FA94..0x8238FA9C)
	// 8238FA94: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 8238FA98: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x8238FA9C; continue 'dispatch;
            }
            0x8238FA9C => {
    //   block [0x8238FA9C..0x8238FAB0)
	// 8238FA9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8238FAA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8238FAA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8238FAA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8238FAAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8238FAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8238FAB0 size=4220
    let mut pc: u32 = 0x8238FAB0;
    'dispatch: loop {
        match pc {
            0x8238FAB0 => {
    //   block [0x8238FAB0..0x8238FAF4)
	// 8238FAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8238FAB4: 481A55F1  bl 0x825350a4
	ctx.lr = 0x8238FAB8;
	sub_82535080(ctx, base);
	// 8238FAB8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8238FABC: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 8238FAC0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8238FAC4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8238FAC8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8238FACC: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 8238FAD0: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FAD4: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 8238FAD8: 7F58D378  mr r24, r26
	ctx.r[24].u64 = ctx.r[26].u64;
	// 8238FADC: 3884FFDD  addi r4, r4, -0x23
	ctx.r[4].s64 = ctx.r[4].s64 + -35;
	// 8238FAE0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 8238FAE4: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 8238FAE8: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 8238FAEC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 8238FAF0: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	pc = 0x8238FAF4; continue 'dispatch;
            }
            0x8238FAF4 => {
    //   block [0x8238FAF4..0x8238FB14)
	// 8238FAF4: 89490000  lbz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FAF8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8238FAFC: 390AFF9F  addi r8, r10, -0x61
	ctx.r[8].s64 = ctx.r[10].s64 + -97;
	// 8238FB00: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8238FB04: 2B080019  cmplwi cr6, r8, 0x19
	ctx.cr[6].compare_u32(ctx.r[8].u32, 25 as u32, &mut ctx.xer);
	// 8238FB08: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8238FB0C: 41990008  bgt cr6, 0x8238fb14
	if ctx.cr[6].gt {
	pc = 0x8238FB14; continue 'dispatch;
	}
	// 8238FB10: 396AFFE0  addi r11, r10, -0x20
	ctx.r[11].s64 = ctx.r[10].s64 + -32;
	pc = 0x8238FB14; continue 'dispatch;
            }
            0x8238FB14 => {
    //   block [0x8238FB14..0x8238FB90)
	// 8238FB14: 396BFFDD  addi r11, r11, -0x23
	ctx.r[11].s64 = ctx.r[11].s64 + -35;
	// 8238FB18: 2B0B0037  cmplwi cr6, r11, 0x37
	ctx.cr[6].compare_u32(ctx.r[11].u32, 55 as u32, &mut ctx.xer);
	// 8238FB1C: 41990FFC  bgt cr6, 0x82390b18
	if ctx.cr[6].gt {
	pc = 0x82390B18; continue 'dispatch;
	}
	// 8238FB20: 3D80820C  lis r12, -0x7df4
	ctx.r[12].s64 = -2113142784;
	// 8238FB24: 398CDC30  addi r12, r12, -0x23d0
	ctx.r[12].s64 = ctx.r[12].s64 + -9168;
	// 8238FB28: 5560083C  slwi r0, r11, 1
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8238FB2C: 7C0C022E  lhzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8238FB30: 3D808239  lis r12, -0x7dc7
	ctx.r[12].s64 = -2110193664;
	// 8238FB34: 398CFB48  addi r12, r12, -0x4b8
	ctx.r[12].s64 = ctx.r[12].s64 + -1208;
	// 8238FB38: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 8238FB3C: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 8238FB40: 60000000  nop
	// 8238FB44: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 8238FB48: 60C60002  ori r6, r6, 2
	ctx.r[6].u64 = ctx.r[6].u64 | 2;
	// 8238FB4C: 4BFFFFA8  b 0x8238faf4
	pc = 0x8238FAF4; continue 'dispatch;
	// 8238FB50: 60C60001  ori r6, r6, 1
	ctx.r[6].u64 = ctx.r[6].u64 | 1;
	// 8238FB54: 4BFFFFA0  b 0x8238faf4
	pc = 0x8238FAF4; continue 'dispatch;
	// 8238FB58: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 8238FB5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238FB60: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8238FB64: 4BFFF99D  bl 0x8238f500
	ctx.lr = 0x8238FB68;
	sub_8238F500(ctx, base);
	// 8238FB68: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238FB6C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8238FB70: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FB74: 2B0A002E  cmplwi cr6, r10, 0x2e
	ctx.cr[6].compare_u32(ctx.r[10].u32, 46 as u32, &mut ctx.xer);
	// 8238FB78: 409A0018  bne cr6, 0x8238fb90
	if !ctx.cr[6].eq {
	pc = 0x8238FB90; continue 'dispatch;
	}
	// 8238FB7C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8238FB80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238FB84: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8238FB88: 4BFFF979  bl 0x8238f500
	ctx.lr = 0x8238FB8C;
	sub_8238F500(ctx, base);
	// 8238FB8C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
            }
            0x8238FB90 => {
    //   block [0x8238FB90..0x8238FBDC)
	// 8238FB90: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8238FB94: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8238FB98: 4098FF5C  bge cr6, 0x8238faf4
	if !ctx.cr[6].lt {
	pc = 0x8238FAF4; continue 'dispatch;
	}
	// 8238FB9C: 60C60002  ori r6, r6, 2
	ctx.r[6].u64 = ctx.r[6].u64 | 2;
	// 8238FBA0: 7CA500D0  neg r5, r5
	ctx.r[5].s64 = -ctx.r[5].s64;
	// 8238FBA4: 4BFFFF50  b 0x8238faf4
	pc = 0x8238FAF4; continue 'dispatch;
	// 8238FBA8: 2B0A006C  cmplwi cr6, r10, 0x6c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 108 as u32, &mut ctx.xer);
	// 8238FBAC: 409A0628  bne cr6, 0x823901d4
	if !ctx.cr[6].eq {
	pc = 0x823901D4; continue 'dispatch;
	}
	// 8238FBB0: 89690000  lbz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FBB4: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 8238FBB8: 419805E0  blt cr6, 0x82390198
	if ctx.cr[6].lt {
	pc = 0x82390198; continue 'dispatch;
	}
	// 8238FBBC: 419A05B4  beq cr6, 0x82390170
	if ctx.cr[6].eq {
	pc = 0x82390170; continue 'dispatch;
	}
	// 8238FBC0: 2B040003  cmplwi cr6, r4, 3
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3 as u32, &mut ctx.xer);
	// 8238FBC4: 40980F54  bge cr6, 0x82390b18
	if !ctx.cr[6].lt {
	pc = 0x82390B18; continue 'dispatch;
	}
	// 8238FBC8: 2B0B006C  cmplwi cr6, r11, 0x6c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 108 as u32, &mut ctx.xer);
	// 8238FBCC: 409A0010  bne cr6, 0x8238fbdc
	if !ctx.cr[6].eq {
	pc = 0x8238FBDC; continue 'dispatch;
	}
	// 8238FBD0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8238FBD4: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 8238FBD8: 4BFFFF1C  b 0x8238faf4
	pc = 0x8238FAF4; continue 'dispatch;
            }
            0x8238FBDC => {
    //   block [0x8238FBDC..0x8238FC24)
	// 8238FBDC: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 8238FBE0: 4BFFFF14  b 0x8238faf4
	pc = 0x8238FAF4; continue 'dispatch;
	// 8238FBE4: 81790010  lwz r11, 0x10(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238FBE8: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8238FBEC: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 8238FBF0: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8238FBF4: B13E0002  sth r9, 2(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(2 as u32), ctx.r[9].u16 ) };
	// 8238FBF8: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 8238FBFC: B17E0000  sth r11, 0(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 8238FC00: 48000F18  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
	// 8238FC04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8238FC08: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 8238FC0C: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8238FC10: 41980014  blt cr6, 0x8238fc24
	if ctx.cr[6].lt {
	pc = 0x8238FC24; continue 'dispatch;
	}
	// 8238FC14: 409A002C  bne cr6, 0x8238fc40
	if !ctx.cr[6].eq {
	pc = 0x8238FC40; continue 'dispatch;
	}
	// 8238FC18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238FC1C: 4BFFF965  bl 0x8238f580
	ctx.lr = 0x8238FC20;
	sub_8238F580(ctx, base);
	// 8238FC20: 48000028  b 0x8238fc48
	pc = 0x8238FC48; continue 'dispatch;
            }
            0x8238FC24 => {
    //   block [0x8238FC24..0x8238FC40)
	// 8238FC24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FC28: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 8238FC2C: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8238FC30: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8238FC34: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238FC38: C80BFFF8  lfd f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	// 8238FC3C: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	pc = 0x8238FC40; continue 'dispatch;
            }
            0x8238FC40 => {
    //   block [0x8238FC40..0x8238FC48)
	// 8238FC40: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 8238FC44: 419A0ED4  beq cr6, 0x82390b18
	if ctx.cr[6].eq {
	pc = 0x82390B18; continue 'dispatch;
	}
	pc = 0x8238FC48; continue 'dispatch;
            }
            0x8238FC48 => {
    //   block [0x8238FC48..0x8238FC70)
	// 8238FC48: D039006C  stfs f1, 0x6c(r25)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8238FC4C: 48000ECC  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
	// 8238FC50: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 8238FC54: 409A0088  bne cr6, 0x8238fcdc
	if !ctx.cr[6].eq {
	pc = 0x8238FCDC; continue 'dispatch;
	}
	// 8238FC58: 89690000  lbz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FC5C: 2B0B0039  cmplwi cr6, r11, 0x39
	ctx.cr[6].compare_u32(ctx.r[11].u32, 57 as u32, &mut ctx.xer);
	// 8238FC60: 41990010  bgt cr6, 0x8238fc70
	if ctx.cr[6].gt {
	pc = 0x8238FC70; continue 'dispatch;
	}
	// 8238FC64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238FC68: 4BFFF899  bl 0x8238f500
	ctx.lr = 0x8238FC6C;
	sub_8238F500(ctx, base);
	// 8238FC6C: 480000A8  b 0x8238fd14
	pc = 0x8238FD14; continue 'dispatch;
            }
            0x8238FC70 => {
    //   block [0x8238FC70..0x8238FC84)
	// 8238FC70: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 8238FC74: 2B0B0061  cmplwi cr6, r11, 0x61
	ctx.cr[6].compare_u32(ctx.r[11].u32, 97 as u32, &mut ctx.xer);
	// 8238FC78: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8238FC7C: 41980008  blt cr6, 0x8238fc84
	if ctx.cr[6].lt {
	pc = 0x8238FC84; continue 'dispatch;
	}
	// 8238FC80: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	pc = 0x8238FC84; continue 'dispatch;
            }
            0x8238FC84 => {
    //   block [0x8238FC84..0x8238FCB4)
	// 8238FC84: 2B0B0041  cmplwi cr6, r11, 0x41
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65 as u32, &mut ctx.xer);
	// 8238FC88: 419A004C  beq cr6, 0x8238fcd4
	if ctx.cr[6].eq {
	pc = 0x8238FCD4; continue 'dispatch;
	}
	// 8238FC8C: 2B0B0042  cmplwi cr6, r11, 0x42
	ctx.cr[6].compare_u32(ctx.r[11].u32, 66 as u32, &mut ctx.xer);
	// 8238FC90: 419A003C  beq cr6, 0x8238fccc
	if ctx.cr[6].eq {
	pc = 0x8238FCCC; continue 'dispatch;
	}
	// 8238FC94: 2B0B004D  cmplwi cr6, r11, 0x4d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 77 as u32, &mut ctx.xer);
	// 8238FC98: 419A002C  beq cr6, 0x8238fcc4
	if ctx.cr[6].eq {
	pc = 0x8238FCC4; continue 'dispatch;
	}
	// 8238FC9C: 2B0B004E  cmplwi cr6, r11, 0x4e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 78 as u32, &mut ctx.xer);
	// 8238FCA0: 419A001C  beq cr6, 0x8238fcbc
	if ctx.cr[6].eq {
	pc = 0x8238FCBC; continue 'dispatch;
	}
	// 8238FCA4: 2B0B0053  cmplwi cr6, r11, 0x53
	ctx.cr[6].compare_u32(ctx.r[11].u32, 83 as u32, &mut ctx.xer);
	// 8238FCA8: 419A000C  beq cr6, 0x8238fcb4
	if ctx.cr[6].eq {
	pc = 0x8238FCB4; continue 'dispatch;
	}
	// 8238FCAC: 3860000D  li r3, 0xd
	ctx.r[3].s64 = 13;
	// 8238FCB0: 48000064  b 0x8238fd14
	pc = 0x8238FD14; continue 'dispatch;
            }
            0x8238FCB4 => {
    //   block [0x8238FCB4..0x8238FCBC)
	// 8238FCB4: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 8238FCB8: 4800005C  b 0x8238fd14
	pc = 0x8238FD14; continue 'dispatch;
            }
            0x8238FCBC => {
    //   block [0x8238FCBC..0x8238FCC4)
	// 8238FCBC: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 8238FCC0: 48000054  b 0x8238fd14
	pc = 0x8238FD14; continue 'dispatch;
            }
            0x8238FCC4 => {
    //   block [0x8238FCC4..0x8238FCCC)
	// 8238FCC4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 8238FCC8: 4800004C  b 0x8238fd14
	pc = 0x8238FD14; continue 'dispatch;
            }
            0x8238FCCC => {
    //   block [0x8238FCCC..0x8238FCD4)
	// 8238FCCC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8238FCD0: 48000044  b 0x8238fd14
	pc = 0x8238FD14; continue 'dispatch;
            }
            0x8238FCD4 => {
    //   block [0x8238FCD4..0x8238FCDC)
	// 8238FCD4: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 8238FCD8: 4800003C  b 0x8238fd14
	pc = 0x8238FD14; continue 'dispatch;
            }
            0x8238FCDC => {
    //   block [0x8238FCDC..0x8238FD10)
	// 8238FCDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FCE0: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 8238FCE4: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 8238FCE8: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8238FCEC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8238FCF0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238FCF4: 409A001C  bne cr6, 0x8238fd10
	if !ctx.cr[6].eq {
	pc = 0x8238FD10; continue 'dispatch;
	}
	// 8238FCF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8238FCFC: 808BFFFC  lwz r4, -4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8238FD00: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8238FD04: 4BFFF05D  bl 0x8238ed60
	ctx.lr = 0x8238FD08;
	sub_8238ED60(ctx, base);
	// 8238FD08: 3B000002  li r24, 2
	ctx.r[24].s64 = 2;
	// 8238FD0C: 48000E0C  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
            }
            0x8238FD10 => {
    //   block [0x8238FD10..0x8238FD14)
	// 8238FD10: 806BFFFC  lwz r3, -4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	pc = 0x8238FD14; continue 'dispatch;
            }
            0x8238FD14 => {
    //   block [0x8238FD14..0x8238FD6C)
	// 8238FD14: 90790070  stw r3, 0x70(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 8238FD18: 48000E00  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
	// 8238FD1C: 2B0A0043  cmplwi cr6, r10, 0x43
	ctx.cr[6].compare_u32(ctx.r[10].u32, 67 as u32, &mut ctx.xer);
	// 8238FD20: 409A00F4  bne cr6, 0x8238fe14
	if !ctx.cr[6].eq {
	pc = 0x8238FE14; continue 'dispatch;
	}
	// 8238FD24: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 8238FD28: 41980090  blt cr6, 0x8238fdb8
	if ctx.cr[6].lt {
	pc = 0x8238FDB8; continue 'dispatch;
	}
	// 8238FD2C: 419A0040  beq cr6, 0x8238fd6c
	if ctx.cr[6].eq {
	pc = 0x8238FD6C; continue 'dispatch;
	}
	// 8238FD30: 2B040003  cmplwi cr6, r4, 3
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3 as u32, &mut ctx.xer);
	// 8238FD34: 40980DE4  bge cr6, 0x82390b18
	if !ctx.cr[6].lt {
	pc = 0x82390B18; continue 'dispatch;
	}
	// 8238FD38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FD3C: 39590060  addi r10, r25, 0x60
	ctx.r[10].s64 = ctx.r[25].s64 + 96;
	// 8238FD40: 392B0007  addi r9, r11, 7
	ctx.r[9].s64 = ctx.r[11].s64 + 7;
	// 8238FD44: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8238FD48: 552A0038  rlwinm r10, r9, 0, 0, 0x1c
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8238FD4C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8238FD50: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8238FD54: 814AFFFC  lwz r10, -4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8238FD58: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8238FD5C: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8238FD60: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 8238FD64: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 8238FD68: 48000DB0  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
            }
            0x8238FD6C => {
    //   block [0x8238FD6C..0x8238FDB8)
	// 8238FD6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238FD70: 4BFFF931  bl 0x8238f6a0
	ctx.lr = 0x8238FD74;
	sub_8238F6A0(ctx, base);
	// 8238FD74: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8238FD78: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 8238FD7C: 396BBF80  addi r11, r11, -0x4080
	ctx.r[11].s64 = ctx.r[11].s64 + -16512;
	pc = 0x8238FDB8; continue 'dispatch;
            }
            0x8238FDB8 => {
    //   block [0x8238FDB8..0x8238FE14)
	// 8238FDB8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8238FDBC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FDC0: 39200060  li r9, 0x60
	ctx.r[9].s64 = 96;
	// 8238FDC4: 396BBF80  addi r11, r11, -0x4080
	ctx.r[11].s64 = ctx.r[11].s64 + -16512;
	// 8238FDC8: 394A0007  addi r10, r10, 7
	ctx.r[10].s64 = ctx.r[10].s64 + 7;
	pc = 0x8238FE14; continue 'dispatch;
            }
            0x8238FE14 => {
    //   block [0x8238FE14..0x82390170)
	// 8238FE14: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 8238FE18: 41980050  blt cr6, 0x8238fe68
	if ctx.cr[6].lt {
	pc = 0x8238FE68; continue 'dispatch;
	}
	// 8238FE1C: 419A003C  beq cr6, 0x8238fe58
	if ctx.cr[6].eq {
	pc = 0x8238FE58; continue 'dispatch;
	}
	// 8238FE20: 2B040003  cmplwi cr6, r4, 3
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3 as u32, &mut ctx.xer);
	// 8238FE24: 40980060  bge cr6, 0x8238fe84
	if !ctx.cr[6].lt {
	pc = 0x8238FE84; continue 'dispatch;
	}
	// 8238FE28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FE2C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8238FE30: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 8238FE34: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8238FE38: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8238FE3C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238FE40: 896BFFFF  lbz r11, -1(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 8238FE44: 81390010  lwz r9, 0x10(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238FE48: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 8238FE4C: 7D6B4A2E  lhzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8238FE50: B15E0002  sth r10, 2(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(2 as u32), ctx.r[10].u16 ) };
	// 8238FE54: 4BFFFDA4  b 0x8238fbf8
	pc = 0x8238FBF8; continue 'dispatch;
	// 8238FE58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238FE5C: 4BFFF6A5  bl 0x8238f500
	ctx.lr = 0x8238FE60;
	sub_8238F500(ctx, base);
	// 8238FE60: 98790018  stb r3, 0x18(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(24 as u32), ctx.r[3].u8 ) };
	// 8238FE64: 48000020  b 0x8238fe84
	pc = 0x8238FE84; continue 'dispatch;
	// 8238FE68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FE6C: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 8238FE70: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8238FE74: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8238FE78: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238FE7C: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8238FE80: 99790018  stb r11, 0x18(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 8238FE84: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FE88: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8238FE8C: 88990018  lbz r4, 0x18(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 8238FE90: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FE94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8238FE98: 4E800421  bctrl
	ctx.lr = 0x8238FE9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8238FE9C: 48000C7C  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
	// 8238FEA0: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 8238FEA4: 409A008C  bne cr6, 0x8238ff30
	if !ctx.cr[6].eq {
	pc = 0x8238FF30; continue 'dispatch;
	}
	// 8238FEA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FEAC: 2B1D0002  cmplwi cr6, r29, 2
	ctx.cr[6].compare_u32(ctx.r[29].u32, 2 as u32, &mut ctx.xer);
	// 8238FEB0: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 8238FEB4: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8238FEB8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8238FEBC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238FEC0: 4098000C  bge cr6, 0x8238fecc
	if !ctx.cr[6].lt {
	pc = 0x8238FECC; continue 'dispatch;
	}
	// 8238FEC4: E88BFFFE  lwa r4, -4(r11)
	ctx.r[4].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as i32) as i64;
	// 8238FEC8: 48000008  b 0x8238fed0
	pc = 0x8238FED0; continue 'dispatch;
	// 8238FECC: E88BFFF8  ld r4, -8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	// 8238FED0: 2B0A0064  cmplwi cr6, r10, 0x64
	ctx.cr[6].compare_u32(ctx.r[10].u32, 100 as u32, &mut ctx.xer);
	// 8238FED4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8238FED8: 409A0014  bne cr6, 0x8238feec
	if !ctx.cr[6].eq {
	pc = 0x8238FEEC; continue 'dispatch;
	}
	// 8238FEDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8238FEE0: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8238FEE4: 4BFFF015  bl 0x8238eef8
	ctx.lr = 0x8238FEE8;
	sub_8238EEF8(ctx, base);
	// 8238FEE8: 4BFFFE20  b 0x8238fd08
	pc = 0x8238FD08; continue 'dispatch;
	// 8238FEEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8238FEF0: 4BFFF009  bl 0x8238eef8
	ctx.lr = 0x8238FEF4;
	sub_8238EEF8(ctx, base);
	// 8238FEF4: 89610070  lbz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8238FEF8: 81390010  lwz r9, 0x10(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238FEFC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8238FF00: 48000020  b 0x8238ff20
	pc = 0x8238FF20; continue 'dispatch;
	// 8238FF04: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8238FF08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8238FF0C: 7D6B4A2E  lhzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8238FF10: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 8238FF14: B17E0000  sth r11, 0(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 8238FF18: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 8238FF1C: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FF20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238FF24: 4082FFE0  bne 0x8238ff04
	if !ctx.cr[0].eq {
	pc = 0x8238FF04; continue 'dispatch;
	}
	// 8238FF28: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8238FF2C: 4BFFFCCC  b 0x8238fbf8
	pc = 0x8238FBF8; continue 'dispatch;
	// 8238FF30: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8238FF34: 409A0024  bne cr6, 0x8238ff58
	if !ctx.cr[6].eq {
	pc = 0x8238FF58; continue 'dispatch;
	}
	// 8238FF38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FF3C: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 8238FF40: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8238FF44: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8238FF48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238FF4C: C80BFFF8  lfd f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	// 8238FF50: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8238FF54: 4800000C  b 0x8238ff60
	pc = 0x8238FF60; continue 'dispatch;
	// 8238FF58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8238FF5C: 4BFFF625  bl 0x8238f580
	ctx.lr = 0x8238FF60;
	sub_8238F580(ctx, base);
	// 8238FF60: C0190044  lfs f0, 0x44(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8238FF64: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 8238FF68: D0190044  stfs f0, 0x44(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8238FF6C: 48000BAC  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
	// 8238FF70: 2B0A0046  cmplwi cr6, r10, 0x46
	ctx.cr[6].compare_u32(ctx.r[10].u32, 70 as u32, &mut ctx.xer);
	// 8238FF74: 419A0BA4  beq cr6, 0x82390b18
	if ctx.cr[6].eq {
	pc = 0x82390B18; continue 'dispatch;
	}
	// 8238FF78: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 8238FF7C: 409A0080  bne cr6, 0x8238fffc
	if !ctx.cr[6].eq {
	pc = 0x8238FFFC; continue 'dispatch;
	}
	// 8238FF80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FF84: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 8238FF88: 2B0A0066  cmplwi cr6, r10, 0x66
	ctx.cr[6].compare_u32(ctx.r[10].u32, 102 as u32, &mut ctx.xer);
	// 8238FF8C: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 8238FF90: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8238FF94: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8238FF98: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8238FF9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8238FFA0: C80BFFF8  lfd f0, -8(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	// 8238FFA4: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8238FFA8: 409A0014  bne cr6, 0x8238ffbc
	if !ctx.cr[6].eq {
	pc = 0x8238FFBC; continue 'dispatch;
	}
	// 8238FFAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8238FFB0: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8238FFB4: 4BFFF0FD  bl 0x8238f0b0
	ctx.lr = 0x8238FFB8;
	sub_8238F0B0(ctx, base);
	// 8238FFB8: 4BFFFD50  b 0x8238fd08
	pc = 0x8238FD08; continue 'dispatch;
	// 8238FFBC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8238FFC0: 4BFFF0F1  bl 0x8238f0b0
	ctx.lr = 0x8238FFC4;
	sub_8238F0B0(ctx, base);
	// 8238FFC4: 89610070  lbz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8238FFC8: 81390010  lwz r9, 0x10(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 8238FFCC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8238FFD0: 48000020  b 0x8238fff0
	pc = 0x8238FFF0; continue 'dispatch;
	// 8238FFD4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8238FFD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8238FFDC: 7D6B4A2E  lhzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8238FFE0: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 8238FFE4: B17E0000  sth r11, 0(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 8238FFE8: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 8238FFEC: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8238FFF0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8238FFF4: 4082FFE0  bne 0x8238ffd4
	if !ctx.cr[0].eq {
	pc = 0x8238FFD4; continue 'dispatch;
	}
	// 8238FFF8: 4BFFFF30  b 0x8238ff28
	pc = 0x8238FF28; continue 'dispatch;
	// 8238FFFC: 2B0A0066  cmplwi cr6, r10, 0x66
	ctx.cr[6].compare_u32(ctx.r[10].u32, 102 as u32, &mut ctx.xer);
	// 82390000: 409A0B18  bne cr6, 0x82390b18
	if !ctx.cr[6].eq {
	pc = 0x82390B18; continue 'dispatch;
	}
	// 82390004: 89690000  lbz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82390008: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 8239000C: 4198002C  blt cr6, 0x82390038
	if ctx.cr[6].lt {
	pc = 0x82390038; continue 'dispatch;
	}
	// 82390010: 409A0B08  bne cr6, 0x82390b18
	if !ctx.cr[6].eq {
	pc = 0x82390B18; continue 'dispatch;
	}
	// 82390014: 2B0B0030  cmplwi cr6, r11, 0x30
	ctx.cr[6].compare_u32(ctx.r[11].u32, 48 as u32, &mut ctx.xer);
	// 82390018: 4198000C  blt cr6, 0x82390024
	if ctx.cr[6].lt {
	pc = 0x82390024; continue 'dispatch;
	}
	// 8239001C: 2B0B0039  cmplwi cr6, r11, 0x39
	ctx.cr[6].compare_u32(ctx.r[11].u32, 57 as u32, &mut ctx.xer);
	// 82390020: 40990038  ble cr6, 0x82390058
	if !ctx.cr[6].gt {
	pc = 0x82390058; continue 'dispatch;
	}
	// 82390024: 2B0B002D  cmplwi cr6, r11, 0x2d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 45 as u32, &mut ctx.xer);
	// 82390028: 419A0030  beq cr6, 0x82390058
	if ctx.cr[6].eq {
	pc = 0x82390058; continue 'dispatch;
	}
	// 8239002C: 3B000004  li r24, 4
	ctx.r[24].s64 = 4;
	// 82390030: 9B590014  stb r26, 0x14(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(20 as u32), ctx.r[26].u8 ) };
	// 82390034: 48000AE4  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
	// 82390038: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8239003C: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 82390040: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82390044: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82390048: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8239004C: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82390050: 99790014  stb r11, 0x14(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82390054: 48000010  b 0x82390064
	pc = 0x82390064; continue 'dispatch;
	// 82390058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8239005C: 4BFFF4A5  bl 0x8238f500
	ctx.lr = 0x82390060;
	sub_8238F500(ctx, base);
	// 82390060: 98790014  stb r3, 0x14(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(20 as u32), ctx.r[3].u8 ) };
	// 82390064: 3B000004  li r24, 4
	ctx.r[24].s64 = 4;
	// 82390068: 48000AB0  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
	// 8239006C: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 82390070: 409A0028  bne cr6, 0x82390098
	if !ctx.cr[6].eq {
	pc = 0x82390098; continue 'dispatch;
	}
	// 82390074: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82390078: 3B000003  li r24, 3
	ctx.r[24].s64 = 3;
	// 8239007C: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 82390080: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82390084: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82390088: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8239008C: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82390090: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82390094: 48000A84  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
	// 82390098: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 8239009C: 41980054  blt cr6, 0x823900f0
	if ctx.cr[6].lt {
	pc = 0x823900F0; continue 'dispatch;
	}
	// 823900A0: 409A0A78  bne cr6, 0x82390b18
	if !ctx.cr[6].eq {
	pc = 0x82390B18; continue 'dispatch;
	}
	// 823900A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823900A8: 4BFFF459  bl 0x8238f500
	ctx.lr = 0x823900AC;
	sub_8238F500(ctx, base);
	// 823900AC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823900B0: 4180000C  blt 0x823900bc
	if ctx.cr[0].lt {
	pc = 0x823900BC; continue 'dispatch;
	}
	// 823900B4: 2F030018  cmpwi cr6, r3, 0x18
	ctx.cr[6].compare_i32(ctx.r[3].s32, 24, &mut ctx.xer);
	// 823900B8: 41980008  blt cr6, 0x823900c0
	if ctx.cr[6].lt {
	pc = 0x823900C0; continue 'dispatch;
	}
	// 823900BC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823900C0: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 823900C4: 3D608285  lis r11, -0x7d7b
	ctx.r[11].s64 = -2105212928;
	// 823900C8: 394ABF80  addi r10, r10, -0x4080
	ctx.r[10].s64 = ctx.r[10].s64 + -16512;
	// 823900CC: 396B9390  addi r11, r11, -0x6c70
	ctx.r[11].s64 = ctx.r[11].s64 + -27760;
	// 823900D0: 5469103A  slwi r9, r3, 2
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
            }
            0x82390170 => {
    //   block [0x82390170..0x82390198)
	// 82390170: 2B0B0030  cmplwi cr6, r11, 0x30
	ctx.cr[6].compare_u32(ctx.r[11].u32, 48 as u32, &mut ctx.xer);
	// 82390174: 4198000C  blt cr6, 0x82390180
	if ctx.cr[6].lt {
	pc = 0x82390180; continue 'dispatch;
	}
	// 82390178: 2B0B0039  cmplwi cr6, r11, 0x39
	ctx.cr[6].compare_u32(ctx.r[11].u32, 57 as u32, &mut ctx.xer);
	// 8239017C: 4099003C  ble cr6, 0x823901b8
	if !ctx.cr[6].gt {
	pc = 0x823901B8; continue 'dispatch;
	}
	// 82390180: 2B0B002D  cmplwi cr6, r11, 0x2d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 45 as u32, &mut ctx.xer);
	// 82390184: 419A0034  beq cr6, 0x823901b8
	if ctx.cr[6].eq {
	pc = 0x823901B8; continue 'dispatch;
	}
	// 82390188: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8239018C: 3B000004  li r24, 4
	ctx.r[24].s64 = 4;
	// 82390190: 99790014  stb r11, 0x14(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82390194: 48000984  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
            }
            0x82390198 => {
    //   block [0x82390198..0x823901D4)
	// 82390198: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8239019C: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 823901A0: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823901A4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823901A8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823901AC: C80BFFF8  lfd f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	// 823901B0: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823901B4: 4800000C  b 0x823901c0
	pc = 0x823901C0; continue 'dispatch;
	// 823901B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823901BC: 4BFFF3C5  bl 0x8238f580
	ctx.lr = 0x823901C0;
	sub_8238F580(ctx, base);
	// 823901C0: C0190040  lfs f0, 0x40(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823901C4: C1B90024  lfs f13, 0x24(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823901C8: EC0D007C  fnmsubs f0, f13, f1, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 823901CC: D0190040  stfs f0, 0x40(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 823901D0: 48000948  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
            }
            0x823901D4 => {
    //   block [0x823901D4..0x82390B18)
	// 823901D4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823901D8: 409A0024  bne cr6, 0x823901fc
	if !ctx.cr[6].eq {
	pc = 0x823901FC; continue 'dispatch;
	}
	// 823901DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823901E0: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 823901E4: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823901E8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823901EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823901F0: C80BFFF8  lfd f0, -8(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	// 823901F4: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823901F8: 4800000C  b 0x82390204
	pc = 0x82390204; continue 'dispatch;
	// 823901FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82390200: 4BFFF381  bl 0x8238f580
	ctx.lr = 0x82390204;
	sub_8238F580(ctx, base);
	// 82390204: C0190040  lfs f0, 0x40(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82390208: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 8239020C: 4BFFFFC0  b 0x823901cc
	pc = 0x823901CC; continue 'dispatch;
	// 82390210: 2B0A006D  cmplwi cr6, r10, 0x6d
	ctx.cr[6].compare_u32(ctx.r[10].u32, 109 as u32, &mut ctx.xer);
	// 82390214: 409A0068  bne cr6, 0x8239027c
	if !ctx.cr[6].eq {
	pc = 0x8239027C; continue 'dispatch;
	}
	// 82390218: 89690000  lbz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8239021C: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 82390220: 409A0034  bne cr6, 0x82390254
	if !ctx.cr[6].eq {
	pc = 0x82390254; continue 'dispatch;
	}
	// 82390224: 2B0B0030  cmplwi cr6, r11, 0x30
	ctx.cr[6].compare_u32(ctx.r[11].u32, 48 as u32, &mut ctx.xer);
	// 82390228: 4198000C  blt cr6, 0x82390234
	if ctx.cr[6].lt {
	pc = 0x82390234; continue 'dispatch;
	}
	// 8239022C: 2B0B0039  cmplwi cr6, r11, 0x39
	ctx.cr[6].compare_u32(ctx.r[11].u32, 57 as u32, &mut ctx.xer);
	// 82390230: 4099000C  ble cr6, 0x8239023c
	if !ctx.cr[6].gt {
	pc = 0x8239023C; continue 'dispatch;
	}
	// 82390234: 2B0B002D  cmplwi cr6, r11, 0x2d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 45 as u32, &mut ctx.xer);
	// 82390238: 409AFDF4  bne cr6, 0x8239002c
	if !ctx.cr[6].eq {
	pc = 0x8239002C; continue 'dispatch;
	}
	// 8239023C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82390240: 4BFFF341  bl 0x8238f580
	ctx.lr = 0x82390244;
	sub_8238F580(ctx, base);
	// 82390244: C0190024  lfs f0, 0x24(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82390248: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 8239024C: D0190088  stfs f0, 0x88(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82390250: 480008C8  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
	// 82390254: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82390258: 409AFFE4  bne cr6, 0x8239023c
	if !ctx.cr[6].eq {
	pc = 0x8239023C; continue 'dispatch;
	}
	// 8239025C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82390260: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 82390264: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82390268: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8239026C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82390270: C80BFFF8  lfd f0, -8(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	// 82390274: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82390278: 4BFFFFCC  b 0x82390244
	pc = 0x82390244; continue 'dispatch;
	// 8239027C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82390280: 409A0024  bne cr6, 0x823902a4
	if !ctx.cr[6].eq {
	pc = 0x823902A4; continue 'dispatch;
	}
	// 82390284: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82390288: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 8239028C: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82390290: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82390294: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82390298: C80BFFF8  lfd f0, -8(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	// 8239029C: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823902A0: 4800000C  b 0x823902ac
	pc = 0x823902AC; continue 'dispatch;
	// 823902A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823902A8: 4BFFF2D9  bl 0x8238f580
	ctx.lr = 0x823902AC;
	sub_8238F580(ctx, base);
	// 823902AC: D0390088  stfs f1, 0x88(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 823902B0: 48000868  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
	// 823902B4: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 823902B8: 409A0014  bne cr6, 0x823902cc
	if !ctx.cr[6].eq {
	pc = 0x823902CC; continue 'dispatch;
	}
	// 823902BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823902C0: 4BFFF241  bl 0x8238f500
	ctx.lr = 0x823902C4;
	sub_8238F500(ctx, base);
	// 823902C4: 98790016  stb r3, 0x16(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(22 as u32), ctx.r[3].u8 ) };
	// 823902C8: 48000850  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
	// 823902CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823902D0: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 823902D4: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823902D8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823902DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823902E0: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823902E4: 99790016  stb r11, 0x16(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(22 as u32), ctx.r[11].u8 ) };
	// 823902E8: 48000830  b 0x82390b18
	pc = 0x82390B18; continue 'dispatch;
	// 823902EC: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 823902F0: 409A0014  bne cr6, 0x82390304
	if !ctx.cr[6].eq {
	pc = 0x82390304; continue 'dispatch;
	}
	// 823902F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823902F8: 4BFFF209  bl 0x8238f500
	ctx.lr = 0x823902FC;
	sub_8238F500(ctx, base);
	// 823902FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82390300: 4800001C  b 0x8239031c
	pc = 0x8239031C; continue 'dispatch;
	// 82390304: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82390308: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 8239030C: 556B0038  rlwinm r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82390310: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82390314: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82390318: 808BFFFC  lwz r4, -4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8239031C: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82390320: 390BB6A0  addi r8, r11, -0x4960
	ctx.r[8].s64 = ctx.r[11].s64 + -18784;
	// 82390324: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 82390328: 48000DB9  bl 0x823910e0
	ctx.lr = 0x8239032C;
	sub_823910E0(ctx, base);
	// 8239032C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82390330: 8159001C  lwz r10, 0x1c(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 82390334: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82390338: C0190028  lfs f0, 0x28(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8239033C: C14BBA38  lfs f10, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82390340: A16A001E  lhz r11, 0x1e(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(30 as u32) ) } as u64;
	// 82390344: FD205090  fmr f9, f10
	ctx.f[9].f64 = ctx.f[10].f64;
	// 82390348: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8239034C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82390350: 3964FF06  addi r11, r4, -0xfa
	ctx.r[11].s64 = ctx.r[4].s64 + -250;
	// 82390354: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82390358: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8239035C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82390360: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82390364: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82390368: 41990040  bgt cr6, 0x823903a8
	if ctx.cr[6].gt {
	pc = 0x823903A8; continue 'dispatch;
	}
	// 8239036C: 480014FD  bl 0x82391868
	ctx.lr = 0x82390370;
	sub_82391868(ctx, base);
	// 82390370: 3963FFA6  addi r11, r3, -0x5a
	ctx.r[11].s64 = ctx.r[3].s64 + -90;
	// 82390374: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 82390378: 41990020  bgt cr6, 0x82390398
	if ctx.cr[6].gt {
	pc = 0x82390398; continue 'dispatch;
	}
	// 8239037C: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 82390380: 394300A6  addi r10, r3, 0xa6
	ctx.r[10].s64 = ctx.r[3].s64 + 166;
	// 82390384: 396B7DD0  addi r11, r11, 0x7dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 32208;
	// 82390388: 554A0DFC  rlwinm r10, r10, 1, 0x17, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 8239038C: 396B0440  addi r11, r11, 0x440
	ctx.r[11].s64 = ctx.r[11].s64 + 1088;
	// 82390390: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82390394: 48000008  b 0x8239039c
	pc = 0x8239039C; continue 'dispatch;
	// 82390398: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 8239039C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823903A0: C1AA478C  lfs f13, 0x478c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(18316 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823903A4: 48000110  b 0x823904b4
	pc = 0x823904B4; continue 'dispatch;
	// 823903A8: 3964FF1A  addi r11, r4, -0xe6
	ctx.r[11].s64 = ctx.r[4].s64 + -230;
	// 823903AC: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 823903B0: 4199002C  bgt cr6, 0x823903dc
	if ctx.cr[6].gt {
	pc = 0x823903DC; continue 'dispatch;
	}
	// 823903B4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 823903B8: 480014B1  bl 0x82391868
	ctx.lr = 0x823903BC;
	sub_82391868(ctx, base);
	// 823903BC: 2B030012  cmplwi cr6, r3, 0x12
	ctx.cr[6].compare_u32(ctx.r[3].u32, 18 as u32, &mut ctx.xer);
	// 823903C0: 409800E8  bge cr6, 0x823904a8
	if !ctx.cr[6].lt {
	pc = 0x823904A8; continue 'dispatch;
	}
	// 823903C4: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 823903C8: 2B030011  cmplwi cr6, r3, 0x11
	ctx.cr[6].compare_u32(ctx.r[3].u32, 17 as u32, &mut ctx.xer);
	// 823903CC: 396B7DD0  addi r11, r11, 0x7dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 32208;
	// 823903D0: 419A00C0  beq cr6, 0x82390490
	if ctx.cr[6].eq {
	pc = 0x82390490; continue 'dispatch;
	}
	// 823903D4: 546A083C  slwi r10, r3, 1
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823903D8: 480000C4  b 0x8239049c
	pc = 0x8239049C; continue 'dispatch;
	// 823903DC: 3964FF2E  addi r11, r4, -0xd2
	ctx.r[11].s64 = ctx.r[4].s64 + -210;
	// 823903E0: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 823903E4: 41990018  bgt cr6, 0x823903fc
	if ctx.cr[6].gt {
	pc = 0x823903FC; continue 'dispatch;
	}
	// 823903E8: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 823903EC: 3944002E  addi r10, r4, 0x2e
	ctx.r[10].s64 = ctx.r[4].s64 + 46;
	// 823903F0: 396B7DD0  addi r11, r11, 0x7dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 32208;
	// 823903F4: 392B0500  addi r9, r11, 0x500
	ctx.r[9].s64 = ctx.r[11].s64 + 1280;
	// 823903F8: 48000020  b 0x82390418
	pc = 0x82390418; continue 'dispatch;
	// 823903FC: 3964FF88  addi r11, r4, -0x78
	ctx.r[11].s64 = ctx.r[4].s64 + -120;
	// 82390400: 2B0B0053  cmplwi cr6, r11, 0x53
	ctx.cr[6].compare_u32(ctx.r[11].u32, 83 as u32, &mut ctx.xer);
	// 82390404: 41990038  bgt cr6, 0x8239043c
	if ctx.cr[6].gt {
	pc = 0x8239043C; continue 'dispatch;
	}
	// 82390408: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 8239040C: 39440088  addi r10, r4, 0x88
	ctx.r[10].s64 = ctx.r[4].s64 + 136;
	// 82390410: 396B7DD0  addi r11, r11, 0x7dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 32208;
	// 82390414: 392B0458  addi r9, r11, 0x458
	ctx.r[9].s64 = ctx.r[11].s64 + 1112;
	// 82390418: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8239041C: C1ABD2B0  lfs f13, -0x2d50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82390420: 554B0DFC  rlwinm r11, r10, 1, 0x17, 0x1e
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 82390424: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82390428: 7D6B4A2E  lhzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8239042C: 5569C23E  srwi r9, r11, 8
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82390430: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82390434: 552B063E  clrlwi r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82390438: 48000130  b 0x82390568
	pc = 0x82390568; continue 'dispatch;
	// 8239043C: 3964FFA6  addi r11, r4, -0x5a
	ctx.r[11].s64 = ctx.r[4].s64 + -90;
	// 82390440: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 82390444: 4199002C  bgt cr6, 0x82390470
	if ctx.cr[6].gt {
	pc = 0x82390470; continue 'dispatch;
	}
	// 82390448: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 8239044C: 394400A6  addi r10, r4, 0xa6
	ctx.r[10].s64 = ctx.r[4].s64 + 166;
	// 82390450: 396B7DD0  addi r11, r11, 0x7dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 32208;
	// 82390454: 392B0440  addi r9, r11, 0x440
	ctx.r[9].s64 = ctx.r[11].s64 + 1088;
	// 82390458: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8239045C: C1AB478C  lfs f13, 0x478c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18316 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82390460: 554B0DFC  rlwinm r11, r10, 1, 0x17, 0x1e
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 82390464: 7D6B4A2E  lhzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82390468: 5569C23E  srwi r9, r11, 8
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8239046C: 4800004C  b 0x823904b8
	pc = 0x823904B8; continue 'dispatch;
	// 82390470: 2B040018  cmplwi cr6, r4, 0x18
	ctx.cr[6].compare_u32(ctx.r[4].u32, 24 as u32, &mut ctx.xer);
	// 82390474: 40980058  bge cr6, 0x823904cc
	if !ctx.cr[6].lt {
	pc = 0x823904CC; continue 'dispatch;
	}
	// 82390478: 2B040012  cmplwi cr6, r4, 0x12
	ctx.cr[6].compare_u32(ctx.r[4].u32, 18 as u32, &mut ctx.xer);
	// 8239047C: 4098002C  bge cr6, 0x823904a8
	if !ctx.cr[6].lt {
	pc = 0x823904A8; continue 'dispatch;
	}
	// 82390480: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 82390484: 2B040011  cmplwi cr6, r4, 0x11
	ctx.cr[6].compare_u32(ctx.r[4].u32, 17 as u32, &mut ctx.xer);
	// 82390488: 396B7DD0  addi r11, r11, 0x7dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 32208;
	// 8239048C: 409A000C  bne cr6, 0x82390498
	if !ctx.cr[6].eq {
	pc = 0x82390498; continue 'dispatch;
	}
	// 82390490: A16B0400  lhz r11, 0x400(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82390494: 48000018  b 0x823904ac
	pc = 0x823904AC; continue 'dispatch;
	// 82390498: 548A083C  slwi r10, r4, 1
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8239049C: 396B0400  addi r11, r11, 0x400
	ctx.r[11].s64 = ctx.r[11].s64 + 1024;
	// 823904A0: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823904A4: 48000008  b 0x823904ac
	pc = 0x823904AC; continue 'dispatch;
	// 823904A8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 823904AC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823904B0: C1AA2600  lfs f13, 0x2600(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9728 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823904B4: 5569C63E  rlwinm r9, r11, 0x18, 0x18, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823904B8: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823904BC: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823904C0: 552B063E  clrlwi r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 823904C4: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 823904C8: 480000A0  b 0x82390568
	pc = 0x82390568; continue 'dispatch;
	// 823904CC: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 823904D0: 89480364  lbz r10, 0x364(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(868 as u32) ) } as u64;
	// 823904D4: 396BCE40  addi r11, r11, -0x31c0
	ctx.r[11].s64 = ctx.r[11].s64 + -12736;
	// 823904D8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823904DC: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 823904E0: 896BFFE8  lbz r11, -0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 823904E4: 40820010  bne 0x823904f4
	if !ctx.cr[0].eq {
	pc = 0x823904F4; continue 'dispatch;
	}
	// 823904E8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823904EC: C1AA2010  lfs f13, 0x2010(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823904F0: 48000008  b 0x823904f8
	pc = 0x823904F8; continue 'dispatch;
	// 823904F4: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 823904F8: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823904FC: FD206890  fmr f9, f13
	ctx.f[9].f64 = ctx.f[13].f64;
	// 82390500: 2B0A0100  cmplwi cr6, r10, 0x100
	ctx.cr[6].compare_u32(ctx.r[10].u32, 256 as u32, &mut ctx.xer);
	// 82390504: 40980018  bge cr6, 0x8239051c
	if !ctx.cr[6].lt {
	pc = 0x8239051C; continue 'dispatch;
	}
	// 82390508: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 8239050C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82390510: 396B7DD0  addi r11, r11, 0x7dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 32208;
	// 82390514: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82390518: 48000008  b 0x82390520
	pc = 0x82390520; continue 'dispatch;
	// 8239051C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82390520: 5569C63E  rlwinm r9, r11, 0x18, 0x18, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82390524: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82390528: 552B063E  clrlwi r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 8239052C: 2B040049  cmplwi cr6, r4, 0x49
	ctx.cr[6].compare_u32(ctx.r[4].u32, 73 as u32, &mut ctx.xer);
	// 82390530: 419A0028  beq cr6, 0x82390558
	if ctx.cr[6].eq {
	pc = 0x82390558; continue 'dispatch;
	}
	// 82390534: 2B04004A  cmplwi cr6, r4, 0x4a
	ctx.cr[6].compare_u32(ctx.r[4].u32, 74 as u32, &mut ctx.xer);
	// 82390538: 419A0020  beq cr6, 0x82390558
	if ctx.cr[6].eq {
	pc = 0x82390558; continue 'dispatch;
	}
	// 8239053C: 2B04004C  cmplwi cr6, r4, 0x4c
	ctx.cr[6].compare_u32(ctx.r[4].u32, 76 as u32, &mut ctx.xer);
	// 82390540: 4198000C  blt cr6, 0x8239054c
	if ctx.cr[6].lt {
	pc = 0x8239054C; continue 'dispatch;
	}
	// 82390544: 2B040055  cmplwi cr6, r4, 0x55
	ctx.cr[6].compare_u32(ctx.r[4].u32, 85 as u32, &mut ctx.xer);
	// 82390548: 40990010  ble cr6, 0x82390558
	if !ctx.cr[6].gt {
	pc = 0x82390558; continue 'dispatch;
	}
	// 8239054C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82390550: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82390554: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82390558: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8239055C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82390560: C1A9D6E8  lfs f13, -0x2918(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10520 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82390564: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82390568: 5567063E  clrlwi r7, r11, 0x18
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8239056C: ED0B6828  fsubs f8, f11, f13
	ctx.f[8].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82390570: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82390574: C0D90044  lfs f6, 0x44(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(68 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82390578: C0F90040  lfs f7, 0x40(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(64 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8239057C: 39200060  li r9, 0x60
	ctx.r[9].s64 = 96;
	// 82390580: ED47502A  fadds f10, f7, f10
	ctx.f[10].f64 = ((ctx.f[7].f64 + ctx.f[10].f64) as f32) as f64;
	// 82390584: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82390588: C1990024  lfs f12, 0x24(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8239058C: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 82390590: C16BBFFC  lfs f11, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82390594: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
            }
            0x82390B18 => {
    //   block [0x82390B18..0x82390B2C)
	// 82390B18: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82390B1C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82390B20: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82390B24: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82390B28: 481A45CC  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82390B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82390B30 size=1456
    let mut pc: u32 = 0x82390B30;
    'dispatch: loop {
        match pc {
            0x82390B30 => {
    //   block [0x82390B30..0x82390BB4)
	// 82390B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82390B34: 481A4571  bl 0x825350a4
	ctx.lr = 0x82390B38;
	sub_82535080(ctx, base);
	// 82390B38: 9421FBB0  stwu r1, -0x450(r1)
	ea = ctx.r[1].u32.wrapping_add(-1104 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82390B3C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82390B40: 90A10474  stw r5, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[5].u32 ) };
	// 82390B44: 396100FF  addi r11, r1, 0xff
	ctx.r[11].s64 = ctx.r[1].s64 + 255;
	// 82390B48: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82390B4C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82390B50: 557F0030  rlwinm r31, r11, 0, 0, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82390B54: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 82390B58: 895C0015  lbz r10, 0x15(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 82390B5C: 393F007F  addi r9, r31, 0x7f
	ctx.r[9].s64 = ctx.r[31].s64 + 127;
	// 82390B60: 397F0180  addi r11, r31, 0x180
	ctx.r[11].s64 = ctx.r[31].s64 + 384;
	// 82390B64: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 82390B68: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 82390B6C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82390B70: 7D480034  cntlzw r8, r10
	ctx.r[8].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82390B74: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 82390B78: 552A0030  rlwinm r10, r9, 0, 0, 0x18
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82390B7C: 5509DFFE  rlwinm r9, r8, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82390B80: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 82390B84: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82390B88: 93010064  stw r24, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[24].u32 ) };
	// 82390B8C: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 82390B90: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82390B94: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82390B98: 91210078  stw r9, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 82390B9C: 55690030  rlwinm r9, r11, 0, 0, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82390BA0: 93410074  stw r26, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[26].u32 ) };
	// 82390BA4: 7D6A4850  subf r11, r10, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82390BA8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82390BAC: 419A0008  beq cr6, 0x82390bb4
	if ctx.cr[6].eq {
	pc = 0x82390BB4; continue 'dispatch;
	}
	// 82390BB0: 7C00FA2C  dcbt 0, r31
	pc = 0x82390BB4; continue 'dispatch;
            }
            0x82390BB4 => {
    //   block [0x82390BB4..0x82390BC0)
	// 82390BB4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82390BB8: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 82390BBC: 41980094  blt cr6, 0x82390c50
	if ctx.cr[6].lt {
	pc = 0x82390C50; continue 'dispatch;
	}
	pc = 0x82390BC0; continue 'dispatch;
            }
            0x82390BC0 => {
    //   block [0x82390BC0..0x82390C50)
	// 82390BC0: 3960FF80  li r11, -0x80
	ctx.r[11].s64 = -128;
	// 82390BC4: 7C0B4FEC  dcbz r11, r9
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[9].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390BC8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82390BCC: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 82390BD0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390BD4: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 82390BD8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82390BDC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390BE0: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 82390BE4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82390BE8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390BEC: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 82390BF0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82390BF4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390BF8: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 82390BFC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82390C00: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390C04: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 82390C08: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82390C0C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390C10: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 82390C14: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82390C18: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390C1C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82390C20: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82390C24: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 82390C28: 392AFC00  addi r9, r10, -0x400
	ctx.r[9].s64 = ctx.r[10].s64 + -1024;
	// 82390C2C: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 82390C30: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82390C34: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82390C38: 4098FF88  bge cr6, 0x82390bc0
	if !ctx.cr[6].lt {
	pc = 0x82390BC0; continue 'dispatch;
	}
	// 82390C3C: 83210070  lwz r25, 0x70(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82390C40: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82390C44: 83410074  lwz r26, 0x74(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82390C48: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82390C4C: 83010064  lwz r24, 0x64(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	pc = 0x82390C50; continue 'dispatch;
            }
            0x82390C50 => {
    //   block [0x82390C50..0x82390C98)
	// 82390C50: 556BCF7E  rlwinm r11, r11, 0x19, 0x1d, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 82390C54: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82390C58: 419A007C  beq cr6, 0x82390cd4
	if ctx.cr[6].eq {
	pc = 0x82390CD4; continue 'dispatch;
	}
	// 82390C5C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82390C60: 419A0068  beq cr6, 0x82390cc8
	if ctx.cr[6].eq {
	pc = 0x82390CC8; continue 'dispatch;
	}
	// 82390C64: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82390C68: 419A0054  beq cr6, 0x82390cbc
	if ctx.cr[6].eq {
	pc = 0x82390CBC; continue 'dispatch;
	}
	// 82390C6C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82390C70: 419A0040  beq cr6, 0x82390cb0
	if ctx.cr[6].eq {
	pc = 0x82390CB0; continue 'dispatch;
	}
	// 82390C74: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82390C78: 419A002C  beq cr6, 0x82390ca4
	if ctx.cr[6].eq {
	pc = 0x82390CA4; continue 'dispatch;
	}
	// 82390C7C: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 82390C80: 419A0018  beq cr6, 0x82390c98
	if ctx.cr[6].eq {
	pc = 0x82390C98; continue 'dispatch;
	}
	// 82390C84: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 82390C88: 409A0068  bne cr6, 0x82390cf0
	if !ctx.cr[6].eq {
	pc = 0x82390CF0; continue 'dispatch;
	}
	// 82390C8C: 3960FC80  li r11, -0x380
	ctx.r[11].s64 = -896;
	// 82390C90: 7C0B4FEC  dcbz r11, r9
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[9].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390C94: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82390C98; continue 'dispatch;
            }
            0x82390C98 => {
    //   block [0x82390C98..0x82390CA4)
	// 82390C98: 3960FD00  li r11, -0x300
	ctx.r[11].s64 = -768;
	// 82390C9C: 7C0B4FEC  dcbz r11, r9
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[9].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390CA0: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82390CA4; continue 'dispatch;
            }
            0x82390CA4 => {
    //   block [0x82390CA4..0x82390CB0)
	// 82390CA4: 3960FD80  li r11, -0x280
	ctx.r[11].s64 = -640;
	// 82390CA8: 7C0B4FEC  dcbz r11, r9
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[9].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390CAC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82390CB0; continue 'dispatch;
            }
            0x82390CB0 => {
    //   block [0x82390CB0..0x82390CBC)
	// 82390CB0: 3960FE00  li r11, -0x200
	ctx.r[11].s64 = -512;
	// 82390CB4: 7C0B4FEC  dcbz r11, r9
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[9].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390CB8: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82390CBC; continue 'dispatch;
            }
            0x82390CBC => {
    //   block [0x82390CBC..0x82390CC8)
	// 82390CBC: 3960FE80  li r11, -0x180
	ctx.r[11].s64 = -384;
	// 82390CC0: 7C0B4FEC  dcbz r11, r9
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[9].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390CC4: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82390CC8; continue 'dispatch;
            }
            0x82390CC8 => {
    //   block [0x82390CC8..0x82390CD4)
	// 82390CC8: 3960FF00  li r11, -0x100
	ctx.r[11].s64 = -256;
	// 82390CCC: 7C0B4FEC  dcbz r11, r9
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[9].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390CD0: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82390CD4; continue 'dispatch;
            }
            0x82390CD4 => {
    //   block [0x82390CD4..0x82390CF0)
	// 82390CD4: 3960FF80  li r11, -0x80
	ctx.r[11].s64 = -128;
	// 82390CD8: 7C0B4FEC  dcbz r11, r9
	ea.u32 = ctx.r[11].u32.wrapping_add(ctx.r[9].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 82390CDC: 83210070  lwz r25, 0x70(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82390CE0: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82390CE4: 83410074  lwz r26, 0x74(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82390CE8: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82390CEC: 83010064  lwz r24, 0x64(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	pc = 0x82390CF0; continue 'dispatch;
            }
            0x82390CF0 => {
    //   block [0x82390CF0..0x82390D0C)
	// 82390CF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82390CF4: 92FC0084  stw r23, 0x84(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(132 as u32), ctx.r[23].u32 ) };
	// 82390CF8: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 82390CFC: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82390D00: D01C0088  stfs f0, 0x88(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82390D04: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82390D08: 4800036C  b 0x82391074
	pc = 0x82391074; continue 'dispatch;
            }
            0x82390D0C => {
    //   block [0x82390D0C..0x82390D44)
	// 82390D0C: 395EFFDD  addi r10, r30, -0x23
	ctx.r[10].s64 = ctx.r[30].s64 + -35;
	// 82390D10: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 82390D14: 4199010C  bgt cr6, 0x82390e20
	if ctx.cr[6].gt {
	pc = 0x82390E20; continue 'dispatch;
	}
	// 82390D18: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82390D1C: 409A0104  bne cr6, 0x82390e20
	if !ctx.cr[6].eq {
	pc = 0x82390E20; continue 'dispatch;
	}
	// 82390D20: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82390D24: 2B1E0025  cmplwi cr6, r30, 0x25
	ctx.cr[6].compare_u32(ctx.r[30].u32, 37 as u32, &mut ctx.xer);
	// 82390D28: 419A001C  beq cr6, 0x82390d44
	if ctx.cr[6].eq {
	pc = 0x82390D44; continue 'dispatch;
	}
	// 82390D2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82390D30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82390D34: 419A0010  beq cr6, 0x82390d44
	if ctx.cr[6].eq {
	pc = 0x82390D44; continue 'dispatch;
	}
	// 82390D38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82390D3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82390D40: 4BFFEBF1  bl 0x8238f930
	ctx.lr = 0x82390D44;
	sub_8238F930(ctx, base);
	pc = 0x82390D44; continue 'dispatch;
            }
            0x82390D44 => {
    //   block [0x82390D44..0x82390D98)
	// 82390D44: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82390D48: 38E10474  addi r7, r1, 0x474
	ctx.r[7].s64 = ctx.r[1].s64 + 1140;
	// 82390D4C: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82390D50: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82390D54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82390D58: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82390D5C: 4BFFED55  bl 0x8238fab0
	ctx.lr = 0x82390D60;
	sub_8238FAB0(ctx, base);
	// 82390D60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82390D64: 41820310  beq 0x82391074
	if ctx.cr[0].eq {
	pc = 0x82391074; continue 'dispatch;
	}
	// 82390D68: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82390D6C: 419A0054  beq cr6, 0x82390dc0
	if ctx.cr[6].eq {
	pc = 0x82390DC0; continue 'dispatch;
	}
	// 82390D70: 2B030002  cmplwi cr6, r3, 2
	ctx.cr[6].compare_u32(ctx.r[3].u32, 2 as u32, &mut ctx.xer);
	// 82390D74: 419A0038  beq cr6, 0x82390dac
	if ctx.cr[6].eq {
	pc = 0x82390DAC; continue 'dispatch;
	}
	// 82390D78: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 82390D7C: 419A001C  beq cr6, 0x82390d98
	if ctx.cr[6].eq {
	pc = 0x82390D98; continue 'dispatch;
	}
	// 82390D80: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82390D84: 409A02F0  bne cr6, 0x82391074
	if !ctx.cr[6].eq {
	pc = 0x82391074; continue 'dispatch;
	}
	// 82390D88: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82390D8C: 889C0014  lbz r4, 0x14(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82390D90: 4BFFE9C1  bl 0x8238f750
	ctx.lr = 0x82390D94;
	sub_8238F750(ctx, base);
	// 82390D94: 480002E0  b 0x82391074
	pc = 0x82391074; continue 'dispatch;
            }
            0x82390D98 => {
    //   block [0x82390D98..0x82390DAC)
	// 82390D98: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82390D9C: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 82390DA0: 83210054  lwz r25, 0x54(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82390DA4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82390DA8: 480002CC  b 0x82391074
	pc = 0x82391074; continue 'dispatch;
            }
            0x82390DAC => {
    //   block [0x82390DAC..0x82390DC0)
	// 82390DAC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82390DB0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82390DB4: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82390DB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82390DBC: 480002B8  b 0x82391074
	pc = 0x82391074; continue 'dispatch;
            }
            0x82390DC0 => {
    //   block [0x82390DC0..0x82390DCC)
	// 82390DC0: A1780000  lhz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82390DC4: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82390DC8: 4800004C  b 0x82390e14
	pc = 0x82390E14; continue 'dispatch;
            }
            0x82390DCC => {
    //   block [0x82390DCC..0x82390E10)
	// 82390DCC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82390DD0: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 82390DD4: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 82390DD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82390DDC: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82390DE0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82390DE4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82390DE8: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 82390DEC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82390DF0: 2B0B00AA  cmplwi cr6, r11, 0xaa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 170 as u32, &mut ctx.xer);
	// 82390DF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82390DF8: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82390DFC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82390E00: 409A0010  bne cr6, 0x82390e10
	if !ctx.cr[6].eq {
	pc = 0x82390E10; continue 'dispatch;
	}
	// 82390E04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82390E08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82390E0C: 4BFFEB25  bl 0x8238f930
	ctx.lr = 0x82390E10;
	sub_8238F930(ctx, base);
	pc = 0x82390E10; continue 'dispatch;
            }
            0x82390E10 => {
    //   block [0x82390E10..0x82390E14)
	// 82390E10: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82390E14; continue 'dispatch;
            }
            0x82390E14 => {
    //   block [0x82390E14..0x82390E20)
	// 82390E14: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 82390E18: 409AFFB4  bne cr6, 0x82390dcc
	if !ctx.cr[6].eq {
	pc = 0x82390DCC; continue 'dispatch;
	}
	// 82390E1C: 48000258  b 0x82391074
	pc = 0x82391074; continue 'dispatch;
            }
            0x82390E20 => {
    //   block [0x82390E20..0x82390EE4)
	// 82390E20: 2B1E0080  cmplwi cr6, r30, 0x80
	ctx.cr[6].compare_u32(ctx.r[30].u32, 128 as u32, &mut ctx.xer);
	// 82390E24: 4098015C  bge cr6, 0x82390f80
	if !ctx.cr[6].lt {
	pc = 0x82390F80; continue 'dispatch;
	}
	// 82390E28: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82390E2C: 2B1E0020  cmplwi cr6, r30, 0x20
	ctx.cr[6].compare_u32(ctx.r[30].u32, 32 as u32, &mut ctx.xer);
	// 82390E30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82390E34: 409900C8  ble cr6, 0x82390efc
	if !ctx.cr[6].gt {
	pc = 0x82390EFC; continue 'dispatch;
	}
	// 82390E38: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82390E3C: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82390E40: 893C0014  lbz r9, 0x14(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82390E44: 2B090004  cmplwi cr6, r9, 4
	ctx.cr[6].compare_u32(ctx.r[9].u32, 4 as u32, &mut ctx.xer);
	// 82390E48: 7FAA5A2E  lhzx r29, r10, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82390E4C: 409A0098  bne cr6, 0x82390ee4
	if !ctx.cr[6].eq {
	pc = 0x82390EE4; continue 'dispatch;
	}
	// 82390E50: 397DFFCF  addi r11, r29, -0x31
	ctx.r[11].s64 = ctx.r[29].s64 + -49;
	// 82390E54: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82390E58: 4199008C  bgt cr6, 0x82390ee4
	if ctx.cr[6].gt {
	pc = 0x82390EE4; continue 'dispatch;
	}
	// 82390E5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82390E60: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82390E64: 4BFFEACD  bl 0x8238f930
	ctx.lr = 0x82390E68;
	sub_8238F930(ctx, base);
	// 82390E68: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82390E6C: 39400015  li r10, 0x15
	ctx.r[10].s64 = 21;
	// 82390E70: 8BDC0018  lbz r30, 0x18(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82390E74: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 82390E78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82390E7C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82390E80: 995C0018  stb r10, 0x18(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 82390E84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82390E88: 4E800421  bctrl
	ctx.lr = 0x82390E8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82390E8C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82390E90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82390E94: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82390E98: B3AB0000  sth r29, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u16 ) };
	// 82390E9C: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82390EA0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82390EA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82390EA8: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 82390EAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82390EB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82390EB4: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82390EB8: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82390EBC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82390EC0: 4BFFEA71  bl 0x8238f930
	ctx.lr = 0x82390EC4;
	sub_8238F930(ctx, base);
	// 82390EC4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82390EC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82390ECC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82390ED0: 9BDC0018  stb r30, 0x18(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82390ED4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82390ED8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82390EDC: 4E800421  bctrl
	ctx.lr = 0x82390EE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82390EE0: 4800017C  b 0x8239105c
	pc = 0x8239105C; continue 'dispatch;
            }
            0x82390EE4 => {
    //   block [0x82390EE4..0x82390EEC)
	// 82390EE4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82390EE8: B3AB0000  sth r29, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u16 ) };
	pc = 0x82390EEC; continue 'dispatch;
            }
            0x82390EEC => {
    //   block [0x82390EEC..0x82390EFC)
	// 82390EEC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82390EF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82390EF4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82390EF8: 4800014C  b 0x82391044
	pc = 0x82391044; continue 'dispatch;
            }
            0x82390EFC => {
    //   block [0x82390EFC..0x82390F20)
	// 82390EFC: 2B1E0009  cmplwi cr6, r30, 9
	ctx.cr[6].compare_u32(ctx.r[30].u32, 9 as u32, &mut ctx.xer);
	// 82390F00: 419A0068  beq cr6, 0x82390f68
	if ctx.cr[6].eq {
	pc = 0x82390F68; continue 'dispatch;
	}
	// 82390F04: 2B1E000A  cmplwi cr6, r30, 0xa
	ctx.cr[6].compare_u32(ctx.r[30].u32, 10 as u32, &mut ctx.xer);
	// 82390F08: 419A0038  beq cr6, 0x82390f40
	if ctx.cr[6].eq {
	pc = 0x82390F40; continue 'dispatch;
	}
	// 82390F0C: 2B1E0020  cmplwi cr6, r30, 0x20
	ctx.cr[6].compare_u32(ctx.r[30].u32, 32 as u32, &mut ctx.xer);
	// 82390F10: 419A0010  beq cr6, 0x82390f20
	if ctx.cr[6].eq {
	pc = 0x82390F20; continue 'dispatch;
	}
	// 82390F14: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82390F18: B3CB0000  sth r30, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u16 ) };
	// 82390F1C: 4BFFFFD0  b 0x82390eec
	pc = 0x82390EEC; continue 'dispatch;
            }
            0x82390F20 => {
    //   block [0x82390F20..0x82390F30)
	// 82390F20: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82390F24: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82390F28: A16B0040  lhz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82390F2C: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	pc = 0x82390F30; continue 'dispatch;
            }
            0x82390F30 => {
    //   block [0x82390F30..0x82390F40)
	// 82390F30: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82390F34: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82390F38: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82390F3C: 48000114  b 0x82391050
	pc = 0x82391050; continue 'dispatch;
            }
            0x82390F40 => {
    //   block [0x82390F40..0x82390F68)
	// 82390F40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82390F44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82390F48: 4BFFE9E9  bl 0x8238f930
	ctx.lr = 0x82390F4C;
	sub_8238F930(ctx, base);
	// 82390F4C: C01C0044  lfs f0, 0x44(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82390F50: C1BC0080  lfs f13, 0x80(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82390F54: C19C0050  lfs f12, 0x50(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82390F58: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82390F5C: D01C0044  stfs f0, 0x44(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82390F60: D19C0040  stfs f12, 0x40(r28)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82390F64: 480000F8  b 0x8239105c
	pc = 0x8239105C; continue 'dispatch;
            }
            0x82390F68 => {
    //   block [0x82390F68..0x82390F80)
	// 82390F68: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 82390F6C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82390F70: 409A00EC  bne cr6, 0x8239105c
	if !ctx.cr[6].eq {
	pc = 0x8239105C; continue 'dispatch;
	}
	// 82390F74: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82390F78: B2EB0000  sth r23, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u16 ) };
	// 82390F7C: 4BFFFFB4  b 0x82390f30
	pc = 0x82390F30; continue 'dispatch;
            }
            0x82390F80 => {
    //   block [0x82390F80..0x82390FB0)
	// 82390F80: 817C0074  lwz r11, 0x74(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(116 as u32) ) } as u64;
	// 82390F84: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 82390F88: 92E1006C  stw r23, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[23].u32 ) };
	// 82390F8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82390F90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82390F94: 4E800421  bctrl
	ctx.lr = 0x82390F98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82390F98: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82390F9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82390FA0: 419A0010  beq cr6, 0x82390fb0
	if ctx.cr[6].eq {
	pc = 0x82390FB0; continue 'dispatch;
	}
	// 82390FA4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82390FA8: B06B0000  sth r3, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u16 ) };
	// 82390FAC: 4BFFFF40  b 0x82390eec
	pc = 0x82390EEC; continue 'dispatch;
            }
            0x82390FB0 => {
    //   block [0x82390FB0..0x82390FF8)
	// 82390FB0: A17C001A  lhz r11, 0x1a(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(26 as u32) ) } as u64;
	// 82390FB4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82390FB8: 40980050  bge cr6, 0x82391008
	if !ctx.cr[6].lt {
	pc = 0x82391008; continue 'dispatch;
	}
	// 82390FBC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82390FC0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82390FC4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82390FC8: B06B0000  sth r3, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u16 ) };
	// 82390FCC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82390FD0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82390FD4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82390FD8: 419A0020  beq cr6, 0x82390ff8
	if ctx.cr[6].eq {
	pc = 0x82390FF8; continue 'dispatch;
	}
	// 82390FDC: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82390FE0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82390FE4: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 82390FE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82390FEC: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82390FF0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82390FF4: 48000068  b 0x8239105c
	pc = 0x8239105C; continue 'dispatch;
            }
            0x82390FF8 => {
    //   block [0x82390FF8..0x82391008)
	// 82390FF8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82390FFC: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82391000: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82391004: 48000058  b 0x8239105c
	pc = 0x8239105C; continue 'dispatch;
            }
            0x82391008 => {
    //   block [0x82391008..0x82391018)
	// 82391008: 3923E140  addi r9, r3, -0x1ec0
	ctx.r[9].s64 = ctx.r[3].s64 + -7872;
	// 8239100C: 2B090073  cmplwi cr6, r9, 0x73
	ctx.cr[6].compare_u32(ctx.r[9].u32, 115 as u32, &mut ctx.xer);
	// 82391010: 41990008  bgt cr6, 0x82391018
	if ctx.cr[6].gt {
	pc = 0x82391018; continue 'dispatch;
	}
	// 82391014: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x82391018; continue 'dispatch;
            }
            0x82391018 => {
    //   block [0x82391018..0x8239102C)
	// 82391018: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 8239101C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82391020: 419A000C  beq cr6, 0x8239102c
	if ctx.cr[6].eq {
	pc = 0x8239102C; continue 'dispatch;
	}
	// 82391024: 616BC000  ori r11, r11, 0xc000
	ctx.r[11].u64 = ctx.r[11].u64 | 49152;
	// 82391028: 48000008  b 0x82391030
	pc = 0x82391030; continue 'dispatch;
            }
            0x8239102C => {
    //   block [0x8239102C..0x82391030)
	// 8239102C: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	pc = 0x82391030; continue 'dispatch;
            }
            0x82391030 => {
    //   block [0x82391030..0x82391044)
	// 82391030: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82391034: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 82391038: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8239103C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82391040: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82391044; continue 'dispatch;
            }
            0x82391044 => {
    //   block [0x82391044..0x82391050)
	// 82391044: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82391048: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 8239104C: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	pc = 0x82391050; continue 'dispatch;
            }
            0x82391050 => {
    //   block [0x82391050..0x8239105C)
	// 82391050: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82391054: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82391058: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8239105C; continue 'dispatch;
            }
            0x8239105C => {
    //   block [0x8239105C..0x82391074)
	// 8239105C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82391060: 2B0B00AA  cmplwi cr6, r11, 0xaa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 170 as u32, &mut ctx.xer);
	// 82391064: 409A0010  bne cr6, 0x82391074
	if !ctx.cr[6].eq {
	pc = 0x82391074; continue 'dispatch;
	}
	// 82391068: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8239106C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82391070: 4BFFE8C1  bl 0x8238f930
	ctx.lr = 0x82391074;
	sub_8238F930(ctx, base);
	pc = 0x82391074; continue 'dispatch;
            }
            0x82391074 => {
    //   block [0x82391074..0x82391078)
	// 82391074: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82391078; continue 'dispatch;
            }
            0x82391078 => {
    //   block [0x82391078..0x823910C8)
	// 82391078: 8BCB0000  lbz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8239107C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82391080: 4082FC8C  bne 0x82390d0c
	if !ctx.cr[0].eq {
	pc = 0x82390D0C; continue 'dispatch;
	}
	// 82391084: 7F6BDB79  or. r11, r27, r27
	ctx.r[11].u64 = ctx.r[27].u64 | ctx.r[27].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82391088: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 8239108C: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 82391090: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82391094: 4082FFE4  bne 0x82391078
	if !ctx.cr[0].eq {
	pc = 0x82391078; continue 'dispatch;
	}
	// 82391098: 7F2BCB79  or. r11, r25, r25
	ctx.r[11].u64 = ctx.r[25].u64 | ctx.r[25].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8239109C: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 823910A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823910A4: 4082FFD4  bne 0x82391078
	if !ctx.cr[0].eq {
	pc = 0x82391078; continue 'dispatch;
	}
	// 823910A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823910AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823910B0: 40990018  ble cr6, 0x823910c8
	if !ctx.cr[6].gt {
	pc = 0x823910C8; continue 'dispatch;
	}
	// 823910B4: 817C0078  lwz r11, 0x78(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(120 as u32) ) } as u64;
	// 823910B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823910BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823910C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823910C4: 4E800421  bctrl
	ctx.lr = 0x823910C8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823910C8 => {
    //   block [0x823910C8..0x823910E0)
	// 823910C8: C01C0040  lfs f0, 0x40(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823910CC: C1BC0088  lfs f13, 0x88(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823910D0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823910D4: D01C0040  stfs f0, 0x40(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 823910D8: 38210450  addi r1, r1, 0x450
	ctx.r[1].s64 = ctx.r[1].s64 + 1104;
	// 823910DC: 481A4018  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823910E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823910E0 size=164
    let mut pc: u32 = 0x823910E0;
    'dispatch: loop {
        match pc {
            0x823910E0 => {
    //   block [0x823910E0..0x82391108)
	// 823910E0: 2B040013  cmplwi cr6, r4, 0x13
	ctx.cr[6].compare_u32(ctx.r[4].u32, 19 as u32, &mut ctx.xer);
	// 823910E4: 419A0094  beq cr6, 0x82391178
	if ctx.cr[6].eq {
	pc = 0x82391178; continue 'dispatch;
	}
	// 823910E8: 2B040014  cmplwi cr6, r4, 0x14
	ctx.cr[6].compare_u32(ctx.r[4].u32, 20 as u32, &mut ctx.xer);
	// 823910EC: 419A0084  beq cr6, 0x82391170
	if ctx.cr[6].eq {
	pc = 0x82391170; continue 'dispatch;
	}
	// 823910F0: 2B040017  cmplwi cr6, r4, 0x17
	ctx.cr[6].compare_u32(ctx.r[4].u32, 23 as u32, &mut ctx.xer);
	// 823910F4: 419A0074  beq cr6, 0x82391168
	if ctx.cr[6].eq {
	pc = 0x82391168; continue 'dispatch;
	}
	// 823910F8: 2B040012  cmplwi cr6, r4, 0x12
	ctx.cr[6].compare_u32(ctx.r[4].u32, 18 as u32, &mut ctx.xer);
	// 823910FC: 4198000C  blt cr6, 0x82391108
	if ctx.cr[6].lt {
	pc = 0x82391108; continue 'dispatch;
	}
	// 82391100: 2B040018  cmplwi cr6, r4, 0x18
	ctx.cr[6].compare_u32(ctx.r[4].u32, 24 as u32, &mut ctx.xer);
	// 82391104: 4198005C  blt cr6, 0x82391160
	if ctx.cr[6].lt {
	pc = 0x82391160; continue 'dispatch;
	}
	pc = 0x82391108; continue 'dispatch;
            }
            0x82391108 => {
    //   block [0x82391108..0x82391118)
	// 82391108: 2B040056  cmplwi cr6, r4, 0x56
	ctx.cr[6].compare_u32(ctx.r[4].u32, 86 as u32, &mut ctx.xer);
	// 8239110C: 4198000C  blt cr6, 0x82391118
	if ctx.cr[6].lt {
	pc = 0x82391118; continue 'dispatch;
	}
	// 82391110: 2B04005A  cmplwi cr6, r4, 0x5a
	ctx.cr[6].compare_u32(ctx.r[4].u32, 90 as u32, &mut ctx.xer);
	// 82391114: 4198004C  blt cr6, 0x82391160
	if ctx.cr[6].lt {
	pc = 0x82391160; continue 'dispatch;
	}
	pc = 0x82391118; continue 'dispatch;
            }
            0x82391118 => {
    //   block [0x82391118..0x82391128)
	// 82391118: 2B040064  cmplwi cr6, r4, 0x64
	ctx.cr[6].compare_u32(ctx.r[4].u32, 100 as u32, &mut ctx.xer);
	// 8239111C: 4198000C  blt cr6, 0x82391128
	if ctx.cr[6].lt {
	pc = 0x82391128; continue 'dispatch;
	}
	// 82391120: 2B040078  cmplwi cr6, r4, 0x78
	ctx.cr[6].compare_u32(ctx.r[4].u32, 120 as u32, &mut ctx.xer);
	// 82391124: 4198003C  blt cr6, 0x82391160
	if ctx.cr[6].lt {
	pc = 0x82391160; continue 'dispatch;
	}
	pc = 0x82391128; continue 'dispatch;
            }
            0x82391128 => {
    //   block [0x82391128..0x82391138)
	// 82391128: 2B0400CC  cmplwi cr6, r4, 0xcc
	ctx.cr[6].compare_u32(ctx.r[4].u32, 204 as u32, &mut ctx.xer);
	// 8239112C: 4198000C  blt cr6, 0x82391138
	if ctx.cr[6].lt {
	pc = 0x82391138; continue 'dispatch;
	}
	// 82391130: 2B0400D2  cmplwi cr6, r4, 0xd2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 210 as u32, &mut ctx.xer);
	// 82391134: 4198002C  blt cr6, 0x82391160
	if ctx.cr[6].lt {
	pc = 0x82391160; continue 'dispatch;
	}
	pc = 0x82391138; continue 'dispatch;
            }
            0x82391138 => {
    //   block [0x82391138..0x82391148)
	// 82391138: 2B0400DC  cmplwi cr6, r4, 0xdc
	ctx.cr[6].compare_u32(ctx.r[4].u32, 220 as u32, &mut ctx.xer);
	// 8239113C: 4198000C  blt cr6, 0x82391148
	if ctx.cr[6].lt {
	pc = 0x82391148; continue 'dispatch;
	}
	// 82391140: 2B0400E6  cmplwi cr6, r4, 0xe6
	ctx.cr[6].compare_u32(ctx.r[4].u32, 230 as u32, &mut ctx.xer);
	// 82391144: 4198001C  blt cr6, 0x82391160
	if ctx.cr[6].lt {
	pc = 0x82391160; continue 'dispatch;
	}
	pc = 0x82391148; continue 'dispatch;
            }
            0x82391148 => {
    //   block [0x82391148..0x82391158)
	// 82391148: 2B0400F6  cmplwi cr6, r4, 0xf6
	ctx.cr[6].compare_u32(ctx.r[4].u32, 246 as u32, &mut ctx.xer);
	// 8239114C: 4198000C  blt cr6, 0x82391158
	if ctx.cr[6].lt {
	pc = 0x82391158; continue 'dispatch;
	}
	// 82391150: 2B0400FA  cmplwi cr6, r4, 0xfa
	ctx.cr[6].compare_u32(ctx.r[4].u32, 250 as u32, &mut ctx.xer);
	// 82391154: 4198000C  blt cr6, 0x82391160
	if ctx.cr[6].lt {
	pc = 0x82391160; continue 'dispatch;
	}
	pc = 0x82391158; continue 'dispatch;
            }
            0x82391158 => {
    //   block [0x82391158..0x82391160)
	// 82391158: 2B040100  cmplwi cr6, r4, 0x100
	ctx.cr[6].compare_u32(ctx.r[4].u32, 256 as u32, &mut ctx.xer);
	// 8239115C: 41980020  blt cr6, 0x8239117c
	if ctx.cr[6].lt {
	pc = 0x8239117C; continue 'dispatch;
	}
	pc = 0x82391160; continue 'dispatch;
            }
            0x82391160 => {
    //   block [0x82391160..0x82391168)
	// 82391160: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 82391164: 48000018  b 0x8239117c
	pc = 0x8239117C; continue 'dispatch;
            }
            0x82391168 => {
    //   block [0x82391168..0x82391170)
	// 82391168: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8239116C: 48000010  b 0x8239117c
	pc = 0x8239117C; continue 'dispatch;
            }
            0x82391170 => {
    //   block [0x82391170..0x82391178)
	// 82391170: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82391174: 48000008  b 0x8239117c
	pc = 0x8239117C; continue 'dispatch;
            }
            0x82391178 => {
    //   block [0x82391178..0x8239117C)
	// 82391178: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8239117C; continue 'dispatch;
            }
            0x8239117C => {
    //   block [0x8239117C..0x82391184)
	// 8239117C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82391180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82391188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82391188 size=660
    let mut pc: u32 = 0x82391188;
    'dispatch: loop {
        match pc {
            0x82391188 => {
    //   block [0x82391188..0x823911E0)
	// 82391188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8239118C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82391190: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82391194: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82391198: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 8239119C: 394BB6A0  addi r10, r11, -0x4960
	ctx.r[10].s64 = ctx.r[11].s64 + -18784;
	// 823911A0: 816A0360  lwz r11, 0x360(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(864 as u32) ) } as u64;
	// 823911A4: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823911A8: 40980260  bge cr6, 0x82391408
	if !ctx.cr[6].lt {
	pc = 0x82391408; continue 'dispatch;
	}
	// 823911AC: 1D640024  mulli r11, r4, 0x24
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 36 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823911B0: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823911B4: 80650020  lwz r3, 0x20(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) } as u64;
	// 823911B8: 2F030012  cmpwi cr6, r3, 0x12
	ctx.cr[6].compare_i32(ctx.r[3].s32, 18, &mut ctx.xer);
	// 823911BC: 40980024  bge cr6, 0x823911e0
	if !ctx.cr[6].lt {
	pc = 0x823911E0; continue 'dispatch;
	}
	// 823911C0: C0850018  lfs f4, 0x18(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823911C4: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 823911C8: C0650014  lfs f3, 0x14(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823911CC: 80C5001C  lwz r6, 0x1c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 823911D0: C0450008  lfs f2, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823911D4: C0250004  lfs f1, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823911D8: 480002B1  bl 0x82391488
	ctx.lr = 0x823911DC;
	sub_82391488(ctx, base);
	// 823911DC: 4800022C  b 0x82391408
	pc = 0x82391408; continue 'dispatch;
            }
            0x823911E0 => {
    //   block [0x823911E0..0x8239120C)
	// 823911E0: 3963FF88  addi r11, r3, -0x78
	ctx.r[11].s64 = ctx.r[3].s64 + -120;
	// 823911E4: 2B0B0053  cmplwi cr6, r11, 0x53
	ctx.cr[6].compare_u32(ctx.r[11].u32, 83 as u32, &mut ctx.xer);
	// 823911E8: 41990024  bgt cr6, 0x8239120c
	if ctx.cr[6].gt {
	pc = 0x8239120C; continue 'dispatch;
	}
	// 823911EC: C0850018  lfs f4, 0x18(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823911F0: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 823911F4: C0650014  lfs f3, 0x14(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823911F8: 80C5001C  lwz r6, 0x1c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 823911FC: C0450008  lfs f2, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82391200: C0250004  lfs f1, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82391204: 480004FD  bl 0x82391700
	ctx.lr = 0x82391208;
	sub_82391700(ctx, base);
	// 82391208: 48000200  b 0x82391408
	pc = 0x82391408; continue 'dispatch;
            }
            0x8239120C => {
    //   block [0x8239120C..0x82391288)
	// 8239120C: 3963FF2E  addi r11, r3, -0xd2
	ctx.r[11].s64 = ctx.r[3].s64 + -210;
	// 82391210: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 82391214: 41990074  bgt cr6, 0x82391288
	if ctx.cr[6].gt {
	pc = 0x82391288; continue 'dispatch;
	}
	// 82391218: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8239121C: C0650014  lfs f3, 0x14(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82391220: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82391224: C0450008  lfs f2, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82391228: 396BF96C  addi r11, r11, -0x694
	ctx.r[11].s64 = ctx.r[11].s64 + -1684;
	// 8239122C: C0250004  lfs f1, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82391230: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82391234: C0850018  lfs f4, 0x18(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82391238: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 8239123C: 8105001C  lwz r8, 0x1c(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 82391240: 394A0318  addi r10, r10, 0x318
	ctx.r[10].s64 = ctx.r[10].s64 + 792;
	// 82391244: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82391248: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8239124C: D8610048  stfd f3, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.f[3].u64 ) };
	// 82391250: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82391254: D8410020  stfd f2, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[2].u64 ) };
	// 82391258: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 8239125C: D8210018  stfd f1, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 82391260: 896BFF2E  lbz r11, -0xd2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-210 as u32) ) } as u64;
	// 82391264: D8810050  stfd f4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[4].u64 ) };
	// 82391268: E9410048  ld r10, 0x48(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(72 as u32) ) };
	// 8239126C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82391270: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82391274: E8810018  ld r4, 0x18(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82391278: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8239127C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82391280: 4BFE1829  bl 0x82372aa8
	ctx.lr = 0x82391284;
	sub_82372AA8(ctx, base);
	// 82391284: 48000184  b 0x82391408
	pc = 0x82391408; continue 'dispatch;
            }
            0x82391288 => {
    //   block [0x82391288..0x823912B4)
	// 82391288: 3963FFA6  addi r11, r3, -0x5a
	ctx.r[11].s64 = ctx.r[3].s64 + -90;
	// 8239128C: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 82391290: 41990024  bgt cr6, 0x823912b4
	if ctx.cr[6].gt {
	pc = 0x823912B4; continue 'dispatch;
	}
	// 82391294: C0850018  lfs f4, 0x18(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82391298: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8239129C: C0650014  lfs f3, 0x14(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823912A0: 80C5001C  lwz r6, 0x1c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 823912A4: C0450008  lfs f2, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823912A8: C0250004  lfs f1, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823912AC: 4800031D  bl 0x823915c8
	ctx.lr = 0x823912B0;
	sub_823915C8(ctx, base);
	// 823912B0: 48000158  b 0x82391408
	pc = 0x82391408; continue 'dispatch;
            }
            0x823912B4 => {
    //   block [0x823912B4..0x823912E0)
	// 823912B4: 3963FF1A  addi r11, r3, -0xe6
	ctx.r[11].s64 = ctx.r[3].s64 + -230;
	// 823912B8: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 823912BC: 41990024  bgt cr6, 0x823912e0
	if ctx.cr[6].gt {
	pc = 0x823912E0; continue 'dispatch;
	}
	// 823912C0: C0850018  lfs f4, 0x18(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823912C4: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 823912C8: C0650014  lfs f3, 0x14(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823912CC: 80C5001C  lwz r6, 0x1c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 823912D0: C0450008  lfs f2, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823912D4: C0250004  lfs f1, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823912D8: 48000679  bl 0x82391950
	ctx.lr = 0x823912DC;
	sub_82391950(ctx, base);
	// 823912DC: 4800012C  b 0x82391408
	pc = 0x82391408; continue 'dispatch;
            }
            0x823912E0 => {
    //   block [0x823912E0..0x8239136C)
	// 823912E0: 3963FF06  addi r11, r3, -0xfa
	ctx.r[11].s64 = ctx.r[3].s64 + -250;
	// 823912E4: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 823912E8: 41990084  bgt cr6, 0x8239136c
	if ctx.cr[6].gt {
	pc = 0x8239136C; continue 'dispatch;
	}
	// 823912EC: 4800057D  bl 0x82391868
	ctx.lr = 0x823912F0;
	sub_82391868(ctx, base);
	// 823912F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823912F4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 823912F8: C0450008  lfs f2, 8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823912FC: 396BF9D0  addi r11, r11, -0x630
	ctx.r[11].s64 = ctx.r[11].s64 + -1584;
	// 82391300: C0250004  lfs f1, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82391304: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82391308: C0A50018  lfs f5, 0x18(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 8239130C: 390BFFA6  addi r8, r11, -0x5a
	ctx.r[8].s64 = ctx.r[11].s64 + -90;
	// 82391310: C0850014  lfs f4, 0x14(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82391314: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82391318: D8410020  stfd f2, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[2].u64 ) };
	// 8239131C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82391320: D8210018  stfd f1, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 82391324: 386B0300  addi r3, r11, 0x300
	ctx.r[3].s64 = ctx.r[11].s64 + 768;
	// 82391328: E8810018  ld r4, 0x18(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 8239132C: C86A2000  lfd f3, 0x2000(r10)
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) };
	// 82391330: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82391334: 7D6940AE  lbzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82391338: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8239133C: 8125001C  lwz r9, 0x1c(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 82391340: D8610028  stfd f3, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[3].u64 ) };
	// 82391344: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82391348: 81050000  lwz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8239134C: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 82391350: D8A10058  stfd f5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[5].u64 ) };
	// 82391354: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82391358: D8810050  stfd f4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[4].u64 ) };
	// 8239135C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82391360: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82391364: 4BFE1745  bl 0x82372aa8
	ctx.lr = 0x82391368;
	sub_82372AA8(ctx, base);
	// 82391368: 480000A0  b 0x82391408
	pc = 0x82391408; continue 'dispatch;
            }
            0x8239136C => {
    //   block [0x8239136C..0x82391390)
	// 8239136C: 3963FFE8  addi r11, r3, -0x18
	ctx.r[11].s64 = ctx.r[3].s64 + -24;
	// 82391370: 2B0B003D  cmplwi cr6, r11, 0x3d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 61 as u32, &mut ctx.xer);
	// 82391374: 41990094  bgt cr6, 0x82391408
	if ctx.cr[6].gt {
	pc = 0x82391408; continue 'dispatch;
	}
	// 82391378: 896A0364  lbz r11, 0x364(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 8239137C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82391380: 40820010  bne 0x82391390
	if !ctx.cr[0].eq {
	pc = 0x82391390; continue 'dispatch;
	}
	// 82391384: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82391388: C00B2010  lfs f0, 0x2010(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8239138C: 4800000C  b 0x82391398
	pc = 0x82391398; continue 'dispatch;
            }
            0x82391390 => {
    //   block [0x82391390..0x82391398)
	// 82391390: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82391394: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82391398; continue 'dispatch;
            }
            0x82391398 => {
    //   block [0x82391398..0x82391408)
	// 82391398: 3D608284  lis r11, -0x7d7c
	ctx.r[11].s64 = -2105278464;
	// 8239139C: C1A50018  lfs f13, 0x18(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823913A0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823913A4: C1850014  lfs f12, 0x14(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823913A8: 396BCE40  addi r11, r11, -0x31c0
	ctx.r[11].s64 = ctx.r[11].s64 + -12736;
	// 823913AC: C0450008  lfs f2, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823913B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823913B4: C0250004  lfs f1, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823913B8: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 823913BC: EC8D0032  fmuls f4, f13, f0
	ctx.f[4].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823913C0: 394A02D4  addi r10, r10, 0x2d4
	ctx.r[10].s64 = ctx.r[10].s64 + 724;
	// 823913C4: EC6C0032  fmuls f3, f12, f0
	ctx.f[3].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823913C8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823913CC: 80E5001C  lwz r7, 0x1c(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 823913D0: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 823913D4: 80C50000  lwz r6, 0(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 823913D8: D8810048  stfd f4, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.f[4].u64 ) };
	// 823913DC: E9410048  ld r10, 0x48(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(72 as u32) ) };
	// 823913E0: 896BFFE8  lbz r11, -0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 823913E4: D8610040  stfd f3, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.f[3].u64 ) };
	// 823913E8: D8410020  stfd f2, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[2].u64 ) };
	// 823913EC: E9210040  ld r9, 0x40(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(64 as u32) ) };
	// 823913F0: D8210018  stfd f1, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 823913F4: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 823913F8: E8810018  ld r4, 0x18(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 823913FC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82391400: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82391404: 4BFE16A5  bl 0x82372aa8
	ctx.lr = 0x82391408;
	sub_82372AA8(ctx, base);
	pc = 0x82391408; continue 'dispatch;
            }
            0x82391408 => {
    //   block [0x82391408..0x8239141C)
	// 82391408: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8239140C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82391410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82391414: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82391418: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82391420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82391420 size=104
    let mut pc: u32 = 0x82391420;
    'dispatch: loop {
        match pc {
            0x82391420 => {
    //   block [0x82391420..0x8239144C)
	// 82391420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82391424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82391428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8239142C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82391430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82391434: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82391438: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8239143C: 3BEBB6A0  addi r31, r11, -0x4960
	ctx.r[31].s64 = ctx.r[11].s64 + -18784;
	// 82391440: 817F0360  lwz r11, 0x360(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 82391444: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82391448: 40990020  ble cr6, 0x82391468
	if !ctx.cr[6].gt {
	pc = 0x82391468; continue 'dispatch;
	}
	pc = 0x8239144C; continue 'dispatch;
            }
            0x8239144C => {
    //   block [0x8239144C..0x82391468)
	// 8239144C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82391450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82391454: 4BFFFD35  bl 0x82391188
	ctx.lr = 0x82391458;
	sub_82391188(ctx, base);
	// 82391458: 817F0360  lwz r11, 0x360(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 8239145C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82391460: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82391464: 4198FFE8  blt cr6, 0x8239144c
	if ctx.cr[6].lt {
	pc = 0x8239144C; continue 'dispatch;
	}
	pc = 0x82391468; continue 'dispatch;
            }
            0x82391468 => {
    //   block [0x82391468..0x82391488)
	// 82391468: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8239146C: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 82391470: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82391474: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82391478: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8239147C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82391480: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82391484: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82391488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82391488 size=320
    let mut pc: u32 = 0x82391488;
    'dispatch: loop {
        match pc {
            0x82391488 => {
    //   block [0x82391488..0x823914E4)
	// 82391488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8239148C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82391490: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82391494: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82391498: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8239149C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823914A0: FC001890  fmr f0, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[3].f64;
	// 823914A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823914A8: FCA02090  fmr f5, f4
	ctx.f[5].f64 = ctx.f[4].f64;
	// 823914AC: 396BF9DC  addi r11, r11, -0x624
	ctx.r[11].s64 = ctx.r[11].s64 + -1572;
	// 823914B0: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 823914B4: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 823914B8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 823914BC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 823914C0: 7CE358AE  lbzx r7, r3, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823914C4: 41980098  blt cr6, 0x8239155c
	if ctx.cr[6].lt {
	pc = 0x8239155C; continue 'dispatch;
	}
	// 823914C8: 419A008C  beq cr6, 0x82391554
	if ctx.cr[6].eq {
	pc = 0x82391554; continue 'dispatch;
	}
	// 823914CC: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 823914D0: 4198007C  blt cr6, 0x8239154c
	if ctx.cr[6].lt {
	pc = 0x8239154C; continue 'dispatch;
	}
	// 823914D4: 419A0070  beq cr6, 0x82391544
	if ctx.cr[6].eq {
	pc = 0x82391544; continue 'dispatch;
	}
	// 823914D8: 2B030008  cmplwi cr6, r3, 8
	ctx.cr[6].compare_u32(ctx.r[3].u32, 8 as u32, &mut ctx.xer);
	// 823914DC: 409A008C  bne cr6, 0x82391568
	if !ctx.cr[6].eq {
	pc = 0x82391568; continue 'dispatch;
	}
	// 823914E0: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	pc = 0x823914E4; continue 'dispatch;
            }
            0x823914E4 => {
    //   block [0x823914E4..0x8239152C)
	// 823914E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823914E8: D8410020  stfd f2, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[2].u64 ) };
	// 823914EC: 7CFE0774  extsb r30, r7
	ctx.r[30].s64 = ctx.r[7].s8 as i64;
	// 823914F0: D8210018  stfd f1, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 823914F4: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 823914F8: FC800090  fmr f4, f0
	ctx.f[4].f64 = ctx.f[0].f64;
	// 823914FC: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82391500: D8A10058  stfd f5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[5].u64 ) };
	// 82391504: E8810018  ld r4, 0x18(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82391508: D8810050  stfd f4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[4].u64 ) };
	// 8239150C: C86B2000  lfd f3, 0x2000(r11)
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 82391510: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82391514: D8610028  stfd f3, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[3].u64 ) };
	// 82391518: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 8239151C: 386B0300  addi r3, r11, 0x300
	ctx.r[3].s64 = ctx.r[11].s64 + 768;
	// 82391520: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82391524: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82391528: 4BFE1581  bl 0x82372aa8
	ctx.lr = 0x8239152C;
	sub_82372AA8(ctx, base);
	pc = 0x8239152C; continue 'dispatch;
            }
            0x8239152C => {
    //   block [0x8239152C..0x82391544)
	// 8239152C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82391530: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82391534: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82391538: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8239153C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82391540: 4E800020  blr
	return;
            }
            0x82391544 => {
    //   block [0x82391544..0x8239154C)
	// 82391544: 39400013  li r10, 0x13
	ctx.r[10].s64 = 19;
	// 82391548: 48000028  b 0x82391570
	pc = 0x82391570; continue 'dispatch;
            }
            0x8239154C => {
    //   block [0x8239154C..0x82391554)
	// 8239154C: 39400012  li r10, 0x12
	ctx.r[10].s64 = 18;
	// 82391550: 48000020  b 0x82391570
	pc = 0x82391570; continue 'dispatch;
            }
            0x82391554 => {
    //   block [0x82391554..0x8239155C)
	// 82391554: 39400011  li r10, 0x11
	ctx.r[10].s64 = 17;
	// 82391558: 48000018  b 0x82391570
	pc = 0x82391570; continue 'dispatch;
            }
            0x8239155C => {
    //   block [0x8239155C..0x82391568)
	// 8239155C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82391560: 2B030008  cmplwi cr6, r3, 8
	ctx.cr[6].compare_u32(ctx.r[3].u32, 8 as u32, &mut ctx.xer);
	// 82391564: 419AFF80  beq cr6, 0x823914e4
	if ctx.cr[6].eq {
	pc = 0x823914E4; continue 'dispatch;
	}
	pc = 0x82391568; continue 'dispatch;
            }
            0x82391568 => {
    //   block [0x82391568..0x82391570)
	// 82391568: 2B030011  cmplwi cr6, r3, 0x11
	ctx.cr[6].compare_u32(ctx.r[3].u32, 17 as u32, &mut ctx.xer);
	// 8239156C: 419AFF78  beq cr6, 0x823914e4
	if ctx.cr[6].eq {
	pc = 0x823914E4; continue 'dispatch;
	}
	pc = 0x82391570; continue 'dispatch;
            }
            0x82391570 => {
    //   block [0x82391570..0x823915C8)
	// 82391570: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82391574: D8410020  stfd f2, 0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[2].u64 ) };
	// 82391578: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 8239157C: D8210018  stfd f1, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 82391580: 7CFE0774  extsb r30, r7
	ctx.r[30].s64 = ctx.r[7].s8 as i64;
	// 82391584: FC800090  fmr f4, f0
	ctx.f[4].f64 = ctx.f[0].f64;
	// 82391588: 396BB6A0  addi r11, r11, -0x4960
	ctx.r[11].s64 = ctx.r[11].s64 + -18784;
	// 8239158C: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82391590: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 82391594: E8810018  ld r4, 0x18(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82391598: C8692000  lfd f3, 0x2000(r9)
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) };
	// 8239159C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823915A0: D8610028  stfd f3, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[3].u64 ) };
	// 823915A4: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 823915A8: 386902E8  addi r3, r9, 0x2e8
	ctx.r[3].s64 = ctx.r[9].s64 + 744;
	// 823915AC: D8A10058  stfd f5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[5].u64 ) };
	// 823915B0: 392B0370  addi r9, r11, 0x370
	ctx.r[9].s64 = ctx.r[11].s64 + 880;
	// 823915B4: D8810050  stfd f4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[4].u64 ) };
	// 823915B8: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 823915BC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 823915C0: 4BFE14E9  bl 0x82372aa8
	ctx.lr = 0x823915C4;
	sub_82372AA8(ctx, base);
	// 823915C4: 4BFFFF68  b 0x8239152c
	pc = 0x8239152C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823915C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823915C8 size=308
    let mut pc: u32 = 0x823915C8;
    'dispatch: loop {
        match pc {
            0x823915C8 => {
    //   block [0x823915C8..0x82391614)
	// 823915C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823915CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823915D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823915D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823915D8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823915DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823915E0: FC001890  fmr f0, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[3].f64;
	// 823915E4: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 823915E8: FCA02090  fmr f5, f4
	ctx.f[5].f64 = ctx.f[4].f64;
	// 823915EC: 396BF9D0  addi r11, r11, -0x630
	ctx.r[11].s64 = ctx.r[11].s64 + -1584;
	// 823915F0: 38E3FFA0  addi r7, r3, -0x60
	ctx.r[7].s64 = ctx.r[3].s64 + -96;
	// 823915F4: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 823915F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823915FC: 2B070003  cmplwi cr6, r7, 3
	ctx.cr[6].compare_u32(ctx.r[7].u32, 3 as u32, &mut ctx.xer);
	// 82391600: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82391604: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82391608: 88EBFFA6  lbz r7, -0x5a(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-90 as u32) ) } as u64;
	// 8239160C: 41990008  bgt cr6, 0x82391614
	if ctx.cr[6].gt {
	pc = 0x82391614; continue 'dispatch;
	}
	// 82391610: 39400015  li r10, 0x15
	ctx.r[10].s64 = 21;
	pc = 0x82391614; continue 'dispatch;
            }
            0x82391614 => {
    //   block [0x82391614..0x82391690)
	// 82391614: 2B03005A  cmplwi cr6, r3, 0x5a
	ctx.cr[6].compare_u32(ctx.r[3].u32, 90 as u32, &mut ctx.xer);
	// 82391618: 419A0078  beq cr6, 0x82391690
	if ctx.cr[6].eq {
	pc = 0x82391690; continue 'dispatch;
	}
	// 8239161C: 2B03005B  cmplwi cr6, r3, 0x5b
	ctx.cr[6].compare_u32(ctx.r[3].u32, 91 as u32, &mut ctx.xer);
	// 82391620: 419A0070  beq cr6, 0x82391690
	if ctx.cr[6].eq {
	pc = 0x82391690; continue 'dispatch;
	}
	// 82391624: 2B03005C  cmplwi cr6, r3, 0x5c
	ctx.cr[6].compare_u32(ctx.r[3].u32, 92 as u32, &mut ctx.xer);
	// 82391628: 419A0068  beq cr6, 0x82391690
	if ctx.cr[6].eq {
	pc = 0x82391690; continue 'dispatch;
	}
	// 8239162C: 2B03005D  cmplwi cr6, r3, 0x5d
	ctx.cr[6].compare_u32(ctx.r[3].u32, 93 as u32, &mut ctx.xer);
	// 82391630: 419A0060  beq cr6, 0x82391690
	if ctx.cr[6].eq {
	pc = 0x82391690; continue 'dispatch;
	}
	// 82391634: 2B03005E  cmplwi cr6, r3, 0x5e
	ctx.cr[6].compare_u32(ctx.r[3].u32, 94 as u32, &mut ctx.xer);
	// 82391638: 419A0058  beq cr6, 0x82391690
	if ctx.cr[6].eq {
	pc = 0x82391690; continue 'dispatch;
	}
	// 8239163C: 2B03005F  cmplwi cr6, r3, 0x5f
	ctx.cr[6].compare_u32(ctx.r[3].u32, 95 as u32, &mut ctx.xer);
	// 82391640: 419A0050  beq cr6, 0x82391690
	if ctx.cr[6].eq {
	pc = 0x82391690; continue 'dispatch;
	}
	// 82391644: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82391648: D8410020  stfd f2, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[2].u64 ) };
	// 8239164C: 7CFE0774  extsb r30, r7
	ctx.r[30].s64 = ctx.r[7].s8 as i64;
	// 82391650: D8210018  stfd f1, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 82391654: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82391658: FC800090  fmr f4, f0
	ctx.f[4].f64 = ctx.f[0].f64;
	// 8239165C: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82391660: D8A10058  stfd f5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[5].u64 ) };
	// 82391664: E8810018  ld r4, 0x18(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82391668: D8810050  stfd f4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[4].u64 ) };
	// 8239166C: C86B2000  lfd f3, 0x2000(r11)
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 82391670: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82391674: D8610028  stfd f3, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[3].u64 ) };
	// 82391678: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 8239167C: 386B0300  addi r3, r11, 0x300
	ctx.r[3].s64 = ctx.r[11].s64 + 768;
	// 82391680: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82391684: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82391688: 4BFE1421  bl 0x82372aa8
	ctx.lr = 0x8239168C;
	sub_82372AA8(ctx, base);
	// 8239168C: 48000058  b 0x823916e4
	pc = 0x823916E4; continue 'dispatch;
            }
            0x82391690 => {
    //   block [0x82391690..0x823916E4)
	// 82391690: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82391694: D8410020  stfd f2, 0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[2].u64 ) };
	// 82391698: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 8239169C: D8210018  stfd f1, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 823916A0: 7CFE0774  extsb r30, r7
	ctx.r[30].s64 = ctx.r[7].s8 as i64;
	// 823916A4: FC800090  fmr f4, f0
	ctx.f[4].f64 = ctx.f[0].f64;
	// 823916A8: 396BB6A0  addi r11, r11, -0x4960
	ctx.r[11].s64 = ctx.r[11].s64 + -18784;
	// 823916AC: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 823916B0: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 823916B4: E8810018  ld r4, 0x18(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 823916B8: C8692000  lfd f3, 0x2000(r9)
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) };
	// 823916BC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823916C0: D8610028  stfd f3, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[3].u64 ) };
	// 823916C4: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 823916C8: 386902E8  addi r3, r9, 0x2e8
	ctx.r[3].s64 = ctx.r[9].s64 + 744;
	// 823916CC: D8A10058  stfd f5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[5].u64 ) };
	// 823916D0: 392B0370  addi r9, r11, 0x370
	ctx.r[9].s64 = ctx.r[11].s64 + 880;
	// 823916D4: D8810050  stfd f4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[4].u64 ) };
	// 823916D8: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 823916DC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 823916E0: 4BFE13C9  bl 0x82372aa8
	ctx.lr = 0x823916E4;
	sub_82372AA8(ctx, base);
	pc = 0x823916E4; continue 'dispatch;
            }
            0x823916E4 => {
    //   block [0x823916E4..0x823916FC)
	// 823916E4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 823916E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823916EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823916F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823916F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823916F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82391700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82391700 size=356
    //   switch @ 0x82391768: r11 with 12 label(s)
    //       case  0  0x82391778
    //       case  1  0x82391784
    //       case  2  0x82391790
    //       case  3  0x8239179C
    //       case  4  0x823917A8
    //       case  5  0x823917B4
    //       case  6  0x823917C0
    //       case  7  0x823917CC
    //       case  8  0x823917D8
    //       case  9  0x823917E4
    //       case 10  0x823917F0
    //       case 11  0x823917FC
    let mut pc: u32 = 0x82391700;
    'dispatch: loop {
        match pc {
            0x82391700 => {
    //   block [0x82391700..0x82391778)
	// 82391700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82391704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82391708: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8239170C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82391710: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82391714: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82391718: 3940000E  li r10, 0xe
	ctx.r[10].s64 = 14;
	// 8239171C: 396BF978  addi r11, r11, -0x688
	ctx.r[11].s64 = ctx.r[11].s64 + -1672;
	// 82391720: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82391724: 8BEBFF88  lbz r31, -0x78(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-120 as u32) ) } as u64;
	// 82391728: 3D7F0001  addis r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 65536;
	// 8239172C: 396BFFD8  addi r11, r11, -0x28
	ctx.r[11].s64 = ctx.r[11].s64 + -40;
	// 82391730: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82391734: 7D4B53D6  divw r10, r11, r10
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82391738: 1D4A000E  mulli r10, r10, 0xe
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 14 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8239173C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82391740: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82391744: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82391748: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 8239174C: 419900BC  bgt cr6, 0x82391808
	if ctx.cr[6].gt {
	pc = 0x82391808; continue 'dispatch;
	}
	// 82391750: 3D80820C  lis r12, -0x7df4
	ctx.r[12].s64 = -2113142784;
	// 82391754: 398CDCF8  addi r12, r12, -0x2308
	ctx.r[12].s64 = ctx.r[12].s64 + -8968;
	// 82391758: 7C0C58AE  lbzx r0, r12, r11
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8239175C: 3D808239  lis r12, -0x7dc7
	ctx.r[12].s64 = -2110193664;
	// 82391760: 398C1778  addi r12, r12, 0x1778
	ctx.r[12].s64 = ctx.r[12].s64 + 6008;
	// 82391764: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 82391768: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 8239176C: 60000000  nop
	// 82391770: 60000000  nop
	// 82391774: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            0x82391778 => {
    //   block [0x82391778..0x82391784)
	// 82391778: 3D00FFF4  lis r8, -0xc
	ctx.r[8].s64 = -786432;
	// 8239177C: 6108CC2E  ori r8, r8, 0xcc2e
	ctx.r[8].u64 = ctx.r[8].u64 | 52270;
	// 82391780: 48000090  b 0x82391810
	pc = 0x82391810; continue 'dispatch;
            }
            0x82391784 => {
    //   block [0x82391784..0x82391790)
	// 82391784: 3D00FF10  lis r8, -0xf0
	ctx.r[8].s64 = -15728640;
	// 82391788: 6108B653  ori r8, r8, 0xb653
	ctx.r[8].u64 = ctx.r[8].u64 | 46675;
	// 8239178C: 48000084  b 0x82391810
	pc = 0x82391810; continue 'dispatch;
            }
            0x82391790 => {
    //   block [0x82391790..0x8239179C)
	// 82391790: 3D00FFAF  lis r8, -0x51
	ctx.r[8].s64 = -5308416;
	// 82391794: 6108DCFF  ori r8, r8, 0xdcff
	ctx.r[8].u64 = ctx.r[8].u64 | 56575;
	// 82391798: 48000078  b 0x82391810
	pc = 0x82391810; continue 'dispatch;
            }
            0x8239179C => {
    //   block [0x8239179C..0x823917A8)
	// 8239179C: 3D00FF67  lis r8, -0x99
	ctx.r[8].s64 = -10027008;
	// 823917A0: 61089AFF  ori r8, r8, 0x9aff
	ctx.r[8].u64 = ctx.r[8].u64 | 39679;
	// 823917A4: 4800006C  b 0x82391810
	pc = 0x82391810; continue 'dispatch;
            }
            0x823917A8 => {
    //   block [0x823917A8..0x823917B4)
	// 823917A8: 3D00FFE6  lis r8, -0x1a
	ctx.r[8].s64 = -1703936;
	// 823917AC: 61088C94  ori r8, r8, 0x8c94
	ctx.r[8].u64 = ctx.r[8].u64 | 35988;
	// 823917B0: 48000060  b 0x82391810
	pc = 0x82391810; continue 'dispatch;
            }
            0x823917B4 => {
    //   block [0x823917B4..0x823917C0)
	// 823917B4: 3D00FFF0  lis r8, -0x10
	ctx.r[8].s64 = -1048576;
	// 823917B8: 6108424A  ori r8, r8, 0x424a
	ctx.r[8].u64 = ctx.r[8].u64 | 16970;
	// 823917BC: 48000054  b 0x82391810
	pc = 0x82391810; continue 'dispatch;
            }
            0x823917C0 => {
    //   block [0x823917C0..0x823917CC)
	// 823917C0: 3D00FFFF  lis r8, -1
	ctx.r[8].s64 = -65536;
	// 823917C4: 61086C00  ori r8, r8, 0x6c00
	ctx.r[8].u64 = ctx.r[8].u64 | 27648;
	// 823917C8: 48000048  b 0x82391810
	pc = 0x82391810; continue 'dispatch;
            }
            0x823917CC => {
    //   block [0x823917CC..0x823917D8)
	// 823917CC: 3D00FF7C  lis r8, -0x84
	ctx.r[8].s64 = -8650752;
	// 823917D0: 6108FFB1  ori r8, r8, 0xffb1
	ctx.r[8].u64 = ctx.r[8].u64 | 65457;
	// 823917D4: 4800003C  b 0x82391810
	pc = 0x82391810; continue 'dispatch;
            }
            0x823917D8 => {
    //   block [0x823917D8..0x823917E4)
	// 823917D8: 3D00FF2D  lis r8, -0xd3
	ctx.r[8].s64 = -13828096;
	// 823917DC: 610864FF  ori r8, r8, 0x64ff
	ctx.r[8].u64 = ctx.r[8].u64 | 25855;
	// 823917E0: 48000030  b 0x82391810
	pc = 0x82391810; continue 'dispatch;
            }
            0x823917E4 => {
    //   block [0x823917E4..0x823917F0)
	// 823917E4: 3D00FF9C  lis r8, -0x64
	ctx.r[8].s64 = -6553600;
	// 823917E8: 610880FF  ori r8, r8, 0x80ff
	ctx.r[8].u64 = ctx.r[8].u64 | 33023;
	// 823917EC: 48000024  b 0x82391810
	pc = 0x82391810; continue 'dispatch;
            }
            0x823917F0 => {
    //   block [0x823917F0..0x823917FC)
	// 823917F0: 3D00FF00  lis r8, -0x100
	ctx.r[8].s64 = -16777216;
	// 823917F4: 6108F7F7  ori r8, r8, 0xf7f7
	ctx.r[8].u64 = ctx.r[8].u64 | 63479;
	// 823917F8: 48000018  b 0x82391810
	pc = 0x82391810; continue 'dispatch;
            }
            0x823917FC => {
    //   block [0x823917FC..0x82391808)
	// 823917FC: 3D00FFFD  lis r8, -3
	ctx.r[8].s64 = -196608;
	// 82391800: 6108F56E  ori r8, r8, 0xf56e
	ctx.r[8].u64 = ctx.r[8].u64 | 62830;
	// 82391804: 4800000C  b 0x82391810
	pc = 0x82391810; continue 'dispatch;
            }
            0x82391808 => {
    //   block [0x82391808..0x82391810)
	// 82391808: 3D00FFB1  lis r8, -0x4f
	ctx.r[8].s64 = -5177344;
	// 8239180C: 610836D9  ori r8, r8, 0x36d9
	ctx.r[8].u64 = ctx.r[8].u64 | 14041;
	pc = 0x82391810; continue 'dispatch;
            }
            0x82391810 => {
    //   block [0x82391810..0x82391864)
	// 82391810: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82391814: D8610048  stfd f3, 0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.f[3].u64 ) };
	// 82391818: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8239181C: D8410020  stfd f2, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[2].u64 ) };
	// 82391820: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82391824: D8210018  stfd f1, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 82391828: 386B0318  addi r3, r11, 0x318
	ctx.r[3].s64 = ctx.r[11].s64 + 792;
	// 8239182C: E9410048  ld r10, 0x48(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(72 as u32) ) };
	// 82391830: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 82391834: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82391838: E8810018  ld r4, 0x18(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 8239183C: D8810050  stfd f4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[4].u64 ) };
	// 82391840: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82391844: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82391848: 4BFE1261  bl 0x82372aa8
	ctx.lr = 0x8239184C;
	sub_82372AA8(ctx, base);
	// 8239184C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82391850: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82391854: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82391858: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8239185C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82391860: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82391868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82391868 size=228
    //   switch @ 0x8239188C: r11 with 26 label(s)
    //       case  0  0x8239189C
    //       case  1  0x823918A4
    //       case  2  0x823918AC
    //       case  3  0x823918B4
    //       case  4  0x823918BC
    //       case  5  0x823918C4
    //       case  6  0x823918CC
    //       case  7  0x823918D4
    //       case  8  0x823918DC
    //       case  9  0x823918E4
    //       case 10  0x823918EC
    //       case 11  0x823918F4
    //       case 12  0x823918FC
    //       case 13  0x82391904
    //       case 14  0x8239190C
    //       case 15  0x82391914
    //       case 16  0x82391948
    //       case 17  0x82391948
    //       case 18  0x82391948
    //       case 19  0x82391948
    //       case 20  0x8239191C
    //       case 21  0x82391924
    //       case 22  0x8239192C
    //       case 23  0x82391934
    //       case 24  0x8239193C
    //       case 25  0x82391944
    let mut pc: u32 = 0x82391868;
    'dispatch: loop {
        match pc {
            0x82391868 => {
    //   block [0x82391868..0x8239189C)
	// 82391868: 3963FF1A  addi r11, r3, -0xe6
	ctx.r[11].s64 = ctx.r[3].s64 + -230;
	// 8239186C: 2B0B0019  cmplwi cr6, r11, 0x19
	ctx.cr[6].compare_u32(ctx.r[11].u32, 25 as u32, &mut ctx.xer);
	// 82391870: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
	// 82391874: 3D80820C  lis r12, -0x7df4
	ctx.r[12].s64 = -2113142784;
	// 82391878: 398CDA88  addi r12, r12, -0x2578
	ctx.r[12].s64 = ctx.r[12].s64 + -9592;
	// 8239187C: 7C0C58AE  lbzx r0, r12, r11
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82391880: 3D808239  lis r12, -0x7dc7
	ctx.r[12].s64 = -2110193664;
	// 82391884: 398C189C  addi r12, r12, 0x189c
	ctx.r[12].s64 = ctx.r[12].s64 + 6300;
	// 82391888: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 8239188C: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 82391890: 60000000  nop
	// 82391894: 60000000  nop
	// 82391898: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            0x8239189C => {
    //   block [0x8239189C..0x823918A4)
	// 8239189C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823918A0: 4E800020  blr
	return;
            }
            0x823918A4 => {
    //   block [0x823918A4..0x823918AC)
	// 823918A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823918A8: 4E800020  blr
	return;
            }
            0x823918AC => {
    //   block [0x823918AC..0x823918B4)
	// 823918AC: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 823918B0: 4E800020  blr
	return;
            }
            0x823918B4 => {
    //   block [0x823918B4..0x823918BC)
	// 823918B4: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 823918B8: 4E800020  blr
	return;
            }
            0x823918BC => {
    //   block [0x823918BC..0x823918C4)
	// 823918BC: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 823918C0: 4E800020  blr
	return;
            }
            0x823918C4 => {
    //   block [0x823918C4..0x823918CC)
	// 823918C4: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 823918C8: 4E800020  blr
	return;
            }
            0x823918CC => {
    //   block [0x823918CC..0x823918D4)
	// 823918CC: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 823918D0: 4E800020  blr
	return;
            }
            0x823918D4 => {
    //   block [0x823918D4..0x823918DC)
	// 823918D4: 38600007  li r3, 7
	ctx.r[3].s64 = 7;
	// 823918D8: 4E800020  blr
	return;
            }
            0x823918DC => {
    //   block [0x823918DC..0x823918E4)
	// 823918DC: 38600009  li r3, 9
	ctx.r[3].s64 = 9;
	// 823918E0: 4E800020  blr
	return;
            }
            0x823918E4 => {
    //   block [0x823918E4..0x823918EC)
	// 823918E4: 3860000A  li r3, 0xa
	ctx.r[3].s64 = 10;
	// 823918E8: 4E800020  blr
	return;
            }
            0x823918EC => {
    //   block [0x823918EC..0x823918F4)
	// 823918EC: 3860000B  li r3, 0xb
	ctx.r[3].s64 = 11;
	// 823918F0: 4E800020  blr
	return;
            }
            0x823918F4 => {
    //   block [0x823918F4..0x823918FC)
	// 823918F4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 823918F8: 4E800020  blr
	return;
            }
            0x823918FC => {
    //   block [0x823918FC..0x82391904)
	// 823918FC: 3860000D  li r3, 0xd
	ctx.r[3].s64 = 13;
	// 82391900: 4E800020  blr
	return;
            }
            0x82391904 => {
    //   block [0x82391904..0x8239190C)
	// 82391904: 3860000E  li r3, 0xe
	ctx.r[3].s64 = 14;
	// 82391908: 4E800020  blr
	return;
            }
            0x8239190C => {
    //   block [0x8239190C..0x82391914)
	// 8239190C: 3860000F  li r3, 0xf
	ctx.r[3].s64 = 15;
	// 82391910: 4E800020  blr
	return;
            }
            0x82391914 => {
    //   block [0x82391914..0x8239191C)
	// 82391914: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82391918: 4E800020  blr
	return;
            }
            0x8239191C => {
    //   block [0x8239191C..0x82391924)
	// 8239191C: 3860005A  li r3, 0x5a
	ctx.r[3].s64 = 90;
	// 82391920: 4E800020  blr
	return;
            }
            0x82391924 => {
    //   block [0x82391924..0x8239192C)
	// 82391924: 3860005B  li r3, 0x5b
	ctx.r[3].s64 = 91;
	// 82391928: 4E800020  blr
	return;
            }
            0x8239192C => {
    //   block [0x8239192C..0x82391934)
	// 8239192C: 3860005C  li r3, 0x5c
	ctx.r[3].s64 = 92;
	// 82391930: 4E800020  blr
	return;
            }
            0x82391934 => {
    //   block [0x82391934..0x8239193C)
	// 82391934: 3860005D  li r3, 0x5d
	ctx.r[3].s64 = 93;
	// 82391938: 4E800020  blr
	return;
            }
            0x8239193C => {
    //   block [0x8239193C..0x82391944)
	// 8239193C: 3860005E  li r3, 0x5e
	ctx.r[3].s64 = 94;
	// 82391940: 4E800020  blr
	return;
            }
            0x82391944 => {
    //   block [0x82391944..0x82391948)
	// 82391944: 3860005F  li r3, 0x5f
	ctx.r[3].s64 = 95;
	pc = 0x82391948; continue 'dispatch;
            }
            0x82391948 => {
    //   block [0x82391948..0x8239194C)
	// 82391948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82391950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82391950 size=216
    let mut pc: u32 = 0x82391950;
    'dispatch: loop {
        match pc {
            0x82391950 => {
    //   block [0x82391950..0x823919AC)
	// 82391950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82391954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82391958: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8239195C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82391960: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82391964: FC001890  fmr f0, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[3].f64;
	// 82391968: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 8239196C: FCA02090  fmr f5, f4
	ctx.f[5].f64 = ctx.f[4].f64;
	// 82391970: 4BFFFEF9  bl 0x82391868
	ctx.lr = 0x82391974;
	sub_82391868(ctx, base);
	// 82391974: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82391978: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8239197C: 396BF9DC  addi r11, r11, -0x624
	ctx.r[11].s64 = ctx.r[11].s64 + -1572;
	// 82391980: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82391984: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82391988: 4198003C  blt cr6, 0x823919c4
	if ctx.cr[6].lt {
	pc = 0x823919C4; continue 'dispatch;
	}
	// 8239198C: 419A0030  beq cr6, 0x823919bc
	if ctx.cr[6].eq {
	pc = 0x823919BC; continue 'dispatch;
	}
	// 82391990: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 82391994: 41980020  blt cr6, 0x823919b4
	if ctx.cr[6].lt {
	pc = 0x823919B4; continue 'dispatch;
	}
	// 82391998: 419A0014  beq cr6, 0x823919ac
	if ctx.cr[6].eq {
	pc = 0x823919AC; continue 'dispatch;
	}
	// 8239199C: 2B030008  cmplwi cr6, r3, 8
	ctx.cr[6].compare_u32(ctx.r[3].u32, 8 as u32, &mut ctx.xer);
	// 823919A0: 409A0028  bne cr6, 0x823919c8
	if !ctx.cr[6].eq {
	pc = 0x823919C8; continue 'dispatch;
	}
	// 823919A4: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 823919A8: 48000020  b 0x823919c8
	pc = 0x823919C8; continue 'dispatch;
            }
            0x823919AC => {
    //   block [0x823919AC..0x823919B4)
	// 823919AC: 39400013  li r10, 0x13
	ctx.r[10].s64 = 19;
	// 823919B0: 48000018  b 0x823919c8
	pc = 0x823919C8; continue 'dispatch;
            }
            0x823919B4 => {
    //   block [0x823919B4..0x823919BC)
	// 823919B4: 39400012  li r10, 0x12
	ctx.r[10].s64 = 18;
	// 823919B8: 48000010  b 0x823919c8
	pc = 0x823919C8; continue 'dispatch;
            }
            0x823919BC => {
    //   block [0x823919BC..0x823919C4)
	// 823919BC: 39400011  li r10, 0x11
	ctx.r[10].s64 = 17;
	// 823919C0: 48000008  b 0x823919c8
	pc = 0x823919C8; continue 'dispatch;
            }
            0x823919C4 => {
    //   block [0x823919C4..0x823919C8)
	// 823919C4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	pc = 0x823919C8; continue 'dispatch;
            }
            0x823919C8 => {
    //   block [0x823919C8..0x82391A28)
	// 823919C8: 7D7F0774  extsb r31, r11
	ctx.r[31].s64 = ctx.r[11].s8 as i64;
	// 823919CC: D8410020  stfd f2, 0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[2].u64 ) };
	// 823919D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823919D4: D8210018  stfd f1, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 823919D8: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 823919DC: FC800090  fmr f4, f0
	ctx.f[4].f64 = ctx.f[0].f64;
	// 823919E0: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 823919E4: D8A10058  stfd f5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[5].u64 ) };
	// 823919E8: E8810018  ld r4, 0x18(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 823919EC: D8810050  stfd f4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[4].u64 ) };
	// 823919F0: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 823919F4: C86B2000  lfd f3, 0x2000(r11)
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 823919F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823919FC: D8610028  stfd f3, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[3].u64 ) };
	// 82391A00: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 82391A04: 386B0300  addi r3, r11, 0x300
	ctx.r[3].s64 = ctx.r[11].s64 + 768;
	// 82391A08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82391A0C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82391A10: 4BFE1099  bl 0x82372aa8
	ctx.lr = 0x82391A14;
	sub_82372AA8(ctx, base);
	// 82391A14: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82391A18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82391A1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82391A20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82391A24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82391A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82391A28 size=92
    let mut pc: u32 = 0x82391A28;
    'dispatch: loop {
        match pc {
            0x82391A28 => {
    //   block [0x82391A28..0x82391A48)
	// 82391A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82391A2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82391A30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82391A34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82391A38: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82391A3C: 4802FE3D  bl 0x823c1878
	ctx.lr = 0x82391A40;
	sub_823C1878(ctx, base);
	// 82391A40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82391A44: 396BB020  addi r11, r11, -0x4fe0
	ctx.r[11].s64 = ctx.r[11].s64 + -20448;
	pc = 0x82391A48; continue 'dispatch;
            }
            0x82391A48 => {
    //   block [0x82391A48..0x82391A68)
	// 82391A48: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82391A4C: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82391A50: 419A0018  beq cr6, 0x82391a68
	if ctx.cr[6].eq {
	pc = 0x82391A68; continue 'dispatch;
	}
	// 82391A54: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82391A58: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82391A5C: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 82391A60: 409AFFE8  bne cr6, 0x82391a48
	if !ctx.cr[6].eq {
	pc = 0x82391A48; continue 'dispatch;
	}
	// 82391A64: 48000008  b 0x82391a6c
	pc = 0x82391A6C; continue 'dispatch;
            }
            0x82391A68 => {
    //   block [0x82391A68..0x82391A6C)
	// 82391A68: 8BEB0001  lbz r31, 1(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	pc = 0x82391A6C; continue 'dispatch;
            }
            0x82391A6C => {
    //   block [0x82391A6C..0x82391A84)
	// 82391A6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82391A70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82391A74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82391A78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82391A7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82391A80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82391A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82391A88 size=324
    let mut pc: u32 = 0x82391A88;
    'dispatch: loop {
        match pc {
            0x82391A88 => {
    //   block [0x82391A88..0x82391AB8)
	// 82391A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82391A8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82391A90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82391A94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82391A98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82391A9C: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82391AA0: 3BEBBAB0  addi r31, r11, -0x4550
	ctx.r[31].s64 = ctx.r[11].s64 + -17744;
	// 82391AA4: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82391AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82391AAC: 419A0108  beq cr6, 0x82391bb4
	if ctx.cr[6].eq {
	pc = 0x82391BB4; continue 'dispatch;
	}
	// 82391AB0: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 82391AB4: 395F0054  addi r10, r31, 0x54
	ctx.r[10].s64 = ctx.r[31].s64 + 84;
	pc = 0x82391AB8; continue 'dispatch;
            }
            0x82391AB8 => {
    //   block [0x82391AB8..0x82391AEC)
	// 82391AB8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82391ABC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82391AC0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82391AC4: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82391AC8: 4082FFF0  bne 0x82391ab8
	if !ctx.cr[0].eq {
	pc = 0x82391AB8; continue 'dispatch;
	}
	// 82391ACC: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82391AD0: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82391AD4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82391AD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82391ADC: 4837B521  bl 0x8270cffc
	ctx.lr = 0x82391AE0;
	// extern call 0x8270CFFC  crate::xboxkrnl::XNotifyGetNext
	crate::xboxkrnl::XNotifyGetNext(ctx, base);
	// 82391AE0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82391AE4: 418200D0  beq 0x82391bb4
	if ctx.cr[0].eq {
	pc = 0x82391BB4; continue 'dispatch;
	}
	// 82391AE8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x82391AEC; continue 'dispatch;
            }
            0x82391AEC => {
    //   block [0x82391AEC..0x82391B3C)
	// 82391AEC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82391AF0: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 82391AF4: 419A0078  beq cr6, 0x82391b6c
	if ctx.cr[6].eq {
	pc = 0x82391B6C; continue 'dispatch;
	}
	// 82391AF8: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 82391AFC: 419A0068  beq cr6, 0x82391b64
	if ctx.cr[6].eq {
	pc = 0x82391B64; continue 'dispatch;
	}
	// 82391B00: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 82391B04: 419A0058  beq cr6, 0x82391b5c
	if ctx.cr[6].eq {
	pc = 0x82391B5C; continue 'dispatch;
	}
	// 82391B08: 2B0B000E  cmplwi cr6, r11, 0xe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 14 as u32, &mut ctx.xer);
	// 82391B0C: 419A0048  beq cr6, 0x82391b54
	if ctx.cr[6].eq {
	pc = 0x82391B54; continue 'dispatch;
	}
	// 82391B10: 2B0B0011  cmplwi cr6, r11, 0x11
	ctx.cr[6].compare_u32(ctx.r[11].u32, 17 as u32, &mut ctx.xer);
	// 82391B14: 419A0038  beq cr6, 0x82391b4c
	if ctx.cr[6].eq {
	pc = 0x82391B4C; continue 'dispatch;
	}
	// 82391B18: 2B0B0012  cmplwi cr6, r11, 0x12
	ctx.cr[6].compare_u32(ctx.r[11].u32, 18 as u32, &mut ctx.xer);
	// 82391B1C: 419A0028  beq cr6, 0x82391b44
	if ctx.cr[6].eq {
	pc = 0x82391B44; continue 'dispatch;
	}
	// 82391B20: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 82391B24: 614A0013  ori r10, r10, 0x13
	ctx.r[10].u64 = ctx.r[10].u64 | 19;
	// 82391B28: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82391B2C: 419A0010  beq cr6, 0x82391b3c
	if ctx.cr[6].eq {
	pc = 0x82391B3C; continue 'dispatch;
	}
	// 82391B30: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82391B34: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82391B38: 48000060  b 0x82391b98
	pc = 0x82391B98; continue 'dispatch;
            }
            0x82391B3C => {
    //   block [0x82391B3C..0x82391B44)
	// 82391B3C: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82391B40: 48000030  b 0x82391b70
	pc = 0x82391B70; continue 'dispatch;
            }
            0x82391B44 => {
    //   block [0x82391B44..0x82391B4C)
	// 82391B44: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82391B48: 48000028  b 0x82391b70
	pc = 0x82391B70; continue 'dispatch;
            }
            0x82391B4C => {
    //   block [0x82391B4C..0x82391B54)
	// 82391B4C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82391B50: 48000020  b 0x82391b70
	pc = 0x82391B70; continue 'dispatch;
            }
            0x82391B54 => {
    //   block [0x82391B54..0x82391B5C)
	// 82391B54: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82391B58: 48000018  b 0x82391b70
	pc = 0x82391B70; continue 'dispatch;
            }
            0x82391B5C => {
    //   block [0x82391B5C..0x82391B64)
	// 82391B5C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82391B60: 48000010  b 0x82391b70
	pc = 0x82391B70; continue 'dispatch;
            }
            0x82391B64 => {
    //   block [0x82391B64..0x82391B6C)
	// 82391B64: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82391B68: 48000008  b 0x82391b70
	pc = 0x82391B70; continue 'dispatch;
            }
            0x82391B6C => {
    //   block [0x82391B6C..0x82391B70)
	// 82391B6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82391B70; continue 'dispatch;
            }
            0x82391B70 => {
    //   block [0x82391B70..0x82391B98)
	// 82391B70: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82391B74: 395F0048  addi r10, r31, 0x48
	ctx.r[10].s64 = ctx.r[31].s64 + 72;
	// 82391B78: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82391B7C: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82391B80: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82391B84: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82391B88: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82391B8C: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82391B90: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82391B94: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82391B98; continue 'dispatch;
            }
            0x82391B98 => {
    //   block [0x82391B98..0x82391BB4)
	// 82391B98: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82391B9C: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82391BA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82391BA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82391BA8: 4837B455  bl 0x8270cffc
	ctx.lr = 0x82391BAC;
	// extern call 0x8270CFFC  crate::xboxkrnl::XNotifyGetNext
	crate::xboxkrnl::XNotifyGetNext(ctx, base);
	// 82391BAC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82391BB0: 4082FF3C  bne 0x82391aec
	if !ctx.cr[0].eq {
	pc = 0x82391AEC; continue 'dispatch;
	}
	pc = 0x82391BB4; continue 'dispatch;
            }
            0x82391BB4 => {
    //   block [0x82391BB4..0x82391BCC)
	// 82391BB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82391BB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82391BBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82391BC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82391BC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82391BC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82391BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82391BD0 size=36
    let mut pc: u32 = 0x82391BD0;
    'dispatch: loop {
        match pc {
            0x82391BD0 => {
    //   block [0x82391BD0..0x82391BF4)
	// 82391BD0: 81430098  lwz r10, 0x98(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 82391BD4: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82391BD8: 81230030  lwz r9, 0x30(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82391BDC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82391BE0: 396BBA8C  addi r11, r11, -0x4574
	ctx.r[11].s64 = ctx.r[11].s64 + -17780;
	// 82391BE4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82391BE8: 9903001C  stb r8, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[8].u8 ) };
	// 82391BEC: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 82391BF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82391BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82391BF8 size=36
    let mut pc: u32 = 0x82391BF8;
    'dispatch: loop {
        match pc {
            0x82391BF8 => {
    //   block [0x82391BF8..0x82391C1C)
	// 82391BF8: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 82391BFC: 81630098  lwz r11, 0x98(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 82391C00: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82391C04: 394ABA8C  addi r10, r10, -0x4574
	ctx.r[10].s64 = ctx.r[10].s64 + -17780;
	// 82391C08: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82391C0C: 390A0020  addi r8, r10, 0x20
	ctx.r[8].s64 = ctx.r[10].s64 + 32;
	// 82391C10: 7D27512E  stwx r9, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 82391C14: 7D2B41AE  stbx r9, r11, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u8) };
	// 82391C18: 480001F8  b 0x82391e10
	sub_82391E10(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82391C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82391C20 size=492
    let mut pc: u32 = 0x82391C20;
    'dispatch: loop {
        match pc {
            0x82391C20 => {
    //   block [0x82391C20..0x82391C80)
	// 82391C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82391C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82391C28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82391C2C: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82391C30: 481A43AD  bl 0x82535fdc
	ctx.lr = 0x82391C34;
	sub_82535FB0(ctx, base);
	// 82391C34: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82391C38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82391C3C: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82391C40: 396BBA8C  addi r11, r11, -0x4574
	ctx.r[11].s64 = ctx.r[11].s64 + -17780;
	// 82391C44: 815F0098  lwz r10, 0x98(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82391C48: 811F0030  lwz r8, 0x30(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82391C4C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82391C50: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82391C54: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82391C58: 419A0028  beq cr6, 0x82391c80
	if ctx.cr[6].eq {
	pc = 0x82391C80; continue 'dispatch;
	}
	// 82391C5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82391C60: 419A0020  beq cr6, 0x82391c80
	if ctx.cr[6].eq {
	pc = 0x82391C80; continue 'dispatch;
	}
	// 82391C64: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82391C68: 3D20830F  lis r9, -0x7cf1
	ctx.r[9].s64 = -2096168960;
	// 82391C6C: 991F001C  stb r8, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[8].u8 ) };
	// 82391C70: 8129FAC0  lwz r9, -0x540(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82391C74: 7D0A592E  stwx r8, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 82391C78: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82391C7C: 48000030  b 0x82391cac
	pc = 0x82391CAC; continue 'dispatch;
            }
            0x82391C80 => {
    //   block [0x82391C80..0x82391CAC)
	// 82391C80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82391C84: C01F00A0  lfs f0, 0xa0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391C88: C32B1FF8  lfs f25, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82391C8C: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82391C90: 40980034  bge cr6, 0x82391cc4
	if !ctx.cr[6].lt {
	pc = 0x82391CC4; continue 'dispatch;
	}
	// 82391C94: C01F00A4  lfs f0, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391C98: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82391C9C: 40980028  bge cr6, 0x82391cc4
	if !ctx.cr[6].lt {
	pc = 0x82391CC4; continue 'dispatch;
	}
	// 82391CA0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82391CA4: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82391CA8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	pc = 0x82391CAC; continue 'dispatch;
            }
            0x82391CAC => {
    //   block [0x82391CAC..0x82391CC4)
	// 82391CAC: 409A0144  bne cr6, 0x82391df0
	if !ctx.cr[6].eq {
	pc = 0x82391DF0; continue 'dispatch;
	}
	// 82391CB0: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82391CB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82391CB8: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82391CBC: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 82391CC0: 48000130  b 0x82391df0
	pc = 0x82391DF0; continue 'dispatch;
            }
            0x82391CC4 => {
    //   block [0x82391CC4..0x82391D60)
	// 82391CC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82391CC8: 48000149  bl 0x82391e10
	ctx.lr = 0x82391CCC;
	sub_82391E10(ctx, base);
	// 82391CCC: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 82391CD0: C1BF009C  lfs f13, 0x9c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82391CD4: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 82391CD8: 396B0C40  addi r11, r11, 0xc40
	ctx.r[11].s64 = ctx.r[11].s64 + 3136;
	// 82391CDC: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 82391CE0: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82391CE4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82391CE8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82391CEC: C3E6BA38  lfs f31, -0x45c8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82391CF0: C00B06B4  lfs f0, 0x6b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1716 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391CF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82391CF8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82391CFC: C1BF0084  lfs f13, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82391D00: CB682008  lfd f27, 0x2008(r8)
	ctx.f[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8200 as u32) ) };
	// 82391D04: C349BFFC  lfs f26, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82391D08: C3AA24B4  lfs f29, 0x24b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9396 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82391D0C: C3CB2604  lfs f30, 0x2604(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9732 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82391D10: CB872000  lfd f28, 0x2000(r7)
	ctx.f[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8192 as u32) ) };
	// 82391D14: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82391D18: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82391D1C: 40980060  bge cr6, 0x82391d7c
	if !ctx.cr[6].lt {
	pc = 0x82391D7C; continue 'dispatch;
	}
	// 82391D20: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82391D24: EC20EFBA  fmadds f1, f0, f30, f29
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[29].f64) as f32) as f64);
	// 82391D28: 4BD8B7A1  bl 0x8211d4c8
	ctx.lr = 0x82391D2C;
	sub_8211D4C8(ctx, base);
	// 82391D2C: EDA1F82A  fadds f13, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 82391D30: C01F0080  lfs f0, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391D34: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82391D38: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82391D3C: 4BFD574D  bl 0x82367488
	ctx.lr = 0x82391D40;
	sub_82367488(ctx, base);
	// 82391D40: C01F0088  lfs f0, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391D44: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82391D48: 40980018  bge cr6, 0x82391d60
	if !ctx.cr[6].lt {
	pc = 0x82391D60; continue 'dispatch;
	}
	// 82391D4C: 4BFD57BD  bl 0x82367508
	ctx.lr = 0x82391D50;
	sub_82367508(ctx, base);
	// 82391D50: EDA1FEBA  fmadds f13, f1, f26, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[26].f64 + ctx.f[31].f64) as f32) as f64);
	// 82391D54: C01F00A0  lfs f0, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391D58: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82391D5C: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	pc = 0x82391D60; continue 'dispatch;
            }
            0x82391D60 => {
    //   block [0x82391D60..0x82391D7C)
	// 82391D60: C01F00A0  lfs f0, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391D64: FC00D82E  fsel f0, f0, f0, f27
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[27].f64 };
	// 82391D68: FDA0E028  fsub f13, f0, f28
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[28].f64;
	// 82391D6C: FC0D072E  fsel f0, f13, f28, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[28].f64 } else { ctx.f[0].f64 };
	// 82391D70: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82391D74: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82391D78: 48000008  b 0x82391d80
	pc = 0x82391D80; continue 'dispatch;
            }
            0x82391D7C => {
    //   block [0x82391D7C..0x82391D80)
	// 82391D7C: D33F00A0  stfs f25, 0xa0(r31)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	pc = 0x82391D80; continue 'dispatch;
            }
            0x82391D80 => {
    //   block [0x82391D80..0x82391DD0)
	// 82391D80: C01F009C  lfs f0, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391D84: C1BF0090  lfs f13, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82391D88: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82391D8C: 40980060  bge cr6, 0x82391dec
	if !ctx.cr[6].lt {
	pc = 0x82391DEC; continue 'dispatch;
	}
	// 82391D90: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82391D94: EC20EFBA  fmadds f1, f0, f30, f29
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[29].f64) as f32) as f64);
	// 82391D98: 4BD8B731  bl 0x8211d4c8
	ctx.lr = 0x82391D9C;
	sub_8211D4C8(ctx, base);
	// 82391D9C: EDA1F82A  fadds f13, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 82391DA0: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391DA4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82391DA8: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82391DAC: 4BFD575D  bl 0x82367508
	ctx.lr = 0x82391DB0;
	sub_82367508(ctx, base);
	// 82391DB0: C01F0094  lfs f0, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391DB4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82391DB8: 40980018  bge cr6, 0x82391dd0
	if !ctx.cr[6].lt {
	pc = 0x82391DD0; continue 'dispatch;
	}
	// 82391DBC: 4BFD56CD  bl 0x82367488
	ctx.lr = 0x82391DC0;
	sub_82367488(ctx, base);
	// 82391DC0: EDA1FEBA  fmadds f13, f1, f26, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[26].f64 + ctx.f[31].f64) as f32) as f64);
	// 82391DC4: C01F00A4  lfs f0, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391DC8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82391DCC: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	pc = 0x82391DD0; continue 'dispatch;
            }
            0x82391DD0 => {
    //   block [0x82391DD0..0x82391DEC)
	// 82391DD0: C01F00A4  lfs f0, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391DD4: FC00D82E  fsel f0, f0, f0, f27
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[27].f64 };
	// 82391DD8: FDA0E028  fsub f13, f0, f28
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[28].f64;
	// 82391DDC: FC0D072E  fsel f0, f13, f28, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[28].f64 } else { ctx.f[0].f64 };
	// 82391DE0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82391DE4: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82391DE8: 48000008  b 0x82391df0
	pc = 0x82391DF0; continue 'dispatch;
            }
            0x82391DEC => {
    //   block [0x82391DEC..0x82391DF0)
	// 82391DEC: D33F00A4  stfs f25, 0xa4(r31)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	pc = 0x82391DF0; continue 'dispatch;
            }
            0x82391DF0 => {
    //   block [0x82391DF0..0x82391E0C)
	// 82391DF0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82391DF4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82391DF8: 481A4231  bl 0x82536028
	ctx.lr = 0x82391DFC;
	sub_82535FFC(ctx, base);
	// 82391DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82391E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82391E04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82391E08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82391E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82391E10 size=220
    let mut pc: u32 = 0x82391E10;
    'dispatch: loop {
        match pc {
            0x82391E10 => {
    //   block [0x82391E10..0x82391E70)
	// 82391E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82391E14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82391E18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82391E1C: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 82391E20: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82391E24: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82391E28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82391E2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82391E30: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82391E34: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82391E38: 396BBA8C  addi r11, r11, -0x4574
	ctx.r[11].s64 = ctx.r[11].s64 + -17780;
	// 82391E3C: 813F0098  lwz r9, 0x98(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82391E40: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82391E44: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82391E48: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 82391E4C: 7D6B48AE  lbzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82391E50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82391E54: 41820058  beq 0x82391eac
	if ctx.cr[0].eq {
	pc = 0x82391EAC; continue 'dispatch;
	}
	// 82391E58: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82391E5C: C01F00A0  lfs f0, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391E60: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82391E64: C3CB9F78  lfs f30, -0x6088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82391E68: 409A0008  bne cr6, 0x82391e70
	if !ctx.cr[6].eq {
	pc = 0x82391E70; continue 'dispatch;
	}
	// 82391E6C: 4800001C  b 0x82391e88
	pc = 0x82391E88; continue 'dispatch;
            }
            0x82391E70 => {
    //   block [0x82391E70..0x82391E88)
	// 82391E70: FC200210  fabs f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82391E74: 481A1165  bl 0x82532fd8
	ctx.lr = 0x82391E78;
	sub_82532FD8(ctx, base);
	// 82391E78: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82391E7C: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82391E80: 481A1619  bl 0x82533498
	ctx.lr = 0x82391E84;
	sub_82533498(ctx, base);
	// 82391E84: FFA00818  frsp f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (ctx.f[1].f64 as f32) as f64;
	pc = 0x82391E88; continue 'dispatch;
            }
            0x82391E88 => {
    //   block [0x82391E88..0x82391EAC)
	// 82391E88: C01F00A4  lfs f0, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391E8C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82391E90: 419A001C  beq cr6, 0x82391eac
	if ctx.cr[6].eq {
	pc = 0x82391EAC; continue 'dispatch;
	}
	// 82391E94: FC200210  fabs f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82391E98: 481A1141  bl 0x82532fd8
	ctx.lr = 0x82391E9C;
	sub_82532FD8(ctx, base);
	// 82391E9C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82391EA0: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82391EA4: 481A15F5  bl 0x82533498
	ctx.lr = 0x82391EA8;
	sub_82533498(ctx, base);
	// 82391EA8: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	pc = 0x82391EAC; continue 'dispatch;
            }
            0x82391EAC => {
    //   block [0x82391EAC..0x82391EEC)
	// 82391EAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82391EB0: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82391EB4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82391EB8: 4800B9C1  bl 0x8239d878
	ctx.lr = 0x82391EBC;
	sub_8239D878(ctx, base);
	// 82391EBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82391EC0: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82391EC4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82391EC8: 4800B9B1  bl 0x8239d878
	ctx.lr = 0x82391ECC;
	sub_8239D878(ctx, base);
	// 82391ECC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82391ED0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82391ED4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82391ED8: CBA1FFD8  lfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82391EDC: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82391EE0: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82391EE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82391EE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82391EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82391EF0 size=288
    let mut pc: u32 = 0x82391EF0;
    'dispatch: loop {
        match pc {
            0x82391EF0 => {
    //   block [0x82391EF0..0x82391F48)
	// 82391EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82391EF4: 481A31A9  bl 0x8253509c
	ctx.lr = 0x82391EF8;
	sub_82535080(ctx, base);
	// 82391EF8: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 82391EFC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82391F00: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82391F04: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82391F08: 3AEB0334  addi r23, r11, 0x334
	ctx.r[23].s64 = ctx.r[11].s64 + 820;
	// 82391F0C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82391F10: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 82391F14: 3B2B032C  addi r25, r11, 0x32c
	ctx.r[25].s64 = ctx.r[11].s64 + 812;
	// 82391F18: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82391F1C: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82391F20: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82391F24: 3BCBBA8C  addi r30, r11, -0x4574
	ctx.r[30].s64 = ctx.r[11].s64 + -17780;
	// 82391F28: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 82391F2C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82391F30: 3BAB0C40  addi r29, r11, 0xc40
	ctx.r[29].s64 = ctx.r[11].s64 + 3136;
	// 82391F34: 3D608285  lis r11, -0x7d7b
	ctx.r[11].s64 = -2105212928;
	// 82391F38: 3F00830F  lis r24, -0x7cf1
	ctx.r[24].s64 = -2096168960;
	// 82391F3C: 3BEB4628  addi r31, r11, 0x4628
	ctx.r[31].s64 = ctx.r[11].s64 + 17960;
	// 82391F40: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 82391F44: 3ACB1358  addi r22, r11, 0x1358
	ctx.r[22].s64 = ctx.r[11].s64 + 4952;
	pc = 0x82391F48; continue 'dispatch;
            }
            0x82391F48 => {
    //   block [0x82391F48..0x82391F9C)
	// 82391F48: 7D7BB0AE  lbzx r11, r27, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82391F4C: 7F0BA840  cmplw cr6, r11, r21
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82391F50: 409A00A4  bne cr6, 0x82391ff4
	if !ctx.cr[6].eq {
	pc = 0x82391FF4; continue 'dispatch;
	}
	// 82391F54: 2B1A0004  cmplwi cr6, r26, 4
	ctx.cr[6].compare_u32(ctx.r[26].u32, 4 as u32, &mut ctx.xer);
	// 82391F58: 4098009C  bge cr6, 0x82391ff4
	if !ctx.cr[6].lt {
	pc = 0x82391FF4; continue 'dispatch;
	}
	// 82391F5C: 3B9E0010  addi r28, r30, 0x10
	ctx.r[28].s64 = ctx.r[30].s64 + 16;
	// 82391F60: 815D0688  lwz r10, 0x688(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1672 as u32) ) } as u64;
	// 82391F64: 7D7BE02E  lwzx r11, r27, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82391F68: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82391F6C: 419A0088  beq cr6, 0x82391ff4
	if ctx.cr[6].eq {
	pc = 0x82391FF4; continue 'dispatch;
	}
	// 82391F70: 3CA00000  lis r5, 0
	ctx.r[5].s64 = 0;
	// 82391F74: 8098FAC0  lwz r4, -0x540(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82391F78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82391F7C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82391F80: 60A58000  ori r5, r5, 0x8000
	ctx.r[5].u64 = ctx.r[5].u64 | 32768;
	// 82391F84: 386000A8  li r3, 0xa8
	ctx.r[3].s64 = 168;
	// 82391F88: 4BFD8509  bl 0x8236a490
	ctx.lr = 0x82391F8C;
	sub_8236A490(ctx, base);
	// 82391F8C: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82391F90: 4182000C  beq 0x82391f9c
	if ctx.cr[0].eq {
	pc = 0x82391F9C; continue 'dispatch;
	}
	// 82391F94: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82391F98: 48000008  b 0x82391fa0
	pc = 0x82391FA0; continue 'dispatch;
            }
            0x82391F9C => {
    //   block [0x82391F9C..0x82391FA0)
	// 82391F9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82391FA0; continue 'dispatch;
            }
            0x82391FA0 => {
    //   block [0x82391FA0..0x82391FF4)
	// 82391FA0: 815D0688  lwz r10, 0x688(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1672 as u32) ) } as u64;
	// 82391FA4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82391FA8: 391E0020  addi r8, r30, 0x20
	ctx.r[8].s64 = ctx.r[30].s64 + 32;
	// 82391FAC: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82391FB0: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82391FB4: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82391FB8: C17F0008  lfs f11, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82391FBC: C15F0004  lfs f10, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82391FC0: 7D5BE12E  stwx r10, r27, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32), ctx.r[10].u32) };
	// 82391FC4: C13F0000  lfs f9, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82391FC8: 7D3A41AE  stbx r9, r26, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u8) };
	// 82391FCC: D12B0080  stfs f9, 0x80(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82391FD0: 934B0098  stw r26, 0x98(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[26].u32 ) };
	// 82391FD4: D3EB009C  stfs f31, 0x9c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82391FD8: D12B00A0  stfs f9, 0xa0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82391FDC: D00B008C  stfs f0, 0x8c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82391FE0: D1AB0094  stfs f13, 0x94(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82391FE4: D18B0090  stfs f12, 0x90(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82391FE8: D16B0088  stfs f11, 0x88(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82391FEC: D14B0084  stfs f10, 0x84(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82391FF0: D00B00A4  stfs f0, 0xa4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), tmp.u32 ) };
	pc = 0x82391FF4; continue 'dispatch;
            }
            0x82391FF4 => {
    //   block [0x82391FF4..0x82392010)
	// 82391FF4: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82391FF8: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82391FFC: 2B1B0010  cmplwi cr6, r27, 0x10
	ctx.cr[6].compare_u32(ctx.r[27].u32, 16 as u32, &mut ctx.xer);
	// 82392000: 4198FF48  blt cr6, 0x82391f48
	if ctx.cr[6].lt {
	pc = 0x82391F48; continue 'dispatch;
	}
	// 82392004: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82392008: CBE1FF98  lfd f31, -0x68(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 8239200C: 481A30E0  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82392010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82392010 size=96
    let mut pc: u32 = 0x82392010;
    'dispatch: loop {
        match pc {
            0x82392010 => {
    //   block [0x82392010..0x82392040)
	// 82392010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82392014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82392018: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8239201C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82392020: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82392024: 396B2F88  addi r11, r11, 0x2f88
	ctx.r[11].s64 = ctx.r[11].s64 + 12168;
	// 82392028: 392B00D0  addi r9, r11, 0xd0
	ctx.r[9].s64 = ctx.r[11].s64 + 208;
	// 8239202C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82392030: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82392034: 7D4A2A15  add. r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82392038: 4081001C  ble 0x82392054
	if !ctx.cr[0].gt {
	pc = 0x82392054; continue 'dispatch;
	}
	// 8239203C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	pc = 0x82392040; continue 'dispatch;
            }
            0x82392040 => {
    //   block [0x82392040..0x82392054)
	// 82392040: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82392044: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82392048: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 8239204C: 7C844214  add r4, r4, r8
	ctx.r[4].u64 = ctx.r[4].u64 + ctx.r[8].u64;
	// 82392050: 4082FFF0  bne 0x82392040
	if !ctx.cr[0].eq {
	pc = 0x82392040; continue 'dispatch;
	}
	pc = 0x82392054; continue 'dispatch;
            }
            0x82392054 => {
    //   block [0x82392054..0x82392070)
	// 82392054: 386B013C  addi r3, r11, 0x13c
	ctx.r[3].s64 = ctx.r[11].s64 + 316;
	// 82392058: 480748D9  bl 0x82406930
	ctx.lr = 0x8239205C;
	sub_82406930(ctx, base);
	// 8239205C: 480733AD  bl 0x82405408
	ctx.lr = 0x82392060;
	sub_82405408(ctx, base);
	// 82392060: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82392064: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82392068: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8239206C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82392070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82392070 size=688
    let mut pc: u32 = 0x82392070;
    'dispatch: loop {
        match pc {
            0x82392070 => {
    //   block [0x82392070..0x82392130)
	// 82392070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82392074: 481A3049  bl 0x825350bc
	ctx.lr = 0x82392078;
	sub_82535080(ctx, base);
	// 82392078: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8239207C: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82392080: 3CC0830F  lis r6, -0x7cf1
	ctx.r[6].s64 = -2096168960;
	// 82392084: 3D6082A3  lis r11, -0x7d5d
	ctx.r[11].s64 = -2103246848;
	// 82392088: 3BE62F88  addi r31, r6, 0x2f88
	ctx.r[31].s64 = ctx.r[6].s64 + 12168;
	// 8239208C: 396B4DB8  addi r11, r11, 0x4db8
	ctx.r[11].s64 = ctx.r[11].s64 + 19896;
	// 82392090: 3D408285  lis r10, -0x7d7b
	ctx.r[10].s64 = -2105212928;
	// 82392094: 3D208285  lis r9, -0x7d7b
	ctx.r[9].s64 = -2105212928;
	// 82392098: 394A3F70  addi r10, r10, 0x3f70
	ctx.r[10].s64 = ctx.r[10].s64 + 16240;
	// 8239209C: 39293EF0  addi r9, r9, 0x3ef0
	ctx.r[9].s64 = ctx.r[9].s64 + 16112;
	// 823920A0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823920A4: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 823920A8: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 823920AC: 3D0082B5  lis r8, -0x7d4b
	ctx.r[8].s64 = -2102067200;
	// 823920B0: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 823920B4: 3CE08285  lis r7, -0x7d7b
	ctx.r[7].s64 = -2105212928;
	// 823920B8: 913F0138  stw r9, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[9].u32 ) };
	// 823920BC: 3908FDD8  addi r8, r8, -0x228
	ctx.r[8].s64 = ctx.r[8].s64 + -552;
	// 823920C0: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 823920C4: 396003E8  li r11, 0x3e8
	ctx.r[11].s64 = 1000;
	// 823920C8: 38E74100  addi r7, r7, 0x4100
	ctx.r[7].s64 = ctx.r[7].s64 + 16640;
	// 823920CC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823920D0: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 823920D4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 823920D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823920DC: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 823920E0: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 823920E4: 3960000E  li r11, 0xe
	ctx.r[11].s64 = 14;
	// 823920E8: 911F0034  stw r8, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[8].u32 ) };
	// 823920EC: 90FF0038  stw r7, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[7].u32 ) };
	// 823920F0: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 823920F4: 48073725  bl 0x82405818
	ctx.lr = 0x823920F8;
	sub_82405818(ctx, base);
	// 823920F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823920FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82392100: 48074581  bl 0x82406680
	ctx.lr = 0x82392104;
	sub_82406680(ctx, base);
	// 82392104: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82392108: 409A0210  bne cr6, 0x82392318
	if !ctx.cr[6].eq {
	pc = 0x82392318; continue 'dispatch;
	}
	// 8239210C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82392110: 409A0208  bne cr6, 0x82392318
	if !ctx.cr[6].eq {
	pc = 0x82392318; continue 'dispatch;
	}
	// 82392114: 3D401555  lis r10, 0x1555
	ctx.r[10].s64 = 357892096;
	// 82392118: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 8239211C: 614A5555  ori r10, r10, 0x5555
	ctx.r[10].u64 = ctx.r[10].u64 | 21845;
	// 82392120: 1C6B000C  mulli r3, r11, 0xc
	ctx.r[3].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82392124: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82392128: 40990008  ble cr6, 0x82392130
	if !ctx.cr[6].gt {
	pc = 0x82392130; continue 'dispatch;
	}
	// 8239212C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82392130; continue 'dispatch;
            }
            0x82392130 => {
    //   block [0x82392130..0x8239214C)
	// 82392130: 48072E29  bl 0x82404f58
	ctx.lr = 0x82392134;
	sub_82404F58(ctx, base);
	// 82392134: 907F0100  stw r3, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[3].u32 ) };
	// 82392138: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 8239213C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82392140: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82392144: 40990020  ble cr6, 0x82392164
	if !ctx.cr[6].gt {
	pc = 0x82392164; continue 'dispatch;
	}
	// 82392148: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	pc = 0x8239214C; continue 'dispatch;
            }
            0x8239214C => {
    //   block [0x8239214C..0x82392164)
	// 8239214C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82392150: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82392154: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82392158: 5529502A  slwi r9, r9, 0xa
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(10);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8239215C: 7FA9EA14  add r29, r9, r29
	ctx.r[29].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 82392160: 4082FFEC  bne 0x8239214c
	if !ctx.cr[0].eq {
	pc = 0x8239214C; continue 'dispatch;
	}
	pc = 0x82392164; continue 'dispatch;
            }
            0x82392164 => {
    //   block [0x82392164..0x823921C0)
	// 82392164: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 82392168: 3BCB2200  addi r30, r11, 0x2200
	ctx.r[30].s64 = ctx.r[11].s64 + 8704;
	// 8239216C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82392170: 4837B0ED  bl 0x8270d25c
	ctx.lr = 0x82392174;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82392174: 38A00800  li r5, 0x800
	ctx.r[5].s64 = 2048;
	// 82392178: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8239217C: 387E0024  addi r3, r30, 0x24
	ctx.r[3].s64 = ctx.r[30].s64 + 36;
	// 82392180: 48018BA1  bl 0x823aad20
	ctx.lr = 0x82392184;
	sub_823AAD20(ctx, base);
	// 82392184: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82392188: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 8239218C: 4837B0E1  bl 0x8270d26c
	ctx.lr = 0x82392190;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82392190: 813F0100  lwz r9, 0x100(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82392194: 80BF003C  lwz r5, 0x3c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82392198: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8239219C: 419A0064  beq cr6, 0x82392200
	if ctx.cr[6].eq {
	pc = 0x82392200; continue 'dispatch;
	}
	// 823921A0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823921A4: 419A005C  beq cr6, 0x82392200
	if ctx.cr[6].eq {
	pc = 0x82392200; continue 'dispatch;
	}
	// 823921A8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 823921AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823921B0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823921B4: 4099004C  ble cr6, 0x82392200
	if !ctx.cr[6].gt {
	pc = 0x82392200; continue 'dispatch;
	}
	// 823921B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823921BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x823921C0; continue 'dispatch;
            }
            0x823921C0 => {
    //   block [0x823921C0..0x82392200)
	// 823921C0: 80DF0038  lwz r6, 0x38(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 823921C4: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 823921C8: 7CC8302E  lwzx r6, r8, r6
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 823921CC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823921D0: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823921D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823921D8: 54C6502A  slwi r6, r6, 0xa
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(10);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 823921DC: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 823921E0: 7F0A2800  cmpw cr6, r10, r5
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[5].s32, &mut ctx.xer);
	// 823921E4: 90C90004  stw r6, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 823921E8: 813F0100  lwz r9, 0x100(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 823921EC: 7CCB4A14  add r6, r11, r9
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 823921F0: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 823921F4: 80C60004  lwz r6, 4(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 823921F8: 7CE63A14  add r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 823921FC: 4198FFC4  blt cr6, 0x823921c0
	if ctx.cr[6].lt {
	pc = 0x823921C0; continue 'dispatch;
	}
	pc = 0x82392200; continue 'dispatch;
            }
            0x82392200 => {
    //   block [0x82392200..0x82392204)
	// 82392200: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82392204; continue 'dispatch;
            }
            0x82392204 => {
    //   block [0x82392204..0x82392228)
	// 82392204: 813F0138  lwz r9, 0x138(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82392208: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8239220C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82392210: 390A0010  addi r8, r10, 0x10
	ctx.r[8].s64 = ctx.r[10].s64 + 16;
	// 82392214: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82392218: B109000E  sth r8, 0xe(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(14 as u32), ctx.r[8].u16 ) };
	// 8239221C: 409A000C  bne cr6, 0x82392228
	if !ctx.cr[6].eq {
	pc = 0x82392228; continue 'dispatch;
	}
	// 82392220: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82392224: 48000020  b 0x82392244
	pc = 0x82392244; continue 'dispatch;
            }
            0x82392228 => {
    //   block [0x82392228..0x82392244)
	// 82392228: 813F0138  lwz r9, 0x138(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 8239222C: 38FF003C  addi r7, r31, 0x3c
	ctx.r[7].s64 = ctx.r[31].s64 + 60;
	// 82392230: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82392234: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82392238: 7D08382E  lwzx r8, r8, r7
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 8239223C: 8129FFF0  lwz r9, -0x10(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82392240: 7CE94214  add r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	pc = 0x82392244; continue 'dispatch;
            }
            0x82392244 => {
    //   block [0x82392244..0x82392260)
	// 82392244: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82392248: 391F0040  addi r8, r31, 0x40
	ctx.r[8].s64 = ctx.r[31].s64 + 64;
	// 8239224C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82392250: 7CE9412E  stwx r7, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[7].u32) };
	// 82392254: 409A000C  bne cr6, 0x82392260
	if !ctx.cr[6].eq {
	pc = 0x82392260; continue 'dispatch;
	}
	// 82392258: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8239225C: 48000020  b 0x8239227c
	pc = 0x8239227C; continue 'dispatch;
            }
            0x82392260 => {
    //   block [0x82392260..0x8239227C)
	// 82392260: 813F0138  lwz r9, 0x138(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82392264: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82392268: 38DF006C  addi r6, r31, 0x6c
	ctx.r[6].s64 = ctx.r[31].s64 + 108;
	// 8239226C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82392270: 7D08302E  lwzx r8, r8, r6
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82392274: 8129FFF4  lwz r9, -0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82392278: 7D094214  add r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	pc = 0x8239227C; continue 'dispatch;
            }
            0x8239227C => {
    //   block [0x8239227C..0x82392298)
	// 8239227C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82392280: 38DF0070  addi r6, r31, 0x70
	ctx.r[6].s64 = ctx.r[31].s64 + 112;
	// 82392284: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82392288: 7D09312E  stwx r8, r9, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[6].u32), ctx.r[8].u32) };
	// 8239228C: 409A000C  bne cr6, 0x82392298
	if !ctx.cr[6].eq {
	pc = 0x82392298; continue 'dispatch;
	}
	// 82392290: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82392294: 48000020  b 0x823922b4
	pc = 0x823922B4; continue 'dispatch;
            }
            0x82392298 => {
    //   block [0x82392298..0x823922B4)
	// 82392298: 813F0138  lwz r9, 0x138(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 8239229C: 38DF009C  addi r6, r31, 0x9c
	ctx.r[6].s64 = ctx.r[31].s64 + 156;
	// 823922A0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823922A4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823922A8: 814AFFF8  lwz r10, -8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823922AC: 7D29302E  lwzx r9, r9, r6
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 823922B0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	pc = 0x823922B4; continue 'dispatch;
            }
            0x823922B4 => {
    //   block [0x823922B4..0x823922F4)
	// 823922B4: 7D2A4214  add r9, r10, r8
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 823922B8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 823922BC: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 823922C0: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823922C4: 391F00A0  addi r8, r31, 0xa0
	ctx.r[8].s64 = ctx.r[31].s64 + 160;
	// 823922C8: 38FF00D0  addi r7, r31, 0xd0
	ctx.r[7].s64 = ctx.r[31].s64 + 208;
	// 823922CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823922D0: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 823922D4: 7D46412E  stwx r10, r6, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 823922D8: 7D25392E  stwx r9, r5, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32), ctx.r[9].u32) };
	// 823922DC: 4198FF28  blt cr6, 0x82392204
	if ctx.cr[6].lt {
	pc = 0x82392204; continue 'dispatch;
	}
	// 823922E0: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823922E4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823922E8: 396BBB70  addi r11, r11, -0x4490
	ctx.r[11].s64 = ctx.r[11].s64 + -17552;
	// 823922EC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 823922F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x823922F4; continue 'dispatch;
            }
            0x823922F4 => {
    //   block [0x823922F4..0x82392318)
	// 823922F4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823922F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823922FC: 4200FFF8  bdnz 0x823922f4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823922F4; continue 'dispatch;
	}
	// 82392300: 3D601234  lis r11, 0x1234
	ctx.r[11].s64 = 305397760;
	// 82392304: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82392308: 616BFEDC  ori r11, r11, 0xfedc
	ctx.r[11].u64 = ctx.r[11].u64 | 65244;
	// 8239230C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82392310: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82392314: 481A2DF8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82392318 => {
    //   block [0x82392318..0x82392320)
	// 82392318: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8239231C: 481A3755  bl 0x82535a70
	ctx.lr = 0x82392320;
	sub_82535A70(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82392320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82392320 size=68
    let mut pc: u32 = 0x82392320;
    'dispatch: loop {
        match pc {
            0x82392320 => {
    //   block [0x82392320..0x82392364)
	// 82392320: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82392324: 4198008C  blt cr6, 0x823923b0
	if ctx.cr[6].lt {
		sub_823923B0(ctx, base);
		return;
	}
	// 82392328: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8239232C: 390B2F88  addi r8, r11, 0x2f88
	ctx.r[8].s64 = ctx.r[11].s64 + 12168;
	// 82392330: 81680014  lwz r11, 0x14(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82392334: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82392338: 40980078  bge cr6, 0x823923b0
	if !ctx.cr[6].lt {
		sub_823923B0(ctx, base);
		return;
	}
	// 8239233C: 81280138  lwz r9, 0x138(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(312 as u32) ) } as u64;
	// 82392340: 548A2036  slwi r10, r4, 4
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82392344: 7D6A482E  lwzx r11, r10, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82392348: 7D6B2851  subf. r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8239234C: 40800018  bge 0x82392364
	if !ctx.cr[0].lt {
		sub_82392364(ctx, base);
		return;
	}
	// 82392350: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82392354: 39480040  addi r10, r8, 0x40
	ctx.r[10].s64 = ctx.r[8].s64 + 64;
	// 82392358: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8239235C: 7C6B2A14  add r3, r11, r5
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82392360: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82392364(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82392364 size=40
    let mut pc: u32 = 0x82392364;
    'dispatch: loop {
        match pc {
            0x82392364 => {
    //   block [0x82392364..0x8239238C)
	// 82392364: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82392368: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 8239236C: 80C60004  lwz r6, 4(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82392370: 7D665851  subf. r11, r6, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82392374: 40800018  bge 0x8239238c
	if !ctx.cr[0].lt {
		sub_8239238C(ctx, base);
		return;
	}
	// 82392378: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8239237C: 39480070  addi r10, r8, 0x70
	ctx.r[10].s64 = ctx.r[8].s64 + 112;
	// 82392380: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82392384: 7C6B3A14  add r3, r11, r7
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82392388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8239238C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8239238C size=36
    let mut pc: u32 = 0x8239238C;
    'dispatch: loop {
        match pc {
            0x8239238C => {
    //   block [0x8239238C..0x823923B0)
	// 8239238C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82392390: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82392394: 7D4A5851  subf. r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82392398: 40800018  bge 0x823923b0
	if !ctx.cr[0].lt {
		sub_823923B0(ctx, base);
		return;
	}
	// 8239239C: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823923A0: 392800A0  addi r9, r8, 0xa0
	ctx.r[9].s64 = ctx.r[8].s64 + 160;
	// 823923A4: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 823923A8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823923AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823923B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823923B0 size=8
    let mut pc: u32 = 0x823923B0;
    'dispatch: loop {
        match pc {
            0x823923B0 => {
    //   block [0x823923B0..0x823923B8)
	// 823923B0: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 823923B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823923B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823923B8 size=64
    let mut pc: u32 = 0x823923B8;
    'dispatch: loop {
        match pc {
            0x823923B8 => {
    //   block [0x823923B8..0x823923F8)
	// 823923B8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823923BC: 41980080  blt cr6, 0x8239243c
	if ctx.cr[6].lt {
		sub_8239243C(ctx, base);
		return;
	}
	// 823923C0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 823923C4: 394B2F88  addi r10, r11, 0x2f88
	ctx.r[10].s64 = ctx.r[11].s64 + 12168;
	// 823923C8: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 823923CC: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823923D0: 4098006C  bge cr6, 0x8239243c
	if !ctx.cr[6].lt {
		sub_8239243C(ctx, base);
		return;
	}
	// 823923D4: 814A0138  lwz r10, 0x138(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(312 as u32) ) } as u64;
	// 823923D8: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823923DC: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823923E0: 7D292851  subf. r9, r9, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823923E4: 40800014  bge 0x823923f8
	if !ctx.cr[0].lt {
		sub_823923F8(ctx, base);
		return;
	}
	// 823923E8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823923EC: A96B000E  lha r11, 0xe(r11)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(14 as u32) ) } as i16) as i64;
	// 823923F0: 7C6B2A14  add r3, r11, r5
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 823923F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823923F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823923F8 size=32
    let mut pc: u32 = 0x823923F8;
    'dispatch: loop {
        match pc {
            0x823923F8 => {
    //   block [0x823923F8..0x82392418)
	// 823923F8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823923FC: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82392400: 7D274851  subf. r9, r7, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82392404: 40800014  bge 0x82392418
	if !ctx.cr[0].lt {
		sub_82392418(ctx, base);
		return;
	}
	// 82392408: A968000E  lha r11, 0xe(r8)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(14 as u32) ) } as i16) as i64;
	// 8239240C: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82392410: 386B4000  addi r3, r11, 0x4000
	ctx.r[3].s64 = ctx.r[11].s64 + 16384;
	// 82392414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82392418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82392418 size=36
    let mut pc: u32 = 0x82392418;
    'dispatch: loop {
        match pc {
            0x82392418 => {
    //   block [0x82392418..0x8239243C)
	// 82392418: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8239241C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82392420: 7D6B4851  subf. r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82392424: 40800018  bge 0x8239243c
	if !ctx.cr[0].lt {
		sub_8239243C(ctx, base);
		return;
	}
	// 82392428: A968000E  lha r11, 0xe(r8)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(14 as u32) ) } as i16) as i64;
	// 8239242C: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82392430: 3C6B0001  addis r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 65536;
	// 82392434: 38638000  addi r3, r3, -0x8000
	ctx.r[3].s64 = ctx.r[3].s64 + -32768;
	// 82392438: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8239243C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8239243C size=8
    let mut pc: u32 = 0x8239243C;
    'dispatch: loop {
        match pc {
            0x8239243C => {
    //   block [0x8239243C..0x82392444)
	// 8239243C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82392440: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82392448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82392448 size=276
    let mut pc: u32 = 0x82392448;
    'dispatch: loop {
        match pc {
            0x82392448 => {
    //   block [0x82392448..0x823924C8)
	// 82392448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8239244C: 481A2C61  bl 0x825350ac
	ctx.lr = 0x82392450;
	sub_82535080(ctx, base);
	// 82392450: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82392454: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82392458: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 8239245C: 3BEB2F88  addi r31, r11, 0x2f88
	ctx.r[31].s64 = ctx.r[11].s64 + 12168;
	// 82392460: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82392464: 395F00D0  addi r10, r31, 0xd0
	ctx.r[10].s64 = ctx.r[31].s64 + 208;
	// 82392468: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8239246C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82392470: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82392474: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 82392478: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8239247C: 7FAB2A14  add r29, r11, r5
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82392480: 4BFFFEA1  bl 0x82392320
	ctx.lr = 0x82392484;
	sub_82392320(ctx, base);
	// 82392484: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82392488: 418000C8  blt 0x82392550
	if ctx.cr[0].lt {
	pc = 0x82392550; continue 'dispatch;
	}
	// 8239248C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82392490: 4BFFFF29  bl 0x823923b8
	ctx.lr = 0x82392494;
	sub_823923B8(ctx, base);
	// 82392494: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82392498: 418000B8  blt 0x82392550
	if ctx.cr[0].lt {
	pc = 0x82392550; continue 'dispatch;
	}
	// 8239249C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823924A0: 419800B0  blt cr6, 0x82392550
	if ctx.cr[6].lt {
	pc = 0x82392550; continue 'dispatch;
	}
	// 823924A4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823924A8: 419A0020  beq cr6, 0x823924c8
	if ctx.cr[6].eq {
	pc = 0x823924C8; continue 'dispatch;
	}
	// 823924AC: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 823924B0: 419800A0  blt cr6, 0x82392550
	if ctx.cr[6].lt {
	pc = 0x82392550; continue 'dispatch;
	}
	// 823924B4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823924B8: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823924BC: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823924C0: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823924C4: 4199008C  bgt cr6, 0x82392550
	if ctx.cr[6].gt {
	pc = 0x82392550; continue 'dispatch;
	}
	pc = 0x823924C8; continue 'dispatch;
            }
            0x823924C8 => {
    //   block [0x823924C8..0x823924E4)
	// 823924C8: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 823924CC: 57BC103A  slwi r28, r29, 2
	ctx.r[28].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 823924D0: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823924D4: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 823924D8: 419A000C  beq cr6, 0x823924e4
	if ctx.cr[6].eq {
	pc = 0x823924E4; continue 'dispatch;
	}
	// 823924DC: 48073635  bl 0x82405b10
	ctx.lr = 0x823924E0;
	sub_82405B10(ctx, base);
	// 823924E0: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	pc = 0x823924E4; continue 'dispatch;
            }
            0x823924E4 => {
    //   block [0x823924E4..0x823924FC)
	// 823924E4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 823924E8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823924EC: 7D5C592E  stwx r10, r28, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 823924F0: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823924F4: 4099001C  ble cr6, 0x82392510
	if !ctx.cr[6].gt {
	pc = 0x82392510; continue 'dispatch;
	}
	// 823924F8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	pc = 0x823924FC; continue 'dispatch;
            }
            0x823924FC => {
    //   block [0x823924FC..0x82392510)
	// 823924FC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82392500: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82392504: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82392508: 7FCAF214  add r30, r10, r30
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 8239250C: 4082FFF0  bne 0x823924fc
	if !ctx.cr[0].eq {
	pc = 0x823924FC; continue 'dispatch;
	}
	pc = 0x82392510; continue 'dispatch;
            }
            0x82392510 => {
    //   block [0x82392510..0x82392550)
	// 82392510: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82392514: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82392518: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8239251C: 481A2635  bl 0x82534b50
	ctx.lr = 0x82392520;
	sub_82534B50(ctx, base);
	// 82392520: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82392524: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82392528: 7CBC5A14  add r5, r28, r11
	ctx.r[5].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 8239252C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82392530: 48072E99  bl 0x824053c8
	ctx.lr = 0x82392534;
	sub_824053C8(ctx, base);
	// 82392534: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82392538: 40820018  bne 0x82392550
	if !ctx.cr[0].eq {
	pc = 0x82392550; continue 'dispatch;
	}
	// 8239253C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82392540: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82392544: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82392548: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8239254C: 48000008  b 0x82392554
	pc = 0x82392554; continue 'dispatch;
            }
            0x82392550 => {
    //   block [0x82392550..0x82392554)
	// 82392550: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82392554; continue 'dispatch;
            }
            0x82392554 => {
    //   block [0x82392554..0x8239255C)
	// 82392554: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82392558: 481A2BA4  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82392560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82392560 size=208
    let mut pc: u32 = 0x82392560;
    'dispatch: loop {
        match pc {
            0x82392560 => {
    //   block [0x82392560..0x823925B4)
	// 82392560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82392564: 481A2B59  bl 0x825350bc
	ctx.lr = 0x82392568;
	sub_82535080(ctx, base);
	// 82392568: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8239256C: 3FA0830F  lis r29, -0x7cf1
	ctx.r[29].s64 = -2096168960;
	// 82392570: 83FDFAC0  lwz r31, -0x540(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82392574: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82392578: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8239257C: 408200A4  bne 0x82392620
	if !ctx.cr[0].eq {
	pc = 0x82392620; continue 'dispatch;
	}
	// 82392580: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82392584: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82392588: 2F0B0258  cmpwi cr6, r11, 0x258
	ctx.cr[6].compare_i32(ctx.r[11].s32, 600, &mut ctx.xer);
	// 8239258C: 915F00D0  stw r10, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 82392590: 41990070  bgt cr6, 0x82392600
	if ctx.cr[6].gt {
	pc = 0x82392600; continue 'dispatch;
	}
	// 82392594: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82392598: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8239259C: 419A0064  beq cr6, 0x82392600
	if ctx.cr[6].eq {
	pc = 0x82392600; continue 'dispatch;
	}
	// 823925A0: 83DF00A8  lwz r30, 0xa8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 823925A4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823925A8: 4082000C  bne 0x823925b4
	if !ctx.cr[0].eq {
	pc = 0x823925B4; continue 'dispatch;
	}
	// 823925AC: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823925B0: 3BCBBB68  addi r30, r11, -0x4498
	ctx.r[30].s64 = ctx.r[11].s64 + -17560;
	pc = 0x823925B4; continue 'dispatch;
            }
            0x823925B4 => {
    //   block [0x823925B4..0x82392600)
	// 823925B4: C03F0094  lfs f1, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823925B8: 481A0BA1  bl 0x82533158
	ctx.lr = 0x823925BC;
	sub_82533158(ctx, base);
	// 823925BC: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 823925C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823925C4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823925C8: C05F0098  lfs f2, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823925CC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 823925D0: 809F0088  lwz r4, 0x88(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 823925D4: C03F0090  lfs f1, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823925D8: 807F00B0  lwz r3, 0xb0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 823925DC: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823925E0: C00B2220  lfs f0, 0x2220(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8736 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823925E4: A8BF009C  lha r5, 0x9c(r31)
	ctx.r[5].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as i16) as i64;
	// 823925E8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823925EC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823925F0: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823925F4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823925F8: 7D680734  extsh r8, r11
	ctx.r[8].s64 = ctx.r[11].s16 as i64;
	// 823925FC: 4807367D  bl 0x82405c78
	ctx.lr = 0x82392600;
	sub_82405C78(ctx, base);
	pc = 0x82392600; continue 'dispatch;
            }
            0x82392600 => {
    //   block [0x82392600..0x82392620)
	// 82392600: 817DFAC0  lwz r11, -0x540(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82392604: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82392608: 409A0020  bne cr6, 0x82392628
	if !ctx.cr[6].eq {
	pc = 0x82392628; continue 'dispatch;
	}
	// 8239260C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82392610: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82392614: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82392618: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 8239261C: 4800000C  b 0x82392628
	pc = 0x82392628; continue 'dispatch;
            }
            0x82392620 => {
    //   block [0x82392620..0x82392628)
	// 82392620: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82392624: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	pc = 0x82392628; continue 'dispatch;
            }
            0x82392628 => {
    //   block [0x82392628..0x82392630)
	// 82392628: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8239262C: 481A2AE0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82392630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82392630 size=36
    let mut pc: u32 = 0x82392630;
    'dispatch: loop {
        match pc {
            0x82392630 => {
    //   block [0x82392630..0x82392654)
	// 82392630: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82392634: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82392638: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8239263C: 814B00B4  lwz r10, 0xb4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) } as u64;
	// 82392640: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82392644: 396BBB70  addi r11, r11, -0x4490
	ctx.r[11].s64 = ctx.r[11].s64 + -17552;
	// 82392648: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8239264C: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 82392650: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82392658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82392658 size=548
    let mut pc: u32 = 0x82392658;
    'dispatch: loop {
        match pc {
            0x82392658 => {
    //   block [0x82392658..0x823926D0)
	// 82392658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8239265C: 481A2A49  bl 0x825350a4
	ctx.lr = 0x82392660;
	sub_82535080(ctx, base);
	// 82392660: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82392664: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82392668: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 8239266C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82392670: 419A0200  beq cr6, 0x82392870
	if ctx.cr[6].eq {
	pc = 0x82392870; continue 'dispatch;
	}
	// 82392674: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82392678: 3BCB2F88  addi r30, r11, 0x2f88
	ctx.r[30].s64 = ctx.r[11].s64 + 12168;
	// 8239267C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82392680: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82392684: 409A01EC  bne cr6, 0x82392870
	if !ctx.cr[6].eq {
	pc = 0x82392870; continue 'dispatch;
	}
	// 82392688: 835F0004  lwz r26, 4(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8239268C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82392690: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82392694: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82392698: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8239269C: 4BFFFC85  bl 0x82392320
	ctx.lr = 0x823926A0;
	sub_82392320(ctx, base);
	// 823926A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823926A4: 418001CC  blt 0x82392870
	if ctx.cr[0].lt {
	pc = 0x82392870; continue 'dispatch;
	}
	// 823926A8: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 823926AC: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823926B0: 409801C0  bge cr6, 0x82392870
	if !ctx.cr[6].lt {
	pc = 0x82392870; continue 'dispatch;
	}
	// 823926B4: 5499103A  slwi r25, r4, 2
	ctx.r[25].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 823926B8: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823926BC: 3B1E00D0  addi r24, r30, 0xd0
	ctx.r[24].s64 = ctx.r[30].s64 + 208;
	// 823926C0: 7D79C02E  lwzx r11, r25, r24
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 823926C4: 7D7A5A15  add. r11, r26, r11
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823926C8: 4081001C  ble 0x823926e4
	if !ctx.cr[0].gt {
	pc = 0x823926E4; continue 'dispatch;
	}
	// 823926CC: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	pc = 0x823926D0; continue 'dispatch;
            }
            0x823926D0 => {
    //   block [0x823926D0..0x823926E4)
	// 823926D0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823926D4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823926D8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823926DC: 7C892214  add r4, r9, r4
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 823926E0: 4082FFF0  bne 0x823926d0
	if !ctx.cr[0].eq {
	pc = 0x823926D0; continue 'dispatch;
	}
	pc = 0x823926E4; continue 'dispatch;
            }
            0x823926E4 => {
    //   block [0x823926E4..0x8239271C)
	// 823926E4: 387E013C  addi r3, r30, 0x13c
	ctx.r[3].s64 = ctx.r[30].s64 + 316;
	// 823926E8: 48074249  bl 0x82406930
	ctx.lr = 0x823926EC;
	sub_82406930(ctx, base);
	// 823926EC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823926F0: 41980180  blt cr6, 0x82392870
	if ctx.cr[6].lt {
	pc = 0x82392870; continue 'dispatch;
	}
	// 823926F4: 48072D15  bl 0x82405408
	ctx.lr = 0x823926F8;
	sub_82405408(ctx, base);
	// 823926F8: 7F1D1800  cmpw cr6, r29, r3
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[3].s32, &mut ctx.xer);
	// 823926FC: 40980174  bge cr6, 0x82392870
	if !ctx.cr[6].lt {
	pc = 0x82392870; continue 'dispatch;
	}
	// 82392700: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82392704: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82392708: 3B8BBB70  addi r28, r11, -0x4490
	ctx.r[28].s64 = ctx.r[11].s64 + -17552;
	// 8239270C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82392710: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82392714: 812BFAC0  lwz r9, -0x540(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82392718: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8239271C; continue 'dispatch;
            }
            0x8239271C => {
    //   block [0x8239271C..0x82392740)
	// 8239271C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82392720: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82392724: 419A008C  beq cr6, 0x823927b0
	if ctx.cr[6].eq {
	pc = 0x823927B0; continue 'dispatch;
	}
	// 82392728: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8239272C: 391C0040  addi r8, r28, 0x40
	ctx.r[8].s64 = ctx.r[28].s64 + 64;
	// 82392730: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82392734: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82392738: 4198FFE4  blt cr6, 0x8239271c
	if ctx.cr[6].lt {
	pc = 0x8239271C; continue 'dispatch;
	}
	// 8239273C: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	pc = 0x82392740; continue 'dispatch;
            }
            0x82392740 => {
    //   block [0x82392740..0x823927B0)
	// 82392740: 2F1BFFFF  cmpwi cr6, r27, -1
	ctx.cr[6].compare_i32(ctx.r[27].s32, -1, &mut ctx.xer);
	// 82392744: 40990124  ble cr6, 0x82392868
	if !ctx.cr[6].gt {
	pc = 0x82392868; continue 'dispatch;
	}
	// 82392748: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8239274C: 80890010  lwz r4, 0x10(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82392750: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82392754: 38EB0354  addi r7, r11, 0x354
	ctx.r[7].s64 = ctx.r[11].s64 + 852;
	// 82392758: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 8239275C: 386000D8  li r3, 0xd8
	ctx.r[3].s64 = 216;
	// 82392760: 4BFD7D31  bl 0x8236a490
	ctx.lr = 0x82392764;
	sub_8236A490(ctx, base);
	// 82392764: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82392768: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8239276C: 4182004C  beq 0x823927b8
	if ctx.cr[0].eq {
	pc = 0x823927B8; continue 'dispatch;
	}
	// 82392770: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82392774: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82392778: 394A0370  addi r10, r10, 0x370
	ctx.r[10].s64 = ctx.r[10].s64 + 880;
	// 8239277C: C008BA38  lfs f0, -0x45c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392780: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82392784: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82392788: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8239278C: D00B0090  stfs f0, 0x90(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82392790: 93AB008C  stw r29, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	// 82392794: D00B0094  stfs f0, 0x94(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82392798: 93AB00A0  stw r29, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 8239279C: C1A81FF8  lfs f13, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823927A0: D1AB0098  stfs f13, 0x98(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 823927A4: B14B009C  sth r10, 0x9c(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[10].u16 ) };
	// 823927A8: 992B001C  stb r9, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u8 ) };
	// 823927AC: 48000010  b 0x823927bc
	pc = 0x823927BC; continue 'dispatch;
            }
            0x823927B0 => {
    //   block [0x823927B0..0x823927B8)
	// 823927B0: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 823927B4: 4BFFFF8C  b 0x82392740
	pc = 0x82392740; continue 'dispatch;
            }
            0x823927B8 => {
    //   block [0x823927B8..0x823927BC)
	// 823927B8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x823927BC; continue 'dispatch;
            }
            0x823927BC => {
    //   block [0x823927BC..0x82392868)
	// 823927BC: 576A103A  slwi r10, r27, 2
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823927C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823927C4: 7D6AE12E  stwx r11, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[11].u32) };
	// 823927C8: 419A00A0  beq cr6, 0x82392868
	if ctx.cr[6].eq {
	pc = 0x82392868; continue 'dispatch;
	}
	// 823927CC: 93AB00D0  stw r29, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 823927D0: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 823927D4: 7D4AE02E  lwzx r10, r10, r28
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 823927D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823927DC: 910A00D4  stw r8, 0xd4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(212 as u32), ctx.r[8].u32 ) };
	// 823927E0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823927E4: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 823927E8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823927EC: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 823927F0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823927F4: 914B0088  stw r10, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 823927F8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823927FC: 914B008C  stw r10, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 82392800: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392804: D00B0090  stfs f0, 0x90(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82392808: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8239280C: D00B0098  stfs f0, 0x98(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82392810: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392814: D00B0094  stfs f0, 0x94(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82392818: A15F001C  lhz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8239281C: B14B009C  sth r10, 0x9c(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[10].u16 ) };
	// 82392820: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82392824: 92EB00A8  stw r23, 0xa8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), ctx.r[23].u32 ) };
	// 82392828: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 8239282C: 7D59C02E  lwzx r10, r25, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 82392830: 7D5A5214  add r10, r26, r10
	ctx.r[10].u64 = ctx.r[26].u64 + ctx.r[10].u64;
	// 82392834: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82392838: 815E0034  lwz r10, 0x34(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 8239283C: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82392840: 936B00B4  stw r27, 0xb4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), ctx.r[27].u32 ) };
	// 82392844: 912B00B8  stw r9, 0xb8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), ctx.r[9].u32 ) };
	// 82392848: 914B00B0  stw r10, 0xb0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 8239284C: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82392850: 914B00C0  stw r10, 0xc0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(192 as u32), ctx.r[10].u32 ) };
	// 82392854: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82392858: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8239285C: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82392860: 93CB00A4  stw r30, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 82392864: 48000010  b 0x82392874
	pc = 0x82392874; continue 'dispatch;
            }
            0x82392868 => {
    //   block [0x82392868..0x82392870)
	// 82392868: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8239286C: 48000008  b 0x82392874
	pc = 0x82392874; continue 'dispatch;
            }
            0x82392870 => {
    //   block [0x82392870..0x82392874)
	// 82392870: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82392874; continue 'dispatch;
            }
            0x82392874 => {
    //   block [0x82392874..0x8239287C)
	// 82392874: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82392878: 481A287C  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82392880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82392880 size=508
    let mut pc: u32 = 0x82392880;
    'dispatch: loop {
        match pc {
            0x82392880 => {
    //   block [0x82392880..0x823928D8)
	// 82392880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82392884: 481A2821  bl 0x825350a4
	ctx.lr = 0x82392888;
	sub_82535080(ctx, base);
	// 82392888: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8239288C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82392890: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82392894: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82392898: 419A01D8  beq cr6, 0x82392a70
	if ctx.cr[6].eq {
	pc = 0x82392A70; continue 'dispatch;
	}
	// 8239289C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 823928A0: 3BCB2F88  addi r30, r11, 0x2f88
	ctx.r[30].s64 = ctx.r[11].s64 + 12168;
	// 823928A4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823928A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823928AC: 409A01C4  bne cr6, 0x82392a70
	if !ctx.cr[6].eq {
	pc = 0x82392A70; continue 'dispatch;
	}
	// 823928B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823928B4: 3B1E00D0  addi r24, r30, 0xd0
	ctx.r[24].s64 = ctx.r[30].s64 + 208;
	// 823928B8: 835F0004  lwz r26, 4(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823928BC: 5579103A  slwi r25, r11, 2
	ctx.r[25].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 823928C0: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823928C4: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823928C8: 7D79C02E  lwzx r11, r25, r24
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 823928CC: 7D6BD215  add. r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823928D0: 4081001C  ble 0x823928ec
	if !ctx.cr[0].gt {
	pc = 0x823928EC; continue 'dispatch;
	}
	// 823928D4: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	pc = 0x823928D8; continue 'dispatch;
            }
            0x823928D8 => {
    //   block [0x823928D8..0x823928EC)
	// 823928D8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823928DC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823928E0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823928E4: 7C892214  add r4, r9, r4
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 823928E8: 4082FFF0  bne 0x823928d8
	if !ctx.cr[0].eq {
	pc = 0x823928D8; continue 'dispatch;
	}
	pc = 0x823928EC; continue 'dispatch;
            }
            0x823928EC => {
    //   block [0x823928EC..0x82392924)
	// 823928EC: 387E013C  addi r3, r30, 0x13c
	ctx.r[3].s64 = ctx.r[30].s64 + 316;
	// 823928F0: 48074041  bl 0x82406930
	ctx.lr = 0x823928F4;
	sub_82406930(ctx, base);
	// 823928F4: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823928F8: 41980178  blt cr6, 0x82392a70
	if ctx.cr[6].lt {
	pc = 0x82392A70; continue 'dispatch;
	}
	// 823928FC: 48072B0D  bl 0x82405408
	ctx.lr = 0x82392900;
	sub_82405408(ctx, base);
	// 82392900: 7F1D1800  cmpw cr6, r29, r3
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82392904: 4098016C  bge cr6, 0x82392a70
	if !ctx.cr[6].lt {
	pc = 0x82392A70; continue 'dispatch;
	}
	// 82392908: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 8239290C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82392910: 3B8BBB70  addi r28, r11, -0x4490
	ctx.r[28].s64 = ctx.r[11].s64 + -17552;
	// 82392914: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82392918: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 8239291C: 812BFAC0  lwz r9, -0x540(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82392920: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82392924; continue 'dispatch;
            }
            0x82392924 => {
    //   block [0x82392924..0x82392948)
	// 82392924: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82392928: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8239292C: 419A008C  beq cr6, 0x823929b8
	if ctx.cr[6].eq {
	pc = 0x823929B8; continue 'dispatch;
	}
	// 82392930: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82392934: 391C0040  addi r8, r28, 0x40
	ctx.r[8].s64 = ctx.r[28].s64 + 64;
	// 82392938: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8239293C: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82392940: 4198FFE4  blt cr6, 0x82392924
	if ctx.cr[6].lt {
	pc = 0x82392924; continue 'dispatch;
	}
	// 82392944: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	pc = 0x82392948; continue 'dispatch;
            }
            0x82392948 => {
    //   block [0x82392948..0x823929B8)
	// 82392948: 2F1BFFFF  cmpwi cr6, r27, -1
	ctx.cr[6].compare_i32(ctx.r[27].s32, -1, &mut ctx.xer);
	// 8239294C: 40990124  ble cr6, 0x82392a70
	if !ctx.cr[6].gt {
	pc = 0x82392A70; continue 'dispatch;
	}
	// 82392950: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82392954: 80890010  lwz r4, 0x10(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82392958: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8239295C: 38EB0360  addi r7, r11, 0x360
	ctx.r[7].s64 = ctx.r[11].s64 + 864;
	// 82392960: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 82392964: 386000D8  li r3, 0xd8
	ctx.r[3].s64 = 216;
	// 82392968: 4BFD7B29  bl 0x8236a490
	ctx.lr = 0x8239296C;
	sub_8236A490(ctx, base);
	// 8239296C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82392970: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82392974: 4182004C  beq 0x823929c0
	if ctx.cr[0].eq {
	pc = 0x823929C0; continue 'dispatch;
	}
	// 82392978: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8239297C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82392980: 394A0370  addi r10, r10, 0x370
	ctx.r[10].s64 = ctx.r[10].s64 + 880;
	// 82392984: C008BA38  lfs f0, -0x45c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392988: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8239298C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82392990: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82392994: D00B0090  stfs f0, 0x90(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82392998: 93AB008C  stw r29, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	// 8239299C: D00B0094  stfs f0, 0x94(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 823929A0: 93AB00A0  stw r29, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 823929A4: C1A81FF8  lfs f13, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823929A8: D1AB0098  stfs f13, 0x98(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 823929AC: B14B009C  sth r10, 0x9c(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[10].u16 ) };
	// 823929B0: 992B001C  stb r9, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u8 ) };
	// 823929B4: 48000010  b 0x823929c4
	pc = 0x823929C4; continue 'dispatch;
            }
            0x823929B8 => {
    //   block [0x823929B8..0x823929C0)
	// 823929B8: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 823929BC: 4BFFFF8C  b 0x82392948
	pc = 0x82392948; continue 'dispatch;
            }
            0x823929C0 => {
    //   block [0x823929C0..0x823929C4)
	// 823929C0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x823929C4; continue 'dispatch;
            }
            0x823929C4 => {
    //   block [0x823929C4..0x82392A70)
	// 823929C4: 576A103A  slwi r10, r27, 2
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823929C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823929CC: 7D6AE12E  stwx r11, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[11].u32) };
	// 823929D0: 419A00A0  beq cr6, 0x82392a70
	if ctx.cr[6].eq {
	pc = 0x82392A70; continue 'dispatch;
	}
	// 823929D4: 93AB00D0  stw r29, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 823929D8: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 823929DC: 7D4AE02E  lwzx r10, r10, r28
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 823929E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823929E4: 910A00D4  stw r8, 0xd4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(212 as u32), ctx.r[8].u32 ) };
	// 823929E8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823929EC: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 823929F0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823929F4: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 823929F8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823929FC: 914B0088  stw r10, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82392A00: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82392A04: 914B008C  stw r10, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 82392A08: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392A0C: D00B0090  stfs f0, 0x90(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82392A10: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392A14: D00B0098  stfs f0, 0x98(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82392A18: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392A1C: D00B0094  stfs f0, 0x94(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82392A20: A15F001C  lhz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82392A24: B14B009C  sth r10, 0x9c(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[10].u16 ) };
	// 82392A28: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82392A2C: 92EB00A8  stw r23, 0xa8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), ctx.r[23].u32 ) };
	// 82392A30: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 82392A34: 7D59C02E  lwzx r10, r25, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 82392A38: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 82392A3C: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82392A40: 815E0034  lwz r10, 0x34(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82392A44: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82392A48: 936B00B4  stw r27, 0xb4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), ctx.r[27].u32 ) };
	// 82392A4C: 912B00B8  stw r9, 0xb8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), ctx.r[9].u32 ) };
	// 82392A50: 93CB00A4  stw r30, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 82392A54: 914B00B0  stw r10, 0xb0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 82392A58: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82392A5C: 914B00C0  stw r10, 0xc0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(192 as u32), ctx.r[10].u32 ) };
	// 82392A60: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82392A64: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82392A68: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82392A6C: 48000008  b 0x82392a74
	pc = 0x82392A74; continue 'dispatch;
            }
            0x82392A70 => {
    //   block [0x82392A70..0x82392A74)
	// 82392A70: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82392A74; continue 'dispatch;
            }
            0x82392A74 => {
    //   block [0x82392A74..0x82392A7C)
	// 82392A74: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82392A78: 481A267C  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82392A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82392A80 size=636
    let mut pc: u32 = 0x82392A80;
    'dispatch: loop {
        match pc {
            0x82392A80 => {
    //   block [0x82392A80..0x82392B60)
	// 82392A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82392A84: 481A261D  bl 0x825350a0
	ctx.lr = 0x82392A88;
	sub_82535080(ctx, base);
	// 82392A88: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 82392A8C: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82392A90: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82392A94: 3D601234  lis r11, 0x1234
	ctx.r[11].s64 = 305397760;
	// 82392A98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82392A9C: 616AFEDC  ori r10, r11, 0xfedc
	ctx.r[10].u64 = ctx.r[11].u64 | 65244;
	// 82392AA0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82392AA4: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82392AA8: 3B6B2F88  addi r27, r11, 0x2f88
	ctx.r[27].s64 = ctx.r[11].s64 + 12168;
	// 82392AAC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82392AB0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82392AB4: 409A0234  bne cr6, 0x82392ce8
	if !ctx.cr[6].eq {
	pc = 0x82392CE8; continue 'dispatch;
	}
	// 82392AB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82392ABC: 419A022C  beq cr6, 0x82392ce8
	if ctx.cr[6].eq {
	pc = 0x82392CE8; continue 'dispatch;
	}
	// 82392AC0: C03F0014  lfs f1, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82392AC4: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82392AC8: C3FF0010  lfs f31, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82392ACC: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82392AD0: C3DF0018  lfs f30, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82392AD4: 839F0008  lwz r28, 8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82392AD8: 833F000C  lwz r25, 0xc(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82392ADC: 481A067D  bl 0x82533158
	ctx.lr = 0x82392AE0;
	sub_82533158(ctx, base);
	// 82392AE0: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82392AE4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82392AE8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82392AEC: AB5F001C  lha r26, 0x1c(r31)
	ctx.r[26].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as i16) as i64;
	// 82392AF0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82392AF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82392AF8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82392AFC: C00B2220  lfs f0, 0x2220(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8736 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392B00: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82392B04: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82392B08: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82392B0C: 4BFFF8AD  bl 0x823923b8
	ctx.lr = 0x82392B10;
	sub_823923B8(ctx, base);
	// 82392B10: 395B00D0  addi r10, r27, 0xd0
	ctx.r[10].s64 = ctx.r[27].s64 + 208;
	// 82392B14: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82392B18: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82392B1C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82392B20: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82392B24: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82392B28: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82392B2C: 817B0034  lwz r11, 0x34(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 82392B30: 7F0A582E  lwzx r24, r10, r11
	ctx.r[24].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82392B34: 419801B4  blt cr6, 0x82392ce8
	if ctx.cr[6].lt {
	pc = 0x82392CE8; continue 'dispatch;
	}
	// 82392B38: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82392B3C: 4BFFF4D5  bl 0x82392010
	ctx.lr = 0x82392B40;
	sub_82392010(ctx, base);
	// 82392B40: 7F1C1800  cmpw cr6, r28, r3
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82392B44: 409801A4  bge cr6, 0x82392ce8
	if !ctx.cr[6].lt {
	pc = 0x82392CE8; continue 'dispatch;
	}
	// 82392B48: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 82392B4C: 409A0050  bne cr6, 0x82392b9c
	if !ctx.cr[6].eq {
	pc = 0x82392B9C; continue 'dispatch;
	}
	// 82392B50: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82392B54: 419A000C  beq cr6, 0x82392b60
	if ctx.cr[6].eq {
	pc = 0x82392B60; continue 'dispatch;
	}
	// 82392B58: 7EDFB378  mr r31, r22
	ctx.r[31].u64 = ctx.r[22].u64;
	// 82392B5C: 48000010  b 0x82392b6c
	pc = 0x82392B6C; continue 'dispatch;
            }
            0x82392B60 => {
    //   block [0x82392B60..0x82392B6C)
	// 82392B60: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82392B64: 396BBB70  addi r11, r11, -0x4490
	ctx.r[11].s64 = ctx.r[11].s64 + -17552;
	// 82392B68: 3BEBFFF8  addi r31, r11, -8
	ctx.r[31].s64 = ctx.r[11].s64 + -8;
	pc = 0x82392B6C; continue 'dispatch;
            }
            0x82392B6C => {
    //   block [0x82392B6C..0x82392B9C)
	// 82392B6C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82392B70: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82392B74: 48072875  bl 0x824053e8
	ctx.lr = 0x82392B78;
	sub_824053E8(ctx, base);
	// 82392B78: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82392B7C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82392B80: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82392B84: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82392B88: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82392B8C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82392B90: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82392B94: 480730E5  bl 0x82405c78
	ctx.lr = 0x82392B98;
	sub_82405C78(ctx, base);
	// 82392B98: 48000154  b 0x82392cec
	pc = 0x82392CEC; continue 'dispatch;
            }
            0x82392B9C => {
    //   block [0x82392B9C..0x82392BB8)
	// 82392B9C: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82392BA0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82392BA4: 3BABBB70  addi r29, r11, -0x4490
	ctx.r[29].s64 = ctx.r[11].s64 + -17552;
	// 82392BA8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82392BAC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82392BB0: 812BFAC0  lwz r9, -0x540(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82392BB4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82392BB8; continue 'dispatch;
            }
            0x82392BB8 => {
    //   block [0x82392BB8..0x82392BDC)
	// 82392BB8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82392BBC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82392BC0: 419A008C  beq cr6, 0x82392c4c
	if ctx.cr[6].eq {
	pc = 0x82392C4C; continue 'dispatch;
	}
	// 82392BC4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82392BC8: 391D0040  addi r8, r29, 0x40
	ctx.r[8].s64 = ctx.r[29].s64 + 64;
	// 82392BCC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82392BD0: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82392BD4: 4198FFE4  blt cr6, 0x82392bb8
	if ctx.cr[6].lt {
	pc = 0x82392BB8; continue 'dispatch;
	}
	// 82392BD8: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	pc = 0x82392BDC; continue 'dispatch;
            }
            0x82392BDC => {
    //   block [0x82392BDC..0x82392C4C)
	// 82392BDC: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 82392BE0: 40990100  ble cr6, 0x82392ce0
	if !ctx.cr[6].gt {
	pc = 0x82392CE0; continue 'dispatch;
	}
	// 82392BE4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82392BE8: 80890010  lwz r4, 0x10(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82392BEC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82392BF0: 38EB0368  addi r7, r11, 0x368
	ctx.r[7].s64 = ctx.r[11].s64 + 872;
	// 82392BF4: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 82392BF8: 386000D8  li r3, 0xd8
	ctx.r[3].s64 = 216;
	// 82392BFC: 4BFD7895  bl 0x8236a490
	ctx.lr = 0x82392C00;
	sub_8236A490(ctx, base);
	// 82392C00: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82392C04: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82392C08: 4182004C  beq 0x82392c54
	if ctx.cr[0].eq {
	pc = 0x82392C54; continue 'dispatch;
	}
	// 82392C0C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82392C10: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82392C14: 394A0370  addi r10, r10, 0x370
	ctx.r[10].s64 = ctx.r[10].s64 + 880;
	// 82392C18: C009BA38  lfs f0, -0x45c8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392C1C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82392C20: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82392C24: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82392C28: D00B0090  stfs f0, 0x90(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82392C2C: 93CB008C  stw r30, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 82392C30: D00B0094  stfs f0, 0x94(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82392C34: 93CB00A0  stw r30, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 82392C38: C1A91FF8  lfs f13, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82392C3C: D1AB0098  stfs f13, 0x98(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82392C40: B14B009C  sth r10, 0x9c(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[10].u16 ) };
	// 82392C44: 990B001C  stb r8, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[8].u8 ) };
	// 82392C48: 48000010  b 0x82392c58
	pc = 0x82392C58; continue 'dispatch;
            }
            0x82392C4C => {
    //   block [0x82392C4C..0x82392C54)
	// 82392C4C: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 82392C50: 4BFFFF8C  b 0x82392bdc
	pc = 0x82392BDC; continue 'dispatch;
            }
            0x82392C54 => {
    //   block [0x82392C54..0x82392C58)
	// 82392C54: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82392C58; continue 'dispatch;
            }
            0x82392C58 => {
    //   block [0x82392C58..0x82392CE0)
	// 82392C58: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82392C5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82392C60: 7D6AE92E  stwx r11, r10, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32), ctx.r[11].u32) };
	// 82392C64: 419A0084  beq cr6, 0x82392ce8
	if ctx.cr[6].eq {
	pc = 0x82392CE8; continue 'dispatch;
	}
	// 82392C68: 93CB00D0  stw r30, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[30].u32 ) };
	// 82392C6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82392C70: 7D4AE82E  lwzx r10, r10, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82392C74: 932A00D4  stw r25, 0xd4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(212 as u32), ctx.r[25].u32 ) };
	// 82392C78: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82392C7C: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82392C80: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82392C84: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 82392C88: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82392C8C: 914B0088  stw r10, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82392C90: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82392C94: 914B008C  stw r10, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 82392C98: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392C9C: D00B0090  stfs f0, 0x90(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82392CA0: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392CA4: D00B0098  stfs f0, 0x98(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82392CA8: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392CAC: D00B0094  stfs f0, 0x94(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82392CB0: A15F001C  lhz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82392CB4: B14B009C  sth r10, 0x9c(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[10].u16 ) };
	// 82392CB8: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82392CBC: 92CB00A8  stw r22, 0xa8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), ctx.r[22].u32 ) };
	// 82392CC0: 92EB00BC  stw r23, 0xbc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), ctx.r[23].u32 ) };
	// 82392CC4: 936B00A4  stw r27, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[27].u32 ) };
	// 82392CC8: 938B00B4  stw r28, 0xb4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), ctx.r[28].u32 ) };
	// 82392CCC: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 82392CD0: 910B00B8  stw r8, 0xb8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), ctx.r[8].u32 ) };
	// 82392CD4: 93CB00CC  stw r30, 0xcc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(204 as u32), ctx.r[30].u32 ) };
	// 82392CD8: 930B00B0  stw r24, 0xb0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[24].u32 ) };
	// 82392CDC: 48000010  b 0x82392cec
	pc = 0x82392CEC; continue 'dispatch;
            }
            0x82392CE0 => {
    //   block [0x82392CE0..0x82392CE8)
	// 82392CE0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82392CE4: 48000008  b 0x82392cec
	pc = 0x82392CEC; continue 'dispatch;
            }
            0x82392CE8 => {
    //   block [0x82392CE8..0x82392CEC)
	// 82392CE8: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82392CEC; continue 'dispatch;
            }
            0x82392CEC => {
    //   block [0x82392CEC..0x82392CFC)
	// 82392CEC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82392CF0: CBC1FF98  lfd f30, -0x68(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82392CF4: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82392CF8: 481A23F8  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82392D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82392D00 size=316
    let mut pc: u32 = 0x82392D00;
    'dispatch: loop {
        match pc {
            0x82392D00 => {
    //   block [0x82392D00..0x82392E24)
	// 82392D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82392D04: 481A23AD  bl 0x825350b0
	ctx.lr = 0x82392D08;
	sub_82535080(ctx, base);
	// 82392D08: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 82392D0C: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82392D10: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82392D14: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82392D18: 3D601234  lis r11, 0x1234
	ctx.r[11].s64 = 305397760;
	// 82392D1C: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82392D20: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 82392D24: 616AFEDC  ori r10, r11, 0xfedc
	ctx.r[10].u64 = ctx.r[11].u64 | 65244;
	// 82392D28: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82392D2C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82392D30: 3BCB2F88  addi r30, r11, 0x2f88
	ctx.r[30].s64 = ctx.r[11].s64 + 12168;
	// 82392D34: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82392D38: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 82392D3C: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 82392D40: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82392D44: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82392D48: 409A00DC  bne cr6, 0x82392e24
	if !ctx.cr[6].eq {
	pc = 0x82392E24; continue 'dispatch;
	}
	// 82392D4C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82392D50: 419800D4  blt cr6, 0x82392e24
	if ctx.cr[6].lt {
	pc = 0x82392E24; continue 'dispatch;
	}
	// 82392D54: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82392D58: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 82392D5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82392D60: 4BFFF2B1  bl 0x82392010
	ctx.lr = 0x82392D64;
	sub_82392010(ctx, base);
	// 82392D64: 7F1B1800  cmpw cr6, r27, r3
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82392D68: 409800BC  bge cr6, 0x82392e24
	if !ctx.cr[6].lt {
	pc = 0x82392E24; continue 'dispatch;
	}
	// 82392D6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82392D70: C01C0004  lfs f0, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392D74: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82392D78: C3EB2490  lfs f31, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82392D7C: 817E00EC  lwz r11, 0xec(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 82392D80: EFC007F2  fmuls f30, f0, f31
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82392D84: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392D88: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82392D8C: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82392D90: 7FCA582E  lwzx r30, r10, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82392D94: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82392D98: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82392D9C: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392DA0: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82392DA4: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82392DA8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82392DAC: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392DB0: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82392DB4: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82392DB8: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82392DBC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82392DC0: 4BD8A709  bl 0x8211d4c8
	ctx.lr = 0x82392DC4;
	sub_8211D4C8(ctx, base);
	// 82392DC4: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392DC8: D0210068  stfs f1, 0x68(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82392DCC: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82392DD0: 4BDC04E9  bl 0x821532b8
	ctx.lr = 0x82392DD4;
	sub_821532B8(ctx, base);
	// 82392DD4: D021006C  stfs f1, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82392DD8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82392DDC: 4BDC04DD  bl 0x821532b8
	ctx.lr = 0x82392DE0;
	sub_821532B8(ctx, base);
	// 82392DE0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82392DE4: D0210070  stfs f1, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82392DE8: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82392DEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82392DF0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82392DF4: 480736D5  bl 0x824064c8
	ctx.lr = 0x82392DF8;
	sub_824064C8(ctx, base);
	// 82392DF8: 39210088  addi r9, r1, 0x88
	ctx.r[9].s64 = ctx.r[1].s64 + 136;
	// 82392DFC: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82392E00: C0410060  lfs f2, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82392E04: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82392E08: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82392E0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82392E10: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82392E14: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82392E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82392E1C: 48072FBD  bl 0x82405dd8
	ctx.lr = 0x82392E20;
	sub_82405DD8(ctx, base);
	// 82392E20: 48000008  b 0x82392e28
	pc = 0x82392E28; continue 'dispatch;
            }
            0x82392E24 => {
    //   block [0x82392E24..0x82392E28)
	// 82392E24: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82392E28; continue 'dispatch;
            }
            0x82392E28 => {
    //   block [0x82392E28..0x82392E3C)
	// 82392E28: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82392E2C: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82392E30: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82392E34: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82392E38: 481A22C8  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82392E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82392E40 size=220
    let mut pc: u32 = 0x82392E40;
    'dispatch: loop {
        match pc {
            0x82392E40 => {
    //   block [0x82392E40..0x82392F10)
	// 82392E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82392E44: 481A2271  bl 0x825350b4
	ctx.lr = 0x82392E48;
	sub_82535080(ctx, base);
	// 82392E48: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82392E4C: 3D601234  lis r11, 0x1234
	ctx.r[11].s64 = 305397760;
	// 82392E50: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 82392E54: 616AFEDC  ori r10, r11, 0xfedc
	ctx.r[10].u64 = ctx.r[11].u64 | 65244;
	// 82392E58: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82392E5C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82392E60: 3BAB2F88  addi r29, r11, 0x2f88
	ctx.r[29].s64 = ctx.r[11].s64 + 12168;
	// 82392E64: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 82392E68: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 82392E6C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82392E70: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82392E74: 409A009C  bne cr6, 0x82392f10
	if !ctx.cr[6].eq {
	pc = 0x82392F10; continue 'dispatch;
	}
	// 82392E78: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82392E7C: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 82392E80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82392E84: 4BFFF18D  bl 0x82392010
	ctx.lr = 0x82392E88;
	sub_82392010(ctx, base);
	// 82392E88: 2F030010  cmpwi cr6, r3, 0x10
	ctx.cr[6].compare_i32(ctx.r[3].s32, 16, &mut ctx.xer);
	// 82392E8C: 40990084  ble cr6, 0x82392f10
	if !ctx.cr[6].gt {
	pc = 0x82392F10; continue 'dispatch;
	}
	// 82392E90: 817D00EC  lwz r11, 0xec(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(236 as u32) ) } as u64;
	// 82392E94: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392E98: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82392E9C: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82392EA0: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82392EA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82392EA8: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82392EAC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82392EB0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82392EB4: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82392EB8: C04B1FF8  lfs f2, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82392EBC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82392EC0: C02BBA38  lfs f1, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82392EC4: 817D0034  lwz r11, 0x34(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82392EC8: 7C66582E  lwzx r3, r6, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82392ECC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82392ED0: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392ED4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82392ED8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82392EDC: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392EE0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82392EE4: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392EE8: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82392EEC: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392EF0: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82392EF4: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392EF8: D0410070  stfs f2, 0x70(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82392EFC: D0410074  stfs f2, 0x74(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82392F00: D0410078  stfs f2, 0x78(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82392F04: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82392F08: 480730E9  bl 0x82405ff0
	ctx.lr = 0x82392F0C;
	sub_82405FF0(ctx, base);
	// 82392F0C: 48000008  b 0x82392f14
	pc = 0x82392F14; continue 'dispatch;
            }
            0x82392F10 => {
    //   block [0x82392F10..0x82392F14)
	// 82392F10: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82392F14; continue 'dispatch;
            }
            0x82392F14 => {
    //   block [0x82392F14..0x82392F1C)
	// 82392F14: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82392F18: 481A21EC  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82392F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82392F20 size=724
    let mut pc: u32 = 0x82392F20;
    'dispatch: loop {
        match pc {
            0x82392F20 => {
    //   block [0x82392F20..0x82392F90)
	// 82392F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82392F24: 481A2185  bl 0x825350a8
	ctx.lr = 0x82392F28;
	sub_82535080(ctx, base);
	// 82392F28: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82392F2C: 3D601234  lis r11, 0x1234
	ctx.r[11].s64 = 305397760;
	// 82392F30: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82392F34: 616AFEDC  ori r10, r11, 0xfedc
	ctx.r[10].u64 = ctx.r[11].u64 | 65244;
	// 82392F38: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82392F3C: 3BCB2F88  addi r30, r11, 0x2f88
	ctx.r[30].s64 = ctx.r[11].s64 + 12168;
	// 82392F40: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82392F44: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82392F48: 409A02A0  bne cr6, 0x823931e8
	if !ctx.cr[6].eq {
	pc = 0x823931E8; continue 'dispatch;
	}
	// 82392F4C: 38A00029  li r5, 0x29
	ctx.r[5].s64 = 41;
	// 82392F50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82392F54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82392F58: 4BFFF461  bl 0x823923b8
	ctx.lr = 0x82392F5C;
	sub_823923B8(ctx, base);
	// 82392F5C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82392F60: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82392F64: 41980284  blt cr6, 0x823931e8
	if ctx.cr[6].lt {
	pc = 0x823931E8; continue 'dispatch;
	}
	// 82392F68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82392F6C: 4BFFF0A5  bl 0x82392010
	ctx.lr = 0x82392F70;
	sub_82392010(ctx, base);
	// 82392F70: 7F1A1800  cmpw cr6, r26, r3
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82392F74: 40980274  bge cr6, 0x823931e8
	if !ctx.cr[6].lt {
	pc = 0x823931E8; continue 'dispatch;
	}
	// 82392F78: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82392F7C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82392F80: 2F184000  cmpwi cr6, r24, 0x4000
	ctx.cr[6].compare_i32(ctx.r[24].s32, 16384, &mut ctx.xer);
	// 82392F84: 4098000C  bge cr6, 0x82392f90
	if !ctx.cr[6].lt {
	pc = 0x82392F90; continue 'dispatch;
	}
	// 82392F88: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82392F8C: 4800001C  b 0x82392fa8
	pc = 0x82392FA8; continue 'dispatch;
            }
            0x82392F90 => {
    //   block [0x82392F90..0x82392FA8)
	// 82392F90: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82392F94: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 82392F98: 7F185800  cmpw cr6, r24, r11
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82392F9C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82392FA0: 41980008  blt cr6, 0x82392fa8
	if ctx.cr[6].lt {
	pc = 0x82392FA8; continue 'dispatch;
	}
	// 82392FA4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	pc = 0x82392FA8; continue 'dispatch;
            }
            0x82392FA8 => {
    //   block [0x82392FA8..0x82393024)
	// 82392FA8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82392FAC: 419800DC  blt cr6, 0x82393088
	if ctx.cr[6].lt {
	pc = 0x82393088; continue 'dispatch;
	}
	// 82392FB0: 419A0074  beq cr6, 0x82393024
	if ctx.cr[6].eq {
	pc = 0x82393024; continue 'dispatch;
	}
	// 82392FB4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82392FB8: 40980230  bge cr6, 0x823931e8
	if !ctx.cr[6].lt {
	pc = 0x823931E8; continue 'dispatch;
	}
	// 82392FBC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82392FC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82392FC4: 409A0104  bne cr6, 0x823930c8
	if !ctx.cr[6].eq {
	pc = 0x823930C8; continue 'dispatch;
	}
	// 82392FC8: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82392FCC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82392FD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82392FD4: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82392FD8: 396BBB70  addi r11, r11, -0x4490
	ctx.r[11].s64 = ctx.r[11].s64 + -17552;
	// 82392FDC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82392FE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82392FE4: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82392FE8: 38ABFFF8  addi r5, r11, -8
	ctx.r[5].s64 = ctx.r[11].s64 + -8;
	// 82392FEC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82392FF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82392FF4: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82392FF8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82392FFC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82393000: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82393004: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82393008: 39600029  li r11, 0x29
	ctx.r[11].s64 = 41;
	// 8239300C: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82393010: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82393014: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82393018: B161006C  sth r11, 0x6c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u16 ) };
	// 8239301C: 4BFFF865  bl 0x82392880
	ctx.lr = 0x82393020;
	sub_82392880(ctx, base);
	// 82393020: 480001CC  b 0x823931ec
	pc = 0x823931EC; continue 'dispatch;
            }
            0x82393024 => {
    //   block [0x82393024..0x82393088)
	// 82393024: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82393028: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8239302C: 409A009C  bne cr6, 0x823930c8
	if !ctx.cr[6].eq {
	pc = 0x823930C8; continue 'dispatch;
	}
	// 82393030: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82393034: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82393038: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8239303C: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82393040: 396BBB70  addi r11, r11, -0x4490
	ctx.r[11].s64 = ctx.r[11].s64 + -17552;
	// 82393044: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82393048: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8239304C: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82393050: 38ABFFF8  addi r5, r11, -8
	ctx.r[5].s64 = ctx.r[11].s64 + -8;
	// 82393054: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82393058: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8239305C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82393060: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82393064: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82393068: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8239306C: 39600029  li r11, 0x29
	ctx.r[11].s64 = 41;
	// 82393070: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82393074: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82393078: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8239307C: B161006C  sth r11, 0x6c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u16 ) };
	// 82393080: 4BFFF5D9  bl 0x82392658
	ctx.lr = 0x82393084;
	sub_82392658(ctx, base);
	// 82393084: 48000168  b 0x823931ec
	pc = 0x823931EC; continue 'dispatch;
            }
            0x82393088 => {
    //   block [0x82393088..0x823930C8)
	// 82393088: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8239308C: 817E00D0  lwz r11, 0xd0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 82393090: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82393094: 396B0029  addi r11, r11, 0x29
	ctx.r[11].s64 = ctx.r[11].s64 + 41;
	// 82393098: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8239309C: C04A1FF8  lfs f2, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823930A0: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 823930A4: 394ABB70  addi r10, r10, -0x4490
	ctx.r[10].s64 = ctx.r[10].s64 + -17552;
	// 823930A8: 390AFFF8  addi r8, r10, -8
	ctx.r[8].s64 = ctx.r[10].s64 + -8;
	// 823930AC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 823930B0: C02ABA38  lfs f1, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823930B4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823930B8: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 823930BC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823930C0: 48072B81  bl 0x82405c40
	ctx.lr = 0x823930C4;
	sub_82405C40(ctx, base);
	// 823930C4: 48000128  b 0x823931ec
	pc = 0x823931EC; continue 'dispatch;
            }
            0x823930C8 => {
    //   block [0x823930C8..0x823930E0)
	// 823930C8: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823930CC: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 823930D0: 3BABBB70  addi r29, r11, -0x4490
	ctx.r[29].s64 = ctx.r[11].s64 + -17552;
	// 823930D4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 823930D8: 812BFAC0  lwz r9, -0x540(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 823930DC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x823930E0; continue 'dispatch;
            }
            0x823930E0 => {
    //   block [0x823930E0..0x82393108)
	// 823930E0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823930E4: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	// 823930E8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823930EC: 419A0084  beq cr6, 0x82393170
	if ctx.cr[6].eq {
	pc = 0x82393170; continue 'dispatch;
	}
	// 823930F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823930F4: 391D0040  addi r8, r29, 0x40
	ctx.r[8].s64 = ctx.r[29].s64 + 64;
	// 823930F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823930FC: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82393100: 4198FFE0  blt cr6, 0x823930e0
	if ctx.cr[6].lt {
	pc = 0x823930E0; continue 'dispatch;
	}
	// 82393104: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	pc = 0x82393108; continue 'dispatch;
            }
            0x82393108 => {
    //   block [0x82393108..0x82393170)
	// 82393108: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 8239310C: 409900D4  ble cr6, 0x823931e0
	if !ctx.cr[6].gt {
	pc = 0x823931E0; continue 'dispatch;
	}
	// 82393110: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82393114: 80890010  lwz r4, 0x10(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82393118: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8239311C: 38EB0368  addi r7, r11, 0x368
	ctx.r[7].s64 = ctx.r[11].s64 + 872;
	// 82393120: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 82393124: 386000D8  li r3, 0xd8
	ctx.r[3].s64 = 216;
	// 82393128: 4BFD7369  bl 0x8236a490
	ctx.lr = 0x8239312C;
	sub_8236A490(ctx, base);
	// 8239312C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82393130: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82393134: C009BA38  lfs f0, -0x45c8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82393138: C1AA1FF8  lfs f13, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8239313C: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82393140: 41820038  beq 0x82393178
	if ctx.cr[0].eq {
	pc = 0x82393178; continue 'dispatch;
	}
	// 82393144: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82393148: 394A0370  addi r10, r10, 0x370
	ctx.r[10].s64 = ctx.r[10].s64 + 880;
	// 8239314C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82393150: D00B0090  stfs f0, 0x90(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82393154: D1AB0098  stfs f13, 0x98(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82393158: 93EB008C  stw r31, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 8239315C: D00B0094  stfs f0, 0x94(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82393160: B36B009C  sth r27, 0x9c(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[27].u16 ) };
	// 82393164: 93EB00A0  stw r31, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 82393168: 9B2B001C  stb r25, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 8239316C: 48000010  b 0x8239317c
	pc = 0x8239317C; continue 'dispatch;
            }
            0x82393170 => {
    //   block [0x82393170..0x82393178)
	// 82393170: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 82393174: 4BFFFF94  b 0x82393108
	pc = 0x82393108; continue 'dispatch;
            }
            0x82393178 => {
    //   block [0x82393178..0x8239317C)
	// 82393178: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8239317C; continue 'dispatch;
            }
            0x8239317C => {
    //   block [0x8239317C..0x823931E0)
	// 8239317C: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82393180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82393184: 7D6AE92E  stwx r11, r10, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32), ctx.r[11].u32) };
	// 82393188: 419A0060  beq cr6, 0x823931e8
	if ctx.cr[6].eq {
	pc = 0x823931E8; continue 'dispatch;
	}
	// 8239318C: 93EB00D0  stw r31, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 82393190: 39200029  li r9, 0x29
	ctx.r[9].s64 = 41;
	// 82393194: 7D4AE82E  lwzx r10, r10, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82393198: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8239319C: 932A00D4  stw r25, 0xd4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(212 as u32), ctx.r[25].u32 ) };
	// 823931A0: D00B0090  stfs f0, 0x90(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 823931A4: D1AB0098  stfs f13, 0x98(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 823931A8: 93EB0080  stw r31, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 823931AC: D00B0094  stfs f0, 0x94(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 823931B0: 912B0084  stw r9, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 823931B4: 934B0088  stw r26, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[26].u32 ) };
	// 823931B8: 93EB008C  stw r31, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 823931BC: B36B009C  sth r27, 0x9c(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[27].u16 ) };
	// 823931C0: 93EB00A0  stw r31, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 823931C4: 93EB00A8  stw r31, 0xa8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 823931C8: 93CB00A4  stw r30, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 823931CC: 930B00BC  stw r24, 0xbc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), ctx.r[24].u32 ) };
	// 823931D0: 938B00B4  stw r28, 0xb4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), ctx.r[28].u32 ) };
	// 823931D4: 932B00B8  stw r25, 0xb8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), ctx.r[25].u32 ) };
	// 823931D8: 93EB00CC  stw r31, 0xcc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(204 as u32), ctx.r[31].u32 ) };
	// 823931DC: 48000010  b 0x823931ec
	pc = 0x823931EC; continue 'dispatch;
            }
            0x823931E0 => {
    //   block [0x823931E0..0x823931E8)
	// 823931E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823931E4: 48000008  b 0x823931ec
	pc = 0x823931EC; continue 'dispatch;
            }
            0x823931E8 => {
    //   block [0x823931E8..0x823931EC)
	// 823931E8: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x823931EC; continue 'dispatch;
            }
            0x823931EC => {
    //   block [0x823931EC..0x823931F4)
	// 823931EC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823931F0: 481A1F08  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823931F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823931F8 size=116
    let mut pc: u32 = 0x823931F8;
    'dispatch: loop {
        match pc {
            0x823931F8 => {
    //   block [0x823931F8..0x8239323C)
	// 823931F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823931FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82393200: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82393204: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82393208: 2B0301FF  cmplwi cr6, r3, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[3].u32, 511 as u32, &mut ctx.xer);
	// 8239320C: 394B86B8  addi r10, r11, -0x7948
	ctx.r[10].s64 = ctx.r[11].s64 + -31048;
	// 82393210: 4098002C  bge cr6, 0x8239323c
	if !ctx.cr[6].lt {
	pc = 0x8239323C; continue 'dispatch;
	}
	// 82393214: 1D630018  mulli r11, r3, 0x18
	ctx.r[11].s32 = ((ctx.r[3].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393218: 7D2B50AE  lbzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8239321C: 2F090003  cmpwi cr6, r9, 3
	ctx.cr[6].compare_i32(ctx.r[9].s32, 3, &mut ctx.xer);
	// 82393220: 419A0024  beq cr6, 0x82393244
	if ctx.cr[6].eq {
	pc = 0x82393244; continue 'dispatch;
	}
	// 82393224: 2B0301FF  cmplwi cr6, r3, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[3].u32, 511 as u32, &mut ctx.xer);
	// 82393228: 40980014  bge cr6, 0x8239323c
	if !ctx.cr[6].lt {
	pc = 0x8239323C; continue 'dispatch;
	}
	// 8239322C: 1D630018  mulli r11, r3, 0x18
	ctx.r[11].s32 = ((ctx.r[3].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393230: 7D2B50AE  lbzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82393234: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 82393238: 419A000C  beq cr6, 0x82393244
	if ctx.cr[6].eq {
	pc = 0x82393244; continue 'dispatch;
	}
	pc = 0x8239323C; continue 'dispatch;
            }
            0x8239323C => {
    //   block [0x8239323C..0x82393244)
	// 8239323C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82393240: 4800001C  b 0x8239325c
	pc = 0x8239325C; continue 'dispatch;
            }
            0x82393244 => {
    //   block [0x82393244..0x8239325C)
	// 82393244: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82393248: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8239324C: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82393250: 409AFFEC  bne cr6, 0x8239323c
	if !ctx.cr[6].eq {
	pc = 0x8239323C; continue 'dispatch;
	}
	// 82393254: 4BFE73BD  bl 0x8237a610
	ctx.lr = 0x82393258;
	sub_8237A610(ctx, base);
	// 82393258: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x8239325C; continue 'dispatch;
            }
            0x8239325C => {
    //   block [0x8239325C..0x8239326C)
	// 8239325C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82393260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82393264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82393268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82393270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82393270 size=296
    let mut pc: u32 = 0x82393270;
    'dispatch: loop {
        match pc {
            0x82393270 => {
    //   block [0x82393270..0x823932FC)
	// 82393270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82393274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82393278: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8239327C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82393280: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82393284: 3FC082C0  lis r30, -0x7d40
	ctx.r[30].s64 = -2101346304;
	// 82393288: 817EBFC0  lwz r11, -0x4040(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16448 as u32) ) } as u64;
	// 8239328C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82393290: 409A00EC  bne cr6, 0x8239337c
	if !ctx.cr[6].eq {
	pc = 0x8239337C; continue 'dispatch;
	}
	// 82393294: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82393298: 386BBBB0  addi r3, r11, -0x4450
	ctx.r[3].s64 = ctx.r[11].s64 + -17488;
	// 8239329C: 48006CBD  bl 0x82399f58
	ctx.lr = 0x823932A0;
	sub_82399F58(ctx, base);
	// 823932A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823932A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823932A8: 418200D8  beq 0x82393380
	if ctx.cr[0].eq {
	pc = 0x82393380; continue 'dispatch;
	}
	// 823932AC: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823932B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823932B4: 3BEBBC30  addi r31, r11, -0x43d0
	ctx.r[31].s64 = ctx.r[11].s64 + -17360;
	// 823932B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823932BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823932C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823932C4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823932C8: 4802E1B1  bl 0x823c1478
	ctx.lr = 0x823932CC;
	sub_823C1478(ctx, base);
	// 823932CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823932D0: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823932D4: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823932D8: 3920007F  li r9, 0x7f
	ctx.r[9].s64 = 127;
	// 823932DC: 396BBA20  addi r11, r11, -0x45e0
	ctx.r[11].s64 = ctx.r[11].s64 + -17888;
	// 823932E0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823932E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823932E8: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 823932EC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823932F0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823932F4: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 823932F8: 394B0024  addi r10, r11, 0x24
	ctx.r[10].s64 = ctx.r[11].s64 + 36;
	pc = 0x823932FC; continue 'dispatch;
            }
            0x823932FC => {
    //   block [0x823932FC..0x8239337C)
	// 823932FC: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82393300: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82393304: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82393308: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 8239330C: 4082FFF0  bne 0x823932fc
	if !ctx.cr[0].eq {
	pc = 0x823932FC; continue 'dispatch;
	}
	// 82393310: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82393314: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82393318: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 8239331C: 392B1160  addi r9, r11, 0x1160
	ctx.r[9].s64 = ctx.r[11].s64 + 4448;
	// 82393320: 3D608239  lis r11, -0x7dc7
	ctx.r[11].s64 = -2110193664;
	// 82393324: 3BEABBF0  addi r31, r10, -0x4410
	ctx.r[31].s64 = ctx.r[10].s64 + -17424;
	// 82393328: 388B3790  addi r4, r11, 0x3790
	ctx.r[4].s64 = ctx.r[11].s64 + 14224;
	// 8239332C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82393330: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 82393334: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82393338: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8239333C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 82393340: 917EBFC0  stw r11, -0x4040(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-16448 as u32), ctx.r[11].u32 ) };
	// 82393344: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82393348: 916ABFC4  stw r11, -0x403c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16444 as u32), ctx.r[11].u32 ) };
	// 8239334C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82393350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82393354: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82393358: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8239335C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82393360: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82393364: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82393368: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 8239336C: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82393370: 4800A679  bl 0x8239d9e8
	ctx.lr = 0x82393374;
	sub_8239D9E8(ctx, base);
	// 82393374: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82393378: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x8239337C; continue 'dispatch;
            }
            0x8239337C => {
    //   block [0x8239337C..0x82393380)
	// 8239337C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82393380; continue 'dispatch;
            }
            0x82393380 => {
    //   block [0x82393380..0x82393398)
	// 82393380: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82393384: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82393388: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8239338C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82393390: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82393394: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82393398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82393398 size=240
    let mut pc: u32 = 0x82393398;
    'dispatch: loop {
        match pc {
            0x82393398 => {
    //   block [0x82393398..0x8239341C)
	// 82393398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8239339C: 481A1D19  bl 0x825350b4
	ctx.lr = 0x823933A0;
	sub_82535080(ctx, base);
	// 823933A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823933A4: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823933A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823933AC: 3B6BBBB0  addi r27, r11, -0x4450
	ctx.r[27].s64 = ctx.r[11].s64 + -17488;
	// 823933B0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823933B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823933B8: 48379EA5  bl 0x8270d25c
	ctx.lr = 0x823933BC;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823933BC: 2B1D01FF  cmplwi cr6, r29, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[29].u32, 511 as u32, &mut ctx.xer);
	// 823933C0: 40980080  bge cr6, 0x82393440
	if !ctx.cr[6].lt {
	pc = 0x82393440; continue 'dispatch;
	}
	// 823933C4: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823933C8: 1FFD0018  mulli r31, r29, 0x18
	ctx.r[31].s32 = ((ctx.r[29].s32 as i64 * 24 as i64) as i32);
	ctx.r[31].s64 = ctx.r[31].s32 as i64;
	// 823933CC: 3BCB86B8  addi r30, r11, -0x7948
	ctx.r[30].s64 = ctx.r[11].s64 + -31048;
	// 823933D0: 7D7FF0AE  lbzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 823933D4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823933D8: 419A0078  beq cr6, 0x82393450
	if ctx.cr[6].eq {
	pc = 0x82393450; continue 'dispatch;
	}
	// 823933DC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 823933E0: 409A0060  bne cr6, 0x82393440
	if !ctx.cr[6].eq {
	pc = 0x82393440; continue 'dispatch;
	}
	// 823933E4: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823933E8: B3A10050  sth r29, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u16 ) };
	// 823933EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823933F0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 823933F4: 386BBA20  addi r3, r11, -0x45e0
	ctx.r[3].s64 = ctx.r[11].s64 + -17888;
	// 823933F8: 48000D79  bl 0x82394170
	ctx.lr = 0x823933FC;
	sub_82394170(ctx, base);
	// 823933FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82393400: 4182001C  beq 0x8239341c
	if ctx.cr[0].eq {
	pc = 0x8239341C; continue 'dispatch;
	}
	// 82393404: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82393408: 48379E65  bl 0x8270d26c
	ctx.lr = 0x8239340C;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 8239340C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82393410: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82393414: 4BFFFDE5  bl 0x823931f8
	ctx.lr = 0x82393418;
	sub_823931F8(ctx, base);
	// 82393418: 48000064  b 0x8239347c
	pc = 0x8239347C; continue 'dispatch;
            }
            0x8239341C => {
    //   block [0x8239341C..0x82393440)
	// 8239341C: 7D7FF0AE  lbzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82393420: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82393424: 409A001C  bne cr6, 0x82393440
	if !ctx.cr[6].eq {
	pc = 0x82393440; continue 'dispatch;
	}
	// 82393428: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 8239342C: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82393430: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82393434: 409A000C  bne cr6, 0x82393440
	if !ctx.cr[6].eq {
	pc = 0x82393440; continue 'dispatch;
	}
	// 82393438: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8239343C: 7D7FF1AE  stbx r11, r31, r30
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u8) };
	pc = 0x82393440; continue 'dispatch;
            }
            0x82393440 => {
    //   block [0x82393440..0x82393450)
	// 82393440: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82393444: 48379E29  bl 0x8270d26c
	ctx.lr = 0x82393448;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82393448: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8239344C: 48000034  b 0x82393480
	pc = 0x82393480; continue 'dispatch;
            }
            0x82393450 => {
    //   block [0x82393450..0x8239347C)
	// 82393450: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82393454: 48379E19  bl 0x8270d26c
	ctx.lr = 0x82393458;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82393458: 7D7FF0AE  lbzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8239345C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82393460: 409A001C  bne cr6, 0x8239347c
	if !ctx.cr[6].eq {
	pc = 0x8239347C; continue 'dispatch;
	}
	// 82393464: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 82393468: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8239346C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82393470: 409A000C  bne cr6, 0x8239347c
	if !ctx.cr[6].eq {
	pc = 0x8239347C; continue 'dispatch;
	}
	// 82393474: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82393478: 4BFE70E9  bl 0x8237a560
	ctx.lr = 0x8239347C;
	sub_8237A560(ctx, base);
	pc = 0x8239347C; continue 'dispatch;
            }
            0x8239347C => {
    //   block [0x8239347C..0x82393480)
	// 8239347C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82393480; continue 'dispatch;
            }
            0x82393480 => {
    //   block [0x82393480..0x82393488)
	// 82393480: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82393484: 481A1C80  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82393488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82393488 size=192
    let mut pc: u32 = 0x82393488;
    'dispatch: loop {
        match pc {
            0x82393488 => {
    //   block [0x82393488..0x823934F0)
	// 82393488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8239348C: 481A1C25  bl 0x825350b0
	ctx.lr = 0x82393490;
	sub_82535080(ctx, base);
	// 82393490: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82393494: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82393498: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8239349C: 3B4BBBB0  addi r26, r11, -0x4450
	ctx.r[26].s64 = ctx.r[11].s64 + -17488;
	// 823934A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823934A4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823934A8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823934AC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823934B0: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 823934B4: 48379DA9  bl 0x8270d25c
	ctx.lr = 0x823934B8;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823934B8: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823934BC: 386BBA20  addi r3, r11, -0x45e0
	ctx.r[3].s64 = ctx.r[11].s64 + -17888;
	// 823934C0: 48000C39  bl 0x823940f8
	ctx.lr = 0x823934C4;
	sub_823940F8(ctx, base);
	// 823934C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823934C8: 40820040  bne 0x82393508
	if !ctx.cr[0].eq {
	pc = 0x82393508; continue 'dispatch;
	}
	// 823934CC: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 823934D0: 816ABFC4  lwz r11, -0x403c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16444 as u32) ) } as u64;
	// 823934D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823934D8: 409A0018  bne cr6, 0x823934f0
	if !ctx.cr[6].eq {
	pc = 0x823934F0; continue 'dispatch;
	}
	// 823934DC: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823934E0: 806BBC30  lwz r3, -0x43d0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17360 as u32) ) } as u64;
	// 823934E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823934E8: 916ABFC4  stw r11, -0x403c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16444 as u32), ctx.r[11].u32 ) };
	// 823934EC: 4802E035  bl 0x823c1520
	ctx.lr = 0x823934F0;
	sub_823C1520(ctx, base);
	pc = 0x823934F0; continue 'dispatch;
            }
            0x823934F0 => {
    //   block [0x823934F0..0x823934F4)
	// 823934F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x823934F4; continue 'dispatch;
            }
            0x823934F4 => {
    //   block [0x823934F4..0x82393508)
	// 823934F4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823934F8: 48379D75  bl 0x8270d26c
	ctx.lr = 0x823934FC;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823934FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82393500: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82393504: 481A1BFC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x82393508 => {
    //   block [0x82393508..0x82393548)
	// 82393508: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8239350C: B3E30000  sth r31, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u16 ) };
	// 82393510: B3830002  sth r28, 2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[28].u16 ) };
	// 82393514: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82393518: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8239351C: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82393520: 9363000C  stw r27, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 82393524: 814BBFC4  lwz r10, -0x403c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16444 as u32) ) } as u64;
	// 82393528: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8239352C: 409AFFC8  bne cr6, 0x823934f4
	if !ctx.cr[6].eq {
	pc = 0x823934F4; continue 'dispatch;
	}
	// 82393530: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 82393534: 806ABC30  lwz r3, -0x43d0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17360 as u32) ) } as u64;
	// 82393538: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 8239353C: 914BBFC4  stw r10, -0x403c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16444 as u32), ctx.r[10].u32 ) };
	// 82393540: 4802DFE1  bl 0x823c1520
	ctx.lr = 0x82393544;
	sub_823C1520(ctx, base);
	// 82393544: 4BFFFFB0  b 0x823934f4
	pc = 0x823934F4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82393548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82393548 size=200
    let mut pc: u32 = 0x82393548;
    'dispatch: loop {
        match pc {
            0x82393548 => {
    //   block [0x82393548..0x823935B0)
	// 82393548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8239354C: 481A1B6D  bl 0x825350b8
	ctx.lr = 0x82393550;
	sub_82535080(ctx, base);
	// 82393550: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82393554: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82393558: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 8239355C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82393560: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82393564: 3B8BBBB0  addi r28, r11, -0x4450
	ctx.r[28].s64 = ctx.r[11].s64 + -17488;
	// 82393568: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8239356C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82393570: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82393574: 48379CE9  bl 0x8270d25c
	ctx.lr = 0x82393578;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82393578: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 8239357C: 386BBA20  addi r3, r11, -0x45e0
	ctx.r[3].s64 = ctx.r[11].s64 + -17888;
	// 82393580: 48000B79  bl 0x823940f8
	ctx.lr = 0x82393584;
	sub_823940F8(ctx, base);
	// 82393584: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82393588: 40820044  bne 0x823935cc
	if !ctx.cr[0].eq {
	pc = 0x823935CC; continue 'dispatch;
	}
	// 8239358C: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 82393590: 816ABFC4  lwz r11, -0x403c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16444 as u32) ) } as u64;
	// 82393594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82393598: 409A0018  bne cr6, 0x823935b0
	if !ctx.cr[6].eq {
	pc = 0x823935B0; continue 'dispatch;
	}
	// 8239359C: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823935A0: 806BBC30  lwz r3, -0x43d0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17360 as u32) ) } as u64;
	// 823935A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823935A8: 916ABFC4  stw r11, -0x403c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16444 as u32), ctx.r[11].u32 ) };
	// 823935AC: 4802DF75  bl 0x823c1520
	ctx.lr = 0x823935B0;
	sub_823C1520(ctx, base);
	pc = 0x823935B0; continue 'dispatch;
            }
            0x823935B0 => {
    //   block [0x823935B0..0x823935B4)
	// 823935B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x823935B4; continue 'dispatch;
            }
            0x823935B4 => {
    //   block [0x823935B4..0x823935CC)
	// 823935B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823935B8: 48379CB5  bl 0x8270d26c
	ctx.lr = 0x823935BC;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823935BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823935C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823935C4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 823935C8: 481A1B40  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x823935CC => {
    //   block [0x823935CC..0x82393610)
	// 823935CC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 823935D0: B3E30000  sth r31, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u16 ) };
	// 823935D4: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 823935D8: D3E30008  stfs f31, 8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823935DC: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823935E0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 823935E4: 93A3000C  stw r29, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 823935E8: 814BBFC4  lwz r10, -0x403c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16444 as u32) ) } as u64;
	// 823935EC: B1030002  sth r8, 2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 823935F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823935F4: 409AFFC0  bne cr6, 0x823935b4
	if !ctx.cr[6].eq {
	pc = 0x823935B4; continue 'dispatch;
	}
	// 823935F8: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 823935FC: 806ABC30  lwz r3, -0x43d0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17360 as u32) ) } as u64;
	// 82393600: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82393604: 914BBFC4  stw r10, -0x403c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16444 as u32), ctx.r[10].u32 ) };
	// 82393608: 4802DF19  bl 0x823c1520
	ctx.lr = 0x8239360C;
	sub_823C1520(ctx, base);
	// 8239360C: 4BFFFFA8  b 0x823935b4
	pc = 0x823935B4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82393610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82393610 size=192
    let mut pc: u32 = 0x82393610;
    'dispatch: loop {
        match pc {
            0x82393610 => {
    //   block [0x82393610..0x82393674)
	// 82393610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82393614: 481A1AA1  bl 0x825350b4
	ctx.lr = 0x82393618;
	sub_82535080(ctx, base);
	// 82393618: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8239361C: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82393620: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82393624: 3B6BBBB0  addi r27, r11, -0x4450
	ctx.r[27].s64 = ctx.r[11].s64 + -17488;
	// 82393628: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8239362C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82393630: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82393634: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82393638: 48379C25  bl 0x8270d25c
	ctx.lr = 0x8239363C;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 8239363C: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82393640: 386BBA20  addi r3, r11, -0x45e0
	ctx.r[3].s64 = ctx.r[11].s64 + -17888;
	// 82393644: 48000AB5  bl 0x823940f8
	ctx.lr = 0x82393648;
	sub_823940F8(ctx, base);
	// 82393648: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8239364C: 40820040  bne 0x8239368c
	if !ctx.cr[0].eq {
	pc = 0x8239368C; continue 'dispatch;
	}
	// 82393650: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 82393654: 816ABFC4  lwz r11, -0x403c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16444 as u32) ) } as u64;
	// 82393658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8239365C: 409A0018  bne cr6, 0x82393674
	if !ctx.cr[6].eq {
	pc = 0x82393674; continue 'dispatch;
	}
	// 82393660: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82393664: 806BBC30  lwz r3, -0x43d0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17360 as u32) ) } as u64;
	// 82393668: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8239366C: 916ABFC4  stw r11, -0x403c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16444 as u32), ctx.r[11].u32 ) };
	// 82393670: 4802DEB1  bl 0x823c1520
	ctx.lr = 0x82393674;
	sub_823C1520(ctx, base);
	pc = 0x82393674; continue 'dispatch;
            }
            0x82393674 => {
    //   block [0x82393674..0x82393678)
	// 82393674: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82393678; continue 'dispatch;
            }
            0x82393678 => {
    //   block [0x82393678..0x8239368C)
	// 82393678: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8239367C: 48379BF1  bl 0x8270d26c
	ctx.lr = 0x82393680;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82393680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82393684: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82393688: 481A1A7C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x8239368C => {
    //   block [0x8239368C..0x823936D0)
	// 8239368C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82393690: B3E30000  sth r31, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u16 ) };
	// 82393694: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82393698: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8239369C: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 823936A0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 823936A4: 9383000C  stw r28, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 823936A8: 814BBFC4  lwz r10, -0x403c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16444 as u32) ) } as u64;
	// 823936AC: B1230002  sth r9, 2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[9].u16 ) };
	// 823936B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823936B4: 409AFFC4  bne cr6, 0x82393678
	if !ctx.cr[6].eq {
	pc = 0x82393678; continue 'dispatch;
	}
	// 823936B8: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 823936BC: 806ABC30  lwz r3, -0x43d0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17360 as u32) ) } as u64;
	// 823936C0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 823936C4: 914BBFC4  stw r10, -0x403c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16444 as u32), ctx.r[10].u32 ) };
	// 823936C8: 4802DE59  bl 0x823c1520
	ctx.lr = 0x823936CC;
	sub_823C1520(ctx, base);
	// 823936CC: 4BFFFFAC  b 0x82393678
	pc = 0x82393678; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823936D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823936D0 size=192
    let mut pc: u32 = 0x823936D0;
    'dispatch: loop {
        match pc {
            0x823936D0 => {
    //   block [0x823936D0..0x82393734)
	// 823936D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823936D4: 481A19E1  bl 0x825350b4
	ctx.lr = 0x823936D8;
	sub_82535080(ctx, base);
	// 823936D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823936DC: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823936E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823936E4: 3B6BBBB0  addi r27, r11, -0x4450
	ctx.r[27].s64 = ctx.r[11].s64 + -17488;
	// 823936E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823936EC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823936F0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823936F4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823936F8: 48379B65  bl 0x8270d25c
	ctx.lr = 0x823936FC;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823936FC: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82393700: 386BBA20  addi r3, r11, -0x45e0
	ctx.r[3].s64 = ctx.r[11].s64 + -17888;
	// 82393704: 480009F5  bl 0x823940f8
	ctx.lr = 0x82393708;
	sub_823940F8(ctx, base);
	// 82393708: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8239370C: 40820040  bne 0x8239374c
	if !ctx.cr[0].eq {
	pc = 0x8239374C; continue 'dispatch;
	}
	// 82393710: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 82393714: 816ABFC4  lwz r11, -0x403c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16444 as u32) ) } as u64;
	// 82393718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8239371C: 409A0018  bne cr6, 0x82393734
	if !ctx.cr[6].eq {
	pc = 0x82393734; continue 'dispatch;
	}
	// 82393720: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82393724: 806BBC30  lwz r3, -0x43d0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17360 as u32) ) } as u64;
	// 82393728: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8239372C: 916ABFC4  stw r11, -0x403c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16444 as u32), ctx.r[11].u32 ) };
	// 82393730: 4802DDF1  bl 0x823c1520
	ctx.lr = 0x82393734;
	sub_823C1520(ctx, base);
	pc = 0x82393734; continue 'dispatch;
            }
            0x82393734 => {
    //   block [0x82393734..0x82393738)
	// 82393734: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82393738; continue 'dispatch;
            }
            0x82393738 => {
    //   block [0x82393738..0x8239374C)
	// 82393738: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8239373C: 48379B31  bl 0x8270d26c
	ctx.lr = 0x82393740;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82393740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82393744: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82393748: 481A19BC  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x8239374C => {
    //   block [0x8239374C..0x82393790)
	// 8239374C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82393750: B3E30000  sth r31, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u16 ) };
	// 82393754: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82393758: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8239375C: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82393760: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82393764: 9383000C  stw r28, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82393768: 814BBFC4  lwz r10, -0x403c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16444 as u32) ) } as u64;
	// 8239376C: B1230002  sth r9, 2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[9].u16 ) };
	// 82393770: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82393774: 409AFFC4  bne cr6, 0x82393738
	if !ctx.cr[6].eq {
	pc = 0x82393738; continue 'dispatch;
	}
	// 82393778: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 8239377C: 806ABC30  lwz r3, -0x43d0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17360 as u32) ) } as u64;
	// 82393780: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82393784: 914BBFC4  stw r10, -0x403c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16444 as u32), ctx.r[10].u32 ) };
	// 82393788: 4802DD99  bl 0x823c1520
	ctx.lr = 0x8239378C;
	sub_823C1520(ctx, base);
	// 8239378C: 4BFFFFAC  b 0x82393738
	pc = 0x82393738; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82393790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82393790 size=432
    let mut pc: u32 = 0x82393790;
    'dispatch: loop {
        match pc {
            0x82393790 => {
    //   block [0x82393790..0x823937D4)
	// 82393790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82393794: 481A191D  bl 0x825350b0
	ctx.lr = 0x82393798;
	sub_82535080(ctx, base);
	// 82393798: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8239379C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 823937A0: 3860FFFE  li r3, -2
	ctx.r[3].s64 = -2;
	// 823937A4: 4802E425  bl 0x823c1bc8
	ctx.lr = 0x823937A8;
	sub_823C1BC8(ctx, base);
	// 823937A8: 3F4082C0  lis r26, -0x7d40
	ctx.r[26].s64 = -2101346304;
	// 823937AC: 817ABFC0  lwz r11, -0x4040(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-16448 as u32) ) } as u64;
	// 823937B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823937B4: 419A0180  beq cr6, 0x82393934
	if ctx.cr[6].eq {
	pc = 0x82393934; continue 'dispatch;
	}
	// 823937B8: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823937BC: 3F6082B6  lis r27, -0x7d4a
	ctx.r[27].s64 = -2102001664;
	// 823937C0: 3BEBBA20  addi r31, r11, -0x45e0
	ctx.r[31].s64 = ctx.r[11].s64 + -17888;
	// 823937C4: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823937C8: 3F8082C0  lis r28, -0x7d40
	ctx.r[28].s64 = -2101346304;
	// 823937CC: 3BABBBB0  addi r29, r11, -0x4450
	ctx.r[29].s64 = ctx.r[11].s64 + -17488;
	// 823937D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x823937D4; continue 'dispatch;
            }
            0x823937D4 => {
    //   block [0x823937D4..0x8239382C)
	// 823937D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823937D8: 48379A85  bl 0x8270d25c
	ctx.lr = 0x823937DC;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823937DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823937E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823937E4: 419A0128  beq cr6, 0x8239390c
	if ctx.cr[6].eq {
	pc = 0x8239390C; continue 'dispatch;
	}
	// 823937E8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823937EC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823937F0: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823937F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823937F8: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823937FC: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82393800: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82393804: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82393808: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 8239380C: 90CA000C  stw r6, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 82393810: 419A0058  beq cr6, 0x82393868
	if ctx.cr[6].eq {
	pc = 0x82393868; continue 'dispatch;
	}
	// 82393814: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82393818: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8239381C: 41820010  beq 0x8239382c
	if ctx.cr[0].eq {
	pc = 0x8239382C; continue 'dispatch;
	}
	// 82393820: 93CA0010  stw r30, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82393824: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82393828: 4800000C  b 0x82393834
	pc = 0x82393834; continue 'dispatch;
            }
            0x8239382C => {
    //   block [0x8239382C..0x82393834)
	// 8239382C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82393830: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x82393834; continue 'dispatch;
            }
            0x82393834 => {
    //   block [0x82393834..0x82393858)
	// 82393834: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82393838: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8239383C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82393840: 419A0018  beq cr6, 0x82393858
	if ctx.cr[6].eq {
	pc = 0x82393858; continue 'dispatch;
	}
	// 82393844: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82393848: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8239384C: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82393850: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82393854: 48000010  b 0x82393864
	pc = 0x82393864; continue 'dispatch;
            }
            0x82393858 => {
    //   block [0x82393858..0x82393864)
	// 82393858: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8239385C: 93CB0014  stw r30, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82393860: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82393864; continue 'dispatch;
            }
            0x82393864 => {
    //   block [0x82393864..0x82393868)
	// 82393864: 93CB0010  stw r30, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	pc = 0x82393868; continue 'dispatch;
            }
            0x82393868 => {
    //   block [0x82393868..0x823938AC)
	// 82393868: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8239386C: 48379A01  bl 0x8270d26c
	ctx.lr = 0x82393870;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82393870: A1610052  lhz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82393874: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82393878: 4198007C  blt cr6, 0x823938f4
	if ctx.cr[6].lt {
	pc = 0x823938F4; continue 'dispatch;
	}
	// 8239387C: 419A0060  beq cr6, 0x823938dc
	if ctx.cr[6].eq {
	pc = 0x823938DC; continue 'dispatch;
	}
	// 82393880: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82393884: 41980040  blt cr6, 0x823938c4
	if ctx.cr[6].lt {
	pc = 0x823938C4; continue 'dispatch;
	}
	// 82393888: 419A0024  beq cr6, 0x823938ac
	if ctx.cr[6].eq {
	pc = 0x823938AC; continue 'dispatch;
	}
	// 8239388C: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82393890: 40980098  bge cr6, 0x82393928
	if !ctx.cr[6].lt {
	pc = 0x82393928; continue 'dispatch;
	}
	// 82393894: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82393898: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8239389C: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823938A0: A0610050  lhz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823938A4: 4800071D  bl 0x82393fc0
	ctx.lr = 0x823938A8;
	sub_82393FC0(ctx, base);
	// 823938A8: 48000080  b 0x82393928
	pc = 0x82393928; continue 'dispatch;
            }
            0x823938AC => {
    //   block [0x823938AC..0x823938C4)
	// 823938AC: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 823938B0: C0210058  lfs f1, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823938B4: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823938B8: A0610050  lhz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823938BC: 4800050D  bl 0x82393dc8
	ctx.lr = 0x823938C0;
	sub_82393DC8(ctx, base);
	// 823938C0: 48000068  b 0x82393928
	pc = 0x82393928; continue 'dispatch;
            }
            0x823938C4 => {
    //   block [0x823938C4..0x823938DC)
	// 823938C4: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 823938C8: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823938CC: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823938D0: A0610050  lhz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823938D4: 48000355  bl 0x82393c28
	ctx.lr = 0x823938D8;
	sub_82393C28(ctx, base);
	// 823938D8: 48000050  b 0x82393928
	pc = 0x82393928; continue 'dispatch;
            }
            0x823938DC => {
    //   block [0x823938DC..0x823938F4)
	// 823938DC: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 823938E0: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823938E4: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823938E8: A0610050  lhz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823938EC: 48000185  bl 0x82393a70
	ctx.lr = 0x823938F0;
	sub_82393A70(ctx, base);
	// 823938F0: 48000038  b 0x82393928
	pc = 0x82393928; continue 'dispatch;
            }
            0x823938F4 => {
    //   block [0x823938F4..0x8239390C)
	// 823938F4: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 823938F8: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823938FC: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82393900: A0610050  lhz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82393904: 4800003D  bl 0x82393940
	ctx.lr = 0x82393908;
	sub_82393940(ctx, base);
	// 82393908: 48000020  b 0x82393928
	pc = 0x82393928; continue 'dispatch;
            }
            0x8239390C => {
    //   block [0x8239390C..0x82393928)
	// 8239390C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82393910: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82393914: 917CBFC4  stw r11, -0x403c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-16444 as u32), ctx.r[11].u32 ) };
	// 82393918: 48379955  bl 0x8270d26c
	ctx.lr = 0x8239391C;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 8239391C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 82393920: 807BBC30  lwz r3, -0x43d0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17360 as u32) ) } as u64;
	// 82393924: 4802DBF5  bl 0x823c1518
	ctx.lr = 0x82393928;
	sub_823C1518(ctx, base);
	pc = 0x82393928; continue 'dispatch;
            }
            0x82393928 => {
    //   block [0x82393928..0x82393934)
	// 82393928: 817ABFC0  lwz r11, -0x4040(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-16448 as u32) ) } as u64;
	// 8239392C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82393930: 409AFEA4  bne cr6, 0x823937d4
	if !ctx.cr[6].eq {
	pc = 0x823937D4; continue 'dispatch;
	}
	pc = 0x82393934; continue 'dispatch;
            }
            0x82393934 => {
    //   block [0x82393934..0x82393940)
	// 82393934: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82393938: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8239393C: 481A17C4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82393940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82393940 size=300
    let mut pc: u32 = 0x82393940;
    'dispatch: loop {
        match pc {
            0x82393940 => {
    //   block [0x82393940..0x8239397C)
	// 82393940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82393944: 481A1761  bl 0x825350a4
	ctx.lr = 0x82393948;
	sub_82535080(ctx, base);
	// 82393948: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8239394C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82393950: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82393954: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82393958: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 8239395C: 48007035  bl 0x8239a990
	ctx.lr = 0x82393960;
	sub_8239A990(ctx, base);
	// 82393960: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82393964: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82393968: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 8239396C: 3BAB86B8  addi r29, r11, -0x7948
	ctx.r[29].s64 = ctx.r[11].s64 + -31048;
	// 82393970: 4198000C  blt cr6, 0x8239397c
	if ctx.cr[6].lt {
	pc = 0x8239397C; continue 'dispatch;
	}
	// 82393974: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	// 82393978: 48000010  b 0x82393988
	pc = 0x82393988; continue 'dispatch;
            }
            0x8239397C => {
    //   block [0x8239397C..0x82393988)
	// 8239397C: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393980: 395D000C  addi r10, r29, 0xc
	ctx.r[10].s64 = ctx.r[29].s64 + 12;
	// 82393984: 7F6B502E  lwzx r27, r11, r10
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	pc = 0x82393988; continue 'dispatch;
            }
            0x82393988 => {
    //   block [0x82393988..0x8239399C)
	// 82393988: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8239398C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82393990: 419A0050  beq cr6, 0x823939e0
	if ctx.cr[6].eq {
	pc = 0x823939E0; continue 'dispatch;
	}
	// 82393994: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82393998: 3B8B0A00  addi r28, r11, 0xa00
	ctx.r[28].s64 = ctx.r[11].s64 + 2560;
	pc = 0x8239399C; continue 'dispatch;
            }
            0x8239399C => {
    //   block [0x8239399C..0x823939B4)
	// 8239399C: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 823939A0: 40980014  bge cr6, 0x823939b4
	if !ctx.cr[6].lt {
	pc = 0x823939B4; continue 'dispatch;
	}
	// 823939A4: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823939A8: 7D6BE8AE  lbzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 823939AC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 823939B0: 419A0030  beq cr6, 0x823939e0
	if ctx.cr[6].eq {
	pc = 0x823939E0; continue 'dispatch;
	}
	pc = 0x823939B4; continue 'dispatch;
            }
            0x823939B4 => {
    //   block [0x823939B4..0x823939E0)
	// 823939B4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 823939B8: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 823939BC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 823939C0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 823939C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823939C8: 4800B269  bl 0x8239ec30
	ctx.lr = 0x823939CC;
	sub_8239EC30(ctx, base);
	// 823939CC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823939D0: 41800048  blt 0x82393a18
	if ctx.cr[0].lt {
	pc = 0x82393A18; continue 'dispatch;
	}
	// 823939D4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823939D8: 7F1EC040  cmplw cr6, r30, r24
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[24].u32, &mut ctx.xer);
	// 823939DC: 4198FFC0  blt cr6, 0x8239399c
	if ctx.cr[6].lt {
	pc = 0x8239399C; continue 'dispatch;
	}
	pc = 0x823939E0; continue 'dispatch;
            }
            0x823939E0 => {
    //   block [0x823939E0..0x82393A08)
	// 823939E0: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823939E4: 3BCBBBB0  addi r30, r11, -0x4450
	ctx.r[30].s64 = ctx.r[11].s64 + -17488;
	// 823939E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823939EC: 48379871  bl 0x8270d25c
	ctx.lr = 0x823939F0;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823939F0: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 823939F4: 40980068  bge cr6, 0x82393a5c
	if !ctx.cr[6].lt {
	pc = 0x82393A5C; continue 'dispatch;
	}
	// 823939F8: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823939FC: 7D6BE8AE  lbzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82393A00: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82393A04: 409A0028  bne cr6, 0x82393a2c
	if !ctx.cr[6].eq {
	pc = 0x82393A2C; continue 'dispatch;
	}
	pc = 0x82393A08; continue 'dispatch;
            }
            0x82393A08 => {
    //   block [0x82393A08..0x82393A18)
	// 82393A08: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82393A0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82393A10: 4BFFF7E9  bl 0x823931f8
	ctx.lr = 0x82393A14;
	sub_823931F8(ctx, base);
	// 82393A14: 48000048  b 0x82393a5c
	pc = 0x82393A5C; continue 'dispatch;
            }
            0x82393A18 => {
    //   block [0x82393A18..0x82393A2C)
	// 82393A18: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82393A1C: 3BCBBBB0  addi r30, r11, -0x4450
	ctx.r[30].s64 = ctx.r[11].s64 + -17488;
	// 82393A20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82393A24: 48379839  bl 0x8270d25c
	ctx.lr = 0x82393A28;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82393A28: 4BFFFFE0  b 0x82393a08
	pc = 0x82393A08; continue 'dispatch;
            }
            0x82393A2C => {
    //   block [0x82393A2C..0x82393A5C)
	// 82393A2C: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393A30: 4098002C  bge cr6, 0x82393a5c
	if !ctx.cr[6].lt {
	pc = 0x82393A5C; continue 'dispatch;
	}
	// 82393A34: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393A38: 7D4BE8AE  lbzx r10, r11, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82393A3C: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 82393A40: 409A001C  bne cr6, 0x82393a5c
	if !ctx.cr[6].eq {
	pc = 0x82393A5C; continue 'dispatch;
	}
	// 82393A44: 395D0008  addi r10, r29, 8
	ctx.r[10].s64 = ctx.r[29].s64 + 8;
	// 82393A48: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82393A4C: 7F0AB840  cmplw cr6, r10, r23
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82393A50: 409A000C  bne cr6, 0x82393a5c
	if !ctx.cr[6].eq {
	pc = 0x82393A5C; continue 'dispatch;
	}
	// 82393A54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82393A58: 7D4BE9AE  stbx r10, r11, r29
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[10].u8) };
	pc = 0x82393A5C; continue 'dispatch;
            }
            0x82393A5C => {
    //   block [0x82393A5C..0x82393A6C)
	// 82393A5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82393A60: 4837980D  bl 0x8270d26c
	ctx.lr = 0x82393A64;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82393A64: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82393A68: 481A168C  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82393A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82393A70 size=436
    let mut pc: u32 = 0x82393A70;
    'dispatch: loop {
        match pc {
            0x82393A70 => {
    //   block [0x82393A70..0x82393AB0)
	// 82393A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82393A74: 481A1625  bl 0x82535098
	ctx.lr = 0x82393A78;
	sub_82535080(ctx, base);
	// 82393A78: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82393A7C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82393A80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82393A84: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 82393A88: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82393A8C: 82BC0000  lwz r21, 0(r28)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82393A90: 48006F01  bl 0x8239a990
	ctx.lr = 0x82393A94;
	sub_8239A990(ctx, base);
	// 82393A94: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82393A98: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82393A9C: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393AA0: 3AEB86B8  addi r23, r11, -0x7948
	ctx.r[23].s64 = ctx.r[11].s64 + -31048;
	// 82393AA4: 4198000C  blt cr6, 0x82393ab0
	if ctx.cr[6].lt {
	pc = 0x82393AB0; continue 'dispatch;
	}
	// 82393AA8: 3B00FFFF  li r24, -1
	ctx.r[24].s64 = -1;
	// 82393AAC: 48000010  b 0x82393abc
	pc = 0x82393ABC; continue 'dispatch;
            }
            0x82393AB0 => {
    //   block [0x82393AB0..0x82393ABC)
	// 82393AB0: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393AB4: 3957000C  addi r10, r23, 0xc
	ctx.r[10].s64 = ctx.r[23].s64 + 12;
	// 82393AB8: 7F0B502E  lwzx r24, r11, r10
	ctx.r[24].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	pc = 0x82393ABC; continue 'dispatch;
            }
            0x82393ABC => {
    //   block [0x82393ABC..0x82393AE8)
	// 82393ABC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82393AC0: 3BBC000C  addi r29, r28, 0xc
	ctx.r[29].s64 = ctx.r[28].s64 + 12;
	// 82393AC4: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82393AC8: 7D4B5051  subf. r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82393ACC: 41820060  beq 0x82393b2c
	if ctx.cr[0].eq {
	pc = 0x82393B2C; continue 'dispatch;
	}
	// 82393AD0: 7F6BE214  add r27, r11, r28
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82393AD4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82393AD8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82393ADC: 419A0050  beq cr6, 0x82393b2c
	if ctx.cr[6].eq {
	pc = 0x82393B2C; continue 'dispatch;
	}
	// 82393AE0: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82393AE4: 3B4B0A00  addi r26, r11, 0xa00
	ctx.r[26].s64 = ctx.r[11].s64 + 2560;
	pc = 0x82393AE8; continue 'dispatch;
            }
            0x82393AE8 => {
    //   block [0x82393AE8..0x82393B00)
	// 82393AE8: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393AEC: 40980014  bge cr6, 0x82393b00
	if !ctx.cr[6].lt {
	pc = 0x82393B00; continue 'dispatch;
	}
	// 82393AF0: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393AF4: 7D6BB8AE  lbzx r11, r11, r23
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82393AF8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82393AFC: 419A0030  beq cr6, 0x82393b2c
	if ctx.cr[6].eq {
	pc = 0x82393B2C; continue 'dispatch;
	}
	pc = 0x82393B00; continue 'dispatch;
            }
            0x82393B00 => {
    //   block [0x82393B00..0x82393B2C)
	// 82393B00: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82393B04: 56C6062C  rlwinm r6, r22, 0, 0x18, 0x16
	ctx.r[6].u64 = ctx.r[22].u32 as u64 & 0xFFFFFFFFu64;
	// 82393B08: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82393B0C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82393B10: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82393B14: 4800B11D  bl 0x8239ec30
	ctx.lr = 0x82393B18;
	sub_8239EC30(ctx, base);
	// 82393B18: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82393B1C: 418000B4  blt 0x82393bd0
	if ctx.cr[0].lt {
	pc = 0x82393BD0; continue 'dispatch;
	}
	// 82393B20: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82393B24: 7F1EC840  cmplw cr6, r30, r25
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82393B28: 4198FFC0  blt cr6, 0x82393ae8
	if ctx.cr[6].lt {
	pc = 0x82393AE8; continue 'dispatch;
	}
	pc = 0x82393B2C; continue 'dispatch;
            }
            0x82393B2C => {
    //   block [0x82393B2C..0x82393B3C)
	// 82393B2C: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82393B30: 2B150003  cmplwi cr6, r21, 3
	ctx.cr[6].compare_u32(ctx.r[21].u32, 3 as u32, &mut ctx.xer);
	// 82393B34: 41980064  blt cr6, 0x82393b98
	if ctx.cr[6].lt {
	pc = 0x82393B98; continue 'dispatch;
	}
	// 82393B38: 3B78FFFD  addi r27, r24, -3
	ctx.r[27].s64 = ctx.r[24].s64 + -3;
	pc = 0x82393B3C; continue 'dispatch;
            }
            0x82393B3C => {
    //   block [0x82393B3C..0x82393B64)
	// 82393B3C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82393B40: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82393B44: 7D6A5851  subf. r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82393B48: 41820040  beq 0x82393b88
	if ctx.cr[0].eq {
	pc = 0x82393B88; continue 'dispatch;
	}
	// 82393B4C: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393B50: 40980014  bge cr6, 0x82393b64
	if !ctx.cr[6].lt {
	pc = 0x82393B64; continue 'dispatch;
	}
	// 82393B54: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393B58: 7D6BB8AE  lbzx r11, r11, r23
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82393B5C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82393B60: 419A0038  beq cr6, 0x82393b98
	if ctx.cr[6].eq {
	pc = 0x82393B98; continue 'dispatch;
	}
	pc = 0x82393B64; continue 'dispatch;
            }
            0x82393B64 => {
    //   block [0x82393B64..0x82393B88)
	// 82393B64: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82393B68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82393B6C: 7C9BF214  add r4, r27, r30
	ctx.r[4].u64 = ctx.r[27].u64 + ctx.r[30].u64;
	// 82393B70: 516507FE  rlwimi r5, r11, 0, 0x1f, 0x1f
	ctx.r[5].u64 = (((ctx.r[11].u32).rotate_left(0) as u64) & 0x0000000000000001) | (ctx.r[5].u64 & 0xFFFFFFFFFFFFFFFE);
	// 82393B74: 7C6AE214  add r3, r10, r28
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82393B78: 51650672  rlwimi r5, r11, 0, 0x19, 0x19
	ctx.r[5].u64 = (((ctx.r[11].u32).rotate_left(0) as u64) & 0x0000000000000040) | (ctx.r[5].u64 & 0xFFFFFFFFFFFFFFBF);
	// 82393B7C: 4800869D  bl 0x8239c218
	ctx.lr = 0x82393B80;
	sub_8239C218(ctx, base);
	// 82393B80: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82393B84: 4180004C  blt 0x82393bd0
	if ctx.cr[0].lt {
	pc = 0x82393BD0; continue 'dispatch;
	}
	pc = 0x82393B88; continue 'dispatch;
            }
            0x82393B88 => {
    //   block [0x82393B88..0x82393B98)
	// 82393B88: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82393B8C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82393B90: 7F1EA840  cmplw cr6, r30, r21
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82393B94: 4099FFA8  ble cr6, 0x82393b3c
	if !ctx.cr[6].gt {
	pc = 0x82393B3C; continue 'dispatch;
	}
	pc = 0x82393B98; continue 'dispatch;
            }
            0x82393B98 => {
    //   block [0x82393B98..0x82393BC0)
	// 82393B98: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82393B9C: 3BCBBBB0  addi r30, r11, -0x4450
	ctx.r[30].s64 = ctx.r[11].s64 + -17488;
	// 82393BA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82393BA4: 483796B9  bl 0x8270d25c
	ctx.lr = 0x82393BA8;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82393BA8: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393BAC: 40980068  bge cr6, 0x82393c14
	if !ctx.cr[6].lt {
	pc = 0x82393C14; continue 'dispatch;
	}
	// 82393BB0: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393BB4: 7D6BB8AE  lbzx r11, r11, r23
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82393BB8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82393BBC: 409A0028  bne cr6, 0x82393be4
	if !ctx.cr[6].eq {
	pc = 0x82393BE4; continue 'dispatch;
	}
	pc = 0x82393BC0; continue 'dispatch;
            }
            0x82393BC0 => {
    //   block [0x82393BC0..0x82393BD0)
	// 82393BC0: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82393BC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82393BC8: 4BFFF631  bl 0x823931f8
	ctx.lr = 0x82393BCC;
	sub_823931F8(ctx, base);
	// 82393BCC: 48000048  b 0x82393c14
	pc = 0x82393C14; continue 'dispatch;
            }
            0x82393BD0 => {
    //   block [0x82393BD0..0x82393BE4)
	// 82393BD0: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82393BD4: 3BCBBBB0  addi r30, r11, -0x4450
	ctx.r[30].s64 = ctx.r[11].s64 + -17488;
	// 82393BD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82393BDC: 48379681  bl 0x8270d25c
	ctx.lr = 0x82393BE0;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82393BE0: 4BFFFFE0  b 0x82393bc0
	pc = 0x82393BC0; continue 'dispatch;
            }
            0x82393BE4 => {
    //   block [0x82393BE4..0x82393C14)
	// 82393BE4: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393BE8: 4098002C  bge cr6, 0x82393c14
	if !ctx.cr[6].lt {
	pc = 0x82393C14; continue 'dispatch;
	}
	// 82393BEC: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393BF0: 7D4BB8AE  lbzx r10, r11, r23
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82393BF4: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 82393BF8: 409A001C  bne cr6, 0x82393c14
	if !ctx.cr[6].eq {
	pc = 0x82393C14; continue 'dispatch;
	}
	// 82393BFC: 39570008  addi r10, r23, 8
	ctx.r[10].s64 = ctx.r[23].s64 + 8;
	// 82393C00: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82393C04: 7F0AA040  cmplw cr6, r10, r20
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[20].u32, &mut ctx.xer);
	// 82393C08: 409A000C  bne cr6, 0x82393c14
	if !ctx.cr[6].eq {
	pc = 0x82393C14; continue 'dispatch;
	}
	// 82393C0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82393C10: 7D4BB9AE  stbx r10, r11, r23
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32), ctx.r[10].u8) };
	pc = 0x82393C14; continue 'dispatch;
            }
            0x82393C14 => {
    //   block [0x82393C14..0x82393C24)
	// 82393C14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82393C18: 48379655  bl 0x8270d26c
	ctx.lr = 0x82393C1C;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82393C1C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82393C20: 481A14C8  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82393C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82393C28 size=412
    let mut pc: u32 = 0x82393C28;
    'dispatch: loop {
        match pc {
            0x82393C28 => {
    //   block [0x82393C28..0x82393C68)
	// 82393C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82393C2C: 481A1475  bl 0x825350a0
	ctx.lr = 0x82393C30;
	sub_82535080(ctx, base);
	// 82393C30: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82393C34: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82393C38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82393C3C: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82393C40: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82393C44: 82F80000  lwz r23, 0(r24)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82393C48: 48006D49  bl 0x8239a990
	ctx.lr = 0x82393C4C;
	sub_8239A990(ctx, base);
	// 82393C4C: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82393C50: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82393C54: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393C58: 3B2B86B8  addi r25, r11, -0x7948
	ctx.r[25].s64 = ctx.r[11].s64 + -31048;
	// 82393C5C: 4198000C  blt cr6, 0x82393c68
	if ctx.cr[6].lt {
	pc = 0x82393C68; continue 'dispatch;
	}
	// 82393C60: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 82393C64: 48000010  b 0x82393c74
	pc = 0x82393C74; continue 'dispatch;
            }
            0x82393C68 => {
    //   block [0x82393C68..0x82393C74)
	// 82393C68: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393C6C: 3959000C  addi r10, r25, 0xc
	ctx.r[10].s64 = ctx.r[25].s64 + 12;
	// 82393C70: 7F8B502E  lwzx r28, r11, r10
	ctx.r[28].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	pc = 0x82393C74; continue 'dispatch;
            }
            0x82393C74 => {
    //   block [0x82393C74..0x82393C90)
	// 82393C74: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82393C78: 419A005C  beq cr6, 0x82393cd4
	if ctx.cr[6].eq {
	pc = 0x82393CD4; continue 'dispatch;
	}
	// 82393C7C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82393C80: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82393C84: 419A0050  beq cr6, 0x82393cd4
	if ctx.cr[6].eq {
	pc = 0x82393CD4; continue 'dispatch;
	}
	// 82393C88: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82393C8C: 3BAB0A00  addi r29, r11, 0xa00
	ctx.r[29].s64 = ctx.r[11].s64 + 2560;
	pc = 0x82393C90; continue 'dispatch;
            }
            0x82393C90 => {
    //   block [0x82393C90..0x82393CA8)
	// 82393C90: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393C94: 40980014  bge cr6, 0x82393ca8
	if !ctx.cr[6].lt {
	pc = 0x82393CA8; continue 'dispatch;
	}
	// 82393C98: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393C9C: 7D6BC8AE  lbzx r11, r11, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 82393CA0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82393CA4: 419A0030  beq cr6, 0x82393cd4
	if ctx.cr[6].eq {
	pc = 0x82393CD4; continue 'dispatch;
	}
	pc = 0x82393CA8; continue 'dispatch;
            }
            0x82393CA8 => {
    //   block [0x82393CA8..0x82393CD4)
	// 82393CA8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82393CAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82393CB0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82393CB4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82393CB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82393CBC: 4800AF75  bl 0x8239ec30
	ctx.lr = 0x82393CC0;
	sub_8239EC30(ctx, base);
	// 82393CC0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82393CC4: 418000AC  blt 0x82393d70
	if ctx.cr[0].lt {
	pc = 0x82393D70; continue 'dispatch;
	}
	// 82393CC8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82393CCC: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82393CD0: 4198FFC0  blt cr6, 0x82393c90
	if ctx.cr[6].lt {
	pc = 0x82393C90; continue 'dispatch;
	}
	pc = 0x82393CD4; continue 'dispatch;
            }
            0x82393CD4 => {
    //   block [0x82393CD4..0x82393CE8)
	// 82393CD4: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 82393CD8: 2B170003  cmplwi cr6, r23, 3
	ctx.cr[6].compare_u32(ctx.r[23].u32, 3 as u32, &mut ctx.xer);
	// 82393CDC: 4198005C  blt cr6, 0x82393d38
	if ctx.cr[6].lt {
	pc = 0x82393D38; continue 'dispatch;
	}
	// 82393CE0: 3BD8000C  addi r30, r24, 0xc
	ctx.r[30].s64 = ctx.r[24].s64 + 12;
	// 82393CE4: 3B9CFFFD  addi r28, r28, -3
	ctx.r[28].s64 = ctx.r[28].s64 + -3;
	pc = 0x82393CE8; continue 'dispatch;
            }
            0x82393CE8 => {
    //   block [0x82393CE8..0x82393D10)
	// 82393CE8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82393CEC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82393CF0: 7D6A5851  subf. r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82393CF4: 41820034  beq 0x82393d28
	if ctx.cr[0].eq {
	pc = 0x82393D28; continue 'dispatch;
	}
	// 82393CF8: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393CFC: 40980014  bge cr6, 0x82393d10
	if !ctx.cr[6].lt {
	pc = 0x82393D10; continue 'dispatch;
	}
	// 82393D00: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393D04: 7D6BC8AE  lbzx r11, r11, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 82393D08: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82393D0C: 419A002C  beq cr6, 0x82393d38
	if ctx.cr[6].eq {
	pc = 0x82393D38; continue 'dispatch;
	}
	pc = 0x82393D10; continue 'dispatch;
            }
            0x82393D10 => {
    //   block [0x82393D10..0x82393D28)
	// 82393D10: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82393D14: 7C9CEA14  add r4, r28, r29
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[29].u64;
	// 82393D18: 7C6AC214  add r3, r10, r24
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[24].u64;
	// 82393D1C: 480084FD  bl 0x8239c218
	ctx.lr = 0x82393D20;
	sub_8239C218(ctx, base);
	// 82393D20: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82393D24: 4180004C  blt 0x82393d70
	if ctx.cr[0].lt {
	pc = 0x82393D70; continue 'dispatch;
	}
	pc = 0x82393D28; continue 'dispatch;
            }
            0x82393D28 => {
    //   block [0x82393D28..0x82393D38)
	// 82393D28: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82393D2C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82393D30: 7F1DB840  cmplw cr6, r29, r23
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82393D34: 4099FFB4  ble cr6, 0x82393ce8
	if !ctx.cr[6].gt {
	pc = 0x82393CE8; continue 'dispatch;
	}
	pc = 0x82393D38; continue 'dispatch;
            }
            0x82393D38 => {
    //   block [0x82393D38..0x82393D60)
	// 82393D38: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82393D3C: 3BCBBBB0  addi r30, r11, -0x4450
	ctx.r[30].s64 = ctx.r[11].s64 + -17488;
	// 82393D40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82393D44: 48379519  bl 0x8270d25c
	ctx.lr = 0x82393D48;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82393D48: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393D4C: 40980068  bge cr6, 0x82393db4
	if !ctx.cr[6].lt {
	pc = 0x82393DB4; continue 'dispatch;
	}
	// 82393D50: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393D54: 7D6BC8AE  lbzx r11, r11, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 82393D58: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82393D5C: 409A0028  bne cr6, 0x82393d84
	if !ctx.cr[6].eq {
	pc = 0x82393D84; continue 'dispatch;
	}
	pc = 0x82393D60; continue 'dispatch;
            }
            0x82393D60 => {
    //   block [0x82393D60..0x82393D70)
	// 82393D60: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82393D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82393D68: 4BFFF491  bl 0x823931f8
	ctx.lr = 0x82393D6C;
	sub_823931F8(ctx, base);
	// 82393D6C: 48000048  b 0x82393db4
	pc = 0x82393DB4; continue 'dispatch;
            }
            0x82393D70 => {
    //   block [0x82393D70..0x82393D84)
	// 82393D70: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82393D74: 3BCBBBB0  addi r30, r11, -0x4450
	ctx.r[30].s64 = ctx.r[11].s64 + -17488;
	// 82393D78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82393D7C: 483794E1  bl 0x8270d25c
	ctx.lr = 0x82393D80;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82393D80: 4BFFFFE0  b 0x82393d60
	pc = 0x82393D60; continue 'dispatch;
            }
            0x82393D84 => {
    //   block [0x82393D84..0x82393DB4)
	// 82393D84: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393D88: 4098002C  bge cr6, 0x82393db4
	if !ctx.cr[6].lt {
	pc = 0x82393DB4; continue 'dispatch;
	}
	// 82393D8C: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393D90: 7D4BC8AE  lbzx r10, r11, r25
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 82393D94: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 82393D98: 409A001C  bne cr6, 0x82393db4
	if !ctx.cr[6].eq {
	pc = 0x82393DB4; continue 'dispatch;
	}
	// 82393D9C: 39590008  addi r10, r25, 8
	ctx.r[10].s64 = ctx.r[25].s64 + 8;
	// 82393DA0: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82393DA4: 7F0AB040  cmplw cr6, r10, r22
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82393DA8: 409A000C  bne cr6, 0x82393db4
	if !ctx.cr[6].eq {
	pc = 0x82393DB4; continue 'dispatch;
	}
	// 82393DAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82393DB0: 7D4BC9AE  stbx r10, r11, r25
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32), ctx.r[10].u8) };
	pc = 0x82393DB4; continue 'dispatch;
            }
            0x82393DB4 => {
    //   block [0x82393DB4..0x82393DC4)
	// 82393DB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82393DB8: 483794B5  bl 0x8270d26c
	ctx.lr = 0x82393DBC;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82393DBC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82393DC0: 481A1330  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82393DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82393DC8 size=500
    let mut pc: u32 = 0x82393DC8;
    'dispatch: loop {
        match pc {
            0x82393DC8 => {
    //   block [0x82393DC8..0x82393E14)
	// 82393DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82393DCC: 481A12D1  bl 0x8253509c
	ctx.lr = 0x82393DD0;
	sub_82535080(ctx, base);
	// 82393DD0: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 82393DD4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82393DD8: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82393DDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82393DE0: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82393DE4: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 82393DE8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82393DEC: 7F8A3214  add r28, r10, r6
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 82393DF0: 7EEB3214  add r23, r11, r6
	ctx.r[23].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 82393DF4: 48006B9D  bl 0x8239a990
	ctx.lr = 0x82393DF8;
	sub_8239A990(ctx, base);
	// 82393DF8: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82393DFC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82393E00: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393E04: 3ACB86B8  addi r22, r11, -0x7948
	ctx.r[22].s64 = ctx.r[11].s64 + -31048;
	// 82393E08: 4198000C  blt cr6, 0x82393e14
	if ctx.cr[6].lt {
	pc = 0x82393E14; continue 'dispatch;
	}
	// 82393E0C: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 82393E10: 48000010  b 0x82393e20
	pc = 0x82393E20; continue 'dispatch;
            }
            0x82393E14 => {
    //   block [0x82393E14..0x82393E20)
	// 82393E14: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393E18: 3956000C  addi r10, r22, 0xc
	ctx.r[10].s64 = ctx.r[22].s64 + 12;
	// 82393E1C: 7F2B502E  lwzx r25, r11, r10
	ctx.r[25].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	pc = 0x82393E20; continue 'dispatch;
            }
            0x82393E20 => {
    //   block [0x82393E20..0x82393E3C)
	// 82393E20: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82393E24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82393E28: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82393E2C: 7F6BE214  add r27, r11, r28
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82393E30: 419A0050  beq cr6, 0x82393e80
	if ctx.cr[6].eq {
	pc = 0x82393E80; continue 'dispatch;
	}
	// 82393E34: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82393E38: 3B4B0A00  addi r26, r11, 0xa00
	ctx.r[26].s64 = ctx.r[11].s64 + 2560;
	pc = 0x82393E3C; continue 'dispatch;
            }
            0x82393E3C => {
    //   block [0x82393E3C..0x82393E54)
	// 82393E3C: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393E40: 40980014  bge cr6, 0x82393e54
	if !ctx.cr[6].lt {
	pc = 0x82393E54; continue 'dispatch;
	}
	// 82393E44: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393E48: 7D6BB0AE  lbzx r11, r11, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82393E4C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82393E50: 419A0030  beq cr6, 0x82393e80
	if ctx.cr[6].eq {
	pc = 0x82393E80; continue 'dispatch;
	}
	pc = 0x82393E54; continue 'dispatch;
            }
            0x82393E54 => {
    //   block [0x82393E54..0x82393E80)
	// 82393E54: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82393E58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82393E5C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82393E60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82393E64: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82393E68: 4800ADC9  bl 0x8239ec30
	ctx.lr = 0x82393E6C;
	sub_8239EC30(ctx, base);
	// 82393E6C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82393E70: 418000F4  blt 0x82393f64
	if ctx.cr[0].lt {
	pc = 0x82393F64; continue 'dispatch;
	}
	// 82393E74: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82393E78: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82393E7C: 4198FFC0  blt cr6, 0x82393e3c
	if ctx.cr[6].lt {
	pc = 0x82393E3C; continue 'dispatch;
	}
	pc = 0x82393E80; continue 'dispatch;
            }
            0x82393E80 => {
    //   block [0x82393E80..0x82393E9C)
	// 82393E80: 831C0000  lwz r24, 0(r28)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82393E84: 3B400003  li r26, 3
	ctx.r[26].s64 = 3;
	// 82393E88: 2B180003  cmplwi cr6, r24, 3
	ctx.cr[6].compare_u32(ctx.r[24].u32, 3 as u32, &mut ctx.xer);
	// 82393E8C: 4198009C  blt cr6, 0x82393f28
	if ctx.cr[6].lt {
	pc = 0x82393F28; continue 'dispatch;
	}
	// 82393E90: 3BBC000C  addi r29, r28, 0xc
	ctx.r[29].s64 = ctx.r[28].s64 + 12;
	// 82393E94: 7F7CB850  subf r27, r28, r23
	ctx.r[27].s64 = ctx.r[23].s64 - ctx.r[28].s64;
	// 82393E98: 3B39FFFD  addi r25, r25, -3
	ctx.r[25].s64 = ctx.r[25].s64 + -3;
	pc = 0x82393E9C; continue 'dispatch;
            }
            0x82393E9C => {
    //   block [0x82393E9C..0x82393EB4)
	// 82393E9C: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393EA0: 40980014  bge cr6, 0x82393eb4
	if !ctx.cr[6].lt {
	pc = 0x82393EB4; continue 'dispatch;
	}
	// 82393EA4: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393EA8: 7D6BB0AE  lbzx r11, r11, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82393EAC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82393EB0: 419A0078  beq cr6, 0x82393f28
	if ctx.cr[6].eq {
	pc = 0x82393F28; continue 'dispatch;
	}
	pc = 0x82393EB4; continue 'dispatch;
            }
            0x82393EB4 => {
    //   block [0x82393EB4..0x82393F28)
	// 82393EB4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82393EB8: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82393EBC: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82393EC0: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82393EC4: 7CAA5850  subf r5, r10, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82393EC8: 48007131  bl 0x8239aff8
	ctx.lr = 0x82393ECC;
	sub_8239AFF8(ctx, base);
	// 82393ECC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82393ED0: 41820094  beq 0x82393f64
	if ctx.cr[0].eq {
	pc = 0x82393F64; continue 'dispatch;
	}
	// 82393ED4: 7D5BE82E  lwzx r10, r27, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82393ED8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82393EDC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82393EE0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82393EE4: 7CAABA14  add r5, r10, r23
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[23].u64;
	// 82393EE8: 7C9C5A14  add r4, r28, r11
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82393EEC: 480038FD  bl 0x823977e8
	ctx.lr = 0x82393EF0;
	sub_823977E8(ctx, base);
	// 82393EF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82393EF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82393EF8: 41820068  beq 0x82393f60
	if ctx.cr[0].eq {
	pc = 0x82393F60; continue 'dispatch;
	}
	// 82393EFC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82393F00: 7C99D214  add r4, r25, r26
	ctx.r[4].u64 = ctx.r[25].u64 + ctx.r[26].u64;
	// 82393F04: 48008315  bl 0x8239c218
	ctx.lr = 0x82393F08;
	sub_8239C218(ctx, base);
	// 82393F08: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82393F0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82393F10: 41800050  blt 0x82393f60
	if ctx.cr[0].lt {
	pc = 0x82393F60; continue 'dispatch;
	}
	// 82393F14: 4800718D  bl 0x8239b0a0
	ctx.lr = 0x82393F18;
	sub_8239B0A0(ctx, base);
	// 82393F18: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82393F1C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82393F20: 7F1AC040  cmplw cr6, r26, r24
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82393F24: 4099FF78  ble cr6, 0x82393e9c
	if !ctx.cr[6].gt {
	pc = 0x82393E9C; continue 'dispatch;
	}
	pc = 0x82393F28; continue 'dispatch;
            }
            0x82393F28 => {
    //   block [0x82393F28..0x82393F50)
	// 82393F28: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82393F2C: 3BCBBBB0  addi r30, r11, -0x4450
	ctx.r[30].s64 = ctx.r[11].s64 + -17488;
	// 82393F30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82393F34: 48379329  bl 0x8270d25c
	ctx.lr = 0x82393F38;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82393F38: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393F3C: 4098006C  bge cr6, 0x82393fa8
	if !ctx.cr[6].lt {
	pc = 0x82393FA8; continue 'dispatch;
	}
	// 82393F40: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393F44: 7D6BB0AE  lbzx r11, r11, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82393F48: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82393F4C: 409A002C  bne cr6, 0x82393f78
	if !ctx.cr[6].eq {
	pc = 0x82393F78; continue 'dispatch;
	}
	pc = 0x82393F50; continue 'dispatch;
            }
            0x82393F50 => {
    //   block [0x82393F50..0x82393F60)
	// 82393F50: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82393F54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82393F58: 4BFFF2A1  bl 0x823931f8
	ctx.lr = 0x82393F5C;
	sub_823931F8(ctx, base);
	// 82393F5C: 4800004C  b 0x82393fa8
	pc = 0x82393FA8; continue 'dispatch;
            }
            0x82393F60 => {
    //   block [0x82393F60..0x82393F64)
	// 82393F60: 48007141  bl 0x8239b0a0
	ctx.lr = 0x82393F64;
	sub_8239B0A0(ctx, base);
	pc = 0x82393F64; continue 'dispatch;
            }
            0x82393F64 => {
    //   block [0x82393F64..0x82393F78)
	// 82393F64: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82393F68: 3BCBBBB0  addi r30, r11, -0x4450
	ctx.r[30].s64 = ctx.r[11].s64 + -17488;
	// 82393F6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82393F70: 483792ED  bl 0x8270d25c
	ctx.lr = 0x82393F74;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82393F74: 4BFFFFDC  b 0x82393f50
	pc = 0x82393F50; continue 'dispatch;
            }
            0x82393F78 => {
    //   block [0x82393F78..0x82393FA8)
	// 82393F78: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82393F7C: 4098002C  bge cr6, 0x82393fa8
	if !ctx.cr[6].lt {
	pc = 0x82393FA8; continue 'dispatch;
	}
	// 82393F80: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82393F84: 7D4BB0AE  lbzx r10, r11, r22
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82393F88: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 82393F8C: 409A001C  bne cr6, 0x82393fa8
	if !ctx.cr[6].eq {
	pc = 0x82393FA8; continue 'dispatch;
	}
	// 82393F90: 39560008  addi r10, r22, 8
	ctx.r[10].s64 = ctx.r[22].s64 + 8;
	// 82393F94: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82393F98: 7F0AA840  cmplw cr6, r10, r21
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82393F9C: 409A000C  bne cr6, 0x82393fa8
	if !ctx.cr[6].eq {
	pc = 0x82393FA8; continue 'dispatch;
	}
	// 82393FA0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82393FA4: 7D4BB1AE  stbx r10, r11, r22
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32), ctx.r[10].u8) };
	pc = 0x82393FA8; continue 'dispatch;
            }
            0x82393FA8 => {
    //   block [0x82393FA8..0x82393FBC)
	// 82393FA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82393FAC: 483792C1  bl 0x8270d26c
	ctx.lr = 0x82393FB0;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82393FB0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82393FB4: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82393FB8: 481A1134  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82393FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82393FC0 size=308
    let mut pc: u32 = 0x82393FC0;
    'dispatch: loop {
        match pc {
            0x82393FC0 => {
    //   block [0x82393FC0..0x82394028)
	// 82393FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82393FC4: 481A10ED  bl 0x825350b0
	ctx.lr = 0x82393FC8;
	sub_82535080(ctx, base);
	// 82393FC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82393FCC: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82393FD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82393FD4: 396B0A00  addi r11, r11, 0xa00
	ctx.r[11].s64 = ctx.r[11].s64 + 2560;
	// 82393FD8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82393FDC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82393FE0: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82393FE4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82393FE8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82393FEC: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82393FF0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82393FF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82393FF8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82393FFC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82394000: 480072A1  bl 0x8239b2a0
	ctx.lr = 0x82394004;
	sub_8239B2A0(ctx, base);
	// 82394004: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82394008: 41800028  blt 0x82394030
	if ctx.cr[0].lt {
	pc = 0x82394030; continue 'dispatch;
	}
	// 8239400C: 2F030008  cmpwi cr6, r3, 8
	ctx.cr[6].compare_i32(ctx.r[3].s32, 8, &mut ctx.xer);
	// 82394010: 40980018  bge cr6, 0x82394028
	if !ctx.cr[6].lt {
	pc = 0x82394028; continue 'dispatch;
	}
	// 82394014: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82394018: 1D430078  mulli r10, r3, 0x78
	ctx.r[10].s32 = ((ctx.r[3].s32 as i64 * 120 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8239401C: 396BC630  addi r11, r11, -0x39d0
	ctx.r[11].s64 = ctx.r[11].s64 + -14800;
	// 82394020: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82394024: 48000008  b 0x8239402c
	pc = 0x8239402C; continue 'dispatch;
            }
            0x82394028 => {
    //   block [0x82394028..0x8239402C)
	// 82394028: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8239402C; continue 'dispatch;
            }
            0x8239402C => {
    //   block [0x8239402C..0x82394030)
	// 8239402C: 48007605  bl 0x8239b630
	ctx.lr = 0x82394030;
	sub_8239B630(ctx, base);
	pc = 0x82394030; continue 'dispatch;
            }
            0x82394030 => {
    //   block [0x82394030..0x8239408C)
	// 82394030: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 82394034: 3B4BBBB0  addi r26, r11, -0x4450
	ctx.r[26].s64 = ctx.r[11].s64 + -17488;
	// 82394038: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8239403C: 48379221  bl 0x8270d25c
	ctx.lr = 0x82394040;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82394040: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82394044: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 82394048: 3BCB86B8  addi r30, r11, -0x7948
	ctx.r[30].s64 = ctx.r[11].s64 + -31048;
	// 8239404C: 40980098  bge cr6, 0x823940e4
	if !ctx.cr[6].lt {
	pc = 0x823940E4; continue 'dispatch;
	}
	// 82394050: 1FBF0018  mulli r29, r31, 0x18
	ctx.r[29].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[29].s64 = ctx.r[29].s32 as i64;
	// 82394054: 7D7DF0AE  lbzx r11, r29, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82394058: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8239405C: 409A0058  bne cr6, 0x823940b4
	if !ctx.cr[6].eq {
	pc = 0x823940B4; continue 'dispatch;
	}
	// 82394060: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82394064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82394068: 480068D1  bl 0x8239a938
	ctx.lr = 0x8239406C;
	sub_8239A938(ctx, base);
	// 8239406C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82394070: 48006921  bl 0x8239a990
	ctx.lr = 0x82394074;
	sub_8239A990(ctx, base);
	// 82394074: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82394078: 40820014  bne 0x8239408c
	if !ctx.cr[0].eq {
	pc = 0x8239408C; continue 'dispatch;
	}
	// 8239407C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82394080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82394084: 4BFFF175  bl 0x823931f8
	ctx.lr = 0x82394088;
	sub_823931F8(ctx, base);
	// 82394088: 4800005C  b 0x823940e4
	pc = 0x823940E4; continue 'dispatch;
            }
            0x8239408C => {
    //   block [0x8239408C..0x823940B4)
	// 8239408C: 7D7DF0AE  lbzx r11, r29, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82394090: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82394094: 409A0050  bne cr6, 0x823940e4
	if !ctx.cr[6].eq {
	pc = 0x823940E4; continue 'dispatch;
	}
	// 82394098: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 8239409C: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823940A0: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 823940A4: 409A0040  bne cr6, 0x823940e4
	if !ctx.cr[6].eq {
	pc = 0x823940E4; continue 'dispatch;
	}
	// 823940A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823940AC: 7D7DF1AE  stbx r11, r29, r30
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u8) };
	// 823940B0: 48000034  b 0x823940e4
	pc = 0x823940E4; continue 'dispatch;
            }
            0x823940B4 => {
    //   block [0x823940B4..0x823940E4)
	// 823940B4: 2B1F01FF  cmplwi cr6, r31, 0x1ff
	ctx.cr[6].compare_u32(ctx.r[31].u32, 511 as u32, &mut ctx.xer);
	// 823940B8: 4098002C  bge cr6, 0x823940e4
	if !ctx.cr[6].lt {
	pc = 0x823940E4; continue 'dispatch;
	}
	// 823940BC: 1D7F0018  mulli r11, r31, 0x18
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823940C0: 7D4BF0AE  lbzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 823940C4: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 823940C8: 409A001C  bne cr6, 0x823940e4
	if !ctx.cr[6].eq {
	pc = 0x823940E4; continue 'dispatch;
	}
	// 823940CC: 395E0008  addi r10, r30, 8
	ctx.r[10].s64 = ctx.r[30].s64 + 8;
	// 823940D0: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823940D4: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 823940D8: 409A000C  bne cr6, 0x823940e4
	if !ctx.cr[6].eq {
	pc = 0x823940E4; continue 'dispatch;
	}
	// 823940DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823940E0: 7D4BF1AE  stbx r10, r11, r30
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[10].u8) };
	pc = 0x823940E4; continue 'dispatch;
            }
            0x823940E4 => {
    //   block [0x823940E4..0x823940F4)
	// 823940E4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823940E8: 48379185  bl 0x8270d26c
	ctx.lr = 0x823940EC;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823940EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823940F0: 481A1010  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823940F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823940F8 size=112
    let mut pc: u32 = 0x823940F8;
    'dispatch: loop {
        match pc {
            0x823940F8 => {
    //   block [0x823940F8..0x82394144)
	// 823940F8: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 823940FC: 396BBA20  addi r11, r11, -0x45e0
	ctx.r[11].s64 = ctx.r[11].s64 + -17888;
	// 82394100: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82394104: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82394108: 419A0060  beq cr6, 0x82394168
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82394168);
		return;
	}
	// 8239410C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82394110: 810A0014  lwz r8, 0x14(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82394114: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82394118: 419A002C  beq cr6, 0x82394144
	if ctx.cr[6].eq {
	pc = 0x82394144; continue 'dispatch;
	}
	// 8239411C: 91490014  stw r10, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82394120: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82394124: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82394128: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8239412C: 91490010  stw r10, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82394130: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82394134: 90EA0014  stw r7, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 82394138: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8239413C: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82394140: 48000020  b 0x82394160
	pc = 0x82394160; continue 'dispatch;
            }
            0x82394144 => {
    //   block [0x82394144..0x82394160)
	// 82394144: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82394148: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8239414C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82394150: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82394154: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82394158: 912A0014  stw r9, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8239415C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82394160; continue 'dispatch;
            }
            0x82394160 => {
    //   block [0x82394160..0x82394168)
	// 82394160: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82394164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82394170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82394170 size=92
    let mut pc: u32 = 0x82394170;
    'dispatch: loop {
        match pc {
            0x82394170 => {
    //   block [0x82394170..0x8239418C)
	// 82394170: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 82394174: 394BBA20  addi r10, r11, -0x45e0
	ctx.r[10].s64 = ctx.r[11].s64 + -17888;
	// 82394178: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8239417C: 7D0B4379  or. r11, r8, r8
	ctx.r[11].u64 = ctx.r[8].u64 | ctx.r[8].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82394180: 41820044  beq 0x823941c4
	if ctx.cr[0].eq {
	pc = 0x823941C4; continue 'dispatch;
	}
	// 82394184: A0E40000  lhz r7, 0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394188: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	pc = 0x8239418C; continue 'dispatch;
            }
            0x8239418C => {
    //   block [0x8239418C..0x823941AC)
	// 8239418C: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394190: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82394194: 409A0018  bne cr6, 0x823941ac
	if !ctx.cr[6].eq {
	pc = 0x823941AC; continue 'dispatch;
	}
	// 82394198: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8239419C: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 823941A0: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 823941A4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823941A8: 419A0008  beq cr6, 0x823941b0
	if ctx.cr[6].eq {
	pc = 0x823941B0; continue 'dispatch;
	}
	pc = 0x823941AC; continue 'dispatch;
            }
            0x823941AC => {
    //   block [0x823941AC..0x823941B0)
	// 823941AC: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	pc = 0x823941B0; continue 'dispatch;
            }
            0x823941B0 => {
    //   block [0x823941B0..0x823941C4)
	// 823941B0: 5529063F  clrlwi. r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823941B4: 40820018  bne 0x823941cc
	if !ctx.cr[0].eq {
		sub_823941CC(ctx, base);
		return;
	}
	// 823941B8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823941BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823941C0: 4082FFCC  bne 0x8239418c
	if !ctx.cr[0].eq {
	pc = 0x8239418C; continue 'dispatch;
	}
	pc = 0x823941C4; continue 'dispatch;
            }
            0x823941C4 => {
    //   block [0x823941C4..0x823941CC)
	// 823941C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823941C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823941CC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823941CC size=196
    let mut pc: u32 = 0x823941CC;
    'dispatch: loop {
        match pc {
            0x823941CC => {
    //   block [0x823941CC..0x823941F8)
	// 823941CC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823941D0: 409A0068  bne cr6, 0x82394238
	if !ctx.cr[6].eq {
	pc = 0x82394238; continue 'dispatch;
	}
	// 823941D4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823941D8: 419A00B0  beq cr6, 0x82394288
	if ctx.cr[6].eq {
	pc = 0x82394288; continue 'dispatch;
	}
	// 823941DC: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 823941E0: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823941E4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823941E8: 41820010  beq 0x823941f8
	if ctx.cr[0].eq {
	pc = 0x823941F8; continue 'dispatch;
	}
	// 823941EC: 90C90010  stw r6, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 823941F0: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823941F4: 4800000C  b 0x82394200
	pc = 0x82394200; continue 'dispatch;
            }
            0x823941F8 => {
    //   block [0x823941F8..0x82394200)
	// 823941F8: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 823941FC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x82394200; continue 'dispatch;
            }
            0x82394200 => {
    //   block [0x82394200..0x82394224)
	// 82394200: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82394204: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82394208: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8239420C: 419A0018  beq cr6, 0x82394224
	if ctx.cr[6].eq {
	pc = 0x82394224; continue 'dispatch;
	}
	// 82394210: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82394214: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82394218: 91690010  stw r11, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8239421C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82394220: 48000010  b 0x82394230
	pc = 0x82394230; continue 'dispatch;
            }
            0x82394224 => {
    //   block [0x82394224..0x82394230)
	// 82394224: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82394228: 90CB0014  stw r6, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 8239422C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82394230; continue 'dispatch;
            }
            0x82394230 => {
    //   block [0x82394230..0x82394238)
	// 82394230: 90CB0010  stw r6, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82394234: 48000054  b 0x82394288
	pc = 0x82394288; continue 'dispatch;
            }
            0x82394238 => {
    //   block [0x82394238..0x8239424C)
	// 82394238: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8239423C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82394240: 4182000C  beq 0x8239424c
	if ctx.cr[0].eq {
	pc = 0x8239424C; continue 'dispatch;
	}
	// 82394244: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82394248: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	pc = 0x8239424C; continue 'dispatch;
            }
            0x8239424C => {
    //   block [0x8239424C..0x82394260)
	// 8239424C: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82394250: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82394254: 4182000C  beq 0x82394260
	if ctx.cr[0].eq {
	pc = 0x82394260; continue 'dispatch;
	}
	// 82394258: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8239425C: 91090010  stw r8, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	pc = 0x82394260; continue 'dispatch;
            }
            0x82394260 => {
    //   block [0x82394260..0x82394280)
	// 82394260: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82394264: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82394268: 419A0018  beq cr6, 0x82394280
	if ctx.cr[6].eq {
	pc = 0x82394280; continue 'dispatch;
	}
	// 8239426C: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82394270: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82394274: 91690010  stw r11, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82394278: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8239427C: 4800000C  b 0x82394288
	pc = 0x82394288; continue 'dispatch;
            }
            0x82394280 => {
    //   block [0x82394280..0x82394288)
	// 82394280: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82394284: 90CB0014  stw r6, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	pc = 0x82394288; continue 'dispatch;
            }
            0x82394288 => {
    //   block [0x82394288..0x82394290)
	// 82394288: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8239428C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82394290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82394290 size=788
    let mut pc: u32 = 0x82394290;
    'dispatch: loop {
        match pc {
            0x82394290 => {
    //   block [0x82394290..0x823942E0)
	// 82394290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82394294: 481A0E1D  bl 0x825350b0
	ctx.lr = 0x82394298;
	sub_82535080(ctx, base);
	// 82394298: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8239429C: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 823942A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823942A4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823942A8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823942AC: 3B4B0C40  addi r26, r11, 0xc40
	ctx.r[26].s64 = ctx.r[11].s64 + 3136;
	// 823942B0: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 823942B4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823942B8: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823942BC: 93BB0000  stw r29, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823942C0: 4BFD4D69  bl 0x82369028
	ctx.lr = 0x823942C4;
	sub_82369028(ctx, base);
	// 823942C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823942C8: 4802D5A9  bl 0x823c1870
	ctx.lr = 0x823942CC;
	sub_823C1870(ctx, base);
	// 823942CC: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823942D0: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 823942D4: 396BBAB0  addi r11, r11, -0x4550
	ctx.r[11].s64 = ctx.r[11].s64 + -17744;
	// 823942D8: 906B0044  stw r3, 0x44(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 823942DC: 396B004C  addi r11, r11, 0x4c
	ctx.r[11].s64 = ctx.r[11].s64 + 76;
	pc = 0x823942E0; continue 'dispatch;
            }
            0x823942E0 => {
    //   block [0x823942E0..0x8239439C)
	// 823942E0: 93ABFFFC  stw r29, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[29].u32 ) };
	// 823942E4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823942E8: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823942EC: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 823942F0: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 823942F4: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 823942F8: 4082FFE8  bne 0x823942e0
	if !ctx.cr[0].eq {
	pc = 0x823942E0; continue 'dispatch;
	}
	// 823942FC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82394300: 483799BD  bl 0x8270dcbc
	ctx.lr = 0x82394304;
	// extern call 0x8270DCBC  crate::xboxkrnl::XGetVideoMode
	crate::xboxkrnl::XGetVideoMode(ctx, base);
	// 82394304: 48005D4D  bl 0x8239a050
	ctx.lr = 0x82394308;
	sub_8239A050(ctx, base);
	// 82394308: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8239430C: 3BEBFB8C  addi r31, r11, -0x474
	ctx.r[31].s64 = ctx.r[11].s64 + -1140;
	// 82394310: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82394314: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82394318: 386B0390  addi r3, r11, 0x390
	ctx.r[3].s64 = ctx.r[11].s64 + 912;
	// 8239431C: 48005F45  bl 0x8239a260
	ctx.lr = 0x82394320;
	sub_8239A260(ctx, base);
	// 82394320: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82394324: 41800278  blt 0x8239459c
	if ctx.cr[0].lt {
	pc = 0x8239459C; continue 'dispatch;
	}
	// 82394328: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8239432C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82394330: 386B0398  addi r3, r11, 0x398
	ctx.r[3].s64 = ctx.r[11].s64 + 920;
	// 82394334: 48005F2D  bl 0x8239a260
	ctx.lr = 0x82394338;
	sub_8239A260(ctx, base);
	// 82394338: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8239433C: 41800260  blt 0x8239459c
	if ctx.cr[0].lt {
	pc = 0x8239459C; continue 'dispatch;
	}
	// 82394340: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82394344: 48379979  bl 0x8270dcbc
	ctx.lr = 0x82394348;
	// extern call 0x8270DCBC  crate::xboxkrnl::XGetVideoMode
	crate::xboxkrnl::XGetVideoMode(ctx, base);
	// 82394348: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 8239434C: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82394350: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82394354: 81010070  lwz r8, 0x70(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82394358: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8239435C: 80E10074  lwz r7, 0x74(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82394360: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82394364: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 82394368: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8239436C: 396B2380  addi r11, r11, 0x2380
	ctx.r[11].s64 = ctx.r[11].s64 + 9088;
	// 82394370: 5529DFFE  rlwinm r9, r9, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82394374: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82394378: 912B0030  stw r9, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 8239437C: 914B0034  stw r10, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82394380: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82394384: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 82394388: 419A0014  beq cr6, 0x8239439c
	if ctx.cr[6].eq {
	pc = 0x8239439C; continue 'dispatch;
	}
	// 8239438C: 394AFFFD  addi r10, r10, -3
	ctx.r[10].s64 = ctx.r[10].s64 + -3;
	// 82394390: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82394394: 554AE7BC  rlwinm r10, r10, 0x1c, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82394398: 48000008  b 0x823943a0
	pc = 0x823943A0; continue 'dispatch;
            }
            0x8239439C => {
    //   block [0x8239439C..0x823943A0)
	// 8239439C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x823943A0; continue 'dispatch;
            }
            0x823943A0 => {
    //   block [0x823943A0..0x823943F8)
	// 823943A0: 79060020  clrldi r6, r8, 0x20
	ctx.r[6].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 823943A4: C0010084  lfs f0, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823943A8: 78E50020  clrldi r5, r7, 0x20
	ctx.r[5].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 823943AC: D00B002C  stfs f0, 0x2c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 823943B0: 914B0038  stw r10, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 823943B4: 2B080500  cmplwi cr6, r8, 0x500
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1280 as u32, &mut ctx.xer);
	// 823943B8: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 823943BC: F8A10058  std r5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u64 ) };
	// 823943C0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823943C4: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823943C8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823943CC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823943D0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823943D4: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 823943D8: FC006818  frsp f0, f13
	ctx.f[0].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823943DC: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823943E0: 40990018  ble cr6, 0x823943f8
	if !ctx.cr[6].gt {
	pc = 0x823943F8; continue 'dispatch;
	}
	// 823943E4: 21490000  subfic r10, r9, 0
	ctx.xer.ca = ctx.r[9].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[9].s64;
	// 823943E8: 7D4A5110  subfe r10, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 823943EC: 554A003C  rlwinm r10, r10, 0, 0, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823943F0: 394A0005  addi r10, r10, 5
	ctx.r[10].s64 = ctx.r[10].s64 + 5;
	// 823943F4: 48000020  b 0x82394414
	pc = 0x82394414; continue 'dispatch;
            }
            0x823943F8 => {
    //   block [0x823943F8..0x82394410)
	// 823943F8: 2B0802D0  cmplwi cr6, r8, 0x2d0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 720 as u32, &mut ctx.xer);
	// 823943FC: 41990014  bgt cr6, 0x82394410
	if ctx.cr[6].gt {
	pc = 0x82394410; continue 'dispatch;
	}
	// 82394400: 7D2A0034  cntlzw r10, r9
	ctx.r[10].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 82394404: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82394408: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8239440C: 48000008  b 0x82394414
	pc = 0x82394414; continue 'dispatch;
            }
            0x82394410 => {
    //   block [0x82394410..0x82394414)
	// 82394410: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	pc = 0x82394414; continue 'dispatch;
            }
            0x82394414 => {
    //   block [0x82394414..0x82394440)
	// 82394414: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82394418: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8239441C: 419A0038  beq cr6, 0x82394454
	if ctx.cr[6].eq {
	pc = 0x82394454; continue 'dispatch;
	}
	// 82394420: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 82394424: 4099001C  ble cr6, 0x82394440
	if !ctx.cr[6].gt {
	pc = 0x82394440; continue 'dispatch;
	}
	// 82394428: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 8239442C: 419A0014  beq cr6, 0x82394440
	if ctx.cr[6].eq {
	pc = 0x82394440; continue 'dispatch;
	}
	// 82394430: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 82394434: 419A000C  beq cr6, 0x82394440
	if ctx.cr[6].eq {
	pc = 0x82394440; continue 'dispatch;
	}
	// 82394438: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 8239443C: 409A0018  bne cr6, 0x82394454
	if !ctx.cr[6].eq {
	pc = 0x82394454; continue 'dispatch;
	}
	pc = 0x82394440; continue 'dispatch;
            }
            0x82394440 => {
    //   block [0x82394440..0x82394454)
	// 82394440: 39000500  li r8, 0x500
	ctx.r[8].s64 = 1280;
	// 82394444: 38E002D0  li r7, 0x2d0
	ctx.r[7].s64 = 720;
	// 82394448: 39400500  li r10, 0x500
	ctx.r[10].s64 = 1280;
	// 8239444C: 392002D0  li r9, 0x2d0
	ctx.r[9].s64 = 720;
	// 82394450: 4800000C  b 0x8239445c
	pc = 0x8239445C; continue 'dispatch;
            }
            0x82394454 => {
    //   block [0x82394454..0x8239445C)
	// 82394454: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82394458: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8239445C; continue 'dispatch;
            }
            0x8239445C => {
    //   block [0x8239445C..0x823944EC)
	// 8239445C: 79050020  clrldi r5, r8, 0x20
	ctx.r[5].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 82394460: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82394464: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 82394468: 79290020  clrldi r9, r9, 0x20
	ctx.r[9].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 8239446C: 3BE6BA38  addi r31, r6, -0x45c8
	ctx.r[31].s64 = ctx.r[6].s64 + -17864;
	// 82394470: F8A10058  std r5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u64 ) };
	// 82394474: 78E60020  clrldi r6, r7, 0x20
	ctx.r[6].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 82394478: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 8239447C: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 82394480: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82394484: F8C10060  std r6, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u64 ) };
	// 82394488: D00B003C  stfs f0, 0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8239448C: D00B0040  stfs f0, 0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82394490: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82394494: 90EB000C  stw r7, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82394498: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8239449C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823944A0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823944A4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823944A8: C9610068  lfd f11, 0x68(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 823944AC: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 823944B0: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 823944B4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 823944B8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823944BC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823944C0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823944C4: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 823944C8: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 823944CC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 823944D0: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823944D4: D16B0014  stfs f11, 0x14(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 823944D8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823944DC: 409A0010  bne cr6, 0x823944ec
	if !ctx.cr[6].eq {
	pc = 0x823944EC; continue 'dispatch;
	}
	// 823944E0: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 823944E4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 823944E8: 419A0008  beq cr6, 0x823944f0
	if ctx.cr[6].eq {
	pc = 0x823944F0; continue 'dispatch;
	}
	pc = 0x823944EC; continue 'dispatch;
            }
            0x823944EC => {
    //   block [0x823944EC..0x823944F0)
	// 823944EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x823944F0; continue 'dispatch;
            }
            0x823944F0 => {
    //   block [0x823944F0..0x8239450C)
	// 823944F0: 914B0024  stw r10, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 823944F4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823944F8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 823944FC: 93BB0000  stw r29, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82394500: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82394504: 4802D375  bl 0x823c1878
	ctx.lr = 0x82394508;
	sub_823C1878(ctx, base);
	// 82394508: 397FF5E8  addi r11, r31, -0xa18
	ctx.r[11].s64 = ctx.r[31].s64 + -2584;
	pc = 0x8239450C; continue 'dispatch;
            }
            0x8239450C => {
    //   block [0x8239450C..0x8239452C)
	// 8239450C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394510: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82394514: 419A0018  beq cr6, 0x8239452c
	if ctx.cr[6].eq {
	pc = 0x8239452C; continue 'dispatch;
	}
	// 82394518: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 8239451C: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82394520: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 82394524: 409AFFE8  bne cr6, 0x8239450c
	if !ctx.cr[6].eq {
	pc = 0x8239450C; continue 'dispatch;
	}
	// 82394528: 48000008  b 0x82394530
	pc = 0x82394530; continue 'dispatch;
            }
            0x8239452C => {
    //   block [0x8239452C..0x82394530)
	// 8239452C: 8BCB0001  lbz r30, 1(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	pc = 0x82394530; continue 'dispatch;
            }
            0x82394530 => {
    //   block [0x82394530..0x82394540)
	// 82394530: 93DA06D8  stw r30, 0x6d8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(1752 as u32), ctx.r[30].u32 ) };
	// 82394534: 3BC00006  li r30, 6
	ctx.r[30].s64 = 6;
	// 82394538: 48378C75  bl 0x8270d1ac
	ctx.lr = 0x8239453C;
	// extern call 0x8270D1AC  crate::xboxkrnl::XGetGameRegion
	crate::xboxkrnl::XGetGameRegion(ctx, base);
	// 8239453C: 397FF600  addi r11, r31, -0xa00
	ctx.r[11].s64 = ctx.r[31].s64 + -2560;
	pc = 0x82394540; continue 'dispatch;
            }
            0x82394540 => {
    //   block [0x82394540..0x82394560)
	// 82394540: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394544: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82394548: 419A0018  beq cr6, 0x82394560
	if ctx.cr[6].eq {
	pc = 0x82394560; continue 'dispatch;
	}
	// 8239454C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82394550: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82394554: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 82394558: 409AFFE8  bne cr6, 0x82394540
	if !ctx.cr[6].eq {
	pc = 0x82394540; continue 'dispatch;
	}
	// 8239455C: 48000008  b 0x82394564
	pc = 0x82394564; continue 'dispatch;
            }
            0x82394560 => {
    //   block [0x82394560..0x82394564)
	// 82394560: A3CB0004  lhz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82394564; continue 'dispatch;
            }
            0x82394564 => {
    //   block [0x82394564..0x82394574)
	// 82394564: 93DA06DC  stw r30, 0x6dc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(1756 as u32), ctx.r[30].u32 ) };
	// 82394568: 3BC00006  li r30, 6
	ctx.r[30].s64 = 6;
	// 8239456C: 48378C41  bl 0x8270d1ac
	ctx.lr = 0x82394570;
	// extern call 0x8270D1AC  crate::xboxkrnl::XGetGameRegion
	crate::xboxkrnl::XGetGameRegion(ctx, base);
	// 82394570: 397FF600  addi r11, r31, -0xa00
	ctx.r[11].s64 = ctx.r[31].s64 + -2560;
	pc = 0x82394574; continue 'dispatch;
            }
            0x82394574 => {
    //   block [0x82394574..0x82394594)
	// 82394574: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394578: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 8239457C: 419A0018  beq cr6, 0x82394594
	if ctx.cr[6].eq {
	pc = 0x82394594; continue 'dispatch;
	}
	// 82394580: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82394584: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82394588: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 8239458C: 409AFFE8  bne cr6, 0x82394574
	if !ctx.cr[6].eq {
	pc = 0x82394574; continue 'dispatch;
	}
	// 82394590: 48000008  b 0x82394598
	pc = 0x82394598; continue 'dispatch;
            }
            0x82394594 => {
    //   block [0x82394594..0x82394598)
	// 82394594: A3CB0006  lhz r30, 6(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	pc = 0x82394598; continue 'dispatch;
            }
            0x82394598 => {
    //   block [0x82394598..0x8239459C)
	// 82394598: 93DA06E0  stw r30, 0x6e0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(1760 as u32), ctx.r[30].u32 ) };
	pc = 0x8239459C; continue 'dispatch;
            }
            0x8239459C => {
    //   block [0x8239459C..0x823945A4)
	// 8239459C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 823945A0: 481A0B60  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823945A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823945A8 size=196
    let mut pc: u32 = 0x823945A8;
    'dispatch: loop {
        match pc {
            0x823945A8 => {
    //   block [0x823945A8..0x823945E8)
	// 823945A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823945AC: 481A0B0D  bl 0x825350b8
	ctx.lr = 0x823945B0;
	sub_82535080(ctx, base);
	// 823945B0: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 823945B4: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 823945B8: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 823945BC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823945C0: 3D6082B6  lis r11, -0x7d4a
	ctx.r[11].s64 = -2102001664;
	// 823945C4: C3A40000  lfs f29, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 823945C8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823945CC: 3BABBC70  addi r29, r11, -0x4390
	ctx.r[29].s64 = ctx.r[11].s64 + -17296;
	// 823945D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823945D4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823945D8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823945DC: CBCA2218  lfd f30, 0x2218(r10)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8728 as u32) ) };
	// 823945E0: 3BFD0200  addi r31, r29, 0x200
	ctx.r[31].s64 = ctx.r[29].s64 + 512;
	// 823945E4: CBEB2210  lfd f31, 0x2210(r11)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8720 as u32) ) };
	pc = 0x823945E8; continue 'dispatch;
            }
            0x823945E8 => {
    //   block [0x823945E8..0x82394628)
	// 823945E8: 7BCB0020  clrldi r11, r30, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 823945EC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 823945F0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823945F4: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823945F8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823945FC: FC2007F2  fmul f1, f0, f31
	ctx.f[1].f64 = ctx.f[0].f64 * ctx.f[31].f64;
	// 82394600: 4819F171  bl 0x82533770
	ctx.lr = 0x82394604;
	sub_82533770(ctx, base);
	// 82394604: FC0107B2  fmul f0, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[30].f64;
	// 82394608: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8239460C: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82394610: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82394614: 216B0020  subfic r11, r11, 0x20
	ctx.xer.ca = ctx.r[11].u32 <= 32 as u32;
	ctx.r[11].s64 = (32 as i64) - ctx.r[11].s64;
	// 82394618: 2B2BFFFF  cmpldi cr6, r11, 0xffff
	ctx.cr[6].compare_u64(ctx.r[11].u64, 65535, &mut ctx.xer);
	// 8239461C: 4099000C  ble cr6, 0x82394628
	if !ctx.cr[6].gt {
	pc = 0x82394628; continue 'dispatch;
	}
	// 82394620: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82394624: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	pc = 0x82394628; continue 'dispatch;
            }
            0x82394628 => {
    //   block [0x82394628..0x8239466C)
	// 82394628: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 8239462C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82394630: 2B1E0100  cmplwi cr6, r30, 0x100
	ctx.cr[6].compare_u32(ctx.r[30].u32, 256 as u32, &mut ctx.xer);
	// 82394634: B17F0200  sth r11, 0x200(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[11].u16 ) };
	// 82394638: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 8239463C: B17FFE00  sth r11, -0x200(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(-512 as u32), ctx.r[11].u16 ) };
	// 82394640: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 82394644: 4198FFA4  blt cr6, 0x823945e8
	if ctx.cr[6].lt {
	pc = 0x823945E8; continue 'dispatch;
	}
	// 82394648: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8239464C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82394650: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82394654: 4804A47D  bl 0x823dead0
	ctx.lr = 0x82394658;
	sub_823DEAD0(ctx, base);
	// 82394658: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8239465C: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82394660: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82394664: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82394668: 481A0AA0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82394670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82394670 size=236
    let mut pc: u32 = 0x82394670;
    'dispatch: loop {
        match pc {
            0x82394670 => {
    //   block [0x82394670..0x823946C0)
	// 82394670: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82394674: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82394678: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 8239467C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394680: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82394684: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82394688: 419A00D4  beq cr6, 0x8239475c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8239475C);
		return;
	}
	// 8239468C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82394690: 90AB0008  stw r5, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82394694: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82394698: 90C90000  stw r6, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 8239469C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823946A0: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823946A4: 4082001C  bne 0x823946c0
	if !ctx.cr[0].eq {
	pc = 0x823946C0; continue 'dispatch;
	}
	// 823946A8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823946AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823946B0: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 823946B4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823946B8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823946BC: 4800005C  b 0x82394718
	pc = 0x82394718; continue 'dispatch;
            }
            0x823946C0 => {
    //   block [0x823946C0..0x823946C4)
	// 823946C0: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	pc = 0x823946C4; continue 'dispatch;
            }
            0x823946C4 => {
    //   block [0x823946C4..0x823946DC)
	// 823946C4: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 823946C8: 7F082800  cmpw cr6, r8, r5
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[5].s32, &mut ctx.xer);
	// 823946CC: 40980010  bge cr6, 0x823946dc
	if !ctx.cr[6].lt {
	pc = 0x823946DC; continue 'dispatch;
	}
	// 823946D0: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 823946D4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823946D8: 4082FFEC  bne 0x823946c4
	if !ctx.cr[0].eq {
	pc = 0x823946C4; continue 'dispatch;
	}
	pc = 0x823946DC; continue 'dispatch;
            }
            0x823946DC => {
    //   block [0x823946DC..0x823946EC)
	// 823946DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823946E0: 419A002C  beq cr6, 0x8239470c
	if ctx.cr[6].eq {
	pc = 0x8239470C; continue 'dispatch;
	}
	// 823946E4: 7F082800  cmpw cr6, r8, r5
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[5].s32, &mut ctx.xer);
	// 823946E8: 409A003C  bne cr6, 0x82394724
	if !ctx.cr[6].eq {
	pc = 0x82394724; continue 'dispatch;
	}
	pc = 0x823946EC; continue 'dispatch;
            }
            0x823946EC => {
    //   block [0x823946EC..0x82394704)
	// 823946EC: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 823946F0: 7F082800  cmpw cr6, r8, r5
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[5].s32, &mut ctx.xer);
	// 823946F4: 409A0010  bne cr6, 0x82394704
	if !ctx.cr[6].eq {
	pc = 0x82394704; continue 'dispatch;
	}
	// 823946F8: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 823946FC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82394700: 4082FFEC  bne 0x823946ec
	if !ctx.cr[0].eq {
	pc = 0x823946EC; continue 'dispatch;
	}
	pc = 0x82394704; continue 'dispatch;
            }
            0x82394704 => {
    //   block [0x82394704..0x8239470C)
	// 82394704: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82394708: 409A001C  bne cr6, 0x82394724
	if !ctx.cr[6].eq {
	pc = 0x82394724; continue 'dispatch;
	}
	pc = 0x8239470C; continue 'dispatch;
            }
            0x8239470C => {
    //   block [0x8239470C..0x82394718)
	// 8239470C: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82394710: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82394714: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x82394718; continue 'dispatch;
            }
            0x82394718 => {
    //   block [0x82394718..0x82394724)
	// 82394718: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8239471C: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82394720: 48000034  b 0x82394754
	pc = 0x82394754; continue 'dispatch;
            }
            0x82394724 => {
    //   block [0x82394724..0x82394730)
	// 82394724: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82394728: 409A0008  bne cr6, 0x82394730
	if !ctx.cr[6].eq {
	pc = 0x82394730; continue 'dispatch;
	}
	// 8239472C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82394730; continue 'dispatch;
            }
            0x82394730 => {
    //   block [0x82394730..0x8239474C)
	// 82394730: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394734: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82394738: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8239473C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82394740: 4182000C  beq 0x8239474c
	if ctx.cr[0].eq {
	pc = 0x8239474C; continue 'dispatch;
	}
	// 82394744: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82394748: 48000008  b 0x82394750
	pc = 0x82394750; continue 'dispatch;
            }
            0x8239474C => {
    //   block [0x8239474C..0x82394750)
	// 8239474C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82394750; continue 'dispatch;
            }
            0x82394750 => {
    //   block [0x82394750..0x82394754)
	// 82394750: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82394754; continue 'dispatch;
            }
            0x82394754 => {
    //   block [0x82394754..0x8239475C)
	// 82394754: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82394758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82394768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82394768 size=100
    let mut pc: u32 = 0x82394768;
    'dispatch: loop {
        match pc {
            0x82394768 => {
    //   block [0x82394768..0x8239478C)
	// 82394768: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8239476C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394770: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82394774: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82394778: 41820048  beq 0x823947c0
	if ctx.cr[0].eq {
	pc = 0x823947C0; continue 'dispatch;
	}
	// 8239477C: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82394780: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82394784: 409A0008  bne cr6, 0x8239478c
	if !ctx.cr[6].eq {
	pc = 0x8239478C; continue 'dispatch;
	}
	// 82394788: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x8239478C; continue 'dispatch;
            }
            0x8239478C => {
    //   block [0x8239478C..0x823947A0)
	// 8239478C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82394790: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82394794: 409A000C  bne cr6, 0x823947a0
	if !ctx.cr[6].eq {
	pc = 0x823947A0; continue 'dispatch;
	}
	// 82394798: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8239479C: 48000008  b 0x823947a4
	pc = 0x823947A4; continue 'dispatch;
            }
            0x823947A0 => {
    //   block [0x823947A0..0x823947A4)
	// 823947A0: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x823947A4; continue 'dispatch;
            }
            0x823947A4 => {
    //   block [0x823947A4..0x823947C0)
	// 823947A4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823947A8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823947AC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823947B0: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823947B4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823947B8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823947BC: 48000008  b 0x823947c4
	pc = 0x823947C4; continue 'dispatch;
            }
            0x823947C0 => {
    //   block [0x823947C0..0x823947C4)
	// 823947C0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x823947C4; continue 'dispatch;
            }
            0x823947C4 => {
    //   block [0x823947C4..0x823947CC)
	// 823947C4: 91240000  stw r9, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823947C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823947D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823947D0 size=16
    let mut pc: u32 = 0x823947D0;
    'dispatch: loop {
        match pc {
            0x823947D0 => {
    //   block [0x823947D0..0x823947E0)
	// 823947D0: 3964FFE0  addi r11, r4, -0x20
	ctx.r[11].s64 = ctx.r[4].s64 + -32;
	// 823947D4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823947D8: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823947DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823947E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823947E0 size=16
    let mut pc: u32 = 0x823947E0;
    'dispatch: loop {
        match pc {
            0x823947E0 => {
    //   block [0x823947E0..0x823947F0)
	// 823947E0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823947E4: 1D6B0070  mulli r11, r11, 0x70
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 112 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823947E8: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 823947EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823947F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823947F0 size=108
    let mut pc: u32 = 0x823947F0;
    'dispatch: loop {
        match pc {
            0x823947F0 => {
    //   block [0x823947F0..0x8239481C)
	// 823947F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823947F4: 481A08C9  bl 0x825350bc
	ctx.lr = 0x823947F8;
	sub_82535080(ctx, base);
	// 823947F8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 823947FC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82394800: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82394804: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82394808: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8239480C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82394810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82394814: 40990030  ble cr6, 0x82394844
	if !ctx.cr[6].gt {
	pc = 0x82394844; continue 'dispatch;
	}
	// 82394818: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x8239481C; continue 'dispatch;
            }
            0x8239481C => {
    //   block [0x8239481C..0x82394844)
	// 8239481C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82394820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82394824: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82394828: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 8239482C: 48000165  bl 0x82394990
	ctx.lr = 0x82394830;
	sub_82394990(ctx, base);
	// 82394830: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82394834: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82394838: 3BDE0070  addi r30, r30, 0x70
	ctx.r[30].s64 = ctx.r[30].s64 + 112;
	// 8239483C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82394840: 4198FFDC  blt cr6, 0x8239481c
	if ctx.cr[6].lt {
	pc = 0x8239481C; continue 'dispatch;
	}
	pc = 0x82394844; continue 'dispatch;
            }
            0x82394844 => {
    //   block [0x82394844..0x8239485C)
	// 82394844: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82394848: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 8239484C: 916ABA88  stw r11, -0x4578(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17784 as u32), ctx.r[11].u32 ) };
	// 82394850: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82394854: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82394858: 481A08B4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82394860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82394860 size=108
    let mut pc: u32 = 0x82394860;
    'dispatch: loop {
        match pc {
            0x82394860 => {
    //   block [0x82394860..0x8239488C)
	// 82394860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82394864: 481A0859  bl 0x825350bc
	ctx.lr = 0x82394868;
	sub_82535080(ctx, base);
	// 82394868: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8239486C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82394870: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82394874: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82394878: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8239487C: 41820048  beq 0x823948c4
	if ctx.cr[0].eq {
	pc = 0x823948C4; continue 'dispatch;
	}
	// 82394880: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82394884: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82394888: 40980028  bge cr6, 0x823948b0
	if !ctx.cr[6].lt {
	pc = 0x823948B0; continue 'dispatch;
	}
	pc = 0x8239488C; continue 'dispatch;
            }
            0x8239488C => {
    //   block [0x8239488C..0x823948B0)
	// 8239488C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82394890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82394894: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82394898: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8239489C: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 823948A0: 394A0003  addi r10, r10, 3
	ctx.r[10].s64 = ctx.r[10].s64 + 3;
	// 823948A4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823948A8: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823948AC: 48000625  bl 0x82394ed0
	ctx.lr = 0x823948B0;
	sub_82394ED0(ctx, base);
	pc = 0x823948B0; continue 'dispatch;
            }
            0x823948B0 => {
    //   block [0x823948B0..0x823948C4)
	// 823948B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823948B4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823948B8: 3BDE0070  addi r30, r30, 0x70
	ctx.r[30].s64 = ctx.r[30].s64 + 112;
	// 823948BC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823948C0: 4198FFCC  blt cr6, 0x8239488c
	if ctx.cr[6].lt {
	pc = 0x8239488C; continue 'dispatch;
	}
	pc = 0x823948C4; continue 'dispatch;
            }
            0x823948C4 => {
    //   block [0x823948C4..0x823948CC)
	// 823948C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823948C8: 481A0844  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823948D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823948D0 size=192
    let mut pc: u32 = 0x823948D0;
    'dispatch: loop {
        match pc {
            0x823948D0 => {
    //   block [0x823948D0..0x82394984)
	// 823948D0: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 823948D4: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 823948D8: 89640010  lbz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 823948DC: 39430023  addi r10, r3, 0x23
	ctx.r[10].s64 = ctx.r[3].s64 + 35;
	// 823948E0: 38E40014  addi r7, r4, 0x14
	ctx.r[7].s64 = ctx.r[4].s64 + 20;
	// 823948E4: 554A0036  rlwinm r10, r10, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823948E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823948EC: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823948F0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823948F4: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 823948F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823948FC: 40990088  ble cr6, 0x82394984
	if !ctx.cr[6].gt {
	pc = 0x82394984; continue 'dispatch;
	}
	// 82394900: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82394904: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82394908: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8239490C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82394910: 3D203F80  lis r9, 0x3f80
	ctx.r[9].s64 = 1065353216;
	// 82394914: C1AABA38  lfs f13, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82394918: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8239491C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82394920: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 82394924: 80A70000  lwz r5, 0(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394928: 3BE00020  li r31, 0x20
	ctx.r[31].s64 = 32;
	// 8239492C: 7D485A14  add r10, r8, r11
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82394930: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 82394934: 396A0030  addi r11, r10, 0x30
	ctx.r[11].s64 = ctx.r[10].s64 + 48;
	// 82394938: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 8239493C: 39080070  addi r8, r8, 0x70
	ctx.r[8].s64 = ctx.r[8].s64 + 112;
	// 82394940: 90AA0000  stw r5, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82394944: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	pc = 0x82394984; continue 'dispatch;
            }
            0x82394984 => {
    //   block [0x82394984..0x82394990)
	// 82394984: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82394988: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 8239498C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82394990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82394990 size=1344
    let mut pc: u32 = 0x82394990;
    'dispatch: loop {
        match pc {
            0x82394990 => {
    //   block [0x82394990..0x82394A2C)
	// 82394990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82394994: 481A0721  bl 0x825350b4
	ctx.lr = 0x82394998;
	sub_82535080(ctx, base);
	// 82394998: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 8239499C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 823949A0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823949A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823949A8: FD200890  fmr f9, f1
	ctx.f[9].f64 = ctx.f[1].f64;
	// 823949AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823949B0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 823949B4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 823949B8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 823949BC: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823949C0: C03F0010  lfs f1, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823949C4: 99610090  stb r11, 0x90(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u8 ) };
	// 823949C8: A0BF000C  lhz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823949CC: 897E0003  lbz r11, 3(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(3 as u32) ) } as u64;
	// 823949D0: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 823949D4: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823949D8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 823949DC: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 823949E0: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 823949E4: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823949E8: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 823949EC: 48004F45  bl 0x82399930
	ctx.lr = 0x823949F0;
	sub_82399930(ctx, base);
	// 823949F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823949F4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 823949F8: 389F0030  addi r4, r31, 0x30
	ctx.r[4].s64 = ctx.r[31].s64 + 48;
	// 823949FC: A12B0002  lhz r9, 2(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82394A00: C3EABA38  lfs f31, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82394A04: 552B073E  clrlwi r11, r9, 0x1c
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000000Fu64;
	// 82394A08: 55280636  rlwinm r8, r9, 0, 0x18, 0x1b
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82394A0C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 82394A10: 409A001C  bne cr6, 0x82394a2c
	if !ctx.cr[6].eq {
	pc = 0x82394A2C; continue 'dispatch;
	}
	// 82394A14: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82394A18: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82394A1C: D0040030  stfs f0, 0x30(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82394A20: D1A40034  stfs f13, 0x34(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82394A24: D3E4003C  stfs f31, 0x3c(r4)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82394A28: 4800002C  b 0x82394a54
	pc = 0x82394A54; continue 'dispatch;
            }
            0x82394A2C => {
    //   block [0x82394A2C..0x82394A3C)
	// 82394A2C: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82394A30: 4182000C  beq 0x82394a3c
	if ctx.cr[0].eq {
	pc = 0x82394A3C; continue 'dispatch;
	}
	// 82394A34: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82394A38: D0040030  stfs f0, 0x30(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(48 as u32), tmp.u32 ) };
	pc = 0x82394A3C; continue 'dispatch;
            }
            0x82394A3C => {
    //   block [0x82394A3C..0x82394A4C)
	// 82394A3C: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82394A40: 4182000C  beq 0x82394a4c
	if ctx.cr[0].eq {
	pc = 0x82394A4C; continue 'dispatch;
	}
	// 82394A44: C0010074  lfs f0, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82394A48: D0040034  stfs f0, 0x34(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(52 as u32), tmp.u32 ) };
	pc = 0x82394A4C; continue 'dispatch;
            }
            0x82394A4C => {
    //   block [0x82394A4C..0x82394A54)
	// 82394A4C: 556B077B  rlwinm. r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82394A50: 4182000C  beq 0x82394a5c
	if ctx.cr[0].eq {
	pc = 0x82394A5C; continue 'dispatch;
	}
	pc = 0x82394A54; continue 'dispatch;
            }
            0x82394A54 => {
    //   block [0x82394A54..0x82394A5C)
	// 82394A54: C0010078  lfs f0, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82394A58: D0040038  stfs f0, 0x38(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(56 as u32), tmp.u32 ) };
	pc = 0x82394A5C; continue 'dispatch;
            }
            0x82394A5C => {
    //   block [0x82394A5C..0x82394ED0)
	// 82394A5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82394A60: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82394A64: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 82394A68: 2B080080  cmplwi cr6, r8, 0x80
	ctx.cr[6].compare_u32(ctx.r[8].u32, 128 as u32, &mut ctx.xer);
	// 82394A6C: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82394A70: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82394ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82394ED0 size=212
    let mut pc: u32 = 0x82394ED0;
    'dispatch: loop {
        match pc {
            0x82394ED0 => {
    //   block [0x82394ED0..0x82394F28)
	// 82394ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82394ED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82394ED8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82394EDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82394EE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82394EE4: 90A40004  stw r5, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82394EE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82394EEC: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394EF0: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82394EF4: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82394EF8: 89650000  lbz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394EFC: D0240010  stfs f1, 0x10(r4)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82394F00: B164000C  sth r11, 0xc(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u16 ) };
	// 82394F04: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82394F08: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82394F0C: 90C40008  stw r6, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82394F10: B0C4000E  sth r6, 0xe(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(14 as u32), ctx.r[6].u16 ) };
	// 82394F14: A1680004  lhz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82394F18: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82394F1C: 41820070  beq 0x82394f8c
	if ctx.cr[0].eq {
	pc = 0x82394F8C; continue 'dispatch;
	}
	// 82394F20: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 82394F24: 80AABA80  lwz r5, -0x4580(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17792 as u32) ) } as u64;
	pc = 0x82394F28; continue 'dispatch;
            }
            0x82394F28 => {
    //   block [0x82394F28..0x82394F38)
	// 82394F28: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82394F2C: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82394F30: 41980008  blt cr6, 0x82394f38
	if ctx.cr[6].lt {
	pc = 0x82394F38; continue 'dispatch;
	}
	// 82394F34: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	pc = 0x82394F38; continue 'dispatch;
            }
            0x82394F38 => {
    //   block [0x82394F38..0x82394F5C)
	// 82394F38: 396A0003  addi r11, r10, 3
	ctx.r[11].s64 = ctx.r[10].s64 + 3;
	// 82394F3C: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 82394F40: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82394F44: 7D6B402E  lwzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82394F48: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82394F4C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394F50: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82394F54: 41820028  beq 0x82394f7c
	if ctx.cr[0].eq {
	pc = 0x82394F7C; continue 'dispatch;
	}
	// 82394F58: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	pc = 0x82394F5C; continue 'dispatch;
            }
            0x82394F5C => {
    //   block [0x82394F5C..0x82394F7C)
	// 82394F5C: 83E90000  lwz r31, 0(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394F60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82394F64: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82394F68: 57FF103A  slwi r31, r31, 2
	ctx.r[31].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82394F6C: 7C3F2D2E  stfsx f1, r31, r5
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 82394F70: 8BEB0000  lbz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394F74: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82394F78: 4198FFE4  blt cr6, 0x82394f5c
	if ctx.cr[6].lt {
	pc = 0x82394F5C; continue 'dispatch;
	}
	pc = 0x82394F7C; continue 'dispatch;
            }
            0x82394F7C => {
    //   block [0x82394F7C..0x82394F8C)
	// 82394F7C: A1680004  lhz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82394F80: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82394F84: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82394F88: 4198FFA0  blt cr6, 0x82394f28
	if ctx.cr[6].lt {
	pc = 0x82394F28; continue 'dispatch;
	}
	pc = 0x82394F8C; continue 'dispatch;
            }
            0x82394F8C => {
    //   block [0x82394F8C..0x82394FA4)
	// 82394F8C: 4BFFFA05  bl 0x82394990
	ctx.lr = 0x82394F90;
	sub_82394990(ctx, base);
	// 82394F90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82394F94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82394F98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82394F9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82394FA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82394FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82394FA8 size=460
    let mut pc: u32 = 0x82394FA8;
    'dispatch: loop {
        match pc {
            0x82394FA8 => {
    //   block [0x82394FA8..0x82394FD4)
	// 82394FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82394FAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82394FB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82394FB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82394FB8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82394FBC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82394FC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82394FC4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82394FC8: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82394FCC: 41820030  beq 0x82394ffc
	if ctx.cr[0].eq {
	pc = 0x82394FFC; continue 'dispatch;
	}
	// 82394FD0: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82394FD4; continue 'dispatch;
            }
            0x82394FD4 => {
    //   block [0x82394FD4..0x82394FEC)
	// 82394FD4: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394FD8: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82394FDC: 41820010  beq 0x82394fec
	if ctx.cr[0].eq {
	pc = 0x82394FEC; continue 'dispatch;
	}
	// 82394FE0: A0E70000  lhz r7, 0(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82394FE4: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82394FE8: 419A0028  beq cr6, 0x82395010
	if ctx.cr[6].eq {
	pc = 0x82395010; continue 'dispatch;
	}
	pc = 0x82394FEC; continue 'dispatch;
            }
            0x82394FEC => {
    //   block [0x82394FEC..0x82394FFC)
	// 82394FEC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82394FF0: 39080070  addi r8, r8, 0x70
	ctx.r[8].s64 = ctx.r[8].s64 + 112;
	// 82394FF4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82394FF8: 4198FFDC  blt cr6, 0x82394fd4
	if ctx.cr[6].lt {
	pc = 0x82394FD4; continue 'dispatch;
	}
	pc = 0x82394FFC; continue 'dispatch;
            }
            0x82394FFC => {
    //   block [0x82394FFC..0x82395000)
	// 82394FFC: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	pc = 0x82395000; continue 'dispatch;
            }
            0x82395000 => {
    //   block [0x82395000..0x82395010)
	// 82395000: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82395004: 409A0014  bne cr6, 0x82395018
	if !ctx.cr[6].eq {
	pc = 0x82395018; continue 'dispatch;
	}
	// 82395008: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8239500C: 48000154  b 0x82395160
	pc = 0x82395160; continue 'dispatch;
            }
            0x82395010 => {
    //   block [0x82395010..0x82395018)
	// 82395010: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82395014: 4BFFFFEC  b 0x82395000
	pc = 0x82395000; continue 'dispatch;
            }
            0x82395018 => {
    //   block [0x82395018..0x8239502C)
	// 82395018: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8239501C: A12A0004  lhz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82395020: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82395024: 41980008  blt cr6, 0x8239502c
	if ctx.cr[6].lt {
	pc = 0x8239502C; continue 'dispatch;
	}
	// 82395028: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x8239502C; continue 'dispatch;
            }
            0x8239502C => {
    //   block [0x8239502C..0x82395088)
	// 8239502C: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 82395030: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82395034: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82395038: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8239503C: D0240010  stfs f1, 0x10(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82395040: B0C4000C  sth r6, 0xc(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[6].u16 ) };
	// 82395044: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82395048: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8239504C: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82395050: 90A40008  stw r5, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82395054: B0A4000E  sth r5, 0xe(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(14 as u32), ctx.r[5].u16 ) };
	// 82395058: 419A0030  beq cr6, 0x82395088
	if ctx.cr[6].eq {
	pc = 0x82395088; continue 'dispatch;
	}
	// 8239505C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82395060: 54CA2036  slwi r10, r6, 4
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82395064: 39240020  addi r9, r4, 0x20
	ctx.r[9].s64 = ctx.r[4].s64 + 32;
	// 82395068: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8239506C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82395070: 394AFFF0  addi r10, r10, -0x10
	ctx.r[10].s64 = ctx.r[10].s64 + -16;
	// 82395074: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82395078: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8239507C: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82395080: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82395084: 4800004C  b 0x823950d0
	pc = 0x823950D0; continue 'dispatch;
            }
            0x82395088 => {
    //   block [0x82395088..0x823950D0)
	// 82395088: 810A0010  lwz r8, 0x10(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8239508C: 54C92036  slwi r9, r6, 4
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82395090: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82395094: 7D094214  add r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82395098: 39640020  addi r11, r4, 0x20
	ctx.r[11].s64 = ctx.r[4].s64 + 32;
	pc = 0x823950D0; continue 'dispatch;
            }
            0x823950D0 => {
    //   block [0x823950D0..0x82395160)
	// 823950D0: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823950D4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823950D8: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 823950DC: A1680004  lhz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 823950E0: C02A1FF8  lfs f1, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823950E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823950E8: 41820070  beq 0x82395158
	if ctx.cr[0].eq {
	pc = 0x82395158; continue 'dispatch;
	}
	// 823950EC: 3D4082B6  lis r10, -0x7d4a
	ctx.r[10].s64 = -2102001664;
	// 823950F0: 80CABA80  lwz r6, -0x4580(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17792 as u32) ) } as u64;
	// 823950F4: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 823950F8: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823950FC: 41980008  blt cr6, 0x82395104
	if ctx.cr[6].lt {
	pc = 0x82395104; continue 'dispatch;
	}
	// 82395100: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 82395104: 396A0003  addi r11, r10, 3
	ctx.r[11].s64 = ctx.r[10].s64 + 3;
	// 82395108: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 8239510C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82395110: 7D6B402E  lwzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82395114: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82395118: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8239511C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82395120: 41820028  beq 0x82395148
	if ctx.cr[0].eq {
	pc = 0x82395148; continue 'dispatch;
	}
	// 82395124: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 82395128: 83E90000  lwz r31, 0(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8239512C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82395130: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82395134: 57FF103A  slwi r31, r31, 2
	ctx.r[31].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82395138: 7C3F352E  stfsx f1, r31, r6
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 8239513C: 8BEB0000  lbz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82395140: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82395144: 4198FFE4  blt cr6, 0x82395128
	if ctx.cr[6].lt {
	pc = 0x82395128; continue 'dispatch;
	}
	// 82395148: A1680004  lhz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8239514C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82395150: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82395154: 4198FFA0  blt cr6, 0x823950f4
	if ctx.cr[6].lt {
	pc = 0x823950F4; continue 'dispatch;
	}
	// 82395158: 4BFFF839  bl 0x82394990
	ctx.lr = 0x8239515C;
	sub_82394990(ctx, base);
	// 8239515C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82395160; continue 'dispatch;
            }
            0x82395160 => {
    //   block [0x82395160..0x82395174)
	// 82395160: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82395164: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82395168: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8239516C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82395170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82395178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82395178 size=100
    let mut pc: u32 = 0x82395178;
    'dispatch: loop {
        match pc {
            0x82395178 => {
    //   block [0x82395178..0x823951DC)
	// 82395178: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823951E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823951E0 size=76
    let mut pc: u32 = 0x823951E0;
    'dispatch: loop {
        match pc {
            0x823951E0 => {
    //   block [0x823951E0..0x8239522C)
	// 823951E0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82395230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82395230 size=220
    let mut pc: u32 = 0x82395230;
    'dispatch: loop {
        match pc {
            0x82395230 => {
    //   block [0x82395230..0x8239530C)
	// 82395230: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82395310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82395310 size=212
    let mut pc: u32 = 0x82395310;
    'dispatch: loop {
        match pc {
            0x82395310 => {
    //   block [0x82395310..0x823953E4)
	// 82395310: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823953E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823953E8 size=92
    let mut pc: u32 = 0x823953E8;
    'dispatch: loop {
        match pc {
            0x823953E8 => {
    //   block [0x823953E8..0x82395444)
	// 823953E8: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82395448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82395448 size=48
    let mut pc: u32 = 0x82395448;
    'dispatch: loop {
        match pc {
            0x82395448 => {
    //   block [0x82395448..0x82395478)
	// 82395448: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82395478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82395478 size=212
    let mut pc: u32 = 0x82395478;
    'dispatch: loop {
        match pc {
            0x82395478 => {
    //   block [0x82395478..0x8239554C)
	// 82395478: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82395550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82395550 size=168
    let mut pc: u32 = 0x82395550;
    'dispatch: loop {
        match pc {
            0x82395550 => {
    //   block [0x82395550..0x823955F8)
	// 82395550: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823955F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823955F8 size=204
    let mut pc: u32 = 0x823955F8;
    'dispatch: loop {
        match pc {
            0x823955F8 => {
    //   block [0x823955F8..0x823956C4)
	// 823955F8: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823956C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823956C8 size=160
    let mut pc: u32 = 0x823956C8;
    'dispatch: loop {
        match pc {
            0x823956C8 => {
    //   block [0x823956C8..0x82395768)
	// 823956C8: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82395768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82395768 size=368
    let mut pc: u32 = 0x82395768;
    'dispatch: loop {
        match pc {
            0x82395768 => {
    //   block [0x82395768..0x823957FC)
	// 82395768: 3946FFFD  addi r10, r6, -3
	ctx.r[10].s64 = ctx.r[6].s64 + -3;
	// 8239576C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82395770: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 82395774: 40990088  ble cr6, 0x823957fc
	if !ctx.cr[6].gt {
	pc = 0x823957FC; continue 'dispatch;
	}
	// 82395778: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8239577C: 794AF082  rldicl r10, r10, 0x3e, 2
	ctx.r[10].u64 = ctx.r[10].u64 & 0x0000000000000003u64;
	// 82395780: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	pc = 0x823957FC; continue 'dispatch;
            }
            0x823957FC => {
    //   block [0x823957FC..0x823958D8)
	// 823957FC: 78CA07A0  clrldi r10, r6, 0x3e
	ctx.r[10].u64 = ctx.r[6].u64 & 0x0000000000000003u64;
	// 82395800: 2B2A0001  cmpldi cr6, r10, 1
	ctx.cr[6].compare_u64(ctx.r[10].u64, 1, &mut ctx.xer);
	// 82395804: 419A0120  beq cr6, 0x82395924
	if ctx.cr[6].eq {
		sub_823958D8(ctx, base);
		return;
	}
	// 82395808: 2B2A0002  cmpldi cr6, r10, 2
	ctx.cr[6].compare_u64(ctx.r[10].u64, 2, &mut ctx.xer);
	// 8239580C: 419A00CC  beq cr6, 0x823958d8
	if ctx.cr[6].eq {
		sub_823958D8(ctx, base);
		return;
	}
	// 82395810: 2B2A0003  cmpldi cr6, r10, 3
	ctx.cr[6].compare_u64(ctx.r[10].u64, 3, &mut ctx.xer);
	// 82395814: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


