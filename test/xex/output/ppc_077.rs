pub fn sub_828B4D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B4D28 size=532
    let mut pc: u32 = 0x828B4D28;
    'dispatch: loop {
        match pc {
            0x828B4D28 => {
    //   block [0x828B4D28..0x828B4E18)
	// 828B4D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4D2C: 483F46CD  bl 0x82ca93f8
	ctx.lr = 0x828B4D30;
	sub_82CA93D0(ctx, base);
	// 828B4D30: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 828B4D34: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828B4D38: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B4D3C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828B4D40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B4D44: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828B4D48: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 828B4D4C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828B4D50: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 828B4D54: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 828B4D58: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828B4D5C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B4D60: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4D64: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828B4D68: 4BD4C681  bl 0x826013e8
	ctx.lr = 0x828B4D6C;
	sub_826013E8(ctx, base);
	// 828B4D6C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828B4D70: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 828B4D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B4D78: 419A01B0  beq cr6, 0x828b4f28
	if ctx.cr[6].eq {
	pc = 0x828B4F28; continue 'dispatch;
	}
	// 828B4D7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B4D80: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B4D84: 3B8B9490  addi r28, r11, -0x6b70
	ctx.r[28].s64 = ctx.r[11].s64 + -27504;
	// 828B4D88: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B4D8C: C3DCFFF4  lfs f30, -0xc(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828B4D90: D3DB0000  stfs f30, 0(r27)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828B4D94: 419A0194  beq cr6, 0x828b4f28
	if ctx.cr[6].eq {
	pc = 0x828B4F28; continue 'dispatch;
	}
	// 828B4D98: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4D9C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4DA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4DA4: 48031385  bl 0x828e6128
	ctx.lr = 0x828B4DA8;
	sub_828E6128(ctx, base);
	// 828B4DA8: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B4DAC: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 828B4DB0: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828B4DB4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4DB8: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4DBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4DC0: 48031441  bl 0x828e6200
	ctx.lr = 0x828B4DC4;
	sub_828E6200(ctx, base);
	// 828B4DC4: D03B0000  stfs f1, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828B4DC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4DCC: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4DD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4DD4: 480313BD  bl 0x828e6190
	ctx.lr = 0x828B4DD8;
	sub_828E6190(ctx, base);
	// 828B4DD8: C19F0018  lfs f12, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828B4DDC: ED610332  fmuls f11, f1, f12
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 828B4DE0: D17F0018  stfs f11, 0x18(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828B4DE4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B4DE8: C3FC0000  lfs f31, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B4DEC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4DF0: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828B4DF4: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4DF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4DFC: 838BC8B0  lwz r28, -0x3750(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14160 as u32) ) } as u64;
	// 828B4E00: 48031289  bl 0x828e6088
	ctx.lr = 0x828B4E04;
	sub_828E6088(ctx, base);
	// 828B4E04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B4E08: 419A0010  beq cr6, 0x828b4e18
	if ctx.cr[6].eq {
	pc = 0x828B4E18; continue 'dispatch;
	}
	// 828B4E0C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B4E10: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B4E14: 4B930A65  bl 0x821e5878
	ctx.lr = 0x828B4E18;
	sub_821E5878(ctx, base);
	pc = 0x828B4E18; continue 'dispatch;
            }
            0x828B4E18 => {
    //   block [0x828B4E18..0x828B4E58)
	// 828B4E18: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B4E1C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B4E20: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B4E24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4E28: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 828B4E2C: D19F0014  stfs f12, 0x14(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828B4E30: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4E34: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828B4E38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4E3C: 838BC8A8  lwz r28, -0x3758(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14168 as u32) ) } as u64;
	// 828B4E40: 48031249  bl 0x828e6088
	ctx.lr = 0x828B4E44;
	sub_828E6088(ctx, base);
	// 828B4E44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B4E48: 419A0010  beq cr6, 0x828b4e58
	if ctx.cr[6].eq {
	pc = 0x828B4E58; continue 'dispatch;
	}
	// 828B4E4C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B4E50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B4E54: 4B930A25  bl 0x821e5878
	ctx.lr = 0x828B4E58;
	sub_821E5878(ctx, base);
	pc = 0x828B4E58; continue 'dispatch;
            }
            0x828B4E58 => {
    //   block [0x828B4E58..0x828B4E98)
	// 828B4E58: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B4E5C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B4E60: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B4E64: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4E68: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 828B4E6C: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828B4E70: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4E74: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828B4E78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4E7C: 838BC8AC  lwz r28, -0x3754(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14164 as u32) ) } as u64;
	// 828B4E80: 48031209  bl 0x828e6088
	ctx.lr = 0x828B4E84;
	sub_828E6088(ctx, base);
	// 828B4E84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B4E88: 419A0010  beq cr6, 0x828b4e98
	if ctx.cr[6].eq {
	pc = 0x828B4E98; continue 'dispatch;
	}
	// 828B4E8C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B4E90: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B4E94: 4B9309E5  bl 0x821e5878
	ctx.lr = 0x828B4E98;
	sub_821E5878(ctx, base);
	pc = 0x828B4E98; continue 'dispatch;
            }
            0x828B4E98 => {
    //   block [0x828B4E98..0x828B4EE4)
	// 828B4E98: C01F001C  lfs f0, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B4E9C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B4EA0: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B4EA4: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 828B4EA8: D19F001C  stfs f12, 0x1c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828B4EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B4EB0: 419A003C  beq cr6, 0x828b4eec
	if ctx.cr[6].eq {
	pc = 0x828B4EEC; continue 'dispatch;
	}
	// 828B4EB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828B4EB8: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 828B4EBC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B4EC0: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B4EC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B4EC8: 83CBC8A0  lwz r30, -0x3760(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14176 as u32) ) } as u64;
	// 828B4ECC: 480311BD  bl 0x828e6088
	ctx.lr = 0x828B4ED0;
	sub_828E6088(ctx, base);
	// 828B4ED0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B4ED4: 419A0010  beq cr6, 0x828b4ee4
	if ctx.cr[6].eq {
	pc = 0x828B4EE4; continue 'dispatch;
	}
	// 828B4ED8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B4EDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B4EE0: 4814B4D1  bl 0x82a003b0
	ctx.lr = 0x828B4EE4;
	sub_82A003B0(ctx, base);
	pc = 0x828B4EE4; continue 'dispatch;
            }
            0x828B4EE4 => {
    //   block [0x828B4EE4..0x828B4EEC)
	// 828B4EE4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B4EE8: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	pc = 0x828B4EEC; continue 'dispatch;
            }
            0x828B4EEC => {
    //   block [0x828B4EEC..0x828B4F28)
	// 828B4EEC: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 828B4EF0: 38A10051  addi r5, r1, 0x51
	ctx.r[5].s64 = ctx.r[1].s64 + 81;
	// 828B4EF4: 9B410051  stb r26, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[26].u8 ) };
	// 828B4EF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B4EFC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828B4F00: 4BD48529  bl 0x825fd428
	ctx.lr = 0x828B4F04;
	sub_825FD428(ctx, base);
	// 828B4F04: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B4F08: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828B4F0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B4F10: 419A001C  beq cr6, 0x828b4f2c
	if ctx.cr[6].eq {
	pc = 0x828B4F2C; continue 'dispatch;
	}
	// 828B4F14: D3DB0000  stfs f30, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828B4F18: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828B4F1C: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828B4F20: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828B4F24: 483F4524  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x828B4F28 => {
    //   block [0x828B4F28..0x828B4F2C)
	// 828B4F28: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x828B4F2C; continue 'dispatch;
            }
            0x828B4F2C => {
    //   block [0x828B4F2C..0x828B4F3C)
	// 828B4F2C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828B4F30: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828B4F34: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828B4F38: 483F4510  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B4F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B4F40 size=456
    let mut pc: u32 = 0x828B4F40;
    'dispatch: loop {
        match pc {
            0x828B4F40 => {
    //   block [0x828B4F40..0x828B4FDC)
	// 828B4F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B4F44: 483F448D  bl 0x82ca93d0
	ctx.lr = 0x828B4F48;
	sub_82CA93D0(ctx, base);
	// 828B4F48: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B4F4C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B4F50: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828B4F54: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 828B4F58: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 828B4F5C: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 828B4F60: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 828B4F64: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B4F68: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 828B4F6C: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 828B4F70: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828B4F74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B4F78: 813A6C10  lwz r9, 0x6c10(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27664 as u32) ) } as u64;
	// 828B4F7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B4F80: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B4F84: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 828B4F88: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 828B4F8C: 93FA6C10  stw r31, 0x6c10(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 828B4F90: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B4F94: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B4F98: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 828B4F9C: 82A90064  lwz r21, 0x64(r9)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B4FA0: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 828B4FA4: 4B9B0A85  bl 0x82265a28
	ctx.lr = 0x828B4FA8;
	sub_82265A28(ctx, base);
	// 828B4FA8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B4FAC: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828B4FB0: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 828B4FB4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B4FB8: 40990148  ble cr6, 0x828b5100
	if !ctx.cr[6].gt {
	pc = 0x828B5100; continue 'dispatch;
	}
	// 828B4FBC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828B4FC0: 7E96A378  mr r22, r20
	ctx.r[22].u64 = ctx.r[20].u64;
	// 828B4FC4: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828B4FC8: 3A0BFFFF  addi r16, r11, -1
	ctx.r[16].s64 = ctx.r[11].s64 + -1;
	// 828B4FCC: 81C10064  lwz r14, 0x64(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B4FD0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828B4FD4: 39EAFFFF  addi r15, r10, -1
	ctx.r[15].s64 = ctx.r[10].s64 + -1;
	// 828B4FD8: 3A2BA2F8  addi r17, r11, -0x5d08
	ctx.r[17].s64 = ctx.r[11].s64 + -23816;
	pc = 0x828B4FDC; continue 'dispatch;
            }
            0x828B4FDC => {
    //   block [0x828B4FDC..0x828B501C)
	// 828B4FDC: 39710004  addi r11, r17, 4
	ctx.r[11].s64 = ctx.r[17].s64 + 4;
	// 828B4FE0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B4FE4: 7D16582E  lwzx r8, r22, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B4FE8: 7D5C4630  sraw r28, r10, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 828B4FEC: 7DCA4630  sraw r10, r14, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[14].s32 < 0) && ((ctx.r[14].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[14].s32 >> tmp.u32) as i64;
	// 828B4FF0: 7E0B4630  sraw r11, r16, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[16].s32 < 0) && ((ctx.r[16].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[16].s32 >> tmp.u32) as i64;
	// 828B4FF4: 3B2B0001  addi r25, r11, 1
	ctx.r[25].s64 = ctx.r[11].s64 + 1;
	// 828B4FF8: 7DEB4630  sraw r11, r15, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[15].s32 < 0) && ((ctx.r[15].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[15].s32 >> tmp.u32) as i64;
	// 828B4FFC: 7E7CC851  subf. r19, r28, r25
	ctx.r[19].s64 = ctx.r[25].s64 - ctx.r[28].s64;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 828B5000: 3A4B0001  addi r18, r11, 1
	ctx.r[18].s64 = ctx.r[11].s64 + 1;
	// 828B5004: 418200E0  beq 0x828b50e4
	if ctx.cr[0].eq {
	pc = 0x828B50E4; continue 'dispatch;
	}
	// 828B5008: 7D6A9051  subf. r11, r10, r18
	ctx.r[11].s64 = ctx.r[18].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B500C: 418200D8  beq 0x828b50e4
	if ctx.cr[0].eq {
	pc = 0x828B50E4; continue 'dispatch;
	}
	// 828B5010: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 828B5014: 7F0A9000  cmpw cr6, r10, r18
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828B5018: 409800CC  bge cr6, 0x828b50e4
	if !ctx.cr[6].lt {
	pc = 0x828B50E4; continue 'dispatch;
	}
	pc = 0x828B501C; continue 'dispatch;
            }
            0x828B501C => {
    //   block [0x828B501C..0x828B5050)
	// 828B501C: 81750008  lwz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B5020: 7F1CC800  cmpw cr6, r28, r25
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[25].s32, &mut ctx.xer);
	// 828B5024: 81550018  lwz r10, 0x18(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B5028: 7D745A14  add r11, r20, r11
	ctx.r[11].u64 = ctx.r[20].u64 + ctx.r[11].u64;
	// 828B502C: 7D4AB214  add r10, r10, r22
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[22].u64;
	// 828B5030: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5034: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5038: 7D69B9D6  mullw r11, r9, r23
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[23].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 828B503C: 7D0BE214  add r8, r11, r28
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828B5040: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B5044: 7F6B5214  add r27, r11, r10
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B5048: 40980088  bge cr6, 0x828b50d0
	if !ctx.cr[6].lt {
	pc = 0x828B50D0; continue 'dispatch;
	}
	// 828B504C: 7E789B78  mr r24, r19
	ctx.r[24].u64 = ctx.r[19].u64;
	pc = 0x828B5050; continue 'dispatch;
            }
            0x828B5050 => {
    //   block [0x828B5050..0x828B505C)
	// 828B5050: 83DB0000  lwz r30, 0(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5054: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B5058: 419A006C  beq cr6, 0x828b50c4
	if ctx.cr[6].eq {
	pc = 0x828B50C4; continue 'dispatch;
	}
	pc = 0x828B505C; continue 'dispatch;
            }
            0x828B505C => {
    //   block [0x828B505C..0x828B50B4)
	// 828B505C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5060: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B5064: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828B5068: 40980050  bge cr6, 0x828b50b8
	if !ctx.cr[6].lt {
	pc = 0x828B50B8; continue 'dispatch;
	}
	// 828B506C: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 828B5070: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5074: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B507C: 4B94E565  bl 0x822035e0
	ctx.lr = 0x828B5080;
	sub_822035E0(ctx, base);
	// 828B5080: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B5084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5088: 419A002C  beq cr6, 0x828b50b4
	if ctx.cr[6].eq {
	pc = 0x828B50B4; continue 'dispatch;
	}
	// 828B508C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5090: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5094: 4BFFEC25  bl 0x828b3cb8
	ctx.lr = 0x828B5098;
	sub_828B3CB8(ctx, base);
	// 828B5098: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B509C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B50A0: 419A0014  beq cr6, 0x828b50b4
	if ctx.cr[6].eq {
	pc = 0x828B50B4; continue 'dispatch;
	}
	// 828B50A4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828B50A8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B50AC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B50B0: 482946A1  bl 0x82b49750
	ctx.lr = 0x828B50B4;
	sub_82B49750(ctx, base);
	pc = 0x828B50B4; continue 'dispatch;
            }
            0x828B50B4 => {
    //   block [0x828B50B4..0x828B50B8)
	// 828B50B4: 83FA6C10  lwz r31, 0x6c10(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x828B50B8; continue 'dispatch;
            }
            0x828B50B8 => {
    //   block [0x828B50B8..0x828B50C4)
	// 828B50B8: 83DE0004  lwz r30, 4(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B50BC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B50C0: 409AFF9C  bne cr6, 0x828b505c
	if !ctx.cr[6].eq {
	pc = 0x828B505C; continue 'dispatch;
	}
	pc = 0x828B50C4; continue 'dispatch;
            }
            0x828B50C4 => {
    //   block [0x828B50C4..0x828B50D0)
	// 828B50C4: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 828B50C8: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 828B50CC: 4082FF84  bne 0x828b5050
	if !ctx.cr[0].eq {
	pc = 0x828B5050; continue 'dispatch;
	}
	pc = 0x828B50D0; continue 'dispatch;
            }
            0x828B50D0 => {
    //   block [0x828B50D0..0x828B50E4)
	// 828B50D0: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 828B50D4: 7F179000  cmpw cr6, r23, r18
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828B50D8: 4198FF44  blt cr6, 0x828b501c
	if ctx.cr[6].lt {
	pc = 0x828B501C; continue 'dispatch;
	}
	// 828B50DC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B50E0: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x828B50E4; continue 'dispatch;
            }
            0x828B50E4 => {
    //   block [0x828B50E4..0x828B5100)
	// 828B50E4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B50E8: 3A940014  addi r20, r20, 0x14
	ctx.r[20].s64 = ctx.r[20].s64 + 20;
	// 828B50EC: 3AD60010  addi r22, r22, 0x10
	ctx.r[22].s64 = ctx.r[22].s64 + 16;
	// 828B50F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B50F4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B50F8: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828B50FC: 4198FEE0  blt cr6, 0x828b4fdc
	if ctx.cr[6].lt {
	pc = 0x828B4FDC; continue 'dispatch;
	}
	pc = 0x828B5100; continue 'dispatch;
            }
            0x828B5100 => {
    //   block [0x828B5100..0x828B5108)
	// 828B5100: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828B5104: 483F431C  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B5108 size=456
    let mut pc: u32 = 0x828B5108;
    'dispatch: loop {
        match pc {
            0x828B5108 => {
    //   block [0x828B5108..0x828B51A4)
	// 828B5108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B510C: 483F42C5  bl 0x82ca93d0
	ctx.lr = 0x828B5110;
	sub_82CA93D0(ctx, base);
	// 828B5110: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5114: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5118: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828B511C: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 828B5120: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 828B5124: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 828B5128: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 828B512C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5130: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 828B5134: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 828B5138: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828B513C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5140: 813A6C10  lwz r9, 0x6c10(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27664 as u32) ) } as u64;
	// 828B5144: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B5148: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B514C: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 828B5150: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 828B5154: 93FA6C10  stw r31, 0x6c10(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 828B5158: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B515C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5160: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 828B5164: 82A90064  lwz r21, 0x64(r9)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B5168: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 828B516C: 4B9B08BD  bl 0x82265a28
	ctx.lr = 0x828B5170;
	sub_82265A28(ctx, base);
	// 828B5170: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B5174: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828B5178: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 828B517C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B5180: 40990148  ble cr6, 0x828b52c8
	if !ctx.cr[6].gt {
	pc = 0x828B52C8; continue 'dispatch;
	}
	// 828B5184: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828B5188: 7E96A378  mr r22, r20
	ctx.r[22].u64 = ctx.r[20].u64;
	// 828B518C: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828B5190: 3A0BFFFF  addi r16, r11, -1
	ctx.r[16].s64 = ctx.r[11].s64 + -1;
	// 828B5194: 81C10064  lwz r14, 0x64(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B5198: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828B519C: 39EAFFFF  addi r15, r10, -1
	ctx.r[15].s64 = ctx.r[10].s64 + -1;
	// 828B51A0: 3A2BA2F8  addi r17, r11, -0x5d08
	ctx.r[17].s64 = ctx.r[11].s64 + -23816;
	pc = 0x828B51A4; continue 'dispatch;
            }
            0x828B51A4 => {
    //   block [0x828B51A4..0x828B51E4)
	// 828B51A4: 39710004  addi r11, r17, 4
	ctx.r[11].s64 = ctx.r[17].s64 + 4;
	// 828B51A8: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B51AC: 7D16582E  lwzx r8, r22, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B51B0: 7D5C4630  sraw r28, r10, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 828B51B4: 7DCA4630  sraw r10, r14, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[14].s32 < 0) && ((ctx.r[14].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[14].s32 >> tmp.u32) as i64;
	// 828B51B8: 7E0B4630  sraw r11, r16, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[16].s32 < 0) && ((ctx.r[16].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[16].s32 >> tmp.u32) as i64;
	// 828B51BC: 3B2B0001  addi r25, r11, 1
	ctx.r[25].s64 = ctx.r[11].s64 + 1;
	// 828B51C0: 7DEB4630  sraw r11, r15, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[15].s32 < 0) && ((ctx.r[15].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[15].s32 >> tmp.u32) as i64;
	// 828B51C4: 7E7CC851  subf. r19, r28, r25
	ctx.r[19].s64 = ctx.r[25].s64 - ctx.r[28].s64;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 828B51C8: 3A4B0001  addi r18, r11, 1
	ctx.r[18].s64 = ctx.r[11].s64 + 1;
	// 828B51CC: 418200E0  beq 0x828b52ac
	if ctx.cr[0].eq {
	pc = 0x828B52AC; continue 'dispatch;
	}
	// 828B51D0: 7D6A9051  subf. r11, r10, r18
	ctx.r[11].s64 = ctx.r[18].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B51D4: 418200D8  beq 0x828b52ac
	if ctx.cr[0].eq {
	pc = 0x828B52AC; continue 'dispatch;
	}
	// 828B51D8: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 828B51DC: 7F0A9000  cmpw cr6, r10, r18
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828B51E0: 409800CC  bge cr6, 0x828b52ac
	if !ctx.cr[6].lt {
	pc = 0x828B52AC; continue 'dispatch;
	}
	pc = 0x828B51E4; continue 'dispatch;
            }
            0x828B51E4 => {
    //   block [0x828B51E4..0x828B5218)
	// 828B51E4: 81750008  lwz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B51E8: 7F1CC800  cmpw cr6, r28, r25
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[25].s32, &mut ctx.xer);
	// 828B51EC: 81550018  lwz r10, 0x18(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B51F0: 7D745A14  add r11, r20, r11
	ctx.r[11].u64 = ctx.r[20].u64 + ctx.r[11].u64;
	// 828B51F4: 7D4AB214  add r10, r10, r22
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[22].u64;
	// 828B51F8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B51FC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5200: 7D69B9D6  mullw r11, r9, r23
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[23].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 828B5204: 7D0BE214  add r8, r11, r28
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828B5208: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B520C: 7F6B5214  add r27, r11, r10
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B5210: 40980088  bge cr6, 0x828b5298
	if !ctx.cr[6].lt {
	pc = 0x828B5298; continue 'dispatch;
	}
	// 828B5214: 7E789B78  mr r24, r19
	ctx.r[24].u64 = ctx.r[19].u64;
	pc = 0x828B5218; continue 'dispatch;
            }
            0x828B5218 => {
    //   block [0x828B5218..0x828B5224)
	// 828B5218: 83DB0000  lwz r30, 0(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B521C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B5220: 419A006C  beq cr6, 0x828b528c
	if ctx.cr[6].eq {
	pc = 0x828B528C; continue 'dispatch;
	}
	pc = 0x828B5224; continue 'dispatch;
            }
            0x828B5224 => {
    //   block [0x828B5224..0x828B527C)
	// 828B5224: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5228: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B522C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828B5230: 40980050  bge cr6, 0x828b5280
	if !ctx.cr[6].lt {
	pc = 0x828B5280; continue 'dispatch;
	}
	// 828B5234: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 828B5238: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B523C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5244: 4B94E39D  bl 0x822035e0
	ctx.lr = 0x828B5248;
	sub_822035E0(ctx, base);
	// 828B5248: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B524C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5250: 419A002C  beq cr6, 0x828b527c
	if ctx.cr[6].eq {
	pc = 0x828B527C; continue 'dispatch;
	}
	// 828B5254: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5258: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B525C: 4BFFE44D  bl 0x828b36a8
	ctx.lr = 0x828B5260;
	sub_828B36A8(ctx, base);
	// 828B5260: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B5264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5268: 419A0014  beq cr6, 0x828b527c
	if ctx.cr[6].eq {
	pc = 0x828B527C; continue 'dispatch;
	}
	// 828B526C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828B5270: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B5274: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B5278: 482944D9  bl 0x82b49750
	ctx.lr = 0x828B527C;
	sub_82B49750(ctx, base);
	pc = 0x828B527C; continue 'dispatch;
            }
            0x828B527C => {
    //   block [0x828B527C..0x828B5280)
	// 828B527C: 83FA6C10  lwz r31, 0x6c10(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x828B5280; continue 'dispatch;
            }
            0x828B5280 => {
    //   block [0x828B5280..0x828B528C)
	// 828B5280: 83DE0004  lwz r30, 4(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5284: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B5288: 409AFF9C  bne cr6, 0x828b5224
	if !ctx.cr[6].eq {
	pc = 0x828B5224; continue 'dispatch;
	}
	pc = 0x828B528C; continue 'dispatch;
            }
            0x828B528C => {
    //   block [0x828B528C..0x828B5298)
	// 828B528C: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 828B5290: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 828B5294: 4082FF84  bne 0x828b5218
	if !ctx.cr[0].eq {
	pc = 0x828B5218; continue 'dispatch;
	}
	pc = 0x828B5298; continue 'dispatch;
            }
            0x828B5298 => {
    //   block [0x828B5298..0x828B52AC)
	// 828B5298: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 828B529C: 7F179000  cmpw cr6, r23, r18
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828B52A0: 4198FF44  blt cr6, 0x828b51e4
	if ctx.cr[6].lt {
	pc = 0x828B51E4; continue 'dispatch;
	}
	// 828B52A4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B52A8: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x828B52AC; continue 'dispatch;
            }
            0x828B52AC => {
    //   block [0x828B52AC..0x828B52C8)
	// 828B52AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B52B0: 3A940014  addi r20, r20, 0x14
	ctx.r[20].s64 = ctx.r[20].s64 + 20;
	// 828B52B4: 3AD60010  addi r22, r22, 0x10
	ctx.r[22].s64 = ctx.r[22].s64 + 16;
	// 828B52B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B52BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B52C0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828B52C4: 4198FEE0  blt cr6, 0x828b51a4
	if ctx.cr[6].lt {
	pc = 0x828B51A4; continue 'dispatch;
	}
	pc = 0x828B52C8; continue 'dispatch;
            }
            0x828B52C8 => {
    //   block [0x828B52C8..0x828B52D0)
	// 828B52C8: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828B52CC: 483F4154  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B52D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B52D0 size=236
    let mut pc: u32 = 0x828B52D0;
    'dispatch: loop {
        match pc {
            0x828B52D0 => {
    //   block [0x828B52D0..0x828B53BC)
	// 828B52D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B52D4: 483F412D  bl 0x82ca9400
	ctx.lr = 0x828B52D8;
	sub_82CA93D0(ctx, base);
	// 828B52D8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B52DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B52E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B52E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B52E8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B52EC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828B52F0: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828B52F4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828B52F8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828B52FC: 390A53C0  addi r8, r10, 0x53c0
	ctx.r[8].s64 = ctx.r[10].s64 + 21440;
	// 828B5300: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 828B5304: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 828B5308: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 828B530C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828B5310: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 828B5314: 387F002C  addi r3, r31, 0x2c
	ctx.r[3].s64 = ctx.r[31].s64 + 44;
	// 828B5318: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 828B531C: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 828B5320: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 828B5324: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 828B5328: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828B532C: 80FC0000  lwz r7, 0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5330: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5334: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 828B5338: 4E800421  bctrl
	ctx.lr = 0x828B533C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B533C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828B5340: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 828B5344: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828B5348: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 828B534C: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 828B5350: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828B5354: 38800160  li r4, 0x160
	ctx.r[4].s64 = 352;
	// 828B5358: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B535C: 7C63582E  lwzx r3, r3, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B5360: 4849FEE9  bl 0x82d55248
	ctx.lr = 0x828B5364;
	sub_82D55248(ctx, base);
	// 828B5364: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B5368: 39400160  li r10, 0x160
	ctx.r[10].s64 = 352;
	// 828B536C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B5370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B5374: 535D801E  rlwimi r29, r26, 0x10, 0, 0xf
	ctx.r[29].u64 = (((ctx.r[26].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[29].u64 & 0xFFFFFFFF0000FFFF);
	// 828B5378: B15E0004  sth r10, 4(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 828B537C: 4B9E5EFD  bl 0x8229b278
	ctx.lr = 0x828B5380;
	sub_8229B278(ctx, base);
	// 828B5380: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5384: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828B5388: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B538C: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B5390: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828B5394: 4E800421  bctrl
	ctx.lr = 0x828B5398;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B5398: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B539C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B53A0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828B53A4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828B53A8: 484CA691  bl 0x82d7fa38
	ctx.lr = 0x828B53AC;
	sub_82D7FA38(ctx, base);
	// 828B53AC: 907F0034  stw r3, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[3].u32 ) };
	// 828B53B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B53B4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828B53B8: 483F4098  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B53C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B53C0 size=80
    let mut pc: u32 = 0x828B53C0;
    'dispatch: loop {
        match pc {
            0x828B53C0 => {
    //   block [0x828B53C0..0x828B53F8)
	// 828B53C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B53C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B53C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B53CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B53D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B53D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B53D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B53DC: 48000035  bl 0x828b5410
	ctx.lr = 0x828B53E0;
	sub_828B5410(ctx, base);
	// 828B53E0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828B53E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B53E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B53EC: 419A000C  beq cr6, 0x828b53f8
	if ctx.cr[6].eq {
	pc = 0x828B53F8; continue 'dispatch;
	}
	// 828B53F0: 4B966949  bl 0x8221bd38
	ctx.lr = 0x828B53F4;
	sub_8221BD38(ctx, base);
	// 828B53F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x828B53F8; continue 'dispatch;
            }
            0x828B53F8 => {
    //   block [0x828B53F8..0x828B5410)
	// 828B53F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B53FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B5400: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B5404: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B5408: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B540C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5410 size=104
    let mut pc: u32 = 0x828B5410;
    'dispatch: loop {
        match pc {
            0x828B5410 => {
    //   block [0x828B5410..0x828B5478)
	// 828B5410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5414: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B5418: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B541C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B5420: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5424: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5428: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B542C: 394B53C0  addi r10, r11, 0x53c0
	ctx.r[10].s64 = ctx.r[11].s64 + 21440;
	// 828B5430: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B5434: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828B5438: 484CAFA9  bl 0x82d803e0
	ctx.lr = 0x828B543C;
	sub_82D803E0(ctx, base);
	// 828B543C: 3BDF002C  addi r30, r31, 0x2c
	ctx.r[30].s64 = ctx.r[31].s64 + 44;
	// 828B5440: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B5444: 4B9026D5  bl 0x821b7b18
	ctx.lr = 0x828B5448;
	sub_821B7B18(ctx, base);
	// 828B5448: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828B544C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B5450: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 828B5454: 4B9026C5  bl 0x821b7b18
	ctx.lr = 0x828B5458;
	sub_821B7B18(ctx, base);
	// 828B5458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B545C: 4BB66B65  bl 0x8241bfc0
	ctx.lr = 0x828B5460;
	sub_8241BFC0(ctx, base);
	// 828B5460: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B5464: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B5468: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B546C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B5470: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B5474: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828B5478 size=48
    let mut pc: u32 = 0x828B5478;
    'dispatch: loop {
        match pc {
            0x828B5478 => {
    //   block [0x828B5478..0x828B54A8)
	// 828B5478: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B547C: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 828B5480: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828B5484: 39099160  addi r8, r9, -0x6ea0
	ctx.r[8].s64 = ctx.r[9].s64 + -28320;
	// 828B5488: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B548C: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B54A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B54A8 size=20
    let mut pc: u32 = 0x828B54A8;
    'dispatch: loop {
        match pc {
            0x828B54A8 => {
    //   block [0x828B54A8..0x828B54BC)
	// 828B54A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B54AC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828B54B0: 908B0010  stw r4, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 828B54B4: 808B0034  lwz r4, 0x34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828B54B8: 484C3FA0  b 0x82d79458
	sub_82D79458(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B54C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B54C0 size=24
    let mut pc: u32 = 0x828B54C0;
    'dispatch: loop {
        match pc {
            0x828B54C0 => {
    //   block [0x828B54C0..0x828B54D8)
	// 828B54C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B54C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B54C8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828B54CC: 808B0034  lwz r4, 0x34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828B54D0: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828B54D4: 484C2AC4  b 0x82d77f98
	sub_82D77F98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B54D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B54D8 size=8
    let mut pc: u32 = 0x828B54D8;
    'dispatch: loop {
        match pc {
            0x828B54D8 => {
    //   block [0x828B54D8..0x828B54E0)
	// 828B54D8: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 828B54DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B54E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B54E0 size=60
    let mut pc: u32 = 0x828B54E0;
    'dispatch: loop {
        match pc {
            0x828B54E0 => {
    //   block [0x828B54E0..0x828B551C)
	// 828B54E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B54E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B54E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B54EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B54F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B54F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B54F8: 388B9484  addi r4, r11, -0x6b7c
	ctx.r[4].s64 = ctx.r[11].s64 + -27516;
	// 828B54FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5500: 4B9779D1  bl 0x8222ced0
	ctx.lr = 0x828B5504;
	sub_8222CED0(ctx, base);
	// 828B5504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5508: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B550C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B5510: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B5514: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B5518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5520 size=104
    let mut pc: u32 = 0x828B5520;
    'dispatch: loop {
        match pc {
            0x828B5520 => {
    //   block [0x828B5520..0x828B5554)
	// 828B5520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5524: 483F3EE9  bl 0x82ca940c
	ctx.lr = 0x828B5528;
	sub_82CA93D0(ctx, base);
	// 828B5528: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B552C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5530: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828B5534: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 828B5538: 4B9025E1  bl 0x821b7b18
	ctx.lr = 0x828B553C;
	sub_821B7B18(ctx, base);
	// 828B553C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B5540: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 828B5544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5548: 419A000C  beq cr6, 0x828b5554
	if ctx.cr[6].eq {
	pc = 0x828B5554; continue 'dispatch;
	}
	// 828B554C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B5550: 4BEAF871  bl 0x82764dc0
	ctx.lr = 0x828B5554;
	sub_82764DC0(ctx, base);
	pc = 0x828B5554; continue 'dispatch;
            }
            0x828B5554 => {
    //   block [0x828B5554..0x828B5580)
	// 828B5554: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828B5558: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B555C: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 828B5560: 57A807FE  clrlwi r8, r29, 0x1f
	ctx.r[8].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 828B5564: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B5568: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B556C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5570: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828B5574: 419A000C  beq cr6, 0x828b5580
	if ctx.cr[6].eq {
	pc = 0x828B5580; continue 'dispatch;
	}
	// 828B5578: 4B9667C1  bl 0x8221bd38
	ctx.lr = 0x828B557C;
	sub_8221BD38(ctx, base);
	// 828B557C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x828B5580; continue 'dispatch;
            }
            0x828B5580 => {
    //   block [0x828B5580..0x828B5588)
	// 828B5580: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B5584: 483F3ED8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5588 size=760
    let mut pc: u32 = 0x828B5588;
    'dispatch: loop {
        match pc {
            0x828B5588 => {
    //   block [0x828B5588..0x828B5660)
	// 828B5588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B558C: 483F3E79  bl 0x82ca9404
	ctx.lr = 0x828B5590;
	sub_82CA93D0(ctx, base);
	// 828B5590: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5594: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828B5598: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828B559C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828B55A0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B55A4: 388A2BE0  addi r4, r10, 0x2be0
	ctx.r[4].s64 = ctx.r[10].s64 + 11232;
	// 828B55A8: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B55AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B55B0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828B55B4: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828B55B8: 3BBB000C  addi r29, r27, 0xc
	ctx.r[29].s64 = ctx.r[27].s64 + 12;
	// 828B55BC: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828B55C0: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 828B55C4: 98E10050  stb r7, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u8 ) };
	// 828B55C8: 4B977909  bl 0x8222ced0
	ctx.lr = 0x828B55CC;
	sub_8222CED0(ctx, base);
	// 828B55CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B55D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B55D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B55D8: 48167871  bl 0x82a1ce48
	ctx.lr = 0x828B55DC;
	sub_82A1CE48(ctx, base);
	// 828B55DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B55E0: 4B95F7F9  bl 0x82214dd8
	ctx.lr = 0x828B55E4;
	sub_82214DD8(ctx, base);
	// 828B55E4: 88A10050  lbz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B55E8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828B55EC: 419A028C  beq cr6, 0x828b5878
	if ctx.cr[6].eq {
	pc = 0x828B5878; continue 'dispatch;
	}
	// 828B55F0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B55F4: 57FF063E  clrlwi r31, r31, 0x18
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828B55F8: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828B55FC: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 828B5600: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B5604: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828B5608: 419A0188  beq cr6, 0x828b5790
	if ctx.cr[6].eq {
	pc = 0x828B5790; continue 'dispatch;
	}
	// 828B560C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5610: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828B5614: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B5618: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B561C: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B5620: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5624: E8E80014  ld r7, 0x14(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) };
	// 828B5628: F8E10060  std r7, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[7].u64 ) };
	// 828B562C: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B5630: 80A60058  lwz r5, 0x58(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B5634: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5638: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B563C: 4B9AEE4D  bl 0x82264488
	ctx.lr = 0x828B5640;
	sub_82264488(ctx, base);
	// 828B5640: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B5644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5648: 419A0018  beq cr6, 0x828b5660
	if ctx.cr[6].eq {
	pc = 0x828B5660; continue 'dispatch;
	}
	// 828B564C: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B5650: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828B5654: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B5658: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B565C: 409A0008  bne cr6, 0x828b5664
	if !ctx.cr[6].eq {
	pc = 0x828B5664; continue 'dispatch;
	}
	pc = 0x828B5660; continue 'dispatch;
            }
            0x828B5660 => {
    //   block [0x828B5660..0x828B5664)
	// 828B5660: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x828B5664; continue 'dispatch;
            }
            0x828B5664 => {
    //   block [0x828B5664..0x828B56B0)
	// 828B5664: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B5668: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B566C: 419A0124  beq cr6, 0x828b5790
	if ctx.cr[6].eq {
	pc = 0x828B5790; continue 'dispatch;
	}
	// 828B5670: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B5674: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B5678: 55499FFE  rlwinm r9, r10, 0x13, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00001FFFu64;
	// 828B567C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B5680: 419A00F4  beq cr6, 0x828b5774
	if ctx.cr[6].eq {
	pc = 0x828B5774; continue 'dispatch;
	}
	// 828B5684: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B5688: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B568C: 419A0024  beq cr6, 0x828b56b0
	if ctx.cr[6].eq {
	pc = 0x828B56B0; continue 'dispatch;
	}
	// 828B5690: 894A000D  lbz r10, 0xd(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(13 as u32) ) } as u64;
	// 828B5694: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B5698: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B569C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B56A0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B56A4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B56A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B56AC: 480000CC  b 0x828b5778
	pc = 0x828B5778; continue 'dispatch;
            }
            0x828B56B0 => {
    //   block [0x828B56B0..0x828B56CC)
	// 828B56B0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B56B4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B56B8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828B56BC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B56C0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828B56C4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B56C8: 40810054  ble 0x828b571c
	if !ctx.cr[0].gt {
	pc = 0x828B571C; continue 'dispatch;
	}
	pc = 0x828B56CC; continue 'dispatch;
            }
            0x828B56CC => {
    //   block [0x828B56CC..0x828B56EC)
	// 828B56CC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B56D0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B56D4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B56D8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B56DC: 2F07000D  cmpwi cr6, r7, 0xd
	ctx.cr[6].compare_i32(ctx.r[7].s32, 13, &mut ctx.xer);
	// 828B56E0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B56E4: 41980008  blt cr6, 0x828b56ec
	if ctx.cr[6].lt {
	pc = 0x828B56EC; continue 'dispatch;
	}
	// 828B56E8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x828B56EC; continue 'dispatch;
            }
            0x828B56EC => {
    //   block [0x828B56EC..0x828B5708)
	// 828B56EC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B56F0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B56F4: 419A0014  beq cr6, 0x828b5708
	if ctx.cr[6].eq {
	pc = 0x828B5708; continue 'dispatch;
	}
	// 828B56F8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B56FC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B5700: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B5704: 4800000C  b 0x828b5710
	pc = 0x828B5710; continue 'dispatch;
            }
            0x828B5708 => {
    //   block [0x828B5708..0x828B5710)
	// 828B5708: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B570C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828B5710; continue 'dispatch;
            }
            0x828B5710 => {
    //   block [0x828B5710..0x828B571C)
	// 828B5710: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5714: 4199FFB8  bgt cr6, 0x828b56cc
	if ctx.cr[6].gt {
	pc = 0x828B56CC; continue 'dispatch;
	}
	// 828B5718: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x828B571C; continue 'dispatch;
            }
            0x828B571C => {
    //   block [0x828B571C..0x828B5738)
	// 828B571C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B5720: 419A0040  beq cr6, 0x828b5760
	if ctx.cr[6].eq {
	pc = 0x828B5760; continue 'dispatch;
	}
	// 828B5724: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5728: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 828B572C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5730: 41990008  bgt cr6, 0x828b5738
	if ctx.cr[6].gt {
	pc = 0x828B5738; continue 'dispatch;
	}
	// 828B5734: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828B5738; continue 'dispatch;
            }
            0x828B5738 => {
    //   block [0x828B5738..0x828B5760)
	// 828B5738: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B573C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5740: 409A0020  bne cr6, 0x828b5760
	if !ctx.cr[6].eq {
	pc = 0x828B5760; continue 'dispatch;
	}
	// 828B5744: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828B5748: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828B574C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B5750: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5754: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B5758: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B575C: 4800001C  b 0x828b5778
	pc = 0x828B5778; continue 'dispatch;
            }
            0x828B5760 => {
    //   block [0x828B5760..0x828B5774)
	// 828B5760: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B5764: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5768: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B576C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5770: 48000008  b 0x828b5778
	pc = 0x828B5778; continue 'dispatch;
            }
            0x828B5774 => {
    //   block [0x828B5774..0x828B5778)
	// 828B5774: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828B5778; continue 'dispatch;
            }
            0x828B5778 => {
    //   block [0x828B5778..0x828B5790)
	// 828B5778: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B577C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5780: 419A0010  beq cr6, 0x828b5790
	if ctx.cr[6].eq {
	pc = 0x828B5790; continue 'dispatch;
	}
	// 828B5784: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B5788: 4BC3EBD9  bl 0x824f4360
	ctx.lr = 0x828B578C;
	sub_824F4360(ctx, base);
	// 828B578C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	pc = 0x828B5790; continue 'dispatch;
            }
            0x828B5790 => {
    //   block [0x828B5790..0x828B57E8)
	// 828B5790: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B5794: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B5798: 388B2BE8  addi r4, r11, 0x2be8
	ctx.r[4].s64 = ctx.r[11].s64 + 11240;
	// 828B579C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B57A0: 4B977731  bl 0x8222ced0
	ctx.lr = 0x828B57A4;
	sub_8222CED0(ctx, base);
	// 828B57A4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828B57A8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B57AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B57B0: 4BBFD009  bl 0x824b27b8
	ctx.lr = 0x828B57B4;
	sub_824B27B8(ctx, base);
	// 828B57B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B57B8: 4B95F621  bl 0x82214dd8
	ctx.lr = 0x828B57BC;
	sub_82214DD8(ctx, base);
	// 828B57BC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828B57C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B57C4: 388AD81C  addi r4, r10, -0x27e4
	ctx.r[4].s64 = ctx.r[10].s64 + -10212;
	// 828B57C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B57CC: 4B977705  bl 0x8222ced0
	ctx.lr = 0x828B57D0;
	sub_8222CED0(ctx, base);
	// 828B57D0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B57D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B57D8: 409A0010  bne cr6, 0x828b57e8
	if !ctx.cr[6].eq {
	pc = 0x828B57E8; continue 'dispatch;
	}
	// 828B57DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B57E0: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 828B57E4: 48000008  b 0x828b57ec
	pc = 0x828B57EC; continue 'dispatch;
            }
            0x828B57E8 => {
    //   block [0x828B57E8..0x828B57EC)
	// 828B57E8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828B57EC; continue 'dispatch;
            }
            0x828B57EC => {
    //   block [0x828B57EC..0x828B581C)
	// 828B57EC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B57F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B57F4: 4BBCAFD5  bl 0x824807c8
	ctx.lr = 0x828B57F8;
	sub_824807C8(ctx, base);
	// 828B57F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B57FC: 4B95F5DD  bl 0x82214dd8
	ctx.lr = 0x828B5800;
	sub_82214DD8(ctx, base);
	// 828B5800: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B5804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5808: 409A0014  bne cr6, 0x828b581c
	if !ctx.cr[6].eq {
	pc = 0x828B581C; continue 'dispatch;
	}
	// 828B580C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B5810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5814: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B5818: 419A0008  beq cr6, 0x828b5820
	if ctx.cr[6].eq {
	pc = 0x828B5820; continue 'dispatch;
	}
	pc = 0x828B581C; continue 'dispatch;
            }
            0x828B581C => {
    //   block [0x828B581C..0x828B5820)
	// 828B581C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x828B5820; continue 'dispatch;
            }
            0x828B5820 => {
    //   block [0x828B5820..0x828B5854)
	// 828B5820: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B5824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5828: 419A0050  beq cr6, 0x828b5878
	if ctx.cr[6].eq {
	pc = 0x828B5878; continue 'dispatch;
	}
	// 828B582C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B5830: 409A0048  bne cr6, 0x828b5878
	if !ctx.cr[6].eq {
	pc = 0x828B5878; continue 'dispatch;
	}
	// 828B5834: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828B5838: 4B969A21  bl 0x8221f258
	ctx.lr = 0x828B583C;
	sub_8221F258(ctx, base);
	// 828B583C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5840: 419A0014  beq cr6, 0x828b5854
	if ctx.cr[6].eq {
	pc = 0x828B5854; continue 'dispatch;
	}
	// 828B5844: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828B5848: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B584C: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828B5850: 48000008  b 0x828b5858
	pc = 0x828B5858; continue 'dispatch;
            }
            0x828B5854 => {
    //   block [0x828B5854..0x828B5858)
	// 828B5854: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x828B5858; continue 'dispatch;
            }
            0x828B5858 => {
    //   block [0x828B5858..0x828B5878)
	// 828B5858: 387B001C  addi r3, r27, 0x1c
	ctx.r[3].s64 = ctx.r[27].s64 + 28;
	// 828B585C: 4BE5C8AD  bl 0x82712108
	ctx.lr = 0x828B5860;
	sub_82712108(ctx, base);
	// 828B5860: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B5864: E9410060  ld r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828B5868: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 828B586C: 811B001C  lwz r8, 0x1c(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B5870: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B5874: 91280008  stw r9, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828B5878; continue 'dispatch;
            }
            0x828B5878 => {
    //   block [0x828B5878..0x828B5880)
	// 828B5878: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B587C: 483F3BD8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5880 size=496
    let mut pc: u32 = 0x828B5880;
    'dispatch: loop {
        match pc {
            0x828B5880 => {
    //   block [0x828B5880..0x828B58DC)
	// 828B5880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5884: 483F3B85  bl 0x82ca9408
	ctx.lr = 0x828B5888;
	sub_82CA93D0(ctx, base);
	// 828B5888: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B588C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5890: 3B9F001C  addi r28, r31, 0x1c
	ctx.r[28].s64 = ctx.r[31].s64 + 28;
	// 828B5894: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B5898: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B589C: 419A01CC  beq cr6, 0x828b5a68
	if ctx.cr[6].eq {
	pc = 0x828B5A68; continue 'dispatch;
	}
	// 828B58A0: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 828B58A4: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B58A8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B58AC: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B58B0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B58B4: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B58B8: 4B9AEBD1  bl 0x82264488
	ctx.lr = 0x828B58BC;
	sub_82264488(ctx, base);
	// 828B58BC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B58C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B58C4: 419A0018  beq cr6, 0x828b58dc
	if ctx.cr[6].eq {
	pc = 0x828B58DC; continue 'dispatch;
	}
	// 828B58C8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B58CC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B58D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B58D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B58D8: 409A0008  bne cr6, 0x828b58e0
	if !ctx.cr[6].eq {
	pc = 0x828B58E0; continue 'dispatch;
	}
	pc = 0x828B58DC; continue 'dispatch;
            }
            0x828B58DC => {
    //   block [0x828B58DC..0x828B58E0)
	// 828B58DC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828B58E0; continue 'dispatch;
            }
            0x828B58E0 => {
    //   block [0x828B58E0..0x828B5928)
	// 828B58E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B58E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B58E8: 419A0174  beq cr6, 0x828b5a5c
	if ctx.cr[6].eq {
	pc = 0x828B5A5C; continue 'dispatch;
	}
	// 828B58EC: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B58F0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B58F4: 55499FFE  rlwinm r9, r10, 0x13, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00001FFFu64;
	// 828B58F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B58FC: 419A00E4  beq cr6, 0x828b59e0
	if ctx.cr[6].eq {
	pc = 0x828B59E0; continue 'dispatch;
	}
	// 828B5900: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B5904: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B5908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B590C: 419A001C  beq cr6, 0x828b5928
	if ctx.cr[6].eq {
	pc = 0x828B5928; continue 'dispatch;
	}
	// 828B5910: 896B000D  lbz r11, 0xd(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(13 as u32) ) } as u64;
	// 828B5914: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828B5918: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B591C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5920: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B5924: 480000C0  b 0x828b59e4
	pc = 0x828B59E4; continue 'dispatch;
            }
            0x828B5928 => {
    //   block [0x828B5928..0x828B5940)
	// 828B5928: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B592C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B5930: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B5934: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B5938: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B593C: 40810054  ble 0x828b5990
	if !ctx.cr[0].gt {
	pc = 0x828B5990; continue 'dispatch;
	}
	pc = 0x828B5940; continue 'dispatch;
            }
            0x828B5940 => {
    //   block [0x828B5940..0x828B5960)
	// 828B5940: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B5944: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B5948: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B594C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5950: 2F07000D  cmpwi cr6, r7, 0xd
	ctx.cr[6].compare_i32(ctx.r[7].s32, 13, &mut ctx.xer);
	// 828B5954: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B5958: 41980008  blt cr6, 0x828b5960
	if ctx.cr[6].lt {
	pc = 0x828B5960; continue 'dispatch;
	}
	// 828B595C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x828B5960; continue 'dispatch;
            }
            0x828B5960 => {
    //   block [0x828B5960..0x828B597C)
	// 828B5960: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B5964: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B5968: 419A0014  beq cr6, 0x828b597c
	if ctx.cr[6].eq {
	pc = 0x828B597C; continue 'dispatch;
	}
	// 828B596C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B5970: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B5974: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B5978: 4800000C  b 0x828b5984
	pc = 0x828B5984; continue 'dispatch;
            }
            0x828B597C => {
    //   block [0x828B597C..0x828B5984)
	// 828B597C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B5980: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828B5984; continue 'dispatch;
            }
            0x828B5984 => {
    //   block [0x828B5984..0x828B5990)
	// 828B5984: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5988: 4199FFB8  bgt cr6, 0x828b5940
	if ctx.cr[6].gt {
	pc = 0x828B5940; continue 'dispatch;
	}
	// 828B598C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828B5990; continue 'dispatch;
            }
            0x828B5990 => {
    //   block [0x828B5990..0x828B59AC)
	// 828B5990: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B5994: 419A003C  beq cr6, 0x828b59d0
	if ctx.cr[6].eq {
	pc = 0x828B59D0; continue 'dispatch;
	}
	// 828B5998: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B599C: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 828B59A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B59A4: 41990008  bgt cr6, 0x828b59ac
	if ctx.cr[6].gt {
	pc = 0x828B59AC; continue 'dispatch;
	}
	// 828B59A8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828B59AC; continue 'dispatch;
            }
            0x828B59AC => {
    //   block [0x828B59AC..0x828B59D0)
	// 828B59AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B59B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B59B4: 409A001C  bne cr6, 0x828b59d0
	if !ctx.cr[6].eq {
	pc = 0x828B59D0; continue 'dispatch;
	}
	// 828B59B8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B59BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B59C0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B59C4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B59C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B59CC: 48000018  b 0x828b59e4
	pc = 0x828B59E4; continue 'dispatch;
            }
            0x828B59D0 => {
    //   block [0x828B59D0..0x828B59E0)
	// 828B59D0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B59D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B59D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B59DC: 48000008  b 0x828b59e4
	pc = 0x828B59E4; continue 'dispatch;
            }
            0x828B59E0 => {
    //   block [0x828B59E0..0x828B59E4)
	// 828B59E0: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x828B59E4; continue 'dispatch;
            }
            0x828B59E4 => {
    //   block [0x828B59E4..0x828B5A24)
	// 828B59E4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B59E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B59EC: 419A0070  beq cr6, 0x828b5a5c
	if ctx.cr[6].eq {
	pc = 0x828B5A5C; continue 'dispatch;
	}
	// 828B59F0: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B59F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B59F8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828B59FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B5A00: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B5A04: 4BC3C34D  bl 0x824f1d50
	ctx.lr = 0x828B5A08;
	sub_824F1D50(ctx, base);
	// 828B5A08: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 828B5A0C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 828B5A10: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828B5A14: 419A0010  beq cr6, 0x828b5a24
	if ctx.cr[6].eq {
	pc = 0x828B5A24; continue 'dispatch;
	}
	// 828B5A18: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B5A1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B5A20: 4B8D8519  bl 0x8218df38
	ctx.lr = 0x828B5A24;
	sub_8218DF38(ctx, base);
	pc = 0x828B5A24; continue 'dispatch;
            }
            0x828B5A24 => {
    //   block [0x828B5A24..0x828B5A38)
	// 828B5A24: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828B5A28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5A2C: 419A000C  beq cr6, 0x828b5a38
	if ctx.cr[6].eq {
	pc = 0x828B5A38; continue 'dispatch;
	}
	// 828B5A30: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B5A34: 4BEAF38D  bl 0x82764dc0
	ctx.lr = 0x828B5A38;
	sub_82764DC0(ctx, base);
	pc = 0x828B5A38; continue 'dispatch;
            }
            0x828B5A38 => {
    //   block [0x828B5A38..0x828B5A5C)
	// 828B5A38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5A3C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828B5A40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5A44: 419A0018  beq cr6, 0x828b5a5c
	if ctx.cr[6].eq {
	pc = 0x828B5A5C; continue 'dispatch;
	}
	// 828B5A48: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B5A4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B5A50: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B5A54: 806B0078  lwz r3, 0x78(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 828B5A58: 4BBAB209  bl 0x82460c60
	ctx.lr = 0x828B5A5C;
	sub_82460C60(ctx, base);
	pc = 0x828B5A5C; continue 'dispatch;
            }
            0x828B5A5C => {
    //   block [0x828B5A5C..0x828B5A68)
	// 828B5A5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B5A60: 4B9020B9  bl 0x821b7b18
	ctx.lr = 0x828B5A64;
	sub_821B7B18(ctx, base);
	// 828B5A64: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x828B5A68; continue 'dispatch;
            }
            0x828B5A68 => {
    //   block [0x828B5A68..0x828B5A70)
	// 828B5A68: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B5A6C: 483F39EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B5A70 size=396
    let mut pc: u32 = 0x828B5A70;
    'dispatch: loop {
        match pc {
            0x828B5A70 => {
    //   block [0x828B5A70..0x828B5BFC)
	// 828B5A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5A74: 483F3995  bl 0x82ca9408
	ctx.lr = 0x828B5A78;
	sub_82CA93D0(ctx, base);
	// 828B5A78: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828B5A7C: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B5C00 size=552
    let mut pc: u32 = 0x828B5C00;
    'dispatch: loop {
        match pc {
            0x828B5C00 => {
    //   block [0x828B5C00..0x828B5C94)
	// 828B5C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5C04: 483F3809  bl 0x82ca940c
	ctx.lr = 0x828B5C08;
	sub_82CA93D0(ctx, base);
	// 828B5C08: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828B5C0C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828B5C10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5C14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B5C18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B5C1C: 3BCB9484  addi r30, r11, -0x6b7c
	ctx.r[30].s64 = ctx.r[11].s64 + -27516;
	// 828B5C20: 895F0098  lbz r10, 0x98(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 828B5C24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B5C28: C3FE000C  lfs f31, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B5C2C: 409A01E8  bne cr6, 0x828b5e14
	if !ctx.cr[6].eq {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5C30: 817F00D8  lwz r11, 0xd8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 828B5C34: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 828B5C38: 419A01DC  beq cr6, 0x828b5e14
	if ctx.cr[6].eq {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5C3C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B5C40: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B5C44: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B5C48: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B5C4C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5C50: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5C54: 4B8BE815  bl 0x82174468
	ctx.lr = 0x828B5C58;
	sub_82174468(ctx, base);
	// 828B5C58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B5C5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B5C60: 4B97CB19  bl 0x82232778
	ctx.lr = 0x828B5C64;
	sub_82232778(ctx, base);
	// 828B5C64: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B5C68: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B5C6C: 409A01A8  bne cr6, 0x828b5e14
	if !ctx.cr[6].eq {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5C70: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B5C74: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 828B5C78: 80DF001C  lwz r6, 0x1c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B5C7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B5C80: 7D093050  subf r8, r9, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 828B5C84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B5C88: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828B5C8C: 7D685BD7  divw. r11, r8, r11
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5C90: 4081005C  ble 0x828b5cec
	if !ctx.cr[0].gt {
	pc = 0x828B5CEC; continue 'dispatch;
	}
	pc = 0x828B5C94; continue 'dispatch;
            }
            0x828B5C94 => {
    //   block [0x828B5C94..0x828B5CBC)
	// 828B5C94: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B5C98: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B5C9C: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828B5CA0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B5CA4: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 828B5CA8: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5CAC: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 828B5CB0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B5CB4: 41980008  blt cr6, 0x828b5cbc
	if ctx.cr[6].lt {
	pc = 0x828B5CBC; continue 'dispatch;
	}
	// 828B5CB8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828B5CBC; continue 'dispatch;
            }
            0x828B5CBC => {
    //   block [0x828B5CBC..0x828B5CD8)
	// 828B5CBC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B5CC0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B5CC4: 419A0014  beq cr6, 0x828b5cd8
	if ctx.cr[6].eq {
	pc = 0x828B5CD8; continue 'dispatch;
	}
	// 828B5CC8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828B5CCC: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 828B5CD0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B5CD4: 4800000C  b 0x828b5ce0
	pc = 0x828B5CE0; continue 'dispatch;
            }
            0x828B5CD8 => {
    //   block [0x828B5CD8..0x828B5CE0)
	// 828B5CD8: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828B5CDC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x828B5CE0; continue 'dispatch;
            }
            0x828B5CE0 => {
    //   block [0x828B5CE0..0x828B5CEC)
	// 828B5CE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5CE4: 4199FFB0  bgt cr6, 0x828b5c94
	if ctx.cr[6].gt {
	pc = 0x828B5C94; continue 'dispatch;
	}
	// 828B5CE8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x828B5CEC; continue 'dispatch;
            }
            0x828B5CEC => {
    //   block [0x828B5CEC..0x828B5D08)
	// 828B5CEC: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B5CF0: 419A0034  beq cr6, 0x828b5d24
	if ctx.cr[6].eq {
	pc = 0x828B5D24; continue 'dispatch;
	}
	// 828B5CF4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5CF8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 828B5CFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5D00: 41990008  bgt cr6, 0x828b5d08
	if ctx.cr[6].gt {
	pc = 0x828B5D08; continue 'dispatch;
	}
	// 828B5D04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828B5D08; continue 'dispatch;
            }
            0x828B5D08 => {
    //   block [0x828B5D08..0x828B5D24)
	// 828B5D08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B5D0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5D10: 409A0014  bne cr6, 0x828b5d24
	if !ctx.cr[6].eq {
	pc = 0x828B5D24; continue 'dispatch;
	}
	// 828B5D14: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B5D18: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B5D1C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B5D20: 48000008  b 0x828b5d28
	pc = 0x828B5D28; continue 'dispatch;
            }
            0x828B5D24 => {
    //   block [0x828B5D24..0x828B5D28)
	// 828B5D24: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x828B5D28; continue 'dispatch;
            }
            0x828B5D28 => {
    //   block [0x828B5D28..0x828B5D3C)
	// 828B5D28: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B5D2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828B5D30: 419A000C  beq cr6, 0x828b5d3c
	if ctx.cr[6].eq {
	pc = 0x828B5D3C; continue 'dispatch;
	}
	// 828B5D34: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5D38: 48000008  b 0x828b5d40
	pc = 0x828B5D40; continue 'dispatch;
            }
            0x828B5D3C => {
    //   block [0x828B5D3C..0x828B5D40)
	// 828B5D3C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x828B5D40; continue 'dispatch;
            }
            0x828B5D40 => {
    //   block [0x828B5D40..0x828B5D98)
	// 828B5D40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5D44: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B5D48: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828B5D4C: 4E800421  bctrl
	ctx.lr = 0x828B5D50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B5D50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5D54: 419A00C0  beq cr6, 0x828b5e14
	if ctx.cr[6].eq {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5D58: 4BEAB2E1  bl 0x82761038
	ctx.lr = 0x828B5D5C;
	sub_82761038(ctx, base);
	// 828B5D5C: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 828B5D60: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B5D64: C00B9A80  lfs f0, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B5D68: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 828B5D6C: 409900A8  ble cr6, 0x828b5e14
	if !ctx.cr[6].gt {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5D70: 807F0090  lwz r3, 0x90(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B5D74: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 828B5D78: 419A009C  beq cr6, 0x828b5e14
	if ctx.cr[6].eq {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5D7C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B5D80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5D84: 41980014  blt cr6, 0x828b5d98
	if ctx.cr[6].lt {
	pc = 0x828B5D98; continue 'dispatch;
	}
	// 828B5D88: 4B9E29B1  bl 0x82298738
	ctx.lr = 0x828B5D8C;
	sub_82298738(ctx, base);
	// 828B5D8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B5D90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5D94: 409A0008  bne cr6, 0x828b5d9c
	if !ctx.cr[6].eq {
	pc = 0x828B5D9C; continue 'dispatch;
	}
            }
            0x828B5D98 => {
    //   block [0x828B5D98..0x828B5D9C)
	// 828B5D98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828B5D9C; continue 'dispatch;
            }
            0x828B5D9C => {
    //   block [0x828B5D9C..0x828B5E14)
	// 828B5D9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B5DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5DA4: 419A0070  beq cr6, 0x828b5e14
	if ctx.cr[6].eq {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5DA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B5DAC: 807F0090  lwz r3, 0x90(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B5DB0: 4BCF68A9  bl 0x825ac658
	ctx.lr = 0x828B5DB4;
	sub_825AC658(ctx, base);
	// 828B5DB4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B5DB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5DBC: 419A0058  beq cr6, 0x828b5e14
	if ctx.cr[6].eq {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5DC0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B5DC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5DC8: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828B5DCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828B5DD0: 4E800421  bctrl
	ctx.lr = 0x828B5DD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B5DD4: 4BEAB265  bl 0x82761038
	ctx.lr = 0x828B5DD8;
	sub_82761038(ctx, base);
	// 828B5DD8: C01E21CC  lfs f0, 0x21cc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8652 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B5DDC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828B5DE0: 40990034  ble cr6, 0x828b5e14
	if !ctx.cr[6].gt {
	pc = 0x828B5E14; continue 'dispatch;
	}
	// 828B5DE4: EDA1F024  fdivs f13, f1, f30
	ctx.f[13].f64 = ((ctx.f[1].f64 / ctx.f[30].f64) as f32) as f64;
	// 828B5DE8: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B5DEC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 828B5DF0: 394B0E68  addi r10, r11, 0xe68
	ctx.r[10].s64 = ctx.r[11].s64 + 3688;
	// 828B5DF4: ED8DF828  fsubs f12, f13, f31
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 828B5DF8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 828B5DFC: 7D200026  mfcr r9
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[9].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 828B5E00: 5528DF7A  rlwinm r8, r9, 0x1b, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828B5E04: 5527F77A  rlwinm r7, r9, 0x1e, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 828B5E08: 7D063B78  or r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 828B5E0C: 7D6A342E  lfsx f11, r10, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828B5E10: FFEB6FEE  fsel f31, f11, f31, f13
	ctx.f[31].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[13].f64 };
            }
            0x828B5E14 => {
    //   block [0x828B5E14..0x828B5E28)
	// 828B5E14: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B5E18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828B5E1C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828B5E20: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828B5E24: 483F3638  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B5E28 size=132
    let mut pc: u32 = 0x828B5E28;
    'dispatch: loop {
        match pc {
            0x828B5E28 => {
    //   block [0x828B5E28..0x828B5E58)
	// 828B5E28: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 828B5E2C: 41990080  bgt cr6, 0x828b5eac
	if ctx.cr[6].gt {
		sub_828B5EAC(ctx, base);
		return;
	}
	// 828B5E30: 3D80828B  lis r12, -0x7d75
	ctx.r[12].s64 = -2104819712;
	// 828B5E34: 398C5E48  addi r12, r12, 0x5e48
	ctx.r[12].s64 = ctx.r[12].s64 + 24136;
	// 828B5E38: 5460103A  slwi r0, r3, 2
	ctx.r[0].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 828B5E3C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 828B5E40: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 828B5E44: 4E800420  bctr
	match ctx.r[3].u64 {
		0 => {
	pc = 0x828B5E58; continue 'dispatch;
		},
		1 => {
	pc = 0x828B5E64; continue 'dispatch;
		},
		2 => {
	pc = 0x828B5E70; continue 'dispatch;
		},
		3 => {
	pc = 0x828B5E94; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 828B5E48: 828B5E58  lwz r20, 0x5e58(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24152 as u32) ) } as u64;
	// 828B5E4C: 828B5E64  lwz r20, 0x5e64(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24164 as u32) ) } as u64;
	// 828B5E50: 828B5E70  lwz r20, 0x5e70(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24176 as u32) ) } as u64;
	// 828B5E54: 828B5E94  lwz r20, 0x5e94(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24212 as u32) ) } as u64;
            }
            0x828B5E58 => {
    //   block [0x828B5E58..0x828B5E64)
	// 828B5E58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B5E5C: 386B0D7C  addi r3, r11, 0xd7c
	ctx.r[3].s64 = ctx.r[11].s64 + 3452;
	// 828B5E60: 4E800020  blr
	return;
            }
            0x828B5E64 => {
    //   block [0x828B5E64..0x828B5E70)
	// 828B5E64: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828B5E68: 386B115C  addi r3, r11, 0x115c
	ctx.r[3].s64 = ctx.r[11].s64 + 4444;
	// 828B5E6C: 4E800020  blr
	return;
            }
            0x828B5E70 => {
    //   block [0x828B5E70..0x828B5E7C)
	// 828B5E70: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 828B5E74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5E78: 419A0010  beq cr6, 0x828b5e88
	if ctx.cr[6].eq {
	pc = 0x828B5E88; continue 'dispatch;
	}
	pc = 0x828B5E7C; continue 'dispatch;
            }
            0x828B5E7C => {
    //   block [0x828B5E7C..0x828B5E88)
	// 828B5E7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B5E80: 386BBCD0  addi r3, r11, -0x4330
	ctx.r[3].s64 = ctx.r[11].s64 + -17200;
	// 828B5E84: 4E800020  blr
	return;
            }
            0x828B5E88 => {
    //   block [0x828B5E88..0x828B5E94)
	// 828B5E88: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B5E8C: 386B2BFC  addi r3, r11, 0x2bfc
	ctx.r[3].s64 = ctx.r[11].s64 + 11260;
	// 828B5E90: 4E800020  blr
	return;
            }
            0x828B5E94 => {
    //   block [0x828B5E94..0x828B5EAC)
	// 828B5E94: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 828B5E98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5E9C: 409AFFE0  bne cr6, 0x828b5e7c
	if !ctx.cr[6].eq {
	pc = 0x828B5E7C; continue 'dispatch;
	}
	// 828B5EA0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B5EA4: 386B2C08  addi r3, r11, 0x2c08
	ctx.r[3].s64 = ctx.r[11].s64 + 11272;
	// 828B5EA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5EAC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B5EAC size=12
    let mut pc: u32 = 0x828B5EAC;
    'dispatch: loop {
        match pc {
            0x828B5EAC => {
    //   block [0x828B5EAC..0x828B5EB8)
	// 828B5EAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B5EB0: 386B0CA0  addi r3, r11, 0xca0
	ctx.r[3].s64 = ctx.r[11].s64 + 3232;
	// 828B5EB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B5EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B5EB8 size=888
    let mut pc: u32 = 0x828B5EB8;
    'dispatch: loop {
        match pc {
            0x828B5EB8 => {
    //   block [0x828B5EB8..0x828B5F14)
	// 828B5EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B5EBC: 483F3539  bl 0x82ca93f4
	ctx.lr = 0x828B5EC0;
	sub_82CA93D0(ctx, base);
	// 828B5EC0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B5EC4: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B5EC8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828B5ECC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B5ED0: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 828B5ED4: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828B5ED8: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 828B5EDC: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 828B5EE0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828B5EE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B5EE8: 419A00E8  beq cr6, 0x828b5fd0
	if ctx.cr[6].eq {
	pc = 0x828B5FD0; continue 'dispatch;
	}
	// 828B5EEC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B5EF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5EF4: 419A0020  beq cr6, 0x828b5f14
	if ctx.cr[6].eq {
	pc = 0x828B5F14; continue 'dispatch;
	}
	// 828B5EF8: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828B5EFC: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B5F00: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B5F04: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B5F08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5F0C: 83A90004  lwz r29, 4(r9)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5F10: 480000C4  b 0x828b5fd4
	pc = 0x828B5FD4; continue 'dispatch;
            }
            0x828B5F14 => {
    //   block [0x828B5F14..0x828B5F30)
	// 828B5F14: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B5F18: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B5F1C: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 828B5F20: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B5F24: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828B5F28: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5F2C: 40810054  ble 0x828b5f80
	if !ctx.cr[0].gt {
	pc = 0x828B5F80; continue 'dispatch;
	}
	pc = 0x828B5F30; continue 'dispatch;
            }
            0x828B5F30 => {
    //   block [0x828B5F30..0x828B5F50)
	// 828B5F30: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B5F34: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B5F38: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B5F3C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5F40: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 828B5F44: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B5F48: 41980008  blt cr6, 0x828b5f50
	if ctx.cr[6].lt {
	pc = 0x828B5F50; continue 'dispatch;
	}
	// 828B5F4C: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	pc = 0x828B5F50; continue 'dispatch;
            }
            0x828B5F50 => {
    //   block [0x828B5F50..0x828B5F6C)
	// 828B5F50: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B5F54: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B5F58: 419A0014  beq cr6, 0x828b5f6c
	if ctx.cr[6].eq {
	pc = 0x828B5F6C; continue 'dispatch;
	}
	// 828B5F5C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B5F60: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B5F64: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B5F68: 4800000C  b 0x828b5f74
	pc = 0x828B5F74; continue 'dispatch;
            }
            0x828B5F6C => {
    //   block [0x828B5F6C..0x828B5F74)
	// 828B5F6C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B5F70: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828B5F74; continue 'dispatch;
            }
            0x828B5F74 => {
    //   block [0x828B5F74..0x828B5F80)
	// 828B5F74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B5F78: 4199FFB8  bgt cr6, 0x828b5f30
	if ctx.cr[6].gt {
	pc = 0x828B5F30; continue 'dispatch;
	}
	// 828B5F7C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x828B5F80; continue 'dispatch;
            }
            0x828B5F80 => {
    //   block [0x828B5F80..0x828B5F9C)
	// 828B5F80: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B5F84: 419A003C  beq cr6, 0x828b5fc0
	if ctx.cr[6].eq {
	pc = 0x828B5FC0; continue 'dispatch;
	}
	// 828B5F88: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B5F8C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828B5F90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5F94: 41990008  bgt cr6, 0x828b5f9c
	if ctx.cr[6].gt {
	pc = 0x828B5F9C; continue 'dispatch;
	}
	// 828B5F98: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x828B5F9C; continue 'dispatch;
            }
            0x828B5F9C => {
    //   block [0x828B5F9C..0x828B5FC0)
	// 828B5F9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B5FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5FA4: 409A001C  bne cr6, 0x828b5fc0
	if !ctx.cr[6].eq {
	pc = 0x828B5FC0; continue 'dispatch;
	}
	// 828B5FA8: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828B5FAC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828B5FB0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B5FB4: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5FB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5FBC: 48000018  b 0x828b5fd4
	pc = 0x828B5FD4; continue 'dispatch;
            }
            0x828B5FC0 => {
    //   block [0x828B5FC0..0x828B5FD0)
	// 828B5FC0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B5FC4: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B5FC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B5FCC: 48000008  b 0x828b5fd4
	pc = 0x828B5FD4; continue 'dispatch;
            }
            0x828B5FD0 => {
    //   block [0x828B5FD0..0x828B5FD4)
	// 828B5FD0: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x828B5FD4; continue 'dispatch;
            }
            0x828B5FD4 => {
    //   block [0x828B5FD4..0x828B5FEC)
	// 828B5FD4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B5FD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B5FDC: 419A0248  beq cr6, 0x828b6224
	if ctx.cr[6].eq {
	pc = 0x828B6224; continue 'dispatch;
	}
	// 828B5FE0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B5FE4: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 828B5FE8: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x828B5FEC; continue 'dispatch;
            }
            0x828B5FEC => {
    //   block [0x828B5FEC..0x828B6028)
	// 828B5FEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B5FF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B5FF4: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B5FF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B5FFC: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B6000: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B6004: 4082FFE8  bne 0x828b5fec
	if !ctx.cr[0].eq {
	pc = 0x828B5FEC; continue 'dispatch;
	}
	// 828B6008: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B600C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 828B6010: 3B8BEF80  addi r28, r11, -0x1080
	ctx.r[28].s64 = ctx.r[11].s64 + -4224;
	// 828B6014: 2F190003  cmpwi cr6, r25, 3
	ctx.cr[6].compare_i32(ctx.r[25].s32, 3, &mut ctx.xer);
	// 828B6018: 3B6AEF7C  addi r27, r10, -0x1084
	ctx.r[27].s64 = ctx.r[10].s64 + -4228;
	// 828B601C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828B6020: 419A0008  beq cr6, 0x828b6028
	if ctx.cr[6].eq {
	pc = 0x828B6028; continue 'dispatch;
	}
	// 828B6024: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	pc = 0x828B6028; continue 'dispatch;
            }
            0x828B6028 => {
    //   block [0x828B6028..0x828B60B0)
	// 828B6028: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B602C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828B6030: 4BFFFDF9  bl 0x828b5e28
	ctx.lr = 0x828B6034;
	sub_828B5E28(ctx, base);
	// 828B6034: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B6038: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B603C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6040: 4B93A201  bl 0x821f0240
	ctx.lr = 0x828B6044;
	sub_821F0240(ctx, base);
	// 828B6044: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6048: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B604C: 4B924975  bl 0x821da9c0
	ctx.lr = 0x828B6050;
	sub_821DA9C0(ctx, base);
	// 828B6050: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B6054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B6058: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B605C: 4B976E75  bl 0x8222ced0
	ctx.lr = 0x828B6060;
	sub_8222CED0(ctx, base);
	// 828B6060: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B6064: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B6068: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B606C: 4B92D09D  bl 0x821e3108
	ctx.lr = 0x828B6070;
	sub_821E3108(ctx, base);
	// 828B6070: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B6074: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6078: 4B9AF129  bl 0x822651a0
	ctx.lr = 0x828B607C;
	sub_822651A0(ctx, base);
	// 828B607C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B6080: 4B95ED59  bl 0x82214dd8
	ctx.lr = 0x828B6084;
	sub_82214DD8(ctx, base);
	// 828B6084: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6088: 4B95ED51  bl 0x82214dd8
	ctx.lr = 0x828B608C;
	sub_82214DD8(ctx, base);
	// 828B608C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B6090: 4B95ED49  bl 0x82214dd8
	ctx.lr = 0x828B6094;
	sub_82214DD8(ctx, base);
	// 828B6094: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B6098: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B609C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B60A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B60A4: 4B9231CD  bl 0x821d9270
	ctx.lr = 0x828B60A8;
	sub_821D9270(ctx, base);
	// 828B60A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B60AC: 419A0024  beq cr6, 0x828b60d0
	if ctx.cr[6].eq {
	pc = 0x828B60D0; continue 'dispatch;
	}
	pc = 0x828B60B0; continue 'dispatch;
            }
            0x828B60B0 => {
    //   block [0x828B60B0..0x828B60D0)
	// 828B60B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B60B4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828B60B8: 4B9AF0E9  bl 0x822651a0
	ctx.lr = 0x828B60BC;
	sub_822651A0(ctx, base);
	// 828B60BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B60C0: 4B95ED19  bl 0x82214dd8
	ctx.lr = 0x828B60C4;
	sub_82214DD8(ctx, base);
	// 828B60C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828B60C8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828B60CC: 483F3378  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x828B60D0 => {
    //   block [0x828B60D0..0x828B60DC)
	// 828B60D0: 2F190003  cmpwi cr6, r25, 3
	ctx.cr[6].compare_i32(ctx.r[25].s32, 3, &mut ctx.xer);
	// 828B60D4: 419A0008  beq cr6, 0x828b60dc
	if ctx.cr[6].eq {
	pc = 0x828B60DC; continue 'dispatch;
	}
	// 828B60D8: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	pc = 0x828B60DC; continue 'dispatch;
            }
            0x828B60DC => {
    //   block [0x828B60DC..0x828B6224)
	// 828B60DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B60E0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828B60E4: 4BFFFD45  bl 0x828b5e28
	ctx.lr = 0x828B60E8;
	sub_828B5E28(ctx, base);
	// 828B60E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B60EC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B60F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B60F4: 4B93A14D  bl 0x821f0240
	ctx.lr = 0x828B60F8;
	sub_821F0240(ctx, base);
	// 828B60F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B60FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6100: 4B9248C1  bl 0x821da9c0
	ctx.lr = 0x828B6104;
	sub_821DA9C0(ctx, base);
	// 828B6104: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B6108: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B610C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B6110: 4B976DC1  bl 0x8222ced0
	ctx.lr = 0x828B6114;
	sub_8222CED0(ctx, base);
	// 828B6114: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B6118: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B611C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B6120: 4B92CFE9  bl 0x821e3108
	ctx.lr = 0x828B6124;
	sub_821E3108(ctx, base);
	// 828B6124: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B6128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B612C: 4B9AF075  bl 0x822651a0
	ctx.lr = 0x828B6130;
	sub_822651A0(ctx, base);
	// 828B6130: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B6134: 4B95ECA5  bl 0x82214dd8
	ctx.lr = 0x828B6138;
	sub_82214DD8(ctx, base);
	// 828B6138: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B613C: 4B95EC9D  bl 0x82214dd8
	ctx.lr = 0x828B6140;
	sub_82214DD8(ctx, base);
	// 828B6140: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B6144: 4B95EC95  bl 0x82214dd8
	ctx.lr = 0x828B6148;
	sub_82214DD8(ctx, base);
	// 828B6148: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B614C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B6150: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B6154: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B6158: 4B923119  bl 0x821d9270
	ctx.lr = 0x828B615C;
	sub_821D9270(ctx, base);
	// 828B615C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B6160: 409AFF50  bne cr6, 0x828b60b0
	if !ctx.cr[6].eq {
	pc = 0x828B60B0; continue 'dispatch;
	}
	// 828B6164: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B6168: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B616C: 4B93A0D5  bl 0x821f0240
	ctx.lr = 0x828B6170;
	sub_821F0240(ctx, base);
	// 828B6170: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6174: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B6178: 4B924849  bl 0x821da9c0
	ctx.lr = 0x828B617C;
	sub_821DA9C0(ctx, base);
	// 828B617C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B6180: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6184: 4B9AF01D  bl 0x822651a0
	ctx.lr = 0x828B6188;
	sub_822651A0(ctx, base);
	// 828B6188: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B618C: 4B95EC4D  bl 0x82214dd8
	ctx.lr = 0x828B6190;
	sub_82214DD8(ctx, base);
	// 828B6190: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B6194: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B6198: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B619C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B61A0: 4B9230D1  bl 0x821d9270
	ctx.lr = 0x828B61A4;
	sub_821D9270(ctx, base);
	// 828B61A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B61A8: 409AFF08  bne cr6, 0x828b60b0
	if !ctx.cr[6].eq {
	pc = 0x828B60B0; continue 'dispatch;
	}
	// 828B61AC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B61B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B61B4: 4B93A08D  bl 0x821f0240
	ctx.lr = 0x828B61B8;
	sub_821F0240(ctx, base);
	// 828B61B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B61BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B61C0: 4B924801  bl 0x821da9c0
	ctx.lr = 0x828B61C4;
	sub_821DA9C0(ctx, base);
	// 828B61C4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B61C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B61CC: 4B9AEFD5  bl 0x822651a0
	ctx.lr = 0x828B61D0;
	sub_822651A0(ctx, base);
	// 828B61D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B61D4: 4B95EC05  bl 0x82214dd8
	ctx.lr = 0x828B61D8;
	sub_82214DD8(ctx, base);
	// 828B61D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B61DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B61E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B61E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B61E8: 4B923089  bl 0x821d9270
	ctx.lr = 0x828B61EC;
	sub_821D9270(ctx, base);
	// 828B61EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B61F0: 409AFEC0  bne cr6, 0x828b60b0
	if !ctx.cr[6].eq {
	pc = 0x828B60B0; continue 'dispatch;
	}
	// 828B61F4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B61F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B61FC: 4B9AEFA5  bl 0x822651a0
	ctx.lr = 0x828B6200;
	sub_822651A0(ctx, base);
	// 828B6200: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B6204: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828B6208: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B620C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B6210: 4B923061  bl 0x821d9270
	ctx.lr = 0x828B6214;
	sub_821D9270(ctx, base);
	// 828B6214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B6218: 409AFE98  bne cr6, 0x828b60b0
	if !ctx.cr[6].eq {
	pc = 0x828B60B0; continue 'dispatch;
	}
	// 828B621C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6220: 4B95EBB9  bl 0x82214dd8
	ctx.lr = 0x828B6224;
	sub_82214DD8(ctx, base);
	pc = 0x828B6224; continue 'dispatch;
            }
            0x828B6224 => {
    //   block [0x828B6224..0x828B6230)
	// 828B6224: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B6228: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828B622C: 483F3218  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B6230 size=2352
    let mut pc: u32 = 0x828B6230;
    'dispatch: loop {
        match pc {
            0x828B6230 => {
    //   block [0x828B6230..0x828B6B60)
	// 828B6230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B6234: 483F31C5  bl 0x82ca93f8
	ctx.lr = 0x828B6238;
	sub_82CA93D0(ctx, base);
	// 828B6238: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 828B623C: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828B6240: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B6B60 size=560
    let mut pc: u32 = 0x828B6B60;
    'dispatch: loop {
        match pc {
            0x828B6B60 => {
    //   block [0x828B6B60..0x828B6B94)
	// 828B6B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B6B64: 483F28A9  bl 0x82ca940c
	ctx.lr = 0x828B6B68;
	sub_82CA93D0(ctx, base);
	// 828B6B68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6B6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B6B70: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 828B6B74: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B6B78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B6B7C: 419A0020  beq cr6, 0x828b6b9c
	if ctx.cr[6].eq {
	pc = 0x828B6B9C; continue 'dispatch;
	}
	// 828B6B80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6B84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B6B88: 419A000C  beq cr6, 0x828b6b94
	if ctx.cr[6].eq {
	pc = 0x828B6B94; continue 'dispatch;
	}
	// 828B6B8C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B6B90: 48000010  b 0x828b6ba0
	pc = 0x828B6BA0; continue 'dispatch;
            }
            0x828B6B94 => {
    //   block [0x828B6B94..0x828B6B9C)
	// 828B6B94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B6B98: 4B8DD2A1  bl 0x82193e38
	ctx.lr = 0x828B6B9C;
	sub_82193E38(ctx, base);
	pc = 0x828B6B9C; continue 'dispatch;
            }
            0x828B6B9C => {
    //   block [0x828B6B9C..0x828B6BA0)
	// 828B6B9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828B6BA0; continue 'dispatch;
            }
            0x828B6BA0 => {
    //   block [0x828B6BA0..0x828B6BD8)
	// 828B6BA0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828B6BA4: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828B6BA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B6BAC: 419A00EC  beq cr6, 0x828b6c98
	if ctx.cr[6].eq {
	pc = 0x828B6C98; continue 'dispatch;
	}
	// 828B6BB0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B6BB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B6BB8: 419A0020  beq cr6, 0x828b6bd8
	if ctx.cr[6].eq {
	pc = 0x828B6BD8; continue 'dispatch;
	}
	// 828B6BBC: 894A0063  lbz r10, 0x63(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(99 as u32) ) } as u64;
	// 828B6BC0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B6BC4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B6BC8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B6BCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B6BD0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B6BD4: 480000CC  b 0x828b6ca0
	pc = 0x828B6CA0; continue 'dispatch;
            }
            0x828B6BD8 => {
    //   block [0x828B6BD8..0x828B6BF8)
	// 828B6BD8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B6BDC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828B6BE0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B6BE4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828B6BE8: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B6BEC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B6BF0: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B6BF4: 40810054  ble 0x828b6c48
	if !ctx.cr[0].gt {
	pc = 0x828B6C48; continue 'dispatch;
	}
	pc = 0x828B6BF8; continue 'dispatch;
            }
            0x828B6BF8 => {
    //   block [0x828B6BF8..0x828B6C18)
	// 828B6BF8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B6BFC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B6C00: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B6C04: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6C08: 2F070063  cmpwi cr6, r7, 0x63
	ctx.cr[6].compare_i32(ctx.r[7].s32, 99, &mut ctx.xer);
	// 828B6C0C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B6C10: 41980008  blt cr6, 0x828b6c18
	if ctx.cr[6].lt {
	pc = 0x828B6C18; continue 'dispatch;
	}
	// 828B6C14: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828B6C18; continue 'dispatch;
            }
            0x828B6C18 => {
    //   block [0x828B6C18..0x828B6C34)
	// 828B6C18: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B6C1C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B6C20: 419A0014  beq cr6, 0x828b6c34
	if ctx.cr[6].eq {
	pc = 0x828B6C34; continue 'dispatch;
	}
	// 828B6C24: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B6C28: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B6C2C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B6C30: 4800000C  b 0x828b6c3c
	pc = 0x828B6C3C; continue 'dispatch;
            }
            0x828B6C34 => {
    //   block [0x828B6C34..0x828B6C3C)
	// 828B6C34: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B6C38: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828B6C3C; continue 'dispatch;
            }
            0x828B6C3C => {
    //   block [0x828B6C3C..0x828B6C48)
	// 828B6C3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B6C40: 4199FFB8  bgt cr6, 0x828b6bf8
	if ctx.cr[6].gt {
	pc = 0x828B6BF8; continue 'dispatch;
	}
	// 828B6C44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828B6C48; continue 'dispatch;
            }
            0x828B6C48 => {
    //   block [0x828B6C48..0x828B6C64)
	// 828B6C48: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B6C4C: 419A003C  beq cr6, 0x828b6c88
	if ctx.cr[6].eq {
	pc = 0x828B6C88; continue 'dispatch;
	}
	// 828B6C50: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6C54: 2F0B0063  cmpwi cr6, r11, 0x63
	ctx.cr[6].compare_i32(ctx.r[11].s32, 99, &mut ctx.xer);
	// 828B6C58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B6C5C: 41990008  bgt cr6, 0x828b6c64
	if ctx.cr[6].gt {
	pc = 0x828B6C64; continue 'dispatch;
	}
	// 828B6C60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828B6C64; continue 'dispatch;
            }
            0x828B6C64 => {
    //   block [0x828B6C64..0x828B6C88)
	// 828B6C64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B6C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B6C6C: 409A001C  bne cr6, 0x828b6c88
	if !ctx.cr[6].eq {
	pc = 0x828B6C88; continue 'dispatch;
	}
	// 828B6C70: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B6C74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B6C78: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B6C7C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B6C80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B6C84: 4800001C  b 0x828b6ca0
	pc = 0x828B6CA0; continue 'dispatch;
            }
            0x828B6C88 => {
    //   block [0x828B6C88..0x828B6C98)
	// 828B6C88: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B6C8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B6C90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B6C94: 4800000C  b 0x828b6ca0
	pc = 0x828B6CA0; continue 'dispatch;
            }
            0x828B6C98 => {
    //   block [0x828B6C98..0x828B6CA0)
	// 828B6C98: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B6C9C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828B6CA0; continue 'dispatch;
            }
            0x828B6CA0 => {
    //   block [0x828B6CA0..0x828B6CBC)
	// 828B6CA0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B6CA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B6CA8: 419A0014  beq cr6, 0x828b6cbc
	if ctx.cr[6].eq {
	pc = 0x828B6CBC; continue 'dispatch;
	}
	// 828B6CAC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828B6CB0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B6CB4: C02AB478  lfs f1, -0x4b88(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19336 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B6CB8: 4B9FCFF9  bl 0x822b3cb0
	ctx.lr = 0x828B6CBC;
	sub_822B3CB0(ctx, base);
	pc = 0x828B6CBC; continue 'dispatch;
            }
            0x828B6CBC => {
    //   block [0x828B6CBC..0x828B6CDC)
	// 828B6CBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B6CC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B6CC4: 419A0020  beq cr6, 0x828b6ce4
	if ctx.cr[6].eq {
	pc = 0x828B6CE4; continue 'dispatch;
	}
	// 828B6CC8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6CCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B6CD0: 419A000C  beq cr6, 0x828b6cdc
	if ctx.cr[6].eq {
	pc = 0x828B6CDC; continue 'dispatch;
	}
	// 828B6CD4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B6CD8: 48000010  b 0x828b6ce8
	pc = 0x828B6CE8; continue 'dispatch;
            }
            0x828B6CDC => {
    //   block [0x828B6CDC..0x828B6CE4)
	// 828B6CDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B6CE0: 4B8DD159  bl 0x82193e38
	ctx.lr = 0x828B6CE4;
	sub_82193E38(ctx, base);
	pc = 0x828B6CE4; continue 'dispatch;
            }
            0x828B6CE4 => {
    //   block [0x828B6CE4..0x828B6CE8)
	// 828B6CE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828B6CE8; continue 'dispatch;
            }
            0x828B6CE8 => {
    //   block [0x828B6CE8..0x828B6D20)
	// 828B6CE8: 83CB007C  lwz r30, 0x7c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828B6CEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6CF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6CF4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6CF8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828B6CFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828B6D00: 4E800421  bctrl
	ctx.lr = 0x828B6D04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B6D04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6D08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B6D0C: 409A0044  bne cr6, 0x828b6d50
	if !ctx.cr[6].eq {
	pc = 0x828B6D50; continue 'dispatch;
	}
	// 828B6D10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B6D14: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 828B6D18: 394B0CA0  addi r10, r11, 0xca0
	ctx.r[10].s64 = ctx.r[11].s64 + 3232;
	// 828B6D1C: 3969936C  addi r11, r9, -0x6c94
	ctx.r[11].s64 = ctx.r[9].s64 + -27796;
            }
            0x828B6D20 => {
    //   block [0x828B6D20..0x828B6D44)
	// 828B6D20: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6D24: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6D28: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B6D2C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828B6D30: 419A0014  beq cr6, 0x828b6d44
	if ctx.cr[6].eq {
	pc = 0x828B6D44; continue 'dispatch;
	}
	// 828B6D34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B6D38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B6D3C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B6D40: 419AFFE0  beq cr6, 0x828b6d20
	if ctx.cr[6].eq {
	pc = 0x828B6D20; continue 'dispatch;
	}
	pc = 0x828B6D44; continue 'dispatch;
            }
            0x828B6D44 => {
    //   block [0x828B6D44..0x828B6D50)
	// 828B6D44: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828B6D48: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828B6D4C: 4800001C  b 0x828b6d68
	pc = 0x828B6D68; continue 'dispatch;
            }
            0x828B6D50 => {
    //   block [0x828B6D50..0x828B6D68)
	// 828B6D50: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 828B6D54: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B6D58: 388A936C  addi r4, r10, -0x6c94
	ctx.r[4].s64 = ctx.r[10].s64 + -27796;
	// 828B6D5C: 4B9B6A9D  bl 0x8226d7f8
	ctx.lr = 0x828B6D60;
	sub_8226D7F8(ctx, base);
	// 828B6D60: 7C690034  cntlzw r9, r3
	ctx.r[9].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828B6D64: 553FDFFE  rlwinm r31, r9, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	pc = 0x828B6D68; continue 'dispatch;
            }
            0x828B6D68 => {
    //   block [0x828B6D68..0x828B6D88)
	// 828B6D68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B6D6C: 4B95E06D  bl 0x82214dd8
	ctx.lr = 0x828B6D70;
	sub_82214DD8(ctx, base);
	// 828B6D70: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828B6D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B6D78: 419A0010  beq cr6, 0x828b6d88
	if ctx.cr[6].eq {
	pc = 0x828B6D88; continue 'dispatch;
	}
	// 828B6D7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6D80: 889D0164  lbz r4, 0x164(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(356 as u32) ) } as u64;
	// 828B6D84: 4B9E7CBD  bl 0x8229ea40
	ctx.lr = 0x828B6D88;
	sub_8229EA40(ctx, base);
	pc = 0x828B6D88; continue 'dispatch;
            }
            0x828B6D88 => {
    //   block [0x828B6D88..0x828B6D90)
	// 828B6D88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B6D8C: 483F26D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B6D90 size=424
    let mut pc: u32 = 0x828B6D90;
    'dispatch: loop {
        match pc {
            0x828B6D90 => {
    //   block [0x828B6D90..0x828B6F38)
	// 828B6D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B6D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B6D98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B6D9C: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6F38 size=160
    let mut pc: u32 = 0x828B6F38;
    'dispatch: loop {
        match pc {
            0x828B6F38 => {
    //   block [0x828B6F38..0x828B6FC0)
	// 828B6F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B6F3C: 483F24D1  bl 0x82ca940c
	ctx.lr = 0x828B6F40;
	sub_82CA93D0(ctx, base);
	// 828B6F40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6F44: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828B6F48: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 828B6F4C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828B6F50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B6F54: 4BF94945  bl 0x8284b898
	ctx.lr = 0x828B6F58;
	sub_8284B898(ctx, base);
	// 828B6F58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B6F5C: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 828B6F60: 394B5028  addi r10, r11, 0x5028
	ctx.r[10].s64 = ctx.r[11].s64 + 20520;
	// 828B6F64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B6F68: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B6F6C: 4BD10235  bl 0x825c71a0
	ctx.lr = 0x828B6F70;
	sub_825C71A0(ctx, base);
	// 828B6F70: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828B6F74: 3BDF0160  addi r30, r31, 0x160
	ctx.r[30].s64 = ctx.r[31].s64 + 352;
	// 828B6F78: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B6F7C: 38892BF4  addi r4, r9, 0x2bf4
	ctx.r[4].s64 = ctx.r[9].s64 + 11252;
	// 828B6F80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6F84: 4B975F4D  bl 0x8222ced0
	ctx.lr = 0x828B6F88;
	sub_8222CED0(ctx, base);
	// 828B6F88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B6F8C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828B6F90: 997F0164  stb r11, 0x164(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u8 ) };
	// 828B6F94: 3BBF0140  addi r29, r31, 0x140
	ctx.r[29].s64 = ctx.r[31].s64 + 320;
	// 828B6F98: 997F0165  stb r11, 0x165(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(357 as u32), ctx.r[11].u8 ) };
	// 828B6F9C: 38880CA0  addi r4, r8, 0xca0
	ctx.r[4].s64 = ctx.r[8].s64 + 3232;
	// 828B6FA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B6FA4: 4B9E4215  bl 0x8229b1b8
	ctx.lr = 0x828B6FA8;
	sub_8229B1B8(ctx, base);
	// 828B6FA8: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B6FAC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B6FB0: 419A0010  beq cr6, 0x828b6fc0
	if ctx.cr[6].eq {
	pc = 0x828B6FC0; continue 'dispatch;
	}
	// 828B6FB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B6FB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B6FBC: 4B9AE1E5  bl 0x822651a0
	ctx.lr = 0x828B6FC0;
	sub_822651A0(ctx, base);
	pc = 0x828B6FC0; continue 'dispatch;
            }
            0x828B6FC0 => {
    //   block [0x828B6FC0..0x828B6FD8)
	// 828B6FC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B6FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B6FC8: 394B5770  addi r10, r11, 0x5770
	ctx.r[10].s64 = ctx.r[11].s64 + 22384;
	// 828B6FCC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B6FD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B6FD4: 483F2488  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B6FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B6FD8 size=56
    let mut pc: u32 = 0x828B6FD8;
    'dispatch: loop {
        match pc {
            0x828B6FD8 => {
    //   block [0x828B6FD8..0x828B7010)
	// 828B6FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B6FDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B6FE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B6FE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B6FE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B6FEC: 4BFFF245  bl 0x828b6230
	ctx.lr = 0x828B6FF0;
	sub_828B6230(ctx, base);
	// 828B6FF0: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 828B6FF4: 616A0001  ori r10, r11, 1
	ctx.r[10].u64 = ctx.r[11].u64 | 1;
	// 828B6FF8: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 828B6FFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B7000: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B7004: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B7008: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B700C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B7010 size=1400
    let mut pc: u32 = 0x828B7010;
    'dispatch: loop {
        match pc {
            0x828B7010 => {
    //   block [0x828B7010..0x828B706C)
	// 828B7010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7014: 483F23F9  bl 0x82ca940c
	ctx.lr = 0x828B7018;
	sub_82CA93D0(ctx, base);
	// 828B7018: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828B701C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7020: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828B7024: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828B7028: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B702C: 386B2090  addi r3, r11, 0x2090
	ctx.r[3].s64 = ctx.r[11].s64 + 8336;
	// 828B7030: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828B7034: 4B93CD25  bl 0x821f3d58
	ctx.lr = 0x828B7038;
	sub_821F3D58(ctx, base);
	// 828B7038: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B703C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B7040: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7044: 4B92336D  bl 0x821da3b0
	ctx.lr = 0x828B7048;
	sub_821DA3B0(ctx, base);
	// 828B7048: 4B8FB4B1  bl 0x821b24f8
	ctx.lr = 0x828B704C;
	sub_821B24F8(ctx, base);
	// 828B704C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B7050: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828B7054: 48149675  bl 0x82a006c8
	ctx.lr = 0x828B7058;
	sub_82A006C8(ctx, base);
	// 828B7058: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B705C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B7060: 419A000C  beq cr6, 0x828b706c
	if ctx.cr[6].eq {
	pc = 0x828B706C; continue 'dispatch;
	}
	// 828B7064: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7068: 48000008  b 0x828b7070
	pc = 0x828B7070; continue 'dispatch;
            }
            0x828B706C => {
    //   block [0x828B706C..0x828B7070)
	// 828B706C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x828B7070; continue 'dispatch;
            }
            0x828B7070 => {
    //   block [0x828B7070..0x828B740C)
	// 828B7070: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B7074: 419A0398  beq cr6, 0x828b740c
	if ctx.cr[6].eq {
	pc = 0x828B740C; continue 'dispatch;
	}
	// 828B7078: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B707C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B7080: 388B2C28  addi r4, r11, 0x2c28
	ctx.r[4].s64 = ctx.r[11].s64 + 11304;
	// 828B7084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B7088: 4B975E49  bl 0x8222ced0
	ctx.lr = 0x828B708C;
	sub_8222CED0(ctx, base);
	// 828B708C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7090: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B7094: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 828B7098: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B709C: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 828B70A0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828B70A4: 4E800421  bctrl
	ctx.lr = 0x828B70A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B70A8: 3C808349  lis r4, -0x7cb7
	ctx.r[4].s64 = -2092367872;
	// 828B70AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B70B0: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 828B70B4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828B70B8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828B70BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B70C0: 81646AB8  lwz r11, 0x6ab8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B70C4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
            }
            0x828B740C => {
    //   block [0x828B740C..0x828B7588)
	// 828B740C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7410: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828B7414: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828B7418: 5549E7FE  rlwinm r9, r10, 0x1c, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 828B741C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B7420: 419A00F4  beq cr6, 0x828b7514
	if ctx.cr[6].eq {
	pc = 0x828B7514; continue 'dispatch;
	}
	// 828B7424: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B7428: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B742C: 419A0024  beq cr6, 0x828b7450
	if ctx.cr[6].eq {
	pc = 0x828B7450; continue 'dispatch;
	}
	// 828B7430: 894A0024  lbz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B7434: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B7438: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B743C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B7440: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7444: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B7448: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B744C: 480000CC  b 0x828b7518
	pc = 0x828B7518; continue 'dispatch;
	// 828B7450: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B7454: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B7458: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828B745C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B7460: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828B7464: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B7468: 40810054  ble 0x828b74bc
	if !ctx.cr[0].gt {
	pc = 0x828B74BC; continue 'dispatch;
	}
	// 828B746C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B7470: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B7474: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B7478: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B747C: 2F070024  cmpwi cr6, r7, 0x24
	ctx.cr[6].compare_i32(ctx.r[7].s32, 36, &mut ctx.xer);
	// 828B7480: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B7484: 41980008  blt cr6, 0x828b748c
	if ctx.cr[6].lt {
	pc = 0x828B748C; continue 'dispatch;
	}
	// 828B7488: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828B748C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B7490: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B7494: 419A0014  beq cr6, 0x828b74a8
	if ctx.cr[6].eq {
	pc = 0x828B74A8; continue 'dispatch;
	}
	// 828B7498: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B749C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B74A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B74A4: 4800000C  b 0x828b74b0
	pc = 0x828B74B0; continue 'dispatch;
	// 828B74A8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B74AC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B74B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B74B4: 4199FFB8  bgt cr6, 0x828b746c
	if ctx.cr[6].gt {
	pc = 0x828B746C; continue 'dispatch;
	}
	// 828B74B8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828B74BC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B74C0: 419A0040  beq cr6, 0x828b7500
	if ctx.cr[6].eq {
	pc = 0x828B7500; continue 'dispatch;
	}
	// 828B74C4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B74C8: 2F0B0024  cmpwi cr6, r11, 0x24
	ctx.cr[6].compare_i32(ctx.r[11].s32, 36, &mut ctx.xer);
	// 828B74CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B74D0: 41990008  bgt cr6, 0x828b74d8
	if ctx.cr[6].gt {
	pc = 0x828B74D8; continue 'dispatch;
	}
	// 828B74D4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B74D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B74DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B74E0: 409A0020  bne cr6, 0x828b7500
	if !ctx.cr[6].eq {
	pc = 0x828B7500; continue 'dispatch;
	}
	// 828B74E4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828B74E8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828B74EC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B74F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B74F4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B74F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B74FC: 4800001C  b 0x828b7518
	pc = 0x828B7518; continue 'dispatch;
	// 828B7500: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B7504: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7508: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B750C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7510: 48000008  b 0x828b7518
	pc = 0x828B7518; continue 'dispatch;
	// 828B7514: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828B7518: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B751C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7520: 419A005C  beq cr6, 0x828b757c
	if ctx.cr[6].eq {
	pc = 0x828B757C; continue 'dispatch;
	}
	// 828B7524: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B7528: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B752C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7530: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B7534: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828B7538: 4B922E79  bl 0x821da3b0
	ctx.lr = 0x828B753C;
	sub_821DA3B0(ctx, base);
	// 828B753C: 4B8FAFBD  bl 0x821b24f8
	ctx.lr = 0x828B7540;
	sub_821B24F8(ctx, base);
	// 828B7540: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828B7544: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B7548: 388A2C30  addi r4, r10, 0x2c30
	ctx.r[4].s64 = ctx.r[10].s64 + 11312;
	// 828B754C: 4BAF5EA5  bl 0x823ad3f0
	ctx.lr = 0x828B7550;
	sub_823AD3F0(ctx, base);
	// 828B7550: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B7554: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B7558: 419A0024  beq cr6, 0x828b757c
	if ctx.cr[6].eq {
	pc = 0x828B757C; continue 'dispatch;
	}
	// 828B755C: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B7560: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828B7564: 40990018  ble cr6, 0x828b757c
	if !ctx.cr[6].gt {
	pc = 0x828B757C; continue 'dispatch;
	}
	// 828B7568: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828B756C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B7570: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828B7574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7578: 4BC16D01  bl 0x824ce278
	ctx.lr = 0x828B757C;
	sub_824CE278(ctx, base);
	// 828B757C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B7580: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828B7584: 483F1ED8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7588 size=136
    let mut pc: u32 = 0x828B7588;
    'dispatch: loop {
        match pc {
            0x828B7588 => {
    //   block [0x828B7588..0x828B75DC)
	// 828B7588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B758C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B7590: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B7594: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B759C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828B75A0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B75A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B75A8: 419A0034  beq cr6, 0x828b75dc
	if ctx.cr[6].eq {
	pc = 0x828B75DC; continue 'dispatch;
	}
	// 828B75AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B75B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B75B4: 419A0054  beq cr6, 0x828b7608
	if ctx.cr[6].eq {
	pc = 0x828B7608; continue 'dispatch;
	}
	// 828B75B8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B75BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B75C0: 419A001C  beq cr6, 0x828b75dc
	if ctx.cr[6].eq {
	pc = 0x828B75DC; continue 'dispatch;
	}
	// 828B75C4: 4B8BC875  bl 0x82173e38
	ctx.lr = 0x828B75C8;
	sub_82173E38(ctx, base);
	// 828B75C8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B75CC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B75D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B75D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B75D8: 409A0008  bne cr6, 0x828b75e0
	if !ctx.cr[6].eq {
	pc = 0x828B75E0; continue 'dispatch;
	}
	pc = 0x828B75DC; continue 'dispatch;
            }
            0x828B75DC => {
    //   block [0x828B75DC..0x828B75E0)
	// 828B75DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828B75E0; continue 'dispatch;
            }
            0x828B75E0 => {
    //   block [0x828B75E0..0x828B75F4)
	// 828B75E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B75E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B75E8: 409A000C  bne cr6, 0x828b75f4
	if !ctx.cr[6].eq {
	pc = 0x828B75F4; continue 'dispatch;
	}
	// 828B75EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B75F0: 48000331  bl 0x828b7920
	ctx.lr = 0x828B75F4;
	sub_828B7920(ctx, base);
	pc = 0x828B75F4; continue 'dispatch;
            }
            0x828B75F4 => {
    //   block [0x828B75F4..0x828B7608)
	// 828B75F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B75F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B75FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B7600: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B7604: 4E800020  blr
	return;
            }
            0x828B7608 => {
    //   block [0x828B7608..0x828B7610)
	// 828B7608: 4B8DC831  bl 0x82193e38
	ctx.lr = 0x828B760C;
	sub_82193E38(ctx, base);
	// 828B760C: 4BFFFFD0  b 0x828b75dc
	pc = 0x828B75DC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7610 size=784
    let mut pc: u32 = 0x828B7610;
    'dispatch: loop {
        match pc {
            0x828B7610 => {
    //   block [0x828B7610..0x828B7668)
	// 828B7610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7614: 483F1DF5  bl 0x82ca9408
	ctx.lr = 0x828B7618;
	sub_82CA93D0(ctx, base);
	// 828B7618: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B761C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B7620: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828B7624: 3BDD000C  addi r30, r29, 0xc
	ctx.r[30].s64 = ctx.r[29].s64 + 12;
	// 828B7628: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B762C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7630: 419A0038  beq cr6, 0x828b7668
	if ctx.cr[6].eq {
	pc = 0x828B7668; continue 'dispatch;
	}
	// 828B7634: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7638: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B763C: 419A0080  beq cr6, 0x828b76bc
	if ctx.cr[6].eq {
	pc = 0x828B76BC; continue 'dispatch;
	}
	// 828B7640: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B7644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7648: 419A0020  beq cr6, 0x828b7668
	if ctx.cr[6].eq {
	pc = 0x828B7668; continue 'dispatch;
	}
	// 828B764C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B7650: 4B8BC7E9  bl 0x82173e38
	ctx.lr = 0x828B7654;
	sub_82173E38(ctx, base);
	// 828B7654: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B7658: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B765C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7660: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B7664: 409A0008  bne cr6, 0x828b766c
	if !ctx.cr[6].eq {
	pc = 0x828B766C; continue 'dispatch;
	}
	pc = 0x828B7668; continue 'dispatch;
            }
            0x828B7668 => {
    //   block [0x828B7668..0x828B766C)
	// 828B7668: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828B766C; continue 'dispatch;
            }
            0x828B766C => {
    //   block [0x828B766C..0x828B76BC)
	// 828B766C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B7670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7674: 419A0188  beq cr6, 0x828b77fc
	if ctx.cr[6].eq {
	pc = 0x828B77FC; continue 'dispatch;
	}
	// 828B7678: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B767C: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828B7680: 386B2C40  addi r3, r11, 0x2c40
	ctx.r[3].s64 = ctx.r[11].s64 + 11328;
	// 828B7684: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828B7688: 4B93C6D1  bl 0x821f3d58
	ctx.lr = 0x828B768C;
	sub_821F3D58(ctx, base);
	// 828B768C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B7690: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B7694: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B7698: 4B922D19  bl 0x821da3b0
	ctx.lr = 0x828B769C;
	sub_821DA3B0(ctx, base);
	// 828B769C: 4B8FAE5D  bl 0x821b24f8
	ctx.lr = 0x828B76A0;
	sub_821B24F8(ctx, base);
	// 828B76A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B76A4: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828B76A8: 48149021  bl 0x82a006c8
	ctx.lr = 0x828B76AC;
	sub_82A006C8(ctx, base);
	// 828B76AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B76B0: 419A0018  beq cr6, 0x828b76c8
	if ctx.cr[6].eq {
	pc = 0x828B76C8; continue 'dispatch;
	}
	// 828B76B4: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B76B8: 48000014  b 0x828b76cc
	pc = 0x828B76CC; continue 'dispatch;
            }
            0x828B76BC => {
    //   block [0x828B76BC..0x828B76C8)
	// 828B76BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B76C0: 4B8DC779  bl 0x82193e38
	ctx.lr = 0x828B76C4;
	sub_82193E38(ctx, base);
	// 828B76C4: 4BFFFFA4  b 0x828b7668
	pc = 0x828B7668; continue 'dispatch;
            }
            0x828B76C8 => {
    //   block [0x828B76C8..0x828B76CC)
	// 828B76C8: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x828B76CC; continue 'dispatch;
            }
            0x828B76CC => {
    //   block [0x828B76CC..0x828B77B8)
	// 828B76CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B76D0: 419A00E8  beq cr6, 0x828b77b8
	if ctx.cr[6].eq {
	pc = 0x828B77B8; continue 'dispatch;
	}
	// 828B76D4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B76D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B76DC: 388B2C50  addi r4, r11, 0x2c50
	ctx.r[4].s64 = ctx.r[11].s64 + 11344;
	// 828B76E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B76E4: 4B9757ED  bl 0x8222ced0
	ctx.lr = 0x828B76E8;
	sub_8222CED0(ctx, base);
	// 828B76E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B76EC: 4B8BC74D  bl 0x82173e38
	ctx.lr = 0x828B76F0;
	sub_82173E38(ctx, base);
	// 828B76F0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828B76F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B76F8: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 828B76FC: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7700: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 828B7704: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828B7708: 4E800421  bctrl
	ctx.lr = 0x828B770C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B770C: 3C808349  lis r4, -0x7cb7
	ctx.r[4].s64 = -2092367872;
	// 828B7710: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B7714: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 828B7718: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828B771C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828B7720: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B7724: 81646AB8  lwz r11, 0x6ab8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B7728: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
            }
            0x828B77B8 => {
    //   block [0x828B77B8..0x828B77FC)
	// 828B77B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B77BC: 4B8BC67D  bl 0x82173e38
	ctx.lr = 0x828B77C0;
	sub_82173E38(ctx, base);
	// 828B77C0: 4BAD6069  bl 0x8238d828
	ctx.lr = 0x828B77C4;
	sub_8238D828(ctx, base);
	// 828B77C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B77C8: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828B77CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B77D0: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828B77D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B77D8: 4B8DC661  bl 0x82193e38
	ctx.lr = 0x828B77DC;
	sub_82193E38(ctx, base);
	// 828B77DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B77E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B77E4: 4BC1A6E5  bl 0x824d1ec8
	ctx.lr = 0x828B77E8;
	sub_824D1EC8(ctx, base);
	// 828B77E8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828B77EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B77F0: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 828B77F4: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828B77F8: 4B8DC641  bl 0x82193e38
	ctx.lr = 0x828B77FC;
	sub_82193E38(ctx, base);
	pc = 0x828B77FC; continue 'dispatch;
            }
            0x828B77FC => {
    //   block [0x828B77FC..0x828B7920)
	// 828B77FC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7800: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B7804: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828B7808: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 828B780C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B7810: 419A00F4  beq cr6, 0x828b7904
	if ctx.cr[6].eq {
	pc = 0x828B7904; continue 'dispatch;
	}
	// 828B7814: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B7818: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B781C: 419A0024  beq cr6, 0x828b7840
	if ctx.cr[6].eq {
	pc = 0x828B7840; continue 'dispatch;
	}
	// 828B7820: 894A0022  lbz r10, 0x22(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(34 as u32) ) } as u64;
	// 828B7824: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B7828: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B782C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B7830: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7834: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B7838: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B783C: 480000CC  b 0x828b7908
	pc = 0x828B7908; continue 'dispatch;
	// 828B7840: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B7844: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B7848: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828B784C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B7850: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B7854: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B7858: 40810054  ble 0x828b78ac
	if !ctx.cr[0].gt {
	pc = 0x828B78AC; continue 'dispatch;
	}
	// 828B785C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B7860: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B7864: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B7868: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B786C: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 828B7870: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B7874: 41980008  blt cr6, 0x828b787c
	if ctx.cr[6].lt {
	pc = 0x828B787C; continue 'dispatch;
	}
	// 828B7878: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828B787C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B7880: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B7884: 419A0014  beq cr6, 0x828b7898
	if ctx.cr[6].eq {
	pc = 0x828B7898; continue 'dispatch;
	}
	// 828B7888: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B788C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B7890: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B7894: 4800000C  b 0x828b78a0
	pc = 0x828B78A0; continue 'dispatch;
	// 828B7898: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B789C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828B78A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B78A4: 4199FFB8  bgt cr6, 0x828b785c
	if ctx.cr[6].gt {
	pc = 0x828B785C; continue 'dispatch;
	}
	// 828B78A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B78AC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B78B0: 419A0040  beq cr6, 0x828b78f0
	if ctx.cr[6].eq {
	pc = 0x828B78F0; continue 'dispatch;
	}
	// 828B78B4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B78B8: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 828B78BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B78C0: 41990008  bgt cr6, 0x828b78c8
	if ctx.cr[6].gt {
	pc = 0x828B78C8; continue 'dispatch;
	}
	// 828B78C4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828B78C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B78CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B78D0: 409A0020  bne cr6, 0x828b78f0
	if !ctx.cr[6].eq {
	pc = 0x828B78F0; continue 'dispatch;
	}
	// 828B78D4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B78D8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828B78DC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B78E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B78E4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B78E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B78EC: 4800001C  b 0x828b7908
	pc = 0x828B7908; continue 'dispatch;
	// 828B78F0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B78F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B78F8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B78FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7900: 48000008  b 0x828b7908
	pc = 0x828B7908; continue 'dispatch;
	// 828B7904: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828B7908: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B790C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7910: 419A0008  beq cr6, 0x828b7918
	if ctx.cr[6].eq {
	pc = 0x828B7918; continue 'dispatch;
	}
	// 828B7914: 4BEC534D  bl 0x8277cc60
	ctx.lr = 0x828B7918;
	sub_8277CC60(ctx, base);
	// 828B7918: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828B791C: 483F1B3C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B7920 size=640
    let mut pc: u32 = 0x828B7920;
    'dispatch: loop {
        match pc {
            0x828B7920 => {
    //   block [0x828B7920..0x828B7988)
	// 828B7920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B7928: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B792C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B7934: 388000DF  li r4, 0xdf
	ctx.r[4].s64 = 223;
	// 828B7938: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B793C: 4BAD523D  bl 0x8238cb78
	ctx.lr = 0x828B7940;
	sub_8238CB78(ctx, base);
	// 828B7940: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7944: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B7948: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B794C: 81660024  lwz r11, 0x24(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B7950: 556A67FE  rlwinm r10, r11, 0xc, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000FFFFFu64;
	// 828B7954: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B7958: 419A00F4  beq cr6, 0x828b7a4c
	if ctx.cr[6].eq {
	pc = 0x828B7A4C; continue 'dispatch;
	}
	// 828B795C: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B7960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7964: 419A0024  beq cr6, 0x828b7988
	if ctx.cr[6].eq {
	pc = 0x828B7988; continue 'dispatch;
	}
	// 828B7968: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828B796C: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B7970: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B7974: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B7978: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B797C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B7980: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7984: 480000CC  b 0x828b7a50
	pc = 0x828B7A50; continue 'dispatch;
            }
            0x828B7988 => {
    //   block [0x828B7988..0x828B79A4)
	// 828B7988: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B798C: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B7990: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828B7994: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 828B7998: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B799C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B79A0: 40810054  ble 0x828b79f4
	if !ctx.cr[0].gt {
	pc = 0x828B79F4; continue 'dispatch;
	}
	pc = 0x828B79A4; continue 'dispatch;
            }
            0x828B79A4 => {
    //   block [0x828B79A4..0x828B79C4)
	// 828B79A4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B79A8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B79AC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828B79B0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B79B4: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 828B79B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B79BC: 41980008  blt cr6, 0x828b79c4
	if ctx.cr[6].lt {
	pc = 0x828B79C4; continue 'dispatch;
	}
	// 828B79C0: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	pc = 0x828B79C4; continue 'dispatch;
            }
            0x828B79C4 => {
    //   block [0x828B79C4..0x828B79E0)
	// 828B79C4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B79C8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B79CC: 419A0014  beq cr6, 0x828b79e0
	if ctx.cr[6].eq {
	pc = 0x828B79E0; continue 'dispatch;
	}
	// 828B79D0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B79D4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B79D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B79DC: 4800000C  b 0x828b79e8
	pc = 0x828B79E8; continue 'dispatch;
            }
            0x828B79E0 => {
    //   block [0x828B79E0..0x828B79E8)
	// 828B79E0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B79E4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828B79E8; continue 'dispatch;
            }
            0x828B79E8 => {
    //   block [0x828B79E8..0x828B79F4)
	// 828B79E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B79EC: 4199FFB8  bgt cr6, 0x828b79a4
	if ctx.cr[6].gt {
	pc = 0x828B79A4; continue 'dispatch;
	}
	// 828B79F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828B79F4; continue 'dispatch;
            }
            0x828B79F4 => {
    //   block [0x828B79F4..0x828B7A10)
	// 828B79F4: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828B79F8: 419A0040  beq cr6, 0x828b7a38
	if ctx.cr[6].eq {
	pc = 0x828B7A38; continue 'dispatch;
	}
	// 828B79FC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7A00: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 828B7A04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7A08: 41990008  bgt cr6, 0x828b7a10
	if ctx.cr[6].gt {
	pc = 0x828B7A10; continue 'dispatch;
	}
	// 828B7A0C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x828B7A10; continue 'dispatch;
            }
            0x828B7A10 => {
    //   block [0x828B7A10..0x828B7A38)
	// 828B7A10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B7A14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7A18: 409A0020  bne cr6, 0x828b7a38
	if !ctx.cr[6].eq {
	pc = 0x828B7A38; continue 'dispatch;
	}
	// 828B7A1C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B7A20: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B7A24: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B7A28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7A2C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B7A30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7A34: 4800001C  b 0x828b7a50
	pc = 0x828B7A50; continue 'dispatch;
            }
            0x828B7A38 => {
    //   block [0x828B7A38..0x828B7A4C)
	// 828B7A38: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828B7A3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7A40: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B7A44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7A48: 48000008  b 0x828b7a50
	pc = 0x828B7A50; continue 'dispatch;
            }
            0x828B7A4C => {
    //   block [0x828B7A4C..0x828B7A50)
	// 828B7A4C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x828B7A50; continue 'dispatch;
            }
            0x828B7A50 => {
    //   block [0x828B7A50..0x828B7AA4)
	// 828B7A50: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B7A54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7A58: 419A0134  beq cr6, 0x828b7b8c
	if ctx.cr[6].eq {
	pc = 0x828B7B8C; continue 'dispatch;
	}
	// 828B7A5C: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B7A60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7A64: 419A0128  beq cr6, 0x828b7b8c
	if ctx.cr[6].eq {
	pc = 0x828B7B8C; continue 'dispatch;
	}
	// 828B7A68: 81460028  lwz r10, 0x28(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(40 as u32) ) } as u64;
	// 828B7A6C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828B7A70: 5549E7FE  rlwinm r9, r10, 0x1c, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 828B7A74: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B7A78: 419A00E4  beq cr6, 0x828b7b5c
	if ctx.cr[6].eq {
	pc = 0x828B7B5C; continue 'dispatch;
	}
	// 828B7A7C: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B7A80: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B7A84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7A88: 419A001C  beq cr6, 0x828b7aa4
	if ctx.cr[6].eq {
	pc = 0x828B7AA4; continue 'dispatch;
	}
	// 828B7A8C: 896B0024  lbz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B7A90: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828B7A94: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B7A98: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7A9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B7AA0: 480000C0  b 0x828b7b60
	pc = 0x828B7B60; continue 'dispatch;
            }
            0x828B7AA4 => {
    //   block [0x828B7AA4..0x828B7ABC)
	// 828B7AA4: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B7AA8: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828B7AAC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B7AB0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B7AB4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B7AB8: 40810054  ble 0x828b7b0c
	if !ctx.cr[0].gt {
	pc = 0x828B7B0C; continue 'dispatch;
	}
	pc = 0x828B7ABC; continue 'dispatch;
            }
            0x828B7ABC => {
    //   block [0x828B7ABC..0x828B7ADC)
	// 828B7ABC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B7AC0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B7AC4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828B7AC8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7ACC: 2F070024  cmpwi cr6, r7, 0x24
	ctx.cr[6].compare_i32(ctx.r[7].s32, 36, &mut ctx.xer);
	// 828B7AD0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B7AD4: 41980008  blt cr6, 0x828b7adc
	if ctx.cr[6].lt {
	pc = 0x828B7ADC; continue 'dispatch;
	}
	// 828B7AD8: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	pc = 0x828B7ADC; continue 'dispatch;
            }
            0x828B7ADC => {
    //   block [0x828B7ADC..0x828B7AF8)
	// 828B7ADC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B7AE0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B7AE4: 419A0014  beq cr6, 0x828b7af8
	if ctx.cr[6].eq {
	pc = 0x828B7AF8; continue 'dispatch;
	}
	// 828B7AE8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B7AEC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B7AF0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B7AF4: 4800000C  b 0x828b7b00
	pc = 0x828B7B00; continue 'dispatch;
            }
            0x828B7AF8 => {
    //   block [0x828B7AF8..0x828B7B00)
	// 828B7AF8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B7AFC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828B7B00; continue 'dispatch;
            }
            0x828B7B00 => {
    //   block [0x828B7B00..0x828B7B0C)
	// 828B7B00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B7B04: 4199FFB8  bgt cr6, 0x828b7abc
	if ctx.cr[6].gt {
	pc = 0x828B7ABC; continue 'dispatch;
	}
	// 828B7B08: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828B7B0C; continue 'dispatch;
            }
            0x828B7B0C => {
    //   block [0x828B7B0C..0x828B7B28)
	// 828B7B0C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B7B10: 419A003C  beq cr6, 0x828b7b4c
	if ctx.cr[6].eq {
	pc = 0x828B7B4C; continue 'dispatch;
	}
	// 828B7B14: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7B18: 2F0B0024  cmpwi cr6, r11, 0x24
	ctx.cr[6].compare_i32(ctx.r[11].s32, 36, &mut ctx.xer);
	// 828B7B1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7B20: 41990008  bgt cr6, 0x828b7b28
	if ctx.cr[6].gt {
	pc = 0x828B7B28; continue 'dispatch;
	}
	// 828B7B24: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x828B7B28; continue 'dispatch;
            }
            0x828B7B28 => {
    //   block [0x828B7B28..0x828B7B4C)
	// 828B7B28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B7B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7B30: 409A001C  bne cr6, 0x828b7b4c
	if !ctx.cr[6].eq {
	pc = 0x828B7B4C; continue 'dispatch;
	}
	// 828B7B34: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B7B38: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B7B3C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B7B40: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B7B44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7B48: 48000018  b 0x828b7b60
	pc = 0x828B7B60; continue 'dispatch;
            }
            0x828B7B4C => {
    //   block [0x828B7B4C..0x828B7B5C)
	// 828B7B4C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B7B50: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B7B54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7B58: 48000008  b 0x828b7b60
	pc = 0x828B7B60; continue 'dispatch;
            }
            0x828B7B5C => {
    //   block [0x828B7B5C..0x828B7B60)
	// 828B7B5C: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	pc = 0x828B7B60; continue 'dispatch;
            }
            0x828B7B60 => {
    //   block [0x828B7B60..0x828B7B80)
	// 828B7B60: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B7B64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B7B68: 419A0018  beq cr6, 0x828b7b80
	if ctx.cr[6].eq {
	pc = 0x828B7B80; continue 'dispatch;
	}
	// 828B7B6C: C00B001C  lfs f0, 0x1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B7B70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B7B74: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828B7B78: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B7B7C: 4BC166FD  bl 0x824ce278
	ctx.lr = 0x828B7B80;
	sub_824CE278(ctx, base);
	pc = 0x828B7B80; continue 'dispatch;
            }
            0x828B7B80 => {
    //   block [0x828B7B80..0x828B7B8C)
	// 828B7B80: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B7B84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7B88: 4BAEFD41  bl 0x823a78c8
	ctx.lr = 0x828B7B8C;
	sub_823A78C8(ctx, base);
	pc = 0x828B7B8C; continue 'dispatch;
            }
            0x828B7B8C => {
    //   block [0x828B7B8C..0x828B7BA0)
	// 828B7B8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B7B90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B7B94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B7B98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B7B9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7BA0 size=80
    let mut pc: u32 = 0x828B7BA0;
    'dispatch: loop {
        match pc {
            0x828B7BA0 => {
    //   block [0x828B7BA0..0x828B7BDC)
	// 828B7BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B7BA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B7BAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7BB0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B7BB8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828B7BBC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7BC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828B7BC4: 4E800421  bctrl
	ctx.lr = 0x828B7BC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B7BC8: 2F030008  cmpwi cr6, r3, 8
	ctx.cr[6].compare_i32(ctx.r[3].s32, 8, &mut ctx.xer);
	// 828B7BCC: 409A0010  bne cr6, 0x828b7bdc
	if !ctx.cr[6].eq {
	pc = 0x828B7BDC; continue 'dispatch;
	}
	// 828B7BD0: 388000DF  li r4, 0xdf
	ctx.r[4].s64 = 223;
	// 828B7BD4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7BD8: 4BAD4FA1  bl 0x8238cb78
	ctx.lr = 0x828B7BDC;
	sub_8238CB78(ctx, base);
            }
            0x828B7BDC => {
    //   block [0x828B7BDC..0x828B7BF0)
	// 828B7BDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B7BE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B7BE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B7BE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B7BEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7BF0 size=584
    let mut pc: u32 = 0x828B7BF0;
    'dispatch: loop {
        match pc {
            0x828B7BF0 => {
    //   block [0x828B7BF0..0x828B7C18)
	// 828B7BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7BF4: 483F180D  bl 0x82ca9400
	ctx.lr = 0x828B7BF8;
	sub_82CA93D0(ctx, base);
	// 828B7BF8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7BFC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7C00: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828B7C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7C08: 409A0010  bne cr6, 0x828b7c18
	if !ctx.cr[6].eq {
	pc = 0x828B7C18; continue 'dispatch;
	}
	// 828B7C0C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B7C10: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828B7C14: 48000008  b 0x828b7c1c
	pc = 0x828B7C1C; continue 'dispatch;
            }
            0x828B7C18 => {
    //   block [0x828B7C18..0x828B7C1C)
	// 828B7C18: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828B7C1C; continue 'dispatch;
            }
            0x828B7C1C => {
    //   block [0x828B7C1C..0x828B7C94)
	// 828B7C1C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7C20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B7C24: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7C28: 4BB16999  bl 0x823ce5c0
	ctx.lr = 0x828B7C2C;
	sub_823CE5C0(ctx, base);
	// 828B7C2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B7C30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B7C34: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B7C38: 4BB165C9  bl 0x823ce200
	ctx.lr = 0x828B7C3C;
	sub_823CE200(ctx, base);
	// 828B7C3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B7C40: 4B8FFED9  bl 0x821b7b18
	ctx.lr = 0x828B7C44;
	sub_821B7B18(ctx, base);
	// 828B7C44: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828B7C48: 4B967611  bl 0x8221f258
	ctx.lr = 0x828B7C4C;
	sub_8221F258(ctx, base);
	// 828B7C4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B7C50: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B7C54: 419A0040  beq cr6, 0x828b7c94
	if ctx.cr[6].eq {
	pc = 0x828B7C94; continue 'dispatch;
	}
	// 828B7C58: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828B7C5C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828B7C60: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828B7C64: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B7C68: 4B9675F1  bl 0x8221f258
	ctx.lr = 0x828B7C6C;
	sub_8221F258(ctx, base);
	// 828B7C6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B7C70: 419A0028  beq cr6, 0x828b7c98
	if ctx.cr[6].eq {
	pc = 0x828B7C98; continue 'dispatch;
	}
	// 828B7C74: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828B7C78: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828B7C7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B7C80: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828B7C84: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B7C88: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B7C8C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B7C90: 4800000C  b 0x828b7c9c
	pc = 0x828B7C9C; continue 'dispatch;
            }
            0x828B7C94 => {
    //   block [0x828B7C94..0x828B7C98)
	// 828B7C94: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828B7C98; continue 'dispatch;
            }
            0x828B7C98 => {
    //   block [0x828B7C98..0x828B7C9C)
	// 828B7C98: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828B7C9C; continue 'dispatch;
            }
            0x828B7C9C => {
    //   block [0x828B7C9C..0x828B7DA0)
	// 828B7C9C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B7CA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B7CA4: 419A00FC  beq cr6, 0x828b7da0
	if ctx.cr[6].eq {
	pc = 0x828B7DA0; continue 'dispatch;
	}
	// 828B7CA8: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7CAC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828B7CB0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7CB4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B7CB8: 4B971451  bl 0x82229108
	ctx.lr = 0x828B7CBC;
	sub_82229108(ctx, base);
	// 828B7CBC: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7CC0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828B7CC4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B7CC8: 3BCB7E38  addi r30, r11, 0x7e38
	ctx.r[30].s64 = ctx.r[11].s64 + 32312;
	// 828B7CCC: 4B96FBB5  bl 0x82227880
	ctx.lr = 0x828B7CD0;
	sub_82227880(ctx, base);
	// 828B7CD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B7CD4: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828B7CD8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B7CDC: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828B7CE0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B7CE4: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B7CE8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828B7CEC: 4B8E2D95  bl 0x8219aa80
	ctx.lr = 0x828B7CF0;
	sub_8219AA80(ctx, base);
	// 828B7CF0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828B7CF4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B7CF8: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828B7CFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B7D00: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B7D04: 4BB1671D  bl 0x823ce420
	ctx.lr = 0x828B7D08;
	sub_823CE420(ctx, base);
	// 828B7D08: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B7D0C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828B7D10: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B7D14: 4816C9B5  bl 0x82a246c8
	ctx.lr = 0x828B7D18;
	sub_82A246C8(ctx, base);
	// 828B7D18: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B7D1C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828B7D20: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828B7D24: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828B7D28: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7D2C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7D30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B7D34: 4B9713D5  bl 0x82229108
	ctx.lr = 0x828B7D38;
	sub_82229108(ctx, base);
	// 828B7D38: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828B7D3C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828B7D40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B7D44: 3BEB7E78  addi r31, r11, 0x7e78
	ctx.r[31].s64 = ctx.r[11].s64 + 32376;
	// 828B7D48: 4B96FB39  bl 0x82227880
	ctx.lr = 0x828B7D4C;
	sub_82227880(ctx, base);
	// 828B7D4C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828B7D50: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828B7D54: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B7D58: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828B7D5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B7D60: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B7D64: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828B7D68: 4B8E2D19  bl 0x8219aa80
	ctx.lr = 0x828B7D6C;
	sub_8219AA80(ctx, base);
	// 828B7D6C: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828B7D70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B7D74: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828B7D78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B7D7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B7D80: 4BB166A1  bl 0x823ce420
	ctx.lr = 0x828B7D84;
	sub_823CE420(ctx, base);
	// 828B7D84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B7D88: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828B7D8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B7D90: 4816C939  bl 0x82a246c8
	ctx.lr = 0x828B7D94;
	sub_82A246C8(ctx, base);
	// 828B7D94: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B7D98: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828B7D9C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x828B7DA0; continue 'dispatch;
            }
            0x828B7DA0 => {
    //   block [0x828B7DA0..0x828B7DB0)
	// 828B7DA0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828B7DA4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B7DA8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828B7DAC: 419A0020  beq cr6, 0x828b7dcc
	if ctx.cr[6].eq {
	pc = 0x828B7DCC; continue 'dispatch;
	}
	pc = 0x828B7DB0; continue 'dispatch;
            }
            0x828B7DB0 => {
    //   block [0x828B7DB0..0x828B7DCC)
	// 828B7DB0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B7DB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B7DB8: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B7DBC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B7DC0: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B7DC4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B7DC8: 4082FFE8  bne 0x828b7db0
	if !ctx.cr[0].eq {
	pc = 0x828B7DB0; continue 'dispatch;
	}
	pc = 0x828B7DCC; continue 'dispatch;
            }
            0x828B7DCC => {
    //   block [0x828B7DCC..0x828B7DEC)
	// 828B7DCC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7DD0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B7DD4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828B7DD8: 4BA3DB71  bl 0x822f5948
	ctx.lr = 0x828B7DDC;
	sub_822F5948(ctx, base);
	// 828B7DDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B7DE0: 4B8FFD39  bl 0x821b7b18
	ctx.lr = 0x828B7DE4;
	sub_821B7B18(ctx, base);
	// 828B7DE4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B7DE8: 419A0040  beq cr6, 0x828b7e28
	if ctx.cr[6].eq {
	pc = 0x828B7E28; continue 'dispatch;
	}
	pc = 0x828B7DEC; continue 'dispatch;
            }
            0x828B7DEC => {
    //   block [0x828B7DEC..0x828B7E28)
	// 828B7DEC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B7DF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B7DF4: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B7DF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B7DFC: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B7E00: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B7E04: 4082FFE8  bne 0x828b7dec
	if !ctx.cr[0].eq {
	pc = 0x828B7DEC; continue 'dispatch;
	}
	// 828B7E08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B7E0C: 409A001C  bne cr6, 0x828b7e28
	if !ctx.cr[6].eq {
	pc = 0x828B7E28; continue 'dispatch;
	}
	// 828B7E10: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B7E14: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B7E18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B7E1C: 4E800421  bctrl
	ctx.lr = 0x828B7E20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B7E20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B7E24: 4B963F15  bl 0x8221bd38
	ctx.lr = 0x828B7E28;
	sub_8221BD38(ctx, base);
            }
            0x828B7E28 => {
    //   block [0x828B7E28..0x828B7E38)
	// 828B7E28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B7E2C: 4B8FFCED  bl 0x821b7b18
	ctx.lr = 0x828B7E30;
	sub_821B7B18(ctx, base);
	// 828B7E30: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B7E34: 483F161C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B7E38 size=56
    let mut pc: u32 = 0x828B7E38;
    'dispatch: loop {
        match pc {
            0x828B7E38 => {
    //   block [0x828B7E38..0x828B7E54)
	// 828B7E38: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B7E3C: 419A0018  beq cr6, 0x828b7e54
	if ctx.cr[6].eq {
	pc = 0x828B7E54; continue 'dispatch;
	}
	// 828B7E40: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B7E44: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B7E48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7E4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B7E50: 409A0008  bne cr6, 0x828b7e58
	if !ctx.cr[6].eq {
	pc = 0x828B7E58; continue 'dispatch;
	}
	pc = 0x828B7E54; continue 'dispatch;
            }
            0x828B7E54 => {
    //   block [0x828B7E54..0x828B7E58)
	// 828B7E54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828B7E58; continue 'dispatch;
            }
            0x828B7E58 => {
    //   block [0x828B7E58..0x828B7E70)
	// 828B7E58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B7E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7E60: 419A0010  beq cr6, 0x828b7e70
	if ctx.cr[6].eq {
		sub_828B7E70(ctx, base);
		return;
	}
	// 828B7E64: 8164003C  lwz r11, 0x3c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 828B7E68: 55630FFE  srwi r3, r11, 0x1f
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828B7E6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B7E70 size=8
    let mut pc: u32 = 0x828B7E70;
    'dispatch: loop {
        match pc {
            0x828B7E70 => {
    //   block [0x828B7E70..0x828B7E78)
	// 828B7E70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B7E74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B7E78 size=8
    let mut pc: u32 = 0x828B7E78;
    'dispatch: loop {
        match pc {
            0x828B7E78 => {
    //   block [0x828B7E78..0x828B7E80)
	// 828B7E78: 386000DF  li r3, 0xdf
	ctx.r[3].s64 = 223;
	// 828B7E7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7E80 size=60
    let mut pc: u32 = 0x828B7E80;
    'dispatch: loop {
        match pc {
            0x828B7E80 => {
    //   block [0x828B7E80..0x828B7EBC)
	// 828B7E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7E84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B7E88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B7E8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7E90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B7E94: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B7E98: 388B9498  addi r4, r11, -0x6b68
	ctx.r[4].s64 = ctx.r[11].s64 + -27496;
	// 828B7E9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B7EA0: 4B975031  bl 0x8222ced0
	ctx.lr = 0x828B7EA4;
	sub_8222CED0(ctx, base);
	// 828B7EA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7EA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B7EAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B7EB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B7EB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B7EB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7EC0 size=124
    let mut pc: u32 = 0x828B7EC0;
    'dispatch: loop {
        match pc {
            0x828B7EC0 => {
    //   block [0x828B7EC0..0x828B7F34)
	// 828B7EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7EC4: 483F1545  bl 0x82ca9408
	ctx.lr = 0x828B7EC8;
	sub_82CA93D0(ctx, base);
	// 828B7EC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7ECC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B7ED0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828B7ED4: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 828B7ED8: 4B95CF01  bl 0x82214dd8
	ctx.lr = 0x828B7EDC;
	sub_82214DD8(ctx, base);
	// 828B7EDC: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 828B7EE0: 4B95CEF9  bl 0x82214dd8
	ctx.lr = 0x828B7EE4;
	sub_82214DD8(ctx, base);
	// 828B7EE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B7EE8: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 828B7EEC: 3B8B0B7C  addi r28, r11, 0xb7c
	ctx.r[28].s64 = ctx.r[11].s64 + 2940;
	// 828B7EF0: 939F0014  stw r28, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 828B7EF4: 4B8DBF45  bl 0x82193e38
	ctx.lr = 0x828B7EF8;
	sub_82193E38(ctx, base);
	// 828B7EF8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B7EFC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828B7F00: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 828B7F04: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 828B7F08: 4B8DBF31  bl 0x82193e38
	ctx.lr = 0x828B7F0C;
	sub_82193E38(ctx, base);
	// 828B7F0C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 828B7F10: 57A907FE  clrlwi r9, r29, 0x1f
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 828B7F14: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 828B7F18: 390A2850  addi r8, r10, 0x2850
	ctx.r[8].s64 = ctx.r[10].s64 + 10320;
	// 828B7F1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B7F20: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828B7F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7F28: 419A000C  beq cr6, 0x828b7f34
	if ctx.cr[6].eq {
	pc = 0x828B7F34; continue 'dispatch;
	}
	// 828B7F2C: 4B963E0D  bl 0x8221bd38
	ctx.lr = 0x828B7F30;
	sub_8221BD38(ctx, base);
	// 828B7F30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x828B7F34; continue 'dispatch;
            }
            0x828B7F34 => {
    //   block [0x828B7F34..0x828B7F3C)
	// 828B7F34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B7F38: 483F1520  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7F40 size=88
    let mut pc: u32 = 0x828B7F40;
    'dispatch: loop {
        match pc {
            0x828B7F40 => {
    //   block [0x828B7F40..0x828B7F80)
	// 828B7F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B7F48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B7F4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7F50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B7F54: 4805D12D  bl 0x82915080
	ctx.lr = 0x828B7F58;
	sub_82915080(ctx, base);
	// 828B7F58: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B7F5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7F60: 419A0020  beq cr6, 0x828b7f80
	if ctx.cr[6].eq {
	pc = 0x828B7F80; continue 'dispatch;
	}
	// 828B7F64: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828B7F68: 4B8BBED1  bl 0x82173e38
	ctx.lr = 0x828B7F6C;
	sub_82173E38(ctx, base);
	// 828B7F6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B7F70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B7F74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B7F78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B7F7C: 4E800020  blr
	return;
            }
            0x828B7F80 => {
    //   block [0x828B7F80..0x828B7F98)
	// 828B7F80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B7F84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B7F88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B7F8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B7F90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B7F94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B7F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B7F98 size=164
    let mut pc: u32 = 0x828B7F98;
    'dispatch: loop {
        match pc {
            0x828B7F98 => {
    //   block [0x828B7F98..0x828B7FEC)
	// 828B7F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B7F9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B7FA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B7FA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B7FA8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B7FAC: 3BE30014  addi r31, r3, 0x14
	ctx.r[31].s64 = ctx.r[3].s64 + 20;
	// 828B7FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7FB4: 419A0038  beq cr6, 0x828b7fec
	if ctx.cr[6].eq {
	pc = 0x828B7FEC; continue 'dispatch;
	}
	// 828B7FB8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B7FBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B7FC0: 419A0058  beq cr6, 0x828b8018
	if ctx.cr[6].eq {
	pc = 0x828B8018; continue 'dispatch;
	}
	// 828B7FC4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B7FC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7FCC: 419A0020  beq cr6, 0x828b7fec
	if ctx.cr[6].eq {
	pc = 0x828B7FEC; continue 'dispatch;
	}
	// 828B7FD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B7FD4: 4B8BBE65  bl 0x82173e38
	ctx.lr = 0x828B7FD8;
	sub_82173E38(ctx, base);
	// 828B7FD8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B7FDC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B7FE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B7FE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B7FE8: 409A0008  bne cr6, 0x828b7ff0
	if !ctx.cr[6].eq {
	pc = 0x828B7FF0; continue 'dispatch;
	}
	pc = 0x828B7FEC; continue 'dispatch;
            }
            0x828B7FEC => {
    //   block [0x828B7FEC..0x828B7FF0)
	// 828B7FEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828B7FF0; continue 'dispatch;
            }
            0x828B7FF0 => {
    //   block [0x828B7FF0..0x828B8018)
	// 828B7FF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B7FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B7FF8: 419A002C  beq cr6, 0x828b8024
	if ctx.cr[6].eq {
	pc = 0x828B8024; continue 'dispatch;
	}
	// 828B7FFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8000: 4B8BBE39  bl 0x82173e38
	ctx.lr = 0x828B8004;
	sub_82173E38(ctx, base);
	// 828B8004: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B8008: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B800C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B8010: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B8014: 4E800020  blr
	return;
            }
            0x828B8018 => {
    //   block [0x828B8018..0x828B8024)
	// 828B8018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B801C: 4B8DBE1D  bl 0x82193e38
	ctx.lr = 0x828B8020;
	sub_82193E38(ctx, base);
	// 828B8020: 4BFFFFCC  b 0x828b7fec
	pc = 0x828B7FEC; continue 'dispatch;
            }
            0x828B8024 => {
    //   block [0x828B8024..0x828B803C)
	// 828B8024: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B8028: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B802C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B8030: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B8034: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B8038: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8040 size=484
    let mut pc: u32 = 0x828B8040;
    'dispatch: loop {
        match pc {
            0x828B8040 => {
    //   block [0x828B8040..0x828B807C)
	// 828B8040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B8048: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B804C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B8050: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8054: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B8058: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B805C: 4BFFFEE5  bl 0x828b7f40
	ctx.lr = 0x828B8060;
	sub_828B7F40(ctx, base);
	// 828B8060: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B8064: 419A0018  beq cr6, 0x828b807c
	if ctx.cr[6].eq {
	pc = 0x828B807C; continue 'dispatch;
	}
	// 828B8068: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B806C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B8070: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8074: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B8078: 409A0008  bne cr6, 0x828b8080
	if !ctx.cr[6].eq {
	pc = 0x828B8080; continue 'dispatch;
	}
	pc = 0x828B807C; continue 'dispatch;
            }
            0x828B807C => {
    //   block [0x828B807C..0x828B8080)
	// 828B807C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828B8080; continue 'dispatch;
            }
            0x828B8080 => {
    //   block [0x828B8080..0x828B80D0)
	// 828B8080: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B8084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8088: 419A0180  beq cr6, 0x828b8208
	if ctx.cr[6].eq {
	pc = 0x828B8208; continue 'dispatch;
	}
	// 828B808C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B8090: 4BFFFEB1  bl 0x828b7f40
	ctx.lr = 0x828B8094;
	sub_828B7F40(ctx, base);
	// 828B8094: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828B8098: 556A3FFE  rlwinm r10, r11, 7, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x01FFFFFFu64;
	// 828B809C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B80A0: 419A00F4  beq cr6, 0x828b8194
	if ctx.cr[6].eq {
	pc = 0x828B8194; continue 'dispatch;
	}
	// 828B80A4: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B80A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B80AC: 419A0024  beq cr6, 0x828b80d0
	if ctx.cr[6].eq {
	pc = 0x828B80D0; continue 'dispatch;
	}
	// 828B80B0: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 828B80B4: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B80B8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B80BC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B80C0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B80C4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B80C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B80CC: 480000CC  b 0x828b8198
	pc = 0x828B8198; continue 'dispatch;
            }
            0x828B80D0 => {
    //   block [0x828B80D0..0x828B80EC)
	// 828B80D0: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B80D4: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B80D8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828B80DC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B80E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B80E4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B80E8: 40810054  ble 0x828b813c
	if !ctx.cr[0].gt {
	pc = 0x828B813C; continue 'dispatch;
	}
	pc = 0x828B80EC; continue 'dispatch;
            }
            0x828B80EC => {
    //   block [0x828B80EC..0x828B810C)
	// 828B80EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B80F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B80F4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B80F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B80FC: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 828B8100: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B8104: 41980008  blt cr6, 0x828b810c
	if ctx.cr[6].lt {
	pc = 0x828B810C; continue 'dispatch;
	}
	// 828B8108: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x828B810C; continue 'dispatch;
            }
            0x828B810C => {
    //   block [0x828B810C..0x828B8128)
	// 828B810C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B8110: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B8114: 419A0014  beq cr6, 0x828b8128
	if ctx.cr[6].eq {
	pc = 0x828B8128; continue 'dispatch;
	}
	// 828B8118: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B811C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B8120: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B8124: 4800000C  b 0x828b8130
	pc = 0x828B8130; continue 'dispatch;
            }
            0x828B8128 => {
    //   block [0x828B8128..0x828B8130)
	// 828B8128: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B812C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828B8130; continue 'dispatch;
            }
            0x828B8130 => {
    //   block [0x828B8130..0x828B813C)
	// 828B8130: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8134: 4199FFB8  bgt cr6, 0x828b80ec
	if ctx.cr[6].gt {
	pc = 0x828B80EC; continue 'dispatch;
	}
	// 828B8138: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828B813C; continue 'dispatch;
            }
            0x828B813C => {
    //   block [0x828B813C..0x828B8158)
	// 828B813C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B8140: 419A0040  beq cr6, 0x828b8180
	if ctx.cr[6].eq {
	pc = 0x828B8180; continue 'dispatch;
	}
	// 828B8144: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8148: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 828B814C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8150: 41990008  bgt cr6, 0x828b8158
	if ctx.cr[6].gt {
	pc = 0x828B8158; continue 'dispatch;
	}
	// 828B8154: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828B8158; continue 'dispatch;
            }
            0x828B8158 => {
    //   block [0x828B8158..0x828B8180)
	// 828B8158: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B815C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8160: 409A0020  bne cr6, 0x828b8180
	if !ctx.cr[6].eq {
	pc = 0x828B8180; continue 'dispatch;
	}
	// 828B8164: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B8168: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B816C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B8170: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8174: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B8178: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B817C: 4800001C  b 0x828b8198
	pc = 0x828B8198; continue 'dispatch;
            }
            0x828B8180 => {
    //   block [0x828B8180..0x828B8194)
	// 828B8180: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B8184: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8188: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B818C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8190: 48000008  b 0x828b8198
	pc = 0x828B8198; continue 'dispatch;
            }
            0x828B8194 => {
    //   block [0x828B8194..0x828B8198)
	// 828B8194: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828B8198; continue 'dispatch;
            }
            0x828B8198 => {
    //   block [0x828B8198..0x828B8200)
	// 828B8198: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B819C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B81A0: 419A0068  beq cr6, 0x828b8208
	if ctx.cr[6].eq {
	pc = 0x828B8208; continue 'dispatch;
	}
	// 828B81A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B81A8: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B81AC: 4BC2D305  bl 0x824e54b0
	ctx.lr = 0x828B81B0;
	sub_824E54B0(ctx, base);
	// 828B81B0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828B81B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B81B8: 409A0050  bne cr6, 0x828b8208
	if !ctx.cr[6].eq {
	pc = 0x828B8208; continue 'dispatch;
	}
	// 828B81BC: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 828B81C0: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 828B81C4: 3BEB3C38  addi r31, r11, 0x3c38
	ctx.r[31].s64 = ctx.r[11].s64 + 15416;
	// 828B81C8: 816A3C3C  lwz r11, 0x3c3c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15420 as u32) ) } as u64;
	// 828B81CC: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828B81D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B81D4: 409A002C  bne cr6, 0x828b8200
	if !ctx.cr[6].eq {
	pc = 0x828B8200; continue 'dispatch;
	}
	// 828B81D8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828B81DC: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828B81E0: 916A3C3C  stw r11, 0x3c3c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15420 as u32), ctx.r[11].u32 ) };
	// 828B81E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B81E8: 38892C68  addi r4, r9, 0x2c68
	ctx.r[4].s64 = ctx.r[9].s64 + 11368;
	// 828B81EC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B81F0: 4B974CE1  bl 0x8222ced0
	ctx.lr = 0x828B81F4;
	sub_8222CED0(ctx, base);
	// 828B81F4: 3D00832B  lis r8, -0x7cd5
	ctx.r[8].s64 = -2094333952;
	// 828B81F8: 3868EB08  addi r3, r8, -0x14f8
	ctx.r[3].s64 = ctx.r[8].s64 + -5368;
	// 828B81FC: 483F1D25  bl 0x82ca9f20
	ctx.lr = 0x828B8200;
	sub_82CA9F20(ctx, base);
	pc = 0x828B8200; continue 'dispatch;
            }
            0x828B8200 => {
    //   block [0x828B8200..0x828B8208)
	// 828B8200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8204: 48000008  b 0x828b820c
	pc = 0x828B820C; continue 'dispatch;
            }
            0x828B8208 => {
    //   block [0x828B8208..0x828B820C)
	// 828B8208: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	pc = 0x828B820C; continue 'dispatch;
            }
            0x828B820C => {
    //   block [0x828B820C..0x828B8224)
	// 828B820C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B8210: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B8214: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B8218: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B821C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B8220: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8228 size=180
    let mut pc: u32 = 0x828B8228;
    'dispatch: loop {
        match pc {
            0x828B8228 => {
    //   block [0x828B8228..0x828B82C4)
	// 828B8228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B822C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B8230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B8234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B8238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B823C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B8240: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B8244: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B8248: 419A007C  beq cr6, 0x828b82c4
	if ctx.cr[6].eq {
	pc = 0x828B82C4; continue 'dispatch;
	}
	// 828B824C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B8250: 38BE001C  addi r5, r30, 0x1c
	ctx.r[5].s64 = ctx.r[30].s64 + 28;
	// 828B8254: 388B2C74  addi r4, r11, 0x2c74
	ctx.r[4].s64 = ctx.r[11].s64 + 11380;
	// 828B8258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B825C: 4BAF513D  bl 0x823ad398
	ctx.lr = 0x828B8260;
	sub_823AD398(ctx, base);
	// 828B8260: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828B8264: 38BE0020  addi r5, r30, 0x20
	ctx.r[5].s64 = ctx.r[30].s64 + 32;
	// 828B8268: 388A2C88  addi r4, r10, 0x2c88
	ctx.r[4].s64 = ctx.r[10].s64 + 11400;
	// 828B826C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8270: 4BAF5129  bl 0x823ad398
	ctx.lr = 0x828B8274;
	sub_823AD398(ctx, base);
	// 828B8274: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828B8278: 38BE0024  addi r5, r30, 0x24
	ctx.r[5].s64 = ctx.r[30].s64 + 36;
	// 828B827C: 38892CA4  addi r4, r9, 0x2ca4
	ctx.r[4].s64 = ctx.r[9].s64 + 11428;
	// 828B8280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8284: 4BAF50BD  bl 0x823ad340
	ctx.lr = 0x828B8288;
	sub_823AD340(ctx, base);
	// 828B8288: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828B828C: 38BE0025  addi r5, r30, 0x25
	ctx.r[5].s64 = ctx.r[30].s64 + 37;
	// 828B8290: 38882CB4  addi r4, r8, 0x2cb4
	ctx.r[4].s64 = ctx.r[8].s64 + 11444;
	// 828B8294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8298: 4BAF50A9  bl 0x823ad340
	ctx.lr = 0x828B829C;
	sub_823AD340(ctx, base);
	// 828B829C: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828B82A0: 38BE0028  addi r5, r30, 0x28
	ctx.r[5].s64 = ctx.r[30].s64 + 40;
	// 828B82A4: 38872CCC  addi r4, r7, 0x2ccc
	ctx.r[4].s64 = ctx.r[7].s64 + 11468;
	// 828B82A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B82AC: 4BAF5145  bl 0x823ad3f0
	ctx.lr = 0x828B82B0;
	sub_823AD3F0(ctx, base);
	// 828B82B0: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828B82B4: 38BE002C  addi r5, r30, 0x2c
	ctx.r[5].s64 = ctx.r[30].s64 + 44;
	// 828B82B8: 38862CEC  addi r4, r6, 0x2cec
	ctx.r[4].s64 = ctx.r[6].s64 + 11500;
	// 828B82BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B82C0: 4BAF5131  bl 0x823ad3f0
	ctx.lr = 0x828B82C4;
	sub_823AD3F0(ctx, base);
	pc = 0x828B82C4; continue 'dispatch;
            }
            0x828B82C4 => {
    //   block [0x828B82C4..0x828B82DC)
	// 828B82C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B82C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B82CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B82D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B82D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B82D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B82E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B82E0 size=1244
    let mut pc: u32 = 0x828B82E0;
    'dispatch: loop {
        match pc {
            0x828B82E0 => {
    //   block [0x828B82E0..0x828B8380)
	// 828B82E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B82E4: 483F1125  bl 0x82ca9408
	ctx.lr = 0x828B82E8;
	sub_82CA93D0(ctx, base);
	// 828B82E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B82EC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828B82F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B82F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B82F8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B82FC: 419A02A4  beq cr6, 0x828b85a0
	if ctx.cr[6].eq {
	pc = 0x828B85A0; continue 'dispatch;
	}
	// 828B8300: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B8304: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828B8308: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B830C: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828B8310: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B8314: 4B95C585  bl 0x82214898
	ctx.lr = 0x828B8318;
	sub_82214898(ctx, base);
	// 828B8318: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B831C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828B8320: 4BC19BA9  bl 0x824d1ec8
	ctx.lr = 0x828B8324;
	sub_824D1EC8(ctx, base);
	// 828B8324: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828B8328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B832C: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 828B8330: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828B8334: 4B8DBB05  bl 0x82193e38
	ctx.lr = 0x828B8338;
	sub_82193E38(ctx, base);
	// 828B8338: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B833C: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 828B8340: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B8344: 80EB0024  lwz r7, 0x24(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B8348: 54E6EFFE  rlwinm r6, r7, 0x1d, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x00000007u64;
	// 828B834C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828B8350: 419A00F4  beq cr6, 0x828b8444
	if ctx.cr[6].eq {
	pc = 0x828B8444; continue 'dispatch;
	}
	// 828B8354: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B8358: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B835C: 419A0024  beq cr6, 0x828b8380
	if ctx.cr[6].eq {
	pc = 0x828B8380; continue 'dispatch;
	}
	// 828B8360: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 828B8364: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B8368: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B836C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B8370: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8374: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828B8378: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B837C: 480000CC  b 0x828b8448
	pc = 0x828B8448; continue 'dispatch;
            }
            0x828B8380 => {
    //   block [0x828B8380..0x828B839C)
	// 828B8380: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B8384: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B8388: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B838C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B8390: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B8394: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8398: 40810054  ble 0x828b83ec
	if !ctx.cr[0].gt {
	pc = 0x828B83EC; continue 'dispatch;
	}
	pc = 0x828B839C; continue 'dispatch;
            }
            0x828B839C => {
    //   block [0x828B839C..0x828B83BC)
	// 828B839C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B83A0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B83A4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B83A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B83AC: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828B83B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B83B4: 41980008  blt cr6, 0x828b83bc
	if ctx.cr[6].lt {
	pc = 0x828B83BC; continue 'dispatch;
	}
	// 828B83B8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x828B83BC; continue 'dispatch;
            }
            0x828B83BC => {
    //   block [0x828B83BC..0x828B83D8)
	// 828B83BC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B83C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B83C4: 419A0014  beq cr6, 0x828b83d8
	if ctx.cr[6].eq {
	pc = 0x828B83D8; continue 'dispatch;
	}
	// 828B83C8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B83CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B83D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B83D4: 4800000C  b 0x828b83e0
	pc = 0x828B83E0; continue 'dispatch;
            }
            0x828B83D8 => {
    //   block [0x828B83D8..0x828B83E0)
	// 828B83D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B83DC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828B83E0; continue 'dispatch;
            }
            0x828B83E0 => {
    //   block [0x828B83E0..0x828B83EC)
	// 828B83E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B83E4: 4199FFB8  bgt cr6, 0x828b839c
	if ctx.cr[6].gt {
	pc = 0x828B839C; continue 'dispatch;
	}
	// 828B83E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828B83EC; continue 'dispatch;
            }
            0x828B83EC => {
    //   block [0x828B83EC..0x828B8408)
	// 828B83EC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B83F0: 419A0040  beq cr6, 0x828b8430
	if ctx.cr[6].eq {
	pc = 0x828B8430; continue 'dispatch;
	}
	// 828B83F4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B83F8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828B83FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8400: 41990008  bgt cr6, 0x828b8408
	if ctx.cr[6].gt {
	pc = 0x828B8408; continue 'dispatch;
	}
	// 828B8404: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828B8408; continue 'dispatch;
            }
            0x828B8408 => {
    //   block [0x828B8408..0x828B8430)
	// 828B8408: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B840C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8410: 409A0020  bne cr6, 0x828b8430
	if !ctx.cr[6].eq {
	pc = 0x828B8430; continue 'dispatch;
	}
	// 828B8414: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B8418: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B841C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B8420: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8424: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828B8428: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B842C: 4800001C  b 0x828b8448
	pc = 0x828B8448; continue 'dispatch;
            }
            0x828B8430 => {
    //   block [0x828B8430..0x828B8444)
	// 828B8430: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B8434: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8438: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828B843C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8440: 48000008  b 0x828b8448
	pc = 0x828B8448; continue 'dispatch;
            }
            0x828B8444 => {
    //   block [0x828B8444..0x828B8448)
	// 828B8444: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828B8448; continue 'dispatch;
            }
            0x828B8448 => {
    //   block [0x828B8448..0x828B8490)
	// 828B8448: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B844C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8450: 419A0364  beq cr6, 0x828b87b4
	if ctx.cr[6].eq {
	pc = 0x828B87B4; continue 'dispatch;
	}
	// 828B8454: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B8458: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828B845C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B8460: 419A00F4  beq cr6, 0x828b8554
	if ctx.cr[6].eq {
	pc = 0x828B8554; continue 'dispatch;
	}
	// 828B8464: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B8468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B846C: 419A0024  beq cr6, 0x828b8490
	if ctx.cr[6].eq {
	pc = 0x828B8490; continue 'dispatch;
	}
	// 828B8470: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828B8474: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B8478: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B847C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B8480: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8484: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828B8488: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B848C: 480000CC  b 0x828b8558
	pc = 0x828B8558; continue 'dispatch;
            }
            0x828B8490 => {
    //   block [0x828B8490..0x828B84AC)
	// 828B8490: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B8494: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B8498: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B849C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B84A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B84A4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B84A8: 40810054  ble 0x828b84fc
	if !ctx.cr[0].gt {
	pc = 0x828B84FC; continue 'dispatch;
	}
	pc = 0x828B84AC; continue 'dispatch;
            }
            0x828B84AC => {
    //   block [0x828B84AC..0x828B84CC)
	// 828B84AC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B84B0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B84B4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B84B8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B84BC: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828B84C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B84C4: 41980008  blt cr6, 0x828b84cc
	if ctx.cr[6].lt {
	pc = 0x828B84CC; continue 'dispatch;
	}
	// 828B84C8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x828B84CC; continue 'dispatch;
            }
            0x828B84CC => {
    //   block [0x828B84CC..0x828B84E8)
	// 828B84CC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B84D0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B84D4: 419A0014  beq cr6, 0x828b84e8
	if ctx.cr[6].eq {
	pc = 0x828B84E8; continue 'dispatch;
	}
	// 828B84D8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B84DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B84E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B84E4: 4800000C  b 0x828b84f0
	pc = 0x828B84F0; continue 'dispatch;
            }
            0x828B84E8 => {
    //   block [0x828B84E8..0x828B84F0)
	// 828B84E8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B84EC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828B84F0; continue 'dispatch;
            }
            0x828B84F0 => {
    //   block [0x828B84F0..0x828B84FC)
	// 828B84F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B84F4: 4199FFB8  bgt cr6, 0x828b84ac
	if ctx.cr[6].gt {
	pc = 0x828B84AC; continue 'dispatch;
	}
	// 828B84F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828B84FC; continue 'dispatch;
            }
            0x828B84FC => {
    //   block [0x828B84FC..0x828B8518)
	// 828B84FC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B8500: 419A0040  beq cr6, 0x828b8540
	if ctx.cr[6].eq {
	pc = 0x828B8540; continue 'dispatch;
	}
	// 828B8504: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8508: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828B850C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8510: 41990008  bgt cr6, 0x828b8518
	if ctx.cr[6].gt {
	pc = 0x828B8518; continue 'dispatch;
	}
	// 828B8514: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828B8518; continue 'dispatch;
            }
            0x828B8518 => {
    //   block [0x828B8518..0x828B8540)
	// 828B8518: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B851C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8520: 409A0020  bne cr6, 0x828b8540
	if !ctx.cr[6].eq {
	pc = 0x828B8540; continue 'dispatch;
	}
	// 828B8524: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B8528: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B852C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B8530: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8534: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828B8538: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B853C: 4800001C  b 0x828b8558
	pc = 0x828B8558; continue 'dispatch;
            }
            0x828B8540 => {
    //   block [0x828B8540..0x828B8554)
	// 828B8540: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B8544: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8548: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828B854C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8550: 48000008  b 0x828b8558
	pc = 0x828B8558; continue 'dispatch;
            }
            0x828B8554 => {
    //   block [0x828B8554..0x828B8558)
	// 828B8554: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828B8558; continue 'dispatch;
            }
            0x828B8558 => {
    //   block [0x828B8558..0x828B8584)
	// 828B8558: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B855C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8560: 419A0254  beq cr6, 0x828b87b4
	if ctx.cr[6].eq {
	pc = 0x828B87B4; continue 'dispatch;
	}
	// 828B8564: 83FC0090  lwz r31, 0x90(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B8568: C0050028  lfs f0, 0x28(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B856C: D01C0028  stfs f0, 0x28(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828B8570: 57EB0630  rlwinm r11, r31, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828B8574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8578: 409A000C  bne cr6, 0x828b8584
	if !ctx.cr[6].eq {
	pc = 0x828B8584; continue 'dispatch;
	}
	// 828B857C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B8580: 4BCBA369  bl 0x825728e8
	ctx.lr = 0x828B8584;
	sub_825728E8(ctx, base);
	pc = 0x828B8584; continue 'dispatch;
            }
            0x828B8584 => {
    //   block [0x828B8584..0x828B85A0)
	// 828B8584: 817C0090  lwz r11, 0x90(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B8588: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828B858C: 616A0080  ori r10, r11, 0x80
	ctx.r[10].u64 = ctx.r[11].u64 | 128;
	// 828B8590: 915C0090  stw r10, 0x90(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 828B8594: 409A0220  bne cr6, 0x828b87b4
	if !ctx.cr[6].eq {
	pc = 0x828B87B4; continue 'dispatch;
	}
	// 828B8598: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B859C: 480001FC  b 0x828b8798
	pc = 0x828B8798; continue 'dispatch;
            }
            0x828B85A0 => {
    //   block [0x828B85A0..0x828B85E4)
	// 828B85A0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B85A4: 3BBF000C  addi r29, r31, 0xc
	ctx.r[29].s64 = ctx.r[31].s64 + 12;
	// 828B85A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B85AC: 419A0038  beq cr6, 0x828b85e4
	if ctx.cr[6].eq {
	pc = 0x828B85E4; continue 'dispatch;
	}
	// 828B85B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B85B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B85B8: 419A00BC  beq cr6, 0x828b8674
	if ctx.cr[6].eq {
	pc = 0x828B8674; continue 'dispatch;
	}
	// 828B85BC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828B85C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B85C4: 419A0020  beq cr6, 0x828b85e4
	if ctx.cr[6].eq {
	pc = 0x828B85E4; continue 'dispatch;
	}
	// 828B85C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B85CC: 4B8BB86D  bl 0x82173e38
	ctx.lr = 0x828B85D0;
	sub_82173E38(ctx, base);
	// 828B85D0: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B85D4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B85D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B85DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B85E0: 409A0008  bne cr6, 0x828b85e8
	if !ctx.cr[6].eq {
	pc = 0x828B85E8; continue 'dispatch;
	}
	pc = 0x828B85E4; continue 'dispatch;
            }
            0x828B85E4 => {
    //   block [0x828B85E4..0x828B85E8)
	// 828B85E4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828B85E8; continue 'dispatch;
            }
            0x828B85E8 => {
    //   block [0x828B85E8..0x828B8674)
	// 828B85E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B85EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B85F0: 419A01C4  beq cr6, 0x828b87b4
	if ctx.cr[6].eq {
	pc = 0x828B87B4; continue 'dispatch;
	}
	// 828B85F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B85F8: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 828B85FC: 4BC198CD  bl 0x824d1ec8
	ctx.lr = 0x828B8600;
	sub_824D1EC8(ctx, base);
	// 828B8600: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B8604: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828B8608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B860C: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828B8610: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B8614: 4B8DB825  bl 0x82193e38
	ctx.lr = 0x828B8618;
	sub_82193E38(ctx, base);
	// 828B8618: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B861C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B8620: 4BC198A9  bl 0x824d1ec8
	ctx.lr = 0x828B8624;
	sub_824D1EC8(ctx, base);
	// 828B8624: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828B8628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B862C: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 828B8630: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828B8634: 4B8DB805  bl 0x82193e38
	ctx.lr = 0x828B8638;
	sub_82193E38(ctx, base);
	// 828B8638: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B863C: 80EB0024  lwz r7, 0x24(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B8640: 54E6EFFE  rlwinm r6, r7, 0x1d, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x00000007u64;
	// 828B8644: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828B8648: 419A00F4  beq cr6, 0x828b873c
	if ctx.cr[6].eq {
	pc = 0x828B873C; continue 'dispatch;
	}
	// 828B864C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B8650: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B8654: 419A002C  beq cr6, 0x828b8680
	if ctx.cr[6].eq {
	pc = 0x828B8680; continue 'dispatch;
	}
	// 828B8658: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 828B865C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B8660: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B8664: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B8668: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B866C: 83C90004  lwz r30, 4(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8670: 480000D0  b 0x828b8740
	pc = 0x828B8740; continue 'dispatch;
            }
            0x828B8674 => {
    //   block [0x828B8674..0x828B8680)
	// 828B8674: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B8678: 4B8DB7C1  bl 0x82193e38
	ctx.lr = 0x828B867C;
	sub_82193E38(ctx, base);
	// 828B867C: 4BFFFF68  b 0x828b85e4
	pc = 0x828B85E4; continue 'dispatch;
            }
            0x828B8680 => {
    //   block [0x828B8680..0x828B869C)
	// 828B8680: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B8684: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B8688: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B868C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B8690: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B8694: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8698: 40810054  ble 0x828b86ec
	if !ctx.cr[0].gt {
	pc = 0x828B86EC; continue 'dispatch;
	}
	pc = 0x828B869C; continue 'dispatch;
            }
            0x828B869C => {
    //   block [0x828B869C..0x828B86BC)
	// 828B869C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B86A0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B86A4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828B86A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B86AC: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828B86B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B86B4: 41980008  blt cr6, 0x828b86bc
	if ctx.cr[6].lt {
	pc = 0x828B86BC; continue 'dispatch;
	}
	// 828B86B8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x828B86BC; continue 'dispatch;
            }
            0x828B86BC => {
    //   block [0x828B86BC..0x828B86D8)
	// 828B86BC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B86C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B86C4: 419A0014  beq cr6, 0x828b86d8
	if ctx.cr[6].eq {
	pc = 0x828B86D8; continue 'dispatch;
	}
	// 828B86C8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B86CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B86D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B86D4: 4800000C  b 0x828b86e0
	pc = 0x828B86E0; continue 'dispatch;
            }
            0x828B86D8 => {
    //   block [0x828B86D8..0x828B86E0)
	// 828B86D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B86DC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828B86E0; continue 'dispatch;
            }
            0x828B86E0 => {
    //   block [0x828B86E0..0x828B86EC)
	// 828B86E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B86E4: 4199FFB8  bgt cr6, 0x828b869c
	if ctx.cr[6].gt {
	pc = 0x828B869C; continue 'dispatch;
	}
	// 828B86E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828B86EC; continue 'dispatch;
            }
            0x828B86EC => {
    //   block [0x828B86EC..0x828B8708)
	// 828B86EC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B86F0: 419A003C  beq cr6, 0x828b872c
	if ctx.cr[6].eq {
	pc = 0x828B872C; continue 'dispatch;
	}
	// 828B86F4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B86F8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828B86FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8700: 41990008  bgt cr6, 0x828b8708
	if ctx.cr[6].gt {
	pc = 0x828B8708; continue 'dispatch;
	}
	// 828B8704: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828B8708; continue 'dispatch;
            }
            0x828B8708 => {
    //   block [0x828B8708..0x828B872C)
	// 828B8708: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B870C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8710: 409A001C  bne cr6, 0x828b872c
	if !ctx.cr[6].eq {
	pc = 0x828B872C; continue 'dispatch;
	}
	// 828B8714: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B8718: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B871C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B8720: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8724: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8728: 48000018  b 0x828b8740
	pc = 0x828B8740; continue 'dispatch;
            }
            0x828B872C => {
    //   block [0x828B872C..0x828B873C)
	// 828B872C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B8730: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8734: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8738: 48000008  b 0x828b8740
	pc = 0x828B8740; continue 'dispatch;
            }
            0x828B873C => {
    //   block [0x828B873C..0x828B8740)
	// 828B873C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828B8740; continue 'dispatch;
            }
            0x828B8740 => {
    //   block [0x828B8740..0x828B8780)
	// 828B8740: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B8744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8748: 419A006C  beq cr6, 0x828b87b4
	if ctx.cr[6].eq {
	pc = 0x828B87B4; continue 'dispatch;
	}
	// 828B874C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B8750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8754: 4B921C5D  bl 0x821da3b0
	ctx.lr = 0x828B8758;
	sub_821DA3B0(ctx, base);
	// 828B8758: 4B8F9DA1  bl 0x821b24f8
	ctx.lr = 0x828B875C;
	sub_821B24F8(ctx, base);
	// 828B875C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B8760: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B8764: 4BCB9CD5  bl 0x82572438
	ctx.lr = 0x828B8768;
	sub_82572438(ctx, base);
	// 828B8768: 83FE0090  lwz r31, 0x90(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B876C: 57EB0630  rlwinm r11, r31, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828B8770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8774: 409A000C  bne cr6, 0x828b8780
	if !ctx.cr[6].eq {
	pc = 0x828B8780; continue 'dispatch;
	}
	// 828B8778: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B877C: 4BCBA16D  bl 0x825728e8
	ctx.lr = 0x828B8780;
	sub_825728E8(ctx, base);
	pc = 0x828B8780; continue 'dispatch;
            }
            0x828B8780 => {
    //   block [0x828B8780..0x828B8798)
	// 828B8780: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B8784: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828B8788: 616A0080  ori r10, r11, 0x80
	ctx.r[10].u64 = ctx.r[11].u64 | 128;
	// 828B878C: 915E0090  stw r10, 0x90(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 828B8790: 409A0024  bne cr6, 0x828b87b4
	if !ctx.cr[6].eq {
	pc = 0x828B87B4; continue 'dispatch;
	}
	// 828B8794: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x828B8798; continue 'dispatch;
            }
            0x828B8798 => {
    //   block [0x828B8798..0x828B87B4)
	// 828B8798: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828B879C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828B87A0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B87A4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B87A8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B87AC: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B87B0: 4B958869  bl 0x82211018
	ctx.lr = 0x828B87B4;
	sub_82211018(ctx, base);
	pc = 0x828B87B4; continue 'dispatch;
            }
            0x828B87B4 => {
    //   block [0x828B87B4..0x828B87BC)
	// 828B87B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B87B8: 483F0CA0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B87C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B87C0 size=244
    let mut pc: u32 = 0x828B87C0;
    'dispatch: loop {
        match pc {
            0x828B87C0 => {
    //   block [0x828B87C0..0x828B88B4)
	// 828B87C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B87C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B87C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B87CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B87D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B87D4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B87D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B87DC: 3BCB2D0C  addi r30, r11, 0x2d0c
	ctx.r[30].s64 = ctx.r[11].s64 + 11532;
	// 828B87E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B87E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B87E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B87EC: 4B9746E5  bl 0x8222ced0
	ctx.lr = 0x828B87F0;
	sub_8222CED0(ctx, base);
	// 828B87F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B87F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B87F8: 480000C1  bl 0x828b88b8
	ctx.lr = 0x828B87FC;
	sub_828B88B8(ctx, base);
	// 828B87FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8800: 4B95C5D9  bl 0x82214dd8
	ctx.lr = 0x828B8804;
	sub_82214DD8(ctx, base);
	// 828B8804: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828B8808: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B880C: 388A2D14  addi r4, r10, 0x2d14
	ctx.r[4].s64 = ctx.r[10].s64 + 11540;
	// 828B8810: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B8814: 4B9746BD  bl 0x8222ced0
	ctx.lr = 0x828B8818;
	sub_8222CED0(ctx, base);
	// 828B8818: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B881C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B8820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8824: 4B9746AD  bl 0x8222ced0
	ctx.lr = 0x828B8828;
	sub_8222CED0(ctx, base);
	// 828B8828: 3D20828B  lis r9, -0x7d75
	ctx.r[9].s64 = -2104819712;
	// 828B882C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8830: 38C97F40  addi r6, r9, 0x7f40
	ctx.r[6].s64 = ctx.r[9].s64 + 32576;
	// 828B8834: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828B8838: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B883C: 480002C5  bl 0x828b8b00
	ctx.lr = 0x828B8840;
	sub_828B8B00(ctx, base);
	// 828B8840: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8844: 4B95C595  bl 0x82214dd8
	ctx.lr = 0x828B8848;
	sub_82214DD8(ctx, base);
	// 828B8848: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B884C: 4B95C58D  bl 0x82214dd8
	ctx.lr = 0x828B8850;
	sub_82214DD8(ctx, base);
	// 828B8850: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828B8854: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B8858: 38882D28  addi r4, r8, 0x2d28
	ctx.r[4].s64 = ctx.r[8].s64 + 11560;
	// 828B885C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8860: 4B974671  bl 0x8222ced0
	ctx.lr = 0x828B8864;
	sub_8222CED0(ctx, base);
	// 828B8864: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B8868: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B886C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B8870: 4B974661  bl 0x8222ced0
	ctx.lr = 0x828B8874;
	sub_8222CED0(ctx, base);
	// 828B8874: 3CE0828B  lis r7, -0x7d75
	ctx.r[7].s64 = -2104819712;
	// 828B8878: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B887C: 38C77F98  addi r6, r7, 0x7f98
	ctx.r[6].s64 = ctx.r[7].s64 + 32664;
	// 828B8880: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828B8884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B8888: 48000279  bl 0x828b8b00
	ctx.lr = 0x828B888C;
	sub_828B8B00(ctx, base);
	// 828B888C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B8890: 4B95C549  bl 0x82214dd8
	ctx.lr = 0x828B8894;
	sub_82214DD8(ctx, base);
	// 828B8894: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8898: 4B95C541  bl 0x82214dd8
	ctx.lr = 0x828B889C;
	sub_82214DD8(ctx, base);
	// 828B889C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B88A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B88A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B88A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B88AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B88B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B88B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B88B8 size=584
    let mut pc: u32 = 0x828B88B8;
    'dispatch: loop {
        match pc {
            0x828B88B8 => {
    //   block [0x828B88B8..0x828B88E0)
	// 828B88B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B88BC: 483F0B45  bl 0x82ca9400
	ctx.lr = 0x828B88C0;
	sub_82CA93D0(ctx, base);
	// 828B88C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B88C4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B88C8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828B88CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B88D0: 409A0010  bne cr6, 0x828b88e0
	if !ctx.cr[6].eq {
	pc = 0x828B88E0; continue 'dispatch;
	}
	// 828B88D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B88D8: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828B88DC: 48000008  b 0x828b88e4
	pc = 0x828B88E4; continue 'dispatch;
            }
            0x828B88E0 => {
    //   block [0x828B88E0..0x828B88E4)
	// 828B88E0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828B88E4; continue 'dispatch;
            }
            0x828B88E4 => {
    //   block [0x828B88E4..0x828B895C)
	// 828B88E4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B88E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B88EC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B88F0: 4BB15CD1  bl 0x823ce5c0
	ctx.lr = 0x828B88F4;
	sub_823CE5C0(ctx, base);
	// 828B88F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B88F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B88FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B8900: 4BB15901  bl 0x823ce200
	ctx.lr = 0x828B8904;
	sub_823CE200(ctx, base);
	// 828B8904: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B8908: 4B8FF211  bl 0x821b7b18
	ctx.lr = 0x828B890C;
	sub_821B7B18(ctx, base);
	// 828B890C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828B8910: 4B966949  bl 0x8221f258
	ctx.lr = 0x828B8914;
	sub_8221F258(ctx, base);
	// 828B8914: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B8918: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B891C: 419A0040  beq cr6, 0x828b895c
	if ctx.cr[6].eq {
	pc = 0x828B895C; continue 'dispatch;
	}
	// 828B8920: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828B8924: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828B8928: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828B892C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B8930: 4B966929  bl 0x8221f258
	ctx.lr = 0x828B8934;
	sub_8221F258(ctx, base);
	// 828B8934: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B8938: 419A0028  beq cr6, 0x828b8960
	if ctx.cr[6].eq {
	pc = 0x828B8960; continue 'dispatch;
	}
	// 828B893C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828B8940: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828B8944: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B8948: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828B894C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B8950: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B8954: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B8958: 4800000C  b 0x828b8964
	pc = 0x828B8964; continue 'dispatch;
            }
            0x828B895C => {
    //   block [0x828B895C..0x828B8960)
	// 828B895C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828B8960; continue 'dispatch;
            }
            0x828B8960 => {
    //   block [0x828B8960..0x828B8964)
	// 828B8960: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828B8964; continue 'dispatch;
            }
            0x828B8964 => {
    //   block [0x828B8964..0x828B8A68)
	// 828B8964: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B8968: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B896C: 419A00FC  beq cr6, 0x828b8a68
	if ctx.cr[6].eq {
	pc = 0x828B8A68; continue 'dispatch;
	}
	// 828B8970: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8974: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828B8978: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B897C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B8980: 4B970789  bl 0x82229108
	ctx.lr = 0x828B8984;
	sub_82229108(ctx, base);
	// 828B8984: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828B8988: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828B898C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B8990: 3BCB8D00  addi r30, r11, -0x7300
	ctx.r[30].s64 = ctx.r[11].s64 + -29440;
	// 828B8994: 4B96EEED  bl 0x82227880
	ctx.lr = 0x828B8998;
	sub_82227880(ctx, base);
	// 828B8998: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B899C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828B89A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B89A4: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828B89A8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B89AC: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B89B0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828B89B4: 4B8E20CD  bl 0x8219aa80
	ctx.lr = 0x828B89B8;
	sub_8219AA80(ctx, base);
	// 828B89B8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828B89BC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B89C0: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828B89C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B89C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B89CC: 4BB15A55  bl 0x823ce420
	ctx.lr = 0x828B89D0;
	sub_823CE420(ctx, base);
	// 828B89D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B89D4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828B89D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B89DC: 4816BCED  bl 0x82a246c8
	ctx.lr = 0x828B89E0;
	sub_82A246C8(ctx, base);
	// 828B89E0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B89E4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828B89E8: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828B89EC: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828B89F0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B89F4: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B89F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B89FC: 4B97070D  bl 0x82229108
	ctx.lr = 0x828B8A00;
	sub_82229108(ctx, base);
	// 828B8A00: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 828B8A04: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828B8A08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B8A0C: 3BEB6B48  addi r31, r11, 0x6b48
	ctx.r[31].s64 = ctx.r[11].s64 + 27464;
	// 828B8A10: 4B96EE71  bl 0x82227880
	ctx.lr = 0x828B8A14;
	sub_82227880(ctx, base);
	// 828B8A14: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828B8A18: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828B8A1C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B8A20: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828B8A24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B8A28: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828B8A2C: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828B8A30: 4B8E2051  bl 0x8219aa80
	ctx.lr = 0x828B8A34;
	sub_8219AA80(ctx, base);
	// 828B8A34: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828B8A38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B8A3C: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828B8A40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8A44: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B8A48: 4BB159D9  bl 0x823ce420
	ctx.lr = 0x828B8A4C;
	sub_823CE420(ctx, base);
	// 828B8A4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B8A50: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828B8A54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B8A58: 4816BC71  bl 0x82a246c8
	ctx.lr = 0x828B8A5C;
	sub_82A246C8(ctx, base);
	// 828B8A5C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B8A60: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828B8A64: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x828B8A68; continue 'dispatch;
            }
            0x828B8A68 => {
    //   block [0x828B8A68..0x828B8A78)
	// 828B8A68: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828B8A6C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B8A70: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828B8A74: 419A0020  beq cr6, 0x828b8a94
	if ctx.cr[6].eq {
	pc = 0x828B8A94; continue 'dispatch;
	}
	pc = 0x828B8A78; continue 'dispatch;
            }
            0x828B8A78 => {
    //   block [0x828B8A78..0x828B8A94)
	// 828B8A78: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B8A7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8A80: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B8A84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B8A88: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B8A8C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8A90: 4082FFE8  bne 0x828b8a78
	if !ctx.cr[0].eq {
	pc = 0x828B8A78; continue 'dispatch;
	}
	pc = 0x828B8A94; continue 'dispatch;
            }
            0x828B8A94 => {
    //   block [0x828B8A94..0x828B8AB4)
	// 828B8A94: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8A98: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B8A9C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828B8AA0: 4BA3CEA9  bl 0x822f5948
	ctx.lr = 0x828B8AA4;
	sub_822F5948(ctx, base);
	// 828B8AA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B8AA8: 4B8FF071  bl 0x821b7b18
	ctx.lr = 0x828B8AAC;
	sub_821B7B18(ctx, base);
	// 828B8AAC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B8AB0: 419A0040  beq cr6, 0x828b8af0
	if ctx.cr[6].eq {
	pc = 0x828B8AF0; continue 'dispatch;
	}
	pc = 0x828B8AB4; continue 'dispatch;
            }
            0x828B8AB4 => {
    //   block [0x828B8AB4..0x828B8AF0)
	// 828B8AB4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B8AB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8ABC: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B8AC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B8AC4: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B8AC8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8ACC: 4082FFE8  bne 0x828b8ab4
	if !ctx.cr[0].eq {
	pc = 0x828B8AB4; continue 'dispatch;
	}
	// 828B8AD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8AD4: 409A001C  bne cr6, 0x828b8af0
	if !ctx.cr[6].eq {
	pc = 0x828B8AF0; continue 'dispatch;
	}
	// 828B8AD8: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B8ADC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8AE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B8AE4: 4E800421  bctrl
	ctx.lr = 0x828B8AE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B8AE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B8AEC: 4B96324D  bl 0x8221bd38
	ctx.lr = 0x828B8AF0;
	sub_8221BD38(ctx, base);
            }
            0x828B8AF0 => {
    //   block [0x828B8AF0..0x828B8B00)
	// 828B8AF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8AF4: 4B8FF025  bl 0x821b7b18
	ctx.lr = 0x828B8AF8;
	sub_821B7B18(ctx, base);
	// 828B8AF8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B8AFC: 483F0954  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8B00 size=512
    let mut pc: u32 = 0x828B8B00;
    'dispatch: loop {
        match pc {
            0x828B8B00 => {
    //   block [0x828B8B00..0x828B8B38)
	// 828B8B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8B04: 483F08F9  bl 0x82ca93fc
	ctx.lr = 0x828B8B08;
	sub_82CA93D0(ctx, base);
	// 828B8B08: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8B0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B8B10: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828B8B14: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828B8B18: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828B8B1C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828B8B20: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8B24: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828B8B28: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828B8B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8B30: 419A0008  beq cr6, 0x828b8b38
	if ctx.cr[6].eq {
	pc = 0x828B8B38; continue 'dispatch;
	}
	// 828B8B34: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828B8B38; continue 'dispatch;
            }
            0x828B8B38 => {
    //   block [0x828B8B38..0x828B8BCC)
	// 828B8B38: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8B3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B8B40: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8B44: 4BB15A7D  bl 0x823ce5c0
	ctx.lr = 0x828B8B48;
	sub_823CE5C0(ctx, base);
	// 828B8B48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B8B4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B8B50: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B8B54: 4BB155BD  bl 0x823ce110
	ctx.lr = 0x828B8B58;
	sub_823CE110(ctx, base);
	// 828B8B58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B8B5C: 4B8FEFBD  bl 0x821b7b18
	ctx.lr = 0x828B8B60;
	sub_821B7B18(ctx, base);
	// 828B8B60: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B8B64: 4B9666F5  bl 0x8221f258
	ctx.lr = 0x828B8B68;
	sub_8221F258(ctx, base);
	// 828B8B68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B8B6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B8B70: 419A005C  beq cr6, 0x828b8bcc
	if ctx.cr[6].eq {
	pc = 0x828B8BCC; continue 'dispatch;
	}
	// 828B8B74: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B8B78: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828B8B7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B8B80: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828B8B84: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B8B88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B8B8C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B8B90: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828B8B94: 4B9376AD  bl 0x821f0240
	ctx.lr = 0x828B8B98;
	sub_821F0240(ctx, base);
	// 828B8B98: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828B8B9C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828B8BA0: 4B9666B9  bl 0x8221f258
	ctx.lr = 0x828B8BA4;
	sub_8221F258(ctx, base);
	// 828B8BA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B8BA8: 419A0028  beq cr6, 0x828b8bd0
	if ctx.cr[6].eq {
	pc = 0x828B8BD0; continue 'dispatch;
	}
	// 828B8BAC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828B8BB0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828B8BB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B8BB8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828B8BBC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B8BC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B8BC4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828B8BC8: 4800000C  b 0x828b8bd4
	pc = 0x828B8BD4; continue 'dispatch;
            }
            0x828B8BCC => {
    //   block [0x828B8BCC..0x828B8BD0)
	// 828B8BCC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828B8BD0; continue 'dispatch;
            }
            0x828B8BD0 => {
    //   block [0x828B8BD0..0x828B8BD4)
	// 828B8BD0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828B8BD4; continue 'dispatch;
            }
            0x828B8BD4 => {
    //   block [0x828B8BD4..0x828B8BE8)
	// 828B8BD4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8BD8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828B8BDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8BE0: 419A0008  beq cr6, 0x828b8be8
	if ctx.cr[6].eq {
	pc = 0x828B8BE8; continue 'dispatch;
	}
	// 828B8BE4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828B8BE8; continue 'dispatch;
            }
            0x828B8BE8 => {
    //   block [0x828B8BE8..0x828B8C68)
	// 828B8BE8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828B8BEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8BF0: 419A0078  beq cr6, 0x828b8c68
	if ctx.cr[6].eq {
	pc = 0x828B8C68; continue 'dispatch;
	}
	// 828B8BF4: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8BF8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828B8BFC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8C00: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B8C04: 4B970505  bl 0x82229108
	ctx.lr = 0x828B8C08;
	sub_82229108(ctx, base);
	// 828B8C08: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828B8C0C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828B8C10: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B8C14: 3BCB8D40  addi r30, r11, -0x72c0
	ctx.r[30].s64 = ctx.r[11].s64 + -29376;
	// 828B8C18: 4B96EC69  bl 0x82227880
	ctx.lr = 0x828B8C1C;
	sub_82227880(ctx, base);
	// 828B8C1C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B8C20: 3D40823B  lis r10, -0x7dc5
	ctx.r[10].s64 = -2110062592;
	// 828B8C24: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B8C28: 388A08A0  addi r4, r10, 0x8a0
	ctx.r[4].s64 = ctx.r[10].s64 + 2208;
	// 828B8C2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B8C30: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828B8C34: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828B8C38: 4B8E1E49  bl 0x8219aa80
	ctx.lr = 0x828B8C3C;
	sub_8219AA80(ctx, base);
	// 828B8C3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B8C40: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B8C44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B8C48: 4BB157D9  bl 0x823ce420
	ctx.lr = 0x828B8C4C;
	sub_823CE420(ctx, base);
	// 828B8C4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B8C50: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828B8C54: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B8C58: 4816BA71  bl 0x82a246c8
	ctx.lr = 0x828B8C5C;
	sub_82A246C8(ctx, base);
	// 828B8C5C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B8C60: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828B8C64: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828B8C68; continue 'dispatch;
            }
            0x828B8C68 => {
    //   block [0x828B8C68..0x828B8C78)
	// 828B8C68: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828B8C6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B8C70: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828B8C74: 419A0020  beq cr6, 0x828b8c94
	if ctx.cr[6].eq {
	pc = 0x828B8C94; continue 'dispatch;
	}
	pc = 0x828B8C78; continue 'dispatch;
            }
            0x828B8C78 => {
    //   block [0x828B8C78..0x828B8C94)
	// 828B8C78: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B8C7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8C80: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B8C84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B8C88: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B8C8C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8C90: 4082FFE8  bne 0x828b8c78
	if !ctx.cr[0].eq {
	pc = 0x828B8C78; continue 'dispatch;
	}
	pc = 0x828B8C94; continue 'dispatch;
            }
            0x828B8C94 => {
    //   block [0x828B8C94..0x828B8CB4)
	// 828B8C94: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8C98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B8C9C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828B8CA0: 4BA3CCA9  bl 0x822f5948
	ctx.lr = 0x828B8CA4;
	sub_822F5948(ctx, base);
	// 828B8CA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B8CA8: 4B8FEE71  bl 0x821b7b18
	ctx.lr = 0x828B8CAC;
	sub_821B7B18(ctx, base);
	// 828B8CAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B8CB0: 419A0040  beq cr6, 0x828b8cf0
	if ctx.cr[6].eq {
	pc = 0x828B8CF0; continue 'dispatch;
	}
	pc = 0x828B8CB4; continue 'dispatch;
            }
            0x828B8CB4 => {
    //   block [0x828B8CB4..0x828B8CF0)
	// 828B8CB4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B8CB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8CBC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B8CC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B8CC4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B8CC8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B8CCC: 4082FFE8  bne 0x828b8cb4
	if !ctx.cr[0].eq {
	pc = 0x828B8CB4; continue 'dispatch;
	}
	// 828B8CD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8CD4: 409A001C  bne cr6, 0x828b8cf0
	if !ctx.cr[6].eq {
	pc = 0x828B8CF0; continue 'dispatch;
	}
	// 828B8CD8: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B8CDC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8CE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B8CE4: 4E800421  bctrl
	ctx.lr = 0x828B8CE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B8CE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B8CEC: 4B96304D  bl 0x8221bd38
	ctx.lr = 0x828B8CF0;
	sub_8221BD38(ctx, base);
            }
            0x828B8CF0 => {
    //   block [0x828B8CF0..0x828B8D00)
	// 828B8CF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B8CF4: 4B8FEE25  bl 0x821b7b18
	ctx.lr = 0x828B8CF8;
	sub_821B7B18(ctx, base);
	// 828B8CF8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828B8CFC: 483F0750  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B8D00 size=56
    let mut pc: u32 = 0x828B8D00;
    'dispatch: loop {
        match pc {
            0x828B8D00 => {
    //   block [0x828B8D00..0x828B8D1C)
	// 828B8D00: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B8D04: 419A0018  beq cr6, 0x828b8d1c
	if ctx.cr[6].eq {
	pc = 0x828B8D1C; continue 'dispatch;
	}
	// 828B8D08: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B8D0C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B8D10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8D14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B8D18: 409A0008  bne cr6, 0x828b8d20
	if !ctx.cr[6].eq {
	pc = 0x828B8D20; continue 'dispatch;
	}
	pc = 0x828B8D1C; continue 'dispatch;
            }
            0x828B8D1C => {
    //   block [0x828B8D1C..0x828B8D20)
	// 828B8D1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828B8D20; continue 'dispatch;
            }
            0x828B8D20 => {
    //   block [0x828B8D20..0x828B8D38)
	// 828B8D20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B8D24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8D28: 419A0010  beq cr6, 0x828b8d38
	if ctx.cr[6].eq {
		sub_828B8D38(ctx, base);
		return;
	}
	// 828B8D2C: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828B8D30: 55636FFE  rlwinm r3, r11, 0xd, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 828B8D34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B8D38 size=8
    let mut pc: u32 = 0x828B8D38;
    'dispatch: loop {
        match pc {
            0x828B8D38 => {
    //   block [0x828B8D38..0x828B8D40)
	// 828B8D38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B8D3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8D40 size=372
    let mut pc: u32 = 0x828B8D40;
    'dispatch: loop {
        match pc {
            0x828B8D40 => {
    //   block [0x828B8D40..0x828B8D68)
	// 828B8D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B8D48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8D4C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828B8D50: 419A0018  beq cr6, 0x828b8d68
	if ctx.cr[6].eq {
	pc = 0x828B8D68; continue 'dispatch;
	}
	// 828B8D54: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B8D58: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B8D5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8D60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B8D64: 409A0008  bne cr6, 0x828b8d6c
	if !ctx.cr[6].eq {
	pc = 0x828B8D6C; continue 'dispatch;
	}
	pc = 0x828B8D68; continue 'dispatch;
            }
            0x828B8D68 => {
    //   block [0x828B8D68..0x828B8D6C)
	// 828B8D68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828B8D6C; continue 'dispatch;
            }
            0x828B8D6C => {
    //   block [0x828B8D6C..0x828B8DB4)
	// 828B8D6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B8D70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8D74: 419A012C  beq cr6, 0x828b8ea0
	if ctx.cr[6].eq {
	pc = 0x828B8EA0; continue 'dispatch;
	}
	// 828B8D78: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828B8D7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B8D80: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 828B8D84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B8D88: 419A00E8  beq cr6, 0x828b8e70
	if ctx.cr[6].eq {
	pc = 0x828B8E70; continue 'dispatch;
	}
	// 828B8D8C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B8D90: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B8D94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8D98: 419A001C  beq cr6, 0x828b8db4
	if ctx.cr[6].eq {
	pc = 0x828B8DB4; continue 'dispatch;
	}
	// 828B8D9C: 896B0053  lbz r11, 0x53(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(83 as u32) ) } as u64;
	// 828B8DA0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828B8DA4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B8DA8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8DAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B8DB0: 480000C4  b 0x828b8e74
	pc = 0x828B8E74; continue 'dispatch;
            }
            0x828B8DB4 => {
    //   block [0x828B8DB4..0x828B8DD0)
	// 828B8DB4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B8DB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B8DBC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B8DC0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B8DC4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B8DC8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8DCC: 40810054  ble 0x828b8e20
	if !ctx.cr[0].gt {
	pc = 0x828B8E20; continue 'dispatch;
	}
	pc = 0x828B8DD0; continue 'dispatch;
            }
            0x828B8DD0 => {
    //   block [0x828B8DD0..0x828B8DF0)
	// 828B8DD0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B8DD4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B8DD8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B8DDC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8DE0: 2F070053  cmpwi cr6, r7, 0x53
	ctx.cr[6].compare_i32(ctx.r[7].s32, 83, &mut ctx.xer);
	// 828B8DE4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B8DE8: 41980008  blt cr6, 0x828b8df0
	if ctx.cr[6].lt {
	pc = 0x828B8DF0; continue 'dispatch;
	}
	// 828B8DEC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828B8DF0; continue 'dispatch;
            }
            0x828B8DF0 => {
    //   block [0x828B8DF0..0x828B8E0C)
	// 828B8DF0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B8DF4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B8DF8: 419A0014  beq cr6, 0x828b8e0c
	if ctx.cr[6].eq {
	pc = 0x828B8E0C; continue 'dispatch;
	}
	// 828B8DFC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B8E00: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B8E04: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B8E08: 4800000C  b 0x828b8e14
	pc = 0x828B8E14; continue 'dispatch;
            }
            0x828B8E0C => {
    //   block [0x828B8E0C..0x828B8E14)
	// 828B8E0C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B8E10: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828B8E14; continue 'dispatch;
            }
            0x828B8E14 => {
    //   block [0x828B8E14..0x828B8E20)
	// 828B8E14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B8E18: 4199FFB8  bgt cr6, 0x828b8dd0
	if ctx.cr[6].gt {
	pc = 0x828B8DD0; continue 'dispatch;
	}
	// 828B8E1C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828B8E20; continue 'dispatch;
            }
            0x828B8E20 => {
    //   block [0x828B8E20..0x828B8E3C)
	// 828B8E20: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B8E24: 419A003C  beq cr6, 0x828b8e60
	if ctx.cr[6].eq {
	pc = 0x828B8E60; continue 'dispatch;
	}
	// 828B8E28: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B8E2C: 2F0B0053  cmpwi cr6, r11, 0x53
	ctx.cr[6].compare_i32(ctx.r[11].s32, 83, &mut ctx.xer);
	// 828B8E30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B8E34: 41990008  bgt cr6, 0x828b8e3c
	if ctx.cr[6].gt {
	pc = 0x828B8E3C; continue 'dispatch;
	}
	// 828B8E38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828B8E3C; continue 'dispatch;
            }
            0x828B8E3C => {
    //   block [0x828B8E3C..0x828B8E60)
	// 828B8E3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B8E40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B8E44: 409A001C  bne cr6, 0x828b8e60
	if !ctx.cr[6].eq {
	pc = 0x828B8E60; continue 'dispatch;
	}
	// 828B8E48: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B8E4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B8E50: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B8E54: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B8E58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8E5C: 48000018  b 0x828b8e74
	pc = 0x828B8E74; continue 'dispatch;
            }
            0x828B8E60 => {
    //   block [0x828B8E60..0x828B8E70)
	// 828B8E60: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B8E64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B8E68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8E6C: 48000008  b 0x828b8e74
	pc = 0x828B8E74; continue 'dispatch;
            }
            0x828B8E70 => {
    //   block [0x828B8E70..0x828B8E74)
	// 828B8E70: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828B8E74; continue 'dispatch;
            }
            0x828B8E74 => {
    //   block [0x828B8E74..0x828B8EA0)
	// 828B8E74: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828B8E78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B8E7C: 419A0024  beq cr6, 0x828b8ea0
	if ctx.cr[6].eq {
	pc = 0x828B8EA0; continue 'dispatch;
	}
	// 828B8E80: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B8E84: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B8E88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828B8E8C: 4E800421  bctrl
	ctx.lr = 0x828B8E90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B8E90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B8E94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B8E98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B8E9C: 4E800020  blr
	return;
            }
            0x828B8EA0 => {
    //   block [0x828B8EA0..0x828B8EB4)
	// 828B8EA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B8EA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B8EA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B8EAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B8EB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B8EB8 size=256
    let mut pc: u32 = 0x828B8EB8;
    'dispatch: loop {
        match pc {
            0x828B8EB8 => {
    //   block [0x828B8EB8..0x828B8F00)
	// 828B8EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B8EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B8EC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B8EC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B8EC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B8ECC: 99430014  stb r10, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 828B8ED0: 38C3000C  addi r6, r3, 0xc
	ctx.r[6].s64 = ctx.r[3].s64 + 12;
	// 828B8ED4: 99430015  stb r10, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 828B8ED8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828B8EDC: 99430016  stb r10, 0x16(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(22 as u32), ctx.r[10].u8 ) };
	// 828B8EE0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828B8EE4: 99430017  stb r10, 0x17(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(23 as u32), ctx.r[10].u8 ) };
	// 828B8EE8: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 828B8EEC: 99430018  stb r10, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 828B8EF0: 99430019  stb r10, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 828B8EF4: 9943001A  stb r10, 0x1a(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(26 as u32), ctx.r[10].u8 ) };
	// 828B8EF8: 9943001B  stb r10, 0x1b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(27 as u32), ctx.r[10].u8 ) };
	// 828B8EFC: 394300C9  addi r10, r3, 0xc9
	ctx.r[10].s64 = ctx.r[3].s64 + 201;
	pc = 0x828B8F00; continue 'dispatch;
            }
            0x828B8F00 => {
    //   block [0x828B8F00..0x828B8F1C)
	// 828B8F00: 90E60000  stw r7, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828B8F04: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 828B8F08: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 828B8F0C: 992B0001  stb r9, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[9].u8 ) };
	// 828B8F10: 992B0002  stb r9, 2(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[9].u8 ) };
	// 828B8F14: 992B0003  stb r9, 3(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(3 as u32), ctx.r[9].u8 ) };
	// 828B8F18: 992B0004  stb r9, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	pc = 0x828B8F1C; continue 'dispatch;
            }
            0x828B8F1C => {
    //   block [0x828B8F1C..0x828B8F48)
	// 828B8F1C: 98EAFFC8  stb r7, -0x38(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-56 as u32), ctx.r[7].u8 ) };
	// 828B8F20: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828B8F24: 98EA0000  stb r7, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 828B8F28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B8F2C: 4082FFF0  bne 0x828b8f1c
	if !ctx.cr[0].eq {
	pc = 0x828B8F1C; continue 'dispatch;
	}
	// 828B8F30: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828B8F34: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 828B8F38: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 828B8F3C: 4082FFC4  bne 0x828b8f00
	if !ctx.cr[0].eq {
	pc = 0x828B8F00; continue 'dispatch;
	}
	// 828B8F40: 396300A4  addi r11, r3, 0xa4
	ctx.r[11].s64 = ctx.r[3].s64 + 164;
	// 828B8F44: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	pc = 0x828B8F48; continue 'dispatch;
            }
            0x828B8F48 => {
    //   block [0x828B8F48..0x828B8F64)
	// 828B8F48: 90EBFFC8  stw r7, -0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-56 as u32), ctx.r[7].u32 ) };
	// 828B8F4C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B8F50: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828B8F54: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B8F58: 4082FFF0  bne 0x828b8f48
	if !ctx.cr[0].eq {
	pc = 0x828B8F48; continue 'dispatch;
	}
	// 828B8F5C: 396300C4  addi r11, r3, 0xc4
	ctx.r[11].s64 = ctx.r[3].s64 + 196;
	// 828B8F60: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	pc = 0x828B8F64; continue 'dispatch;
            }
            0x828B8F64 => {
    //   block [0x828B8F64..0x828B8F80)
	// 828B8F64: 98EBFFC8  stb r7, -0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-56 as u32), ctx.r[7].u8 ) };
	// 828B8F68: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B8F6C: 98EB0000  stb r7, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 828B8F70: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B8F74: 4082FFF0  bne 0x828b8f64
	if !ctx.cr[0].eq {
	pc = 0x828B8F64; continue 'dispatch;
	}
	// 828B8F78: 39630044  addi r11, r3, 0x44
	ctx.r[11].s64 = ctx.r[3].s64 + 68;
	// 828B8F7C: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	pc = 0x828B8F80; continue 'dispatch;
            }
            0x828B8F80 => {
    //   block [0x828B8F80..0x828B8F84)
	// 828B8F80: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	pc = 0x828B8F84; continue 'dispatch;
            }
            0x828B8F84 => {
    //   block [0x828B8F84..0x828B8FB8)
	// 828B8F84: 98EBFFD8  stb r7, -0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-40 as u32), ctx.r[7].u8 ) };
	// 828B8F88: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B8F8C: 98EB0000  stb r7, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 828B8F90: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B8F94: 4082FFF0  bne 0x828b8f84
	if !ctx.cr[0].eq {
	pc = 0x828B8F84; continue 'dispatch;
	}
	// 828B8F98: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B8F9C: 4082FFE4  bne 0x828b8f80
	if !ctx.cr[0].eq {
	pc = 0x828B8F80; continue 'dispatch;
	}
	// 828B8FA0: 48000019  bl 0x828b8fb8
	ctx.lr = 0x828B8FA4;
	sub_828B8FB8(ctx, base);
	// 828B8FA4: 480000AD  bl 0x828b9050
	ctx.lr = 0x828B8FA8;
	sub_828B9050(ctx, base);
	// 828B8FA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B8FAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B8FB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B8FB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B8FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B8FB8 size=152
    let mut pc: u32 = 0x828B8FB8;
    'dispatch: loop {
        match pc {
            0x828B8FB8 => {
    //   block [0x828B8FB8..0x828B8FC4)
	// 828B8FB8: 396300C4  addi r11, r3, 0xc4
	ctx.r[11].s64 = ctx.r[3].s64 + 196;
	// 828B8FBC: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 828B8FC0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x828B8FC4; continue 'dispatch;
            }
            0x828B8FC4 => {
    //   block [0x828B8FC4..0x828B8FE4)
	// 828B8FC4: 994BFFC8  stb r10, -0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-56 as u32), ctx.r[10].u8 ) };
	// 828B8FC8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B8FCC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828B8FD0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B8FD4: 4082FFF0  bne 0x828b8fc4
	if !ctx.cr[0].eq {
	pc = 0x828B8FC4; continue 'dispatch;
	}
	// 828B8FD8: 396300A4  addi r11, r3, 0xa4
	ctx.r[11].s64 = ctx.r[3].s64 + 164;
	// 828B8FDC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 828B8FE0: 3900000A  li r8, 0xa
	ctx.r[8].s64 = 10;
	pc = 0x828B8FE4; continue 'dispatch;
            }
            0x828B8FE4 => {
    //   block [0x828B8FE4..0x828B9000)
	// 828B8FE4: 910BFFC8  stw r8, -0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-56 as u32), ctx.r[8].u32 ) };
	// 828B8FE8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B8FEC: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828B8FF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B8FF4: 4082FFF0  bne 0x828b8fe4
	if !ctx.cr[0].eq {
	pc = 0x828B8FE4; continue 'dispatch;
	}
	// 828B8FF8: 39630099  addi r11, r3, 0x99
	ctx.r[11].s64 = ctx.r[3].s64 + 153;
	// 828B8FFC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	pc = 0x828B9000; continue 'dispatch;
            }
            0x828B9000 => {
    //   block [0x828B9000..0x828B9020)
	// 828B9000: 994BFFF8  stb r10, -8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[10].u8 ) };
	// 828B9004: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828B9008: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828B900C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B9010: 4082FFF0  bne 0x828b9000
	if !ctx.cr[0].eq {
	pc = 0x828B9000; continue 'dispatch;
	}
	// 828B9014: 392300D1  addi r9, r3, 0xd1
	ctx.r[9].s64 = ctx.r[3].s64 + 209;
	// 828B9018: 3963001C  addi r11, r3, 0x1c
	ctx.r[11].s64 = ctx.r[3].s64 + 28;
	// 828B901C: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	pc = 0x828B9020; continue 'dispatch;
            }
            0x828B9020 => {
    //   block [0x828B9020..0x828B9050)
	// 828B9020: 9949FFF8  stb r10, -8(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8 as u32), ctx.r[10].u8 ) };
	// 828B9024: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828B9028: 99490000  stb r10, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828B902C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B9030: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828B9034: 994B0001  stb r10, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[10].u8 ) };
	// 828B9038: 994B0002  stb r10, 2(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 828B903C: 994B0003  stb r10, 3(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(3 as u32), ctx.r[10].u8 ) };
	// 828B9040: 994B0004  stb r10, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 828B9044: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 828B9048: 4082FFD8  bne 0x828b9020
	if !ctx.cr[0].eq {
	pc = 0x828B9020; continue 'dispatch;
	}
	// 828B904C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B9050 size=720
    let mut pc: u32 = 0x828B9050;
    'dispatch: loop {
        match pc {
            0x828B9050 => {
    //   block [0x828B9050..0x828B9070)
	// 828B9050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9054: 483F03B1  bl 0x82ca9404
	ctx.lr = 0x828B9058;
	sub_82CA93D0(ctx, base);
	// 828B9058: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B905C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828B9060: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828B9064: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 828B9068: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828B906C: 3943008C  addi r10, r3, 0x8c
	ctx.r[10].s64 = ctx.r[3].s64 + 140;
	pc = 0x828B9070; continue 'dispatch;
            }
            0x828B9070 => {
    //   block [0x828B9070..0x828B909C)
	// 828B9070: 7D2A58AE  lbzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B9074: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B9078: 419A0024  beq cr6, 0x828b909c
	if ctx.cr[6].eq {
	pc = 0x828B909C; continue 'dispatch;
	}
	// 828B907C: 7D2B1A14  add r9, r11, r3
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 828B9080: 890900C4  lbz r8, 0xc4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(196 as u32) ) } as u64;
	// 828B9084: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828B9088: 419A0014  beq cr6, 0x828b909c
	if ctx.cr[6].eq {
	pc = 0x828B909C; continue 'dispatch;
	}
	// 828B908C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828B9090: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B9094: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 828B9098: 4198FFD8  blt cr6, 0x828b9070
	if ctx.cr[6].lt {
	pc = 0x828B9070; continue 'dispatch;
	}
	pc = 0x828B909C; continue 'dispatch;
            }
            0x828B909C => {
    //   block [0x828B909C..0x828B90B0)
	// 828B909C: 38A300C9  addi r5, r3, 0xc9
	ctx.r[5].s64 = ctx.r[3].s64 + 201;
	// 828B90A0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828B90A4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828B90A8: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 828B90AC: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	pc = 0x828B90B0; continue 'dispatch;
            }
            0x828B90B0 => {
    //   block [0x828B90B0..0x828B90B8)
	// 828B90B0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828B90B4: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	pc = 0x828B90B8; continue 'dispatch;
            }
            0x828B90B8 => {
    //   block [0x828B90B8..0x828B90F4)
	// 828B90B8: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 828B90BC: 7F08E800  cmpw cr6, r8, r29
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[29].s32, &mut ctx.xer);
	// 828B90C0: 419900C0  bgt cr6, 0x828b9180
	if ctx.cr[6].gt {
	pc = 0x828B9180; continue 'dispatch;
	}
	// 828B90C4: 54CB063E  clrlwi r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 828B90C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B90CC: 409A00B4  bne cr6, 0x828b9180
	if !ctx.cr[6].eq {
	pc = 0x828B9180; continue 'dispatch;
	}
	// 828B90D0: 7D6740AE  lbzx r11, r7, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828B90D4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 828B90D8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 828B90DC: 419A00A4  beq cr6, 0x828b9180
	if ctx.cr[6].eq {
	pc = 0x828B9180; continue 'dispatch;
	}
	// 828B90E0: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 828B90E4: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 828B90E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B90EC: 409A0008  bne cr6, 0x828b90f4
	if !ctx.cr[6].eq {
	pc = 0x828B90F4; continue 'dispatch;
	}
	// 828B90F0: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	pc = 0x828B90F4; continue 'dispatch;
            }
            0x828B90F4 => {
    //   block [0x828B90F4..0x828B911C)
	// 828B90F4: 552A063E  clrlwi r10, r9, 0x18
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 828B90F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B90FC: 409A0024  bne cr6, 0x828b9120
	if !ctx.cr[6].eq {
	pc = 0x828B9120; continue 'dispatch;
	}
	// 828B9100: 7D445A14  add r10, r4, r11
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 828B9104: 894AFFC8  lbz r10, -0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-56 as u32) ) } as u64;
	// 828B9108: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B910C: 419A0010  beq cr6, 0x828b911c
	if ctx.cr[6].eq {
	pc = 0x828B911C; continue 'dispatch;
	}
	// 828B9110: 7D4458AE  lbzx r10, r4, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B9114: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B9118: 409A0008  bne cr6, 0x828b9120
	if !ctx.cr[6].eq {
	pc = 0x828B9120; continue 'dispatch;
	}
	pc = 0x828B911C; continue 'dispatch;
            }
            0x828B911C => {
    //   block [0x828B911C..0x828B9120)
	// 828B911C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	pc = 0x828B9120; continue 'dispatch;
            }
            0x828B9120 => {
    //   block [0x828B9120..0x828B9154)
	// 828B9120: 552A063E  clrlwi r10, r9, 0x18
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 828B9124: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B9128: 409A0030  bne cr6, 0x828b9158
	if !ctx.cr[6].eq {
	pc = 0x828B9158; continue 'dispatch;
	}
	// 828B912C: 394B001B  addi r10, r11, 0x1b
	ctx.r[10].s64 = ctx.r[11].s64 + 27;
	// 828B9130: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828B9134: 7D4A182E  lwzx r10, r10, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 828B9138: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 828B913C: 41980018  blt cr6, 0x828b9154
	if ctx.cr[6].lt {
	pc = 0x828B9154; continue 'dispatch;
	}
	// 828B9140: 394B0029  addi r10, r11, 0x29
	ctx.r[10].s64 = ctx.r[11].s64 + 41;
	// 828B9144: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828B9148: 7D4A182E  lwzx r10, r10, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 828B914C: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 828B9150: 40980008  bge cr6, 0x828b9158
	if !ctx.cr[6].lt {
	pc = 0x828B9158; continue 'dispatch;
	}
	pc = 0x828B9154; continue 'dispatch;
            }
            0x828B9154 => {
    //   block [0x828B9154..0x828B9158)
	// 828B9154: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	pc = 0x828B9158; continue 'dispatch;
            }
            0x828B9158 => {
    //   block [0x828B9158..0x828B9180)
	// 828B9158: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828B915C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B9160: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 828B9164: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 828B9168: 894B001C  lbz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B916C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B9170: 419A0010  beq cr6, 0x828b9180
	if ctx.cr[6].eq {
	pc = 0x828B9180; continue 'dispatch;
	}
	// 828B9174: 896B0044  lbz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 828B9178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B917C: 409A0008  bne cr6, 0x828b9184
	if !ctx.cr[6].eq {
	pc = 0x828B9184; continue 'dispatch;
	}
	pc = 0x828B9180; continue 'dispatch;
            }
            0x828B9180 => {
    //   block [0x828B9180..0x828B9184)
	// 828B9180: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	pc = 0x828B9184; continue 'dispatch;
            }
            0x828B9184 => {
    //   block [0x828B9184..0x828B9198)
	// 828B9184: 552B063E  clrlwi r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 828B9188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B918C: 419A000C  beq cr6, 0x828b9198
	if ctx.cr[6].eq {
	pc = 0x828B9198; continue 'dispatch;
	}
	// 828B9190: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828B9194: 7FE741AE  stbx r31, r7, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32), ctx.r[31].u8) };
	pc = 0x828B9198; continue 'dispatch;
            }
            0x828B9198 => {
    //   block [0x828B9198..0x828B91C4)
	// 828B9198: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 828B919C: 2F080005  cmpwi cr6, r8, 5
	ctx.cr[6].compare_i32(ctx.r[8].s32, 5, &mut ctx.xer);
	// 828B91A0: 4198FF18  blt cr6, 0x828b90b8
	if ctx.cr[6].lt {
	pc = 0x828B90B8; continue 'dispatch;
	}
	// 828B91A4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828B91A8: 38840008  addi r4, r4, 8
	ctx.r[4].s64 = ctx.r[4].s64 + 8;
	// 828B91AC: 38E70005  addi r7, r7, 5
	ctx.r[7].s64 = ctx.r[7].s64 + 5;
	// 828B91B0: 4082FF00  bne 0x828b90b0
	if !ctx.cr[0].eq {
	pc = 0x828B90B0; continue 'dispatch;
	}
	// 828B91B4: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B91B8: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 828B91BC: 409A0008  bne cr6, 0x828b91c4
	if !ctx.cr[6].eq {
	pc = 0x828B91C4; continue 'dispatch;
	}
	// 828B91C0: 4BFFFDF9  bl 0x828b8fb8
	ctx.lr = 0x828B91C4;
	sub_828B8FB8(ctx, base);
	pc = 0x828B91C4; continue 'dispatch;
            }
            0x828B91C4 => {
    //   block [0x828B91C4..0x828B91D0)
	// 828B91C4: 3BC30044  addi r30, r3, 0x44
	ctx.r[30].s64 = ctx.r[3].s64 + 68;
	// 828B91C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B91CC: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	pc = 0x828B91D0; continue 'dispatch;
            }
            0x828B91D0 => {
    //   block [0x828B91D0..0x828B91D8)
	// 828B91D0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828B91D4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x828B91D8; continue 'dispatch;
            }
            0x828B91D8 => {
    //   block [0x828B91D8..0x828B91F4)
	// 828B91D8: 7D6430AE  lbzx r11, r4, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 828B91DC: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 828B91E0: 409A0088  bne cr6, 0x828b9268
	if !ctx.cr[6].eq {
	pc = 0x828B9268; continue 'dispatch;
	}
	// 828B91E4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828B91E8: 394300A4  addi r10, r3, 0xa4
	ctx.r[10].s64 = ctx.r[3].s64 + 164;
	// 828B91EC: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 828B91F0: 39030014  addi r8, r3, 0x14
	ctx.r[8].s64 = ctx.r[3].s64 + 20;
	pc = 0x828B91F4; continue 'dispatch;
            }
            0x828B91F4 => {
    //   block [0x828B91F4..0x828B924C)
	// 828B91F4: 7FA858AE  lbzx r29, r8, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B91F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B91FC: 419A0050  beq cr6, 0x828b924c
	if ctx.cr[6].eq {
	pc = 0x828B924C; continue 'dispatch;
	}
	// 828B9200: 8BA9FFD8  lbz r29, -0x28(r9)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-40 as u32) ) } as u64;
	// 828B9204: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B9208: 419A0044  beq cr6, 0x828b924c
	if ctx.cr[6].eq {
	pc = 0x828B924C; continue 'dispatch;
	}
	// 828B920C: 8BA90000  lbz r29, 0(r9)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9210: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B9214: 419A0038  beq cr6, 0x828b924c
	if ctx.cr[6].eq {
	pc = 0x828B924C; continue 'dispatch;
	}
	// 828B9218: 7FA55A14  add r29, r5, r11
	ctx.r[29].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 828B921C: 8BBDFFC8  lbz r29, -0x38(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(-56 as u32) ) } as u64;
	// 828B9220: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B9224: 419A0028  beq cr6, 0x828b924c
	if ctx.cr[6].eq {
	pc = 0x828B924C; continue 'dispatch;
	}
	// 828B9228: 7FA558AE  lbzx r29, r5, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828B922C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828B9230: 419A001C  beq cr6, 0x828b924c
	if ctx.cr[6].eq {
	pc = 0x828B924C; continue 'dispatch;
	}
	// 828B9234: 83AAFFC8  lwz r29, -0x38(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-56 as u32) ) } as u64;
	// 828B9238: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 828B923C: 41980010  blt cr6, 0x828b924c
	if ctx.cr[6].lt {
	pc = 0x828B924C; continue 'dispatch;
	}
	// 828B9240: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9244: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 828B9248: 4098001C  bge cr6, 0x828b9264
	if !ctx.cr[6].lt {
	pc = 0x828B9264; continue 'dispatch;
	}
	pc = 0x828B924C; continue 'dispatch;
            }
            0x828B924C => {
    //   block [0x828B924C..0x828B9264)
	// 828B924C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B9250: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828B9254: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 828B9258: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 828B925C: 4198FF98  blt cr6, 0x828b91f4
	if ctx.cr[6].lt {
	pc = 0x828B91F4; continue 'dispatch;
	}
	// 828B9260: 48000008  b 0x828b9268
	pc = 0x828B9268; continue 'dispatch;
            }
            0x828B9264 => {
    //   block [0x828B9264..0x828B9268)
	// 828B9264: 7D6431AE  stbx r11, r4, r6
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u8) };
	pc = 0x828B9268; continue 'dispatch;
            }
            0x828B9268 => {
    //   block [0x828B9268..0x828B9294)
	// 828B9268: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 828B926C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 828B9270: 2F060005  cmpwi cr6, r6, 5
	ctx.cr[6].compare_i32(ctx.r[6].s32, 5, &mut ctx.xer);
	// 828B9274: 4198FF64  blt cr6, 0x828b91d8
	if ctx.cr[6].lt {
	pc = 0x828B91D8; continue 'dispatch;
	}
	// 828B9278: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828B927C: 38840005  addi r4, r4, 5
	ctx.r[4].s64 = ctx.r[4].s64 + 5;
	// 828B9280: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 828B9284: 4082FF4C  bne 0x828b91d0
	if !ctx.cr[0].eq {
	pc = 0x828B91D0; continue 'dispatch;
	}
	// 828B9288: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 828B928C: 39430002  addi r10, r3, 2
	ctx.r[10].s64 = ctx.r[3].s64 + 2;
	// 828B9290: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	pc = 0x828B9294; continue 'dispatch;
            }
            0x828B9294 => {
    //   block [0x828B9294..0x828B92A8)
	// 828B9294: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828B9298: 892AFFFE  lbz r9, -2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-2 as u32) ) } as u64;
	// 828B929C: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 828B92A0: 419A0008  beq cr6, 0x828b92a8
	if ctx.cr[6].eq {
	pc = 0x828B92A8; continue 'dispatch;
	}
	// 828B92A4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x828B92A8; continue 'dispatch;
            }
            0x828B92A8 => {
    //   block [0x828B92A8..0x828B92C0)
	// 828B92A8: 892AFFFF  lbz r9, -1(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-1 as u32) ) } as u64;
	// 828B92AC: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 828B92B0: 419A0010  beq cr6, 0x828b92c0
	if ctx.cr[6].eq {
	pc = 0x828B92C0; continue 'dispatch;
	}
	// 828B92B4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B92B8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B92BC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x828B92C0; continue 'dispatch;
            }
            0x828B92C0 => {
    //   block [0x828B92C0..0x828B92D8)
	// 828B92C0: 892A0000  lbz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B92C4: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 828B92C8: 419A0010  beq cr6, 0x828b92d8
	if ctx.cr[6].eq {
	pc = 0x828B92D8; continue 'dispatch;
	}
	// 828B92CC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B92D0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B92D4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x828B92D8; continue 'dispatch;
            }
            0x828B92D8 => {
    //   block [0x828B92D8..0x828B92F0)
	// 828B92D8: 892A0001  lbz r9, 1(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 828B92DC: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 828B92E0: 419A0010  beq cr6, 0x828b92f0
	if ctx.cr[6].eq {
	pc = 0x828B92F0; continue 'dispatch;
	}
	// 828B92E4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B92E8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B92EC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x828B92F0; continue 'dispatch;
            }
            0x828B92F0 => {
    //   block [0x828B92F0..0x828B9308)
	// 828B92F0: 892A0002  lbz r9, 2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 828B92F4: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 828B92F8: 419A0010  beq cr6, 0x828b9308
	if ctx.cr[6].eq {
	pc = 0x828B9308; continue 'dispatch;
	}
	// 828B92FC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9300: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B9304: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x828B9308; continue 'dispatch;
            }
            0x828B9308 => {
    //   block [0x828B9308..0x828B9320)
	// 828B9308: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828B930C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B9310: 394A0005  addi r10, r10, 5
	ctx.r[10].s64 = ctx.r[10].s64 + 5;
	// 828B9314: 4082FF80  bne 0x828b9294
	if !ctx.cr[0].eq {
	pc = 0x828B9294; continue 'dispatch;
	}
	// 828B9318: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B931C: 483F0138  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B9320 size=1920
    let mut pc: u32 = 0x828B9320;
    'dispatch: loop {
        match pc {
            0x828B9320 => {
    //   block [0x828B9320..0x828B9370)
	// 828B9320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9324: 483F00B9  bl 0x82ca93dc
	ctx.lr = 0x828B9328;
	sub_82CA93D0(ctx, base);
	// 828B9328: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B932C: 3FA0834C  lis r29, -0x7cb4
	ctx.r[29].s64 = -2092171264;
	// 828B9330: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 828B9334: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828B9338: 3AAB3780  addi r21, r11, 0x3780
	ctx.r[21].s64 = ctx.r[11].s64 + 14208;
	// 828B933C: 3BEA7088  addi r31, r10, 0x7088
	ctx.r[31].s64 = ctx.r[10].s64 + 28808;
	// 828B9340: 817D3820  lwz r11, 0x3820(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14368 as u32) ) } as u64;
	// 828B9344: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 828B9348: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 828B934C: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828B9350: 7CD13378  mr r17, r6
	ctx.r[17].u64 = ctx.r[6].u64;
	// 828B9354: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828B9358: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B935C: 409A0054  bne cr6, 0x828b93b0
	if !ctx.cr[6].eq {
	pc = 0x828B93B0; continue 'dispatch;
	}
	// 828B9360: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828B9364: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 828B9368: 917D3820  stw r11, 0x3820(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(14368 as u32), ctx.r[11].u32 ) };
	// 828B936C: 39600027  li r11, 0x27
	ctx.r[11].s64 = 39;
	pc = 0x828B9370; continue 'dispatch;
            }
            0x828B9370 => {
    //   block [0x828B9370..0x828B9378)
	// 828B9370: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828B9374: 93CA0000  stw r30, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x828B9378; continue 'dispatch;
            }
            0x828B9378 => {
    //   block [0x828B9378..0x828B93B0)
	// 828B9378: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828B937C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9380: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828B9384: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B9388: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B938C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9390: 4082FFE8  bne 0x828b9378
	if !ctx.cr[0].eq {
	pc = 0x828B9378; continue 'dispatch;
	}
	// 828B9394: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B9398: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828B939C: 4080FFD4  bge 0x828b9370
	if !ctx.cr[0].lt {
	pc = 0x828B9370; continue 'dispatch;
	}
	// 828B93A0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828B93A4: 386BEBE8  addi r3, r11, -0x1418
	ctx.r[3].s64 = ctx.r[11].s64 + -5144;
	// 828B93A8: 483F0B79  bl 0x82ca9f20
	ctx.lr = 0x828B93AC;
	sub_82CA9F20(ctx, base);
	// 828B93AC: 817D3820  lwz r11, 0x3820(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14368 as u32) ) } as u64;
	pc = 0x828B93B0; continue 'dispatch;
            }
            0x828B93B0 => {
    //   block [0x828B93B0..0x828B93D4)
	// 828B93B0: 556907BC  rlwinm r9, r11, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B93B4: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 828B93B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B93BC: 3ACA36E0  addi r22, r10, 0x36e0
	ctx.r[22].s64 = ctx.r[10].s64 + 14048;
	// 828B93C0: 409A0054  bne cr6, 0x828b9414
	if !ctx.cr[6].eq {
	pc = 0x828B9414; continue 'dispatch;
	}
	// 828B93C4: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 828B93C8: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 828B93CC: 917D3820  stw r11, 0x3820(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(14368 as u32), ctx.r[11].u32 ) };
	// 828B93D0: 39600027  li r11, 0x27
	ctx.r[11].s64 = 39;
	pc = 0x828B93D4; continue 'dispatch;
            }
            0x828B93D4 => {
    //   block [0x828B93D4..0x828B93DC)
	// 828B93D4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828B93D8: 93CA0000  stw r30, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x828B93DC; continue 'dispatch;
            }
            0x828B93DC => {
    //   block [0x828B93DC..0x828B9414)
	// 828B93DC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828B93E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B93E4: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828B93E8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B93EC: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B93F0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B93F4: 4082FFE8  bne 0x828b93dc
	if !ctx.cr[0].eq {
	pc = 0x828B93DC; continue 'dispatch;
	}
	// 828B93F8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B93FC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828B9400: 4080FFD4  bge 0x828b93d4
	if !ctx.cr[0].lt {
	pc = 0x828B93D4; continue 'dispatch;
	}
	// 828B9404: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828B9408: 386BEB80  addi r3, r11, -0x1480
	ctx.r[3].s64 = ctx.r[11].s64 + -5248;
	// 828B940C: 483F0B15  bl 0x82ca9f20
	ctx.lr = 0x828B9410;
	sub_82CA9F20(ctx, base);
	// 828B9410: 817D3820  lwz r11, 0x3820(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14368 as u32) ) } as u64;
	pc = 0x828B9414; continue 'dispatch;
            }
            0x828B9414 => {
    //   block [0x828B9414..0x828B9438)
	// 828B9414: 5569077A  rlwinm r9, r11, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B9418: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 828B941C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B9420: 3A8A36B4  addi r20, r10, 0x36b4
	ctx.r[20].s64 = ctx.r[10].s64 + 14004;
	// 828B9424: 409A0050  bne cr6, 0x828b9474
	if !ctx.cr[6].eq {
	pc = 0x828B9474; continue 'dispatch;
	}
	// 828B9428: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 828B942C: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 828B9430: 917D3820  stw r11, 0x3820(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(14368 as u32), ctx.r[11].u32 ) };
	// 828B9434: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	pc = 0x828B9438; continue 'dispatch;
            }
            0x828B9438 => {
    //   block [0x828B9438..0x828B9440)
	// 828B9438: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828B943C: 93CA0000  stw r30, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x828B9440; continue 'dispatch;
            }
            0x828B9440 => {
    //   block [0x828B9440..0x828B9474)
	// 828B9440: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828B9444: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9448: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828B944C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828B9450: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9454: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9458: 4082FFE8  bne 0x828b9440
	if !ctx.cr[0].eq {
	pc = 0x828B9440; continue 'dispatch;
	}
	// 828B945C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B9460: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828B9464: 4080FFD4  bge 0x828b9438
	if !ctx.cr[0].lt {
	pc = 0x828B9438; continue 'dispatch;
	}
	// 828B9468: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828B946C: 386BEB18  addi r3, r11, -0x14e8
	ctx.r[3].s64 = ctx.r[11].s64 + -5352;
	// 828B9470: 483F0AB1  bl 0x82ca9f20
	ctx.lr = 0x828B9474;
	sub_82CA9F20(ctx, base);
	pc = 0x828B9474; continue 'dispatch;
            }
            0x828B9474 => {
    //   block [0x828B9474..0x828B94B4)
	// 828B9474: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 828B9478: 896AEBC8  lbz r11, -0x1438(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-5176 as u32) ) } as u64;
	// 828B947C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9480: 409A0554  bne cr6, 0x828b99d4
	if !ctx.cr[6].eq {
	pc = 0x828B99D4; continue 'dispatch;
	}
	// 828B9484: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9488: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828B948C: 996AEBC8  stb r11, -0x1438(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-5176 as u32), ctx.r[11].u8 ) };
	// 828B9490: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828B9494: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828B9498: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B949C: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 828B94A0: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 828B94A4: 3B880B34  addi r28, r8, 0xb34
	ctx.r[28].s64 = ctx.r[8].s64 + 2868;
	// 828B94A8: 3B092D5C  addi r24, r9, 0x2d5c
	ctx.r[24].s64 = ctx.r[9].s64 + 11612;
	// 828B94AC: 3AEA2D40  addi r23, r10, 0x2d40
	ctx.r[23].s64 = ctx.r[10].s64 + 11584;
	// 828B94B0: 3B4B0B70  addi r26, r11, 0xb70
	ctx.r[26].s64 = ctx.r[11].s64 + 2928;
	pc = 0x828B94B4; continue 'dispatch;
            }
            0x828B94B4 => {
    //   block [0x828B94B4..0x828B94B8)
	// 828B94B4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x828B94B8; continue 'dispatch;
            }
            0x828B94B8 => {
    //   block [0x828B94B8..0x828B94C0)
	// 828B94B8: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828B94BC: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	pc = 0x828B94C0; continue 'dispatch;
            }
            0x828B94C0 => {
    //   block [0x828B94C0..0x828B94F4)
	// 828B94C0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B94C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B94C8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B94CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B94D0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B94D4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B94D8: 4082FFE8  bne 0x828b94c0
	if !ctx.cr[0].eq {
	pc = 0x828B94C0; continue 'dispatch;
	}
	// 828B94DC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B94E0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B94E4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828B94E8: 4B92A969  bl 0x821e3e50
	ctx.lr = 0x828B94EC;
	sub_821E3E50(ctx, base);
	// 828B94EC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828B94F0: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	pc = 0x828B94F4; continue 'dispatch;
            }
            0x828B94F4 => {
    //   block [0x828B94F4..0x828B957C)
	// 828B94F4: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828B94F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B94FC: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828B9500: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 828B9504: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9508: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B950C: 4082FFE8  bne 0x828b94f4
	if !ctx.cr[0].eq {
	pc = 0x828B94F4; continue 'dispatch;
	}
	// 828B9510: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B9514: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828B9518: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B951C: 4B92A935  bl 0x821e3e50
	ctx.lr = 0x828B9520;
	sub_821E3E50(ctx, base);
	// 828B9520: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828B9524: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B9528: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828B952C: 4B9739A5  bl 0x8222ced0
	ctx.lr = 0x828B9530;
	sub_8222CED0(ctx, base);
	// 828B9530: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828B9534: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828B9538: 4B9332C1  bl 0x821ec7f8
	ctx.lr = 0x828B953C;
	sub_821EC7F8(ctx, base);
	// 828B953C: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 828B9540: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B9544: 4B936CFD  bl 0x821f0240
	ctx.lr = 0x828B9548;
	sub_821F0240(ctx, base);
	// 828B9548: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B954C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B9550: 4B921471  bl 0x821da9c0
	ctx.lr = 0x828B9554;
	sub_821DA9C0(ctx, base);
	// 828B9554: 38A10084  addi r5, r1, 0x84
	ctx.r[5].s64 = ctx.r[1].s64 + 132;
	// 828B9558: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828B955C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828B9560: 4B929BA9  bl 0x821e3108
	ctx.lr = 0x828B9564;
	sub_821E3108(ctx, base);
	// 828B9564: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B9568: 7C7BAA14  add r3, r27, r21
	ctx.r[3].u64 = ctx.r[27].u64 + ctx.r[21].u64;
	// 828B956C: 4B9ABC35  bl 0x822651a0
	ctx.lr = 0x828B9570;
	sub_822651A0(ctx, base);
	// 828B9570: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828B9574: 4B90D1F5  bl 0x821c6768
	ctx.lr = 0x828B9578;
	sub_821C6768(ctx, base);
	// 828B9578: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828B957C; continue 'dispatch;
            }
            0x828B957C => {
    //   block [0x828B957C..0x828B95A8)
	// 828B957C: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 828B9580: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9584: 7CA05828  lwarx r5, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 828B9588: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 828B958C: 7CA0592D  stwcx. r5, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9590: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9594: 4082FFE8  bne 0x828b957c
	if !ctx.cr[0].eq {
	pc = 0x828B957C; continue 'dispatch;
	}
	// 828B9598: 93C10088  stw r30, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 828B959C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B95A0: 4B90D1C9  bl 0x821c6768
	ctx.lr = 0x828B95A4;
	sub_821C6768(ctx, base);
	// 828B95A4: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	pc = 0x828B95A8; continue 'dispatch;
            }
            0x828B95A8 => {
    //   block [0x828B95A8..0x828B95D4)
	// 828B95A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B95AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B95B0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B95B4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828B95B8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B95BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B95C0: 4082FFE8  bne 0x828b95a8
	if !ctx.cr[0].eq {
	pc = 0x828B95A8; continue 'dispatch;
	}
	// 828B95C4: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828B95C8: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828B95CC: 4B90D19D  bl 0x821c6768
	ctx.lr = 0x828B95D0;
	sub_821C6768(ctx, base);
	// 828B95D0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	pc = 0x828B95D4; continue 'dispatch;
            }
            0x828B95D4 => {
    //   block [0x828B95D4..0x828B9600)
	// 828B95D4: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 828B95D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B95DC: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 828B95E0: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 828B95E4: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B95E8: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B95EC: 4082FFE8  bne 0x828b95d4
	if !ctx.cr[0].eq {
	pc = 0x828B95D4; continue 'dispatch;
	}
	// 828B95F0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B95F4: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 828B95F8: 4B90D171  bl 0x821c6768
	ctx.lr = 0x828B95FC;
	sub_821C6768(ctx, base);
	// 828B95FC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828B9600; continue 'dispatch;
            }
            0x828B9600 => {
    //   block [0x828B9600..0x828B9628)
	// 828B9600: 7C6000A6  mfmsr r3
	ctx.r[3].u64 = ctx.msr;
	// 828B9604: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9608: 7C805828  lwarx r4, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[4].u64 = ctx.reserved.u32 as u64;
	// 828B960C: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 828B9610: 7C80592D  stwcx. r4, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[4].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9614: 7C610164  mtmsrd r3, 1
	ctx.msr = (ctx.r[3].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9618: 4082FFE8  bne 0x828b9600
	if !ctx.cr[0].eq {
	pc = 0x828B9600; continue 'dispatch;
	}
	// 828B961C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828B9620: 4B90D149  bl 0x821c6768
	ctx.lr = 0x828B9624;
	sub_821C6768(ctx, base);
	// 828B9624: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	pc = 0x828B9628; continue 'dispatch;
            }
            0x828B9628 => {
    //   block [0x828B9628..0x828B964C)
	// 828B9628: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B962C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9630: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B9634: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828B9638: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B963C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9640: 4082FFE8  bne 0x828b9628
	if !ctx.cr[0].eq {
	pc = 0x828B9628; continue 'dispatch;
	}
	// 828B9644: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B9648: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	pc = 0x828B964C; continue 'dispatch;
            }
            0x828B964C => {
    //   block [0x828B964C..0x828B9680)
	// 828B964C: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 828B9650: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9654: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 828B9658: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 828B965C: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9660: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9664: 4082FFE8  bne 0x828b964c
	if !ctx.cr[0].eq {
	pc = 0x828B964C; continue 'dispatch;
	}
	// 828B9668: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B966C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B9670: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B9674: 4B92A7DD  bl 0x821e3e50
	ctx.lr = 0x828B9678;
	sub_821E3E50(ctx, base);
	// 828B9678: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828B967C: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	pc = 0x828B9680; continue 'dispatch;
            }
            0x828B9680 => {
    //   block [0x828B9680..0x828B9708)
	// 828B9680: 7C6000A6  mfmsr r3
	ctx.r[3].u64 = ctx.msr;
	// 828B9684: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9688: 7C805828  lwarx r4, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[4].u64 = ctx.reserved.u32 as u64;
	// 828B968C: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 828B9690: 7C80592D  stwcx. r4, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[4].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9694: 7C610164  mtmsrd r3, 1
	ctx.msr = (ctx.r[3].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9698: 4082FFE8  bne 0x828b9680
	if !ctx.cr[0].eq {
	pc = 0x828B9680; continue 'dispatch;
	}
	// 828B969C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B96A0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828B96A4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828B96A8: 4B92A7A9  bl 0x821e3e50
	ctx.lr = 0x828B96AC;
	sub_821E3E50(ctx, base);
	// 828B96AC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828B96B0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B96B4: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828B96B8: 4B973819  bl 0x8222ced0
	ctx.lr = 0x828B96BC;
	sub_8222CED0(ctx, base);
	// 828B96BC: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 828B96C0: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828B96C4: 4B933135  bl 0x821ec7f8
	ctx.lr = 0x828B96C8;
	sub_821EC7F8(ctx, base);
	// 828B96C8: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 828B96CC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828B96D0: 4B936B71  bl 0x821f0240
	ctx.lr = 0x828B96D4;
	sub_821F0240(ctx, base);
	// 828B96D4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B96D8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828B96DC: 4B9212E5  bl 0x821da9c0
	ctx.lr = 0x828B96E0;
	sub_821DA9C0(ctx, base);
	// 828B96E0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828B96E4: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 828B96E8: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 828B96EC: 4B929A1D  bl 0x821e3108
	ctx.lr = 0x828B96F0;
	sub_821E3108(ctx, base);
	// 828B96F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B96F4: 7C7BB214  add r3, r27, r22
	ctx.r[3].u64 = ctx.r[27].u64 + ctx.r[22].u64;
	// 828B96F8: 4B9ABAA9  bl 0x822651a0
	ctx.lr = 0x828B96FC;
	sub_822651A0(ctx, base);
	// 828B96FC: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 828B9700: 4B90D069  bl 0x821c6768
	ctx.lr = 0x828B9704;
	sub_821C6768(ctx, base);
	// 828B9704: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	pc = 0x828B9708; continue 'dispatch;
            }
            0x828B9708 => {
    //   block [0x828B9708..0x828B9734)
	// 828B9708: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B970C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9710: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B9714: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828B9718: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B971C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9720: 4082FFE8  bne 0x828b9708
	if !ctx.cr[0].eq {
	pc = 0x828B9708; continue 'dispatch;
	}
	// 828B9724: 93C1008C  stw r30, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 828B9728: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828B972C: 4B90D03D  bl 0x821c6768
	ctx.lr = 0x828B9730;
	sub_821C6768(ctx, base);
	// 828B9730: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x828B9734; continue 'dispatch;
            }
            0x828B9734 => {
    //   block [0x828B9734..0x828B9760)
	// 828B9734: 7CA000A6  mfmsr r5
	ctx.r[5].u64 = ctx.msr;
	// 828B9738: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B973C: 7CC03828  lwarx r6, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[6].u64 = ctx.reserved.u32 as u64;
	// 828B9740: 38C6FFFF  addi r6, r6, -1
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	// 828B9744: 7CC0392D  stwcx. r6, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[6].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9748: 7CA10164  mtmsrd r5, 1
	ctx.msr = (ctx.r[5].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B974C: 4082FFE8  bne 0x828b9734
	if !ctx.cr[0].eq {
	pc = 0x828B9734; continue 'dispatch;
	}
	// 828B9750: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828B9754: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 828B9758: 4B90D011  bl 0x821c6768
	ctx.lr = 0x828B975C;
	sub_821C6768(ctx, base);
	// 828B975C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828B9760; continue 'dispatch;
            }
            0x828B9760 => {
    //   block [0x828B9760..0x828B978C)
	// 828B9760: 7C6000A6  mfmsr r3
	ctx.r[3].u64 = ctx.msr;
	// 828B9764: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9768: 7C805828  lwarx r4, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[4].u64 = ctx.reserved.u32 as u64;
	// 828B976C: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 828B9770: 7C80592D  stwcx. r4, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[4].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9774: 7C610164  mtmsrd r3, 1
	ctx.msr = (ctx.r[3].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9778: 4082FFE8  bne 0x828b9760
	if !ctx.cr[0].eq {
	pc = 0x828B9760; continue 'dispatch;
	}
	// 828B977C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828B9780: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 828B9784: 4B90CFE5  bl 0x821c6768
	ctx.lr = 0x828B9788;
	sub_821C6768(ctx, base);
	// 828B9788: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	pc = 0x828B978C; continue 'dispatch;
            }
            0x828B978C => {
    //   block [0x828B978C..0x828B97B4)
	// 828B978C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B9790: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9794: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B9798: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828B979C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B97A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B97A4: 4082FFE8  bne 0x828b978c
	if !ctx.cr[0].eq {
	pc = 0x828B978C; continue 'dispatch;
	}
	// 828B97A8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B97AC: 4B90CFBD  bl 0x821c6768
	ctx.lr = 0x828B97B0;
	sub_821C6768(ctx, base);
	// 828B97B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	pc = 0x828B97B4; continue 'dispatch;
            }
            0x828B97B4 => {
    //   block [0x828B97B4..0x828B97FC)
	// 828B97B4: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 828B97B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B97BC: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 828B97C0: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 828B97C4: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B97C8: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B97CC: 4082FFE8  bne 0x828b97b4
	if !ctx.cr[0].eq {
	pc = 0x828B97B4; continue 'dispatch;
	}
	// 828B97D0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828B97D4: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 828B97D8: 2F1D0005  cmpwi cr6, r29, 5
	ctx.cr[6].compare_i32(ctx.r[29].s32, 5, &mut ctx.xer);
	// 828B97DC: 4198FCDC  blt cr6, 0x828b94b8
	if ctx.cr[6].lt {
	pc = 0x828B94B8; continue 'dispatch;
	}
	// 828B97E0: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 828B97E4: 2F1B00A0  cmpwi cr6, r27, 0xa0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 160, &mut ctx.xer);
	// 828B97E8: 4198FCCC  blt cr6, 0x828b94b4
	if ctx.cr[6].lt {
	pc = 0x828B94B4; continue 'dispatch;
	}
	// 828B97EC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828B97F0: 7E9BA378  mr r27, r20
	ctx.r[27].u64 = ctx.r[20].u64;
	// 828B97F4: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 828B97F8: 3B0B2D7C  addi r24, r11, 0x2d7c
	ctx.r[24].s64 = ctx.r[11].s64 + 11644;
	pc = 0x828B97FC; continue 'dispatch;
            }
            0x828B97FC => {
    //   block [0x828B97FC..0x828B9800)
	// 828B97FC: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x828B9800; continue 'dispatch;
            }
            0x828B9800 => {
    //   block [0x828B9800..0x828B9808)
	// 828B9800: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828B9804: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	pc = 0x828B9808; continue 'dispatch;
            }
            0x828B9808 => {
    //   block [0x828B9808..0x828B983C)
	// 828B9808: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B980C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9810: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B9814: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828B9818: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B981C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9820: 4082FFE8  bne 0x828b9808
	if !ctx.cr[0].eq {
	pc = 0x828B9808; continue 'dispatch;
	}
	// 828B9824: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B9828: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B982C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B9830: 4B92A621  bl 0x821e3e50
	ctx.lr = 0x828B9834;
	sub_821E3E50(ctx, base);
	// 828B9834: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828B9838: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	pc = 0x828B983C; continue 'dispatch;
            }
            0x828B983C => {
    //   block [0x828B983C..0x828B98A4)
	// 828B983C: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828B9840: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9844: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828B9848: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 828B984C: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9850: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9854: 4082FFE8  bne 0x828b983c
	if !ctx.cr[0].eq {
	pc = 0x828B983C; continue 'dispatch;
	}
	// 828B9858: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B985C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828B9860: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828B9864: 4B92A5ED  bl 0x821e3e50
	ctx.lr = 0x828B9868;
	sub_821E3E50(ctx, base);
	// 828B9868: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828B986C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B9870: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828B9874: 4B97365D  bl 0x8222ced0
	ctx.lr = 0x828B9878;
	sub_8222CED0(ctx, base);
	// 828B9878: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 828B987C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828B9880: 4B932F79  bl 0x821ec7f8
	ctx.lr = 0x828B9884;
	sub_821EC7F8(ctx, base);
	// 828B9884: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 828B9888: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828B988C: 4B9369B5  bl 0x821f0240
	ctx.lr = 0x828B9890;
	sub_821F0240(ctx, base);
	// 828B9890: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B9894: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828B9898: 4B921129  bl 0x821da9c0
	ctx.lr = 0x828B989C;
	sub_821DA9C0(ctx, base);
	// 828B989C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B98A0: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	pc = 0x828B98A4; continue 'dispatch;
            }
            0x828B98A4 => {
    //   block [0x828B98A4..0x828B98F0)
	// 828B98A4: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 828B98A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B98AC: 7CA01828  lwarx r5, 0, r3
	// lwarx
	let ea = ctx.r[3].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 828B98B0: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 828B98B4: 7CA0192D  stwcx. r5, 0, r3
	// stwcx.
	let addr = ctx.r[3].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B98B8: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B98BC: 4082FFE8  bne 0x828b98a4
	if !ctx.cr[0].eq {
	pc = 0x828B98A4; continue 'dispatch;
	}
	// 828B98C0: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 828B98C4: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828B98C8: 4B9AB8D9  bl 0x822651a0
	ctx.lr = 0x828B98CC;
	sub_822651A0(ctx, base);
	// 828B98CC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828B98D0: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828B98D4: 4B932F25  bl 0x821ec7f8
	ctx.lr = 0x828B98D8;
	sub_821EC7F8(ctx, base);
	// 828B98D8: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 828B98DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828B98E0: 4B9AB8C1  bl 0x822651a0
	ctx.lr = 0x828B98E4;
	sub_822651A0(ctx, base);
	// 828B98E4: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828B98E8: 4B90CE81  bl 0x821c6768
	ctx.lr = 0x828B98EC;
	sub_821C6768(ctx, base);
	// 828B98EC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	pc = 0x828B98F0; continue 'dispatch;
            }
            0x828B98F0 => {
    //   block [0x828B98F0..0x828B9918)
	// 828B98F0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B98F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B98F8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B98FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B9900: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9904: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9908: 4082FFE8  bne 0x828b98f0
	if !ctx.cr[0].eq {
	pc = 0x828B98F0; continue 'dispatch;
	}
	// 828B990C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828B9910: 4B90CE59  bl 0x821c6768
	ctx.lr = 0x828B9914;
	sub_821C6768(ctx, base);
	// 828B9914: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	pc = 0x828B9918; continue 'dispatch;
            }
            0x828B9918 => {
    //   block [0x828B9918..0x828B9944)
	// 828B9918: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828B991C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9920: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828B9924: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 828B9928: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B992C: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9930: 4082FFE8  bne 0x828b9918
	if !ctx.cr[0].eq {
	pc = 0x828B9918; continue 'dispatch;
	}
	// 828B9934: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828B9938: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 828B993C: 4B90CE2D  bl 0x821c6768
	ctx.lr = 0x828B9940;
	sub_821C6768(ctx, base);
	// 828B9940: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	pc = 0x828B9944; continue 'dispatch;
            }
            0x828B9944 => {
    //   block [0x828B9944..0x828B9970)
	// 828B9944: 7C6000A6  mfmsr r3
	ctx.r[3].u64 = ctx.msr;
	// 828B9948: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B994C: 7C802828  lwarx r4, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[4].u64 = ctx.reserved.u32 as u64;
	// 828B9950: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 828B9954: 7C80292D  stwcx. r4, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[4].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9958: 7C610164  mtmsrd r3, 1
	ctx.msr = (ctx.r[3].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B995C: 4082FFE8  bne 0x828b9944
	if !ctx.cr[0].eq {
	pc = 0x828B9944; continue 'dispatch;
	}
	// 828B9960: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828B9964: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 828B9968: 4B90CE01  bl 0x821c6768
	ctx.lr = 0x828B996C;
	sub_821C6768(ctx, base);
	// 828B996C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	pc = 0x828B9970; continue 'dispatch;
            }
            0x828B9970 => {
    //   block [0x828B9970..0x828B9998)
	// 828B9970: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828B9974: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9978: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828B997C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B9980: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B9984: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B9988: 4082FFE8  bne 0x828b9970
	if !ctx.cr[0].eq {
	pc = 0x828B9970; continue 'dispatch;
	}
	// 828B998C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B9990: 4B90CDD9  bl 0x821c6768
	ctx.lr = 0x828B9994;
	sub_821C6768(ctx, base);
	// 828B9994: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	pc = 0x828B9998; continue 'dispatch;
            }
            0x828B9998 => {
    //   block [0x828B9998..0x828B99D4)
	// 828B9998: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 828B999C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B99A0: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 828B99A4: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 828B99A8: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B99AC: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B99B0: 4082FFE8  bne 0x828b9998
	if !ctx.cr[0].eq {
	pc = 0x828B9998; continue 'dispatch;
	}
	// 828B99B4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828B99B8: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 828B99BC: 2F1D0005  cmpwi cr6, r29, 5
	ctx.cr[6].compare_i32(ctx.r[29].s32, 5, &mut ctx.xer);
	// 828B99C0: 4198FE40  blt cr6, 0x828b9800
	if ctx.cr[6].lt {
	pc = 0x828B9800; continue 'dispatch;
	}
	// 828B99C4: 39740028  addi r11, r20, 0x28
	ctx.r[11].s64 = ctx.r[20].s64 + 40;
	// 828B99C8: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 828B99CC: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B99D0: 4198FE2C  blt cr6, 0x828b97fc
	if ctx.cr[6].lt {
	pc = 0x828B97FC; continue 'dispatch;
	}
	pc = 0x828B99D4; continue 'dispatch;
            }
            0x828B99D4 => {
    //   block [0x828B99D4..0x828B99E4)
	// 828B99D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B99D8: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 828B99DC: 7E5B9378  mr r27, r18
	ctx.r[27].u64 = ctx.r[18].u64;
	// 828B99E0: 3B4BFFDF  addi r26, r11, -0x21
	ctx.r[26].s64 = ctx.r[11].s64 + -33;
	pc = 0x828B99E4; continue 'dispatch;
            }
            0x828B99E4 => {
    //   block [0x828B99E4..0x828B99E8)
	// 828B99E4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x828B99E8; continue 'dispatch;
            }
            0x828B99E8 => {
    //   block [0x828B99E8..0x828B9A0C)
	// 828B99E8: 7D5BF8AE  lbzx r10, r27, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828B99EC: 7F9BFA14  add r28, r27, r31
	ctx.r[28].u64 = ctx.r[27].u64 + ctx.r[31].u64;
	// 828B99F0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B99F4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828B99F8: 7D490774  extsb r9, r10
	ctx.r[9].s64 = ctx.r[10].s8 as i64;
	// 828B99FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9A00: 91210090  stw r9, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 828B9A04: 419A0008  beq cr6, 0x828b9a0c
	if ctx.cr[6].eq {
	pc = 0x828B9A0C; continue 'dispatch;
	}
	// 828B9A08: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828B9A0C; continue 'dispatch;
            }
            0x828B9A0C => {
    //   block [0x828B9A0C..0x828B9A48)
	// 828B9A0C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 828B9A10: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 828B9A14: 4BBC6DB5  bl 0x824807c8
	ctx.lr = 0x828B9A18;
	sub_824807C8(ctx, base);
	// 828B9A18: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828B9A1C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828B9A20: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 828B9A24: 2F1F0005  cmpwi cr6, r31, 5
	ctx.cr[6].compare_i32(ctx.r[31].s32, 5, &mut ctx.xer);
	// 828B9A28: 997C0000  stb r11, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828B9A2C: 4198FFBC  blt cr6, 0x828b99e8
	if ctx.cr[6].lt {
	pc = 0x828B99E8; continue 'dispatch;
	}
	// 828B9A30: 39740028  addi r11, r20, 0x28
	ctx.r[11].s64 = ctx.r[20].s64 + 40;
	// 828B9A34: 3B7B0005  addi r27, r27, 5
	ctx.r[27].s64 = ctx.r[27].s64 + 5;
	// 828B9A38: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828B9A3C: 4198FFA8  blt cr6, 0x828b99e4
	if ctx.cr[6].lt {
	pc = 0x828B99E4; continue 'dispatch;
	}
	// 828B9A40: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828B9A44: 3BB20044  addi r29, r18, 0x44
	ctx.r[29].s64 = ctx.r[18].s64 + 68;
	pc = 0x828B9A48; continue 'dispatch;
            }
            0x828B9A48 => {
    //   block [0x828B9A48..0x828B9A4C)
	// 828B9A48: 3BC00005  li r30, 5
	ctx.r[30].s64 = 5;
	pc = 0x828B9A4C; continue 'dispatch;
            }
            0x828B9A4C => {
    //   block [0x828B9A4C..0x828B9A98)
	// 828B9A4C: 38BDFFD8  addi r5, r29, -0x28
	ctx.r[5].s64 = ctx.r[29].s64 + -40;
	// 828B9A50: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 828B9A54: 7C7FAA14  add r3, r31, r21
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[21].u64;
	// 828B9A58: 481633F1  bl 0x82a1ce48
	ctx.lr = 0x828B9A5C;
	sub_82A1CE48(ctx, base);
	// 828B9A5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B9A60: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 828B9A64: 7C7FB214  add r3, r31, r22
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[22].u64;
	// 828B9A68: 481633E1  bl 0x82a1ce48
	ctx.lr = 0x828B9A6C;
	sub_82A1CE48(ctx, base);
	// 828B9A6C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828B9A70: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 828B9A74: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828B9A78: 4082FFD4  bne 0x828b9a4c
	if !ctx.cr[0].eq {
	pc = 0x828B9A4C; continue 'dispatch;
	}
	// 828B9A7C: 2F1F00A0  cmpwi cr6, r31, 0xa0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 160, &mut ctx.xer);
	// 828B9A80: 4198FFC8  blt cr6, 0x828b9a48
	if ctx.cr[6].lt {
	pc = 0x828B9A48; continue 'dispatch;
	}
	// 828B9A84: 562B063E  clrlwi r11, r17, 0x18
	ctx.r[11].u64 = ctx.r[17].u32 as u64 & 0x000000FFu64;
	// 828B9A88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9A8C: 409A000C  bne cr6, 0x828b9a98
	if !ctx.cr[6].eq {
	pc = 0x828B9A98; continue 'dispatch;
	}
	// 828B9A90: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828B9A94: 4BFFF5BD  bl 0x828b9050
	ctx.lr = 0x828B9A98;
	sub_828B9050(ctx, base);
	pc = 0x828B9A98; continue 'dispatch;
            }
            0x828B9A98 => {
    //   block [0x828B9A98..0x828B9AA0)
	// 828B9A98: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 828B9A9C: 483EF990  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B9AA0 size=60
    let mut pc: u32 = 0x828B9AA0;
    'dispatch: loop {
        match pc {
            0x828B9AA0 => {
    //   block [0x828B9AA0..0x828B9ADC)
	// 828B9AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9AA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B9AAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9AB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B9AB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B9AB8: 388B9E28  addi r4, r11, -0x61d8
	ctx.r[4].s64 = ctx.r[11].s64 + -25048;
	// 828B9ABC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B9AC0: 4B973411  bl 0x8222ced0
	ctx.lr = 0x828B9AC4;
	sub_8222CED0(ctx, base);
	// 828B9AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B9AC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B9ACC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B9AD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B9AD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B9AD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B9AE0 size=84
    let mut pc: u32 = 0x828B9AE0;
    'dispatch: loop {
        match pc {
            0x828B9AE0 => {
    //   block [0x828B9AE0..0x828B9B10)
	// 828B9AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9AE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9AE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B9AEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9AF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B9AF4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9AF8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B9AFC: 556ACFFE  rlwinm r10, r11, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 828B9B00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B9B04: 419A000C  beq cr6, 0x828b9b10
	if ctx.cr[6].eq {
	pc = 0x828B9B10; continue 'dispatch;
	}
	// 828B9B08: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 828B9B0C: 4BAD306D  bl 0x8238cb78
	ctx.lr = 0x828B9B10;
	sub_8238CB78(ctx, base);
	pc = 0x828B9B10; continue 'dispatch;
            }
            0x828B9B10 => {
    //   block [0x828B9B10..0x828B9B34)
	// 828B9B10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B9B14: C05F0010  lfs f2, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828B9B18: C03F0014  lfs f1, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B9B1C: 4800001D  bl 0x828b9b38
	ctx.lr = 0x828B9B20;
	sub_828B9B38(ctx, base);
	// 828B9B20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B9B24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B9B28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B9B2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B9B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B9B38 size=412
    let mut pc: u32 = 0x828B9B38;
    'dispatch: loop {
        match pc {
            0x828B9B38 => {
    //   block [0x828B9B38..0x828B9B9C)
	// 828B9B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9B40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B9B44: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828B9B48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9B4C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9B50: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 828B9B54: D021009C  stfs f1, 0x9c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 828B9B58: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B9B5C: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 828B9B60: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B9B64: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828B9B68: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B9B6C: 419A00F4  beq cr6, 0x828b9c60
	if ctx.cr[6].eq {
	pc = 0x828B9C60; continue 'dispatch;
	}
	// 828B9B70: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B9B74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B9B78: 419A0024  beq cr6, 0x828b9b9c
	if ctx.cr[6].eq {
	pc = 0x828B9B9C; continue 'dispatch;
	}
	// 828B9B7C: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 828B9B80: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B9B84: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B9B88: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B9B8C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9B90: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B9B94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9B98: 480000CC  b 0x828b9c64
	pc = 0x828B9C64; continue 'dispatch;
            }
            0x828B9B9C => {
    //   block [0x828B9B9C..0x828B9BB8)
	// 828B9B9C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B9BA0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B9BA4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828B9BA8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B9BAC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B9BB0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B9BB4: 40810054  ble 0x828b9c08
	if !ctx.cr[0].gt {
	pc = 0x828B9C08; continue 'dispatch;
	}
	pc = 0x828B9BB8; continue 'dispatch;
            }
            0x828B9BB8 => {
    //   block [0x828B9BB8..0x828B9BD8)
	// 828B9BB8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B9BBC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B9BC0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B9BC4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9BC8: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828B9BCC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B9BD0: 41980008  blt cr6, 0x828b9bd8
	if ctx.cr[6].lt {
	pc = 0x828B9BD8; continue 'dispatch;
	}
	// 828B9BD4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x828B9BD8; continue 'dispatch;
            }
            0x828B9BD8 => {
    //   block [0x828B9BD8..0x828B9BF4)
	// 828B9BD8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B9BDC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B9BE0: 419A0014  beq cr6, 0x828b9bf4
	if ctx.cr[6].eq {
	pc = 0x828B9BF4; continue 'dispatch;
	}
	// 828B9BE4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B9BE8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B9BEC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B9BF0: 4800000C  b 0x828b9bfc
	pc = 0x828B9BFC; continue 'dispatch;
            }
            0x828B9BF4 => {
    //   block [0x828B9BF4..0x828B9BFC)
	// 828B9BF4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B9BF8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828B9BFC; continue 'dispatch;
            }
            0x828B9BFC => {
    //   block [0x828B9BFC..0x828B9C08)
	// 828B9BFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B9C00: 4199FFB8  bgt cr6, 0x828b9bb8
	if ctx.cr[6].gt {
	pc = 0x828B9BB8; continue 'dispatch;
	}
	// 828B9C04: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828B9C08; continue 'dispatch;
            }
            0x828B9C08 => {
    //   block [0x828B9C08..0x828B9C24)
	// 828B9C08: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B9C0C: 419A0040  beq cr6, 0x828b9c4c
	if ctx.cr[6].eq {
	pc = 0x828B9C4C; continue 'dispatch;
	}
	// 828B9C10: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9C14: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828B9C18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9C1C: 41990008  bgt cr6, 0x828b9c24
	if ctx.cr[6].gt {
	pc = 0x828B9C24; continue 'dispatch;
	}
	// 828B9C20: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828B9C24; continue 'dispatch;
            }
            0x828B9C24 => {
    //   block [0x828B9C24..0x828B9C4C)
	// 828B9C24: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B9C28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9C2C: 409A0020  bne cr6, 0x828b9c4c
	if !ctx.cr[6].eq {
	pc = 0x828B9C4C; continue 'dispatch;
	}
	// 828B9C30: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B9C34: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B9C38: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B9C3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9C40: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B9C44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9C48: 4800001C  b 0x828b9c64
	pc = 0x828B9C64; continue 'dispatch;
            }
            0x828B9C4C => {
    //   block [0x828B9C4C..0x828B9C60)
	// 828B9C4C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B9C50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9C54: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828B9C58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9C5C: 48000008  b 0x828b9c64
	pc = 0x828B9C64; continue 'dispatch;
            }
            0x828B9C60 => {
    //   block [0x828B9C60..0x828B9C64)
	// 828B9C60: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828B9C64; continue 'dispatch;
            }
            0x828B9C64 => {
    //   block [0x828B9C64..0x828B9CBC)
	// 828B9C64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B9C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9C6C: 419A0050  beq cr6, 0x828b9cbc
	if ctx.cr[6].eq {
	pc = 0x828B9CBC; continue 'dispatch;
	}
	// 828B9C70: 3961009C  addi r11, r1, 0x9c
	ctx.r[11].s64 = ctx.r[1].s64 + 156;
	// 828B9C74: 3941009C  addi r10, r1, 0x9c
	ctx.r[10].s64 = ctx.r[1].s64 + 156;
	// 828B9C78: 392100A4  addi r9, r1, 0xa4
	ctx.r[9].s64 = ctx.r[1].s64 + 164;
	// 828B9C7C: 3901009C  addi r8, r1, 0x9c
	ctx.r[8].s64 = ctx.r[1].s64 + 156;
	// 828B9C80: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	pc = 0x828B9CBC; continue 'dispatch;
            }
            0x828B9CBC => {
    //   block [0x828B9CBC..0x828B9CD4)
	// 828B9CBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B9CC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B9CC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B9CC8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B9CCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B9CD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B9CD8 size=144
    let mut pc: u32 = 0x828B9CD8;
    'dispatch: loop {
        match pc {
            0x828B9CD8 => {
    //   block [0x828B9CD8..0x828B9D30)
	// 828B9CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9CE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B9CE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B9CE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9CEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B9CF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B9CF4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B9CF8: 419A0038  beq cr6, 0x828b9d30
	if ctx.cr[6].eq {
	pc = 0x828B9D30; continue 'dispatch;
	}
	// 828B9CFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9D00: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828B9D04: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 828B9D08: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 828B9D0C: 388A34A0  addi r4, r10, 0x34a0
	ctx.r[4].s64 = ctx.r[10].s64 + 13472;
	// 828B9D10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B9D14: 4BAF36DD  bl 0x823ad3f0
	ctx.lr = 0x828B9D18;
	sub_823AD3F0(ctx, base);
	// 828B9D18: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828B9D1C: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 828B9D20: 38892D8C  addi r4, r9, 0x2d8c
	ctx.r[4].s64 = ctx.r[9].s64 + 11660;
	// 828B9D24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B9D28: 4BAF36C9  bl 0x823ad3f0
	ctx.lr = 0x828B9D2C;
	sub_823AD3F0(ctx, base);
	// 828B9D2C: 48000024  b 0x828b9d50
	pc = 0x828B9D50; continue 'dispatch;
            }
            0x828B9D30 => {
    //   block [0x828B9D30..0x828B9D50)
	// 828B9D30: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B9D34: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828B9D38: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828B9D3C: 993F000C  stb r9, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u8 ) };
	// 828B9D40: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B9D44: C1AA15A0  lfs f13, 0x15a0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5536 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B9D48: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828B9D4C: D1BF0014  stfs f13, 0x14(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x828B9D50; continue 'dispatch;
            }
            0x828B9D50 => {
    //   block [0x828B9D50..0x828B9D68)
	// 828B9D50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B9D54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B9D58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B9D5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B9D60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B9D64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B9D68 size=92
    let mut pc: u32 = 0x828B9D68;
    'dispatch: loop {
        match pc {
            0x828B9D68 => {
    //   block [0x828B9D68..0x828B9DAC)
	// 828B9D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9D70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B9D74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B9D78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9D7C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B9D80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B9D84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B9D88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9D8C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9D90: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828B9D94: 4E800421  bctrl
	ctx.lr = 0x828B9D98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B9D98: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 828B9D9C: 409A0010  bne cr6, 0x828b9dac
	if !ctx.cr[6].eq {
	pc = 0x828B9DAC; continue 'dispatch;
	}
	// 828B9DA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B9DA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B9DA8: 48000021  bl 0x828b9dc8
	ctx.lr = 0x828B9DAC;
	sub_828B9DC8(ctx, base);
            }
            0x828B9DAC => {
    //   block [0x828B9DAC..0x828B9DC4)
	// 828B9DAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B9DB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B9DB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B9DB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B9DBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B9DC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B9DC8 size=320
    let mut pc: u32 = 0x828B9DC8;
    'dispatch: loop {
        match pc {
            0x828B9DC8 => {
    //   block [0x828B9DC8..0x828B9E18)
	// 828B9DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9DCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9DD0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9DD4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9DD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828B9DDC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828B9DE0: 554957FE  rlwinm r9, r10, 0xa, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x003FFFFFu64;
	// 828B9DE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828B9DE8: 419A00F4  beq cr6, 0x828b9edc
	if ctx.cr[6].eq {
	pc = 0x828B9EDC; continue 'dispatch;
	}
	// 828B9DEC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B9DF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828B9DF4: 419A0024  beq cr6, 0x828b9e18
	if ctx.cr[6].eq {
	pc = 0x828B9E18; continue 'dispatch;
	}
	// 828B9DF8: 894A0016  lbz r10, 0x16(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(22 as u32) ) } as u64;
	// 828B9DFC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B9E00: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828B9E04: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B9E08: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9E0C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B9E10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9E14: 480000CC  b 0x828b9ee0
	pc = 0x828B9EE0; continue 'dispatch;
            }
            0x828B9E18 => {
    //   block [0x828B9E18..0x828B9E34)
	// 828B9E18: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828B9E1C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828B9E20: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828B9E24: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828B9E28: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B9E2C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B9E30: 40810054  ble 0x828b9e84
	if !ctx.cr[0].gt {
	pc = 0x828B9E84; continue 'dispatch;
	}
	pc = 0x828B9E34; continue 'dispatch;
            }
            0x828B9E34 => {
    //   block [0x828B9E34..0x828B9E54)
	// 828B9E34: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828B9E38: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828B9E3C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828B9E40: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9E44: 2F070016  cmpwi cr6, r7, 0x16
	ctx.cr[6].compare_i32(ctx.r[7].s32, 22, &mut ctx.xer);
	// 828B9E48: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828B9E4C: 41980008  blt cr6, 0x828b9e54
	if ctx.cr[6].lt {
	pc = 0x828B9E54; continue 'dispatch;
	}
	// 828B9E50: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x828B9E54; continue 'dispatch;
            }
            0x828B9E54 => {
    //   block [0x828B9E54..0x828B9E70)
	// 828B9E54: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828B9E58: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828B9E5C: 419A0014  beq cr6, 0x828b9e70
	if ctx.cr[6].eq {
	pc = 0x828B9E70; continue 'dispatch;
	}
	// 828B9E60: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828B9E64: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828B9E68: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828B9E6C: 4800000C  b 0x828b9e78
	pc = 0x828B9E78; continue 'dispatch;
            }
            0x828B9E70 => {
    //   block [0x828B9E70..0x828B9E78)
	// 828B9E70: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828B9E74: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828B9E78; continue 'dispatch;
            }
            0x828B9E78 => {
    //   block [0x828B9E78..0x828B9E84)
	// 828B9E78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B9E7C: 4199FFB8  bgt cr6, 0x828b9e34
	if ctx.cr[6].gt {
	pc = 0x828B9E34; continue 'dispatch;
	}
	// 828B9E80: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828B9E84; continue 'dispatch;
            }
            0x828B9E84 => {
    //   block [0x828B9E84..0x828B9EA0)
	// 828B9E84: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828B9E88: 419A0040  beq cr6, 0x828b9ec8
	if ctx.cr[6].eq {
	pc = 0x828B9EC8; continue 'dispatch;
	}
	// 828B9E8C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B9E90: 2F0B0016  cmpwi cr6, r11, 0x16
	ctx.cr[6].compare_i32(ctx.r[11].s32, 22, &mut ctx.xer);
	// 828B9E94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9E98: 41990008  bgt cr6, 0x828b9ea0
	if ctx.cr[6].gt {
	pc = 0x828B9EA0; continue 'dispatch;
	}
	// 828B9E9C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x828B9EA0; continue 'dispatch;
            }
            0x828B9EA0 => {
    //   block [0x828B9EA0..0x828B9EC8)
	// 828B9EA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B9EA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9EA8: 409A0020  bne cr6, 0x828b9ec8
	if !ctx.cr[6].eq {
	pc = 0x828B9EC8; continue 'dispatch;
	}
	// 828B9EAC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828B9EB0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828B9EB4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B9EB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9EBC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B9EC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9EC4: 4800001C  b 0x828b9ee0
	pc = 0x828B9EE0; continue 'dispatch;
            }
            0x828B9EC8 => {
    //   block [0x828B9EC8..0x828B9EDC)
	// 828B9EC8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828B9ECC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B9ED0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828B9ED4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B9ED8: 48000008  b 0x828b9ee0
	pc = 0x828B9EE0; continue 'dispatch;
            }
            0x828B9EDC => {
    //   block [0x828B9EDC..0x828B9EE0)
	// 828B9EDC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x828B9EE0; continue 'dispatch;
            }
            0x828B9EE0 => {
    //   block [0x828B9EE0..0x828B9EF8)
	// 828B9EE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828B9EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9EE8: 419A0010  beq cr6, 0x828b9ef8
	if ctx.cr[6].eq {
	pc = 0x828B9EF8; continue 'dispatch;
	}
	// 828B9EEC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B9EF0: C02B92D4  lfs f1, -0x6d2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B9EF4: 4BD35745  bl 0x825ef638
	ctx.lr = 0x828B9EF8;
	sub_825EF638(ctx, base);
	pc = 0x828B9EF8; continue 'dispatch;
            }
            0x828B9EF8 => {
    //   block [0x828B9EF8..0x828B9F08)
	// 828B9EF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B9EFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B9F00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B9F04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B9F08 size=204
    let mut pc: u32 = 0x828B9F08;
    'dispatch: loop {
        match pc {
            0x828B9F08 => {
    //   block [0x828B9F08..0x828B9F50)
	// 828B9F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9F0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9F10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B9F14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B9F18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9F1C: 8964000C  lbz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B9F20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B9F24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9F28: 419A0028  beq cr6, 0x828b9f50
	if ctx.cr[6].eq {
	pc = 0x828B9F50; continue 'dispatch;
	}
	// 828B9F2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9F30: 4B920481  bl 0x821da3b0
	ctx.lr = 0x828B9F34;
	sub_821DA3B0(ctx, base);
	// 828B9F34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828B9F38: 38AB2D60  addi r5, r11, 0x2d60
	ctx.r[5].s64 = ctx.r[11].s64 + 11616;
	// 828B9F3C: 4B8F85BD  bl 0x821b24f8
	ctx.lr = 0x828B9F40;
	sub_821B24F8(ctx, base);
	// 828B9F40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B9F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B9F48: 4BEC94D1  bl 0x82783418
	ctx.lr = 0x828B9F4C;
	sub_82783418(ctx, base);
	// 828B9F4C: 4800006C  b 0x828b9fb8
	pc = 0x828B9FB8; continue 'dispatch;
            }
            0x828B9F50 => {
    //   block [0x828B9F50..0x828B9FB8)
	// 828B9F50: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828B9F54: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B9F58: 388B0500  addi r4, r11, 0x500
	ctx.r[4].s64 = ctx.r[11].s64 + 1280;
	// 828B9F5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9F60: 4B972F71  bl 0x8222ced0
	ctx.lr = 0x828B9F64;
	sub_8222CED0(ctx, base);
	// 828B9F64: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828B9F68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B9F6C: 388A2D94  addi r4, r10, 0x2d94
	ctx.r[4].s64 = ctx.r[10].s64 + 11668;
	// 828B9F70: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828B9F74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9F78: 4B972F59  bl 0x8222ced0
	ctx.lr = 0x828B9F7C;
	sub_8222CED0(ctx, base);
	// 828B9F7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B9F80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9F84: 4B932875  bl 0x821ec7f8
	ctx.lr = 0x828B9F88;
	sub_821EC7F8(ctx, base);
	// 828B9F88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B9F8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B9F90: 4B934BA9  bl 0x821eeb38
	ctx.lr = 0x828B9F94;
	sub_821EEB38(ctx, base);
	// 828B9F94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B9F98: 48349859  bl 0x82c037f0
	ctx.lr = 0x828B9F9C;
	sub_82C037F0(ctx, base);
	// 828B9F9C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828B9FA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B9FA4: 4B95AE35  bl 0x82214dd8
	ctx.lr = 0x828B9FA8;
	sub_82214DD8(ctx, base);
	// 828B9FA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B9FAC: 4B95AE2D  bl 0x82214dd8
	ctx.lr = 0x828B9FB0;
	sub_82214DD8(ctx, base);
	// 828B9FB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B9FB4: 4B95AE25  bl 0x82214dd8
	ctx.lr = 0x828B9FB8;
	sub_82214DD8(ctx, base);
	pc = 0x828B9FB8; continue 'dispatch;
            }
            0x828B9FB8 => {
    //   block [0x828B9FB8..0x828B9FD4)
	// 828B9FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B9FBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B9FC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B9FC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B9FC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B9FCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B9FD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B9FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B9FD8 size=204
    let mut pc: u32 = 0x828B9FD8;
    'dispatch: loop {
        match pc {
            0x828B9FD8 => {
    //   block [0x828B9FD8..0x828BA020)
	// 828B9FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B9FDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B9FE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B9FE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B9FE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B9FEC: 8964000C  lbz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 828B9FF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B9FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B9FF8: 419A0028  beq cr6, 0x828ba020
	if ctx.cr[6].eq {
	pc = 0x828BA020; continue 'dispatch;
	}
	// 828B9FFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BA000: 4B9203B1  bl 0x821da3b0
	ctx.lr = 0x828BA004;
	sub_821DA3B0(ctx, base);
	// 828BA004: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828BA008: 38AB2D70  addi r5, r11, 0x2d70
	ctx.r[5].s64 = ctx.r[11].s64 + 11632;
	// 828BA00C: 4B8F84ED  bl 0x821b24f8
	ctx.lr = 0x828BA010;
	sub_821B24F8(ctx, base);
	// 828BA010: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BA014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA018: 4BEC9401  bl 0x82783418
	ctx.lr = 0x828BA01C;
	sub_82783418(ctx, base);
	// 828BA01C: 4800006C  b 0x828ba088
	pc = 0x828BA088; continue 'dispatch;
            }
            0x828BA020 => {
    //   block [0x828BA020..0x828BA088)
	// 828BA020: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828BA024: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BA028: 388B0500  addi r4, r11, 0x500
	ctx.r[4].s64 = ctx.r[11].s64 + 1280;
	// 828BA02C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BA030: 4B972EA1  bl 0x8222ced0
	ctx.lr = 0x828BA034;
	sub_8222CED0(ctx, base);
	// 828BA034: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828BA038: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BA03C: 388A2DC4  addi r4, r10, 0x2dc4
	ctx.r[4].s64 = ctx.r[10].s64 + 11716;
	// 828BA040: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BA044: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA048: 4B972E89  bl 0x8222ced0
	ctx.lr = 0x828BA04C;
	sub_8222CED0(ctx, base);
	// 828BA04C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BA050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA054: 4B9327A5  bl 0x821ec7f8
	ctx.lr = 0x828BA058;
	sub_821EC7F8(ctx, base);
	// 828BA058: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA05C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BA060: 4B934AD9  bl 0x821eeb38
	ctx.lr = 0x828BA064;
	sub_821EEB38(ctx, base);
	// 828BA064: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BA068: 48349789  bl 0x82c037f0
	ctx.lr = 0x828BA06C;
	sub_82C037F0(ctx, base);
	// 828BA06C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828BA070: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BA074: 4B95AD65  bl 0x82214dd8
	ctx.lr = 0x828BA078;
	sub_82214DD8(ctx, base);
	// 828BA078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA07C: 4B95AD5D  bl 0x82214dd8
	ctx.lr = 0x828BA080;
	sub_82214DD8(ctx, base);
	// 828BA080: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BA084: 4B95AD55  bl 0x82214dd8
	ctx.lr = 0x828BA088;
	sub_82214DD8(ctx, base);
	pc = 0x828BA088; continue 'dispatch;
            }
            0x828BA088 => {
    //   block [0x828BA088..0x828BA0A4)
	// 828BA088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA08C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BA090: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA094: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA098: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BA09C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA0A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BA0A8 size=204
    let mut pc: u32 = 0x828BA0A8;
    'dispatch: loop {
        match pc {
            0x828BA0A8 => {
    //   block [0x828BA0A8..0x828BA0F0)
	// 828BA0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA0AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BA0B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BA0B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BA0B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA0BC: 8964000C  lbz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BA0C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BA0C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BA0C8: 419A0028  beq cr6, 0x828ba0f0
	if ctx.cr[6].eq {
	pc = 0x828BA0F0; continue 'dispatch;
	}
	// 828BA0CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BA0D0: 4B9202E1  bl 0x821da3b0
	ctx.lr = 0x828BA0D4;
	sub_821DA3B0(ctx, base);
	// 828BA0D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828BA0D8: 38AB2D80  addi r5, r11, 0x2d80
	ctx.r[5].s64 = ctx.r[11].s64 + 11648;
	// 828BA0DC: 4B8F841D  bl 0x821b24f8
	ctx.lr = 0x828BA0E0;
	sub_821B24F8(ctx, base);
	// 828BA0E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BA0E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA0E8: 4BEC9331  bl 0x82783418
	ctx.lr = 0x828BA0EC;
	sub_82783418(ctx, base);
	// 828BA0EC: 4800006C  b 0x828ba158
	pc = 0x828BA158; continue 'dispatch;
            }
            0x828BA0F0 => {
    //   block [0x828BA0F0..0x828BA158)
	// 828BA0F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828BA0F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BA0F8: 388B0500  addi r4, r11, 0x500
	ctx.r[4].s64 = ctx.r[11].s64 + 1280;
	// 828BA0FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BA100: 4B972DD1  bl 0x8222ced0
	ctx.lr = 0x828BA104;
	sub_8222CED0(ctx, base);
	// 828BA104: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828BA108: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BA10C: 388A2DF8  addi r4, r10, 0x2df8
	ctx.r[4].s64 = ctx.r[10].s64 + 11768;
	// 828BA110: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BA114: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA118: 4B972DB9  bl 0x8222ced0
	ctx.lr = 0x828BA11C;
	sub_8222CED0(ctx, base);
	// 828BA11C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BA120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA124: 4B9326D5  bl 0x821ec7f8
	ctx.lr = 0x828BA128;
	sub_821EC7F8(ctx, base);
	// 828BA128: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BA12C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BA130: 4B934A09  bl 0x821eeb38
	ctx.lr = 0x828BA134;
	sub_821EEB38(ctx, base);
	// 828BA134: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BA138: 483496B9  bl 0x82c037f0
	ctx.lr = 0x828BA13C;
	sub_82C037F0(ctx, base);
	// 828BA13C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828BA140: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BA144: 4B95AC95  bl 0x82214dd8
	ctx.lr = 0x828BA148;
	sub_82214DD8(ctx, base);
	// 828BA148: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BA14C: 4B95AC8D  bl 0x82214dd8
	ctx.lr = 0x828BA150;
	sub_82214DD8(ctx, base);
	// 828BA150: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BA154: 4B95AC85  bl 0x82214dd8
	ctx.lr = 0x828BA158;
	sub_82214DD8(ctx, base);
	pc = 0x828BA158; continue 'dispatch;
            }
            0x828BA158 => {
    //   block [0x828BA158..0x828BA174)
	// 828BA158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA15C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BA160: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BA164: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BA168: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BA16C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BA170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BA178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BA178 size=3192
    let mut pc: u32 = 0x828BA178;
    'dispatch: loop {
        match pc {
            0x828BA178 => {
    //   block [0x828BA178..0x828BA1AC)
	// 828BA178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BA17C: 483EF281  bl 0x82ca93fc
	ctx.lr = 0x828BA180;
	sub_82CA93D0(ctx, base);
	// 828BA180: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828BA184: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BA188: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828BA18C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828BA190: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828BA194: 419A0018  beq cr6, 0x828ba1ac
	if ctx.cr[6].eq {
	pc = 0x828BA1AC; continue 'dispatch;
	}
	// 828BA198: 897A0090  lbz r11, 0x90(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BA19C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BA1A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BA1A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BA1A8: 409A0008  bne cr6, 0x828ba1b0
	if !ctx.cr[6].eq {
	pc = 0x828BA1B0; continue 'dispatch;
	}
	pc = 0x828BA1AC; continue 'dispatch;
            }
            0x828BA1AC => {
    //   block [0x828BA1AC..0x828BA1B0)
	// 828BA1AC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x828BA1B0; continue 'dispatch;
            }
            0x828BA1B0 => {
    //   block [0x828BA1B0..0x828BA79C)
	// 828BA1B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BA1B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BA1B8: 419A0C2C  beq cr6, 0x828bade4
	if ctx.cr[6].eq {
	pc = 0x828BADE4; continue 'dispatch;
	}
	// 828BA1BC: 817A0024  lwz r11, 0x24(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 828BA1C0: 556ACFFE  rlwinm r10, r11, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 828BA1C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BA1C8: 419A05D4  beq cr6, 0x828ba79c
	if ctx.cr[6].eq {
	pc = 0x828BA79C; continue 'dispatch;
	}
	// 828BA1CC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828BA1D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BA1D4: 3BAB2E2C  addi r29, r11, 0x2e2c
	ctx.r[29].s64 = ctx.r[11].s64 + 11820;
	// 828BA1D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BA1DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BA1E0: 4B972CF1  bl 0x8222ced0
	ctx.lr = 0x828BA1E4;
	sub_8222CED0(ctx, base);
	// 828BA1E4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828BA1E8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BA1EC: 3B8B7564  addi r28, r11, 0x7564
	ctx.r[28].s64 = ctx.r[11].s64 + 30052;
	// 828BA1F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828BA1F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BA1F8: 4B972CD9  bl 0x8222ced0
	ctx.lr = 0x828BA1FC;
	sub_8222CED0(ctx, base);
	// 828BA1FC: 809A007C  lwz r4, 0x7c(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(124 as u32) ) } as u64;
	// 828BA200: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828BA204: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA208: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BA20C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BA210: 4E800421  bctrl
	ctx.lr = 0x828BA214;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BA214: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 828BA218: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	// 828BA21C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828BA220: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828BA224: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828BA228: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
            }
            0x828BA79C => {
    //   block [0x828BA79C..0x828BADE4)
	// 828BA79C: 817A0040  lwz r11, 0x40(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BA7A0: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 828BA7A4: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828BA7A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BA7AC: 419A00F4  beq cr6, 0x828ba8a0
	if ctx.cr[6].eq {
	pc = 0x828BA8A0; continue 'dispatch;
	}
	// 828BA7B0: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BA7B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BA7B8: 419A0024  beq cr6, 0x828ba7dc
	if ctx.cr[6].eq {
	pc = 0x828BA7DC; continue 'dispatch;
	}
	// 828BA7BC: 894B00E5  lbz r10, 0xe5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(229 as u32) ) } as u64;
	// 828BA7C0: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BA7C4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828BA7C8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BA7CC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BA7D0: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828BA7D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BA7D8: 480000CC  b 0x828ba8a4
	pc = 0x828BA8A4; continue 'dispatch;
	// 828BA7DC: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BA7E0: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BA7E4: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 828BA7E8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BA7EC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BA7F0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BA7F4: 40810054  ble 0x828ba848
	if !ctx.cr[0].gt {
	pc = 0x828BA848; continue 'dispatch;
	}
	// 828BA7F8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BA7FC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BA800: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828BA804: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA808: 2F0700E5  cmpwi cr6, r7, 0xe5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 229, &mut ctx.xer);
	// 828BA80C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828BA810: 41980008  blt cr6, 0x828ba818
	if ctx.cr[6].lt {
	pc = 0x828BA818; continue 'dispatch;
	}
	// 828BA814: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828BA818: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BA81C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BA820: 419A0014  beq cr6, 0x828ba834
	if ctx.cr[6].eq {
	pc = 0x828BA834; continue 'dispatch;
	}
	// 828BA824: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BA828: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BA82C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BA830: 4800000C  b 0x828ba83c
	pc = 0x828BA83C; continue 'dispatch;
	// 828BA834: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BA838: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BA83C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BA840: 4199FFB8  bgt cr6, 0x828ba7f8
	if ctx.cr[6].gt {
	pc = 0x828BA7F8; continue 'dispatch;
	}
	// 828BA844: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BA848: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BA84C: 419A0040  beq cr6, 0x828ba88c
	if ctx.cr[6].eq {
	pc = 0x828BA88C; continue 'dispatch;
	}
	// 828BA850: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA854: 2F0B00E5  cmpwi cr6, r11, 0xe5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 229, &mut ctx.xer);
	// 828BA858: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BA85C: 41990008  bgt cr6, 0x828ba864
	if ctx.cr[6].gt {
	pc = 0x828BA864; continue 'dispatch;
	}
	// 828BA860: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BA864: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BA868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BA86C: 409A0020  bne cr6, 0x828ba88c
	if !ctx.cr[6].eq {
	pc = 0x828BA88C; continue 'dispatch;
	}
	// 828BA870: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BA874: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BA878: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BA87C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BA880: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828BA884: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BA888: 4800001C  b 0x828ba8a4
	pc = 0x828BA8A4; continue 'dispatch;
	// 828BA88C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BA890: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BA894: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 828BA898: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BA89C: 48000008  b 0x828ba8a4
	pc = 0x828BA8A4; continue 'dispatch;
	// 828BA8A0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BA8A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BA8A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BA8AC: 409A001C  bne cr6, 0x828ba8c8
	if !ctx.cr[6].eq {
	pc = 0x828BA8C8; continue 'dispatch;
	}
	// 828BA8B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828BA8B4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828BA8B8: 388B9E28  addi r4, r11, -0x61d8
	ctx.r[4].s64 = ctx.r[11].s64 + -25048;
	// 828BA8BC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828BA8C0: 4BAD24A9  bl 0x8238cd68
	ctx.lr = 0x828BA8C4;
	sub_8238CD68(ctx, base);
	// 828BA8C4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BA8C8: 817A0024  lwz r11, 0x24(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 828BA8CC: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 828BA8D0: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 828BA8D4: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828BA8D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BA8DC: 419A00E8  beq cr6, 0x828ba9c4
	if ctx.cr[6].eq {
	pc = 0x828BA9C4; continue 'dispatch;
	}
	// 828BA8E0: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BA8E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BA8E8: 419A0020  beq cr6, 0x828ba908
	if ctx.cr[6].eq {
	pc = 0x828BA908; continue 'dispatch;
	}
	// 828BA8EC: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828BA8F0: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BA8F4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828BA8F8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BA8FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BA900: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BA904: 480000C4  b 0x828ba9c8
	pc = 0x828BA9C8; continue 'dispatch;
	// 828BA908: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BA90C: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BA910: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 828BA914: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BA918: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BA91C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BA920: 40810054  ble 0x828ba974
	if !ctx.cr[0].gt {
	pc = 0x828BA974; continue 'dispatch;
	}
	// 828BA924: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BA928: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BA92C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828BA930: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA934: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828BA938: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828BA93C: 41980008  blt cr6, 0x828ba944
	if ctx.cr[6].lt {
	pc = 0x828BA944; continue 'dispatch;
	}
	// 828BA940: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828BA944: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BA948: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BA94C: 419A0014  beq cr6, 0x828ba960
	if ctx.cr[6].eq {
	pc = 0x828BA960; continue 'dispatch;
	}
	// 828BA950: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BA954: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BA958: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BA95C: 4800000C  b 0x828ba968
	pc = 0x828BA968; continue 'dispatch;
	// 828BA960: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BA964: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BA968: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BA96C: 4199FFB8  bgt cr6, 0x828ba924
	if ctx.cr[6].gt {
	pc = 0x828BA924; continue 'dispatch;
	}
	// 828BA970: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BA974: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BA978: 419A003C  beq cr6, 0x828ba9b4
	if ctx.cr[6].eq {
	pc = 0x828BA9B4; continue 'dispatch;
	}
	// 828BA97C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BA980: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828BA984: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BA988: 41990008  bgt cr6, 0x828ba990
	if ctx.cr[6].gt {
	pc = 0x828BA990; continue 'dispatch;
	}
	// 828BA98C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BA990: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BA994: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BA998: 409A001C  bne cr6, 0x828ba9b4
	if !ctx.cr[6].eq {
	pc = 0x828BA9B4; continue 'dispatch;
	}
	// 828BA99C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BA9A0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BA9A4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BA9A8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BA9AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BA9B0: 48000018  b 0x828ba9c8
	pc = 0x828BA9C8; continue 'dispatch;
	// 828BA9B4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BA9B8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BA9BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BA9C0: 48000008  b 0x828ba9c8
	pc = 0x828BA9C8; continue 'dispatch;
	// 828BA9C4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BA9C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BA9CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BA9D0: 419A0050  beq cr6, 0x828baa20
	if ctx.cr[6].eq {
	pc = 0x828BAA20; continue 'dispatch;
	}
	// 828BA9D4: 83DF0090  lwz r30, 0x90(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BA9D8: 57CB0630  rlwinm r11, r30, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 828BA9DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BA9E0: 409A000C  bne cr6, 0x828ba9ec
	if !ctx.cr[6].eq {
	pc = 0x828BA9EC; continue 'dispatch;
	}
	// 828BA9E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BA9E8: 4BCB7F01  bl 0x825728e8
	ctx.lr = 0x828BA9EC;
	sub_825728E8(ctx, base);
	// 828BA9EC: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BA9F0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828BA9F4: 616A0080  ori r10, r11, 0x80
	ctx.r[10].u64 = ctx.r[11].u64 | 128;
	// 828BA9F8: 915F0090  stw r10, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 828BA9FC: 409A0024  bne cr6, 0x828baa20
	if !ctx.cr[6].eq {
	pc = 0x828BAA20; continue 'dispatch;
	}
	// 828BAA00: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828BAA04: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAA08: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BAA0C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BAA10: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BAA14: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAA18: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAA1C: 4B9565FD  bl 0x82211018
	ctx.lr = 0x828BAA20;
	sub_82211018(ctx, base);
	// 828BAA20: 815A0028  lwz r10, 0x28(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 828BAA24: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BAA28: 55498FFE  rlwinm r9, r10, 0x11, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00007FFFu64;
	// 828BAA2C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BAA30: 419A00E8  beq cr6, 0x828bab18
	if ctx.cr[6].eq {
	pc = 0x828BAB18; continue 'dispatch;
	}
	// 828BAA34: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BAA38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BAA3C: 419A0020  beq cr6, 0x828baa5c
	if ctx.cr[6].eq {
	pc = 0x828BAA5C; continue 'dispatch;
	}
	// 828BAA40: 894B002F  lbz r10, 0x2f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(47 as u32) ) } as u64;
	// 828BAA44: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BAA48: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828BAA4C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BAA50: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BAA54: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAA58: 480000C4  b 0x828bab1c
	pc = 0x828BAB1C; continue 'dispatch;
	// 828BAA5C: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BAA60: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BAA64: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 828BAA68: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BAA6C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BAA70: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BAA74: 40810054  ble 0x828baac8
	if !ctx.cr[0].gt {
	pc = 0x828BAAC8; continue 'dispatch;
	}
	// 828BAA78: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BAA7C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BAA80: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828BAA84: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAA88: 2F07002F  cmpwi cr6, r7, 0x2f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 47, &mut ctx.xer);
	// 828BAA8C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828BAA90: 41980008  blt cr6, 0x828baa98
	if ctx.cr[6].lt {
	pc = 0x828BAA98; continue 'dispatch;
	}
	// 828BAA94: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828BAA98: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BAA9C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BAAA0: 419A0014  beq cr6, 0x828baab4
	if ctx.cr[6].eq {
	pc = 0x828BAAB4; continue 'dispatch;
	}
	// 828BAAA4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BAAA8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BAAAC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BAAB0: 4800000C  b 0x828baabc
	pc = 0x828BAABC; continue 'dispatch;
	// 828BAAB4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BAAB8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BAABC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BAAC0: 4199FFB8  bgt cr6, 0x828baa78
	if ctx.cr[6].gt {
	pc = 0x828BAA78; continue 'dispatch;
	}
	// 828BAAC4: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BAAC8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BAACC: 419A003C  beq cr6, 0x828bab08
	if ctx.cr[6].eq {
	pc = 0x828BAB08; continue 'dispatch;
	}
	// 828BAAD0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAAD4: 2F0B002F  cmpwi cr6, r11, 0x2f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 47, &mut ctx.xer);
	// 828BAAD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BAADC: 41990008  bgt cr6, 0x828baae4
	if ctx.cr[6].gt {
	pc = 0x828BAAE4; continue 'dispatch;
	}
	// 828BAAE0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BAAE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BAAE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BAAEC: 409A001C  bne cr6, 0x828bab08
	if !ctx.cr[6].eq {
	pc = 0x828BAB08; continue 'dispatch;
	}
	// 828BAAF0: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BAAF4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BAAF8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BAAFC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BAB00: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAB04: 48000018  b 0x828bab1c
	pc = 0x828BAB1C; continue 'dispatch;
	// 828BAB08: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BAB0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BAB10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAB14: 48000008  b 0x828bab1c
	pc = 0x828BAB1C; continue 'dispatch;
	// 828BAB18: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 828BAB1C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828BAB20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BAB24: 419A0008  beq cr6, 0x828bab2c
	if ctx.cr[6].eq {
	pc = 0x828BAB2C; continue 'dispatch;
	}
	// 828BAB28: 9B2B0308  stb r25, 0x308(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(776 as u32), ctx.r[25].u8 ) };
	// 828BAB2C: 897A0024  lbz r11, 0x24(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 828BAB30: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 828BAB34: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828BAB38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BAB3C: 419A00F0  beq cr6, 0x828bac2c
	if ctx.cr[6].eq {
	pc = 0x828BAC2C; continue 'dispatch;
	}
	// 828BAB40: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BAB44: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BAB48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BAB4C: 419A0020  beq cr6, 0x828bab6c
	if ctx.cr[6].eq {
	pc = 0x828BAB6C; continue 'dispatch;
	}
	// 828BAB50: 896B0018  lbz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828BAB54: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828BAB58: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BAB5C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAB60: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828BAB64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BAB68: 480000C8  b 0x828bac30
	pc = 0x828BAC30; continue 'dispatch;
	// 828BAB6C: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BAB70: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 828BAB74: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BAB78: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BAB7C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BAB80: 40810054  ble 0x828babd4
	if !ctx.cr[0].gt {
	pc = 0x828BABD4; continue 'dispatch;
	}
	// 828BAB84: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BAB88: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BAB8C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828BAB90: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAB94: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 828BAB98: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828BAB9C: 41980008  blt cr6, 0x828baba4
	if ctx.cr[6].lt {
	pc = 0x828BABA4; continue 'dispatch;
	}
	// 828BABA0: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828BABA4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BABA8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BABAC: 419A0014  beq cr6, 0x828babc0
	if ctx.cr[6].eq {
	pc = 0x828BABC0; continue 'dispatch;
	}
	// 828BABB0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BABB4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BABB8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BABBC: 4800000C  b 0x828babc8
	pc = 0x828BABC8; continue 'dispatch;
	// 828BABC0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BABC4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BABC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BABCC: 4199FFB8  bgt cr6, 0x828bab84
	if ctx.cr[6].gt {
	pc = 0x828BAB84; continue 'dispatch;
	}
	// 828BABD0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BABD4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BABD8: 419A0040  beq cr6, 0x828bac18
	if ctx.cr[6].eq {
	pc = 0x828BAC18; continue 'dispatch;
	}
	// 828BABDC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BABE0: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 828BABE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BABE8: 41990008  bgt cr6, 0x828babf0
	if ctx.cr[6].gt {
	pc = 0x828BABF0; continue 'dispatch;
	}
	// 828BABEC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BABF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BABF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BABF8: 409A0020  bne cr6, 0x828bac18
	if !ctx.cr[6].eq {
	pc = 0x828BAC18; continue 'dispatch;
	}
	// 828BABFC: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BAC00: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BAC04: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BAC08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAC0C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828BAC10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BAC14: 4800001C  b 0x828bac30
	pc = 0x828BAC30; continue 'dispatch;
	// 828BAC18: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BAC1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAC20: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828BAC24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BAC28: 48000008  b 0x828bac30
	pc = 0x828BAC30; continue 'dispatch;
	// 828BAC2C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BAC30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BAC34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BAC38: 419A01AC  beq cr6, 0x828bade4
	if ctx.cr[6].eq {
	pc = 0x828BADE4; continue 'dispatch;
	}
	// 828BAC3C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828BAC40: 4BA65F49  bl 0x82320b88
	ctx.lr = 0x828BAC44;
	sub_82320B88(ctx, base);
	// 828BAC44: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828BAC48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAC4C: 4BC43755  bl 0x824fe3a0
	ctx.lr = 0x828BAC50;
	sub_824FE3A0(ctx, base);
	// 828BAC50: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828BAC54: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAC58: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BAC5C: 419A0178  beq cr6, 0x828badd4
	if ctx.cr[6].eq {
	pc = 0x828BADD4; continue 'dispatch;
	}
	// 828BAC60: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BAC64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BAC68: 419A0018  beq cr6, 0x828bac80
	if ctx.cr[6].eq {
	pc = 0x828BAC80; continue 'dispatch;
	}
	// 828BAC6C: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BAC70: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BAC74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BAC78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BAC7C: 409A0008  bne cr6, 0x828bac84
	if !ctx.cr[6].eq {
	pc = 0x828BAC84; continue 'dispatch;
	}
	// 828BAC80: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BAC84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BAC88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BAC8C: 419A0130  beq cr6, 0x828badbc
	if ctx.cr[6].eq {
	pc = 0x828BADBC; continue 'dispatch;
	}
	// 828BAC90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAC94: 4BFFF4E5  bl 0x828ba178
	ctx.lr = 0x828BAC98;
	sub_828BA178(ctx, base);
	// 828BAC98: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BAC9C: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828BACA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BACA4: 419A00F0  beq cr6, 0x828bad94
	if ctx.cr[6].eq {
	pc = 0x828BAD94; continue 'dispatch;
	}
	// 828BACA8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BACAC: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BACB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BACB4: 419A0020  beq cr6, 0x828bacd4
	if ctx.cr[6].eq {
	pc = 0x828BACD4; continue 'dispatch;
	}
	// 828BACB8: 896B00E5  lbz r11, 0xe5(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(229 as u32) ) } as u64;
	// 828BACBC: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828BACC0: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BACC4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BACC8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828BACCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BACD0: 480000C8  b 0x828bad98
	pc = 0x828BAD98; continue 'dispatch;
	// 828BACD4: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BACD8: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 828BACDC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BACE0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BACE4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BACE8: 40810054  ble 0x828bad3c
	if !ctx.cr[0].gt {
	pc = 0x828BAD3C; continue 'dispatch;
	}
	// 828BACEC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BACF0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BACF4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828BACF8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BACFC: 2F0700E5  cmpwi cr6, r7, 0xe5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 229, &mut ctx.xer);
	// 828BAD00: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828BAD04: 41980008  blt cr6, 0x828bad0c
	if ctx.cr[6].lt {
	pc = 0x828BAD0C; continue 'dispatch;
	}
	// 828BAD08: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828BAD0C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BAD10: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BAD14: 419A0014  beq cr6, 0x828bad28
	if ctx.cr[6].eq {
	pc = 0x828BAD28; continue 'dispatch;
	}
	// 828BAD18: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BAD1C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BAD20: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BAD24: 4800000C  b 0x828bad30
	pc = 0x828BAD30; continue 'dispatch;
	// 828BAD28: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BAD2C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BAD30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BAD34: 4199FFB8  bgt cr6, 0x828bacec
	if ctx.cr[6].gt {
	pc = 0x828BACEC; continue 'dispatch;
	}
	// 828BAD38: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BAD3C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BAD40: 419A0040  beq cr6, 0x828bad80
	if ctx.cr[6].eq {
	pc = 0x828BAD80; continue 'dispatch;
	}
	// 828BAD44: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAD48: 2F0B00E5  cmpwi cr6, r11, 0xe5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 229, &mut ctx.xer);
	// 828BAD4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BAD50: 41990008  bgt cr6, 0x828bad58
	if ctx.cr[6].gt {
	pc = 0x828BAD58; continue 'dispatch;
	}
	// 828BAD54: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BAD58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BAD5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BAD60: 409A0020  bne cr6, 0x828bad80
	if !ctx.cr[6].eq {
	pc = 0x828BAD80; continue 'dispatch;
	}
	// 828BAD64: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BAD68: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 828BAD6C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828BAD70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAD74: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828BAD78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BAD7C: 4800001C  b 0x828bad98
	pc = 0x828BAD98; continue 'dispatch;
	// 828BAD80: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BAD84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAD88: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828BAD8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BAD90: 48000008  b 0x828bad98
	pc = 0x828BAD98; continue 'dispatch;
	// 828BAD94: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828BAD98: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BAD9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BADA0: 419A001C  beq cr6, 0x828badbc
	if ctx.cr[6].eq {
	pc = 0x828BADBC; continue 'dispatch;
	}
	// 828BADA4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828BADA8: 419A0014  beq cr6, 0x828badbc
	if ctx.cr[6].eq {
	pc = 0x828BADBC; continue 'dispatch;
	}
	// 828BADAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BADB0: C05C0010  lfs f2, 0x10(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828BADB4: C03C0014  lfs f1, 0x14(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BADB8: 4BFFED81  bl 0x828b9b38
	ctx.lr = 0x828BADBC;
	sub_828B9B38(ctx, base);
	// 828BADBC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828BADC0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BADC4: 409A0008  bne cr6, 0x828badcc
	if !ctx.cr[6].eq {
	pc = 0x828BADCC; continue 'dispatch;
	}
	// 828BADC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BADCC: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BADD0: 4BFFFE88  b 0x828bac58
	pc = 0x828BAC58; continue 'dispatch;
	// 828BADD4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828BADD8: 48159FB9  bl 0x82a14d90
	ctx.lr = 0x828BADDC;
	sub_82A14D90(ctx, base);
	// 828BADDC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828BADE0: 4B960F59  bl 0x8221bd38
	ctx.lr = 0x828BADE4;
	sub_8221BD38(ctx, base);
            }
            0x828BADE4 => {
    //   block [0x828BADE4..0x828BADF0)
	// 828BADE4: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 828BADE8: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 828BADEC: 483EE660  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BADF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BADF0 size=316
    let mut pc: u32 = 0x828BADF0;
    'dispatch: loop {
        match pc {
            0x828BADF0 => {
    //   block [0x828BADF0..0x828BAF2C)
	// 828BADF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BADF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BADF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BADFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BAE00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BAE04: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828BAE08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BAE0C: 3BCB2E50  addi r30, r11, 0x2e50
	ctx.r[30].s64 = ctx.r[11].s64 + 11856;
	// 828BAE10: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BAE14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAE18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BAE1C: 4B9720B5  bl 0x8222ced0
	ctx.lr = 0x828BAE20;
	sub_8222CED0(ctx, base);
	// 828BAE20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BAE24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAE28: 48000109  bl 0x828baf30
	ctx.lr = 0x828BAE2C;
	sub_828BAF30(ctx, base);
	// 828BAE2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAE30: 4B959FA9  bl 0x82214dd8
	ctx.lr = 0x828BAE34;
	sub_82214DD8(ctx, base);
	// 828BAE34: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828BAE38: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BAE3C: 388A3118  addi r4, r10, 0x3118
	ctx.r[4].s64 = ctx.r[10].s64 + 12568;
	// 828BAE40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAE44: 4B97208D  bl 0x8222ced0
	ctx.lr = 0x828BAE48;
	sub_8222CED0(ctx, base);
	// 828BAE48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BAE4C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BAE50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAE54: 4B97207D  bl 0x8222ced0
	ctx.lr = 0x828BAE58;
	sub_8222CED0(ctx, base);
	// 828BAE58: 3D20828A  lis r9, -0x7d76
	ctx.r[9].s64 = -2104885248;
	// 828BAE5C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828BAE60: 38C93120  addi r6, r9, 0x3120
	ctx.r[6].s64 = ctx.r[9].s64 + 12576;
	// 828BAE64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BAE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAE6C: 4800030D  bl 0x828bb178
	ctx.lr = 0x828BAE70;
	sub_828BB178(ctx, base);
	// 828BAE70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAE74: 4B959F65  bl 0x82214dd8
	ctx.lr = 0x828BAE78;
	sub_82214DD8(ctx, base);
	// 828BAE78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAE7C: 4B959F5D  bl 0x82214dd8
	ctx.lr = 0x828BAE80;
	sub_82214DD8(ctx, base);
	// 828BAE80: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828BAE84: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BAE88: 38882E60  addi r4, r8, 0x2e60
	ctx.r[4].s64 = ctx.r[8].s64 + 11872;
	// 828BAE8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAE90: 4B972041  bl 0x8222ced0
	ctx.lr = 0x828BAE94;
	sub_8222CED0(ctx, base);
	// 828BAE94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BAE98: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BAE9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAEA0: 4B972031  bl 0x8222ced0
	ctx.lr = 0x828BAEA4;
	sub_8222CED0(ctx, base);
	// 828BAEA4: 3CE08295  lis r7, -0x7d6b
	ctx.r[7].s64 = -2104164352;
	// 828BAEA8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828BAEAC: 38C795D0  addi r6, r7, -0x6a30
	ctx.r[6].s64 = ctx.r[7].s64 + -27184;
	// 828BAEB0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828BAEB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BAEB8: 480002C1  bl 0x828bb178
	ctx.lr = 0x828BAEBC;
	sub_828BB178(ctx, base);
	// 828BAEBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAEC0: 4B959F19  bl 0x82214dd8
	ctx.lr = 0x828BAEC4;
	sub_82214DD8(ctx, base);
	// 828BAEC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAEC8: 4B959F11  bl 0x82214dd8
	ctx.lr = 0x828BAECC;
	sub_82214DD8(ctx, base);
	// 828BAECC: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAED4: 80860000  lwz r4, 0(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAED8: 4BB136E9  bl 0x823ce5c0
	ctx.lr = 0x828BAEDC;
	sub_823CE5C0(ctx, base);
	// 828BAEDC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BAEE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BAEE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAEE8: 4BB13319  bl 0x823ce200
	ctx.lr = 0x828BAEEC;
	sub_823CE200(ctx, base);
	// 828BAEEC: 3CA0828C  lis r5, -0x7d74
	ctx.r[5].s64 = -2104754176;
	// 828BAEF0: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828BAEF4: 38A5A178  addi r5, r5, -0x5e88
	ctx.r[5].s64 = ctx.r[5].s64 + -24200;
	// 828BAEF8: 38842E68  addi r4, r4, 0x2e68
	ctx.r[4].s64 = ctx.r[4].s64 + 11880;
	// 828BAEFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAF00: 4BA4E511  bl 0x82309410
	ctx.lr = 0x828BAF04;
	sub_82309410(ctx, base);
	// 828BAF04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BAF08: 4B8FCC11  bl 0x821b7b18
	ctx.lr = 0x828BAF0C;
	sub_821B7B18(ctx, base);
	// 828BAF0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAF10: 4B8FCC09  bl 0x821b7b18
	ctx.lr = 0x828BAF14;
	sub_821B7B18(ctx, base);
	// 828BAF14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BAF18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BAF1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BAF20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BAF24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BAF28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BAF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BAF30 size=584
    let mut pc: u32 = 0x828BAF30;
    'dispatch: loop {
        match pc {
            0x828BAF30 => {
    //   block [0x828BAF30..0x828BAF58)
	// 828BAF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BAF34: 483EE4CD  bl 0x82ca9400
	ctx.lr = 0x828BAF38;
	sub_82CA93D0(ctx, base);
	// 828BAF38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BAF3C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAF40: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BAF44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BAF48: 409A0010  bne cr6, 0x828baf58
	if !ctx.cr[6].eq {
	pc = 0x828BAF58; continue 'dispatch;
	}
	// 828BAF4C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BAF50: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828BAF54: 48000008  b 0x828baf5c
	pc = 0x828BAF5C; continue 'dispatch;
            }
            0x828BAF58 => {
    //   block [0x828BAF58..0x828BAF5C)
	// 828BAF58: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828BAF5C; continue 'dispatch;
            }
            0x828BAF5C => {
    //   block [0x828BAF5C..0x828BAFD4)
	// 828BAF5C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAF60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BAF64: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAF68: 4BB13659  bl 0x823ce5c0
	ctx.lr = 0x828BAF6C;
	sub_823CE5C0(ctx, base);
	// 828BAF6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BAF70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BAF74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BAF78: 4BB13289  bl 0x823ce200
	ctx.lr = 0x828BAF7C;
	sub_823CE200(ctx, base);
	// 828BAF7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BAF80: 4B8FCB99  bl 0x821b7b18
	ctx.lr = 0x828BAF84;
	sub_821B7B18(ctx, base);
	// 828BAF84: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828BAF88: 4B9642D1  bl 0x8221f258
	ctx.lr = 0x828BAF8C;
	sub_8221F258(ctx, base);
	// 828BAF8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BAF90: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BAF94: 419A0040  beq cr6, 0x828bafd4
	if ctx.cr[6].eq {
	pc = 0x828BAFD4; continue 'dispatch;
	}
	// 828BAF98: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828BAF9C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828BAFA0: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828BAFA4: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828BAFA8: 4B9642B1  bl 0x8221f258
	ctx.lr = 0x828BAFAC;
	sub_8221F258(ctx, base);
	// 828BAFAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BAFB0: 419A0028  beq cr6, 0x828bafd8
	if ctx.cr[6].eq {
	pc = 0x828BAFD8; continue 'dispatch;
	}
	// 828BAFB4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828BAFB8: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828BAFBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BAFC0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828BAFC4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828BAFC8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BAFCC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828BAFD0: 4800000C  b 0x828bafdc
	pc = 0x828BAFDC; continue 'dispatch;
            }
            0x828BAFD4 => {
    //   block [0x828BAFD4..0x828BAFD8)
	// 828BAFD4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828BAFD8; continue 'dispatch;
            }
            0x828BAFD8 => {
    //   block [0x828BAFD8..0x828BAFDC)
	// 828BAFD8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828BAFDC; continue 'dispatch;
            }
            0x828BAFDC => {
    //   block [0x828BAFDC..0x828BB0E0)
	// 828BAFDC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BAFE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BAFE4: 419A00FC  beq cr6, 0x828bb0e0
	if ctx.cr[6].eq {
	pc = 0x828BB0E0; continue 'dispatch;
	}
	// 828BAFE8: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BAFEC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828BAFF0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BAFF4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828BAFF8: 4B96E111  bl 0x82229108
	ctx.lr = 0x828BAFFC;
	sub_82229108(ctx, base);
	// 828BAFFC: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828BB000: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828BB004: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828BB008: 3BCBB378  addi r30, r11, -0x4c88
	ctx.r[30].s64 = ctx.r[11].s64 + -19592;
	// 828BB00C: 4B96C875  bl 0x82227880
	ctx.lr = 0x828BB010;
	sub_82227880(ctx, base);
	// 828BB010: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BB014: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828BB018: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828BB01C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828BB020: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828BB024: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828BB028: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828BB02C: 4B8DFA55  bl 0x8219aa80
	ctx.lr = 0x828BB030;
	sub_8219AA80(ctx, base);
	// 828BB030: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828BB034: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828BB038: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828BB03C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB040: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BB044: 4BB133DD  bl 0x823ce420
	ctx.lr = 0x828BB048;
	sub_823CE420(ctx, base);
	// 828BB048: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BB04C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828BB050: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828BB054: 48169675  bl 0x82a246c8
	ctx.lr = 0x828BB058;
	sub_82A246C8(ctx, base);
	// 828BB058: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB05C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828BB060: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828BB064: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828BB068: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB06C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB070: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB074: 4B96E095  bl 0x82229108
	ctx.lr = 0x828BB078;
	sub_82229108(ctx, base);
	// 828BB078: 3D608230  lis r11, -0x7dd0
	ctx.r[11].s64 = -2110783488;
	// 828BB07C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828BB080: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB084: 3BEB2268  addi r31, r11, 0x2268
	ctx.r[31].s64 = ctx.r[11].s64 + 8808;
	// 828BB088: 4B96C7F9  bl 0x82227880
	ctx.lr = 0x828BB08C;
	sub_82227880(ctx, base);
	// 828BB08C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828BB090: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828BB094: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828BB098: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828BB09C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB0A0: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828BB0A4: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828BB0A8: 4B8DF9D9  bl 0x8219aa80
	ctx.lr = 0x828BB0AC;
	sub_8219AA80(ctx, base);
	// 828BB0AC: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828BB0B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BB0B4: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828BB0B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB0BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BB0C0: 4BB13361  bl 0x823ce420
	ctx.lr = 0x828BB0C4;
	sub_823CE420(ctx, base);
	// 828BB0C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BB0C8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828BB0CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB0D0: 481695F9  bl 0x82a246c8
	ctx.lr = 0x828BB0D4;
	sub_82A246C8(ctx, base);
	// 828BB0D4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB0D8: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828BB0DC: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x828BB0E0; continue 'dispatch;
            }
            0x828BB0E0 => {
    //   block [0x828BB0E0..0x828BB0F0)
	// 828BB0E0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828BB0E4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828BB0E8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828BB0EC: 419A0020  beq cr6, 0x828bb10c
	if ctx.cr[6].eq {
	pc = 0x828BB10C; continue 'dispatch;
	}
	pc = 0x828BB0F0; continue 'dispatch;
            }
            0x828BB0F0 => {
    //   block [0x828BB0F0..0x828BB10C)
	// 828BB0F0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BB0F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB0F8: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BB0FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828BB100: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BB104: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB108: 4082FFE8  bne 0x828bb0f0
	if !ctx.cr[0].eq {
	pc = 0x828BB0F0; continue 'dispatch;
	}
	pc = 0x828BB10C; continue 'dispatch;
            }
            0x828BB10C => {
    //   block [0x828BB10C..0x828BB12C)
	// 828BB10C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB110: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828BB114: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828BB118: 4BA3A831  bl 0x822f5948
	ctx.lr = 0x828BB11C;
	sub_822F5948(ctx, base);
	// 828BB11C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB120: 4B8FC9F9  bl 0x821b7b18
	ctx.lr = 0x828BB124;
	sub_821B7B18(ctx, base);
	// 828BB124: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828BB128: 419A0040  beq cr6, 0x828bb168
	if ctx.cr[6].eq {
	pc = 0x828BB168; continue 'dispatch;
	}
	pc = 0x828BB12C; continue 'dispatch;
            }
            0x828BB12C => {
    //   block [0x828BB12C..0x828BB168)
	// 828BB12C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BB130: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB134: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BB138: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BB13C: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BB140: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB144: 4082FFE8  bne 0x828bb12c
	if !ctx.cr[0].eq {
	pc = 0x828BB12C; continue 'dispatch;
	}
	// 828BB148: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB14C: 409A001C  bne cr6, 0x828bb168
	if !ctx.cr[6].eq {
	pc = 0x828BB168; continue 'dispatch;
	}
	// 828BB150: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB154: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB158: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BB15C: 4E800421  bctrl
	ctx.lr = 0x828BB160;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BB160: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BB164: 4B960BD5  bl 0x8221bd38
	ctx.lr = 0x828BB168;
	sub_8221BD38(ctx, base);
            }
            0x828BB168 => {
    //   block [0x828BB168..0x828BB178)
	// 828BB168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB16C: 4B8FC9AD  bl 0x821b7b18
	ctx.lr = 0x828BB170;
	sub_821B7B18(ctx, base);
	// 828BB170: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BB174: 483EE2DC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BB178 size=512
    let mut pc: u32 = 0x828BB178;
    'dispatch: loop {
        match pc {
            0x828BB178 => {
    //   block [0x828BB178..0x828BB1B0)
	// 828BB178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB17C: 483EE281  bl 0x82ca93fc
	ctx.lr = 0x828BB180;
	sub_82CA93D0(ctx, base);
	// 828BB180: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB184: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BB188: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828BB18C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828BB190: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828BB194: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828BB198: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB19C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828BB1A0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828BB1A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB1A8: 419A0008  beq cr6, 0x828bb1b0
	if ctx.cr[6].eq {
	pc = 0x828BB1B0; continue 'dispatch;
	}
	// 828BB1AC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828BB1B0; continue 'dispatch;
            }
            0x828BB1B0 => {
    //   block [0x828BB1B0..0x828BB244)
	// 828BB1B0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB1B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BB1B8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB1BC: 4BB13405  bl 0x823ce5c0
	ctx.lr = 0x828BB1C0;
	sub_823CE5C0(ctx, base);
	// 828BB1C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BB1C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB1C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BB1CC: 4BB12F45  bl 0x823ce110
	ctx.lr = 0x828BB1D0;
	sub_823CE110(ctx, base);
	// 828BB1D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BB1D4: 4B8FC945  bl 0x821b7b18
	ctx.lr = 0x828BB1D8;
	sub_821B7B18(ctx, base);
	// 828BB1D8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828BB1DC: 4B96407D  bl 0x8221f258
	ctx.lr = 0x828BB1E0;
	sub_8221F258(ctx, base);
	// 828BB1E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BB1E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BB1E8: 419A005C  beq cr6, 0x828bb244
	if ctx.cr[6].eq {
	pc = 0x828BB244; continue 'dispatch;
	}
	// 828BB1EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828BB1F0: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828BB1F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828BB1F8: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828BB1FC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828BB200: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BB204: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BB208: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828BB20C: 4B935035  bl 0x821f0240
	ctx.lr = 0x828BB210;
	sub_821F0240(ctx, base);
	// 828BB210: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828BB214: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828BB218: 4B964041  bl 0x8221f258
	ctx.lr = 0x828BB21C;
	sub_8221F258(ctx, base);
	// 828BB21C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BB220: 419A0028  beq cr6, 0x828bb248
	if ctx.cr[6].eq {
	pc = 0x828BB248; continue 'dispatch;
	}
	// 828BB224: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828BB228: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828BB22C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BB230: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828BB234: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828BB238: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BB23C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828BB240: 4800000C  b 0x828bb24c
	pc = 0x828BB24C; continue 'dispatch;
            }
            0x828BB244 => {
    //   block [0x828BB244..0x828BB248)
	// 828BB244: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828BB248; continue 'dispatch;
            }
            0x828BB248 => {
    //   block [0x828BB248..0x828BB24C)
	// 828BB248: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828BB24C; continue 'dispatch;
            }
            0x828BB24C => {
    //   block [0x828BB24C..0x828BB260)
	// 828BB24C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB250: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828BB254: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB258: 419A0008  beq cr6, 0x828bb260
	if ctx.cr[6].eq {
	pc = 0x828BB260; continue 'dispatch;
	}
	// 828BB25C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828BB260; continue 'dispatch;
            }
            0x828BB260 => {
    //   block [0x828BB260..0x828BB2E0)
	// 828BB260: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BB264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB268: 419A0078  beq cr6, 0x828bb2e0
	if ctx.cr[6].eq {
	pc = 0x828BB2E0; continue 'dispatch;
	}
	// 828BB26C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB270: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828BB274: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB278: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BB27C: 4B96DE8D  bl 0x82229108
	ctx.lr = 0x828BB280;
	sub_82229108(ctx, base);
	// 828BB280: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828BB284: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828BB288: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BB28C: 3BCBB3B8  addi r30, r11, -0x4c48
	ctx.r[30].s64 = ctx.r[11].s64 + -19528;
	// 828BB290: 4B96C5F1  bl 0x82227880
	ctx.lr = 0x828BB294;
	sub_82227880(ctx, base);
	// 828BB294: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BB298: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828BB29C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828BB2A0: 388A8370  addi r4, r10, -0x7c90
	ctx.r[4].s64 = ctx.r[10].s64 + -31888;
	// 828BB2A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BB2A8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828BB2AC: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828BB2B0: 4B8DF7D1  bl 0x8219aa80
	ctx.lr = 0x828BB2B4;
	sub_8219AA80(ctx, base);
	// 828BB2B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BB2B8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828BB2BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB2C0: 4BB13161  bl 0x823ce420
	ctx.lr = 0x828BB2C4;
	sub_823CE420(ctx, base);
	// 828BB2C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BB2C8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828BB2CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BB2D0: 481693F9  bl 0x82a246c8
	ctx.lr = 0x828BB2D4;
	sub_82A246C8(ctx, base);
	// 828BB2D4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB2D8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828BB2DC: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828BB2E0; continue 'dispatch;
            }
            0x828BB2E0 => {
    //   block [0x828BB2E0..0x828BB2F0)
	// 828BB2E0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828BB2E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BB2E8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828BB2EC: 419A0020  beq cr6, 0x828bb30c
	if ctx.cr[6].eq {
	pc = 0x828BB30C; continue 'dispatch;
	}
	pc = 0x828BB2F0; continue 'dispatch;
            }
            0x828BB2F0 => {
    //   block [0x828BB2F0..0x828BB30C)
	// 828BB2F0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BB2F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB2F8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BB2FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828BB300: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BB304: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB308: 4082FFE8  bne 0x828bb2f0
	if !ctx.cr[0].eq {
	pc = 0x828BB2F0; continue 'dispatch;
	}
	pc = 0x828BB30C; continue 'dispatch;
            }
            0x828BB30C => {
    //   block [0x828BB30C..0x828BB32C)
	// 828BB30C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB310: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BB314: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828BB318: 4BA3A631  bl 0x822f5948
	ctx.lr = 0x828BB31C;
	sub_822F5948(ctx, base);
	// 828BB31C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB320: 4B8FC7F9  bl 0x821b7b18
	ctx.lr = 0x828BB324;
	sub_821B7B18(ctx, base);
	// 828BB324: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BB328: 419A0040  beq cr6, 0x828bb368
	if ctx.cr[6].eq {
	pc = 0x828BB368; continue 'dispatch;
	}
	pc = 0x828BB32C; continue 'dispatch;
            }
            0x828BB32C => {
    //   block [0x828BB32C..0x828BB368)
	// 828BB32C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BB330: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB334: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BB338: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BB33C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BB340: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB344: 4082FFE8  bne 0x828bb32c
	if !ctx.cr[0].eq {
	pc = 0x828BB32C; continue 'dispatch;
	}
	// 828BB348: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB34C: 409A001C  bne cr6, 0x828bb368
	if !ctx.cr[6].eq {
	pc = 0x828BB368; continue 'dispatch;
	}
	// 828BB350: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB354: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB358: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828BB35C: 4E800421  bctrl
	ctx.lr = 0x828BB360;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BB360: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BB364: 4B9609D5  bl 0x8221bd38
	ctx.lr = 0x828BB368;
	sub_8221BD38(ctx, base);
            }
            0x828BB368 => {
    //   block [0x828BB368..0x828BB378)
	// 828BB368: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB36C: 4B8FC7AD  bl 0x821b7b18
	ctx.lr = 0x828BB370;
	sub_821B7B18(ctx, base);
	// 828BB370: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BB374: 483EE0D8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BB378 size=56
    let mut pc: u32 = 0x828BB378;
    'dispatch: loop {
        match pc {
            0x828BB378 => {
    //   block [0x828BB378..0x828BB394)
	// 828BB378: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828BB37C: 419A0018  beq cr6, 0x828bb394
	if ctx.cr[6].eq {
	pc = 0x828BB394; continue 'dispatch;
	}
	// 828BB380: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BB384: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BB388: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BB38C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BB390: 409A0008  bne cr6, 0x828bb398
	if !ctx.cr[6].eq {
	pc = 0x828BB398; continue 'dispatch;
	}
	pc = 0x828BB394; continue 'dispatch;
            }
            0x828BB394 => {
    //   block [0x828BB394..0x828BB398)
	// 828BB394: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828BB398; continue 'dispatch;
            }
            0x828BB398 => {
    //   block [0x828BB398..0x828BB3B0)
	// 828BB398: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BB39C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB3A0: 419A0010  beq cr6, 0x828bb3b0
	if ctx.cr[6].eq {
		sub_828BB3B0(ctx, base);
		return;
	}
	// 828BB3A4: 81640040  lwz r11, 0x40(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BB3A8: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828BB3AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BB3B0 size=8
    let mut pc: u32 = 0x828BB3B0;
    'dispatch: loop {
        match pc {
            0x828BB3B0 => {
    //   block [0x828BB3B0..0x828BB3B8)
	// 828BB3B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BB3B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BB3B8 size=380
    let mut pc: u32 = 0x828BB3B8;
    'dispatch: loop {
        match pc {
            0x828BB3B8 => {
    //   block [0x828BB3B8..0x828BB3E0)
	// 828BB3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB3BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BB3C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB3C4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828BB3C8: 419A0018  beq cr6, 0x828bb3e0
	if ctx.cr[6].eq {
	pc = 0x828BB3E0; continue 'dispatch;
	}
	// 828BB3CC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BB3D0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BB3D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BB3D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BB3DC: 409A0008  bne cr6, 0x828bb3e4
	if !ctx.cr[6].eq {
	pc = 0x828BB3E4; continue 'dispatch;
	}
	pc = 0x828BB3E0; continue 'dispatch;
            }
            0x828BB3E0 => {
    //   block [0x828BB3E0..0x828BB3E4)
	// 828BB3E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828BB3E4; continue 'dispatch;
            }
            0x828BB3E4 => {
    //   block [0x828BB3E4..0x828BB42C)
	// 828BB3E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BB3E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB3EC: 419A0130  beq cr6, 0x828bb51c
	if ctx.cr[6].eq {
	pc = 0x828BB51C; continue 'dispatch;
	}
	// 828BB3F0: 81440040  lwz r10, 0x40(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BB3F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BB3F8: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828BB3FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BB400: 419A00EC  beq cr6, 0x828bb4ec
	if ctx.cr[6].eq {
	pc = 0x828BB4EC; continue 'dispatch;
	}
	// 828BB404: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BB408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB40C: 419A0020  beq cr6, 0x828bb42c
	if ctx.cr[6].eq {
	pc = 0x828BB42C; continue 'dispatch;
	}
	// 828BB410: 894B00E5  lbz r10, 0xe5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(229 as u32) ) } as u64;
	// 828BB414: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BB418: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828BB41C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BB420: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BB424: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB428: 480000C8  b 0x828bb4f0
	pc = 0x828BB4F0; continue 'dispatch;
            }
            0x828BB42C => {
    //   block [0x828BB42C..0x828BB44C)
	// 828BB42C: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BB430: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828BB434: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BB438: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BB43C: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BB440: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828BB444: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB448: 40810054  ble 0x828bb49c
	if !ctx.cr[0].gt {
	pc = 0x828BB49C; continue 'dispatch;
	}
	pc = 0x828BB44C; continue 'dispatch;
            }
            0x828BB44C => {
    //   block [0x828BB44C..0x828BB46C)
	// 828BB44C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BB450: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BB454: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828BB458: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB45C: 2F0700E5  cmpwi cr6, r7, 0xe5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 229, &mut ctx.xer);
	// 828BB460: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828BB464: 41980008  blt cr6, 0x828bb46c
	if ctx.cr[6].lt {
	pc = 0x828BB46C; continue 'dispatch;
	}
	// 828BB468: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828BB46C; continue 'dispatch;
            }
            0x828BB46C => {
    //   block [0x828BB46C..0x828BB488)
	// 828BB46C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BB470: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BB474: 419A0014  beq cr6, 0x828bb488
	if ctx.cr[6].eq {
	pc = 0x828BB488; continue 'dispatch;
	}
	// 828BB478: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BB47C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BB480: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BB484: 4800000C  b 0x828bb490
	pc = 0x828BB490; continue 'dispatch;
            }
            0x828BB488 => {
    //   block [0x828BB488..0x828BB490)
	// 828BB488: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BB48C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828BB490; continue 'dispatch;
            }
            0x828BB490 => {
    //   block [0x828BB490..0x828BB49C)
	// 828BB490: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB494: 4199FFB8  bgt cr6, 0x828bb44c
	if ctx.cr[6].gt {
	pc = 0x828BB44C; continue 'dispatch;
	}
	// 828BB498: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828BB49C; continue 'dispatch;
            }
            0x828BB49C => {
    //   block [0x828BB49C..0x828BB4B8)
	// 828BB49C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BB4A0: 419A003C  beq cr6, 0x828bb4dc
	if ctx.cr[6].eq {
	pc = 0x828BB4DC; continue 'dispatch;
	}
	// 828BB4A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB4A8: 2F0B00E5  cmpwi cr6, r11, 0xe5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 229, &mut ctx.xer);
	// 828BB4AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BB4B0: 41990008  bgt cr6, 0x828bb4b8
	if ctx.cr[6].gt {
	pc = 0x828BB4B8; continue 'dispatch;
	}
	// 828BB4B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828BB4B8; continue 'dispatch;
            }
            0x828BB4B8 => {
    //   block [0x828BB4B8..0x828BB4DC)
	// 828BB4B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BB4BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB4C0: 409A001C  bne cr6, 0x828bb4dc
	if !ctx.cr[6].eq {
	pc = 0x828BB4DC; continue 'dispatch;
	}
	// 828BB4C4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BB4C8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BB4CC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828BB4D0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BB4D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB4D8: 48000018  b 0x828bb4f0
	pc = 0x828BB4F0; continue 'dispatch;
            }
            0x828BB4DC => {
    //   block [0x828BB4DC..0x828BB4EC)
	// 828BB4DC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BB4E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BB4E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB4E8: 48000008  b 0x828bb4f0
	pc = 0x828BB4F0; continue 'dispatch;
            }
            0x828BB4EC => {
    //   block [0x828BB4EC..0x828BB4F0)
	// 828BB4EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828BB4F0; continue 'dispatch;
            }
            0x828BB4F0 => {
    //   block [0x828BB4F0..0x828BB51C)
	// 828BB4F0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828BB4F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BB4F8: 419A0024  beq cr6, 0x828bb51c
	if ctx.cr[6].eq {
	pc = 0x828BB51C; continue 'dispatch;
	}
	// 828BB4FC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB500: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828BB504: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BB508: 4E800421  bctrl
	ctx.lr = 0x828BB50C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BB50C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BB510: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BB514: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BB518: 4E800020  blr
	return;
            }
            0x828BB51C => {
    //   block [0x828BB51C..0x828BB534)
	// 828BB51C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828BB520: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BB524: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BB528: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BB52C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BB530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BB538 size=80
    let mut pc: u32 = 0x828BB538;
    'dispatch: loop {
        match pc {
            0x828BB538 => {
    //   block [0x828BB538..0x828BB570)
	// 828BB538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB53C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BB540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BB544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BB548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB54C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BB550: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BB554: 48000035  bl 0x828bb588
	ctx.lr = 0x828BB558;
	sub_828BB588(ctx, base);
	// 828BB558: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828BB55C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB560: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BB564: 419A000C  beq cr6, 0x828bb570
	if ctx.cr[6].eq {
	pc = 0x828BB570; continue 'dispatch;
	}
	// 828BB568: 4B9607D1  bl 0x8221bd38
	ctx.lr = 0x828BB56C;
	sub_8221BD38(ctx, base);
	// 828BB56C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x828BB570; continue 'dispatch;
            }
            0x828BB570 => {
    //   block [0x828BB570..0x828BB588)
	// 828BB570: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BB574: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BB578: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BB57C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BB580: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BB584: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BB588 size=272
    let mut pc: u32 = 0x828BB588;
    'dispatch: loop {
        match pc {
            0x828BB588 => {
    //   block [0x828BB588..0x828BB5C4)
	// 828BB588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB58C: 483EDE81  bl 0x82ca940c
	ctx.lr = 0x828BB590;
	sub_82CA93D0(ctx, base);
	// 828BB590: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB594: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BB598: 387E003C  addi r3, r30, 0x3c
	ctx.r[3].s64 = ctx.r[30].s64 + 60;
	// 828BB59C: 4BDB52ED  bl 0x82670888
	ctx.lr = 0x828BB5A0;
	sub_82670888(ctx, base);
	// 828BB5A0: 809E002C  lwz r4, 0x2c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 828BB5A4: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 828BB5A8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828BB5AC: 419A0018  beq cr6, 0x828bb5c4
	if ctx.cr[6].eq {
	pc = 0x828BB5C4; continue 'dispatch;
	}
	// 828BB5B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB5B4: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB5B8: 48000F09  bl 0x828bc4c0
	ctx.lr = 0x828BB5BC;
	sub_828BC4C0(ctx, base);
	// 828BB5BC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB5C0: 4B960779  bl 0x8221bd38
	ctx.lr = 0x828BB5C4;
	sub_8221BD38(ctx, base);
	pc = 0x828BB5C4; continue 'dispatch;
            }
            0x828BB5C4 => {
    //   block [0x828BB5C4..0x828BB5E4)
	// 828BB5C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828BB5C8: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828BB5CC: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828BB5D0: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 828BB5D4: 807E0020  lwz r3, 0x20(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 828BB5D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BB5DC: 419A0040  beq cr6, 0x828bb61c
	if ctx.cr[6].eq {
	pc = 0x828BB61C; continue 'dispatch;
	}
	// 828BB5E0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x828BB5E4; continue 'dispatch;
            }
            0x828BB5E4 => {
    //   block [0x828BB5E4..0x828BB618)
	// 828BB5E4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BB5E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB5EC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BB5F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BB5F4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BB5F8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB5FC: 4082FFE8  bne 0x828bb5e4
	if !ctx.cr[0].eq {
	pc = 0x828BB5E4; continue 'dispatch;
	}
	// 828BB600: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB604: 409A0014  bne cr6, 0x828bb618
	if !ctx.cr[6].eq {
	pc = 0x828BB618; continue 'dispatch;
	}
	// 828BB608: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB60C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB610: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BB614: 4E800421  bctrl
	ctx.lr = 0x828BB618;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828BB618 => {
    //   block [0x828BB618..0x828BB61C)
	// 828BB618: 93BE0020  stw r29, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	pc = 0x828BB61C; continue 'dispatch;
            }
            0x828BB61C => {
    //   block [0x828BB61C..0x828BB62C)
	// 828BB61C: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828BB620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BB624: 419A0040  beq cr6, 0x828bb664
	if ctx.cr[6].eq {
	pc = 0x828BB664; continue 'dispatch;
	}
	// 828BB628: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x828BB62C; continue 'dispatch;
            }
            0x828BB62C => {
    //   block [0x828BB62C..0x828BB660)
	// 828BB62C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BB630: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB634: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BB638: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BB63C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BB640: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB644: 4082FFE8  bne 0x828bb62c
	if !ctx.cr[0].eq {
	pc = 0x828BB62C; continue 'dispatch;
	}
	// 828BB648: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB64C: 409A0014  bne cr6, 0x828bb660
	if !ctx.cr[6].eq {
	pc = 0x828BB660; continue 'dispatch;
	}
	// 828BB650: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB654: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB658: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BB65C: 4E800421  bctrl
	ctx.lr = 0x828BB660;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828BB660 => {
    //   block [0x828BB660..0x828BB664)
	// 828BB660: 93BE001C  stw r29, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	pc = 0x828BB664; continue 'dispatch;
            }
            0x828BB664 => {
    //   block [0x828BB664..0x828BB684)
	// 828BB664: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828BB668: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BB66C: 394B2B98  addi r10, r11, 0x2b98
	ctx.r[10].s64 = ctx.r[11].s64 + 11160;
	// 828BB670: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BB674: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828BB678: 419A000C  beq cr6, 0x828bb684
	if ctx.cr[6].eq {
	pc = 0x828BB684; continue 'dispatch;
	}
	// 828BB67C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BB680: 48168199  bl 0x82a23818
	ctx.lr = 0x828BB684;
	sub_82A23818(ctx, base);
	pc = 0x828BB684; continue 'dispatch;
            }
            0x828BB684 => {
    //   block [0x828BB684..0x828BB698)
	// 828BB684: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828BB688: 394B0FD0  addi r10, r11, 0xfd0
	ctx.r[10].s64 = ctx.r[11].s64 + 4048;
	// 828BB68C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828BB690: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BB694: 483EDDC8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BB698 size=328
    let mut pc: u32 = 0x828BB698;
    'dispatch: loop {
        match pc {
            0x828BB698 => {
    //   block [0x828BB698..0x828BB714)
	// 828BB698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB69C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BB6A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BB6A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BB6A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB6AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BB6B0: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 828BB6B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB6B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BB6BC: 48165C75  bl 0x82a21330
	ctx.lr = 0x828BB6C0;
	sub_82A21330(ctx, base);
	// 828BB6C0: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BB6C4: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 828BB6C8: 4198004C  blt cr6, 0x828bb714
	if ctx.cr[6].lt {
	pc = 0x828BB714; continue 'dispatch;
	}
	// 828BB6CC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BB6D0: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 828BB6D4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB6D8: 38EAFFFC  addi r7, r10, -4
	ctx.r[7].s64 = ctx.r[10].s64 + -4;
	// 828BB6DC: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 828BB6E0: 38A90004  addi r5, r9, 4
	ctx.r[5].s64 = ctx.r[9].s64 + 4;
	// 828BB6E4: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB6E8: 98880000  stb r4, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 828BB6EC: 886B0001  lbz r3, 1(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 828BB6F0: 98680001  stb r3, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[3].u8 ) };
	// 828BB6F4: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 828BB6F8: 99480002  stb r10, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 828BB6FC: 892B0003  lbz r9, 3(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828BB700: 99280003  stb r9, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[9].u8 ) };
	// 828BB704: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 828BB708: 90FF0014  stw r7, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 828BB70C: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 828BB710: 48000014  b 0x828bb724
	pc = 0x828BB724; continue 'dispatch;
            }
            0x828BB714 => {
    //   block [0x828BB714..0x828BB724)
	// 828BB714: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828BB718: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828BB71C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB720: 481657C9  bl 0x82a20ee8
	ctx.lr = 0x828BB724;
	sub_82A20EE8(ctx, base);
	pc = 0x828BB724; continue 'dispatch;
            }
            0x828BB724 => {
    //   block [0x828BB724..0x828BB758)
	// 828BB724: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BB728: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828BB72C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BB730: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BB734: 419A0024  beq cr6, 0x828bb758
	if ctx.cr[6].eq {
	pc = 0x828BB758; continue 'dispatch;
	}
	// 828BB738: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828BB73C: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 828BB740: 89210057  lbz r9, 0x57(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 828BB744: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BB748: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 828BB74C: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 828BB750: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 828BB754: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x828BB758; continue 'dispatch;
            }
            0x828BB758 => {
    //   block [0x828BB758..0x828BB774)
	// 828BB758: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828BB75C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB760: 388B2EB8  addi r4, r11, 0x2eb8
	ctx.r[4].s64 = ctx.r[11].s64 + 11960;
	// 828BB764: 4B9DFA55  bl 0x8229b1b8
	ctx.lr = 0x828BB768;
	sub_8229B1B8(ctx, base);
	// 828BB768: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BB76C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BB770: 419A0014  beq cr6, 0x828bb784
	if ctx.cr[6].eq {
	pc = 0x828BB784; continue 'dispatch;
	}
	pc = 0x828BB774; continue 'dispatch;
            }
            0x828BB774 => {
    //   block [0x828BB774..0x828BB784)
	// 828BB774: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB778: 4B959661  bl 0x82214dd8
	ctx.lr = 0x828BB77C;
	sub_82214DD8(ctx, base);
	// 828BB77C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BB780: 48000048  b 0x828bb7c8
	pc = 0x828BB7C8; continue 'dispatch;
            }
            0x828BB784 => {
    //   block [0x828BB784..0x828BB7C8)
	// 828BB784: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BB788: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828BB78C: 409AFFE8  bne cr6, 0x828bb774
	if !ctx.cr[6].eq {
	pc = 0x828BB774; continue 'dispatch;
	}
	// 828BB790: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BB794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB798: 48000049  bl 0x828bb7e0
	ctx.lr = 0x828BB79C;
	sub_828BB7E0(ctx, base);
	// 828BB79C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BB7A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB7A4: 48000255  bl 0x828bb9f8
	ctx.lr = 0x828BB7A8;
	sub_828BB9F8(ctx, base);
	// 828BB7A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BB7AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB7B0: 480005A1  bl 0x828bbd50
	ctx.lr = 0x828BB7B4;
	sub_828BBD50(ctx, base);
	// 828BB7B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BB7B8: 480008E9  bl 0x828bc0a0
	ctx.lr = 0x828BB7BC;
	sub_828BC0A0(ctx, base);
	// 828BB7BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BB7C0: 4B959619  bl 0x82214dd8
	ctx.lr = 0x828BB7C4;
	sub_82214DD8(ctx, base);
	// 828BB7C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x828BB7C8; continue 'dispatch;
            }
            0x828BB7C8 => {
    //   block [0x828BB7C8..0x828BB7E0)
	// 828BB7C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BB7CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BB7D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BB7D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BB7D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BB7DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BB7E0 size=284
    let mut pc: u32 = 0x828BB7E0;
    'dispatch: loop {
        match pc {
            0x828BB7E0 => {
    //   block [0x828BB7E0..0x828BB89C)
	// 828BB7E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB7E4: 483EDC29  bl 0x82ca940c
	ctx.lr = 0x828BB7E8;
	sub_82CA93D0(ctx, base);
	// 828BB7E8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB7EC: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 828BB7F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828BB7F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828BB7F8: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 828BB7FC: 39210068  addi r9, r1, 0x68
	ctx.r[9].s64 = ctx.r[1].s64 + 104;
	// 828BB800: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828BB804: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 828BB808: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 828BB80C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BB810: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828BB814: 38E838C0  addi r7, r8, 0x38c0
	ctx.r[7].s64 = ctx.r[8].s64 + 14528;
	// 828BB818: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828BB81C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB820: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828BB824: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828BB828: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828BB82C: 93E90000  stw r31, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828BB830: 93E90004  stw r31, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828BB834: 93E90008  stw r31, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828BB838: 93E9000C  stw r31, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828BB83C: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828BB840: 93E100E0  stw r31, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[31].u32 ) };
	// 828BB844: 93E100E4  stw r31, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[31].u32 ) };
	// 828BB848: 93E100E8  stw r31, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[31].u32 ) };
	// 828BB84C: 9BE10088  stb r31, 0x88(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u8 ) };
	// 828BB850: 9BE10089  stb r31, 0x89(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(137 as u32), ctx.r[31].u8 ) };
	// 828BB854: 9BE1008A  stb r31, 0x8a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(138 as u32), ctx.r[31].u8 ) };
	// 828BB858: 9BE100B8  stb r31, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u8 ) };
	// 828BB85C: 9BE100B9  stb r31, 0xb9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(185 as u32), ctx.r[31].u8 ) };
	// 828BB860: 482BF269  bl 0x82b7aac8
	ctx.lr = 0x828BB864;
	sub_82B7AAC8(ctx, base);
	// 828BB864: 80C10080  lwz r6, 0x80(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BB868: 80A1007C  lwz r5, 0x7c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828BB86C: 7C853050  subf r4, r5, r6
	ctx.r[4].s64 = ctx.r[6].s64 - ctx.r[5].s64;
	// 828BB870: 54830038  rlwinm r3, r4, 0, 0, 0x1c
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 828BB874: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 828BB878: 40990074  ble cr6, 0x828bb8ec
	if !ctx.cr[6].gt {
	pc = 0x828BB8EC; continue 'dispatch;
	}
	// 828BB87C: 3860009C  li r3, 0x9c
	ctx.r[3].s64 = 156;
	// 828BB880: 4B9639D9  bl 0x8221f258
	ctx.lr = 0x828BB884;
	sub_8221F258(ctx, base);
	// 828BB884: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BB888: 419A0014  beq cr6, 0x828bb89c
	if ctx.cr[6].eq {
	pc = 0x828BB89C; continue 'dispatch;
	}
	// 828BB88C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BB890: 48000071  bl 0x828bb900
	ctx.lr = 0x828BB894;
	sub_828BB900(ctx, base);
	// 828BB894: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BB898: 48000008  b 0x828bb8a0
	pc = 0x828BB8A0; continue 'dispatch;
            }
            0x828BB89C => {
    //   block [0x828BB89C..0x828BB8A0)
	// 828BB89C: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	pc = 0x828BB8A0; continue 'dispatch;
            }
            0x828BB8A0 => {
    //   block [0x828BB8A0..0x828BB8B0)
	// 828BB8A0: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828BB8A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BB8A8: 419A0040  beq cr6, 0x828bb8e8
	if ctx.cr[6].eq {
	pc = 0x828BB8E8; continue 'dispatch;
	}
	// 828BB8AC: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x828BB8B0; continue 'dispatch;
            }
            0x828BB8B0 => {
    //   block [0x828BB8B0..0x828BB8E4)
	// 828BB8B0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BB8B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB8B8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BB8BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BB8C0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BB8C4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BB8C8: 4082FFE8  bne 0x828bb8b0
	if !ctx.cr[0].eq {
	pc = 0x828BB8B0; continue 'dispatch;
	}
	// 828BB8CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BB8D0: 409A0014  bne cr6, 0x828bb8e4
	if !ctx.cr[6].eq {
	pc = 0x828BB8E4; continue 'dispatch;
	}
	// 828BB8D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB8D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BB8DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BB8E0: 4E800421  bctrl
	ctx.lr = 0x828BB8E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828BB8E4 => {
    //   block [0x828BB8E4..0x828BB8E8)
	// 828BB8E4: 93FE001C  stw r31, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	pc = 0x828BB8E8; continue 'dispatch;
            }
            0x828BB8E8 => {
    //   block [0x828BB8E8..0x828BB8EC)
	// 828BB8E8: 93BE001C  stw r29, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	pc = 0x828BB8EC; continue 'dispatch;
            }
            0x828BB8EC => {
    //   block [0x828BB8EC..0x828BB8FC)
	// 828BB8EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BB8F0: 4BCC0C11  bl 0x8257c500
	ctx.lr = 0x828BB8F4;
	sub_8257C500(ctx, base);
	// 828BB8F4: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828BB8F8: 483EDB64  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BB900 size=248
    let mut pc: u32 = 0x828BB900;
    'dispatch: loop {
        match pc {
            0x828BB900 => {
    //   block [0x828BB900..0x828BB954)
	// 828BB900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BB908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BB90C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BB910: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BB914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BB918: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BB91C: 4BCA81B5  bl 0x82563ad0
	ctx.lr = 0x828BB920;
	sub_82563AD0(ctx, base);
	// 828BB920: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828BB924: 395F003C  addi r10, r31, 0x3c
	ctx.r[10].s64 = ctx.r[31].s64 + 60;
	// 828BB928: 392B38C0  addi r9, r11, 0x38c0
	ctx.r[9].s64 = ctx.r[11].s64 + 14528;
	// 828BB92C: 397E003C  addi r11, r30, 0x3c
	ctx.r[11].s64 = ctx.r[30].s64 + 60;
	// 828BB930: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BB934: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 828BB938: 891E0038  lbz r8, 0x38(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 828BB93C: 991F0038  stb r8, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 828BB940: 88FE0039  lbz r7, 0x39(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(57 as u32) ) } as u64;
	// 828BB944: 98FF0039  stb r7, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[7].u8 ) };
	// 828BB948: 88DE003A  lbz r6, 0x3a(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(58 as u32) ) } as u64;
	// 828BB94C: 98DF003A  stb r6, 0x3a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(58 as u32), ctx.r[6].u8 ) };
	// 828BB950: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x828BB954; continue 'dispatch;
            }
            0x828BB954 => {
    //   block [0x828BB954..0x828BB978)
	// 828BB954: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB958: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BB95C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BB960: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828BB964: 4200FFF0  bdnz 0x828bb954
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BB954; continue 'dispatch;
	}
	// 828BB968: 395F0050  addi r10, r31, 0x50
	ctx.r[10].s64 = ctx.r[31].s64 + 80;
	// 828BB96C: 397E0050  addi r11, r30, 0x50
	ctx.r[11].s64 = ctx.r[30].s64 + 80;
	// 828BB970: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 828BB974: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x828BB978; continue 'dispatch;
            }
            0x828BB978 => {
    //   block [0x828BB978..0x828BB9BC)
	// 828BB978: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB97C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BB980: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BB984: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828BB988: 4200FFF0  bdnz 0x828bb978
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BB978; continue 'dispatch;
	}
	// 828BB98C: 891E0068  lbz r8, 0x68(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 828BB990: 395F0074  addi r10, r31, 0x74
	ctx.r[10].s64 = ctx.r[31].s64 + 116;
	// 828BB994: 397E0074  addi r11, r30, 0x74
	ctx.r[11].s64 = ctx.r[30].s64 + 116;
	// 828BB998: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 828BB99C: 991F0068  stb r8, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[8].u8 ) };
	// 828BB9A0: 88FE0069  lbz r7, 0x69(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(105 as u32) ) } as u64;
	// 828BB9A4: 98FF0069  stb r7, 0x69(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(105 as u32), ctx.r[7].u8 ) };
	// 828BB9A8: 80DE006C  lwz r6, 0x6c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 828BB9AC: 90DF006C  stw r6, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[6].u32 ) };
	// 828BB9B0: 80BE0070  lwz r5, 0x70(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 828BB9B4: 90BF0070  stw r5, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[5].u32 ) };
	// 828BB9B8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x828BB9BC; continue 'dispatch;
            }
            0x828BB9BC => {
    //   block [0x828BB9BC..0x828BB9F8)
	// 828BB9BC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BB9C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BB9C4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BB9C8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828BB9CC: 4200FFF0  bdnz 0x828bb9bc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BB9BC; continue 'dispatch;
	}
	// 828BB9D0: 389E008C  addi r4, r30, 0x8c
	ctx.r[4].s64 = ctx.r[30].s64 + 140;
	// 828BB9D4: 387F008C  addi r3, r31, 0x8c
	ctx.r[3].s64 = ctx.r[31].s64 + 140;
	// 828BB9D8: 4BCC4421  bl 0x8257fdf8
	ctx.lr = 0x828BB9DC;
	sub_8257FDF8(ctx, base);
	// 828BB9DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BB9E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BB9E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BB9E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BB9EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BB9F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BB9F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BB9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BB9F8 size=852
    let mut pc: u32 = 0x828BB9F8;
    'dispatch: loop {
        match pc {
            0x828BB9F8 => {
    //   block [0x828BB9F8..0x828BBA60)
	// 828BB9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BB9FC: 483ED9FD  bl 0x82ca93f8
	ctx.lr = 0x828BBA00;
	sub_82CA93D0(ctx, base);
	// 828BBA00: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BBA04: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828BBA08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BBA0C: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BBA10: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828BBA14: 4198004C  blt cr6, 0x828bba60
	if ctx.cr[6].lt {
	pc = 0x828BBA60; continue 'dispatch;
	}
	// 828BBA18: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 828BBA1C: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BBA20: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 828BBA24: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BBA28: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 828BBA2C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 828BBA30: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBA34: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 828BBA38: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 828BBA3C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 828BBA40: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 828BBA44: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 828BBA48: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828BBA4C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 828BBA50: 90FD000C  stw r7, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 828BBA54: 913D0014  stw r9, 0x14(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 828BBA58: 90DD0004  stw r6, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 828BBA5C: 48000014  b 0x828bba70
	pc = 0x828BBA70; continue 'dispatch;
            }
            0x828BBA60 => {
    //   block [0x828BBA60..0x828BBA70)
	// 828BBA60: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828BBA64: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828BBA68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BBA6C: 4816547D  bl 0x82a20ee8
	ctx.lr = 0x828BBA70;
	sub_82A20EE8(ctx, base);
	pc = 0x828BBA70; continue 'dispatch;
            }
            0x828BBA70 => {
    //   block [0x828BBA70..0x828BBAA8)
	// 828BBA70: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BBA74: 897D0018  lbz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 828BBA78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BBA7C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BBA80: 419A0028  beq cr6, 0x828bbaa8
	if ctx.cr[6].eq {
	pc = 0x828BBAA8; continue 'dispatch;
	}
	// 828BBA84: 8901005B  lbz r8, 0x5b(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 828BBA88: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828BBA8C: 89210052  lbz r9, 0x52(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 828BBA90: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BBA94: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 828BBA98: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 828BBA9C: 99210051  stb r9, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[9].u8 ) };
	// 828BBAA0: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 828BBAA4: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x828BBAA8; continue 'dispatch;
            }
            0x828BBAA8 => {
    //   block [0x828BBAA8..0x828BBD04)
	// 828BBAA8: 3BFF0028  addi r31, r31, 0x28
	ctx.r[31].s64 = ctx.r[31].s64 + 40;
	// 828BBAAC: 3B400050  li r26, 0x50
	ctx.r[26].s64 = 80;
	// 828BBAB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BBAB4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BBAB8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BBABC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BBAC0: 7D69D3D6  divw r11, r9, r26
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 828BBAC4: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828BBAC8: 480007F1  bl 0x828bc2b8
	ctx.lr = 0x828BBACC;
	sub_828BC2B8(ctx, base);
	// 828BBACC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828BBAD0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828BBAD4: 40990230  ble cr6, 0x828bbd04
	if !ctx.cr[6].gt {
	pc = 0x828BBD04; continue 'dispatch;
	}
	// 828BBAD8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828BBADC: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 828BBAE0: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 828BBAE4: 3B6B7088  addi r27, r11, 0x7088
	ctx.r[27].s64 = ctx.r[11].s64 + 28808;
	// 828BBAE8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBAEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BBAF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BBAF4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BBAF8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BBAFC: 4E800421  bctrl
	ctx.lr = 0x828BBB00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BBB00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BBB04: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 828BBB08: 48166071  bl 0x82a21b78
	ctx.lr = 0x828BBB0C;
	sub_82A21B78(ctx, base);
	// 828BBB0C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828BBB10: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 828BBB14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BBB18: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
            }
            0x828BBD04 => {
    //   block [0x828BBD04..0x828BBD4C)
	// 828BBD04: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 828BBD08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BBD0C: 419A0038  beq cr6, 0x828bbd44
	if ctx.cr[6].eq {
	pc = 0x828BBD44; continue 'dispatch;
	}
	// 828BBD10: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828BBD14: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BBD18: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BBD1C: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 828BBD20: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BBD24: 88DF0010  lbz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BBD28: 7CA9D3D6  divw r5, r9, r26
	ctx.r[5].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 828BBD2C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828BBD30: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828BBD34: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828BBD38: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BBD3C: 4800139D  bl 0x828bd0d8
	ctx.lr = 0x828BBD40;
	sub_828BD0D8(ctx, base);
	// 828BBD40: 9B9F0011  stb r28, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[28].u8 ) };
	// 828BBD44: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 828BBD48: 483ED700  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BBD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BBD50 size=844
    let mut pc: u32 = 0x828BBD50;
    'dispatch: loop {
        match pc {
            0x828BBD50 => {
    //   block [0x828BBD50..0x828BBDC0)
	// 828BBD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BBD54: 483ED6AD  bl 0x82ca9400
	ctx.lr = 0x828BBD58;
	sub_82CA93D0(ctx, base);
	// 828BBD58: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 828BBD5C: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828BBD60: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BBD64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BBD68: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BBD6C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BBD70: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828BBD74: 4198004C  blt cr6, 0x828bbdc0
	if ctx.cr[6].lt {
	pc = 0x828BBDC0; continue 'dispatch;
	}
	// 828BBD78: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 828BBD7C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BBD80: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 828BBD84: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BBD88: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 828BBD8C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 828BBD90: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBD94: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 828BBD98: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 828BBD9C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 828BBDA0: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 828BBDA4: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 828BBDA8: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828BBDAC: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 828BBDB0: 90FE000C  stw r7, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 828BBDB4: 913E0014  stw r9, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 828BBDB8: 90DE0004  stw r6, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 828BBDBC: 48000014  b 0x828bbdd0
	pc = 0x828BBDD0; continue 'dispatch;
            }
            0x828BBDC0 => {
    //   block [0x828BBDC0..0x828BBDD0)
	// 828BBDC0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828BBDC4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828BBDC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BBDCC: 4816511D  bl 0x82a20ee8
	ctx.lr = 0x828BBDD0;
	sub_82A20EE8(ctx, base);
	pc = 0x828BBDD0; continue 'dispatch;
            }
            0x828BBDD0 => {
    //   block [0x828BBDD0..0x828BBE08)
	// 828BBDD0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BBDD4: 897E0018  lbz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828BBDD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BBDDC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828BBDE0: 419A0028  beq cr6, 0x828bbe08
	if ctx.cr[6].eq {
	pc = 0x828BBE08; continue 'dispatch;
	}
	// 828BBDE4: 89010057  lbz r8, 0x57(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 828BBDE8: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828BBDEC: 89210052  lbz r9, 0x52(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 828BBDF0: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BBDF4: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 828BBDF8: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 828BBDFC: 99210051  stb r9, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[9].u8 ) };
	// 828BBE00: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 828BBE04: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x828BBE08; continue 'dispatch;
            }
            0x828BBE08 => {
    //   block [0x828BBE08..0x828BBEC8)
	// 828BBE08: 3B9D003C  addi r28, r29, 0x3c
	ctx.r[28].s64 = ctx.r[29].s64 + 60;
	// 828BBE0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BBE10: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BBE14: 480005BD  bl 0x828bc3d0
	ctx.lr = 0x828BBE18;
	sub_828BC3D0(ctx, base);
	// 828BBE18: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828BBE1C: 40990270  ble cr6, 0x828bc08c
	if !ctx.cr[6].gt {
	pc = 0x828BC08C; continue 'dispatch;
	}
	// 828BBE20: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828BBE24: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828BBE28: 392AB650  addi r9, r10, -0x49b0
	ctx.r[9].s64 = ctx.r[10].s64 + -18864;
	// 828BBE2C: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 828BBE30: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828BBE34: C3CAB650  lfs f30, -0x49b0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828BBE38: 3B4B7088  addi r26, r11, 0x7088
	ctx.r[26].s64 = ctx.r[11].s64 + 28808;
	// 828BBE3C: C3E9DE34  lfs f31, -0x21cc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8652 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BBE40: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 828BBE44: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 828BBE48: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 828BBE4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BBE50: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 828BBE54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BBE58: 4BF3C751  bl 0x827f85a8
	ctx.lr = 0x828BBE5C;
	sub_827F85A8(ctx, base);
	// 828BBE5C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBE60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BBE64: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828BBE68: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BBE6C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BBE70: 4E800421  bctrl
	ctx.lr = 0x828BBE74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BBE74: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BBE78: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828BBE7C: 4198004C  blt cr6, 0x828bbec8
	if ctx.cr[6].lt {
	pc = 0x828BBEC8; continue 'dispatch;
	}
	// 828BBE80: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 828BBE84: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BBE88: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 828BBE8C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BBE90: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 828BBE94: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 828BBE98: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BBE9C: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 828BBEA0: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 828BBEA4: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 828BBEA8: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 828BBEAC: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 828BBEB0: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828BBEB4: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 828BBEB8: 90FE000C  stw r7, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 828BBEBC: 913E0014  stw r9, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 828BBEC0: 90DE0004  stw r6, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 828BBEC4: 48000014  b 0x828bbed8
	pc = 0x828BBED8; continue 'dispatch;
            }
            0x828BBEC8 => {
    //   block [0x828BBEC8..0x828BBED8)
	// 828BBEC8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828BBECC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828BBED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BBED4: 48165015  bl 0x82a20ee8
	ctx.lr = 0x828BBED8;
	sub_82A20EE8(ctx, base);
	pc = 0x828BBED8; continue 'dispatch;
            }
            0x828BBED8 => {
    //   block [0x828BBED8..0x828BBF10)
	// 828BBED8: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BBEDC: 897E0018  lbz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828BBEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BBEE4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828BBEE8: 419A0028  beq cr6, 0x828bbf10
	if ctx.cr[6].eq {
	pc = 0x828BBF10; continue 'dispatch;
	}
	// 828BBEEC: 89410058  lbz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BBEF0: 8901005B  lbz r8, 0x5b(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 828BBEF4: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 828BBEF8: 89210051  lbz r9, 0x51(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828BBEFC: 99410053  stb r10, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[10].u8 ) };
	// 828BBF00: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 828BBF04: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 828BBF08: 99210052  stb r9, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[9].u8 ) };
	// 828BBF0C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x828BBF10; continue 'dispatch;
            }
            0x828BBF10 => {
    //   block [0x828BBF10..0x828BBFB0)
	// 828BBF10: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828BBF14: 4099009C  ble cr6, 0x828bbfb0
	if !ctx.cr[6].gt {
	pc = 0x828BBFB0; continue 'dispatch;
	}
	// 828BBF18: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828BBF1C: D3C10074  stfs f30, 0x74(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828BBF20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BBF24: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828BBF28: 48165C51  bl 0x82a21b78
	ctx.lr = 0x828BBF2C;
	sub_82A21B78(ctx, base);
	// 828BBF2C: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 828BBF30: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 828BBF34: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 828BBF38: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 828BBF3C: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	pc = 0x828BBFB0; continue 'dispatch;
            }
            0x828BBFB0 => {
    //   block [0x828BBFB0..0x828BC08C)
	// 828BBFB0: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BBFB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BBFB8: 409A000C  bne cr6, 0x828bbfc4
	if !ctx.cr[6].eq {
	pc = 0x828BBFC4; continue 'dispatch;
	}
	// 828BBFBC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828BBFC0: 48000010  b 0x828bbfd0
	pc = 0x828BBFD0; continue 'dispatch;
	// 828BBFC4: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BBFC8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BBFCC: 7D2B2670  srawi r11, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 828BBFD0: 83FC0008  lwz r31, 8(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BBFD4: 7D4AF850  subf r10, r10, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 828BBFD8: 7D492670  srawi r9, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 828BBFDC: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BBFE0: 40980040  bge cr6, 0x828bc020
	if !ctx.cr[6].lt {
	pc = 0x828BC020; continue 'dispatch;
	}
	// 828BBFE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BBFE8: 419A002C  beq cr6, 0x828bc014
	if ctx.cr[6].eq {
	pc = 0x828BC014; continue 'dispatch;
	}
	// 828BBFEC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828BBFF0: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 828BBFF4: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828BBFF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BBFFC: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 828BC000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC004: 4BF3C5A5  bl 0x827f85a8
	ctx.lr = 0x828BC008;
	sub_827F85A8(ctx, base);
	// 828BC008: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828BC00C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC010: 4BF910B1  bl 0x8284d0c0
	ctx.lr = 0x828BC014;
	sub_8284D0C0(ctx, base);
	// 828BC014: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828BC018: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828BC01C: 48000020  b 0x828bc03c
	pc = 0x828BC03C; continue 'dispatch;
	// 828BC020: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 828BC024: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828BC028: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828BC02C: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 828BC030: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BC034: E8810078  ld r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828BC038: 480005D1  bl 0x828bc608
	ctx.lr = 0x828BC03C;
	sub_828BC608(ctx, base);
	// 828BC03C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828BC040: 4B90A729  bl 0x821c6768
	ctx.lr = 0x828BC044;
	sub_821C6768(ctx, base);
	// 828BC044: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 828BC048: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BC04C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BC050: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BC054: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BC058: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BC05C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BC060: 4082FFE8  bne 0x828bc048
	if !ctx.cr[0].eq {
	pc = 0x828BC048; continue 'dispatch;
	}
	// 828BC064: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BC068: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 828BC06C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BC070: 419A0008  beq cr6, 0x828bc078
	if ctx.cr[6].eq {
	pc = 0x828BC078; continue 'dispatch;
	}
	// 828BC074: 4B95FCC5  bl 0x8221bd38
	ctx.lr = 0x828BC078;
	sub_8221BD38(ctx, base);
	// 828BC078: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 828BC07C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 828BC080: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 828BC084: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 828BC088: 4082FDB8  bne 0x828bbe40
	if !ctx.cr[0].eq {
	pc = 0x828BBE40; continue 'dispatch;
	}
            }
            0x828BC08C => {
    //   block [0x828BC08C..0x828BC09C)
	// 828BC08C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 828BC090: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 828BC094: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 828BC098: 483ED3B8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC0A0 size=252
    let mut pc: u32 = 0x828BC0A0;
    'dispatch: loop {
        match pc {
            0x828BC0A0 => {
    //   block [0x828BC0A0..0x828BC100)
	// 828BC0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC0A4: 483ED35D  bl 0x82ca9400
	ctx.lr = 0x828BC0A8;
	sub_82CA93D0(ctx, base);
	// 828BC0A8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC0AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BC0B0: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828BC0B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BC0B8: 419A00DC  beq cr6, 0x828bc194
	if ctx.cr[6].eq {
	pc = 0x828BC194; continue 'dispatch;
	}
	// 828BC0BC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828BC0C0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828BC0C4: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828BC0C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC0CC: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 828BC0D0: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828BC0D4: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 828BC0D8: 90810064  stw r4, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 828BC0DC: 7D051E71  srawi. r5, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828BC0E0: 41820020  beq 0x828bc100
	if ctx.cr[0].eq {
	pc = 0x828BC100; continue 'dispatch;
	}
	// 828BC0E4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 828BC0E8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BC0EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BC0F0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828BC0F4: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BC0F8: 48000881  bl 0x828bc978
	ctx.lr = 0x828BC0FC;
	sub_828BC978(ctx, base);
	// 828BC0FC: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	pc = 0x828BC100; continue 'dispatch;
            }
            0x828BC100 => {
    //   block [0x828BC100..0x828BC114)
	// 828BC100: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828BC104: 7D445850  subf r10, r4, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 828BC108: 7D493671  srawi. r9, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 6) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828BC10C: 40820008  bne 0x828bc114
	if !ctx.cr[0].eq {
	pc = 0x828BC114; continue 'dispatch;
	}
	// 828BC110: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	pc = 0x828BC114; continue 'dispatch;
            }
            0x828BC114 => {
    //   block [0x828BC114..0x828BC140)
	// 828BC114: 807C001C  lwz r3, 0x1c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828BC118: 482BE799  bl 0x82b7a8b0
	ctx.lr = 0x828BC11C;
	sub_82B7A8B0(ctx, base);
	// 828BC11C: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 828BC120: 3B600050  li r27, 0x50
	ctx.r[27].s64 = 80;
	// 828BC124: 815C002C  lwz r10, 0x2c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 828BC128: 3BFC0028  addi r31, r28, 0x28
	ctx.r[31].s64 = ctx.r[28].s64 + 40;
	// 828BC12C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 828BC130: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BC134: 7D09DBD7  divw. r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828BC138: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BC13C: 41820048  beq 0x828bc184
	if ctx.cr[0].eq {
	pc = 0x828BC184; continue 'dispatch;
	}
	pc = 0x828BC140; continue 'dispatch;
            }
            0x828BC140 => {
    //   block [0x828BC140..0x828BC164)
	// 828BC140: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 828BC144: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828BC148: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 828BC14C: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BC150: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BC154: 41980010  blt cr6, 0x828bc164
	if ctx.cr[6].lt {
	pc = 0x828BC164; continue 'dispatch;
	}
	// 828BC158: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC15C: 7C8BD214  add r4, r11, r26
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 828BC160: 4B97F7D9  bl 0x8223b938
	ctx.lr = 0x828BC164;
	sub_8223B938(ctx, base);
	pc = 0x828BC164; continue 'dispatch;
            }
            0x828BC164 => {
    //   block [0x828BC164..0x828BC184)
	// 828BC164: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC168: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828BC16C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC170: 3BDE0050  addi r30, r30, 0x50
	ctx.r[30].s64 = ctx.r[30].s64 + 80;
	// 828BC174: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BC178: 7D09DBD6  divw r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	// 828BC17C: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BC180: 4198FFC0  blt cr6, 0x828bc140
	if ctx.cr[6].lt {
	pc = 0x828BC140; continue 'dispatch;
	}
	pc = 0x828BC184; continue 'dispatch;
            }
            0x828BC184 => {
    //   block [0x828BC184..0x828BC194)
	// 828BC184: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828BC188: 419A000C  beq cr6, 0x828bc194
	if ctx.cr[6].eq {
	pc = 0x828BC194; continue 'dispatch;
	}
	// 828BC18C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828BC190: 4B95FBA9  bl 0x8221bd38
	ctx.lr = 0x828BC194;
	sub_8221BD38(ctx, base);
	pc = 0x828BC194; continue 'dispatch;
            }
            0x828BC194 => {
    //   block [0x828BC194..0x828BC19C)
	// 828BC194: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828BC198: 483ED2B8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC1A0 size=116
    let mut pc: u32 = 0x828BC1A0;
    'dispatch: loop {
        match pc {
            0x828BC1A0 => {
    //   block [0x828BC1A0..0x828BC1FC)
	// 828BC1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC1A4: 483ED269  bl 0x82ca940c
	ctx.lr = 0x828BC1A8;
	sub_82CA93D0(ctx, base);
	// 828BC1A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC1AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC1B0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828BC1B4: 4BAF4885  bl 0x823b0a38
	ctx.lr = 0x828BC1B8;
	sub_823B0A38(ctx, base);
	// 828BC1B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BC1BC: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 828BC1C0: 83BF0030  lwz r29, 0x30(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 828BC1C4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828BC1C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828BC1CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BC1D0: 4B9A8E61  bl 0x82265030
	ctx.lr = 0x828BC1D4;
	sub_82265030(ctx, base);
	// 828BC1D4: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BC1D8: 57AB003E  slwi r11, r29, 0
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC1DC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BC1E0: 419A001C  beq cr6, 0x828bc1fc
	if ctx.cr[6].eq {
	pc = 0x828BC1FC; continue 'dispatch;
	}
	// 828BC1E4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC1E8: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BC1EC: 41980010  blt cr6, 0x828bc1fc
	if ctx.cr[6].lt {
	pc = 0x828BC1FC; continue 'dispatch;
	}
	// 828BC1F0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BC1F4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828BC1F8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x828BC1FC; continue 'dispatch;
            }
            0x828BC1FC => {
    //   block [0x828BC1FC..0x828BC214)
	// 828BC1FC: 7D6BE850  subf r11, r11, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 828BC200: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828BC204: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828BC208: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 828BC20C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BC210: 483ED24C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC218 size=160
    let mut pc: u32 = 0x828BC218;
    'dispatch: loop {
        match pc {
            0x828BC218 => {
    //   block [0x828BC218..0x828BC27C)
	// 828BC218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC21C: 483ED1E5  bl 0x82ca9400
	ctx.lr = 0x828BC220;
	sub_82CA93D0(ctx, base);
	// 828BC220: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC224: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BC228: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828BC22C: 3B400050  li r26, 0x50
	ctx.r[26].s64 = 80;
	// 828BC230: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BC234: 3BFB0028  addi r31, r27, 0x28
	ctx.r[31].s64 = ctx.r[27].s64 + 40;
	// 828BC238: 813B0030  lwz r9, 0x30(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 828BC23C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC240: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC244: 811B002C  lwz r8, 0x2c(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 828BC248: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BC24C: 7CC84850  subf r6, r8, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828BC250: 7CEA1670  srawi r10, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 828BC254: 7D66D3D6  divw r11, r6, r26
	ctx.r[11].s32 = ctx.r[6].s32 / ctx.r[26].s32;
	// 828BC258: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BC25C: 4BBA4B1D  bl 0x82460d78
	ctx.lr = 0x828BC260;
	sub_82460D78(ctx, base);
	// 828BC260: 80BB0030  lwz r5, 0x30(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 828BC264: 809B002C  lwz r4, 0x2c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 828BC268: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828BC26C: 7C642850  subf r3, r4, r5
	ctx.r[3].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 828BC270: 7D63D3D7  divw. r11, r3, r26
	ctx.r[11].s32 = ctx.r[3].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BC274: 4182003C  beq 0x828bc2b0
	if ctx.cr[0].eq {
	pc = 0x828BC2B0; continue 'dispatch;
	}
	// 828BC278: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828BC27C; continue 'dispatch;
            }
            0x828BC27C => {
    //   block [0x828BC27C..0x828BC2B0)
	// 828BC27C: 817B002C  lwz r11, 0x2c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 828BC280: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BC284: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 828BC288: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 828BC28C: 4BA6507D  bl 0x82321308
	ctx.lr = 0x828BC290;
	sub_82321308(ctx, base);
	// 828BC290: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC294: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC298: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828BC29C: 3BBD0050  addi r29, r29, 0x50
	ctx.r[29].s64 = ctx.r[29].s64 + 80;
	// 828BC2A0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BC2A4: 7D09D3D6  divw r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 828BC2A8: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BC2AC: 4198FFD0  blt cr6, 0x828bc27c
	if ctx.cr[6].lt {
	pc = 0x828BC27C; continue 'dispatch;
	}
	pc = 0x828BC2B0; continue 'dispatch;
            }
            0x828BC2B0 => {
    //   block [0x828BC2B0..0x828BC2B8)
	// 828BC2B0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BC2B4: 483ED19C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC2B8 size=280
    let mut pc: u32 = 0x828BC2B8;
    'dispatch: loop {
        match pc {
            0x828BC2B8 => {
    //   block [0x828BC2B8..0x828BC2E8)
	// 828BC2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC2BC: 483ED141  bl 0x82ca93fc
	ctx.lr = 0x828BC2C0;
	sub_82CA93D0(ctx, base);
	// 828BC2C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC2C4: 3D600333  lis r11, 0x333
	ctx.r[11].s64 = 53673984;
	// 828BC2C8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828BC2CC: 616A3333  ori r10, r11, 0x3333
	ctx.r[10].u64 = ctx.r[11].u64 | 13107;
	// 828BC2D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC2D4: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BC2D8: 40990010  ble cr6, 0x828bc2e8
	if !ctx.cr[6].gt {
	pc = 0x828BC2E8; continue 'dispatch;
	}
	// 828BC2DC: 4818B1ED  bl 0x82a474c8
	ctx.lr = 0x828BC2E0;
	sub_82A474C8(ctx, base);
	// 828BC2E0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BC2E4: 483ED168  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x828BC2E8 => {
    //   block [0x828BC2E8..0x828BC304)
	// 828BC2E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC2EC: 3B200050  li r25, 0x50
	ctx.r[25].s64 = 80;
	// 828BC2F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BC2F4: 419A0010  beq cr6, 0x828bc304
	if ctx.cr[6].eq {
	pc = 0x828BC304; continue 'dispatch;
	}
	// 828BC2F8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BC2FC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BC300: 7D69CBD6  divw r11, r9, r25
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[25].s32;
	pc = 0x828BC304; continue 'dispatch;
            }
            0x828BC304 => {
    //   block [0x828BC304..0x828BC348)
	// 828BC304: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BC308: 409800C0  bge cr6, 0x828bc3c8
	if !ctx.cr[6].lt {
	pc = 0x828BC3C8; continue 'dispatch;
	}
	// 828BC30C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828BC310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC314: 481DBC35  bl 0x82a97f48
	ctx.lr = 0x828BC318;
	sub_82A97F48(ctx, base);
	// 828BC318: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC31C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828BC320: 837F0008  lwz r27, 8(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC324: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BC328: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828BC32C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BC330: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828BC334: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828BC338: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BC33C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828BC340: 419A0034  beq cr6, 0x828bc374
	if ctx.cr[6].eq {
	pc = 0x828BC374; continue 'dispatch;
	}
	// 828BC344: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x828BC348; continue 'dispatch;
            }
            0x828BC348 => {
    //   block [0x828BC348..0x828BC364)
	// 828BC348: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BC34C: 419A0018  beq cr6, 0x828bc364
	if ctx.cr[6].eq {
	pc = 0x828BC364; continue 'dispatch;
	}
	// 828BC350: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC354: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 828BC358: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828BC35C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BC360: 480001D1  bl 0x828bc530
	ctx.lr = 0x828BC364;
	sub_828BC530(ctx, base);
	pc = 0x828BC364; continue 'dispatch;
            }
            0x828BC364 => {
    //   block [0x828BC364..0x828BC374)
	// 828BC364: 3BBD0050  addi r29, r29, 0x50
	ctx.r[29].s64 = ctx.r[29].s64 + 80;
	// 828BC368: 3BDE0050  addi r30, r30, 0x50
	ctx.r[30].s64 = ctx.r[30].s64 + 80;
	// 828BC36C: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BC370: 409AFFD8  bne cr6, 0x828bc348
	if !ctx.cr[6].eq {
	pc = 0x828BC348; continue 'dispatch;
	}
	pc = 0x828BC374; continue 'dispatch;
            }
            0x828BC374 => {
    //   block [0x828BC374..0x828BC39C)
	// 828BC374: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC378: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC37C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828BC380: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 828BC384: 7FCBCBD6  divw r30, r11, r25
	ctx.r[30].s32 = ctx.r[11].s32 / ctx.r[25].s32;
	// 828BC388: 419A0014  beq cr6, 0x828bc39c
	if ctx.cr[6].eq {
	pc = 0x828BC39C; continue 'dispatch;
	}
	// 828BC38C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC390: 48000131  bl 0x828bc4c0
	ctx.lr = 0x828BC394;
	sub_828BC4C0(ctx, base);
	// 828BC394: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC398: 4B95F9A1  bl 0x8221bd38
	ctx.lr = 0x828BC39C;
	sub_8221BD38(ctx, base);
	pc = 0x828BC39C; continue 'dispatch;
            }
            0x828BC39C => {
    //   block [0x828BC39C..0x828BC3C8)
	// 828BC39C: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC3A0: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828BC3A4: 574A103A  slwi r10, r26, 2
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BC3A8: 7D3E5A14  add r9, r30, r11
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828BC3AC: 7D5A5214  add r10, r26, r10
	ctx.r[10].u64 = ctx.r[26].u64 + ctx.r[10].u64;
	// 828BC3B0: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC3B4: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BC3B8: 7CEBE214  add r7, r11, r28
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828BC3BC: 7D0AE214  add r8, r10, r28
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 828BC3C0: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 828BC3C4: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	pc = 0x828BC3C8; continue 'dispatch;
            }
            0x828BC3C8 => {
    //   block [0x828BC3C8..0x828BC3D0)
	// 828BC3C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BC3CC: 483ED080  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC3D0 size=236
    let mut pc: u32 = 0x828BC3D0;
    'dispatch: loop {
        match pc {
            0x828BC3D0 => {
    //   block [0x828BC3D0..0x828BC438)
	// 828BC3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC3D4: 483ED02D  bl 0x82ca9400
	ctx.lr = 0x828BC3D8;
	sub_82CA93D0(ctx, base);
	// 828BC3D8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC3DC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828BC3E0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828BC3E4: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828BC3E8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BC3EC: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828BC3F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BC3F4: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828BC3F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC3FC: 4BF3C1AD  bl 0x827f85a8
	ctx.lr = 0x828BC400;
	sub_827F85A8(ctx, base);
	// 828BC400: 83FA0008  lwz r31, 8(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC404: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC408: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 828BC40C: 7D6A2671  srawi. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828BC410: 41820094  beq 0x828bc4a4
	if ctx.cr[0].eq {
	pc = 0x828BC4A4; continue 'dispatch;
	}
	// 828BC414: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC418: 419A008C  beq cr6, 0x828bc4a4
	if ctx.cr[6].eq {
	pc = 0x828BC4A4; continue 'dispatch;
	}
	// 828BC41C: 7D7FF850  subf r11, r31, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[31].s64;
	// 828BC420: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC424: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 828BC428: 554B2036  slwi r11, r10, 4
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC42C: 7F6BF214  add r27, r11, r30
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828BC430: 419A0034  beq cr6, 0x828bc464
	if ctx.cr[6].eq {
	pc = 0x828BC464; continue 'dispatch;
	}
	// 828BC434: 7FBEF850  subf r29, r30, r31
	ctx.r[29].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	pc = 0x828BC438; continue 'dispatch;
            }
            0x828BC438 => {
    //   block [0x828BC438..0x828BC464)
	// 828BC438: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BC43C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BC440: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC444: 4BF3C165  bl 0x827f85a8
	ctx.lr = 0x828BC448;
	sub_827F85A8(ctx, base);
	// 828BC448: 7C9DF214  add r4, r29, r30
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 828BC44C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC450: 4BF90C71  bl 0x8284d0c0
	ctx.lr = 0x828BC454;
	sub_8284D0C0(ctx, base);
	// 828BC454: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BC458: 7D7DF214  add r11, r29, r30
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 828BC45C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC460: 409AFFD8  bne cr6, 0x828bc438
	if !ctx.cr[6].eq {
	pc = 0x828BC438; continue 'dispatch;
	}
	pc = 0x828BC464; continue 'dispatch;
            }
            0x828BC464 => {
    //   block [0x828BC464..0x828BC474)
	// 828BC464: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC468: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BC46C: 419A0034  beq cr6, 0x828bc4a0
	if ctx.cr[6].eq {
	pc = 0x828BC4A0; continue 'dispatch;
	}
	// 828BC470: 3BFB0004  addi r31, r27, 4
	ctx.r[31].s64 = ctx.r[27].s64 + 4;
	pc = 0x828BC474; continue 'dispatch;
            }
            0x828BC474 => {
    //   block [0x828BC474..0x828BC484)
	// 828BC474: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC478: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BC47C: 419A0008  beq cr6, 0x828bc484
	if ctx.cr[6].eq {
	pc = 0x828BC484; continue 'dispatch;
	}
	// 828BC480: 4B95F8B9  bl 0x8221bd38
	ctx.lr = 0x828BC484;
	sub_8221BD38(ctx, base);
	pc = 0x828BC484; continue 'dispatch;
            }
            0x828BC484 => {
    //   block [0x828BC484..0x828BC4A0)
	// 828BC484: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828BC488: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828BC48C: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 828BC490: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828BC494: 397FFFFC  addi r11, r31, -4
	ctx.r[11].s64 = ctx.r[31].s64 + -4;
	// 828BC498: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BC49C: 409AFFD8  bne cr6, 0x828bc474
	if !ctx.cr[6].eq {
	pc = 0x828BC474; continue 'dispatch;
	}
	pc = 0x828BC4A0; continue 'dispatch;
            }
            0x828BC4A0 => {
    //   block [0x828BC4A0..0x828BC4A4)
	// 828BC4A0: 937A0008  stw r27, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x828BC4A4; continue 'dispatch;
            }
            0x828BC4A4 => {
    //   block [0x828BC4A4..0x828BC4B4)
	// 828BC4A4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BC4A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BC4AC: 419A0008  beq cr6, 0x828bc4b4
	if ctx.cr[6].eq {
	pc = 0x828BC4B4; continue 'dispatch;
	}
	// 828BC4B0: 4B95F889  bl 0x8221bd38
	ctx.lr = 0x828BC4B4;
	sub_8221BD38(ctx, base);
	pc = 0x828BC4B4; continue 'dispatch;
            }
            0x828BC4B4 => {
    //   block [0x828BC4B4..0x828BC4BC)
	// 828BC4B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BC4B8: 483ECF98  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC4C0 size=108
    let mut pc: u32 = 0x828BC4C0;
    'dispatch: loop {
        match pc {
            0x828BC4C0 => {
    //   block [0x828BC4C0..0x828BC4E8)
	// 828BC4C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC4C4: 483ECF45  bl 0x82ca9408
	ctx.lr = 0x828BC4C8;
	sub_82CA93D0(ctx, base);
	// 828BC4C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC4CC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828BC4D0: 7F04E040  cmplw cr6, r4, r28
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BC4D4: 419A0050  beq cr6, 0x828bc524
	if ctx.cr[6].eq {
	pc = 0x828BC524; continue 'dispatch;
	}
	// 828BC4D8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828BC4DC: 3BE40010  addi r31, r4, 0x10
	ctx.r[31].s64 = ctx.r[4].s64 + 16;
	// 828BC4E0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828BC4E4: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	pc = 0x828BC4E8; continue 'dispatch;
            }
            0x828BC4E8 => {
    //   block [0x828BC4E8..0x828BC4F4)
	// 828BC4E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC4EC: 4B90A27D  bl 0x821c6768
	ctx.lr = 0x828BC4F0;
	sub_821C6768(ctx, base);
	// 828BC4F0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x828BC4F4; continue 'dispatch;
            }
            0x828BC4F4 => {
    //   block [0x828BC4F4..0x828BC524)
	// 828BC4F4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828BC4F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BC4FC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828BC500: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BC504: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BC508: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BC50C: 4082FFE8  bne 0x828bc4f4
	if !ctx.cr[0].eq {
	pc = 0x828BC4F4; continue 'dispatch;
	}
	// 828BC510: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828BC514: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 828BC518: 391FFFF0  addi r8, r31, -0x10
	ctx.r[8].s64 = ctx.r[31].s64 + -16;
	// 828BC51C: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BC520: 409AFFC8  bne cr6, 0x828bc4e8
	if !ctx.cr[6].eq {
	pc = 0x828BC4E8; continue 'dispatch;
	}
	pc = 0x828BC524; continue 'dispatch;
            }
            0x828BC524 => {
    //   block [0x828BC524..0x828BC52C)
	// 828BC524: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BC528: 483ECF30  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC530 size=112
    let mut pc: u32 = 0x828BC530;
    'dispatch: loop {
        match pc {
            0x828BC530 => {
    //   block [0x828BC530..0x828BC5A0)
	// 828BC530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BC538: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BC53C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BC540: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC544: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BC548: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BC54C: 4B933CF5  bl 0x821f0240
	ctx.lr = 0x828BC550;
	sub_821F0240(ctx, base);
	// 828BC550: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BC554: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828BC558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC55C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828BC560: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BC564: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 828BC568: 811E0018  lwz r8, 0x18(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828BC56C: 911F0018  stw r8, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 828BC570: 80FE001C  lwz r7, 0x1c(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828BC574: 90FF001C  stw r7, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC5A0 size=104
    let mut pc: u32 = 0x828BC5A0;
    'dispatch: loop {
        match pc {
            0x828BC5A0 => {
    //   block [0x828BC5A0..0x828BC5C8)
	// 828BC5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC5A4: 483ECE61  bl 0x82ca9404
	ctx.lr = 0x828BC5A8;
	sub_82CA93D0(ctx, base);
	// 828BC5A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC5AC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828BC5B0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828BC5B4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 828BC5B8: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 828BC5BC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828BC5C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BC5C4: 419A002C  beq cr6, 0x828bc5f0
	if ctx.cr[6].eq {
	pc = 0x828BC5F0; continue 'dispatch;
	}
	pc = 0x828BC5C8; continue 'dispatch;
            }
            0x828BC5C8 => {
    //   block [0x828BC5C8..0x828BC5E4)
	// 828BC5C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BC5CC: 419A0018  beq cr6, 0x828bc5e4
	if ctx.cr[6].eq {
	pc = 0x828BC5E4; continue 'dispatch;
	}
	// 828BC5D0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BC5D4: 389C0010  addi r4, r28, 0x10
	ctx.r[4].s64 = ctx.r[28].s64 + 16;
	// 828BC5D8: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828BC5DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BC5E0: 4BFFFF51  bl 0x828bc530
	ctx.lr = 0x828BC5E4;
	sub_828BC530(ctx, base);
	pc = 0x828BC5E4; continue 'dispatch;
            }
            0x828BC5E4 => {
    //   block [0x828BC5E4..0x828BC5F0)
	// 828BC5E4: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828BC5E8: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 828BC5EC: 4082FFDC  bne 0x828bc5c8
	if !ctx.cr[0].eq {
	pc = 0x828BC5C8; continue 'dispatch;
	}
	pc = 0x828BC5F0; continue 'dispatch;
            }
            0x828BC5F0 => {
    //   block [0x828BC5F0..0x828BC608)
	// 828BC5F0: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC5F4: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828BC5F8: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC5FC: 7C6BDA14  add r3, r11, r27
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828BC600: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BC604: 483ECE50  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC608 size=876
    let mut pc: u32 = 0x828BC608;
    'dispatch: loop {
        match pc {
            0x828BC608 => {
    //   block [0x828BC608..0x828BC644)
	// 828BC608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC60C: 483ECDE9  bl 0x82ca93f4
	ctx.lr = 0x828BC610;
	sub_82CA93D0(ctx, base);
	// 828BC610: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC614: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828BC618: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 828BC61C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 828BC620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BC624: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828BC628: 4BF90739  bl 0x8284cd60
	ctx.lr = 0x828BC62C;
	sub_8284CD60(ctx, base);
	// 828BC62C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC630: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 828BC634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BC638: 409A000C  bne cr6, 0x828bc644
	if !ctx.cr[6].eq {
	pc = 0x828BC644; continue 'dispatch;
	}
	// 828BC63C: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 828BC640: 48000010  b 0x828bc650
	pc = 0x828BC650; continue 'dispatch;
            }
            0x828BC644 => {
    //   block [0x828BC644..0x828BC650)
	// 828BC644: 8159000C  lwz r10, 0xc(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BC648: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BC64C: 7D292670  srawi r9, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 4) as i64;
	pc = 0x828BC650; continue 'dispatch;
            }
            0x828BC650 => {
    //   block [0x828BC650..0x828BC680)
	// 828BC650: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828BC654: 419A0308  beq cr6, 0x828bc95c
	if ctx.cr[6].eq {
	pc = 0x828BC95C; continue 'dispatch;
	}
	// 828BC658: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC65C: 3D400FFF  lis r10, 0xfff
	ctx.r[10].s64 = 268369920;
	// 828BC660: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 828BC664: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 828BC668: 7D0B2670  srawi r11, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 828BC66C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BC670: 7F07D040  cmplw cr6, r7, r26
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BC674: 4098000C  bge cr6, 0x828bc680
	if !ctx.cr[6].lt {
	pc = 0x828BC680; continue 'dispatch;
	}
	// 828BC678: 4818AE51  bl 0x82a474c8
	ctx.lr = 0x828BC67C;
	sub_82A474C8(ctx, base);
	// 828BC67C: 480002E0  b 0x828bc95c
	pc = 0x828BC95C; continue 'dispatch;
            }
            0x828BC680 => {
    //   block [0x828BC680..0x828BC6A4)
	// 828BC680: 7D0BD214  add r8, r11, r26
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 828BC684: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BC688: 4098015C  bge cr6, 0x828bc7e4
	if !ctx.cr[6].lt {
	pc = 0x828BC7E4; continue 'dispatch;
	}
	// 828BC68C: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC690: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	// 828BC694: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BC698: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BC69C: 41980008  blt cr6, 0x828bc6a4
	if ctx.cr[6].lt {
	pc = 0x828BC6A4; continue 'dispatch;
	}
	// 828BC6A0: 7F0B4A14  add r24, r11, r9
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x828BC6A4; continue 'dispatch;
            }
            0x828BC6A4 => {
    //   block [0x828BC6A4..0x828BC6B0)
	// 828BC6A4: 7F184040  cmplw cr6, r24, r8
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BC6A8: 40980008  bge cr6, 0x828bc6b0
	if !ctx.cr[6].lt {
	pc = 0x828BC6B0; continue 'dispatch;
	}
	// 828BC6AC: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	pc = 0x828BC6B0; continue 'dispatch;
            }
            0x828BC6B0 => {
    //   block [0x828BC6B0..0x828BC6D4)
	// 828BC6B0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828BC6B4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828BC6B8: 4BB66B81  bl 0x82423238
	ctx.lr = 0x828BC6BC;
	sub_82423238(ctx, base);
	// 828BC6BC: 83D90004  lwz r30, 4(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC6C0: 838100DC  lwz r28, 0xdc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 828BC6C4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BC6C8: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BC6CC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828BC6D0: 419A0028  beq cr6, 0x828bc6f8
	if ctx.cr[6].eq {
	pc = 0x828BC6F8; continue 'dispatch;
	}
	pc = 0x828BC6D4; continue 'dispatch;
            }
            0x828BC6D4 => {
    //   block [0x828BC6D4..0x828BC6E8)
	// 828BC6D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BC6D8: 419A0010  beq cr6, 0x828bc6e8
	if ctx.cr[6].eq {
	pc = 0x828BC6E8; continue 'dispatch;
	}
	// 828BC6DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC6E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC6E4: 4BF9067D  bl 0x8284cd60
	ctx.lr = 0x828BC6E8;
	sub_8284CD60(ctx, base);
	pc = 0x828BC6E8; continue 'dispatch;
            }
            0x828BC6E8 => {
    //   block [0x828BC6E8..0x828BC6F8)
	// 828BC6E8: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BC6EC: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828BC6F0: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BC6F4: 409AFFE0  bne cr6, 0x828bc6d4
	if !ctx.cr[6].eq {
	pc = 0x828BC6D4; continue 'dispatch;
	}
	pc = 0x828BC6F8; continue 'dispatch;
            }
            0x828BC6F8 => {
    //   block [0x828BC6F8..0x828BC708)
	// 828BC6F8: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 828BC6FC: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828BC700: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828BC704: 419A0024  beq cr6, 0x828bc728
	if ctx.cr[6].eq {
	pc = 0x828BC728; continue 'dispatch;
	}
	pc = 0x828BC708; continue 'dispatch;
            }
            0x828BC708 => {
    //   block [0x828BC708..0x828BC71C)
	// 828BC708: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BC70C: 419A0010  beq cr6, 0x828bc71c
	if ctx.cr[6].eq {
	pc = 0x828BC71C; continue 'dispatch;
	}
	// 828BC710: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC714: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC718: 4BF90649  bl 0x8284cd60
	ctx.lr = 0x828BC71C;
	sub_8284CD60(ctx, base);
	pc = 0x828BC71C; continue 'dispatch;
            }
            0x828BC71C => {
    //   block [0x828BC71C..0x828BC728)
	// 828BC71C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828BC720: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BC724: 4082FFE4  bne 0x828bc708
	if !ctx.cr[0].eq {
	pc = 0x828BC708; continue 'dispatch;
	}
	pc = 0x828BC728; continue 'dispatch;
            }
            0x828BC728 => {
    //   block [0x828BC728..0x828BC748)
	// 828BC728: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC72C: 574B2036  slwi r11, r26, 4
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC730: 7FDF5A14  add r30, r31, r11
	ctx.r[30].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828BC734: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BC738: 419A0034  beq cr6, 0x828bc76c
	if ctx.cr[6].eq {
	pc = 0x828BC76C; continue 'dispatch;
	}
	// 828BC73C: 7D5FF050  subf r10, r31, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 828BC740: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BC744: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x828BC748; continue 'dispatch;
            }
            0x828BC748 => {
    //   block [0x828BC748..0x828BC75C)
	// 828BC748: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BC74C: 419A0010  beq cr6, 0x828bc75c
	if ctx.cr[6].eq {
	pc = 0x828BC75C; continue 'dispatch;
	}
	// 828BC750: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BC754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC758: 4BF90609  bl 0x8284cd60
	ctx.lr = 0x828BC75C;
	sub_8284CD60(ctx, base);
	pc = 0x828BC75C; continue 'dispatch;
            }
            0x828BC75C => {
    //   block [0x828BC75C..0x828BC76C)
	// 828BC75C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828BC760: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BC764: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BC768: 409AFFE0  bne cr6, 0x828bc748
	if !ctx.cr[6].eq {
	pc = 0x828BC748; continue 'dispatch;
	}
	pc = 0x828BC76C; continue 'dispatch;
            }
            0x828BC76C => {
    //   block [0x828BC76C..0x828BC790)
	// 828BC76C: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC770: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC774: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BC778: 7D7FE850  subf r11, r31, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 828BC77C: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 828BC780: 7F8BD214  add r28, r11, r26
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 828BC784: 419A0040  beq cr6, 0x828bc7c4
	if ctx.cr[6].eq {
	pc = 0x828BC7C4; continue 'dispatch;
	}
	// 828BC788: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BC78C: 419A0030  beq cr6, 0x828bc7bc
	if ctx.cr[6].eq {
	pc = 0x828BC7BC; continue 'dispatch;
	}
	pc = 0x828BC790; continue 'dispatch;
            }
            0x828BC790 => {
    //   block [0x828BC790..0x828BC7A4)
	// 828BC790: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC794: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 828BC798: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BC79C: 419A0008  beq cr6, 0x828bc7a4
	if ctx.cr[6].eq {
	pc = 0x828BC7A4; continue 'dispatch;
	}
	// 828BC7A0: 4B95F599  bl 0x8221bd38
	ctx.lr = 0x828BC7A4;
	sub_8221BD38(ctx, base);
	pc = 0x828BC7A4; continue 'dispatch;
            }
            0x828BC7A4 => {
    //   block [0x828BC7A4..0x828BC7BC)
	// 828BC7A4: 92FF0008  stw r23, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 828BC7A8: 92FF000C  stw r23, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[23].u32 ) };
	// 828BC7AC: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828BC7B0: 92FE0000  stw r23, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 828BC7B4: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BC7B8: 409AFFD8  bne cr6, 0x828bc790
	if !ctx.cr[6].eq {
	pc = 0x828BC790; continue 'dispatch;
	}
	pc = 0x828BC7BC; continue 'dispatch;
            }
            0x828BC7BC => {
    //   block [0x828BC7BC..0x828BC7C4)
	// 828BC7BC: 80790004  lwz r3, 4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC7C0: 4B95F579  bl 0x8221bd38
	ctx.lr = 0x828BC7C4;
	sub_8221BD38(ctx, base);
	pc = 0x828BC7C4; continue 'dispatch;
            }
            0x828BC7C4 => {
    //   block [0x828BC7C4..0x828BC7E4)
	// 828BC7C4: 570A2036  slwi r10, r24, 4
	ctx.r[10].u32 = ctx.r[24].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BC7C8: 93790004  stw r27, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828BC7CC: 578B2036  slwi r11, r28, 4
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BC7D0: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 828BC7D4: 7D2BDA14  add r9, r11, r27
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828BC7D8: 9159000C  stw r10, 0xc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828BC7DC: 91390008  stw r9, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828BC7E0: 4800017C  b 0x828bc95c
	pc = 0x828BC95C; continue 'dispatch;
            }
            0x828BC7E4 => {
    //   block [0x828BC7E4..0x828BC80C)
	// 828BC7E4: 836100DC  lwz r27, 0xdc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 828BC7E8: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 828BC7EC: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 828BC7F0: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BC7F4: 409800B8  bge cr6, 0x828bc8ac
	if !ctx.cr[6].lt {
	pc = 0x828BC8AC; continue 'dispatch;
	}
	// 828BC7F8: 575C2036  slwi r28, r26, 4
	ctx.r[28].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 828BC7FC: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC800: 7FDCDA14  add r30, r28, r27
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 828BC804: 419A002C  beq cr6, 0x828bc830
	if ctx.cr[6].eq {
	pc = 0x828BC830; continue 'dispatch;
	}
	// 828BC808: 7FBCF050  subf r29, r28, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	pc = 0x828BC80C; continue 'dispatch;
            }
            0x828BC80C => {
    //   block [0x828BC80C..0x828BC820)
	// 828BC80C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BC810: 419A0010  beq cr6, 0x828bc820
	if ctx.cr[6].eq {
	pc = 0x828BC820; continue 'dispatch;
	}
	// 828BC814: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BC818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC81C: 4BF90545  bl 0x8284cd60
	ctx.lr = 0x828BC820;
	sub_8284CD60(ctx, base);
	pc = 0x828BC820; continue 'dispatch;
            }
            0x828BC820 => {
    //   block [0x828BC820..0x828BC830)
	// 828BC820: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 828BC824: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BC828: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC82C: 409AFFE0  bne cr6, 0x828bc80c
	if !ctx.cr[6].eq {
	pc = 0x828BC80C; continue 'dispatch;
	}
	pc = 0x828BC830; continue 'dispatch;
            }
            0x828BC830 => {
    //   block [0x828BC830..0x828BC844)
	// 828BC830: 83D90008  lwz r30, 8(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC834: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 828BC838: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 828BC83C: 7FEAD051  subf. r31, r10, r26
	ctx.r[31].s64 = ctx.r[26].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828BC840: 41820024  beq 0x828bc864
	if ctx.cr[0].eq {
	pc = 0x828BC864; continue 'dispatch;
	}
	pc = 0x828BC844; continue 'dispatch;
            }
            0x828BC844 => {
    //   block [0x828BC844..0x828BC858)
	// 828BC844: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BC848: 419A0010  beq cr6, 0x828bc858
	if ctx.cr[6].eq {
	pc = 0x828BC858; continue 'dispatch;
	}
	// 828BC84C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC850: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC854: 4BF9050D  bl 0x8284cd60
	ctx.lr = 0x828BC858;
	sub_8284CD60(ctx, base);
	pc = 0x828BC858; continue 'dispatch;
            }
            0x828BC858 => {
    //   block [0x828BC858..0x828BC864)
	// 828BC858: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828BC85C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BC860: 4082FFE4  bne 0x828bc844
	if !ctx.cr[0].eq {
	pc = 0x828BC844; continue 'dispatch;
	}
	pc = 0x828BC864; continue 'dispatch;
            }
            0x828BC864 => {
    //   block [0x828BC864..0x828BC880)
	// 828BC864: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC868: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828BC86C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828BC870: 7FDC5850  subf r30, r28, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 828BC874: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828BC878: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BC87C: 419A00E0  beq cr6, 0x828bc95c
	if ctx.cr[6].eq {
	pc = 0x828BC95C; continue 'dispatch;
	}
	pc = 0x828BC880; continue 'dispatch;
            }
            0x828BC880 => {
    //   block [0x828BC880..0x828BC8AC)
	// 828BC880: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BC884: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BC888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC88C: 4BF3BD1D  bl 0x827f85a8
	ctx.lr = 0x828BC890;
	sub_827F85A8(ctx, base);
	// 828BC890: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC898: 4BF90829  bl 0x8284d0c0
	ctx.lr = 0x828BC89C;
	sub_8284D0C0(ctx, base);
	// 828BC89C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828BC8A0: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BC8A4: 409AFFDC  bne cr6, 0x828bc880
	if !ctx.cr[6].eq {
	pc = 0x828BC880; continue 'dispatch;
	}
	// 828BC8A8: 480000B4  b 0x828bc95c
	pc = 0x828BC95C; continue 'dispatch;
            }
            0x828BC8AC => {
    //   block [0x828BC8AC..0x828BC8C4)
	// 828BC8AC: 575A2036  slwi r26, r26, 4
	ctx.r[26].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 828BC8B0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828BC8B4: 7F9AF850  subf r28, r26, r31
	ctx.r[28].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 828BC8B8: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 828BC8BC: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC8C0: 419A0028  beq cr6, 0x828bc8e8
	if ctx.cr[6].eq {
	pc = 0x828BC8E8; continue 'dispatch;
	}
	pc = 0x828BC8C4; continue 'dispatch;
            }
            0x828BC8C4 => {
    //   block [0x828BC8C4..0x828BC8D8)
	// 828BC8C4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BC8C8: 419A0010  beq cr6, 0x828bc8d8
	if ctx.cr[6].eq {
	pc = 0x828BC8D8; continue 'dispatch;
	}
	// 828BC8CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BC8D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BC8D4: 4BF9048D  bl 0x8284cd60
	ctx.lr = 0x828BC8D8;
	sub_8284CD60(ctx, base);
	pc = 0x828BC8D8; continue 'dispatch;
            }
            0x828BC8D8 => {
    //   block [0x828BC8D8..0x828BC8E8)
	// 828BC8D8: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 828BC8DC: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828BC8E0: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC8E4: 409AFFE0  bne cr6, 0x828bc8c4
	if !ctx.cr[6].eq {
	pc = 0x828BC8C4; continue 'dispatch;
	}
	pc = 0x828BC8E8; continue 'dispatch;
            }
            0x828BC8E8 => {
    //   block [0x828BC8E8..0x828BC8F8)
	// 828BC8E8: 93D90008  stw r30, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828BC8EC: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BC8F0: 419A0034  beq cr6, 0x828bc924
	if ctx.cr[6].eq {
	pc = 0x828BC924; continue 'dispatch;
	}
	// 828BC8F4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x828BC8F8; continue 'dispatch;
            }
            0x828BC8F8 => {
    //   block [0x828BC8F8..0x828BC924)
	// 828BC8F8: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 828BC8FC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BC900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC904: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BC908: 3BDEFFF0  addi r30, r30, -0x10
	ctx.r[30].s64 = ctx.r[30].s64 + -16;
	// 828BC90C: 4BF3BC9D  bl 0x827f85a8
	ctx.lr = 0x828BC910;
	sub_827F85A8(ctx, base);
	// 828BC910: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BC914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC918: 4BF907A9  bl 0x8284d0c0
	ctx.lr = 0x828BC91C;
	sub_8284D0C0(ctx, base);
	// 828BC91C: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BC920: 409AFFD8  bne cr6, 0x828bc8f8
	if !ctx.cr[6].eq {
	pc = 0x828BC8F8; continue 'dispatch;
	}
	pc = 0x828BC924; continue 'dispatch;
            }
            0x828BC924 => {
    //   block [0x828BC924..0x828BC934)
	// 828BC924: 7FDADA14  add r30, r26, r27
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 828BC928: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828BC92C: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BC930: 419A002C  beq cr6, 0x828bc95c
	if ctx.cr[6].eq {
	pc = 0x828BC95C; continue 'dispatch;
	}
	pc = 0x828BC934; continue 'dispatch;
            }
            0x828BC934 => {
    //   block [0x828BC934..0x828BC95C)
	// 828BC934: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BC938: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BC93C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC940: 4BF3BC69  bl 0x827f85a8
	ctx.lr = 0x828BC944;
	sub_827F85A8(ctx, base);
	// 828BC944: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BC948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BC94C: 4BF90775  bl 0x8284d0c0
	ctx.lr = 0x828BC950;
	sub_8284D0C0(ctx, base);
	// 828BC950: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828BC954: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BC958: 409AFFDC  bne cr6, 0x828bc934
	if !ctx.cr[6].eq {
	pc = 0x828BC934; continue 'dispatch;
	}
	pc = 0x828BC95C; continue 'dispatch;
            }
            0x828BC95C => {
    //   block [0x828BC95C..0x828BC96C)
	// 828BC95C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BC960: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BC964: 419A0008  beq cr6, 0x828bc96c
	if ctx.cr[6].eq {
	pc = 0x828BC96C; continue 'dispatch;
	}
	// 828BC968: 4B95F3D1  bl 0x8221bd38
	ctx.lr = 0x828BC96C;
	sub_8221BD38(ctx, base);
	pc = 0x828BC96C; continue 'dispatch;
            }
            0x828BC96C => {
    //   block [0x828BC96C..0x828BC974)
	// 828BC96C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BC970: 483ECAD4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BC978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BC978 size=1004
    let mut pc: u32 = 0x828BC978;
    'dispatch: loop {
        match pc {
            0x828BC978 => {
    //   block [0x828BC978..0x828BC9A0)
	// 828BC978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BC97C: 483ECA8D  bl 0x82ca9408
	ctx.lr = 0x828BC980;
	sub_82CA93D0(ctx, base);
	// 828BC980: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BC984: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BC988: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 828BC98C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828BC990: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BC994: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828BC998: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 828BC99C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x828BC9A0; continue 'dispatch;
            }
            0x828BC9A0 => {
    //   block [0x828BC9A0..0x828BC9C8)
	// 828BC9A0: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BC9A4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BC9A8: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 828BC9AC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BC9B0: 4200FFF0  bdnz 0x828bc9a0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BC9A0; continue 'dispatch;
	}
	// 828BC9B4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BC9B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BC9BC: 409A000C  bne cr6, 0x828bc9c8
	if !ctx.cr[6].eq {
	pc = 0x828BC9C8; continue 'dispatch;
	}
	// 828BC9C0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828BC9C4: 48000010  b 0x828bc9d4
	pc = 0x828BC9D4; continue 'dispatch;
            }
            0x828BC9C8 => {
    //   block [0x828BC9C8..0x828BC9D4)
	// 828BC9C8: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BC9CC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BC9D0: 7D293670  srawi r9, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 6) as i64;
	pc = 0x828BC9D4; continue 'dispatch;
            }
            0x828BC9D4 => {
    //   block [0x828BC9D4..0x828BCA08)
	// 828BC9D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BC9D8: 419A0384  beq cr6, 0x828bcd5c
	if ctx.cr[6].eq {
	pc = 0x828BCD5C; continue 'dispatch;
	}
	// 828BC9DC: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BC9E0: 3D4003FF  lis r10, 0x3ff
	ctx.r[10].s64 = 67043328;
	// 828BC9E4: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 828BC9E8: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 828BC9EC: 7D0B3670  srawi r11, r8, 6
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 6) as i64;
	// 828BC9F0: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BC9F4: 7F07F840  cmplw cr6, r7, r31
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BC9F8: 40980010  bge cr6, 0x828bca08
	if !ctx.cr[6].lt {
	pc = 0x828BCA08; continue 'dispatch;
	}
	// 828BC9FC: 4818AACD  bl 0x82a474c8
	ctx.lr = 0x828BCA00;
	sub_82A474C8(ctx, base);
	// 828BCA00: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BCA04: 483ECA54  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x828BCA08 => {
    //   block [0x828BCA08..0x828BCA2C)
	// 828BCA08: 7D0BFA14  add r8, r11, r31
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828BCA0C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BCA10: 40980170  bge cr6, 0x828bcb80
	if !ctx.cr[6].lt {
	pc = 0x828BCB80; continue 'dispatch;
	}
	// 828BCA14: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BCA18: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828BCA1C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BCA20: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BCA24: 41980008  blt cr6, 0x828bca2c
	if ctx.cr[6].lt {
	pc = 0x828BCA2C; continue 'dispatch;
	}
	// 828BCA28: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x828BCA2C; continue 'dispatch;
            }
            0x828BCA2C => {
    //   block [0x828BCA2C..0x828BCA38)
	// 828BCA2C: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BCA30: 40980008  bge cr6, 0x828bca38
	if !ctx.cr[6].lt {
	pc = 0x828BCA38; continue 'dispatch;
	}
	// 828BCA34: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x828BCA38; continue 'dispatch;
            }
            0x828BCA38 => {
    //   block [0x828BCA38..0x828BCA5C)
	// 828BCA38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BCA3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BCA40: 481121F1  bl 0x829cec30
	ctx.lr = 0x828BCA44;
	sub_829CEC30(ctx, base);
	// 828BCA44: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BCA48: 80A100DC  lwz r5, 0xdc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 828BCA4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BCA50: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828BCA54: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828BCA58: 419A0040  beq cr6, 0x828bca98
	if ctx.cr[6].eq {
	pc = 0x828BCA98; continue 'dispatch;
	}
	pc = 0x828BCA5C; continue 'dispatch;
            }
            0x828BCA5C => {
    //   block [0x828BCA5C..0x828BCA74)
	// 828BCA5C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BCA60: 419A0028  beq cr6, 0x828bca88
	if ctx.cr[6].eq {
	pc = 0x828BCA88; continue 'dispatch;
	}
	// 828BCA64: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828BCA68: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 828BCA6C: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 828BCA70: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x828BCA74; continue 'dispatch;
            }
            0x828BCA74 => {
    //   block [0x828BCA74..0x828BCA88)
	// 828BCA74: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BCA78: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BCA7C: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 828BCA80: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCA84: 4200FFF0  bdnz 0x828bca74
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCA74; continue 'dispatch;
	}
	pc = 0x828BCA88; continue 'dispatch;
            }
            0x828BCA88 => {
    //   block [0x828BCA88..0x828BCA98)
	// 828BCA88: 39290040  addi r9, r9, 0x40
	ctx.r[9].s64 = ctx.r[9].s64 + 64;
	// 828BCA8C: 38E70040  addi r7, r7, 0x40
	ctx.r[7].s64 = ctx.r[7].s64 + 64;
	// 828BCA90: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828BCA94: 409AFFC8  bne cr6, 0x828bca5c
	if !ctx.cr[6].eq {
	pc = 0x828BCA5C; continue 'dispatch;
	}
	pc = 0x828BCA98; continue 'dispatch;
            }
            0x828BCA98 => {
    //   block [0x828BCA98..0x828BCAA8)
	// 828BCA98: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828BCA9C: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 828BCAA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BCAA4: 419A003C  beq cr6, 0x828bcae0
	if ctx.cr[6].eq {
	pc = 0x828BCAE0; continue 'dispatch;
	}
	pc = 0x828BCAA8; continue 'dispatch;
            }
            0x828BCAA8 => {
    //   block [0x828BCAA8..0x828BCAC0)
	// 828BCAA8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828BCAAC: 419A0028  beq cr6, 0x828bcad4
	if ctx.cr[6].eq {
	pc = 0x828BCAD4; continue 'dispatch;
	}
	// 828BCAB0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828BCAB4: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 828BCAB8: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 828BCABC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x828BCAC0; continue 'dispatch;
            }
            0x828BCAC0 => {
    //   block [0x828BCAC0..0x828BCAD4)
	// 828BCAC0: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BCAC4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BCAC8: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 828BCACC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCAD0: 4200FFF0  bdnz 0x828bcac0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCAC0; continue 'dispatch;
	}
	pc = 0x828BCAD4; continue 'dispatch;
            }
            0x828BCAD4 => {
    //   block [0x828BCAD4..0x828BCAE0)
	// 828BCAD4: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 828BCAD8: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 828BCADC: 4082FFCC  bne 0x828bcaa8
	if !ctx.cr[0].eq {
	pc = 0x828BCAA8; continue 'dispatch;
	}
	pc = 0x828BCAE0; continue 'dispatch;
            }
            0x828BCAE0 => {
    //   block [0x828BCAE0..0x828BCB00)
	// 828BCAE0: 80DC0008  lwz r6, 8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCAE4: 57EB3032  slwi r11, r31, 6
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BCAE8: 7D2B3A14  add r9, r11, r7
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 828BCAEC: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BCAF0: 419A004C  beq cr6, 0x828bcb3c
	if ctx.cr[6].eq {
	pc = 0x828BCB3C; continue 'dispatch;
	}
	// 828BCAF4: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 828BCAF8: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 828BCAFC: 7D0B2A14  add r8, r11, r5
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	pc = 0x828BCB00; continue 'dispatch;
            }
            0x828BCB00 => {
    //   block [0x828BCB00..0x828BCB18)
	// 828BCB00: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BCB04: 419A0028  beq cr6, 0x828bcb2c
	if ctx.cr[6].eq {
	pc = 0x828BCB2C; continue 'dispatch;
	}
	// 828BCB08: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 828BCB0C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 828BCB10: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 828BCB14: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x828BCB18; continue 'dispatch;
            }
            0x828BCB18 => {
    //   block [0x828BCB18..0x828BCB2C)
	// 828BCB18: E8EB0000  ld r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BCB1C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BCB20: F8EA0000  std r7, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 828BCB24: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCB28: 4200FFF0  bdnz 0x828bcb18
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCB18; continue 'dispatch;
	}
	pc = 0x828BCB2C; continue 'dispatch;
            }
            0x828BCB2C => {
    //   block [0x828BCB2C..0x828BCB3C)
	// 828BCB2C: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 828BCB30: 39290040  addi r9, r9, 0x40
	ctx.r[9].s64 = ctx.r[9].s64 + 64;
	// 828BCB34: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BCB38: 409AFFC8  bne cr6, 0x828bcb00
	if !ctx.cr[6].eq {
	pc = 0x828BCB00; continue 'dispatch;
	}
	pc = 0x828BCB3C; continue 'dispatch;
            }
            0x828BCB3C => {
    //   block [0x828BCB3C..0x828BCB5C)
	// 828BCB3C: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BCB40: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCB44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BCB48: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 828BCB4C: 7D4B3670  srawi r11, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 6) as i64;
	// 828BCB50: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828BCB54: 419A0008  beq cr6, 0x828bcb5c
	if ctx.cr[6].eq {
	pc = 0x828BCB5C; continue 'dispatch;
	}
	// 828BCB58: 4B95F1E1  bl 0x8221bd38
	ctx.lr = 0x828BCB5C;
	sub_8221BD38(ctx, base);
	pc = 0x828BCB5C; continue 'dispatch;
            }
            0x828BCB5C => {
    //   block [0x828BCB5C..0x828BCB80)
	// 828BCB5C: 57AA3032  slwi r10, r29, 6
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BCB60: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828BCB64: 57EB3032  slwi r11, r31, 6
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BCB68: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 828BCB6C: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828BCB70: 915C000C  stw r10, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828BCB74: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828BCB78: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BCB7C: 483EC8DC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x828BCB80 => {
    //   block [0x828BCB80..0x828BCBA8)
	// 828BCB80: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 828BCB84: 7D632850  subf r11, r3, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[3].s64;
	// 828BCB88: 7D6A3670  srawi r10, r11, 6
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 6) as i64;
	// 828BCB8C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BCB90: 409800F4  bge cr6, 0x828bcc84
	if !ctx.cr[6].lt {
	pc = 0x828BCC84; continue 'dispatch;
	}
	// 828BCB94: 57E63032  slwi r6, r31, 6
	ctx.r[6].u32 = ctx.r[31].u32.wrapping_shl(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828BCB98: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828BCB9C: 7D261A14  add r9, r6, r3
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 828BCBA0: 419A0044  beq cr6, 0x828bcbe4
	if ctx.cr[6].eq {
	pc = 0x828BCBE4; continue 'dispatch;
	}
	// 828BCBA4: 7CE64850  subf r7, r6, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	pc = 0x828BCBA8; continue 'dispatch;
            }
            0x828BCBA8 => {
    //   block [0x828BCBA8..0x828BCBC0)
	// 828BCBA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BCBAC: 419A0028  beq cr6, 0x828bcbd4
	if ctx.cr[6].eq {
	pc = 0x828BCBD4; continue 'dispatch;
	}
	// 828BCBB0: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 828BCBB4: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 828BCBB8: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 828BCBBC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x828BCBC0; continue 'dispatch;
            }
            0x828BCBC0 => {
    //   block [0x828BCBC0..0x828BCBD4)
	// 828BCBC0: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BCBC4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BCBC8: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 828BCBCC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCBD0: 4200FFF0  bdnz 0x828bcbc0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCBC0; continue 'dispatch;
	}
	pc = 0x828BCBD4; continue 'dispatch;
            }
            0x828BCBD4 => {
    //   block [0x828BCBD4..0x828BCBE4)
	// 828BCBD4: 38E70040  addi r7, r7, 0x40
	ctx.r[7].s64 = ctx.r[7].s64 + 64;
	// 828BCBD8: 39290040  addi r9, r9, 0x40
	ctx.r[9].s64 = ctx.r[9].s64 + 64;
	// 828BCBDC: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828BCBE0: 409AFFC8  bne cr6, 0x828bcba8
	if !ctx.cr[6].eq {
	pc = 0x828BCBA8; continue 'dispatch;
	}
	pc = 0x828BCBE4; continue 'dispatch;
            }
            0x828BCBE4 => {
    //   block [0x828BCBE4..0x828BCBF8)
	// 828BCBE4: 811C0008  lwz r8, 8(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCBE8: 7D634050  subf r11, r3, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[3].s64;
	// 828BCBEC: 7D6A3670  srawi r10, r11, 6
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 6) as i64;
	// 828BCBF0: 7CEAF851  subf. r7, r10, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 828BCBF4: 4182003C  beq 0x828bcc30
	if ctx.cr[0].eq {
	pc = 0x828BCC30; continue 'dispatch;
	}
	pc = 0x828BCBF8; continue 'dispatch;
            }
            0x828BCBF8 => {
    //   block [0x828BCBF8..0x828BCC10)
	// 828BCBF8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828BCBFC: 419A0028  beq cr6, 0x828bcc24
	if ctx.cr[6].eq {
	pc = 0x828BCC24; continue 'dispatch;
	}
	// 828BCC00: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828BCC04: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 828BCC08: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 828BCC0C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x828BCC10; continue 'dispatch;
            }
            0x828BCC10 => {
    //   block [0x828BCC10..0x828BCC24)
	// 828BCC10: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BCC14: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BCC18: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 828BCC1C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCC20: 4200FFF0  bdnz 0x828bcc10
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCC10; continue 'dispatch;
	}
	pc = 0x828BCC24; continue 'dispatch;
            }
            0x828BCC24 => {
    //   block [0x828BCC24..0x828BCC30)
	// 828BCC24: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 828BCC28: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 828BCC2C: 4082FFCC  bne 0x828bcbf8
	if !ctx.cr[0].eq {
	pc = 0x828BCBF8; continue 'dispatch;
	}
	pc = 0x828BCC30; continue 'dispatch;
            }
            0x828BCC30 => {
    //   block [0x828BCC30..0x828BCC4C)
	// 828BCC30: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCC34: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828BCC38: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 828BCC3C: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 828BCC40: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828BCC44: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828BCC48: 419A0114  beq cr6, 0x828bcd5c
	if ctx.cr[6].eq {
	pc = 0x828BCD5C; continue 'dispatch;
	}
	pc = 0x828BCC4C; continue 'dispatch;
            }
            0x828BCC4C => {
    //   block [0x828BCC4C..0x828BCC5C)
	// 828BCC4C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828BCC50: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 828BCC54: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 828BCC58: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x828BCC5C; continue 'dispatch;
            }
            0x828BCC5C => {
    //   block [0x828BCC5C..0x828BCC84)
	// 828BCC5C: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BCC60: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BCC64: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 828BCC68: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCC6C: 4200FFF0  bdnz 0x828bcc5c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCC5C; continue 'dispatch;
	}
	// 828BCC70: 39290040  addi r9, r9, 0x40
	ctx.r[9].s64 = ctx.r[9].s64 + 64;
	// 828BCC74: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828BCC78: 409AFFD4  bne cr6, 0x828bcc4c
	if !ctx.cr[6].eq {
	pc = 0x828BCC4C; continue 'dispatch;
	}
	// 828BCC7C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BCC80: 483EC7D8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x828BCC84 => {
    //   block [0x828BCC84..0x828BCC9C)
	// 828BCC84: 57E43032  slwi r4, r31, 6
	ctx.r[4].u32 = ctx.r[31].u32.wrapping_shl(6);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828BCC88: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 828BCC8C: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 828BCC90: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 828BCC94: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828BCC98: 419A0040  beq cr6, 0x828bccd8
	if ctx.cr[6].eq {
	pc = 0x828BCCD8; continue 'dispatch;
	}
	pc = 0x828BCC9C; continue 'dispatch;
            }
            0x828BCC9C => {
    //   block [0x828BCC9C..0x828BCCB4)
	// 828BCC9C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828BCCA0: 419A0028  beq cr6, 0x828bccc8
	if ctx.cr[6].eq {
	pc = 0x828BCCC8; continue 'dispatch;
	}
	// 828BCCA4: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 828BCCA8: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 828BCCAC: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 828BCCB0: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	pc = 0x828BCCB4; continue 'dispatch;
            }
            0x828BCCB4 => {
    //   block [0x828BCCB4..0x828BCCC8)
	// 828BCCB4: E8CA0000  ld r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 828BCCB8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCCBC: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 828BCCC0: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 828BCCC4: 4200FFF0  bdnz 0x828bccb4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCCB4; continue 'dispatch;
	}
	pc = 0x828BCCC8; continue 'dispatch;
            }
            0x828BCCC8 => {
    //   block [0x828BCCC8..0x828BCCD8)
	// 828BCCC8: 38E70040  addi r7, r7, 0x40
	ctx.r[7].s64 = ctx.r[7].s64 + 64;
	// 828BCCCC: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 828BCCD0: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828BCCD4: 409AFFC8  bne cr6, 0x828bcc9c
	if !ctx.cr[6].eq {
	pc = 0x828BCC9C; continue 'dispatch;
	}
	pc = 0x828BCCD8; continue 'dispatch;
            }
            0x828BCCD8 => {
    //   block [0x828BCCD8..0x828BCCE8)
	// 828BCCD8: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828BCCDC: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BCCE0: 419A003C  beq cr6, 0x828bcd1c
	if ctx.cr[6].eq {
	pc = 0x828BCD1C; continue 'dispatch;
	}
	// 828BCCE4: 7D045A14  add r8, r4, r11
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	pc = 0x828BCCE8; continue 'dispatch;
            }
            0x828BCCE8 => {
    //   block [0x828BCCE8..0x828BCD00)
	// 828BCCE8: 396BFFC0  addi r11, r11, -0x40
	ctx.r[11].s64 = ctx.r[11].s64 + -64;
	// 828BCCEC: 3908FFC0  addi r8, r8, -0x40
	ctx.r[8].s64 = ctx.r[8].s64 + -64;
	// 828BCCF0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828BCCF4: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 828BCCF8: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 828BCCFC: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x828BCD00; continue 'dispatch;
            }
            0x828BCD00 => {
    //   block [0x828BCD00..0x828BCD1C)
	// 828BCD00: E8EA0000  ld r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 828BCD04: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCD08: F8E90000  std r7, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 828BCD0C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 828BCD10: 4200FFF0  bdnz 0x828bcd00
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCD00; continue 'dispatch;
	}
	// 828BCD14: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828BCD18: 409AFFD0  bne cr6, 0x828bcce8
	if !ctx.cr[6].eq {
	pc = 0x828BCCE8; continue 'dispatch;
	}
	pc = 0x828BCD1C; continue 'dispatch;
            }
            0x828BCD1C => {
    //   block [0x828BCD1C..0x828BCD2C)
	// 828BCD1C: 7CE41A14  add r7, r4, r3
	ctx.r[7].u64 = ctx.r[4].u64 + ctx.r[3].u64;
	// 828BCD20: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828BCD24: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828BCD28: 419A0034  beq cr6, 0x828bcd5c
	if ctx.cr[6].eq {
	pc = 0x828BCD5C; continue 'dispatch;
	}
	pc = 0x828BCD2C; continue 'dispatch;
            }
            0x828BCD2C => {
    //   block [0x828BCD2C..0x828BCD3C)
	// 828BCD2C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828BCD30: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 828BCD34: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 828BCD38: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x828BCD3C; continue 'dispatch;
            }
            0x828BCD3C => {
    //   block [0x828BCD3C..0x828BCD5C)
	// 828BCD3C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828BCD40: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828BCD44: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 828BCD48: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BCD4C: 4200FFF0  bdnz 0x828bcd3c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828BCD3C; continue 'dispatch;
	}
	// 828BCD50: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 828BCD54: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828BCD58: 409AFFD4  bne cr6, 0x828bcd2c
	if !ctx.cr[6].eq {
	pc = 0x828BCD2C; continue 'dispatch;
	}
	pc = 0x828BCD5C; continue 'dispatch;
            }
            0x828BCD5C => {
    //   block [0x828BCD5C..0x828BCD64)
	// 828BCD5C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BCD60: 483EC6F8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BCD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BCD68 size=756
    let mut pc: u32 = 0x828BCD68;
    'dispatch: loop {
        match pc {
            0x828BCD68 => {
    //   block [0x828BCD68..0x828BCDA8)
	// 828BCD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BCD6C: 483EC68D  bl 0x82ca93f8
	ctx.lr = 0x828BCD70;
	sub_82CA93D0(ctx, base);
	// 828BCD70: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BCD74: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCD78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BCD7C: F8810108  std r4, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[4].u64 ) };
	// 828BCD80: 38860010  addi r4, r6, 0x10
	ctx.r[4].s64 = ctx.r[6].s64 + 16;
	// 828BCD84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BCD88: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BCD8C: 4BFFF7A5  bl 0x828bc530
	ctx.lr = 0x828BCD90;
	sub_828BC530(ctx, base);
	// 828BCD90: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BCD94: 3B000050  li r24, 0x50
	ctx.r[24].s64 = 80;
	// 828BCD98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BCD9C: 409A000C  bne cr6, 0x828bcda8
	if !ctx.cr[6].eq {
	pc = 0x828BCDA8; continue 'dispatch;
	}
	// 828BCDA0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828BCDA4: 48000010  b 0x828bcdb4
	pc = 0x828BCDB4; continue 'dispatch;
            }
            0x828BCDA8 => {
    //   block [0x828BCDA8..0x828BCDB4)
	// 828BCDA8: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BCDAC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BCDB0: 7D29C3D6  divw r9, r9, r24
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	pc = 0x828BCDB4; continue 'dispatch;
            }
            0x828BCDB4 => {
    //   block [0x828BCDB4..0x828BCDE8)
	// 828BCDB4: 837C0008  lwz r27, 8(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCDB8: 3D400333  lis r10, 0x333
	ctx.r[10].s64 = 53673984;
	// 828BCDBC: 7D0BD850  subf r8, r11, r27
	ctx.r[8].s64 = ctx.r[27].s64 - ctx.r[11].s64;
	// 828BCDC0: 614A3333  ori r10, r10, 0x3333
	ctx.r[10].u64 = ctx.r[10].u64 | 13107;
	// 828BCDC4: 7D68C3D6  divw r11, r8, r24
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[24].s32;
	// 828BCDC8: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BCDCC: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 828BCDD0: 40980018  bge cr6, 0x828bcde8
	if !ctx.cr[6].lt {
	pc = 0x828BCDE8; continue 'dispatch;
	}
	// 828BCDD4: 4818A6F5  bl 0x82a474c8
	ctx.lr = 0x828BCDD8;
	sub_82A474C8(ctx, base);
	// 828BCDD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BCDDC: 4B957FFD  bl 0x82214dd8
	ctx.lr = 0x828BCDE0;
	sub_82214DD8(ctx, base);
	// 828BCDE0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828BCDE4: 483EC664  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x828BCDE8 => {
    //   block [0x828BCDE8..0x828BCE0C)
	// 828BCDE8: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 828BCDEC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BCDF0: 40980134  bge cr6, 0x828bcf24
	if !ctx.cr[6].lt {
	pc = 0x828BCF24; continue 'dispatch;
	}
	// 828BCDF4: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BCDF8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828BCDFC: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BCE00: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BCE04: 41980008  blt cr6, 0x828bce0c
	if ctx.cr[6].lt {
	pc = 0x828BCE0C; continue 'dispatch;
	}
	// 828BCE08: 7F2B4A14  add r25, r11, r9
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x828BCE0C; continue 'dispatch;
            }
            0x828BCE0C => {
    //   block [0x828BCE0C..0x828BCE18)
	// 828BCE0C: 7F194040  cmplw cr6, r25, r8
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BCE10: 40980008  bge cr6, 0x828bce18
	if !ctx.cr[6].lt {
	pc = 0x828BCE18; continue 'dispatch;
	}
	// 828BCE14: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	pc = 0x828BCE18; continue 'dispatch;
            }
            0x828BCE18 => {
    //   block [0x828BCE18..0x828BCE3C)
	// 828BCE18: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828BCE1C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BCE20: 481DB129  bl 0x82a97f48
	ctx.lr = 0x828BCE24;
	sub_82A97F48(ctx, base);
	// 828BCE24: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BCE28: 83A1010C  lwz r29, 0x10c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 828BCE2C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828BCE30: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BCE34: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 828BCE38: 419A0030  beq cr6, 0x828bce68
	if ctx.cr[6].eq {
	pc = 0x828BCE68; continue 'dispatch;
	}
	pc = 0x828BCE3C; continue 'dispatch;
            }
            0x828BCE3C => {
    //   block [0x828BCE3C..0x828BCE58)
	// 828BCE3C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BCE40: 419A0018  beq cr6, 0x828bce58
	if ctx.cr[6].eq {
	pc = 0x828BCE58; continue 'dispatch;
	}
	// 828BCE44: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCE48: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 828BCE4C: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828BCE50: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BCE54: 4BFFF6DD  bl 0x828bc530
	ctx.lr = 0x828BCE58;
	sub_828BC530(ctx, base);
	pc = 0x828BCE58; continue 'dispatch;
            }
            0x828BCE58 => {
    //   block [0x828BCE58..0x828BCE68)
	// 828BCE58: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 828BCE5C: 3BDE0050  addi r30, r30, 0x50
	ctx.r[30].s64 = ctx.r[30].s64 + 80;
	// 828BCE60: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BCE64: 409AFFD8  bne cr6, 0x828bce3c
	if !ctx.cr[6].eq {
	pc = 0x828BCE3C; continue 'dispatch;
	}
	pc = 0x828BCE68; continue 'dispatch;
            }
            0x828BCE68 => {
    //   block [0x828BCE68..0x828BCE90)
	// 828BCE68: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828BCE6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828BCE70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BCE74: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BCE78: 4BFFF729  bl 0x828bc5a0
	ctx.lr = 0x828BCE7C;
	sub_828BC5A0(ctx, base);
	// 828BCE7C: 837C0008  lwz r27, 8(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCE80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BCE84: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BCE88: 419A0034  beq cr6, 0x828bcebc
	if ctx.cr[6].eq {
	pc = 0x828BCEBC; continue 'dispatch;
	}
	// 828BCE8C: 7FC3E850  subf r30, r3, r29
	ctx.r[30].s64 = ctx.r[29].s64 - ctx.r[3].s64;
	pc = 0x828BCE90; continue 'dispatch;
            }
            0x828BCE90 => {
    //   block [0x828BCE90..0x828BCEAC)
	// 828BCE90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BCE94: 419A0018  beq cr6, 0x828bceac
	if ctx.cr[6].eq {
	pc = 0x828BCEAC; continue 'dispatch;
	}
	// 828BCE98: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828BCE9C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828BCEA0: 7C83F214  add r4, r3, r30
	ctx.r[4].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 828BCEA4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BCEA8: 4BFFF689  bl 0x828bc530
	ctx.lr = 0x828BCEAC;
	sub_828BC530(ctx, base);
	pc = 0x828BCEAC; continue 'dispatch;
            }
            0x828BCEAC => {
    //   block [0x828BCEAC..0x828BCEBC)
	// 828BCEAC: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 828BCEB0: 7D7FF214  add r11, r31, r30
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 828BCEB4: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BCEB8: 409AFFD8  bne cr6, 0x828bce90
	if !ctx.cr[6].eq {
	pc = 0x828BCE90; continue 'dispatch;
	}
	pc = 0x828BCEBC; continue 'dispatch;
            }
            0x828BCEBC => {
    //   block [0x828BCEBC..0x828BCEE8)
	// 828BCEBC: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BCEC0: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCEC4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828BCEC8: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 828BCECC: 7D6BC3D6  divw r11, r11, r24
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 828BCED0: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 828BCED4: 419A0014  beq cr6, 0x828bcee8
	if ctx.cr[6].eq {
	pc = 0x828BCEE8; continue 'dispatch;
	}
	// 828BCED8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BCEDC: 4BFFF5E5  bl 0x828bc4c0
	ctx.lr = 0x828BCEE0;
	sub_828BC4C0(ctx, base);
	// 828BCEE0: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BCEE4: 4B95EE55  bl 0x8221bd38
	ctx.lr = 0x828BCEE8;
	sub_8221BD38(ctx, base);
	pc = 0x828BCEE8; continue 'dispatch;
            }
            0x828BCEE8 => {
    //   block [0x828BCEE8..0x828BCF24)
	// 828BCEE8: 572B103A  slwi r11, r25, 2
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BCEEC: 935C0004  stw r26, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 828BCEF0: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BCEF4: 7D795A14  add r11, r25, r11
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 828BCEF8: 7D3F5214  add r9, r31, r10
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 828BCEFC: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BCF00: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BCF04: 7D0AD214  add r8, r10, r26
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 828BCF08: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 828BCF0C: 911C000C  stw r8, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 828BCF10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BCF14: 90FC0008  stw r7, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 828BCF18: 4B957EC1  bl 0x82214dd8
	ctx.lr = 0x828BCF1C;
	sub_82214DD8(ctx, base);
	// 828BCF1C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828BCF20: 483EC528  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x828BCF24 => {
    //   block [0x828BCF24..0x828BCF48)
	// 828BCF24: 8341010C  lwz r26, 0x10c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 828BCF28: 7D7AD850  subf r11, r26, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[26].s64;
	// 828BCF2C: 7D4BC3D6  divw r10, r11, r24
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 828BCF30: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 828BCF34: 40980070  bge cr6, 0x828bcfa4
	if !ctx.cr[6].lt {
	pc = 0x828BCFA4; continue 'dispatch;
	}
	// 828BCF38: 3BDA0050  addi r30, r26, 0x50
	ctx.r[30].s64 = ctx.r[26].s64 + 80;
	// 828BCF3C: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BCF40: 419A0034  beq cr6, 0x828bcf74
	if ctx.cr[6].eq {
	pc = 0x828BCF74; continue 'dispatch;
	}
	// 828BCF44: 3BFEFFB0  addi r31, r30, -0x50
	ctx.r[31].s64 = ctx.r[30].s64 + -80;
	pc = 0x828BCF48; continue 'dispatch;
            }
            0x828BCF48 => {
    //   block [0x828BCF48..0x828BCF64)
	// 828BCF48: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BCF4C: 419A0018  beq cr6, 0x828bcf64
	if ctx.cr[6].eq {
	pc = 0x828BCF64; continue 'dispatch;
	}
	// 828BCF50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCF54: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 828BCF58: 3883FFB0  addi r4, r3, -0x50
	ctx.r[4].s64 = ctx.r[3].s64 + -80;
	// 828BCF5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BCF60: 4BFFF5D1  bl 0x828bc530
	ctx.lr = 0x828BCF64;
	sub_828BC530(ctx, base);
	pc = 0x828BCF64; continue 'dispatch;
            }
            0x828BCF64 => {
    //   block [0x828BCF64..0x828BCF74)
	// 828BCF64: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 828BCF68: 3BDE0050  addi r30, r30, 0x50
	ctx.r[30].s64 = ctx.r[30].s64 + 80;
	// 828BCF6C: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BCF70: 409AFFD8  bne cr6, 0x828bcf48
	if !ctx.cr[6].eq {
	pc = 0x828BCF48; continue 'dispatch;
	}
	pc = 0x828BCF74; continue 'dispatch;
            }
            0x828BCF74 => {
    //   block [0x828BCF74..0x828BCFA4)
	// 828BCF74: 809C0008  lwz r4, 8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCF78: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828BCF7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BCF80: 7D7A2050  subf r11, r26, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[26].s64;
	// 828BCF84: 7D4BC3D6  divw r10, r11, r24
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 828BCF88: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 828BCF8C: 4BFFF615  bl 0x828bc5a0
	ctx.lr = 0x828BCF90;
	sub_828BC5A0(ctx, base);
	// 828BCF90: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BCF94: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 828BCF98: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828BCF9C: 388BFFB0  addi r4, r11, -0x50
	ctx.r[4].s64 = ctx.r[11].s64 + -80;
	// 828BCFA0: 480000A0  b 0x828bd040
	pc = 0x828BD040; continue 'dispatch;
            }
            0x828BCFA4 => {
    //   block [0x828BCFA4..0x828BCFB8)
	// 828BCFA4: 3BDBFFB0  addi r30, r27, -0x50
	ctx.r[30].s64 = ctx.r[27].s64 + -80;
	// 828BCFA8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828BCFAC: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 828BCFB0: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BCFB4: 419A0030  beq cr6, 0x828bcfe4
	if ctx.cr[6].eq {
	pc = 0x828BCFE4; continue 'dispatch;
	}
	pc = 0x828BCFB8; continue 'dispatch;
            }
            0x828BCFB8 => {
    //   block [0x828BCFB8..0x828BCFD4)
	// 828BCFB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BCFBC: 419A0018  beq cr6, 0x828bcfd4
	if ctx.cr[6].eq {
	pc = 0x828BCFD4; continue 'dispatch;
	}
	// 828BCFC0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BCFC4: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 828BCFC8: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828BCFCC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BCFD0: 4BFFF561  bl 0x828bc530
	ctx.lr = 0x828BCFD4;
	sub_828BC530(ctx, base);
	pc = 0x828BCFD4; continue 'dispatch;
            }
            0x828BCFD4 => {
    //   block [0x828BCFD4..0x828BCFE4)
	// 828BCFD4: 3BBD0050  addi r29, r29, 0x50
	ctx.r[29].s64 = ctx.r[29].s64 + 80;
	// 828BCFD8: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 828BCFDC: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BCFE0: 409AFFD8  bne cr6, 0x828bcfb8
	if !ctx.cr[6].eq {
	pc = 0x828BCFB8; continue 'dispatch;
	}
	pc = 0x828BCFE4; continue 'dispatch;
            }
            0x828BCFE4 => {
    //   block [0x828BCFE4..0x828BD03C)
	// 828BCFE4: 93FC0008  stw r31, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828BCFE8: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BCFEC: 419A0050  beq cr6, 0x828bd03c
	if ctx.cr[6].eq {
	pc = 0x828BD03C; continue 'dispatch;
	}
	// 828BCFF0: 3BFE0080  addi r31, r30, 0x80
	ctx.r[31].s64 = ctx.r[30].s64 + 128;
	// 828BCFF4: 3BA0FFB0  li r29, -0x50
	ctx.r[29].s64 = -80;
	// 828BCFF8: 3BDEFFB0  addi r30, r30, -0x50
	ctx.r[30].s64 = ctx.r[30].s64 + -80;
	// 828BCFFC: 3BFFFFB0  addi r31, r31, -0x50
	ctx.r[31].s64 = ctx.r[31].s64 + -80;
	// 828BD000: 389FFF90  addi r4, r31, -0x70
	ctx.r[4].s64 = ctx.r[31].s64 + -112;
	// 828BD004: 387FFFE0  addi r3, r31, -0x20
	ctx.r[3].s64 = ctx.r[31].s64 + -32;
	// 828BD008: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD00C: 917FFFD0  stw r11, -0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-48 as u32), ctx.r[11].u32 ) };
	// 828BD010: 4B9A8191  bl 0x822651a0
	ctx.lr = 0x828BD014;
	sub_822651A0(ctx, base);
	// 828BD014: E95FFFA0  ld r10, -0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(-96 as u32) ) };
	// 828BD018: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BD01C: F95FFFF0  std r10, -0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 828BD020: E93FFFA8  ld r9, -0x58(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(-88 as u32) ) };
	// 828BD024: F93FFFF8  std r9, -8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[9].u64 ) };
	pc = 0x828BD03C; continue 'dispatch;
            }
            0x828BD03C => {
    //   block [0x828BD03C..0x828BD040)
	// 828BD03C: 389A0050  addi r4, r26, 0x50
	ctx.r[4].s64 = ctx.r[26].s64 + 80;
	pc = 0x828BD040; continue 'dispatch;
            }
            0x828BD040 => {
    //   block [0x828BD040..0x828BD05C)
	// 828BD040: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828BD044: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828BD048: 48000019  bl 0x828bd060
	ctx.lr = 0x828BD04C;
	sub_828BD060(ctx, base);
	// 828BD04C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BD050: 4B957D89  bl 0x82214dd8
	ctx.lr = 0x828BD054;
	sub_82214DD8(ctx, base);
	// 828BD054: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828BD058: 483EC3F0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD060 size=120
    let mut pc: u32 = 0x828BD060;
    'dispatch: loop {
        match pc {
            0x828BD060 => {
    //   block [0x828BD060..0x828BD0D0)
	// 828BD060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD064: 483EC39D  bl 0x82ca9400
	ctx.lr = 0x828BD068;
	sub_82CA93D0(ctx, base);
	// 828BD068: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD06C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828BD070: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828BD074: 7F03D040  cmplw cr6, r3, r26
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BD078: 419A0058  beq cr6, 0x828bd0d0
	if ctx.cr[6].eq {
	pc = 0x828BD0D0; continue 'dispatch;
	}
	// 828BD07C: 3BDC0010  addi r30, r28, 0x10
	ctx.r[30].s64 = ctx.r[28].s64 + 16;
	// 828BD080: 3BE30030  addi r31, r3, 0x30
	ctx.r[31].s64 = ctx.r[3].s64 + 48;
	// 828BD084: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 828BD088: 3B7E0020  addi r27, r30, 0x20
	ctx.r[27].s64 = ctx.r[30].s64 + 32;
	// 828BD08C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD090: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD094: 387FFFE0  addi r3, r31, -0x20
	ctx.r[3].s64 = ctx.r[31].s64 + -32;
	// 828BD098: 917FFFD0  stw r11, -0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-48 as u32), ctx.r[11].u32 ) };
	// 828BD09C: 4B9A8105  bl 0x822651a0
	ctx.lr = 0x828BD0A0;
	sub_822651A0(ctx, base);
	// 828BD0A0: E95D0000  ld r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 828BD0A4: F95FFFF0  std r10, -0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 828BD0A8: E93D0008  ld r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 828BD0AC: F93FFFF8  std r9, -8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[9].u64 ) };
	pc = 0x828BD0D0; continue 'dispatch;
            }
            0x828BD0D0 => {
    //   block [0x828BD0D0..0x828BD0D8)
	// 828BD0D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BD0D4: 483EC37C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BD0D8 size=436
    let mut pc: u32 = 0x828BD0D8;
    'dispatch: loop {
        match pc {
            0x828BD0D8 => {
    //   block [0x828BD0D8..0x828BD118)
	// 828BD0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD0DC: 483EC31D  bl 0x82ca93f8
	ctx.lr = 0x828BD0E0;
	sub_82CA93D0(ctx, base);
	// 828BD0E0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD0E4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BD0E8: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 828BD0EC: FB610110  std r27, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[27].u64 ) };
	// 828BD0F0: 3BC00050  li r30, 0x50
	ctx.r[30].s64 = 80;
	// 828BD0F4: FB010118  std r24, 0x118(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[24].u64 ) };
	// 828BD0F8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828BD0FC: 83A10114  lwz r29, 0x114(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 828BD100: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 828BD104: 8341011C  lwz r26, 0x11c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 828BD108: 7D7DD050  subf r11, r29, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[29].s64;
	// 828BD10C: 7D6BF3D6  divw r11, r11, r30
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[30].s32;
	// 828BD110: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 828BD114: 409900A0  ble cr6, 0x828bd1b4
	if !ctx.cr[6].gt {
	pc = 0x828BD1B4; continue 'dispatch;
	}
	pc = 0x828BD118; continue 'dispatch;
            }
            0x828BD118 => {
    //   block [0x828BD118..0x828BD18C)
	// 828BD118: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828BD11C: 409900B8  ble cr6, 0x828bd1d4
	if !ctx.cr[6].gt {
	pc = 0x828BD1D4; continue 'dispatch;
	}
	// 828BD120: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828BD124: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 828BD128: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828BD12C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BD130: 48000161  bl 0x828bd290
	ctx.lr = 0x828BD134;
	sub_828BD290(ctx, base);
	// 828BD134: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 828BD138: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BD13C: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 828BD140: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BD144: 7CE9D050  subf r7, r9, r26
	ctx.r[7].s64 = ctx.r[26].s64 - ctx.r[9].s64;
	// 828BD148: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BD14C: 7CDD4050  subf r6, r29, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[29].s64;
	// 828BD150: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 828BD154: 7CA7F3D6  divw r5, r7, r30
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[30].s32;
	// 828BD158: 7C86F3D6  divw r4, r6, r30
	ctx.r[4].s32 = ctx.r[6].s32 / ctx.r[30].s32;
	// 828BD15C: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BD160: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 828BD164: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828BD168: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BD16C: 40980020  bge cr6, 0x828bd18c
	if !ctx.cr[6].lt {
	pc = 0x828BD18C; continue 'dispatch;
	}
	// 828BD170: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BD174: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD178: 4BFFFF61  bl 0x828bd0d8
	ctx.lr = 0x828BD17C;
	sub_828BD0D8(ctx, base);
	// 828BD17C: EB610058  ld r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD180: FB610110  std r27, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[27].u64 ) };
	// 828BD184: 83A10114  lwz r29, 0x114(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 828BD188: 4800001C  b 0x828bd1a4
	pc = 0x828BD1A4; continue 'dispatch;
            }
            0x828BD18C => {
    //   block [0x828BD18C..0x828BD1A4)
	// 828BD18C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828BD190: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD194: 4BFFFF45  bl 0x828bd0d8
	ctx.lr = 0x828BD198;
	sub_828BD0D8(ctx, base);
	// 828BD198: EB010050  ld r24, 0x50(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD19C: FB010118  std r24, 0x118(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[24].u64 ) };
	// 828BD1A0: 8341011C  lwz r26, 0x11c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	pc = 0x828BD1A4; continue 'dispatch;
            }
            0x828BD1A4 => {
    //   block [0x828BD1A4..0x828BD1B4)
	// 828BD1A4: 7D7DD050  subf r11, r29, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[29].s64;
	// 828BD1A8: 7D6BF3D6  divw r11, r11, r30
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[30].s32;
	// 828BD1AC: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 828BD1B0: 4199FF68  bgt cr6, 0x828bd118
	if ctx.cr[6].gt {
	pc = 0x828BD118; continue 'dispatch;
	}
	pc = 0x828BD1B4; continue 'dispatch;
            }
            0x828BD1B4 => {
    //   block [0x828BD1B4..0x828BD1CC)
	// 828BD1B4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828BD1B8: 40990014  ble cr6, 0x828bd1cc
	if !ctx.cr[6].gt {
	pc = 0x828BD1CC; continue 'dispatch;
	}
	// 828BD1BC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828BD1C0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828BD1C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BD1C8: 48000331  bl 0x828bd4f8
	ctx.lr = 0x828BD1CC;
	sub_828BD4F8(ctx, base);
	pc = 0x828BD1CC; continue 'dispatch;
            }
            0x828BD1CC => {
    //   block [0x828BD1CC..0x828BD1D4)
	// 828BD1CC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 828BD1D0: 483EC278  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x828BD1D4 => {
    //   block [0x828BD1D4..0x828BD274)
	// 828BD1D4: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 828BD1D8: 4099FFDC  ble cr6, 0x828bd1b4
	if !ctx.cr[6].gt {
	pc = 0x828BD1B4; continue 'dispatch;
	}
	// 828BD1DC: 7D7DD050  subf r11, r29, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[29].s64;
	// 828BD1E0: 7F4BF3D6  divw r26, r11, r30
	ctx.r[26].s32 = ctx.r[11].s32 / ctx.r[30].s32;
	// 828BD1E4: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 828BD1E8: 4099008C  ble cr6, 0x828bd274
	if !ctx.cr[6].gt {
	pc = 0x828BD274; continue 'dispatch;
	}
	// 828BD1EC: 7F4B0E70  srawi r11, r26, 1
	ctx.xer.ca = (ctx.r[26].s32 < 0) && ((ctx.r[26].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[26].s32 >> 1) as i64;
	// 828BD1F0: 7FCB0195  addze. r30, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[30].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828BD1F4: 40810080  ble 0x828bd274
	if !ctx.cr[0].gt {
	pc = 0x828BD274; continue 'dispatch;
	}
	// 828BD1F8: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD1FC: 3B200020  li r25, 0x20
	ctx.r[25].s64 = 32;
	// 828BD200: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828BD204: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD208: 7FEBEA14  add r31, r11, r29
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 828BD20C: 3BFFFFB0  addi r31, r31, -0x50
	ctx.r[31].s64 = ctx.r[31].s64 + -80;
	// 828BD210: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828BD214: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 828BD218: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 828BD21C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BD220: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD224: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828BD228: 4B933019  bl 0x821f0240
	ctx.lr = 0x828BD22C;
	sub_821F0240(ctx, base);
	// 828BD22C: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	pc = 0x828BD274; continue 'dispatch;
            }
            0x828BD274 => {
    //   block [0x828BD274..0x828BD28C)
	// 828BD274: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828BD278: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828BD27C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BD280: 48000511  bl 0x828bd790
	ctx.lr = 0x828BD284;
	sub_828BD790(ctx, base);
	// 828BD284: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 828BD288: 483EC1C0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BD290 size=616
    let mut pc: u32 = 0x828BD290;
    'dispatch: loop {
        match pc {
            0x828BD290 => {
    //   block [0x828BD290..0x828BD320)
	// 828BD290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD294: 483EC161  bl 0x82ca93f4
	ctx.lr = 0x828BD298;
	sub_82CA93D0(ctx, base);
	// 828BD298: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD29C: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 828BD2A0: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 828BD2A4: 832100EC  lwz r25, 0xec(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 828BD2A8: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828BD2AC: F8A100F0  std r5, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[5].u64 ) };
	// 828BD2B0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828BD2B4: 830100F4  lwz r24, 0xf4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 828BD2B8: 3958FFB0  addi r10, r24, -0x50
	ctx.r[10].s64 = ctx.r[24].s64 + -80;
	// 828BD2BC: 7D39C050  subf r9, r25, r24
	ctx.r[9].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 828BD2C0: F8A10068  std r5, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u64 ) };
	// 828BD2C4: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828BD2C8: 7D095BD6  divw r8, r9, r11
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 828BD2CC: F8810060  std r4, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u64 ) };
	// 828BD2D0: 7D070E70  srawi r7, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 828BD2D4: 7D670194  addze r11, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[11].s64 = tmp.s64;
	// 828BD2D8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BD2DC: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BD2E0: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD2E4: 7FEBCA14  add r31, r11, r25
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 828BD2E8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828BD2EC: EBC10060  ld r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BD2F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD2F4: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828BD2F8: 480002F1  bl 0x828bd5e8
	ctx.lr = 0x828BD2FC;
	sub_828BD5E8(ctx, base);
	// 828BD2FC: 395F0050  addi r10, r31, 0x50
	ctx.r[10].s64 = ctx.r[31].s64 + 80;
	// 828BD300: FBC10068  std r30, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u64 ) };
	// 828BD304: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 828BD308: 7F19F840  cmplw cr6, r25, r31
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BD30C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828BD310: E8610068  ld r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828BD314: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BD318: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 828BD31C: 40980034  bge cr6, 0x828bd350
	if !ctx.cr[6].lt {
	pc = 0x828BD350; continue 'dispatch;
	}
	pc = 0x828BD320; continue 'dispatch;
            }
            0x828BD320 => {
    //   block [0x828BD320..0x828BD350)
	// 828BD320: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD324: 813DFFB0  lwz r9, -0x50(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-80 as u32) ) } as u64;
	// 828BD328: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BD32C: 41980024  blt cr6, 0x828bd350
	if ctx.cr[6].lt {
	pc = 0x828BD350; continue 'dispatch;
	}
	// 828BD330: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828BD334: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BD338: 41980018  blt cr6, 0x828bd350
	if ctx.cr[6].lt {
	pc = 0x828BD350; continue 'dispatch;
	}
	// 828BD33C: 3BBDFFB0  addi r29, r29, -0x50
	ctx.r[29].s64 = ctx.r[29].s64 + -80;
	// 828BD340: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828BD344: 7F19E840  cmplw cr6, r25, r29
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BD348: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD34C: 4198FFD4  blt cr6, 0x828bd320
	if ctx.cr[6].lt {
	pc = 0x828BD320; continue 'dispatch;
	}
	pc = 0x828BD350; continue 'dispatch;
            }
            0x828BD350 => {
    //   block [0x828BD350..0x828BD360)
	// 828BD350: 8341005C  lwz r26, 0x5c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BD354: 7F0AC040  cmplw cr6, r10, r24
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828BD358: 40980028  bge cr6, 0x828bd380
	if !ctx.cr[6].lt {
	pc = 0x828BD380; continue 'dispatch;
	}
	// 828BD35C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828BD360; continue 'dispatch;
            }
            0x828BD360 => {
    //   block [0x828BD360..0x828BD380)
	// 828BD360: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD364: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BD368: 41990018  bgt cr6, 0x828bd380
	if ctx.cr[6].gt {
	pc = 0x828BD380; continue 'dispatch;
	}
	// 828BD36C: 41980014  blt cr6, 0x828bd380
	if ctx.cr[6].lt {
	pc = 0x828BD380; continue 'dispatch;
	}
	// 828BD370: 3B5A0050  addi r26, r26, 0x50
	ctx.r[26].s64 = ctx.r[26].s64 + 80;
	// 828BD374: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 828BD378: 7F1AC040  cmplw cr6, r26, r24
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828BD37C: 4198FFE4  blt cr6, 0x828bd360
	if ctx.cr[6].lt {
	pc = 0x828BD360; continue 'dispatch;
	}
	pc = 0x828BD380; continue 'dispatch;
            }
            0x828BD380 => {
    //   block [0x828BD380..0x828BD394)
	// 828BD380: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD384: FBC10068  std r30, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u64 ) };
	// 828BD388: 8381006C  lwz r28, 0x6c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828BD38C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BD390: 83610064  lwz r27, 0x64(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	pc = 0x828BD394; continue 'dispatch;
            }
            0x828BD394 => {
    //   block [0x828BD394..0x828BD39C)
	// 828BD394: 7F1BC040  cmplw cr6, r27, r24
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828BD398: 4098003C  bge cr6, 0x828bd3d4
	if !ctx.cr[6].lt {
	pc = 0x828BD3D4; continue 'dispatch;
	}
	pc = 0x828BD39C; continue 'dispatch;
            }
            0x828BD39C => {
    //   block [0x828BD39C..0x828BD3C4)
	// 828BD39C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD3A0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD3A4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BD3A8: 4199001C  bgt cr6, 0x828bd3c4
	if ctx.cr[6].gt {
	pc = 0x828BD3C4; continue 'dispatch;
	}
	// 828BD3AC: 41980028  blt cr6, 0x828bd3d4
	if ctx.cr[6].lt {
	pc = 0x828BD3D4; continue 'dispatch;
	}
	// 828BD3B0: 3B5A0050  addi r26, r26, 0x50
	ctx.r[26].s64 = ctx.r[26].s64 + 80;
	// 828BD3B4: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD3B8: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BD3BC: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 828BD3C0: 48000351  bl 0x828bd710
	ctx.lr = 0x828BD3C4;
	sub_828BD710(ctx, base);
	pc = 0x828BD3C4; continue 'dispatch;
            }
            0x828BD3C4 => {
    //   block [0x828BD3C4..0x828BD3D4)
	// 828BD3C4: 3B7B0050  addi r27, r27, 0x50
	ctx.r[27].s64 = ctx.r[27].s64 + 80;
	// 828BD3C8: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 828BD3CC: 7F1BC040  cmplw cr6, r27, r24
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828BD3D0: 4198FFCC  blt cr6, 0x828bd39c
	if ctx.cr[6].lt {
	pc = 0x828BD39C; continue 'dispatch;
	}
	pc = 0x828BD3D4; continue 'dispatch;
            }
            0x828BD3D4 => {
    //   block [0x828BD3D4..0x828BD3DC)
	// 828BD3D4: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828BD3D8: 4099005C  ble cr6, 0x828bd434
	if !ctx.cr[6].gt {
	pc = 0x828BD434; continue 'dispatch;
	}
	pc = 0x828BD3DC; continue 'dispatch;
            }
            0x828BD3DC => {
    //   block [0x828BD3DC..0x828BD420)
	// 828BD3DC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD3E0: 3BFCFFB0  addi r31, r28, -0x50
	ctx.r[31].s64 = ctx.r[28].s64 + -80;
	// 828BD3E4: 815CFFB0  lwz r10, -0x50(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-80 as u32) ) } as u64;
	// 828BD3E8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BD3EC: 41980034  blt cr6, 0x828bd420
	if ctx.cr[6].lt {
	pc = 0x828BD420; continue 'dispatch;
	}
	// 828BD3F0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD3F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BD3F8: 41980038  blt cr6, 0x828bd430
	if ctx.cr[6].lt {
	pc = 0x828BD430; continue 'dispatch;
	}
	// 828BD3FC: 3BBDFFB0  addi r29, r29, -0x50
	ctx.r[29].s64 = ctx.r[29].s64 + -80;
	// 828BD400: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828BD404: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828BD408: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 828BD40C: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 828BD410: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD414: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD418: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828BD41C: 480002F5  bl 0x828bd710
	ctx.lr = 0x828BD420;
	sub_828BD710(ctx, base);
	pc = 0x828BD420; continue 'dispatch;
            }
            0x828BD420 => {
    //   block [0x828BD420..0x828BD430)
	// 828BD420: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828BD424: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 828BD428: 7F19E040  cmplw cr6, r25, r28
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BD42C: 4198FFB0  blt cr6, 0x828bd3dc
	if ctx.cr[6].lt {
	pc = 0x828BD3DC; continue 'dispatch;
	}
	pc = 0x828BD430; continue 'dispatch;
            }
            0x828BD430 => {
    //   block [0x828BD430..0x828BD434)
	// 828BD430: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	pc = 0x828BD434; continue 'dispatch;
            }
            0x828BD434 => {
    //   block [0x828BD434..0x828BD454)
	// 828BD434: 409A004C  bne cr6, 0x828bd480
	if !ctx.cr[6].eq {
	pc = 0x828BD480; continue 'dispatch;
	}
	// 828BD438: 7F1BC040  cmplw cr6, r27, r24
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828BD43C: 419A00A4  beq cr6, 0x828bd4e0
	if ctx.cr[6].eq {
	pc = 0x828BD4E0; continue 'dispatch;
	}
	// 828BD440: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BD444: 419A0010  beq cr6, 0x828bd454
	if ctx.cr[6].eq {
	pc = 0x828BD454; continue 'dispatch;
	}
	// 828BD448: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD44C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD450: 480002C1  bl 0x828bd710
	ctx.lr = 0x828BD454;
	sub_828BD710(ctx, base);
	pc = 0x828BD454; continue 'dispatch;
            }
            0x828BD454 => {
    //   block [0x828BD454..0x828BD480)
	// 828BD454: 3B5A0050  addi r26, r26, 0x50
	ctx.r[26].s64 = ctx.r[26].s64 + 80;
	// 828BD458: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BD45C: 3B7B0050  addi r27, r27, 0x50
	ctx.r[27].s64 = ctx.r[27].s64 + 80;
	// 828BD460: 3BBD0050  addi r29, r29, 0x50
	ctx.r[29].s64 = ctx.r[29].s64 + 80;
	// 828BD464: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 828BD468: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD46C: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 828BD470: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828BD474: 4800029D  bl 0x828bd710
	ctx.lr = 0x828BD478;
	sub_828BD710(ctx, base);
	// 828BD478: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD47C: 4BFFFF18  b 0x828bd394
	pc = 0x828BD394; continue 'dispatch;
            }
            0x828BD480 => {
    //   block [0x828BD480..0x828BD4B0)
	// 828BD480: 3B9CFFB0  addi r28, r28, -0x50
	ctx.r[28].s64 = ctx.r[28].s64 + -80;
	// 828BD484: 7F1BC040  cmplw cr6, r27, r24
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828BD488: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 828BD48C: 409A003C  bne cr6, 0x828bd4c8
	if !ctx.cr[6].eq {
	pc = 0x828BD4C8; continue 'dispatch;
	}
	// 828BD490: 3BBDFFB0  addi r29, r29, -0x50
	ctx.r[29].s64 = ctx.r[29].s64 + -80;
	// 828BD494: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828BD498: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BD49C: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD4A0: 419A0010  beq cr6, 0x828bd4b0
	if ctx.cr[6].eq {
	pc = 0x828BD4B0; continue 'dispatch;
	}
	// 828BD4A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD4A8: E8610068  ld r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828BD4AC: 48000265  bl 0x828bd710
	ctx.lr = 0x828BD4B0;
	sub_828BD710(ctx, base);
	pc = 0x828BD4B0; continue 'dispatch;
            }
            0x828BD4B0 => {
    //   block [0x828BD4B0..0x828BD4C8)
	// 828BD4B0: 3B5AFFB0  addi r26, r26, -0x50
	ctx.r[26].s64 = ctx.r[26].s64 + -80;
	// 828BD4B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD4B8: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 828BD4BC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD4C0: 48000251  bl 0x828bd710
	ctx.lr = 0x828BD4C4;
	sub_828BD710(ctx, base);
	// 828BD4C4: 4BFFFED0  b 0x828bd394
	pc = 0x828BD394; continue 'dispatch;
            }
            0x828BD4C8 => {
    //   block [0x828BD4C8..0x828BD4E0)
	// 828BD4C8: 3B7B0050  addi r27, r27, 0x50
	ctx.r[27].s64 = ctx.r[27].s64 + 80;
	// 828BD4CC: E8610060  ld r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BD4D0: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828BD4D4: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 828BD4D8: 48000239  bl 0x828bd710
	ctx.lr = 0x828BD4DC;
	sub_828BD710(ctx, base);
	// 828BD4DC: 4BFFFEB8  b 0x828bd394
	pc = 0x828BD394; continue 'dispatch;
            }
            0x828BD4E0 => {
    //   block [0x828BD4E0..0x828BD4F8)
	// 828BD4E0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD4E4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828BD4E8: FBD70000  std r30, 0(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 828BD4EC: F9770008  std r11, 8(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828BD4F0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828BD4F4: 483EBF50  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD4F8 size=236
    let mut pc: u32 = 0x828BD4F8;
    'dispatch: loop {
        match pc {
            0x828BD4F8 => {
    //   block [0x828BD4F8..0x828BD534)
	// 828BD4F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD4FC: 483EBF0D  bl 0x82ca9408
	ctx.lr = 0x828BD500;
	sub_82CA93D0(ctx, base);
	// 828BD500: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD504: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828BD508: FBA100A0  std r29, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u64 ) };
	// 828BD50C: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 828BD510: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828BD514: 838100AC  lwz r28, 0xac(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 828BD518: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BD51C: 419A00C0  beq cr6, 0x828bd5dc
	if ctx.cr[6].eq {
	pc = 0x828BD5DC; continue 'dispatch;
	}
	// 828BD520: 3BFE0050  addi r31, r30, 0x50
	ctx.r[31].s64 = ctx.r[30].s64 + 80;
	// 828BD524: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 828BD528: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828BD52C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BD530: 419A00AC  beq cr6, 0x828bd5dc
	if ctx.cr[6].eq {
	pc = 0x828BD5DC; continue 'dispatch;
	}
	pc = 0x828BD534; continue 'dispatch;
            }
            0x828BD534 => {
    //   block [0x828BD534..0x828BD56C)
	// 828BD534: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD538: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD53C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD540: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BD544: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 828BD548: 40980024  bge cr6, 0x828bd56c
	if !ctx.cr[6].lt {
	pc = 0x828BD56C; continue 'dispatch;
	}
	// 828BD54C: 397F0050  addi r11, r31, 0x50
	ctx.r[11].s64 = ctx.r[31].s64 + 80;
	// 828BD550: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BD554: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828BD558: 419A0074  beq cr6, 0x828bd5cc
	if ctx.cr[6].eq {
	pc = 0x828BD5CC; continue 'dispatch;
	}
	// 828BD55C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BD560: 419A006C  beq cr6, 0x828bd5cc
	if ctx.cr[6].eq {
	pc = 0x828BD5CC; continue 'dispatch;
	}
	// 828BD564: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BD568: 48000054  b 0x828bd5bc
	pc = 0x828BD5BC; continue 'dispatch;
            }
            0x828BD56C => {
    //   block [0x828BD56C..0x828BD580)
	// 828BD56C: 397FFFB0  addi r11, r31, -0x50
	ctx.r[11].s64 = ctx.r[31].s64 + -80;
	// 828BD570: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828BD574: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD578: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BD57C: 40980050  bge cr6, 0x828bd5cc
	if !ctx.cr[6].lt {
	pc = 0x828BD5CC; continue 'dispatch;
	}
	pc = 0x828BD580; continue 'dispatch;
            }
            0x828BD580 => {
    //   block [0x828BD580..0x828BD5BC)
	// 828BD580: 396BFFB0  addi r11, r11, -0x50
	ctx.r[11].s64 = ctx.r[11].s64 + -80;
	// 828BD584: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD588: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828BD58C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD590: F8610060  std r3, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u64 ) };
	// 828BD594: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BD598: 4198FFE8  blt cr6, 0x828bd580
	if ctx.cr[6].lt {
	pc = 0x828BD580; continue 'dispatch;
	}
	// 828BD59C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BD5A0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BD5A4: 419A0028  beq cr6, 0x828bd5cc
	if ctx.cr[6].eq {
	pc = 0x828BD5CC; continue 'dispatch;
	}
	// 828BD5A8: 397F0050  addi r11, r31, 0x50
	ctx.r[11].s64 = ctx.r[31].s64 + 80;
	// 828BD5AC: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 828BD5B0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828BD5B4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BD5B8: 419A0014  beq cr6, 0x828bd5cc
	if ctx.cr[6].eq {
	pc = 0x828BD5CC; continue 'dispatch;
	}
	pc = 0x828BD5BC; continue 'dispatch;
            }
            0x828BD5BC => {
    //   block [0x828BD5BC..0x828BD5CC)
	// 828BD5BC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828BD5C0: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD5C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828BD5C8: 48000609  bl 0x828bdbd0
	ctx.lr = 0x828BD5CC;
	sub_828BDBD0(ctx, base);
	pc = 0x828BD5CC; continue 'dispatch;
            }
            0x828BD5CC => {
    //   block [0x828BD5CC..0x828BD5DC)
	// 828BD5CC: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 828BD5D0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828BD5D4: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BD5D8: 409AFF5C  bne cr6, 0x828bd534
	if !ctx.cr[6].eq {
	pc = 0x828BD534; continue 'dispatch;
	}
	pc = 0x828BD5DC; continue 'dispatch;
            }
            0x828BD5DC => {
    //   block [0x828BD5DC..0x828BD5E4)
	// 828BD5DC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BD5E0: 483EBE78  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BD5E8 size=296
    let mut pc: u32 = 0x828BD5E8;
    'dispatch: loop {
        match pc {
            0x828BD5E8 => {
    //   block [0x828BD5E8..0x828BD6FC)
	// 828BD5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD5EC: 483EBE0D  bl 0x82ca93f8
	ctx.lr = 0x828BD5F0;
	sub_82CA93D0(ctx, base);
	// 828BD5F0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD5F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BD5F8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828BD5FC: FBC100C0  std r30, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 828BD600: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 828BD604: FB8100D0  std r28, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[28].u64 ) };
	// 828BD608: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828BD60C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828BD610: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 828BD614: 830100D4  lwz r24, 0xd4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 828BD618: 7D2AC050  subf r9, r10, r24
	ctx.r[9].s64 = ctx.r[24].s64 - ctx.r[10].s64;
	// 828BD61C: 7D695BD6  divw r11, r9, r11
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 828BD620: FBA100C8  std r29, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u64 ) };
	// 828BD624: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 828BD628: 409900D4  ble cr6, 0x828bd6fc
	if !ctx.cr[6].gt {
	pc = 0x828BD6FC; continue 'dispatch;
	}
	// 828BD62C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828BD630: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 828BD634: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 828BD638: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 828BD63C: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 828BD640: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828BD644: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BD648: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828BD64C: 7CAB4214  add r5, r11, r8
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 828BD650: 54FF2036  slwi r31, r7, 4
	ctx.r[31].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828BD654: 54B92834  slwi r25, r5, 5
	ctx.r[25].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 828BD658: 7F5F5214  add r26, r31, r10
	ctx.r[26].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 828BD65C: 7C995214  add r4, r25, r10
	ctx.r[4].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 828BD660: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 828BD664: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 828BD668: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD66C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD670: 48000201  bl 0x828bd870
	ctx.lr = 0x828BD674;
	sub_828BD870(ctx, base);
	// 828BD674: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 828BD678: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828BD67C: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 828BD680: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BD684: 7C7F5A14  add r3, r31, r11
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828BD688: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 828BD68C: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 828BD690: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 828BD694: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828BD698: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD69C: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD6A0: 480001D1  bl 0x828bd870
	ctx.lr = 0x828BD6A4;
	sub_828BD870(ctx, base);
	// 828BD6A4: 7D59C050  subf r10, r25, r24
	ctx.r[10].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 828BD6A8: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 828BD6AC: 7FFFC050  subf r31, r31, r24
	ctx.r[31].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 828BD6B0: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 828BD6B4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828BD6B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828BD6BC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828BD6C0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828BD6C4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD6C8: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD6CC: 480001A5  bl 0x828bd870
	ctx.lr = 0x828BD6D0;
	sub_828BD870(ctx, base);
	// 828BD6D0: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 828BD6D4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828BD6D8: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 828BD6DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BD6E0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828BD6E4: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828BD6E8: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BD6EC: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BD6F0: 48000181  bl 0x828bd870
	ctx.lr = 0x828BD6F4;
	sub_828BD870(ctx, base);
	// 828BD6F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BD6F8: 483EBD50  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x828BD6FC => {
    //   block [0x828BD6FC..0x828BD710)
	// 828BD6FC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828BD700: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BD704: 4800016D  bl 0x828bd870
	ctx.lr = 0x828BD708;
	sub_828BD870(ctx, base);
	// 828BD708: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BD70C: 483EBD3C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD710 size=128
    let mut pc: u32 = 0x828BD710;
    'dispatch: loop {
        match pc {
            0x828BD710 => {
    //   block [0x828BD710..0x828BD790)
	// 828BD710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BD718: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BD71C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BD720: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD724: F86100C0  std r3, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[3].u64 ) };
	// 828BD728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BD72C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828BD730: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 828BD734: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 828BD738: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 828BD73C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD740: 3BEA0010  addi r31, r10, 0x10
	ctx.r[31].s64 = ctx.r[10].s64 + 16;
	// 828BD744: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD748: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BD74C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BD750: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828BD754: 4BFFEDDD  bl 0x828bc530
	ctx.lr = 0x828BD758;
	sub_828BC530(ctx, base);
	// 828BD758: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD75C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD760: 4B9A79E1  bl 0x82265140
	ctx.lr = 0x828BD764;
	sub_82265140(ctx, base);
	// 828BD764: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BD768: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BD76C: 4B9A79D5  bl 0x82265140
	ctx.lr = 0x828BD770;
	sub_82265140(ctx, base);
	// 828BD770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BD774: 4B957665  bl 0x82214dd8
	ctx.lr = 0x828BD778;
	sub_82214DD8(ctx, base);
	// 828BD778: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BD77C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BD780: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BD784: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BD788: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BD78C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD790 size=224
    let mut pc: u32 = 0x828BD790;
    'dispatch: loop {
        match pc {
            0x828BD790 => {
    //   block [0x828BD790..0x828BD7D0)
	// 828BD790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD794: 483EBC69  bl 0x82ca93fc
	ctx.lr = 0x828BD798;
	sub_82CA93D0(ctx, base);
	// 828BD798: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD79C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BD7A0: 3B800050  li r28, 0x50
	ctx.r[28].s64 = 80;
	// 828BD7A4: FB610140  std r27, 0x140(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[27].u64 ) };
	// 828BD7A8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828BD7AC: F8810148  std r4, 0x148(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.r[4].u64 ) };
	// 828BD7B0: 83C10144  lwz r30, 0x144(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 828BD7B4: 83A1014C  lwz r29, 0x14c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 828BD7B8: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 828BD7BC: 7D6BE3D6  divw r11, r11, r28
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[28].s32;
	// 828BD7C0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828BD7C4: 409900A4  ble cr6, 0x828bd868
	if !ctx.cr[6].gt {
	pc = 0x828BD868; continue 'dispatch;
	}
	// 828BD7C8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828BD7CC: 3B2A7088  addi r25, r10, 0x7088
	ctx.r[25].s64 = ctx.r[10].s64 + 28808;
	pc = 0x828BD7D0; continue 'dispatch;
            }
            0x828BD7D0 => {
    //   block [0x828BD7D0..0x828BD838)
	// 828BD7D0: 817DFFB0  lwz r11, -0x50(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-80 as u32) ) } as u64;
	// 828BD7D4: 3BFDFFB0  addi r31, r29, -0x50
	ctx.r[31].s64 = ctx.r[29].s64 + -80;
	// 828BD7D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BD7DC: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 828BD7E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828BD7E4: 4BFFED4D  bl 0x828bc530
	ctx.lr = 0x828BD7E8;
	sub_828BC530(ctx, base);
	// 828BD7E8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD7EC: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 828BD7F0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828BD7F4: 915DFFB0  stw r10, -0x50(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-80 as u32), ctx.r[10].u32 ) };
	// 828BD7F8: 4B9A7949  bl 0x82265140
	ctx.lr = 0x828BD7FC;
	sub_82265140(ctx, base);
	// 828BD7FC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BD800: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828BD804: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828BD808: 912100A0  stw r9, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 828BD80C: 4BFFED25  bl 0x828bc530
	ctx.lr = 0x828BD810;
	sub_828BC530(ctx, base);
	// 828BD810: 7D1EF850  subf r8, r30, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 828BD814: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828BD818: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828BD81C: 7CA8E3D6  divw r5, r8, r28
	ctx.r[5].s32 = ctx.r[8].s32 / ctx.r[28].s32;
	// 828BD820: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BD824: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BD828: 480000D9  bl 0x828bd900
	ctx.lr = 0x828BD82C;
	sub_828BD900(ctx, base);
	// 828BD82C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BD830: 4B908F39  bl 0x821c6768
	ctx.lr = 0x828BD834;
	sub_821C6768(ctx, base);
	// 828BD834: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	pc = 0x828BD838; continue 'dispatch;
            }
            0x828BD838 => {
    //   block [0x828BD838..0x828BD868)
	// 828BD838: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 828BD83C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BD840: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 828BD844: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 828BD848: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BD84C: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BD850: 4082FFE8  bne 0x828bd838
	if !ctx.cr[0].eq {
	pc = 0x828BD838; continue 'dispatch;
	}
	// 828BD854: 3BBDFFB0  addi r29, r29, -0x50
	ctx.r[29].s64 = ctx.r[29].s64 + -80;
	// 828BD858: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 828BD85C: 7D6BE3D6  divw r11, r11, r28
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[28].s32;
	// 828BD860: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828BD864: 4199FF6C  bgt cr6, 0x828bd7d0
	if ctx.cr[6].gt {
	pc = 0x828BD7D0; continue 'dispatch;
	}
	pc = 0x828BD868; continue 'dispatch;
            }
            0x828BD868 => {
    //   block [0x828BD868..0x828BD870)
	// 828BD868: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 828BD86C: 483EBBE0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD870 size=140
    let mut pc: u32 = 0x828BD870;
    'dispatch: loop {
        match pc {
            0x828BD870 => {
    //   block [0x828BD870..0x828BD8B8)
	// 828BD870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD874: 483EBB91  bl 0x82ca9404
	ctx.lr = 0x828BD878;
	sub_82CA93D0(ctx, base);
	// 828BD878: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD87C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828BD880: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BD884: FBC10090  std r30, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u64 ) };
	// 828BD888: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828BD88C: FBE10098  std r31, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u64 ) };
	// 828BD890: 8381009C  lwz r28, 0x9c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828BD894: 83610094  lwz r27, 0x94(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828BD898: FBA100A0  std r29, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u64 ) };
	// 828BD89C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD8A0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD8A4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BD8A8: 40980010  bge cr6, 0x828bd8b8
	if !ctx.cr[6].lt {
	pc = 0x828BD8B8; continue 'dispatch;
	}
	// 828BD8AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD8B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD8B4: 4BFFFE5D  bl 0x828bd710
	ctx.lr = 0x828BD8B8;
	sub_828BD710(ctx, base);
	pc = 0x828BD8B8; continue 'dispatch;
            }
            0x828BD8B8 => {
    //   block [0x828BD8B8..0x828BD8D8)
	// 828BD8B8: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828BD8BC: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD8C0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD8C4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BD8C8: 40980010  bge cr6, 0x828bd8d8
	if !ctx.cr[6].lt {
	pc = 0x828BD8D8; continue 'dispatch;
	}
	// 828BD8CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BD8D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BD8D4: 4BFFFE3D  bl 0x828bd710
	ctx.lr = 0x828BD8D8;
	sub_828BD710(ctx, base);
	pc = 0x828BD8D8; continue 'dispatch;
            }
            0x828BD8D8 => {
    //   block [0x828BD8D8..0x828BD8F4)
	// 828BD8D8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD8DC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD8E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BD8E4: 40980010  bge cr6, 0x828bd8f4
	if !ctx.cr[6].lt {
	pc = 0x828BD8F4; continue 'dispatch;
	}
	// 828BD8E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BD8EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BD8F0: 4BFFFE21  bl 0x828bd710
	ctx.lr = 0x828BD8F4;
	sub_828BD710(ctx, base);
	pc = 0x828BD8F4; continue 'dispatch;
            }
            0x828BD8F4 => {
    //   block [0x828BD8F4..0x828BD8FC)
	// 828BD8F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BD8F8: 483EBB5C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BD900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BD900 size=436
    let mut pc: u32 = 0x828BD900;
    'dispatch: loop {
        match pc {
            0x828BD900 => {
    //   block [0x828BD900..0x828BD96C)
	// 828BD900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BD904: 483EBAE1  bl 0x82ca93e4
	ctx.lr = 0x828BD908;
	sub_82CA93D0(ctx, base);
	// 828BD908: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BD90C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828BD910: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 828BD914: 397C0001  addi r11, r28, 1
	ctx.r[11].s64 = ctx.r[28].s64 + 1;
	// 828BD918: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 828BD91C: FAA10130  std r21, 0x130(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[21].u64 ) };
	// 828BD920: 557F083C  slwi r31, r11, 1
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828BD924: 83610134  lwz r27, 0x134(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 828BD928: 3AE00020  li r23, 0x20
	ctx.r[23].s64 = 32;
	// 828BD92C: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 828BD930: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
	// 828BD934: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 828BD938: 7F1FC000  cmpw cr6, r31, r24
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[24].s32, &mut ctx.xer);
	// 828BD93C: 409800A4  bge cr6, 0x828bd9e0
	if !ctx.cr[6].lt {
	pc = 0x828BD9E0; continue 'dispatch;
	}
	// 828BD940: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD944: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828BD948: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD94C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828BD950: 394BFFB0  addi r10, r11, -0x50
	ctx.r[10].s64 = ctx.r[11].s64 + -80;
	// 828BD954: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828BD958: 812BFFB0  lwz r9, -0x50(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-80 as u32) ) } as u64;
	// 828BD95C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BD960: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BD964: 40980008  bge cr6, 0x828bd96c
	if !ctx.cr[6].lt {
	pc = 0x828BD96C; continue 'dispatch;
	}
	// 828BD968: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	pc = 0x828BD96C; continue 'dispatch;
            }
            0x828BD96C => {
    //   block [0x828BD96C..0x828BD9E0)
	// 828BD96C: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BD970: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD974: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 828BD978: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 828BD97C: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BD980: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD984: 7FCADA14  add r30, r10, r27
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 828BD988: 7FABDA14  add r29, r11, r27
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828BD98C: 3B5E0010  addi r26, r30, 0x10
	ctx.r[26].s64 = ctx.r[30].s64 + 16;
	// 828BD990: 7D0AD82E  lwzx r8, r10, r27
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 828BD994: 3B3D0010  addi r25, r29, 0x10
	ctx.r[25].s64 = ctx.r[29].s64 + 16;
	// 828BD998: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828BD99C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828BD9A0: 7D0BD92E  stwx r8, r11, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[8].u32) };
	// 828BD9A4: 4B9A77FD  bl 0x822651a0
	ctx.lr = 0x828BD9A8;
	sub_822651A0(ctx, base);
	// 828BD9A8: E8DE0020  ld r6, 0x20(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	// 828BD9AC: 38FF0001  addi r7, r31, 1
	ctx.r[7].s64 = ctx.r[31].s64 + 1;
	// 828BD9B0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828BD9B4: 54FF083C  slwi r31, r7, 1
	ctx.r[31].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828BD9B8: F8DD0020  std r6, 0x20(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[6].u64 ) };
	// 828BD9BC: 7F1FC000  cmpw cr6, r31, r24
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[24].s32, &mut ctx.xer);
	// 828BD9C0: E8BE0028  ld r5, 0x28(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	// 828BD9C4: F8BD0028  std r5, 0x28(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[5].u64 ) };
	pc = 0x828BD9E0; continue 'dispatch;
            }
            0x828BD9E0 => {
    //   block [0x828BD9E0..0x828BDAB4)
	// 828BD9E0: 409A0068  bne cr6, 0x828bda48
	if !ctx.cr[6].eq {
	pc = 0x828BDA48; continue 'dispatch;
	}
	// 828BD9E4: 570A103A  slwi r10, r24, 2
	ctx.r[10].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BD9E8: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD9EC: 7D585214  add r10, r24, r10
	ctx.r[10].u64 = ctx.r[24].u64 + ctx.r[10].u64;
	// 828BD9F0: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 828BD9F4: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BD9F8: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BD9FC: 7FEADA14  add r31, r10, r27
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 828BDA00: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828BDA04: 397FFFB0  addi r11, r31, -0x50
	ctx.r[11].s64 = ctx.r[31].s64 + -80;
	// 828BDA08: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 828BDA0C: 3B6B0010  addi r27, r11, 0x10
	ctx.r[27].s64 = ctx.r[11].s64 + 16;
	// 828BDA10: 811FFFB0  lwz r8, -0x50(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-80 as u32) ) } as u64;
	// 828BDA14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BDA18: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828BDA1C: 911E0000  stw r8, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828BDA20: 4B9A7781  bl 0x822651a0
	ctx.lr = 0x828BDA24;
	sub_822651A0(ctx, base);
	// 828BDA24: E8FFFFD0  ld r7, -0x30(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(-48 as u32) ) };
	// 828BDA28: 3B98FFFF  addi r28, r24, -1
	ctx.r[28].s64 = ctx.r[24].s64 + -1;
	// 828BDA2C: F8FE0020  std r7, 0x20(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[7].u64 ) };
	// 828BDA30: E8DFFFD8  ld r6, -0x28(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(-40 as u32) ) };
	// 828BDA34: F8DE0028  std r6, 0x28(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BDAB8 size=280
    let mut pc: u32 = 0x828BDAB8;
    'dispatch: loop {
        match pc {
            0x828BDAB8 => {
    //   block [0x828BDAB8..0x828BDAE8)
	// 828BDAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDABC: 483EB94D  bl 0x82ca9408
	ctx.lr = 0x828BDAC0;
	sub_82CA93D0(ctx, base);
	// 828BDAC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDAC4: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 828BDAC8: F8610090  std r3, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u64 ) };
	// 828BDACC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828BDAD0: 83810094  lwz r28, 0x94(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828BDAD4: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BDAD8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 828BDADC: 7F1D2000  cmpw cr6, r29, r4
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[4].s32, &mut ctx.xer);
	// 828BDAE0: 7FEA0194  addze r31, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[31].s64 = tmp.s64;
	// 828BDAE4: 40980060  bge cr6, 0x828bdb44
	if !ctx.cr[6].lt {
	pc = 0x828BDB44; continue 'dispatch;
	}
	pc = 0x828BDAE8; continue 'dispatch;
            }
            0x828BDAE8 => {
    //   block [0x828BDAE8..0x828BDB44)
	// 828BDAE8: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDAEC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDAF0: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828BDAF4: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDAF8: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828BDAFC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDB00: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BDB04: 40980040  bge cr6, 0x828bdb44
	if !ctx.cr[6].lt {
	pc = 0x828BDB44; continue 'dispatch;
	}
	// 828BDB08: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BDB0C: 5509003E  slwi r9, r8, 0
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828BDB10: 7D045214  add r8, r4, r10
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 828BDB14: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 828BDB18: 550A2036  slwi r10, r8, 4
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BDB1C: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 828BDB20: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 828BDB24: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BDB28: 4B9A7619  bl 0x82265140
	ctx.lr = 0x828BDB2C;
	sub_82265140(ctx, base);
	// 828BDB2C: 38FFFFFF  addi r7, r31, -1
	ctx.r[7].s64 = ctx.r[31].s64 + -1;
	// 828BDB30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BDB34: 7CE60E70  srawi r6, r7, 1
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 1) as i64;
	// 828BDB38: 7F1D2000  cmpw cr6, r29, r4
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[4].s32, &mut ctx.xer);
	// 828BDB3C: 7FE60194  addze r31, r6
	tmp.s64 = ctx.r[6].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[6].u32);
	ctx.r[31].s64 = tmp.s64;
	// 828BDB40: 4198FFA8  blt cr6, 0x828bdae8
	if ctx.cr[6].lt {
	pc = 0x828BDAE8; continue 'dispatch;
	}
	pc = 0x828BDB44; continue 'dispatch;
            }
            0x828BDB44 => {
    //   block [0x828BDB44..0x828BDBD0)
	// 828BDB44: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDB48: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDB4C: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 828BDB50: 7D245A14  add r9, r4, r11
	ctx.r[9].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 828BDB54: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BDB58: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDB5C: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828BDB60: 7D4BE12E  stwx r10, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[10].u32) };
	// 828BDB64: 3B9F0010  addi r28, r31, 0x10
	ctx.r[28].s64 = ctx.r[31].s64 + 16;
	// 828BDB68: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BDB6C: 4B9A7635  bl 0x822651a0
	ctx.lr = 0x828BDB70;
	sub_822651A0(ctx, base);
	// 828BDB70: E91E0020  ld r8, 0x20(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	// 828BDB74: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828BDB78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BDB7C: F91F0020  std r8, 0x20(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[8].u64 ) };
	// 828BDB80: E8FE0028  ld r7, 0x28(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	// 828BDB84: F8FF0028  std r7, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[7].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BDBD0 size=512
    let mut pc: u32 = 0x828BDBD0;
    'dispatch: loop {
        match pc {
            0x828BDBD0 => {
    //   block [0x828BDBD0..0x828BDC18)
	// 828BDBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDBD4: 483EB805  bl 0x82ca93d8
	ctx.lr = 0x828BDBD8;
	sub_82CA93D0(ctx, base);
	// 828BDBD8: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDBDC: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 828BDBE0: 3A600050  li r19, 0x50
	ctx.r[19].s64 = 80;
	// 828BDBE4: FAA10170  std r21, 0x170(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[21].u64 ) };
	// 828BDBE8: F8A10180  std r5, 0x180(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[5].u64 ) };
	// 828BDBEC: 82E10184  lwz r23, 0x184(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 828BDBF0: F8810178  std r4, 0x178(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[4].u64 ) };
	// 828BDBF4: 82810174  lwz r20, 0x174(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 828BDBF8: 8161017C  lwz r11, 0x17c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(380 as u32) ) } as u64;
	// 828BDBFC: 7D545850  subf r10, r20, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[20].s64;
	// 828BDC00: 7D34B850  subf r9, r20, r23
	ctx.r[9].s64 = ctx.r[23].s64 - ctx.r[20].s64;
	// 828BDC04: 7F4A9BD7  divw. r26, r10, r19
	ctx.r[26].s32 = ctx.r[10].s32 / ctx.r[19].s32;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 828BDC08: 7D299BD6  divw r9, r9, r19
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[19].s32;
	// 828BDC0C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BDC10: 7D364B78  mr r22, r9
	ctx.r[22].u64 = ctx.r[9].u64;
	// 828BDC14: 4182001C  beq 0x828bdc30
	if ctx.cr[0].eq {
	pc = 0x828BDC30; continue 'dispatch;
	}
	pc = 0x828BDC18; continue 'dispatch;
            }
            0x828BDC18 => {
    //   block [0x828BDC18..0x828BDC30)
	// 828BDC18: 7D565BD6  divw r10, r22, r11
	ctx.r[10].s32 = ctx.r[22].s32 / ctx.r[11].s32;
	// 828BDC1C: 7D0A59D6  mullw r8, r10, r11
	ctx.r[8].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 828BDC20: 7D48B051  subf. r10, r8, r22
	ctx.r[10].s64 = ctx.r[22].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828BDC24: 7D765B78  mr r22, r11
	ctx.r[22].u64 = ctx.r[11].u64;
	// 828BDC28: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828BDC2C: 4082FFEC  bne 0x828bdc18
	if !ctx.cr[0].eq {
	pc = 0x828BDC18; continue 'dispatch;
	}
	pc = 0x828BDC30; continue 'dispatch;
            }
            0x828BDC30 => {
    //   block [0x828BDC30..0x828BDCA4)
	// 828BDC30: 7F164800  cmpw cr6, r22, r9
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828BDC34: 40980194  bge cr6, 0x828bddc8
	if !ctx.cr[6].lt {
	pc = 0x828BDDC8; continue 'dispatch;
	}
	// 828BDC38: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 828BDC3C: 4099018C  ble cr6, 0x828bddc8
	if !ctx.cr[6].gt {
	pc = 0x828BDDC8; continue 'dispatch;
	}
	// 828BDC40: 56CB103A  slwi r11, r22, 2
	ctx.r[11].u32 = ctx.r[22].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDC44: 574A103A  slwi r10, r26, 2
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BDC48: 7D765A14  add r11, r22, r11
	ctx.r[11].u64 = ctx.r[22].u64 + ctx.r[11].u64;
	// 828BDC4C: 7D5A5214  add r10, r26, r10
	ctx.r[10].u64 = ctx.r[26].u64 + ctx.r[10].u64;
	// 828BDC50: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDC54: 55522036  slwi r18, r10, 4
	ctx.r[18].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[18].u64 = ctx.r[18].u32 as u64;
	// 828BDC58: 7F2BA214  add r25, r11, r20
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[20].u64;
	// 828BDC5C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828BDC60: 3B000020  li r24, 0x20
	ctx.r[24].s64 = 32;
	// 828BDC64: 3A000000  li r16, 0
	ctx.r[16].s64 = 0;
	// 828BDC68: 3A2B7088  addi r17, r11, 0x7088
	ctx.r[17].s64 = ctx.r[11].s64 + 28808;
	// 828BDC6C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDC70: 38990010  addi r4, r25, 0x10
	ctx.r[4].s64 = ctx.r[25].s64 + 16;
	// 828BDC74: FAA10058  std r21, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[21].u64 ) };
	// 828BDC78: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828BDC7C: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 828BDC80: EBE10058  ld r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BDC84: FBE10058  std r31, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u64 ) };
	// 828BDC88: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828BDC8C: 4BFFE8A5  bl 0x828bc530
	ctx.lr = 0x828BDC90;
	sub_828BC530(ctx, base);
	// 828BDC90: 7D799214  add r11, r25, r18
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[18].u64;
	// 828BDC94: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 828BDC98: 409A000C  bne cr6, 0x828bdca4
	if !ctx.cr[6].eq {
	pc = 0x828BDCA4; continue 'dispatch;
	}
	// 828BDC9C: 39410170  addi r10, r1, 0x170
	ctx.r[10].s64 = ctx.r[1].s64 + 368;
	// 828BDCA0: 48000018  b 0x828bdcb8
	pc = 0x828BDCB8; continue 'dispatch;
            }
            0x828BDCA4 => {
    //   block [0x828BDCA4..0x828BDCB8)
	// 828BDCA4: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 828BDCA8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828BDCAC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828BDCB0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BDCB4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	pc = 0x828BDCB8; continue 'dispatch;
            }
            0x828BDCB8 => {
    //   block [0x828BDCB8..0x828BDD78)
	// 828BDCB8: EB6A0000  ld r27, 0(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 828BDCBC: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 828BDCC0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BDCC4: 7F1FC840  cmplw cr6, r31, r25
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828BDCC8: 419A00B0  beq cr6, 0x828bdd78
	if ctx.cr[6].eq {
	pc = 0x828BDD78; continue 'dispatch;
	}
	// 828BDCCC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDCD0: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 828BDCD4: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BDCD8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BDCDC: 3B9E0010  addi r28, r30, 0x10
	ctx.r[28].s64 = ctx.r[30].s64 + 16;
	// 828BDCE0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BDCE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828BDCE8: 4B9A74B9  bl 0x822651a0
	ctx.lr = 0x828BDCEC;
	sub_822651A0(ctx, base);
	// 828BDCEC: E93F0020  ld r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	// 828BDCF0: 7D5FB850  subf r10, r31, r23
	ctx.r[10].s64 = ctx.r[23].s64 - ctx.r[31].s64;
	// 828BDCF4: FB610058  std r27, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u64 ) };
	// 828BDCF8: 7D6A9BD6  divw r11, r10, r19
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[19].s32;
	// 828BDCFC: F93E0020  std r9, 0x20(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[9].u64 ) };
	// 828BDD00: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828BDD04: E91F0028  ld r8, 0x28(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	// 828BDD08: F91E0028  std r8, 0x28(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[8].u64 ) };
	pc = 0x828BDD78; continue 'dispatch;
            }
            0x828BDD78 => {
    //   block [0x828BDD78..0x828BDDC8)
	// 828BDD78: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BDD7C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828BDD80: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BDD84: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 828BDD88: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828BDD8C: 4B9A73B5  bl 0x82265140
	ctx.lr = 0x828BDD90;
	sub_82265140(ctx, base);
	// 828BDD90: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828BDD94: 4B9089D5  bl 0x821c6768
	ctx.lr = 0x828BDD98;
	sub_821C6768(ctx, base);
	// 828BDD98: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 828BDD9C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828BDDA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BDDA4: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828BDDA8: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 828BDDAC: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828BDDB0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828BDDB4: 4082FFE8  bne 0x828bdd9c
	if !ctx.cr[0].eq {
	pc = 0x828BDD9C; continue 'dispatch;
	}
	// 828BDDB8: 36D6FFFF  addic. r22, r22, -1
	ctx.xer.ca = (ctx.r[22].u32 > (!(-1 as u32)));
	ctx.r[22].s64 = ctx.r[22].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 828BDDBC: 92010090  stw r16, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[16].u32 ) };
	// 828BDDC0: 3B39FFB0  addi r25, r25, -0x50
	ctx.r[25].s64 = ctx.r[25].s64 + -80;
	// 828BDDC4: 4181FEA8  bgt 0x828bdc6c
	if ctx.cr[0].gt {
	pc = 0x828BDC6C; continue 'dispatch;
	}
	pc = 0x828BDDC8; continue 'dispatch;
            }
            0x828BDDC8 => {
    //   block [0x828BDDC8..0x828BDDD0)
	// 828BDDC8: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 828BDDCC: 483EB65C  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BDDD0 size=60
    let mut pc: u32 = 0x828BDDD0;
    'dispatch: loop {
        match pc {
            0x828BDDD0 => {
    //   block [0x828BDDD0..0x828BDE0C)
	// 828BDDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDDD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BDDD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BDDDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDDE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828BDDE4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BDDE8: 388B9938  addi r4, r11, -0x66c8
	ctx.r[4].s64 = ctx.r[11].s64 + -26312;
	// 828BDDEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BDDF0: 4B96F0E1  bl 0x8222ced0
	ctx.lr = 0x828BDDF4;
	sub_8222CED0(ctx, base);
	// 828BDDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BDDF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BDDFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BDE00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BDE04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BDE08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BDE10 size=324
    let mut pc: u32 = 0x828BDE10;
    'dispatch: loop {
        match pc {
            0x828BDE10 => {
    //   block [0x828BDE10..0x828BDE70)
	// 828BDE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BDE14: 483EB5ED  bl 0x82ca9400
	ctx.lr = 0x828BDE18;
	sub_82CA93D0(ctx, base);
	// 828BDE18: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BDE1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BDE20: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828BDE24: 419A0128  beq cr6, 0x828bdf4c
	if ctx.cr[6].eq {
	pc = 0x828BDF4C; continue 'dispatch;
	}
	// 828BDE28: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828BDE2C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828BDE30: 388B2ED8  addi r4, r11, 0x2ed8
	ctx.r[4].s64 = ctx.r[11].s64 + 11992;
	// 828BDE34: 4B9EBBB5  bl 0x822a99e8
	ctx.lr = 0x828BDE38;
	sub_822A99E8(ctx, base);
	// 828BDE38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BDE3C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828BDE40: 419A010C  beq cr6, 0x828bdf4c
	if ctx.cr[6].eq {
	pc = 0x828BDF4C; continue 'dispatch;
	}
	// 828BDE44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BDE48: 48142B49  bl 0x82a00990
	ctx.lr = 0x828BDE4C;
	sub_82A00990(ctx, base);
	// 828BDE4C: 83C10068  lwz r30, 0x68(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828BDE50: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BDE54: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828BDE58: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BDE5C: 419A00E8  beq cr6, 0x828bdf44
	if ctx.cr[6].eq {
	pc = 0x828BDF44; continue 'dispatch;
	}
	// 828BDE60: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828BDE64: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 828BDE68: 3F60834A  lis r27, -0x7cb6
	ctx.r[27].s64 = -2092302336;
	// 828BDE6C: 3B8BE460  addi r28, r11, -0x1ba0
	ctx.r[28].s64 = ctx.r[11].s64 + -7072;
	pc = 0x828BDE70; continue 'dispatch;
            }
            0x828BDE70 => {
    //   block [0x828BDE70..0x828BDEAC)
	// 828BDE70: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDE74: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828BDE78: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BDE7C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 828BDE80: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BDE84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDE88: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 828BDE8C: 419A0020  beq cr6, 0x828bdeac
	if ctx.cr[6].eq {
	pc = 0x828BDEAC; continue 'dispatch;
	}
	// 828BDE90: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828BDE94: 409A0018  bne cr6, 0x828bdeac
	if !ctx.cr[6].eq {
	pc = 0x828BDEAC; continue 'dispatch;
	}
	// 828BDE98: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDE9C: 813BE454  lwz r9, -0x1bac(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828BDEA0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BDEA4: 409A0008  bne cr6, 0x828bdeac
	if !ctx.cr[6].eq {
	pc = 0x828BDEAC; continue 'dispatch;
	}
	// 828BDEA8: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x828BDEAC; continue 'dispatch;
            }
            0x828BDEAC => {
    //   block [0x828BDEAC..0x828BDEC8)
	// 828BDEAC: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDEB0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BDEB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BDEB8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828BDEBC: 409A000C  bne cr6, 0x828bdec8
	if !ctx.cr[6].eq {
	pc = 0x828BDEC8; continue 'dispatch;
	}
	// 828BDEC0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828BDEC4: 48000010  b 0x828bded4
	pc = 0x828BDED4; continue 'dispatch;
            }
            0x828BDEC8 => {
    //   block [0x828BDEC8..0x828BDED4)
	// 828BDEC8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BDECC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BDED0: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x828BDED4; continue 'dispatch;
            }
            0x828BDED4 => {
    //   block [0x828BDED4..0x828BDF00)
	// 828BDED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BDED8: 419A0034  beq cr6, 0x828bdf0c
	if ctx.cr[6].eq {
	pc = 0x828BDF0C; continue 'dispatch;
	}
	// 828BDEDC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BDEE0: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828BDEE4: 7CEA1670  srawi r10, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 828BDEE8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BDEEC: 40980020  bge cr6, 0x828bdf0c
	if !ctx.cr[6].lt {
	pc = 0x828BDF0C; continue 'dispatch;
	}
	// 828BDEF0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BDEF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BDEF8: 419A0008  beq cr6, 0x828bdf00
	if ctx.cr[6].eq {
	pc = 0x828BDF00; continue 'dispatch;
	}
	// 828BDEFC: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x828BDF00; continue 'dispatch;
            }
            0x828BDF00 => {
    //   block [0x828BDF00..0x828BDF0C)
	// 828BDF00: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828BDF04: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828BDF08: 48000030  b 0x828bdf38
	pc = 0x828BDF38; continue 'dispatch;
            }
            0x828BDF0C => {
    //   block [0x828BDF0C..0x828BDF1C)
	// 828BDF0C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BDF10: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BDF14: 40990008  ble cr6, 0x828bdf1c
	if !ctx.cr[6].gt {
	pc = 0x828BDF1C; continue 'dispatch;
	}
	// 828BDF18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BDF1C; continue 'dispatch;
            }
            0x828BDF1C => {
    //   block [0x828BDF1C..0x828BDF38)
	// 828BDF1C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828BDF20: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828BDF24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BDF28: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828BDF2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BDF30: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828BDF34: 4BCC1715  bl 0x8257f648
	ctx.lr = 0x828BDF38;
	sub_8257F648(ctx, base);
	pc = 0x828BDF38; continue 'dispatch;
            }
            0x828BDF38 => {
    //   block [0x828BDF38..0x828BDF44)
	// 828BDF38: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828BDF3C: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BDF40: 409AFF30  bne cr6, 0x828bde70
	if !ctx.cr[6].eq {
	pc = 0x828BDE70; continue 'dispatch;
	}
	pc = 0x828BDF44; continue 'dispatch;
            }
            0x828BDF44 => {
    //   block [0x828BDF44..0x828BDF4C)
	// 828BDF44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828BDF48: 4B95DDF1  bl 0x8221bd38
	ctx.lr = 0x828BDF4C;
	sub_8221BD38(ctx, base);
	pc = 0x828BDF4C; continue 'dispatch;
            }
            0x828BDF4C => {
    //   block [0x828BDF4C..0x828BDF54)
	// 828BDF4C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828BDF50: 483EB500  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BDF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BDF58 size=296
    let mut pc: u32 = 0x828BDF58;
    'dispatch: loop {
        match pc {
            0x828BDF58 => {
    //   block [0x828BDF58..0x828BDF70)
	// 828BDF58: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828BDF5C: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 828BDF60: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BDF64: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BDF68: 40990008  ble cr6, 0x828bdf70
	if !ctx.cr[6].gt {
	pc = 0x828BDF70; continue 'dispatch;
	}
	// 828BDF6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BDF70; continue 'dispatch;
            }
            0x828BDF70 => {
    //   block [0x828BDF70..0x828BDF84)
	// 828BDF70: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BDF74: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BDF78: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BDF7C: 40990008  ble cr6, 0x828bdf84
	if !ctx.cr[6].gt {
	pc = 0x828BDF84; continue 'dispatch;
	}
	// 828BDF80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BDF84; continue 'dispatch;
            }
            0x828BDF84 => {
    //   block [0x828BDF84..0x828BDF9C)
	// 828BDF84: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 828BDF88: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BDF8C: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 828BDF90: E901FFF0  ld r8, -0x10(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BDF94: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 828BDF98: 419A001C  beq cr6, 0x828bdfb4
	if ctx.cr[6].eq {
	pc = 0x828BDFB4; continue 'dispatch;
	}
	pc = 0x828BDF9C; continue 'dispatch;
            }
            0x828BDF9C => {
    //   block [0x828BDF9C..0x828BDFB4)
	// 828BDF9C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BDFA0: 7F082040  cmplw cr6, r8, r4
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828BDFA4: 419A0010  beq cr6, 0x828bdfb4
	if ctx.cr[6].eq {
	pc = 0x828BDFB4; continue 'dispatch;
	}
	// 828BDFA8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828BDFAC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BDFB0: 409AFFEC  bne cr6, 0x828bdf9c
	if !ctx.cr[6].eq {
	pc = 0x828BDF9C; continue 'dispatch;
	}
	pc = 0x828BDFB4; continue 'dispatch;
            }
            0x828BDFB4 => {
    //   block [0x828BDFB4..0x828BDFC8)
	// 828BDFB4: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BDFB8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BDFBC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BDFC0: 40990008  ble cr6, 0x828bdfc8
	if !ctx.cr[6].gt {
	pc = 0x828BDFC8; continue 'dispatch;
	}
	// 828BDFC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BDFC8; continue 'dispatch;
            }
            0x828BDFC8 => {
    //   block [0x828BDFC8..0x828BDFDC)
	// 828BDFC8: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828BDFCC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BDFD0: 419A000C  beq cr6, 0x828bdfdc
	if ctx.cr[6].eq {
	pc = 0x828BDFDC; continue 'dispatch;
	}
	// 828BDFD4: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BDFD8: 419A0008  beq cr6, 0x828bdfe0
	if ctx.cr[6].eq {
	pc = 0x828BDFE0; continue 'dispatch;
	}
	pc = 0x828BDFDC; continue 'dispatch;
            }
            0x828BDFDC => {
    //   block [0x828BDFDC..0x828BDFE0)
	// 828BDFDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BDFE0; continue 'dispatch;
            }
            0x828BDFE0 => {
    //   block [0x828BDFE0..0x828BDFFC)
	// 828BDFE0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BDFE4: 409A0094  bne cr6, 0x828be078
	if !ctx.cr[6].eq {
	pc = 0x828BE078; continue 'dispatch;
	}
	// 828BDFE8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BDFEC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BDFF0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BDFF4: 40990008  ble cr6, 0x828bdffc
	if !ctx.cr[6].gt {
	pc = 0x828BDFFC; continue 'dispatch;
	}
	// 828BDFF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BDFFC; continue 'dispatch;
            }
            0x828BDFFC => {
    //   block [0x828BDFFC..0x828BE010)
	// 828BDFFC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE000: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BE004: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BE008: 40990008  ble cr6, 0x828be010
	if !ctx.cr[6].gt {
	pc = 0x828BE010; continue 'dispatch;
	}
	// 828BE00C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BE010; continue 'dispatch;
            }
            0x828BE010 => {
    //   block [0x828BE010..0x828BE028)
	// 828BE010: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 828BE014: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BE018: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 828BE01C: E901FFF0  ld r8, -0x10(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BE020: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 828BE024: 419A001C  beq cr6, 0x828be040
	if ctx.cr[6].eq {
	pc = 0x828BE040; continue 'dispatch;
	}
	pc = 0x828BE028; continue 'dispatch;
            }
            0x828BE028 => {
    //   block [0x828BE028..0x828BE040)
	// 828BE028: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE02C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828BE030: 419A0010  beq cr6, 0x828be040
	if ctx.cr[6].eq {
	pc = 0x828BE040; continue 'dispatch;
	}
	// 828BE034: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828BE038: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BE03C: 409AFFEC  bne cr6, 0x828be028
	if !ctx.cr[6].eq {
	pc = 0x828BE028; continue 'dispatch;
	}
	pc = 0x828BE040; continue 'dispatch;
            }
            0x828BE040 => {
    //   block [0x828BE040..0x828BE054)
	// 828BE040: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BE044: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE048: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BE04C: 40990008  ble cr6, 0x828be054
	if !ctx.cr[6].gt {
	pc = 0x828BE054; continue 'dispatch;
	}
	// 828BE050: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BE054; continue 'dispatch;
            }
            0x828BE054 => {
    //   block [0x828BE054..0x828BE068)
	// 828BE054: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828BE058: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BE05C: 419A000C  beq cr6, 0x828be068
	if ctx.cr[6].eq {
	pc = 0x828BE068; continue 'dispatch;
	}
	// 828BE060: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BE064: 419A0008  beq cr6, 0x828be06c
	if ctx.cr[6].eq {
	pc = 0x828BE06C; continue 'dispatch;
	}
	pc = 0x828BE068; continue 'dispatch;
            }
            0x828BE068 => {
    //   block [0x828BE068..0x828BE06C)
	// 828BE068: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BE06C; continue 'dispatch;
            }
            0x828BE06C => {
    //   block [0x828BE06C..0x828BE078)
	// 828BE06C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BE070: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BE074: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x828BE078; continue 'dispatch;
            }
            0x828BE078 => {
    //   block [0x828BE078..0x828BE080)
	// 828BE078: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828BE07C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE080 size=60
    let mut pc: u32 = 0x828BE080;
    'dispatch: loop {
        match pc {
            0x828BE080 => {
    //   block [0x828BE080..0x828BE0BC)
	// 828BE080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE088: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BE08C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE090: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828BE094: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BE098: 388B9500  addi r4, r11, -0x6b00
	ctx.r[4].s64 = ctx.r[11].s64 + -27392;
	// 828BE09C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE0A0: 4B96EE31  bl 0x8222ced0
	ctx.lr = 0x828BE0A4;
	sub_8222CED0(ctx, base);
	// 828BE0A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE0A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828BE0AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BE0B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BE0B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BE0B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE0C0 size=96
    let mut pc: u32 = 0x828BE0C0;
    'dispatch: loop {
        match pc {
            0x828BE0C0 => {
    //   block [0x828BE0C0..0x828BE108)
	// 828BE0C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE0C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE0C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BE0CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BE0D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE0D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE0D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BE0DC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828BE0E0: 48002531  bl 0x828c0610
	ctx.lr = 0x828BE0E4;
	sub_828C0610(ctx, base);
	// 828BE0E4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828BE0E8: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828BE0EC: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 828BE0F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE0F4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BE0F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE0FC: 419A000C  beq cr6, 0x828be108
	if ctx.cr[6].eq {
	pc = 0x828BE108; continue 'dispatch;
	}
	// 828BE100: 4B95DC39  bl 0x8221bd38
	ctx.lr = 0x828BE104;
	sub_8221BD38(ctx, base);
	// 828BE104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x828BE108; continue 'dispatch;
            }
            0x828BE108 => {
    //   block [0x828BE108..0x828BE120)
	// 828BE108: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BE10C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BE110: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BE114: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BE118: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BE11C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BE120 size=8
    let mut pc: u32 = 0x828BE120;
    'dispatch: loop {
        match pc {
            0x828BE120 => {
    //   block [0x828BE120..0x828BE128)
	// 828BE120: 3860000A  li r3, 0xa
	ctx.r[3].s64 = 10;
	// 828BE124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BE128 size=160
    let mut pc: u32 = 0x828BE128;
    'dispatch: loop {
        match pc {
            0x828BE128 => {
    //   block [0x828BE128..0x828BE1C8)
	// 828BE128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE12C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BE130: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828BE134: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BE138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE13C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE140: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828BE144: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828BE148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE14C: 388B2F30  addi r4, r11, 0x2f30
	ctx.r[4].s64 = ctx.r[11].s64 + 12080;
	// 828BE150: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 828BE154: 4BAEF29D  bl 0x823ad3f0
	ctx.lr = 0x828BE158;
	sub_823AD3F0(ctx, base);
	// 828BE158: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828BE15C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE160: 388A2F40  addi r4, r10, 0x2f40
	ctx.r[4].s64 = ctx.r[10].s64 + 12096;
	// 828BE164: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 828BE168: 4BAEF289  bl 0x823ad3f0
	ctx.lr = 0x828BE16C;
	sub_823AD3F0(ctx, base);
	// 828BE16C: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828BE170: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 828BE174: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE178: 38892F5C  addi r4, r9, 0x2f5c
	ctx.r[4].s64 = ctx.r[9].s64 + 12124;
	// 828BE17C: 4BAEF275  bl 0x823ad3f0
	ctx.lr = 0x828BE180;
	sub_823AD3F0(ctx, base);
	// 828BE180: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 828BE184: C1BF001C  lfs f13, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BE188: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 828BE18C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828BE190: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 828BE194: 38862F6C  addi r4, r6, 0x2f6c
	ctx.r[4].s64 = ctx.r[6].s64 + 12140;
	// 828BE198: C8089660  lfd f0, -0x69a0(r8)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(-27040 as u32) ) };
	// 828BE19C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BE1A0: FD8D0032  fmul f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 828BE1A4: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 828BE1A8: 7D7F3FAE  stfiwx f11, r31, r7
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 828BE1AC: 4BAEF245  bl 0x823ad3f0
	ctx.lr = 0x828BE1B0;
	sub_823AD3F0(ctx, base);
	// 828BE1B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BE1B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BE1B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BE1BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BE1C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BE1C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE1C8 size=164
    let mut pc: u32 = 0x828BE1C8;
    'dispatch: loop {
        match pc {
            0x828BE1C8 => {
    //   block [0x828BE1C8..0x828BE224)
	// 828BE1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE1CC: 483EB241  bl 0x82ca940c
	ctx.lr = 0x828BE1D0;
	sub_82CA93D0(ctx, base);
	// 828BE1D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE1D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BE1D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BE1DC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828BE1E0: 3BCB0CA0  addi r30, r11, 0xca0
	ctx.r[30].s64 = ctx.r[11].s64 + 3232;
	// 828BE1E4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BE1E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE1EC: 409A0038  bne cr6, 0x828be224
	if !ctx.cr[6].eq {
	pc = 0x828BE224; continue 'dispatch;
	}
	// 828BE1F0: 807D0064  lwz r3, 0x64(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE1F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BE1F8: 419A002C  beq cr6, 0x828be224
	if ctx.cr[6].eq {
	pc = 0x828BE224; continue 'dispatch;
	}
	// 828BE1FC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828BE200: 388BE398  addi r4, r11, -0x1c68
	ctx.r[4].s64 = ctx.r[11].s64 + -7272;
	// 828BE204: 485C94CD  bl 0x82e876d0
	ctx.lr = 0x828BE208;
	sub_82E876D0(ctx, base);
	// 828BE208: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 828BE20C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BE210: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BE214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE218: 4B96ECB9  bl 0x8222ced0
	ctx.lr = 0x828BE21C;
	sub_8222CED0(ctx, base);
	// 828BE21C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE220: 4B956BB9  bl 0x82214dd8
	ctx.lr = 0x828BE224;
	sub_82214DD8(ctx, base);
	pc = 0x828BE224; continue 'dispatch;
            }
            0x828BE224 => {
    //   block [0x828BE224..0x828BE264)
	// 828BE224: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BE228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE22C: 409A0038  bne cr6, 0x828be264
	if !ctx.cr[6].eq {
	pc = 0x828BE264; continue 'dispatch;
	}
	// 828BE230: 807D0064  lwz r3, 0x64(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE234: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BE238: 419A002C  beq cr6, 0x828be264
	if ctx.cr[6].eq {
	pc = 0x828BE264; continue 'dispatch;
	}
	// 828BE23C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828BE240: 388BE284  addi r4, r11, -0x1d7c
	ctx.r[4].s64 = ctx.r[11].s64 + -7548;
	// 828BE244: 485C948D  bl 0x82e876d0
	ctx.lr = 0x828BE248;
	sub_82E876D0(ctx, base);
	// 828BE248: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 828BE24C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BE250: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BE254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE258: 4B96EC79  bl 0x8222ced0
	ctx.lr = 0x828BE25C;
	sub_8222CED0(ctx, base);
	// 828BE25C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BE260: 4B956B79  bl 0x82214dd8
	ctx.lr = 0x828BE264;
	sub_82214DD8(ctx, base);
	pc = 0x828BE264; continue 'dispatch;
            }
            0x828BE264 => {
    //   block [0x828BE264..0x828BE26C)
	// 828BE264: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828BE268: 483EB1F4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BE270 size=992
    let mut pc: u32 = 0x828BE270;
    'dispatch: loop {
        match pc {
            0x828BE270 => {
    //   block [0x828BE270..0x828BE2B0)
	// 828BE270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE274: 483EB18D  bl 0x82ca9400
	ctx.lr = 0x828BE278;
	sub_82CA93D0(ctx, base);
	// 828BE278: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE27C: 83830010  lwz r28, 0x10(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BE280: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828BE284: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828BE288: 419A03BC  beq cr6, 0x828be644
	if ctx.cr[6].eq {
	pc = 0x828BE644; continue 'dispatch;
	}
	// 828BE28C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828BE290: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 828BE294: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828BE298: 419A0018  beq cr6, 0x828be2b0
	if ctx.cr[6].eq {
	pc = 0x828BE2B0; continue 'dispatch;
	}
	// 828BE29C: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BE2A0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BE2A4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE2A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE2AC: 409A0008  bne cr6, 0x828be2b4
	if !ctx.cr[6].eq {
	pc = 0x828BE2B4; continue 'dispatch;
	}
	pc = 0x828BE2B0; continue 'dispatch;
            }
            0x828BE2B0 => {
    //   block [0x828BE2B0..0x828BE2B4)
	// 828BE2B0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828BE2B4; continue 'dispatch;
            }
            0x828BE2B4 => {
    //   block [0x828BE2B4..0x828BE308)
	// 828BE2B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE2B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE2BC: 419A0388  beq cr6, 0x828be644
	if ctx.cr[6].eq {
	pc = 0x828BE644; continue 'dispatch;
	}
	// 828BE2C0: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE2C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE2C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BE2CC: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 828BE2D0: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 828BE2D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE2D8: 419A00F4  beq cr6, 0x828be3cc
	if ctx.cr[6].eq {
	pc = 0x828BE3CC; continue 'dispatch;
	}
	// 828BE2DC: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BE2E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE2E4: 419A0024  beq cr6, 0x828be308
	if ctx.cr[6].eq {
	pc = 0x828BE308; continue 'dispatch;
	}
	// 828BE2E8: 894B003B  lbz r10, 0x3b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 828BE2EC: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE2F0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828BE2F4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BE2F8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE2FC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828BE300: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE304: 480000CC  b 0x828be3d0
	pc = 0x828BE3D0; continue 'dispatch;
            }
            0x828BE308 => {
    //   block [0x828BE308..0x828BE324)
	// 828BE308: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE30C: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BE310: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828BE314: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BE318: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE31C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE320: 40810054  ble 0x828be374
	if !ctx.cr[0].gt {
	pc = 0x828BE374; continue 'dispatch;
	}
	pc = 0x828BE324; continue 'dispatch;
            }
            0x828BE324 => {
    //   block [0x828BE324..0x828BE344)
	// 828BE324: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BE328: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BE32C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828BE330: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE334: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 828BE338: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828BE33C: 41980008  blt cr6, 0x828be344
	if ctx.cr[6].lt {
	pc = 0x828BE344; continue 'dispatch;
	}
	// 828BE340: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x828BE344; continue 'dispatch;
            }
            0x828BE344 => {
    //   block [0x828BE344..0x828BE360)
	// 828BE344: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BE348: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BE34C: 419A0014  beq cr6, 0x828be360
	if ctx.cr[6].eq {
	pc = 0x828BE360; continue 'dispatch;
	}
	// 828BE350: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BE354: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BE358: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BE35C: 4800000C  b 0x828be368
	pc = 0x828BE368; continue 'dispatch;
            }
            0x828BE360 => {
    //   block [0x828BE360..0x828BE368)
	// 828BE360: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BE364: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828BE368; continue 'dispatch;
            }
            0x828BE368 => {
    //   block [0x828BE368..0x828BE374)
	// 828BE368: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE36C: 4199FFB8  bgt cr6, 0x828be324
	if ctx.cr[6].gt {
	pc = 0x828BE324; continue 'dispatch;
	}
	// 828BE370: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x828BE374; continue 'dispatch;
            }
            0x828BE374 => {
    //   block [0x828BE374..0x828BE390)
	// 828BE374: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BE378: 419A0040  beq cr6, 0x828be3b8
	if ctx.cr[6].eq {
	pc = 0x828BE3B8; continue 'dispatch;
	}
	// 828BE37C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE380: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 828BE384: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE388: 41990008  bgt cr6, 0x828be390
	if ctx.cr[6].gt {
	pc = 0x828BE390; continue 'dispatch;
	}
	// 828BE38C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828BE390; continue 'dispatch;
            }
            0x828BE390 => {
    //   block [0x828BE390..0x828BE3B8)
	// 828BE390: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE394: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE398: 409A0020  bne cr6, 0x828be3b8
	if !ctx.cr[6].eq {
	pc = 0x828BE3B8; continue 'dispatch;
	}
	// 828BE39C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BE3A0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BE3A4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE3A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE3AC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828BE3B0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE3B4: 4800001C  b 0x828be3d0
	pc = 0x828BE3D0; continue 'dispatch;
            }
            0x828BE3B8 => {
    //   block [0x828BE3B8..0x828BE3CC)
	// 828BE3B8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BE3BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE3C0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828BE3C4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE3C8: 48000008  b 0x828be3d0
	pc = 0x828BE3D0; continue 'dispatch;
            }
            0x828BE3CC => {
    //   block [0x828BE3CC..0x828BE3D0)
	// 828BE3CC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828BE3D0; continue 'dispatch;
            }
            0x828BE3D0 => {
    //   block [0x828BE3D0..0x828BE418)
	// 828BE3D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE3D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE3D8: 419A026C  beq cr6, 0x828be644
	if ctx.cr[6].eq {
	pc = 0x828BE644; continue 'dispatch;
	}
	// 828BE3DC: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 828BE3E0: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 828BE3E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE3E8: 419A00F0  beq cr6, 0x828be4d8
	if ctx.cr[6].eq {
	pc = 0x828BE4D8; continue 'dispatch;
	}
	// 828BE3EC: 817B008C  lwz r11, 0x8c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BE3F0: 815B0048  lwz r10, 0x48(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE3F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE3F8: 419A0020  beq cr6, 0x828be418
	if ctx.cr[6].eq {
	pc = 0x828BE418; continue 'dispatch;
	}
	// 828BE3FC: 896B003B  lbz r11, 0x3b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 828BE400: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828BE404: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BE408: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE40C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828BE410: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE414: 480000C8  b 0x828be4dc
	pc = 0x828BE4DC; continue 'dispatch;
            }
            0x828BE418 => {
    //   block [0x828BE418..0x828BE430)
	// 828BE418: 80DB004C  lwz r6, 0x4c(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BE41C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828BE420: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BE424: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE428: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE42C: 40810054  ble 0x828be480
	if !ctx.cr[0].gt {
	pc = 0x828BE480; continue 'dispatch;
	}
	pc = 0x828BE430; continue 'dispatch;
            }
            0x828BE430 => {
    //   block [0x828BE430..0x828BE450)
	// 828BE430: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BE434: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BE438: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828BE43C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE440: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 828BE444: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828BE448: 41980008  blt cr6, 0x828be450
	if ctx.cr[6].lt {
	pc = 0x828BE450; continue 'dispatch;
	}
	// 828BE44C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x828BE450; continue 'dispatch;
            }
            0x828BE450 => {
    //   block [0x828BE450..0x828BE46C)
	// 828BE450: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BE454: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BE458: 419A0014  beq cr6, 0x828be46c
	if ctx.cr[6].eq {
	pc = 0x828BE46C; continue 'dispatch;
	}
	// 828BE45C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BE460: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BE464: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BE468: 4800000C  b 0x828be474
	pc = 0x828BE474; continue 'dispatch;
            }
            0x828BE46C => {
    //   block [0x828BE46C..0x828BE474)
	// 828BE46C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BE470: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828BE474; continue 'dispatch;
            }
            0x828BE474 => {
    //   block [0x828BE474..0x828BE480)
	// 828BE474: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE478: 4199FFB8  bgt cr6, 0x828be430
	if ctx.cr[6].gt {
	pc = 0x828BE430; continue 'dispatch;
	}
	// 828BE47C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x828BE480; continue 'dispatch;
            }
            0x828BE480 => {
    //   block [0x828BE480..0x828BE49C)
	// 828BE480: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BE484: 419A0040  beq cr6, 0x828be4c4
	if ctx.cr[6].eq {
	pc = 0x828BE4C4; continue 'dispatch;
	}
	// 828BE488: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE48C: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 828BE490: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE494: 41990008  bgt cr6, 0x828be49c
	if ctx.cr[6].gt {
	pc = 0x828BE49C; continue 'dispatch;
	}
	// 828BE498: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828BE49C; continue 'dispatch;
            }
            0x828BE49C => {
    //   block [0x828BE49C..0x828BE4C4)
	// 828BE49C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE4A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE4A4: 409A0020  bne cr6, 0x828be4c4
	if !ctx.cr[6].eq {
	pc = 0x828BE4C4; continue 'dispatch;
	}
	// 828BE4A8: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BE4AC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BE4B0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE4B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE4B8: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828BE4BC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE4C0: 4800001C  b 0x828be4dc
	pc = 0x828BE4DC; continue 'dispatch;
            }
            0x828BE4C4 => {
    //   block [0x828BE4C4..0x828BE4D8)
	// 828BE4C4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BE4C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE4CC: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828BE4D0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828BE4D4: 48000008  b 0x828be4dc
	pc = 0x828BE4DC; continue 'dispatch;
            }
            0x828BE4D8 => {
    //   block [0x828BE4D8..0x828BE4DC)
	// 828BE4D8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828BE4DC; continue 'dispatch;
            }
            0x828BE4DC => {
    //   block [0x828BE4DC..0x828BE564)
	// 828BE4DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE4E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE4E4: 419A0160  beq cr6, 0x828be644
	if ctx.cr[6].eq {
	pc = 0x828BE644; continue 'dispatch;
	}
	// 828BE4E8: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 828BE4EC: 83E4000C  lwz r31, 0xc(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BE4F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BE4F4: 83C5000C  lwz r30, 0xc(r5)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BE4F8: 419A00E4  beq cr6, 0x828be5dc
	if ctx.cr[6].eq {
	pc = 0x828BE5DC; continue 'dispatch;
	}
	// 828BE4FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BE500: 419A00DC  beq cr6, 0x828be5dc
	if ctx.cr[6].eq {
	pc = 0x828BE5DC; continue 'dispatch;
	}
	// 828BE504: 897C0044  lbz r11, 0x44(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 828BE508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE50C: 409A0070  bne cr6, 0x828be57c
	if !ctx.cr[6].eq {
	pc = 0x828BE57C; continue 'dispatch;
	}
	// 828BE510: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BE514: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE518: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BE51C: 480041E5  bl 0x828c2700
	ctx.lr = 0x828BE520;
	sub_828C2700(ctx, base);
	// 828BE520: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BE524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE528: 419A0054  beq cr6, 0x828be57c
	if ctx.cr[6].eq {
	pc = 0x828BE57C; continue 'dispatch;
	}
	// 828BE52C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BE530: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE534: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BE538: 48004229  bl 0x828c2760
	ctx.lr = 0x828BE53C;
	sub_828C2760(ctx, base);
	// 828BE53C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BE540: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 828BE544: 419A0100  beq cr6, 0x828be644
	if ctx.cr[6].eq {
	pc = 0x828BE644; continue 'dispatch;
	}
	// 828BE548: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 828BE54C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828BE550: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828BE554: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BE558: 48004019  bl 0x828c2570
	ctx.lr = 0x828BE55C;
	sub_828C2570(ctx, base);
	// 828BE55C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 828BE560: 419A00E4  beq cr6, 0x828be644
	if ctx.cr[6].eq {
	pc = 0x828BE644; continue 'dispatch;
	}
	pc = 0x828BE564; continue 'dispatch;
            }
            0x828BE564 => {
    //   block [0x828BE564..0x828BE57C)
	// 828BE564: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BE568: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828BE56C: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 828BE570: 5523DFFE  rlwinm r3, r9, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828BE574: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BE578: 483EAED8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x828BE57C => {
    //   block [0x828BE57C..0x828BE580)
	// 828BE57C: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	pc = 0x828BE580; continue 'dispatch;
            }
            0x828BE580 => {
    //   block [0x828BE580..0x828BE5DC)
	// 828BE580: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828BE584: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BE588: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BE58C: 4BA14DCD  bl 0x822d3358
	ctx.lr = 0x828BE590;
	sub_822D3358(ctx, base);
	// 828BE590: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE594: 38E10051  addi r7, r1, 0x51
	ctx.r[7].s64 = ctx.r[1].s64 + 81;
	// 828BE598: 9B410051  stb r26, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[26].u8 ) };
	// 828BE59C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828BE5A0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BE5A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BE5A8: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BE5AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828BE5B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BE5B4: 4E800421  bctrl
	ctx.lr = 0x828BE5B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BE5B8: 89010051  lbz r8, 0x51(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828BE5BC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828BE5C0: 419AFFC0  beq cr6, 0x828be580
	if ctx.cr[6].eq {
	pc = 0x828BE580; continue 'dispatch;
	}
	// 828BE5C4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BE5C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE5CC: 409AFF98  bne cr6, 0x828be564
	if !ctx.cr[6].eq {
	pc = 0x828BE564; continue 'dispatch;
	}
	// 828BE5D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BE5D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BE5D8: 483EAE78  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x828BE5DC => {
    //   block [0x828BE5DC..0x828BE644)
	// 828BE5DC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828BE5E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BE5E4: 388B2F8C  addi r4, r11, 0x2f8c
	ctx.r[4].s64 = ctx.r[11].s64 + 12172;
	// 828BE5E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BE5EC: 3BFB0080  addi r31, r27, 0x80
	ctx.r[31].s64 = ctx.r[27].s64 + 128;
	// 828BE5F0: 4B96E8E1  bl 0x8222ced0
	ctx.lr = 0x828BE5F4;
	sub_8222CED0(ctx, base);
	// 828BE5F4: 389D0080  addi r4, r29, 0x80
	ctx.r[4].s64 = ctx.r[29].s64 + 128;
	// 828BE5F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BE5FC: 4B92E1FD  bl 0x821ec7f8
	ctx.lr = 0x828BE600;
	sub_821EC7F8(ctx, base);
	// 828BE600: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828BE604: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BE608: 4B931C39  bl 0x821f0240
	ctx.lr = 0x828BE60C;
	sub_821F0240(ctx, base);
	// 828BE60C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828BE610: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BE614: 388A4A00  addi r4, r10, 0x4a00
	ctx.r[4].s64 = ctx.r[10].s64 + 18944;
	// 828BE618: 4B91C3A9  bl 0x821da9c0
	ctx.lr = 0x828BE61C;
	sub_821DA9C0(ctx, base);
	// 828BE61C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BE620: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828BE624: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BE628: 4B924AE1  bl 0x821e3108
	ctx.lr = 0x828BE62C;
	sub_821E3108(ctx, base);
	// 828BE62C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BE630: 4B9567A9  bl 0x82214dd8
	ctx.lr = 0x828BE634;
	sub_82214DD8(ctx, base);
	// 828BE634: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BE638: 4B9567A1  bl 0x82214dd8
	ctx.lr = 0x828BE63C;
	sub_82214DD8(ctx, base);
	// 828BE63C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BE640: 4B956799  bl 0x82214dd8
	ctx.lr = 0x828BE644;
	sub_82214DD8(ctx, base);
	pc = 0x828BE644; continue 'dispatch;
            }
            0x828BE644 => {
    //   block [0x828BE644..0x828BE650)
	// 828BE644: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BE648: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828BE64C: 483EAE04  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BE650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BE650 size=1404
    let mut pc: u32 = 0x828BE650;
    'dispatch: loop {
        match pc {
            0x828BE650 => {
    //   block [0x828BE650..0x828BE6A8)
	// 828BE650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BE654: 483EADA1  bl 0x82ca93f4
	ctx.lr = 0x828BE658;
	sub_82CA93D0(ctx, base);
	// 828BE658: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BE65C: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828BE660: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828BE664: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828BE668: C1B70018  lfs f13, 0x18(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828BE66C: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BE670: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828BE674: 4099054C  ble cr6, 0x828bebc0
	if !ctx.cr[6].gt {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BE678: 8177000C  lwz r11, 0xc(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BE67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE680: 419A0540  beq cr6, 0x828bebc0
	if ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BE684: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828BE688: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 828BE68C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828BE690: 419A0018  beq cr6, 0x828be6a8
	if ctx.cr[6].eq {
	pc = 0x828BE6A8; continue 'dispatch;
	}
	// 828BE694: 897A0090  lbz r11, 0x90(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BE698: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BE69C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE6A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE6A4: 409A0008  bne cr6, 0x828be6ac
	if !ctx.cr[6].eq {
	pc = 0x828BE6AC; continue 'dispatch;
	}
	pc = 0x828BE6A8; continue 'dispatch;
            }
            0x828BE6A8 => {
    //   block [0x828BE6A8..0x828BE6AC)
	// 828BE6A8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x828BE6AC; continue 'dispatch;
            }
            0x828BE6AC => {
    //   block [0x828BE6AC..0x828BE704)
	// 828BE6AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE6B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE6B4: 419A050C  beq cr6, 0x828bebc0
	if ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BE6B8: 817A0024  lwz r11, 0x24(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 828BE6BC: 3BDA0024  addi r30, r26, 0x24
	ctx.r[30].s64 = ctx.r[26].s64 + 36;
	// 828BE6C0: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 828BE6C4: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 828BE6C8: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 828BE6CC: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 828BE6D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE6D4: 419A00F4  beq cr6, 0x828be7c8
	if ctx.cr[6].eq {
	pc = 0x828BE7C8; continue 'dispatch;
	}
	// 828BE6D8: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BE6DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE6E0: 419A0024  beq cr6, 0x828be704
	if ctx.cr[6].eq {
	pc = 0x828BE704; continue 'dispatch;
	}
	// 828BE6E4: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828BE6E8: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE6EC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828BE6F0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BE6F4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE6F8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828BE6FC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE700: 480000CC  b 0x828be7cc
	pc = 0x828BE7CC; continue 'dispatch;
            }
            0x828BE704 => {
    //   block [0x828BE704..0x828BE720)
	// 828BE704: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE708: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BE70C: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 828BE710: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BE714: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE718: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE71C: 40810054  ble 0x828be770
	if !ctx.cr[0].gt {
	pc = 0x828BE770; continue 'dispatch;
	}
	pc = 0x828BE720; continue 'dispatch;
            }
            0x828BE720 => {
    //   block [0x828BE720..0x828BE740)
	// 828BE720: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BE724: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BE728: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828BE72C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE730: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 828BE734: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 828BE738: 41980008  blt cr6, 0x828be740
	if ctx.cr[6].lt {
	pc = 0x828BE740; continue 'dispatch;
	}
	// 828BE73C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x828BE740; continue 'dispatch;
            }
            0x828BE740 => {
    //   block [0x828BE740..0x828BE75C)
	// 828BE740: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BE744: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BE748: 419A0014  beq cr6, 0x828be75c
	if ctx.cr[6].eq {
	pc = 0x828BE75C; continue 'dispatch;
	}
	// 828BE74C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BE750: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BE754: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BE758: 4800000C  b 0x828be764
	pc = 0x828BE764; continue 'dispatch;
            }
            0x828BE75C => {
    //   block [0x828BE75C..0x828BE764)
	// 828BE75C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BE760: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828BE764; continue 'dispatch;
            }
            0x828BE764 => {
    //   block [0x828BE764..0x828BE770)
	// 828BE764: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE768: 4199FFB8  bgt cr6, 0x828be720
	if ctx.cr[6].gt {
	pc = 0x828BE720; continue 'dispatch;
	}
	// 828BE76C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x828BE770; continue 'dispatch;
            }
            0x828BE770 => {
    //   block [0x828BE770..0x828BE78C)
	// 828BE770: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BE774: 419A0040  beq cr6, 0x828be7b4
	if ctx.cr[6].eq {
	pc = 0x828BE7B4; continue 'dispatch;
	}
	// 828BE778: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE77C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 828BE780: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE784: 41990008  bgt cr6, 0x828be78c
	if ctx.cr[6].gt {
	pc = 0x828BE78C; continue 'dispatch;
	}
	// 828BE788: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x828BE78C; continue 'dispatch;
            }
            0x828BE78C => {
    //   block [0x828BE78C..0x828BE7B4)
	// 828BE78C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE794: 409A0020  bne cr6, 0x828be7b4
	if !ctx.cr[6].eq {
	pc = 0x828BE7B4; continue 'dispatch;
	}
	// 828BE798: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BE79C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BE7A0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE7A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE7A8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828BE7AC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE7B0: 4800001C  b 0x828be7cc
	pc = 0x828BE7CC; continue 'dispatch;
            }
            0x828BE7B4 => {
    //   block [0x828BE7B4..0x828BE7C8)
	// 828BE7B4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BE7B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE7BC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828BE7C0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE7C4: 48000008  b 0x828be7cc
	pc = 0x828BE7CC; continue 'dispatch;
            }
            0x828BE7C8 => {
    //   block [0x828BE7C8..0x828BE7CC)
	// 828BE7C8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x828BE7CC; continue 'dispatch;
            }
            0x828BE7CC => {
    //   block [0x828BE7CC..0x828BE808)
	// 828BE7CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE7D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE7D4: 419A0034  beq cr6, 0x828be808
	if ctx.cr[6].eq {
	pc = 0x828BE808; continue 'dispatch;
	}
	// 828BE7D8: 3880002C  li r4, 0x2c
	ctx.r[4].s64 = 44;
	// 828BE7DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE7E0: 4B940DE9  bl 0x821ff5c8
	ctx.lr = 0x828BE7E4;
	sub_821FF5C8(ctx, base);
	// 828BE7E4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BE7E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE7EC: 409A03D4  bne cr6, 0x828bebc0
	if !ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BE7F0: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 828BE7F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BE7F8: 4B940DD1  bl 0x821ff5c8
	ctx.lr = 0x828BE7FC;
	sub_821FF5C8(ctx, base);
	// 828BE7FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BE800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE804: 409A03BC  bne cr6, 0x828bebc0
	if !ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	pc = 0x828BE808; continue 'dispatch;
            }
            0x828BE808 => {
    //   block [0x828BE808..0x828BE848)
	// 828BE808: 83970004  lwz r28, 4(r23)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE80C: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 828BE810: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 828BE814: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE818: 419A00F4  beq cr6, 0x828be90c
	if ctx.cr[6].eq {
	pc = 0x828BE90C; continue 'dispatch;
	}
	// 828BE81C: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BE820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE824: 419A0024  beq cr6, 0x828be848
	if ctx.cr[6].eq {
	pc = 0x828BE848; continue 'dispatch;
	}
	// 828BE828: 894B003B  lbz r10, 0x3b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 828BE82C: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE830: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828BE834: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BE838: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE83C: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828BE840: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE844: 480000CC  b 0x828be910
	pc = 0x828BE910; continue 'dispatch;
            }
            0x828BE848 => {
    //   block [0x828BE848..0x828BE864)
	// 828BE848: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE84C: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BE850: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 828BE854: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BE858: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE85C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE860: 40810054  ble 0x828be8b4
	if !ctx.cr[0].gt {
	pc = 0x828BE8B4; continue 'dispatch;
	}
	pc = 0x828BE864; continue 'dispatch;
            }
            0x828BE864 => {
    //   block [0x828BE864..0x828BE884)
	// 828BE864: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BE868: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BE86C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828BE870: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE874: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 828BE878: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 828BE87C: 41980008  blt cr6, 0x828be884
	if ctx.cr[6].lt {
	pc = 0x828BE884; continue 'dispatch;
	}
	// 828BE880: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x828BE884; continue 'dispatch;
            }
            0x828BE884 => {
    //   block [0x828BE884..0x828BE8A0)
	// 828BE884: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BE888: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BE88C: 419A0014  beq cr6, 0x828be8a0
	if ctx.cr[6].eq {
	pc = 0x828BE8A0; continue 'dispatch;
	}
	// 828BE890: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BE894: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BE898: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BE89C: 4800000C  b 0x828be8a8
	pc = 0x828BE8A8; continue 'dispatch;
            }
            0x828BE8A0 => {
    //   block [0x828BE8A0..0x828BE8A8)
	// 828BE8A0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BE8A4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828BE8A8; continue 'dispatch;
            }
            0x828BE8A8 => {
    //   block [0x828BE8A8..0x828BE8B4)
	// 828BE8A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE8AC: 4199FFB8  bgt cr6, 0x828be864
	if ctx.cr[6].gt {
	pc = 0x828BE864; continue 'dispatch;
	}
	// 828BE8B0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x828BE8B4; continue 'dispatch;
            }
            0x828BE8B4 => {
    //   block [0x828BE8B4..0x828BE8D0)
	// 828BE8B4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BE8B8: 419A0040  beq cr6, 0x828be8f8
	if ctx.cr[6].eq {
	pc = 0x828BE8F8; continue 'dispatch;
	}
	// 828BE8BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE8C0: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 828BE8C4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE8C8: 41990008  bgt cr6, 0x828be8d0
	if ctx.cr[6].gt {
	pc = 0x828BE8D0; continue 'dispatch;
	}
	// 828BE8CC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x828BE8D0; continue 'dispatch;
            }
            0x828BE8D0 => {
    //   block [0x828BE8D0..0x828BE8F8)
	// 828BE8D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE8D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE8D8: 409A0020  bne cr6, 0x828be8f8
	if !ctx.cr[6].eq {
	pc = 0x828BE8F8; continue 'dispatch;
	}
	// 828BE8DC: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BE8E0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BE8E4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE8E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE8EC: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828BE8F0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE8F4: 4800001C  b 0x828be910
	pc = 0x828BE910; continue 'dispatch;
            }
            0x828BE8F8 => {
    //   block [0x828BE8F8..0x828BE90C)
	// 828BE8F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BE8FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE900: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 828BE904: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE908: 48000008  b 0x828be910
	pc = 0x828BE910; continue 'dispatch;
            }
            0x828BE90C => {
    //   block [0x828BE90C..0x828BE910)
	// 828BE90C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x828BE910; continue 'dispatch;
            }
            0x828BE910 => {
    //   block [0x828BE910..0x828BE958)
	// 828BE910: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE918: 419A02A8  beq cr6, 0x828bebc0
	if ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BE91C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE920: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 828BE924: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BE928: 419A00F0  beq cr6, 0x828bea18
	if ctx.cr[6].eq {
	pc = 0x828BEA18; continue 'dispatch;
	}
	// 828BE92C: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BE930: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BE934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE938: 419A0020  beq cr6, 0x828be958
	if ctx.cr[6].eq {
	pc = 0x828BE958; continue 'dispatch;
	}
	// 828BE93C: 896B003B  lbz r11, 0x3b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 828BE940: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828BE944: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BE948: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE94C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828BE950: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE954: 480000C8  b 0x828bea1c
	pc = 0x828BEA1C; continue 'dispatch;
            }
            0x828BE958 => {
    //   block [0x828BE958..0x828BE970)
	// 828BE958: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BE95C: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 828BE960: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BE964: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BE968: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE96C: 40810054  ble 0x828be9c0
	if !ctx.cr[0].gt {
	pc = 0x828BE9C0; continue 'dispatch;
	}
	pc = 0x828BE970; continue 'dispatch;
            }
            0x828BE970 => {
    //   block [0x828BE970..0x828BE990)
	// 828BE970: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BE974: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BE978: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828BE97C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE980: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 828BE984: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 828BE988: 41980008  blt cr6, 0x828be990
	if ctx.cr[6].lt {
	pc = 0x828BE990; continue 'dispatch;
	}
	// 828BE98C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x828BE990; continue 'dispatch;
            }
            0x828BE990 => {
    //   block [0x828BE990..0x828BE9AC)
	// 828BE990: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BE994: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BE998: 419A0014  beq cr6, 0x828be9ac
	if ctx.cr[6].eq {
	pc = 0x828BE9AC; continue 'dispatch;
	}
	// 828BE99C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BE9A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BE9A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BE9A8: 4800000C  b 0x828be9b4
	pc = 0x828BE9B4; continue 'dispatch;
            }
            0x828BE9AC => {
    //   block [0x828BE9AC..0x828BE9B4)
	// 828BE9AC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BE9B0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828BE9B4; continue 'dispatch;
            }
            0x828BE9B4 => {
    //   block [0x828BE9B4..0x828BE9C0)
	// 828BE9B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BE9B8: 4199FFB8  bgt cr6, 0x828be970
	if ctx.cr[6].gt {
	pc = 0x828BE970; continue 'dispatch;
	}
	// 828BE9BC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x828BE9C0; continue 'dispatch;
            }
            0x828BE9C0 => {
    //   block [0x828BE9C0..0x828BE9DC)
	// 828BE9C0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BE9C4: 419A0040  beq cr6, 0x828bea04
	if ctx.cr[6].eq {
	pc = 0x828BEA04; continue 'dispatch;
	}
	// 828BE9C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BE9CC: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 828BE9D0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BE9D4: 41990008  bgt cr6, 0x828be9dc
	if ctx.cr[6].gt {
	pc = 0x828BE9DC; continue 'dispatch;
	}
	// 828BE9D8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x828BE9DC; continue 'dispatch;
            }
            0x828BE9DC => {
    //   block [0x828BE9DC..0x828BEA04)
	// 828BE9DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BE9E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BE9E4: 409A0020  bne cr6, 0x828bea04
	if !ctx.cr[6].eq {
	pc = 0x828BEA04; continue 'dispatch;
	}
	// 828BE9E8: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BE9EC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BE9F0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BE9F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BE9F8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828BE9FC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BEA00: 4800001C  b 0x828bea1c
	pc = 0x828BEA1C; continue 'dispatch;
            }
            0x828BEA04 => {
    //   block [0x828BEA04..0x828BEA18)
	// 828BEA04: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BEA08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEA0C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828BEA10: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828BEA14: 48000008  b 0x828bea1c
	pc = 0x828BEA1C; continue 'dispatch;
            }
            0x828BEA18 => {
    //   block [0x828BEA18..0x828BEA1C)
	// 828BEA18: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x828BEA1C; continue 'dispatch;
            }
            0x828BEA1C => {
    //   block [0x828BEA1C..0x828BEAA8)
	// 828BEA1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BEA20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEA24: 419A019C  beq cr6, 0x828bebc0
	if ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BEA28: 83DB000C  lwz r30, 0xc(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEA2C: 83BD000C  lwz r29, 0xc(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEA30: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828BEA34: 419A0124  beq cr6, 0x828beb58
	if ctx.cr[6].eq {
	pc = 0x828BEB58; continue 'dispatch;
	}
	// 828BEA38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828BEA3C: 419A011C  beq cr6, 0x828beb58
	if ctx.cr[6].eq {
	pc = 0x828BEB58; continue 'dispatch;
	}
	// 828BEA40: 83F7000C  lwz r31, 0xc(r23)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEA44: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 828BEA48: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 828BEA4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEA50: 409A0070  bne cr6, 0x828beac0
	if !ctx.cr[6].eq {
	pc = 0x828BEAC0; continue 'dispatch;
	}
	// 828BEA54: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828BEA58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BEA5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEA60: 48003CA1  bl 0x828c2700
	ctx.lr = 0x828BEA64;
	sub_828C2700(ctx, base);
	// 828BEA64: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BEA68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEA6C: 419A0054  beq cr6, 0x828beac0
	if ctx.cr[6].eq {
	pc = 0x828BEAC0; continue 'dispatch;
	}
	// 828BEA70: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828BEA74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BEA78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEA7C: 48003CE5  bl 0x828c2760
	ctx.lr = 0x828BEA80;
	sub_828C2760(ctx, base);
	// 828BEA80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828BEA84: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 828BEA88: 419A0138  beq cr6, 0x828bebc0
	if ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BEA8C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828BEA90: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828BEA94: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828BEA98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEA9C: 48003AD5  bl 0x828c2570
	ctx.lr = 0x828BEAA0;
	sub_828C2570(ctx, base);
	// 828BEAA0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 828BEAA4: 419A011C  beq cr6, 0x828bebc0
	if ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	pc = 0x828BEAA8; continue 'dispatch;
            }
            0x828BEAA8 => {
    //   block [0x828BEAA8..0x828BEAC0)
	// 828BEAA8: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828BEAAC: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828BEAB0: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 828BEAB4: 5523DFFE  rlwinm r3, r9, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828BEAB8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BEABC: 483EA988  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x828BEAC0 => {
    //   block [0x828BEAC0..0x828BEADC)
	// 828BEAC0: 4B9A1EF9  bl 0x822609b8
	ctx.lr = 0x828BEAC4;
	sub_822609B8(ctx, base);
	// 828BEAC4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BEAC8: 485C2B89  bl 0x82e81650
	ctx.lr = 0x828BEACC;
	sub_82E81650(ctx, base);
	// 828BEACC: 897B006C  lbz r11, 0x6c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(108 as u32) ) } as u64;
	// 828BEAD0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828BEAD4: 419A00EC  beq cr6, 0x828bebc0
	if ctx.cr[6].eq {
	pc = 0x828BEBC0; continue 'dispatch;
	}
	// 828BEAD8: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	pc = 0x828BEADC; continue 'dispatch;
            }
            0x828BEADC => {
    //   block [0x828BEADC..0x828BEB40)
	// 828BEADC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828BEAE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828BEAE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEAE8: 4BA14871  bl 0x822d3358
	ctx.lr = 0x828BEAEC;
	sub_822D3358(ctx, base);
	// 828BEAEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEAF0: 38E10051  addi r7, r1, 0x51
	ctx.r[7].s64 = ctx.r[1].s64 + 81;
	// 828BEAF4: 9B010051  stb r24, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[24].u8 ) };
	// 828BEAF8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828BEAFC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828BEB00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BEB04: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BEB08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828BEB0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BEB10: 4E800421  bctrl
	ctx.lr = 0x828BEB14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BEB14: 89010051  lbz r8, 0x51(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828BEB18: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828BEB1C: 409A0024  bne cr6, 0x828beb40
	if !ctx.cr[6].eq {
	pc = 0x828BEB40; continue 'dispatch;
	}
	// 828BEB20: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BEB24: 485C2B2D  bl 0x82e81650
	ctx.lr = 0x828BEB28;
	sub_82E81650(ctx, base);
	// 828BEB28: 897B006C  lbz r11, 0x6c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(108 as u32) ) } as u64;
	// 828BEB2C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828BEB30: 409AFFAC  bne cr6, 0x828beadc
	if !ctx.cr[6].eq {
	pc = 0x828BEADC; continue 'dispatch;
	}
	// 828BEB34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BEB38: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BEB3C: 483EA908  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x828BEB40 => {
    //   block [0x828BEB40..0x828BEB58)
	// 828BEB40: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BEB44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEB48: 409AFF60  bne cr6, 0x828beaa8
	if !ctx.cr[6].eq {
	pc = 0x828BEAA8; continue 'dispatch;
	}
	// 828BEB4C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BEB50: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BEB54: 483EA8F0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x828BEB58 => {
    //   block [0x828BEB58..0x828BEBC0)
	// 828BEB58: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828BEB5C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828BEB60: 388B2F8C  addi r4, r11, 0x2f8c
	ctx.r[4].s64 = ctx.r[11].s64 + 12172;
	// 828BEB64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BEB68: 3BFA0080  addi r31, r26, 0x80
	ctx.r[31].s64 = ctx.r[26].s64 + 128;
	// 828BEB6C: 4B96E365  bl 0x8222ced0
	ctx.lr = 0x828BEB70;
	sub_8222CED0(ctx, base);
	// 828BEB70: 389C0080  addi r4, r28, 0x80
	ctx.r[4].s64 = ctx.r[28].s64 + 128;
	// 828BEB74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BEB78: 4B92DC81  bl 0x821ec7f8
	ctx.lr = 0x828BEB7C;
	sub_821EC7F8(ctx, base);
	// 828BEB7C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828BEB80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BEB84: 4B9316BD  bl 0x821f0240
	ctx.lr = 0x828BEB88;
	sub_821F0240(ctx, base);
	// 828BEB88: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828BEB8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BEB90: 388A4A00  addi r4, r10, 0x4a00
	ctx.r[4].s64 = ctx.r[10].s64 + 18944;
	// 828BEB94: 4B91BE2D  bl 0x821da9c0
	ctx.lr = 0x828BEB98;
	sub_821DA9C0(ctx, base);
	// 828BEB98: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828BEB9C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828BEBA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BEBA4: 4B924565  bl 0x821e3108
	ctx.lr = 0x828BEBA8;
	sub_821E3108(ctx, base);
	// 828BEBA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828BEBAC: 4B95622D  bl 0x82214dd8
	ctx.lr = 0x828BEBB0;
	sub_82214DD8(ctx, base);
	// 828BEBB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828BEBB4: 4B956225  bl 0x82214dd8
	ctx.lr = 0x828BEBB8;
	sub_82214DD8(ctx, base);
	// 828BEBB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BEBBC: 4B95621D  bl 0x82214dd8
	ctx.lr = 0x828BEBC0;
	sub_82214DD8(ctx, base);
	pc = 0x828BEBC0; continue 'dispatch;
            }
            0x828BEBC0 => {
    //   block [0x828BEBC0..0x828BEBCC)
	// 828BEBC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828BEBC4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BEBC8: 483EA87C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BEBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BEBD0 size=160
    let mut pc: u32 = 0x828BEBD0;
    'dispatch: loop {
        match pc {
            0x828BEBD0 => {
    //   block [0x828BEBD0..0x828BEC70)
	// 828BEBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BEBD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BEBD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BEBDC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828BEBE0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEBE4: 8084007C  lwz r4, 0x7c(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(124 as u32) ) } as u64;
	// 828BEBE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BEBEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BEBF0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEBF4: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BEBF8: EFE00032  fmuls f31, f0, f0
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 828BEBFC: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BEC00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BEC04: 4E800421  bctrl
	ctx.lr = 0x828BEC08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BEC08: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEC0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828BEC10: 8089007C  lwz r4, 0x7c(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 828BEC14: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEC18: 80E80040  lwz r7, 0x40(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BEC1C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 828BEC20: 4E800421  bctrl
	ctx.lr = 0x828BEC24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BEC24: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828BEC28: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828BEC2C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828BEC30: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BEC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BEC70 size=672
    let mut pc: u32 = 0x828BEC70;
    'dispatch: loop {
        match pc {
            0x828BEC70 => {
    //   block [0x828BEC70..0x828BECA4)
	// 828BEC70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BEC74: 483EA77D  bl 0x82ca93f0
	ctx.lr = 0x828BEC78;
	sub_82CA93D0(ctx, base);
	// 828BEC78: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEC7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BEC80: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828BEC84: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828BEC88: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828BEC8C: 3BC30028  addi r30, r3, 0x28
	ctx.r[30].s64 = ctx.r[3].s64 + 40;
	// 828BEC90: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828BEC94: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 828BEC98: 3F208332  lis r25, -0x7cce
	ctx.r[25].s64 = -2093875200;
	// 828BEC9C: 3AEB0B7C  addi r23, r11, 0xb7c
	ctx.r[23].s64 = ctx.r[11].s64 + 2940;
	// 828BECA0: 3ACA0B7C  addi r22, r10, 0xb7c
	ctx.r[22].s64 = ctx.r[10].s64 + 2940;
	pc = 0x828BECA4; continue 'dispatch;
            }
            0x828BECA4 => {
    //   block [0x828BECA4..0x828BECC0)
	// 828BECA4: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BECA8: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 828BECAC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BECB0: 7D4BFA14  add r10, r11, r31
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828BECB4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BECB8: 40990008  ble cr6, 0x828becc0
	if !ctx.cr[6].gt {
	pc = 0x828BECC0; continue 'dispatch;
	}
	// 828BECBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BECC0; continue 'dispatch;
            }
            0x828BECC0 => {
    //   block [0x828BECC0..0x828BECD8)
	// 828BECC0: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BECC4: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BECC8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 828BECCC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BECD0: 40990008  ble cr6, 0x828becd8
	if !ctx.cr[6].gt {
	pc = 0x828BECD8; continue 'dispatch;
	}
	// 828BECD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BECD8; continue 'dispatch;
            }
            0x828BECD8 => {
    //   block [0x828BECD8..0x828BECE4)
	// 828BECD8: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BECDC: 419A0008  beq cr6, 0x828bece4
	if ctx.cr[6].eq {
	pc = 0x828BECE4; continue 'dispatch;
	}
	// 828BECE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BECE4; continue 'dispatch;
            }
            0x828BECE4 => {
    //   block [0x828BECE4..0x828BECFC)
	// 828BECE4: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BECE8: 419A00F4  beq cr6, 0x828beddc
	if ctx.cr[6].eq {
	pc = 0x828BEDDC; continue 'dispatch;
	}
	// 828BECEC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828BECF0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BECF4: 41980008  blt cr6, 0x828becfc
	if ctx.cr[6].lt {
	pc = 0x828BECFC; continue 'dispatch;
	}
	// 828BECF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BECFC; continue 'dispatch;
            }
            0x828BECFC => {
    //   block [0x828BECFC..0x828BED0C)
	// 828BECFC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BED00: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BED04: 41990008  bgt cr6, 0x828bed0c
	if ctx.cr[6].gt {
	pc = 0x828BED0C; continue 'dispatch;
	}
	// 828BED08: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	pc = 0x828BED0C; continue 'dispatch;
            }
            0x828BED0C => {
    //   block [0x828BED0C..0x828BED38)
	// 828BED0C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BED10: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BED14: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BED18: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BED1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BED20: 419A001C  beq cr6, 0x828bed3c
	if ctx.cr[6].eq {
	pc = 0x828BED3C; continue 'dispatch;
	}
	// 828BED24: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BED28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BED2C: 419A000C  beq cr6, 0x828bed38
	if ctx.cr[6].eq {
	pc = 0x828BED38; continue 'dispatch;
	}
	// 828BED30: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BED34: 4800000C  b 0x828bed40
	pc = 0x828BED40; continue 'dispatch;
            }
            0x828BED38 => {
    //   block [0x828BED38..0x828BED3C)
	// 828BED38: 4B8D5101  bl 0x82193e38
	ctx.lr = 0x828BED3C;
	sub_82193E38(ctx, base);
	pc = 0x828BED3C; continue 'dispatch;
            }
            0x828BED3C => {
    //   block [0x828BED3C..0x828BED40)
	// 828BED3C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x828BED40; continue 'dispatch;
            }
            0x828BED40 => {
    //   block [0x828BED40..0x828BED64)
	// 828BED40: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BED44: 409A0078  bne cr6, 0x828bedbc
	if !ctx.cr[6].eq {
	pc = 0x828BEDBC; continue 'dispatch;
	}
	// 828BED48: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BED4C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828BED50: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BED54: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BED58: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BED5C: 41980008  blt cr6, 0x828bed64
	if ctx.cr[6].lt {
	pc = 0x828BED64; continue 'dispatch;
	}
	// 828BED60: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BED64; continue 'dispatch;
            }
            0x828BED64 => {
    //   block [0x828BED64..0x828BED74)
	// 828BED64: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BED68: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BED6C: 41990008  bgt cr6, 0x828bed74
	if ctx.cr[6].gt {
	pc = 0x828BED74; continue 'dispatch;
	}
	// 828BED70: 7D2AF850  subf r9, r10, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	pc = 0x828BED74; continue 'dispatch;
            }
            0x828BED74 => {
    //   block [0x828BED74..0x828BED9C)
	// 828BED74: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BED78: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BED7C: 7D2B382E  lwzx r9, r11, r7
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 828BED80: 80C90008  lwz r6, 8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BED84: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 828BED88: 40990030  ble cr6, 0x828bedb8
	if !ctx.cr[6].gt {
	pc = 0x828BEDB8; continue 'dispatch;
	}
	// 828BED8C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828BED90: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828BED94: 41980008  blt cr6, 0x828bed9c
	if ctx.cr[6].lt {
	pc = 0x828BED9C; continue 'dispatch;
	}
	// 828BED98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BED9C; continue 'dispatch;
            }
            0x828BED9C => {
    //   block [0x828BED9C..0x828BEDA8)
	// 828BED9C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BEDA0: 41990008  bgt cr6, 0x828beda8
	if ctx.cr[6].gt {
	pc = 0x828BEDA8; continue 'dispatch;
	}
	// 828BEDA4: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	pc = 0x828BEDA8; continue 'dispatch;
            }
            0x828BEDA8 => {
    //   block [0x828BEDA8..0x828BEDB8)
	// 828BEDA8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BEDAC: 81799650  lwz r11, -0x69b0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 828BEDB0: 7D2A382E  lwzx r9, r10, r7
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 828BEDB4: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x828BEDB8; continue 'dispatch;
            }
            0x828BEDB8 => {
    //   block [0x828BEDB8..0x828BEDBC)
	// 828BEDB8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	pc = 0x828BEDBC; continue 'dispatch;
            }
            0x828BEDBC => {
    //   block [0x828BEDBC..0x828BEDD4)
	// 828BEDBC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BEDC0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEDC4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BEDC8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BEDCC: 41980008  blt cr6, 0x828bedd4
	if ctx.cr[6].lt {
	pc = 0x828BEDD4; continue 'dispatch;
	}
	// 828BEDD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BEDD4; continue 'dispatch;
            }
            0x828BEDD4 => {
    //   block [0x828BEDD4..0x828BEDDC)
	// 828BEDD4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828BEDD8: 4BFFFEE8  b 0x828becc0
	pc = 0x828BECC0; continue 'dispatch;
            }
            0x828BEDDC => {
    //   block [0x828BEDDC..0x828BEE20)
	// 828BEDDC: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828BEDE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEDE4: 409A003C  bne cr6, 0x828bee20
	if !ctx.cr[6].eq {
	pc = 0x828BEE20; continue 'dispatch;
	}
	// 828BEDE8: 81799650  lwz r11, -0x69b0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 828BEDEC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BEDF0: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 828BEDF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BEDF8: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828BEDFC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828BEE00: 4B955A99  bl 0x82214898
	ctx.lr = 0x828BEE04;
	sub_82214898(ctx, base);
	// 828BEE04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BEE08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BEE0C: 48001895  bl 0x828c06a0
	ctx.lr = 0x828BEE10;
	sub_828C06A0(ctx, base);
	// 828BEE10: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 828BEE14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BEE18: 4B8D5021  bl 0x82193e38
	ctx.lr = 0x828BEE1C;
	sub_82193E38(ctx, base);
	// 828BEE1C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	pc = 0x828BEE20; continue 'dispatch;
            }
            0x828BEE20 => {
    //   block [0x828BEE20..0x828BEEAC)
	// 828BEE20: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 828BEE24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEE28: 419A00E0  beq cr6, 0x828bef08
	if ctx.cr[6].eq {
	pc = 0x828BEF08; continue 'dispatch;
	}
	// 828BEE2C: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BEE30: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BEE34: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEE38: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BEE3C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEE40: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEE44: 4B973935  bl 0x82232778
	ctx.lr = 0x828BEE48;
	sub_82232778(ctx, base);
	// 828BEE48: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BEE4C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828BEE50: 419A00B8  beq cr6, 0x828bef08
	if ctx.cr[6].eq {
	pc = 0x828BEF08; continue 'dispatch;
	}
	// 828BEE54: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BEE58: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEE5C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BEE60: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEE64: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEE68: 4B96D351  bl 0x8222c1b8
	ctx.lr = 0x828BEE6C;
	sub_8222C1B8(ctx, base);
	// 828BEE6C: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BEE70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BEE74: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEE78: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BEE7C: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEE80: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEE84: 48026BF5  bl 0x828e5a78
	ctx.lr = 0x828BEE88;
	sub_828E5A78(ctx, base);
	// 828BEE88: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BEE8C: 409A003C  bne cr6, 0x828beec8
	if !ctx.cr[6].eq {
	pc = 0x828BEEC8; continue 'dispatch;
	}
	// 828BEE90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BEE94: 419A0018  beq cr6, 0x828beeac
	if ctx.cr[6].eq {
	pc = 0x828BEEAC; continue 'dispatch;
	}
	// 828BEE98: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BEE9C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BEEA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BEEA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BEEA8: 409A0008  bne cr6, 0x828beeb0
	if !ctx.cr[6].eq {
	pc = 0x828BEEB0; continue 'dispatch;
	}
	pc = 0x828BEEAC; continue 'dispatch;
            }
            0x828BEEAC => {
    //   block [0x828BEEAC..0x828BEEB0)
	// 828BEEAC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x828BEEB0; continue 'dispatch;
            }
            0x828BEEB0 => {
    //   block [0x828BEEB0..0x828BEEC8)
	// 828BEEB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BEEB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEEB8: 419A0010  beq cr6, 0x828beec8
	if ctx.cr[6].eq {
	pc = 0x828BEEC8; continue 'dispatch;
	}
	// 828BEEBC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BEEC0: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 828BEEC4: 4BFFFDE0  b 0x828beca4
	pc = 0x828BECA4; continue 'dispatch;
            }
            0x828BEEC8 => {
    //   block [0x828BEEC8..0x828BEEEC)
	// 828BEEC8: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828BEECC: 409A003C  bne cr6, 0x828bef08
	if !ctx.cr[6].eq {
	pc = 0x828BEF08; continue 'dispatch;
	}
	// 828BEED0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BEED4: 419A0018  beq cr6, 0x828beeec
	if ctx.cr[6].eq {
	pc = 0x828BEEEC; continue 'dispatch;
	}
	// 828BEED8: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BEEDC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BEEE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BEEE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BEEE8: 409A0008  bne cr6, 0x828beef0
	if !ctx.cr[6].eq {
	pc = 0x828BEEF0; continue 'dispatch;
	}
	pc = 0x828BEEEC; continue 'dispatch;
            }
            0x828BEEEC => {
    //   block [0x828BEEEC..0x828BEEF0)
	// 828BEEEC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x828BEEF0; continue 'dispatch;
            }
            0x828BEEF0 => {
    //   block [0x828BEEF0..0x828BEF08)
	// 828BEEF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BEEF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEEF8: 419A0010  beq cr6, 0x828bef08
	if ctx.cr[6].eq {
	pc = 0x828BEF08; continue 'dispatch;
	}
	// 828BEEFC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828BEF00: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 828BEF04: 4BFFFDA0  b 0x828beca4
	pc = 0x828BECA4; continue 'dispatch;
            }
            0x828BEF08 => {
    //   block [0x828BEF08..0x828BEF10)
	// 828BEF08: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BEF0C: 483EA534  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BEF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BEF10 size=616
    let mut pc: u32 = 0x828BEF10;
    'dispatch: loop {
        match pc {
            0x828BEF10 => {
    //   block [0x828BEF10..0x828BEF44)
	// 828BEF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BEF14: 483EA4DD  bl 0x82ca93f0
	ctx.lr = 0x828BEF18;
	sub_82CA93D0(ctx, base);
	// 828BEF18: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BEF1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828BEF20: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828BEF24: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828BEF28: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828BEF2C: 3BC30028  addi r30, r3, 0x28
	ctx.r[30].s64 = ctx.r[3].s64 + 40;
	// 828BEF30: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828BEF34: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 828BEF38: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 828BEF3C: 3AEB0B7C  addi r23, r11, 0xb7c
	ctx.r[23].s64 = ctx.r[11].s64 + 2940;
	// 828BEF40: 3ACA0B7C  addi r22, r10, 0xb7c
	ctx.r[22].s64 = ctx.r[10].s64 + 2940;
	pc = 0x828BEF44; continue 'dispatch;
            }
            0x828BEF44 => {
    //   block [0x828BEF44..0x828BEF60)
	// 828BEF44: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEF48: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 828BEF4C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BEF50: 7D4BFA14  add r10, r11, r31
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828BEF54: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BEF58: 40990008  ble cr6, 0x828bef60
	if !ctx.cr[6].gt {
	pc = 0x828BEF60; continue 'dispatch;
	}
	// 828BEF5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BEF60; continue 'dispatch;
            }
            0x828BEF60 => {
    //   block [0x828BEF60..0x828BEF78)
	// 828BEF60: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEF64: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BEF68: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 828BEF6C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BEF70: 40990008  ble cr6, 0x828bef78
	if !ctx.cr[6].gt {
	pc = 0x828BEF78; continue 'dispatch;
	}
	// 828BEF74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BEF78; continue 'dispatch;
            }
            0x828BEF78 => {
    //   block [0x828BEF78..0x828BEF84)
	// 828BEF78: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BEF7C: 419A0008  beq cr6, 0x828bef84
	if ctx.cr[6].eq {
	pc = 0x828BEF84; continue 'dispatch;
	}
	// 828BEF80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BEF84; continue 'dispatch;
            }
            0x828BEF84 => {
    //   block [0x828BEF84..0x828BEF9C)
	// 828BEF84: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BEF88: 419A00C0  beq cr6, 0x828bf048
	if ctx.cr[6].eq {
	pc = 0x828BF048; continue 'dispatch;
	}
	// 828BEF8C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 828BEF90: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BEF94: 41980008  blt cr6, 0x828bef9c
	if ctx.cr[6].lt {
	pc = 0x828BEF9C; continue 'dispatch;
	}
	// 828BEF98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BEF9C; continue 'dispatch;
            }
            0x828BEF9C => {
    //   block [0x828BEF9C..0x828BEFAC)
	// 828BEF9C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BEFA0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BEFA4: 41990008  bgt cr6, 0x828befac
	if ctx.cr[6].gt {
	pc = 0x828BEFAC; continue 'dispatch;
	}
	// 828BEFA8: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	pc = 0x828BEFAC; continue 'dispatch;
            }
            0x828BEFAC => {
    //   block [0x828BEFAC..0x828BEFD8)
	// 828BEFAC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEFB0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BEFB4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BEFB8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BEFBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BEFC0: 419A001C  beq cr6, 0x828befdc
	if ctx.cr[6].eq {
	pc = 0x828BEFDC; continue 'dispatch;
	}
	// 828BEFC4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BEFC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BEFCC: 419A000C  beq cr6, 0x828befd8
	if ctx.cr[6].eq {
	pc = 0x828BEFD8; continue 'dispatch;
	}
	// 828BEFD0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BEFD4: 4800000C  b 0x828befe0
	pc = 0x828BEFE0; continue 'dispatch;
            }
            0x828BEFD8 => {
    //   block [0x828BEFD8..0x828BEFDC)
	// 828BEFD8: 4B8D4E61  bl 0x82193e38
	ctx.lr = 0x828BEFDC;
	sub_82193E38(ctx, base);
	pc = 0x828BEFDC; continue 'dispatch;
            }
            0x828BEFDC => {
    //   block [0x828BEFDC..0x828BEFE0)
	// 828BEFDC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x828BEFE0; continue 'dispatch;
            }
            0x828BEFE0 => {
    //   block [0x828BEFE0..0x828BF004)
	// 828BEFE0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828BEFE4: 409A0044  bne cr6, 0x828bf028
	if !ctx.cr[6].eq {
	pc = 0x828BF028; continue 'dispatch;
	}
	// 828BEFE8: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BEFEC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828BEFF0: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BEFF4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 828BEFF8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BEFFC: 41980008  blt cr6, 0x828bf004
	if ctx.cr[6].lt {
	pc = 0x828BF004; continue 'dispatch;
	}
	// 828BF000: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF004; continue 'dispatch;
            }
            0x828BF004 => {
    //   block [0x828BF004..0x828BF014)
	// 828BF004: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF008: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BF00C: 41990008  bgt cr6, 0x828bf014
	if ctx.cr[6].gt {
	pc = 0x828BF014; continue 'dispatch;
	}
	// 828BF010: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	pc = 0x828BF014; continue 'dispatch;
            }
            0x828BF014 => {
    //   block [0x828BF014..0x828BF028)
	// 828BF014: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF018: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828BF01C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828BF020: 7D09502E  lwzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828BF024: 93280008  stw r25, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	pc = 0x828BF028; continue 'dispatch;
            }
            0x828BF028 => {
    //   block [0x828BF028..0x828BF040)
	// 828BF028: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF02C: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF030: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF034: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF038: 41980008  blt cr6, 0x828bf040
	if ctx.cr[6].lt {
	pc = 0x828BF040; continue 'dispatch;
	}
	// 828BF03C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF040; continue 'dispatch;
            }
            0x828BF040 => {
    //   block [0x828BF040..0x828BF048)
	// 828BF040: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828BF044: 4BFFFF1C  b 0x828bef60
	pc = 0x828BEF60; continue 'dispatch;
            }
            0x828BF048 => {
    //   block [0x828BF048..0x828BF088)
	// 828BF048: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828BF04C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF050: 409A0038  bne cr6, 0x828bf088
	if !ctx.cr[6].eq {
	pc = 0x828BF088; continue 'dispatch;
	}
	// 828BF054: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 828BF058: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BF05C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828BF060: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF064: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 828BF068: 4B955831  bl 0x82214898
	ctx.lr = 0x828BF06C;
	sub_82214898(ctx, base);
	// 828BF06C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828BF070: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BF074: 4800162D  bl 0x828c06a0
	ctx.lr = 0x828BF078;
	sub_828C06A0(ctx, base);
	// 828BF078: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 828BF07C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828BF080: 4B8D4DB9  bl 0x82193e38
	ctx.lr = 0x828BF084;
	sub_82193E38(ctx, base);
	// 828BF084: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	pc = 0x828BF088; continue 'dispatch;
            }
            0x828BF088 => {
    //   block [0x828BF088..0x828BF114)
	// 828BF088: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 828BF08C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF090: 419A00E0  beq cr6, 0x828bf170
	if ctx.cr[6].eq {
	pc = 0x828BF170; continue 'dispatch;
	}
	// 828BF094: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BF098: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BF09C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF0A0: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BF0A4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF0A8: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF0AC: 4B9736CD  bl 0x82232778
	ctx.lr = 0x828BF0B0;
	sub_82232778(ctx, base);
	// 828BF0B0: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828BF0B4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828BF0B8: 419A00B8  beq cr6, 0x828bf170
	if ctx.cr[6].eq {
	pc = 0x828BF170; continue 'dispatch;
	}
	// 828BF0BC: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BF0C0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF0C4: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BF0C8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF0CC: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF0D0: 4B96D0E9  bl 0x8222c1b8
	ctx.lr = 0x828BF0D4;
	sub_8222C1B8(ctx, base);
	// 828BF0D4: 81786AB8  lwz r11, 0x6ab8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BF0D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BF0DC: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF0E0: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828BF0E4: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF0E8: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF0EC: 4802698D  bl 0x828e5a78
	ctx.lr = 0x828BF0F0;
	sub_828E5A78(ctx, base);
	// 828BF0F0: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BF0F4: 409A003C  bne cr6, 0x828bf130
	if !ctx.cr[6].eq {
	pc = 0x828BF130; continue 'dispatch;
	}
	// 828BF0F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828BF0FC: 419A0018  beq cr6, 0x828bf114
	if ctx.cr[6].eq {
	pc = 0x828BF114; continue 'dispatch;
	}
	// 828BF100: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BF104: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BF108: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BF10C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF110: 409A0008  bne cr6, 0x828bf118
	if !ctx.cr[6].eq {
	pc = 0x828BF118; continue 'dispatch;
	}
	pc = 0x828BF114; continue 'dispatch;
            }
            0x828BF114 => {
    //   block [0x828BF114..0x828BF118)
	// 828BF114: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x828BF118; continue 'dispatch;
            }
            0x828BF118 => {
    //   block [0x828BF118..0x828BF130)
	// 828BF118: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BF11C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF120: 419A0010  beq cr6, 0x828bf130
	if ctx.cr[6].eq {
	pc = 0x828BF130; continue 'dispatch;
	}
	// 828BF124: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BF128: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 828BF12C: 4BFFFE18  b 0x828bef44
	pc = 0x828BEF44; continue 'dispatch;
            }
            0x828BF130 => {
    //   block [0x828BF130..0x828BF154)
	// 828BF130: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828BF134: 409A003C  bne cr6, 0x828bf170
	if !ctx.cr[6].eq {
	pc = 0x828BF170; continue 'dispatch;
	}
	// 828BF138: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BF13C: 419A0018  beq cr6, 0x828bf154
	if ctx.cr[6].eq {
	pc = 0x828BF154; continue 'dispatch;
	}
	// 828BF140: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BF144: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BF148: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BF14C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF150: 409A0008  bne cr6, 0x828bf158
	if !ctx.cr[6].eq {
	pc = 0x828BF158; continue 'dispatch;
	}
	pc = 0x828BF154; continue 'dispatch;
            }
            0x828BF154 => {
    //   block [0x828BF154..0x828BF158)
	// 828BF154: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x828BF158; continue 'dispatch;
            }
            0x828BF158 => {
    //   block [0x828BF158..0x828BF170)
	// 828BF158: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BF15C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF160: 419A0010  beq cr6, 0x828bf170
	if ctx.cr[6].eq {
	pc = 0x828BF170; continue 'dispatch;
	}
	// 828BF164: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828BF168: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 828BF16C: 4BFFFDD8  b 0x828bef44
	pc = 0x828BEF44; continue 'dispatch;
            }
            0x828BF170 => {
    //   block [0x828BF170..0x828BF178)
	// 828BF170: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BF174: 483EA2CC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BF178 size=360
    let mut pc: u32 = 0x828BF178;
    'dispatch: loop {
        match pc {
            0x828BF178 => {
    //   block [0x828BF178..0x828BF1A4)
	// 828BF178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF17C: 483EA289  bl 0x82ca9404
	ctx.lr = 0x828BF180;
	sub_82CA93D0(ctx, base);
	// 828BF180: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF184: 83C30034  lwz r30, 0x34(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BF188: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828BF18C: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 828BF190: 3BA30028  addi r29, r3, 0x28
	ctx.r[29].s64 = ctx.r[3].s64 + 40;
	// 828BF194: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828BF198: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BF19C: 40990008  ble cr6, 0x828bf1a4
	if !ctx.cr[6].gt {
	pc = 0x828BF1A4; continue 'dispatch;
	}
	// 828BF1A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF1A4; continue 'dispatch;
            }
            0x828BF1A4 => {
    //   block [0x828BF1A4..0x828BF1AC)
	// 828BF1A4: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828BF1A8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828BF1AC; continue 'dispatch;
            }
            0x828BF1AC => {
    //   block [0x828BF1AC..0x828BF1C4)
	// 828BF1AC: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF1B0: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF1B4: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BF1B8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF1BC: 40990008  ble cr6, 0x828bf1c4
	if !ctx.cr[6].gt {
	pc = 0x828BF1C4; continue 'dispatch;
	}
	// 828BF1C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF1C4; continue 'dispatch;
            }
            0x828BF1C4 => {
    //   block [0x828BF1C4..0x828BF1D4)
	// 828BF1C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BF1C8: 419A000C  beq cr6, 0x828bf1d4
	if ctx.cr[6].eq {
	pc = 0x828BF1D4; continue 'dispatch;
	}
	// 828BF1CC: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BF1D0: 419A0008  beq cr6, 0x828bf1d8
	if ctx.cr[6].eq {
	pc = 0x828BF1D8; continue 'dispatch;
	}
	pc = 0x828BF1D4; continue 'dispatch;
            }
            0x828BF1D4 => {
    //   block [0x828BF1D4..0x828BF1D8)
	// 828BF1D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF1D8; continue 'dispatch;
            }
            0x828BF1D8 => {
    //   block [0x828BF1D8..0x828BF1F0)
	// 828BF1D8: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF1DC: 419A00FC  beq cr6, 0x828bf2d8
	if ctx.cr[6].eq {
	pc = 0x828BF2D8; continue 'dispatch;
	}
	// 828BF1E0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 828BF1E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828BF1E8: 409A0008  bne cr6, 0x828bf1f0
	if !ctx.cr[6].eq {
	pc = 0x828BF1F0; continue 'dispatch;
	}
	// 828BF1EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF1F0; continue 'dispatch;
            }
            0x828BF1F0 => {
    //   block [0x828BF1F0..0x828BF208)
	// 828BF1F0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF1F4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF1F8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF1FC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BF200: 41980008  blt cr6, 0x828bf208
	if ctx.cr[6].lt {
	pc = 0x828BF208; continue 'dispatch;
	}
	// 828BF204: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF208; continue 'dispatch;
            }
            0x828BF208 => {
    //   block [0x828BF208..0x828BF218)
	// 828BF208: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF20C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BF210: 41990008  bgt cr6, 0x828bf218
	if ctx.cr[6].gt {
	pc = 0x828BF218; continue 'dispatch;
	}
	// 828BF214: 7D2BF050  subf r9, r11, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	pc = 0x828BF218; continue 'dispatch;
            }
            0x828BF218 => {
    //   block [0x828BF218..0x828BF244)
	// 828BF218: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF21C: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BF220: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BF224: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF22C: 419A001C  beq cr6, 0x828bf248
	if ctx.cr[6].eq {
	pc = 0x828BF248; continue 'dispatch;
	}
	// 828BF230: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF234: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF238: 419A000C  beq cr6, 0x828bf244
	if ctx.cr[6].eq {
	pc = 0x828BF244; continue 'dispatch;
	}
	// 828BF23C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BF240: 4800000C  b 0x828bf24c
	pc = 0x828BF24C; continue 'dispatch;
            }
            0x828BF244 => {
    //   block [0x828BF244..0x828BF248)
	// 828BF244: 4B8D4BF5  bl 0x82193e38
	ctx.lr = 0x828BF248;
	sub_82193E38(ctx, base);
	pc = 0x828BF248; continue 'dispatch;
            }
            0x828BF248 => {
    //   block [0x828BF248..0x828BF24C)
	// 828BF248: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828BF24C; continue 'dispatch;
            }
            0x828BF24C => {
    //   block [0x828BF24C..0x828BF274)
	// 828BF24C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828BF250: 409A0068  bne cr6, 0x828bf2b8
	if !ctx.cr[6].eq {
	pc = 0x828BF2B8; continue 'dispatch;
	}
	// 828BF254: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF258: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 828BF25C: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF260: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 828BF264: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF268: 4199000C  bgt cr6, 0x828bf274
	if ctx.cr[6].gt {
	pc = 0x828BF274; continue 'dispatch;
	}
	// 828BF26C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF270: 40980008  bge cr6, 0x828bf278
	if !ctx.cr[6].lt {
	pc = 0x828BF278; continue 'dispatch;
	}
	pc = 0x828BF274; continue 'dispatch;
            }
            0x828BF274 => {
    //   block [0x828BF274..0x828BF278)
	// 828BF274: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF278; continue 'dispatch;
            }
            0x828BF278 => {
    //   block [0x828BF278..0x828BF2B8)
	// 828BF278: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828BF27C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828BF280: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828BF284: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828BF288: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 828BF28C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828BF290: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828BF294: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828BF298: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828BF29C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828BF2A0: 48001541  bl 0x828c07e0
	ctx.lr = 0x828BF2A4;
	sub_828C07E0(ctx, base);
	// 828BF2A4: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828BF2A8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828BF2AC: 83E10074  lwz r31, 0x74(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828BF2B0: 83C10078  lwz r30, 0x78(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828BF2B4: 4BFFFEF8  b 0x828bf1ac
	pc = 0x828BF1AC; continue 'dispatch;
            }
            0x828BF2B8 => {
    //   block [0x828BF2B8..0x828BF2D0)
	// 828BF2B8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF2BC: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF2C0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF2C4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BF2C8: 41980008  blt cr6, 0x828bf2d0
	if ctx.cr[6].lt {
	pc = 0x828BF2D0; continue 'dispatch;
	}
	// 828BF2CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF2D0; continue 'dispatch;
            }
            0x828BF2D0 => {
    //   block [0x828BF2D0..0x828BF2D8)
	// 828BF2D0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828BF2D4: 4BFFFED8  b 0x828bf1ac
	pc = 0x828BF1AC; continue 'dispatch;
            }
            0x828BF2D8 => {
    //   block [0x828BF2D8..0x828BF2E0)
	// 828BF2D8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828BF2DC: 483EA178  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BF2E0 size=588
    let mut pc: u32 = 0x828BF2E0;
    'dispatch: loop {
        match pc {
            0x828BF2E0 => {
    //   block [0x828BF2E0..0x828BF310)
	// 828BF2E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF2E4: 483EA11D  bl 0x82ca9400
	ctx.lr = 0x828BF2E8;
	sub_82CA93D0(ctx, base);
	// 828BF2E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF2EC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BF2F0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828BF2F4: 3BDC0028  addi r30, r28, 0x28
	ctx.r[30].s64 = ctx.r[28].s64 + 40;
	// 828BF2F8: 817C0034  lwz r11, 0x34(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BF2FC: 815C0038  lwz r10, 0x38(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 828BF300: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BF304: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF308: 40990008  ble cr6, 0x828bf310
	if !ctx.cr[6].gt {
	pc = 0x828BF310; continue 'dispatch;
	}
	// 828BF30C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF310; continue 'dispatch;
            }
            0x828BF310 => {
    //   block [0x828BF310..0x828BF318)
	// 828BF310: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828BF314: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x828BF318; continue 'dispatch;
            }
            0x828BF318 => {
    //   block [0x828BF318..0x828BF330)
	// 828BF318: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF31C: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF320: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 828BF324: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF328: 40990008  ble cr6, 0x828bf330
	if !ctx.cr[6].gt {
	pc = 0x828BF330; continue 'dispatch;
	}
	// 828BF32C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF330; continue 'dispatch;
            }
            0x828BF330 => {
    //   block [0x828BF330..0x828BF33C)
	// 828BF330: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BF334: 419A0008  beq cr6, 0x828bf33c
	if ctx.cr[6].eq {
	pc = 0x828BF33C; continue 'dispatch;
	}
	// 828BF338: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF33C; continue 'dispatch;
            }
            0x828BF33C => {
    //   block [0x828BF33C..0x828BF354)
	// 828BF33C: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF340: 419A00B8  beq cr6, 0x828bf3f8
	if ctx.cr[6].eq {
	pc = 0x828BF3F8; continue 'dispatch;
	}
	// 828BF344: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 828BF348: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF34C: 41980008  blt cr6, 0x828bf354
	if ctx.cr[6].lt {
	pc = 0x828BF354; continue 'dispatch;
	}
	// 828BF350: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF354; continue 'dispatch;
            }
            0x828BF354 => {
    //   block [0x828BF354..0x828BF364)
	// 828BF354: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF358: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BF35C: 41990008  bgt cr6, 0x828bf364
	if ctx.cr[6].gt {
	pc = 0x828BF364; continue 'dispatch;
	}
	// 828BF360: 7D2BE850  subf r9, r11, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	pc = 0x828BF364; continue 'dispatch;
            }
            0x828BF364 => {
    //   block [0x828BF364..0x828BF390)
	// 828BF364: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF368: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BF36C: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BF370: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF378: 419A0048  beq cr6, 0x828bf3c0
	if ctx.cr[6].eq {
	pc = 0x828BF3C0; continue 'dispatch;
	}
	// 828BF37C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF380: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF384: 419A000C  beq cr6, 0x828bf390
	if ctx.cr[6].eq {
	pc = 0x828BF390; continue 'dispatch;
	}
	// 828BF388: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BF38C: 48000038  b 0x828bf3c4
	pc = 0x828BF3C4; continue 'dispatch;
            }
            0x828BF390 => {
    //   block [0x828BF390..0x828BF3BC)
	// 828BF390: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF394: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828BF398: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828BF39C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF3A0: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF3A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BF3A8: 409A0014  bne cr6, 0x828bf3bc
	if !ctx.cr[6].eq {
	pc = 0x828BF3BC; continue 'dispatch;
	}
	// 828BF3AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF3B4: 409A0008  bne cr6, 0x828bf3bc
	if !ctx.cr[6].eq {
	pc = 0x828BF3BC; continue 'dispatch;
	}
	// 828BF3B8: 4B95C981  bl 0x8221bd38
	ctx.lr = 0x828BF3BC;
	sub_8221BD38(ctx, base);
	pc = 0x828BF3BC; continue 'dispatch;
            }
            0x828BF3BC => {
    //   block [0x828BF3BC..0x828BF3C0)
	// 828BF3BC: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	pc = 0x828BF3C0; continue 'dispatch;
            }
            0x828BF3C0 => {
    //   block [0x828BF3C0..0x828BF3C4)
	// 828BF3C0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x828BF3C4; continue 'dispatch;
            }
            0x828BF3C4 => {
    //   block [0x828BF3C4..0x828BF3E4)
	// 828BF3C4: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BF3C8: 419A0024  beq cr6, 0x828bf3ec
	if ctx.cr[6].eq {
	pc = 0x828BF3EC; continue 'dispatch;
	}
	// 828BF3CC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF3D0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF3D4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF3D8: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF3DC: 41980008  blt cr6, 0x828bf3e4
	if ctx.cr[6].lt {
	pc = 0x828BF3E4; continue 'dispatch;
	}
	// 828BF3E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF3E4; continue 'dispatch;
            }
            0x828BF3E4 => {
    //   block [0x828BF3E4..0x828BF3EC)
	// 828BF3E4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828BF3E8: 4BFFFF30  b 0x828bf318
	pc = 0x828BF318; continue 'dispatch;
            }
            0x828BF3EC => {
    //   block [0x828BF3EC..0x828BF3F8)
	// 828BF3EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828BF3F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BF3F4: 483EA05C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x828BF3F8 => {
    //   block [0x828BF3F8..0x828BF43C)
	// 828BF3F8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF3FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BF400: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828BF404: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 828BF408: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828BF40C: 419A00F4  beq cr6, 0x828bf500
	if ctx.cr[6].eq {
	pc = 0x828BF500; continue 'dispatch;
	}
	// 828BF410: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BF414: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF418: 419A0024  beq cr6, 0x828bf43c
	if ctx.cr[6].eq {
	pc = 0x828BF43C; continue 'dispatch;
	}
	// 828BF41C: 892A0022  lbz r9, 0x22(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(34 as u32) ) } as u64;
	// 828BF420: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BF424: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828BF428: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF42C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF430: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828BF434: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BF438: 480000CC  b 0x828bf504
	pc = 0x828BF504; continue 'dispatch;
            }
            0x828BF43C => {
    //   block [0x828BF43C..0x828BF458)
	// 828BF43C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BF440: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BF444: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828BF448: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BF44C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828BF450: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BF454: 40810054  ble 0x828bf4a8
	if !ctx.cr[0].gt {
	pc = 0x828BF4A8; continue 'dispatch;
	}
	pc = 0x828BF458; continue 'dispatch;
            }
            0x828BF458 => {
    //   block [0x828BF458..0x828BF478)
	// 828BF458: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BF45C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BF460: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828BF464: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF468: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 828BF46C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828BF470: 41980008  blt cr6, 0x828bf478
	if ctx.cr[6].lt {
	pc = 0x828BF478; continue 'dispatch;
	}
	// 828BF474: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x828BF478; continue 'dispatch;
            }
            0x828BF478 => {
    //   block [0x828BF478..0x828BF494)
	// 828BF478: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BF47C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BF480: 419A0014  beq cr6, 0x828bf494
	if ctx.cr[6].eq {
	pc = 0x828BF494; continue 'dispatch;
	}
	// 828BF484: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BF488: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BF48C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BF490: 4800000C  b 0x828bf49c
	pc = 0x828BF49C; continue 'dispatch;
            }
            0x828BF494 => {
    //   block [0x828BF494..0x828BF49C)
	// 828BF494: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BF498: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828BF49C; continue 'dispatch;
            }
            0x828BF49C => {
    //   block [0x828BF49C..0x828BF4A8)
	// 828BF49C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BF4A0: 4199FFB8  bgt cr6, 0x828bf458
	if ctx.cr[6].gt {
	pc = 0x828BF458; continue 'dispatch;
	}
	// 828BF4A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828BF4A8; continue 'dispatch;
            }
            0x828BF4A8 => {
    //   block [0x828BF4A8..0x828BF4C4)
	// 828BF4A8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BF4AC: 419A0040  beq cr6, 0x828bf4ec
	if ctx.cr[6].eq {
	pc = 0x828BF4EC; continue 'dispatch;
	}
	// 828BF4B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF4B4: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 828BF4B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BF4BC: 41990008  bgt cr6, 0x828bf4c4
	if ctx.cr[6].gt {
	pc = 0x828BF4C4; continue 'dispatch;
	}
	// 828BF4C0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x828BF4C4; continue 'dispatch;
            }
            0x828BF4C4 => {
    //   block [0x828BF4C4..0x828BF4EC)
	// 828BF4C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BF4C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF4CC: 409A0020  bne cr6, 0x828bf4ec
	if !ctx.cr[6].eq {
	pc = 0x828BF4EC; continue 'dispatch;
	}
	// 828BF4D0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BF4D4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828BF4D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828BF4DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF4E0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828BF4E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BF4E8: 4800001C  b 0x828bf504
	pc = 0x828BF504; continue 'dispatch;
            }
            0x828BF4EC => {
    //   block [0x828BF4EC..0x828BF500)
	// 828BF4EC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828BF4F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF4F4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828BF4F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BF4FC: 48000008  b 0x828bf504
	pc = 0x828BF504; continue 'dispatch;
            }
            0x828BF500 => {
    //   block [0x828BF500..0x828BF504)
	// 828BF500: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x828BF504; continue 'dispatch;
            }
            0x828BF504 => {
    //   block [0x828BF504..0x828BF520)
	// 828BF504: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BF508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF50C: 419A0014  beq cr6, 0x828bf520
	if ctx.cr[6].eq {
	pc = 0x828BF520; continue 'dispatch;
	}
	// 828BF510: 4BEBCE09  bl 0x8277c318
	ctx.lr = 0x828BF514;
	sub_8277C318(ctx, base);
	// 828BF514: 7F03D040  cmplw cr6, r3, r26
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828BF518: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828BF51C: 419A0008  beq cr6, 0x828bf524
	if ctx.cr[6].eq {
	pc = 0x828BF524; continue 'dispatch;
	}
	pc = 0x828BF520; continue 'dispatch;
            }
            0x828BF520 => {
    //   block [0x828BF520..0x828BF524)
	// 828BF520: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x828BF524; continue 'dispatch;
            }
            0x828BF524 => {
    //   block [0x828BF524..0x828BF52C)
	// 828BF524: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BF528: 483E9F28  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BF530 size=652
    let mut pc: u32 = 0x828BF530;
    'dispatch: loop {
        match pc {
            0x828BF530 => {
    //   block [0x828BF530..0x828BF59C)
	// 828BF530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF534: 483E9EC9  bl 0x82ca93fc
	ctx.lr = 0x828BF538;
	sub_82CA93D0(ctx, base);
	// 828BF538: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF53C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828BF540: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828BF544: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828BF548: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828BF54C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828BF550: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BF554: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF558: 812A0078  lwz r9, 0x78(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 828BF55C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF560: 83C80000  lwz r30, 0(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF564: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828BF568: 4B922641  bl 0x821e1ba8
	ctx.lr = 0x828BF56C;
	sub_821E1BA8(ctx, base);
	// 828BF56C: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 828BF570: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828BF574: 38A7B278  addi r5, r7, -0x4d88
	ctx.r[5].s64 = ctx.r[7].s64 + -19848;
	// 828BF578: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BF57C: 4B9FA275  bl 0x822b97f0
	ctx.lr = 0x828BF580;
	sub_822B97F0(ctx, base);
	// 828BF580: 3BFF0028  addi r31, r31, 0x28
	ctx.r[31].s64 = ctx.r[31].s64 + 40;
	// 828BF584: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF588: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF58C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF590: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF594: 40990008  ble cr6, 0x828bf59c
	if !ctx.cr[6].gt {
	pc = 0x828BF59C; continue 'dispatch;
	}
	// 828BF598: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF59C; continue 'dispatch;
            }
            0x828BF59C => {
    //   block [0x828BF59C..0x828BF5A8)
	// 828BF59C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828BF5A0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828BF5A4: 3B4BFFDF  addi r26, r11, -0x21
	ctx.r[26].s64 = ctx.r[11].s64 + -33;
	pc = 0x828BF5A8; continue 'dispatch;
            }
            0x828BF5A8 => {
    //   block [0x828BF5A8..0x828BF5C0)
	// 828BF5A8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF5AC: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF5B0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 828BF5B4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF5B8: 40990008  ble cr6, 0x828bf5c0
	if !ctx.cr[6].gt {
	pc = 0x828BF5C0; continue 'dispatch;
	}
	// 828BF5BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF5C0; continue 'dispatch;
            }
            0x828BF5C0 => {
    //   block [0x828BF5C0..0x828BF5CC)
	// 828BF5C0: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BF5C4: 419A0008  beq cr6, 0x828bf5cc
	if ctx.cr[6].eq {
	pc = 0x828BF5CC; continue 'dispatch;
	}
	// 828BF5C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF5CC; continue 'dispatch;
            }
            0x828BF5CC => {
    //   block [0x828BF5CC..0x828BF5E4)
	// 828BF5CC: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF5D0: 419A01E0  beq cr6, 0x828bf7b0
	if ctx.cr[6].eq {
	pc = 0x828BF7B0; continue 'dispatch;
	}
	// 828BF5D4: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 828BF5D8: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF5DC: 41980008  blt cr6, 0x828bf5e4
	if ctx.cr[6].lt {
	pc = 0x828BF5E4; continue 'dispatch;
	}
	// 828BF5E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF5E4; continue 'dispatch;
            }
            0x828BF5E4 => {
    //   block [0x828BF5E4..0x828BF5F4)
	// 828BF5E4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF5E8: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BF5EC: 41990008  bgt cr6, 0x828bf5f4
	if ctx.cr[6].gt {
	pc = 0x828BF5F4; continue 'dispatch;
	}
	// 828BF5F0: 7D2BE850  subf r9, r11, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	pc = 0x828BF5F4; continue 'dispatch;
            }
            0x828BF5F4 => {
    //   block [0x828BF5F4..0x828BF638)
	// 828BF5F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF5F8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BF5FC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BF600: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF604: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF608: 419A0030  beq cr6, 0x828bf638
	if ctx.cr[6].eq {
	pc = 0x828BF638; continue 'dispatch;
	}
	// 828BF60C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF610: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF614: 419A008C  beq cr6, 0x828bf6a0
	if ctx.cr[6].eq {
	pc = 0x828BF6A0; continue 'dispatch;
	}
	// 828BF618: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BF61C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF620: 419A0018  beq cr6, 0x828bf638
	if ctx.cr[6].eq {
	pc = 0x828BF638; continue 'dispatch;
	}
	// 828BF624: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BF628: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BF62C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BF630: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF634: 409A0008  bne cr6, 0x828bf63c
	if !ctx.cr[6].eq {
	pc = 0x828BF63C; continue 'dispatch;
	}
	pc = 0x828BF638; continue 'dispatch;
            }
            0x828BF638 => {
    //   block [0x828BF638..0x828BF63C)
	// 828BF638: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828BF63C; continue 'dispatch;
            }
            0x828BF63C => {
    //   block [0x828BF63C..0x828BF664)
	// 828BF63C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BF640: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF644: 419A014C  beq cr6, 0x828bf790
	if ctx.cr[6].eq {
	pc = 0x828BF790; continue 'dispatch;
	}
	// 828BF648: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF64C: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 828BF650: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF654: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BF658: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BF65C: 41980008  blt cr6, 0x828bf664
	if ctx.cr[6].lt {
	pc = 0x828BF664; continue 'dispatch;
	}
	// 828BF660: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF664; continue 'dispatch;
            }
            0x828BF664 => {
    //   block [0x828BF664..0x828BF674)
	// 828BF664: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF668: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BF66C: 41990008  bgt cr6, 0x828bf674
	if ctx.cr[6].gt {
	pc = 0x828BF674; continue 'dispatch;
	}
	// 828BF670: 7D2BE850  subf r9, r11, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	pc = 0x828BF674; continue 'dispatch;
            }
            0x828BF674 => {
    //   block [0x828BF674..0x828BF6A0)
	// 828BF674: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF678: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BF67C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BF680: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF688: 419A0024  beq cr6, 0x828bf6ac
	if ctx.cr[6].eq {
	pc = 0x828BF6AC; continue 'dispatch;
	}
	// 828BF68C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF690: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF694: 419A0014  beq cr6, 0x828bf6a8
	if ctx.cr[6].eq {
	pc = 0x828BF6A8; continue 'dispatch;
	}
	// 828BF698: 555C003E  slwi r28, r10, 0
	ctx.r[28].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 828BF69C: 48000014  b 0x828bf6b0
	pc = 0x828BF6B0; continue 'dispatch;
            }
            0x828BF6A0 => {
    //   block [0x828BF6A0..0x828BF6A8)
	// 828BF6A0: 4B8D4799  bl 0x82193e38
	ctx.lr = 0x828BF6A4;
	sub_82193E38(ctx, base);
	// 828BF6A4: 4BFFFF94  b 0x828bf638
	pc = 0x828BF638; continue 'dispatch;
            }
            0x828BF6A8 => {
    //   block [0x828BF6A8..0x828BF6AC)
	// 828BF6A8: 4B8D4791  bl 0x82193e38
	ctx.lr = 0x828BF6AC;
	sub_82193E38(ctx, base);
	pc = 0x828BF6AC; continue 'dispatch;
            }
            0x828BF6AC => {
    //   block [0x828BF6AC..0x828BF6B0)
	// 828BF6AC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828BF6B0; continue 'dispatch;
            }
            0x828BF6B0 => {
    //   block [0x828BF6B0..0x828BF6CC)
	// 828BF6B0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF6B4: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 828BF6B8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF6BC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BF6C0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BF6C4: 41980008  blt cr6, 0x828bf6cc
	if ctx.cr[6].lt {
	pc = 0x828BF6CC; continue 'dispatch;
	}
	// 828BF6C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF6CC; continue 'dispatch;
            }
            0x828BF6CC => {
    //   block [0x828BF6CC..0x828BF6DC)
	// 828BF6CC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF6D0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828BF6D4: 41990008  bgt cr6, 0x828bf6dc
	if ctx.cr[6].gt {
	pc = 0x828BF6DC; continue 'dispatch;
	}
	// 828BF6D8: 7D2BE850  subf r9, r11, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	pc = 0x828BF6DC; continue 'dispatch;
            }
            0x828BF6DC => {
    //   block [0x828BF6DC..0x828BF708)
	// 828BF6DC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF6E0: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BF6E4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BF6E8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF6EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF6F0: 419A001C  beq cr6, 0x828bf70c
	if ctx.cr[6].eq {
	pc = 0x828BF70C; continue 'dispatch;
	}
	// 828BF6F4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF6F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF6FC: 419A000C  beq cr6, 0x828bf708
	if ctx.cr[6].eq {
	pc = 0x828BF708; continue 'dispatch;
	}
	// 828BF700: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BF704: 4800000C  b 0x828bf710
	pc = 0x828BF710; continue 'dispatch;
            }
            0x828BF708 => {
    //   block [0x828BF708..0x828BF70C)
	// 828BF708: 4B8D4731  bl 0x82193e38
	ctx.lr = 0x828BF70C;
	sub_82193E38(ctx, base);
	pc = 0x828BF70C; continue 'dispatch;
            }
            0x828BF70C => {
    //   block [0x828BF70C..0x828BF710)
	// 828BF70C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828BF710; continue 'dispatch;
            }
            0x828BF710 => {
    //   block [0x828BF710..0x828BF724)
	// 828BF710: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828BF714: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 828BF718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF71C: 419A0008  beq cr6, 0x828bf724
	if ctx.cr[6].eq {
	pc = 0x828BF724; continue 'dispatch;
	}
	// 828BF720: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828BF724; continue 'dispatch;
            }
            0x828BF724 => {
    //   block [0x828BF724..0x828BF790)
	// 828BF724: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF72C: 419A0064  beq cr6, 0x828bf790
	if ctx.cr[6].eq {
	pc = 0x828BF790; continue 'dispatch;
	}
	// 828BF730: 832B0000  lwz r25, 0(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF734: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF738: 81790010  lwz r11, 0x10(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF73C: 806B005C  lwz r3, 0x5c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828BF740: 4B969A21  bl 0x82229160
	ctx.lr = 0x828BF744;
	sub_82229160(ctx, base);
	// 828BF744: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828BF748: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF74C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828BF750: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828BF754: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF758: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828BF75C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF760: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 828BF764: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF768: 38EB0008  addi r7, r11, 8
	ctx.r[7].s64 = ctx.r[11].s64 + 8;
	// 828BF76C: 90F90008  stw r7, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 828BF770: 4BAE3851  bl 0x823a2fc0
	ctx.lr = 0x828BF774;
	sub_823A2FC0(ctx, base);
	// 828BF774: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828BF778: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828BF77C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828BF780: 48164F49  bl 0x82a246c8
	ctx.lr = 0x828BF784;
	sub_82A246C8(ctx, base);
	// 828BF784: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF788: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 828BF78C: 90D90008  stw r6, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x828BF790; continue 'dispatch;
            }
            0x828BF790 => {
    //   block [0x828BF790..0x828BF7A8)
	// 828BF790: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF794: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF798: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF79C: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF7A0: 41980008  blt cr6, 0x828bf7a8
	if ctx.cr[6].lt {
	pc = 0x828BF7A8; continue 'dispatch;
	}
	// 828BF7A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF7A8; continue 'dispatch;
            }
            0x828BF7A8 => {
    //   block [0x828BF7A8..0x828BF7B0)
	// 828BF7A8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828BF7AC: 4BFFFDFC  b 0x828bf5a8
	pc = 0x828BF5A8; continue 'dispatch;
            }
            0x828BF7B0 => {
    //   block [0x828BF7B0..0x828BF7BC)
	// 828BF7B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828BF7B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828BF7B8: 483E9C94  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BF7C0 size=344
    let mut pc: u32 = 0x828BF7C0;
    'dispatch: loop {
        match pc {
            0x828BF7C0 => {
    //   block [0x828BF7C0..0x828BF7FC)
	// 828BF7C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF7C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828BF7C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828BF7CC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828BF7D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF7D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828BF7D8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828BF7DC: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828BF7E0: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 828BF7E4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828BF7E8: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 828BF7EC: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 828BF7F0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BF7F4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828BF7F8: FFE06818  frsp f31, f13
	ctx.f[31].f64 = (ctx.f[13].f64 as f32) as f64;
	pc = 0x828BF7FC; continue 'dispatch;
            }
            0x828BF7FC => {
    //   block [0x828BF7FC..0x828BF828)
	// 828BF7FC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 828BF800: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828BF804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF808: 409900EC  ble cr6, 0x828bf8f4
	if !ctx.cr[6].gt {
	pc = 0x828BF8F4; continue 'dispatch;
	}
	// 828BF80C: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BF810: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BF814: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828BF818: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BF81C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF820: 40990008  ble cr6, 0x828bf828
	if !ctx.cr[6].gt {
	pc = 0x828BF828; continue 'dispatch;
	}
	// 828BF824: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF828; continue 'dispatch;
            }
            0x828BF828 => {
    //   block [0x828BF828..0x828BF83C)
	// 828BF828: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 828BF82C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF830: 4199000C  bgt cr6, 0x828bf83c
	if ctx.cr[6].gt {
	pc = 0x828BF83C; continue 'dispatch;
	}
	// 828BF834: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF838: 40980008  bge cr6, 0x828bf840
	if !ctx.cr[6].lt {
	pc = 0x828BF840; continue 'dispatch;
	}
	pc = 0x828BF83C; continue 'dispatch;
            }
            0x828BF83C => {
    //   block [0x828BF83C..0x828BF840)
	// 828BF83C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF840; continue 'dispatch;
            }
            0x828BF840 => {
    //   block [0x828BF840..0x828BF84C)
	// 828BF840: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF844: 41980008  blt cr6, 0x828bf84c
	if ctx.cr[6].lt {
	pc = 0x828BF84C; continue 'dispatch;
	}
	// 828BF848: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF84C; continue 'dispatch;
            }
            0x828BF84C => {
    //   block [0x828BF84C..0x828BF85C)
	// 828BF84C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF850: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BF854: 41990008  bgt cr6, 0x828bf85c
	if ctx.cr[6].gt {
	pc = 0x828BF85C; continue 'dispatch;
	}
	// 828BF858: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	pc = 0x828BF85C; continue 'dispatch;
            }
            0x828BF85C => {
    //   block [0x828BF85C..0x828BF88C)
	// 828BF85C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF860: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828BF864: 7CE9502E  lwzx r7, r9, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828BF868: 80C70008  lwz r6, 8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF86C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 828BF870: 40990084  ble cr6, 0x828bf8f4
	if !ctx.cr[6].gt {
	pc = 0x828BF8F4; continue 'dispatch;
	}
	// 828BF874: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BF878: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BF87C: 7D4B4A14  add r10, r11, r9
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828BF880: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF884: 40990008  ble cr6, 0x828bf88c
	if !ctx.cr[6].gt {
	pc = 0x828BF88C; continue 'dispatch;
	}
	// 828BF888: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF88C; continue 'dispatch;
            }
            0x828BF88C => {
    //   block [0x828BF88C..0x828BF8A0)
	// 828BF88C: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 828BF890: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF894: 4199000C  bgt cr6, 0x828bf8a0
	if ctx.cr[6].gt {
	pc = 0x828BF8A0; continue 'dispatch;
	}
	// 828BF898: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BF89C: 40980008  bge cr6, 0x828bf8a4
	if !ctx.cr[6].lt {
	pc = 0x828BF8A4; continue 'dispatch;
	}
	pc = 0x828BF8A0; continue 'dispatch;
            }
            0x828BF8A0 => {
    //   block [0x828BF8A0..0x828BF8A4)
	// 828BF8A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF8A4; continue 'dispatch;
            }
            0x828BF8A4 => {
    //   block [0x828BF8A4..0x828BF8B0)
	// 828BF8A4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BF8A8: 41980008  blt cr6, 0x828bf8b0
	if ctx.cr[6].lt {
	pc = 0x828BF8B0; continue 'dispatch;
	}
	// 828BF8AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BF8B0; continue 'dispatch;
            }
            0x828BF8B0 => {
    //   block [0x828BF8B0..0x828BF8C0)
	// 828BF8B0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF8B4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BF8B8: 41990008  bgt cr6, 0x828bf8c0
	if ctx.cr[6].gt {
	pc = 0x828BF8C0; continue 'dispatch;
	}
	// 828BF8BC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	pc = 0x828BF8C0; continue 'dispatch;
            }
            0x828BF8C0 => {
    //   block [0x828BF8C0..0x828BF8F4)
	// 828BF8C0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF8C4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828BF8C8: 7CE9502E  lwzx r7, r9, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828BF8CC: 80C70008  lwz r6, 8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BF8D0: 7CC507B4  extsw r5, r6
	ctx.r[5].s64 = ctx.r[6].s32 as i64;
	// 828BF8D4: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 828BF8D8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828BF8DC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828BF8E0: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828BF8E4: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 828BF8E8: 4098000C  bge cr6, 0x828bf8f4
	if !ctx.cr[6].lt {
	pc = 0x828BF8F4; continue 'dispatch;
	}
	// 828BF8EC: 48000E5D  bl 0x828c0748
	ctx.lr = 0x828BF8F0;
	sub_828C0748(ctx, base);
	// 828BF8F0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x828BF8F4; continue 'dispatch;
            }
            0x828BF8F4 => {
    //   block [0x828BF8F4..0x828BF918)
	// 828BF8F4: 550B063E  clrlwi r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 828BF8F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BF8FC: 419AFF00  beq cr6, 0x828bf7fc
	if ctx.cr[6].eq {
	pc = 0x828BF7FC; continue 'dispatch;
	}
	// 828BF900: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828BF904: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828BF908: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828BF90C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828BF910: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BF914: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828BF918 size=8
    let mut pc: u32 = 0x828BF918;
    'dispatch: loop {
        match pc {
            0x828BF918 => {
    //   block [0x828BF918..0x828BF920)
	// 828BF918: C0230018  lfs f1, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BF91C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828BF920 size=24
    let mut pc: u32 = 0x828BF920;
    'dispatch: loop {
        match pc {
            0x828BF920 => {
    //   block [0x828BF920..0x828BF938)
	// 828BF920: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828BF924: C0230024  lfs f1, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828BF928: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 828BF92C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 828BF930: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 828BF934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828BF938 size=28
    let mut pc: u32 = 0x828BF938;
    'dispatch: loop {
        match pc {
            0x828BF938 => {
    //   block [0x828BF938..0x828BF954)
	// 828BF938: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 828BF93C: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 828BF940: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 828BF944: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828BF948: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 828BF94C: FC206818  frsp f1, f13
	ctx.f[1].f64 = (ctx.f[13].f64 as f32) as f64;
	// 828BF950: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BF958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828BF958 size=1472
    let mut pc: u32 = 0x828BF958;
    'dispatch: loop {
        match pc {
            0x828BF958 => {
    //   block [0x828BF958..0x828BF9D4)
	// 828BF958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BF95C: 483E9AA5  bl 0x82ca9400
	ctx.lr = 0x828BF960;
	sub_82CA93D0(ctx, base);
	// 828BF960: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 828BF964: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828BF968: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BF96C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828BF970: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828BF974: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828BF978: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 828BF97C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF980: C3FA0024  lfs f31, 0x24(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828BF984: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828BF988: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BF98C: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BF990: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828BF994: 4E800421  bctrl
	ctx.lr = 0x828BF998;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BF998: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF99C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 828BF9A0: 810B0034  lwz r8, 0x34(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BF9A4: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 828BF9A8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BF9AC: 419A00D8  beq cr6, 0x828bfa84
	if ctx.cr[6].eq {
	pc = 0x828BFA84; continue 'dispatch;
	}
	// 828BF9B0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828BF9B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BF9B8: 419A001C  beq cr6, 0x828bf9d4
	if ctx.cr[6].eq {
	pc = 0x828BF9D4; continue 'dispatch;
	}
	// 828BF9BC: 894A0085  lbz r10, 0x85(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(133 as u32) ) } as u64;
	// 828BF9C0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BF9C4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828BF9C8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BF9CC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BF9D0: 480000B0  b 0x828bfa80
	pc = 0x828BFA80; continue 'dispatch;
            }
            0x828BF9D4 => {
    //   block [0x828BF9D4..0x828BF9F0)
	// 828BF9D4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828BF9D8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828BF9DC: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 828BF9E0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828BF9E4: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828BF9E8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BF9EC: 40810054  ble 0x828bfa40
	if !ctx.cr[0].gt {
	pc = 0x828BFA40; continue 'dispatch;
	}
	pc = 0x828BF9F0; continue 'dispatch;
            }
            0x828BF9F0 => {
    //   block [0x828BF9F0..0x828BFA10)
	// 828BF9F0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828BF9F4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828BF9F8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828BF9FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFA00: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 828BFA04: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828BFA08: 41980008  blt cr6, 0x828bfa10
	if ctx.cr[6].lt {
	pc = 0x828BFA10; continue 'dispatch;
	}
	// 828BFA0C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x828BFA10; continue 'dispatch;
            }
            0x828BFA10 => {
    //   block [0x828BFA10..0x828BFA2C)
	// 828BFA10: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828BFA14: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828BFA18: 419A0014  beq cr6, 0x828bfa2c
	if ctx.cr[6].eq {
	pc = 0x828BFA2C; continue 'dispatch;
	}
	// 828BFA1C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828BFA20: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828BFA24: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828BFA28: 4800000C  b 0x828bfa34
	pc = 0x828BFA34; continue 'dispatch;
            }
            0x828BFA2C => {
    //   block [0x828BFA2C..0x828BFA34)
	// 828BFA2C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828BFA30: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828BFA34; continue 'dispatch;
            }
            0x828BFA34 => {
    //   block [0x828BFA34..0x828BFA40)
	// 828BFA34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828BFA38: 4199FFB8  bgt cr6, 0x828bf9f0
	if ctx.cr[6].gt {
	pc = 0x828BF9F0; continue 'dispatch;
	}
	// 828BFA3C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x828BFA40; continue 'dispatch;
            }
            0x828BFA40 => {
    //   block [0x828BFA40..0x828BFA5C)
	// 828BFA40: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828BFA44: 419A0034  beq cr6, 0x828bfa78
	if ctx.cr[6].eq {
	pc = 0x828BFA78; continue 'dispatch;
	}
	// 828BFA48: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFA4C: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 828BFA50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BFA54: 41990008  bgt cr6, 0x828bfa5c
	if ctx.cr[6].gt {
	pc = 0x828BFA5C; continue 'dispatch;
	}
	// 828BFA58: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828BFA5C; continue 'dispatch;
            }
            0x828BFA5C => {
    //   block [0x828BFA5C..0x828BFA78)
	// 828BFA5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BFA60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BFA64: 409A0014  bne cr6, 0x828bfa78
	if !ctx.cr[6].eq {
	pc = 0x828BFA78; continue 'dispatch;
	}
	// 828BFA68: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828BFA6C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828BFA70: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828BFA74: 48000008  b 0x828bfa7c
	pc = 0x828BFA7C; continue 'dispatch;
            }
            0x828BFA78 => {
    //   block [0x828BFA78..0x828BFA7C)
	// 828BFA78: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x828BFA7C; continue 'dispatch;
            }
            0x828BFA7C => {
    //   block [0x828BFA7C..0x828BFA80)
	// 828BFA7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x828BFA80; continue 'dispatch;
            }
            0x828BFA80 => {
    //   block [0x828BFA80..0x828BFA84)
	// 828BFA80: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	pc = 0x828BFA84; continue 'dispatch;
            }
            0x828BFA84 => {
    //   block [0x828BFA84..0x828BFAA0)
	// 828BFA84: 817A0034  lwz r11, 0x34(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(52 as u32) ) } as u64;
	// 828BFA88: 3BFA0028  addi r31, r26, 0x28
	ctx.r[31].s64 = ctx.r[26].s64 + 40;
	// 828BFA8C: 815A0038  lwz r10, 0x38(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(56 as u32) ) } as u64;
	// 828BFA90: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BFA94: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BFA98: 40990008  ble cr6, 0x828bfaa0
	if !ctx.cr[6].gt {
	pc = 0x828BFAA0; continue 'dispatch;
	}
	// 828BFA9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BFAA0; continue 'dispatch;
            }
            0x828BFAA0 => {
    //   block [0x828BFAA0..0x828BFABC)
	// 828BFAA0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828BFAA4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BFAA8: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BFAAC: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828BFAB0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BFAB4: 40990008  ble cr6, 0x828bfabc
	if !ctx.cr[6].gt {
	pc = 0x828BFABC; continue 'dispatch;
	}
	// 828BFAB8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BFABC; continue 'dispatch;
            }
            0x828BFABC => {
    //   block [0x828BFABC..0x828BFAC8)
	// 828BFABC: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828BFAC0: 419A0008  beq cr6, 0x828bfac8
	if ctx.cr[6].eq {
	pc = 0x828BFAC8; continue 'dispatch;
	}
	// 828BFAC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BFAC8; continue 'dispatch;
            }
            0x828BFAC8 => {
    //   block [0x828BFAC8..0x828BFAE0)
	// 828BFAC8: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828BFACC: 419A0228  beq cr6, 0x828bfcf4
	if ctx.cr[6].eq {
	pc = 0x828BFCF4; continue 'dispatch;
	}
	// 828BFAD0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 828BFAD4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BFAD8: 41980008  blt cr6, 0x828bfae0
	if ctx.cr[6].lt {
	pc = 0x828BFAE0; continue 'dispatch;
	}
	// 828BFADC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BFAE0; continue 'dispatch;
            }
            0x828BFAE0 => {
    //   block [0x828BFAE0..0x828BFAF0)
	// 828BFAE0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BFAE4: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BFAE8: 41990008  bgt cr6, 0x828bfaf0
	if ctx.cr[6].gt {
	pc = 0x828BFAF0; continue 'dispatch;
	}
	// 828BFAEC: 7D2BF050  subf r9, r11, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	pc = 0x828BFAF0; continue 'dispatch;
            }
            0x828BFAF0 => {
    //   block [0x828BFAF0..0x828BFB34)
	// 828BFAF0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BFAF4: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BFAF8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BFAFC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BFB00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BFB04: 419A0030  beq cr6, 0x828bfb34
	if ctx.cr[6].eq {
	pc = 0x828BFB34; continue 'dispatch;
	}
	// 828BFB08: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFB0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BFB10: 419A008C  beq cr6, 0x828bfb9c
	if ctx.cr[6].eq {
	pc = 0x828BFB9C; continue 'dispatch;
	}
	// 828BFB14: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BFB18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BFB1C: 419A0018  beq cr6, 0x828bfb34
	if ctx.cr[6].eq {
	pc = 0x828BFB34; continue 'dispatch;
	}
	// 828BFB20: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828BFB24: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828BFB28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828BFB2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BFB30: 409A0008  bne cr6, 0x828bfb38
	if !ctx.cr[6].eq {
	pc = 0x828BFB38; continue 'dispatch;
	}
	pc = 0x828BFB34; continue 'dispatch;
            }
            0x828BFB34 => {
    //   block [0x828BFB34..0x828BFB38)
	// 828BFB34: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828BFB38; continue 'dispatch;
            }
            0x828BFB38 => {
    //   block [0x828BFB38..0x828BFB60)
	// 828BFB38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828BFB3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BFB40: 419A0194  beq cr6, 0x828bfcd4
	if ctx.cr[6].eq {
	pc = 0x828BFCD4; continue 'dispatch;
	}
	// 828BFB44: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BFB48: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 828BFB4C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BFB50: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828BFB54: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828BFB58: 41980008  blt cr6, 0x828bfb60
	if ctx.cr[6].lt {
	pc = 0x828BFB60; continue 'dispatch;
	}
	// 828BFB5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828BFB60; continue 'dispatch;
            }
            0x828BFB60 => {
    //   block [0x828BFB60..0x828BFB70)
	// 828BFB60: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828BFB64: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828BFB68: 41990008  bgt cr6, 0x828bfb70
	if ctx.cr[6].gt {
	pc = 0x828BFB70; continue 'dispatch;
	}
	// 828BFB6C: 7D2BF050  subf r9, r11, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	pc = 0x828BFB70; continue 'dispatch;
            }
            0x828BFB70 => {
    //   block [0x828BFB70..0x828BFB9C)
	// 828BFB70: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BFB74: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828BFB78: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828BFB7C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BFB80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828BFB84: 419A0024  beq cr6, 0x828bfba8
	if ctx.cr[6].eq {
	pc = 0x828BFBA8; continue 'dispatch;
	}
	// 828BFB88: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFB8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828BFB90: 419A0014  beq cr6, 0x828bfba4
	if ctx.cr[6].eq {
	pc = 0x828BFBA4; continue 'dispatch;
	}
	// 828BFB94: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828BFB98: 48000014  b 0x828bfbac
	pc = 0x828BFBAC; continue 'dispatch;
            }
            0x828BFB9C => {
    //   block [0x828BFB9C..0x828BFBA4)
	// 828BFB9C: 4B8D429D  bl 0x82193e38
	ctx.lr = 0x828BFBA0;
	sub_82193E38(ctx, base);
	// 828BFBA0: 4BFFFF94  b 0x828bfb34
	pc = 0x828BFB34; continue 'dispatch;
            }
            0x828BFBA4 => {
    //   block [0x828BFBA4..0x828BFBA8)
	// 828BFBA4: 4B8D4295  bl 0x82193e38
	ctx.lr = 0x828BFBA8;
	sub_82193E38(ctx, base);
	pc = 0x828BFBA8; continue 'dispatch;
            }
            0x828BFBA8 => {
    //   block [0x828BFBA8..0x828BFBAC)
	// 828BFBA8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828BFBAC; continue 'dispatch;
            }
            0x828BFBAC => {
    //   block [0x828BFBAC..0x828BFCD4)
	// 828BFBAC: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828BFBB0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828BFBB4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828BFBB8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828BFBBC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828BFBC0: 4E800421  bctrl
	ctx.lr = 0x828BFBC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828BFBC4: 392100B0  addi r9, r1, 0xb0
	ctx.r[9].s64 = ctx.r[1].s64 + 176;
	// 828BFBC8: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 828BFBCC: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
            }
            0x828BFCD4 => {
    //   block [0x828BFCD4..0x828BFCF4)
	// 828BFCD4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828BFCD8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828BFCDC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828BFCE0: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828BFCE4: 41980008  blt cr6, 0x828bfcec
	if ctx.cr[6].lt {
	pc = 0x828BFCEC; continue 'dispatch;
	}
	// 828BFCE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828BFCEC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828BFCF0: 4BFFFDB4  b 0x828bfaa4
	pc = 0x828BFAA4; continue 'dispatch;
            }
            0x828BFCF4 => {
    //   block [0x828BFCF4..0x828BFF18)
	// 828BFCF4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828BFCF8: FC00F81E  fctiwz f0, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[31].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[31].f64.trunc() as i32 as i64 };
	// 828BFCFC: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 828BFD00: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 828BFD04: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 828BFD08: 80FA0004  lwz r7, 4(r26)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828BFD0C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828BFD10: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828BFD14: 814B6AB8  lwz r10, 0x6ab8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828BFD18: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828BFD1C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828BFF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828BFF18 size=700
    let mut pc: u32 = 0x828BFF18;
    'dispatch: loop {
        match pc {
            0x828BFF18 => {
    //   block [0x828BFF18..0x828C01D4)
	// 828BFF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828BFF1C: 483E94ED  bl 0x82ca9408
	ctx.lr = 0x828BFF20;
	sub_82CA93D0(ctx, base);
	// 828BFF20: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828BFF24: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 828BFF28: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828BFF2C: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 828BFF30: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828BFF34: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C01D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C01D8 size=1080
    let mut pc: u32 = 0x828C01D8;
    'dispatch: loop {
        match pc {
            0x828C01D8 => {
    //   block [0x828C01D8..0x828C0610)
	// 828C01D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C01DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C01E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C01E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C01E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C01EC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C01F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C01F4: 3BCB2FA8  addi r30, r11, 0x2fa8
	ctx.r[30].s64 = ctx.r[11].s64 + 12200;
	// 828C01F8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C01FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0200: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0204: 4B96CCCD  bl 0x8222ced0
	ctx.lr = 0x828C0208;
	sub_8222CED0(ctx, base);
	// 828C0208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C020C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C0210: 48000A39  bl 0x828c0c48
	ctx.lr = 0x828C0214;
	sub_828C0C48(ctx, base);
	// 828C0214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0218: 4B954BC1  bl 0x82214dd8
	ctx.lr = 0x828C021C;
	sub_82214DD8(ctx, base);
	// 828C021C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C0220: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0224: 388A2FB4  addi r4, r10, 0x2fb4
	ctx.r[4].s64 = ctx.r[10].s64 + 12212;
	// 828C0228: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C022C: 4B96CCA5  bl 0x8222ced0
	ctx.lr = 0x828C0230;
	sub_8222CED0(ctx, base);
	// 828C0230: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0234: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C023C: 4B96CC95  bl 0x8222ced0
	ctx.lr = 0x828C0240;
	sub_8222CED0(ctx, base);
	// 828C0240: 3D20828C  lis r9, -0x7d74
	ctx.r[9].s64 = -2104754176;
	// 828C0244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0248: 38C9E650  addi r6, r9, -0x19b0
	ctx.r[6].s64 = ctx.r[9].s64 + -6576;
	// 828C024C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828C0250: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C0254: 48000C3D  bl 0x828c0e90
	ctx.lr = 0x828C0258;
	sub_828C0E90(ctx, base);
	// 828C0258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C025C: 4B954B7D  bl 0x82214dd8
	ctx.lr = 0x828C0260;
	sub_82214DD8(ctx, base);
	// 828C0260: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0264: 4B954B75  bl 0x82214dd8
	ctx.lr = 0x828C0268;
	sub_82214DD8(ctx, base);
	// 828C0268: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828C026C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0270: 38882FC4  addi r4, r8, 0x2fc4
	ctx.r[4].s64 = ctx.r[8].s64 + 12228;
	// 828C0274: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0278: 4B96CC59  bl 0x8222ced0
	ctx.lr = 0x828C027C;
	sub_8222CED0(ctx, base);
	// 828C027C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0280: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0284: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0288: 4B96CC49  bl 0x8222ced0
	ctx.lr = 0x828C028C;
	sub_8222CED0(ctx, base);
	// 828C028C: 3CE0821A  lis r7, -0x7de6
	ctx.r[7].s64 = -2112225280;
	// 828C0290: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0294: 38C79BB8  addi r6, r7, -0x6448
	ctx.r[6].s64 = ctx.r[7].s64 + -25672;
	// 828C0298: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C029C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C02A0: 48000DB1  bl 0x828c1050
	ctx.lr = 0x828C02A4;
	sub_828C1050(ctx, base);
	// 828C02A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C02A8: 4B954B31  bl 0x82214dd8
	ctx.lr = 0x828C02AC;
	sub_82214DD8(ctx, base);
	// 828C02AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C02B0: 4B954B29  bl 0x82214dd8
	ctx.lr = 0x828C02B4;
	sub_82214DD8(ctx, base);
	// 828C02B4: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828C02B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C02BC: 38862FD0  addi r4, r6, 0x2fd0
	ctx.r[4].s64 = ctx.r[6].s64 + 12240;
	// 828C02C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C02C4: 4B96CC0D  bl 0x8222ced0
	ctx.lr = 0x828C02C8;
	sub_8222CED0(ctx, base);
	// 828C02C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C02CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C02D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C02D4: 4B96CBFD  bl 0x8222ced0
	ctx.lr = 0x828C02D8;
	sub_8222CED0(ctx, base);
	// 828C02D8: 3C80828C  lis r4, -0x7d74
	ctx.r[4].s64 = -2104754176;
	// 828C02DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C02E0: 38C4E270  addi r6, r4, -0x1d90
	ctx.r[6].s64 = ctx.r[4].s64 + -7568;
	// 828C02E4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C02E8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C02EC: 48000BA5  bl 0x828c0e90
	ctx.lr = 0x828C02F0;
	sub_828C0E90(ctx, base);
	// 828C02F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C02F4: 4B954AE5  bl 0x82214dd8
	ctx.lr = 0x828C02F8;
	sub_82214DD8(ctx, base);
	// 828C02F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C02FC: 4B954ADD  bl 0x82214dd8
	ctx.lr = 0x828C0300;
	sub_82214DD8(ctx, base);
	// 828C0300: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828C0304: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0308: 38832FE0  addi r4, r3, 0x2fe0
	ctx.r[4].s64 = ctx.r[3].s64 + 12256;
	// 828C030C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0310: 4B96CBC1  bl 0x8222ced0
	ctx.lr = 0x828C0314;
	sub_8222CED0(ctx, base);
	// 828C0314: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0318: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C031C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0320: 4B96CBB1  bl 0x8222ced0
	ctx.lr = 0x828C0324;
	sub_8222CED0(ctx, base);
	// 828C0324: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C0328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C032C: 38CBF918  addi r6, r11, -0x6e8
	ctx.r[6].s64 = ctx.r[11].s64 + -1768;
	// 828C0330: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C0334: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C0338: 48000ED9  bl 0x828c1210
	ctx.lr = 0x828C033C;
	sub_828C1210(ctx, base);
	// 828C033C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0340: 4B954A99  bl 0x82214dd8
	ctx.lr = 0x828C0344;
	sub_82214DD8(ctx, base);
	// 828C0344: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0348: 4B954A91  bl 0x82214dd8
	ctx.lr = 0x828C034C;
	sub_82214DD8(ctx, base);
	// 828C034C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C0350: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0354: 388A2FF8  addi r4, r10, 0x2ff8
	ctx.r[4].s64 = ctx.r[10].s64 + 12280;
	// 828C0358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C035C: 4B96CB75  bl 0x8222ced0
	ctx.lr = 0x828C0360;
	sub_8222CED0(ctx, base);
	// 828C0360: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0364: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0368: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C036C: 4B96CB65  bl 0x8222ced0
	ctx.lr = 0x828C0370;
	sub_8222CED0(ctx, base);
	// 828C0370: 3D20828C  lis r9, -0x7d74
	ctx.r[9].s64 = -2104754176;
	// 828C0374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0378: 38C9F920  addi r6, r9, -0x6e0
	ctx.r[6].s64 = ctx.r[9].s64 + -1760;
	// 828C037C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C0380: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C0384: 48000E8D  bl 0x828c1210
	ctx.lr = 0x828C0388;
	sub_828C1210(ctx, base);
	// 828C0388: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C038C: 4B954A4D  bl 0x82214dd8
	ctx.lr = 0x828C0390;
	sub_82214DD8(ctx, base);
	// 828C0390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0394: 4B954A45  bl 0x82214dd8
	ctx.lr = 0x828C0398;
	sub_82214DD8(ctx, base);
	// 828C0398: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828C039C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C03A0: 38883010  addi r4, r8, 0x3010
	ctx.r[4].s64 = ctx.r[8].s64 + 12304;
	// 828C03A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C03A8: 4B96CB29  bl 0x8222ced0
	ctx.lr = 0x828C03AC;
	sub_8222CED0(ctx, base);
	// 828C03AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C03B0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C03B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C03B8: 4B96CB19  bl 0x8222ced0
	ctx.lr = 0x828C03BC;
	sub_8222CED0(ctx, base);
	// 828C03BC: 3CE08270  lis r7, -0x7d90
	ctx.r[7].s64 = -2106589184;
	// 828C03C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C03C4: 38C7FED8  addi r6, r7, -0x128
	ctx.r[6].s64 = ctx.r[7].s64 + -296;
	// 828C03C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C03CC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C03D0: 48001041  bl 0x828c1410
	ctx.lr = 0x828C03D4;
	sub_828C1410(ctx, base);
	// 828C03D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C03D8: 4B954A01  bl 0x82214dd8
	ctx.lr = 0x828C03DC;
	sub_82214DD8(ctx, base);
	// 828C03DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C03E0: 4B9549F9  bl 0x82214dd8
	ctx.lr = 0x828C03E4;
	sub_82214DD8(ctx, base);
	// 828C03E4: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828C03E8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C03EC: 3886301C  addi r4, r6, 0x301c
	ctx.r[4].s64 = ctx.r[6].s64 + 12316;
	// 828C03F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C03F4: 4B96CADD  bl 0x8222ced0
	ctx.lr = 0x828C03F8;
	sub_8222CED0(ctx, base);
	// 828C03F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C03FC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0400: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0404: 4B96CACD  bl 0x8222ced0
	ctx.lr = 0x828C0408;
	sub_8222CED0(ctx, base);
	// 828C0408: 3C808272  lis r4, -0x7d8e
	ctx.r[4].s64 = -2106458112;
	// 828C040C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0410: 38C425D0  addi r6, r4, 0x25d0
	ctx.r[6].s64 = ctx.r[4].s64 + 9680;
	// 828C0414: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C0418: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C041C: 48000FF5  bl 0x828c1410
	ctx.lr = 0x828C0420;
	sub_828C1410(ctx, base);
	// 828C0420: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0424: 4B9549B5  bl 0x82214dd8
	ctx.lr = 0x828C0428;
	sub_82214DD8(ctx, base);
	// 828C0428: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C042C: 4B9549AD  bl 0x82214dd8
	ctx.lr = 0x828C0430;
	sub_82214DD8(ctx, base);
	// 828C0430: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828C0434: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0438: 38833034  addi r4, r3, 0x3034
	ctx.r[4].s64 = ctx.r[3].s64 + 12340;
	// 828C043C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0440: 4B96CA91  bl 0x8222ced0
	ctx.lr = 0x828C0444;
	sub_8222CED0(ctx, base);
	// 828C0444: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0448: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C044C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0450: 4B96CA81  bl 0x8222ced0
	ctx.lr = 0x828C0454;
	sub_8222CED0(ctx, base);
	// 828C0454: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C0458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C045C: 38CBF178  addi r6, r11, -0xe88
	ctx.r[6].s64 = ctx.r[11].s64 + -3720;
	// 828C0460: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C0464: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C0468: 48000FA9  bl 0x828c1410
	ctx.lr = 0x828C046C;
	sub_828C1410(ctx, base);
	// 828C046C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0470: 4B954969  bl 0x82214dd8
	ctx.lr = 0x828C0474;
	sub_82214DD8(ctx, base);
	// 828C0474: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0478: 4B954961  bl 0x82214dd8
	ctx.lr = 0x828C047C;
	sub_82214DD8(ctx, base);
	// 828C047C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C0480: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0484: 388A3044  addi r4, r10, 0x3044
	ctx.r[4].s64 = ctx.r[10].s64 + 12356;
	// 828C0488: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C048C: 4B96CA45  bl 0x8222ced0
	ctx.lr = 0x828C0490;
	sub_8222CED0(ctx, base);
	// 828C0490: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0494: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0498: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C049C: 4B96CA35  bl 0x8222ced0
	ctx.lr = 0x828C04A0;
	sub_8222CED0(ctx, base);
	// 828C04A0: 3D20828C  lis r9, -0x7d74
	ctx.r[9].s64 = -2104754176;
	// 828C04A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C04A8: 38C9F938  addi r6, r9, -0x6c8
	ctx.r[6].s64 = ctx.r[9].s64 + -1736;
	// 828C04AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C04B0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C04B4: 48000D5D  bl 0x828c1210
	ctx.lr = 0x828C04B8;
	sub_828C1210(ctx, base);
	// 828C04B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C04BC: 4B95491D  bl 0x82214dd8
	ctx.lr = 0x828C04C0;
	sub_82214DD8(ctx, base);
	// 828C04C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C04C4: 4B954915  bl 0x82214dd8
	ctx.lr = 0x828C04C8;
	sub_82214DD8(ctx, base);
	// 828C04C8: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828C04CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C04D0: 38883058  addi r4, r8, 0x3058
	ctx.r[4].s64 = ctx.r[8].s64 + 12376;
	// 828C04D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C04D8: 4B96C9F9  bl 0x8222ced0
	ctx.lr = 0x828C04DC;
	sub_8222CED0(ctx, base);
	// 828C04DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C04E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C04E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C04E8: 4B96C9E9  bl 0x8222ced0
	ctx.lr = 0x828C04EC;
	sub_8222CED0(ctx, base);
	// 828C04EC: 3CE0828C  lis r7, -0x7d74
	ctx.r[7].s64 = -2104754176;
	// 828C04F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C04F4: 38C7F2E0  addi r6, r7, -0xd20
	ctx.r[6].s64 = ctx.r[7].s64 + -3360;
	// 828C04F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C04FC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C0500: 48000991  bl 0x828c0e90
	ctx.lr = 0x828C0504;
	sub_828C0E90(ctx, base);
	// 828C0504: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0508: 4B9548D1  bl 0x82214dd8
	ctx.lr = 0x828C050C;
	sub_82214DD8(ctx, base);
	// 828C050C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0510: 4B9548C9  bl 0x82214dd8
	ctx.lr = 0x828C0514;
	sub_82214DD8(ctx, base);
	// 828C0514: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828C0518: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C051C: 38863064  addi r4, r6, 0x3064
	ctx.r[4].s64 = ctx.r[6].s64 + 12388;
	// 828C0520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0524: 4B96C9AD  bl 0x8222ced0
	ctx.lr = 0x828C0528;
	sub_8222CED0(ctx, base);
	// 828C0528: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C052C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0530: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0534: 4B96C99D  bl 0x8222ced0
	ctx.lr = 0x828C0538;
	sub_8222CED0(ctx, base);
	// 828C0538: 3C80828C  lis r4, -0x7d74
	ctx.r[4].s64 = -2104754176;
	// 828C053C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0540: 38C4F530  addi r6, r4, -0xad0
	ctx.r[6].s64 = ctx.r[4].s64 + -2768;
	// 828C0544: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C0548: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C054C: 480010C5  bl 0x828c1610
	ctx.lr = 0x828C0550;
	sub_828C1610(ctx, base);
	// 828C0550: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0554: 4B954885  bl 0x82214dd8
	ctx.lr = 0x828C0558;
	sub_82214DD8(ctx, base);
	// 828C0558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C055C: 4B95487D  bl 0x82214dd8
	ctx.lr = 0x828C0560;
	sub_82214DD8(ctx, base);
	// 828C0560: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828C0564: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C0568: 38833078  addi r4, r3, 0x3078
	ctx.r[4].s64 = ctx.r[3].s64 + 12408;
	// 828C056C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0570: 4B96C961  bl 0x8222ced0
	ctx.lr = 0x828C0574;
	sub_8222CED0(ctx, base);
	// 828C0574: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0578: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C057C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C0580: 4B96C951  bl 0x8222ced0
	ctx.lr = 0x828C0584;
	sub_8222CED0(ctx, base);
	// 828C0584: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C0588: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C058C: 38CBEBD0  addi r6, r11, -0x1430
	ctx.r[6].s64 = ctx.r[11].s64 + -5168;
	// 828C0590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0594: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C0598: 48000AB9  bl 0x828c1050
	ctx.lr = 0x828C059C;
	sub_828C1050(ctx, base);
	// 828C059C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C05A0: 4B954839  bl 0x82214dd8
	ctx.lr = 0x828C05A4;
	sub_82214DD8(ctx, base);
	// 828C05A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C05A8: 4B954831  bl 0x82214dd8
	ctx.lr = 0x828C05AC;
	sub_82214DD8(ctx, base);
	// 828C05AC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C05B0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C05B4: 388A3080  addi r4, r10, 0x3080
	ctx.r[4].s64 = ctx.r[10].s64 + 12416;
	// 828C05B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C05BC: 4B96C915  bl 0x8222ced0
	ctx.lr = 0x828C05C0;
	sub_8222CED0(ctx, base);
	// 828C05C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C05C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C05C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C05CC: 4B96C905  bl 0x8222ced0
	ctx.lr = 0x828C05D0;
	sub_8222CED0(ctx, base);
	// 828C05D0: 3D20828C  lis r9, -0x7d74
	ctx.r[9].s64 = -2104754176;
	// 828C05D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C05D8: 38C9F958  addi r6, r9, -0x6a8
	ctx.r[6].s64 = ctx.r[9].s64 + -1704;
	// 828C05DC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C05E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C05E4: 48001235  bl 0x828c1818
	ctx.lr = 0x828C05E8;
	sub_828C1818(ctx, base);
	// 828C05E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C05EC: 4B9547ED  bl 0x82214dd8
	ctx.lr = 0x828C05F0;
	sub_82214DD8(ctx, base);
	// 828C05F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C05F4: 4B9547E5  bl 0x82214dd8
	ctx.lr = 0x828C05F8;
	sub_82214DD8(ctx, base);
	// 828C05F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C05FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C0600: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C0604: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C0608: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C060C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C0610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C0610 size=140
    let mut pc: u32 = 0x828C0610;
    'dispatch: loop {
        match pc {
            0x828C0610 => {
    //   block [0x828C0610..0x828C062C)
	// 828C0610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C0614: 483E8DF9  bl 0x82ca940c
	ctx.lr = 0x828C0618;
	sub_82CA93D0(ctx, base);
	// 828C0618: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C061C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C0620: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C0624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C0628: 419A0018  beq cr6, 0x828c0640
	if ctx.cr[6].eq {
	pc = 0x828C0640; continue 'dispatch;
	}
	pc = 0x828C062C; continue 'dispatch;
            }
            0x828C062C => {
    //   block [0x828C062C..0x828C0640)
	// 828C062C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C0630: 48000119  bl 0x828c0748
	ctx.lr = 0x828C0634;
	sub_828C0748(ctx, base);
	// 828C0634: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C0638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C063C: 409AFFF0  bne cr6, 0x828c062c
	if !ctx.cr[6].eq {
	pc = 0x828C062C; continue 'dispatch;
	}
	pc = 0x828C0640; continue 'dispatch;
            }
            0x828C0640 => {
    //   block [0x828C0640..0x828C0650)
	// 828C0640: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0644: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C0648: 419A0030  beq cr6, 0x828c0678
	if ctx.cr[6].eq {
	pc = 0x828C0678; continue 'dispatch;
	}
	// 828C064C: 57DF103A  slwi r31, r30, 2
	ctx.r[31].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x828C0650; continue 'dispatch;
            }
            0x828C0650 => {
    //   block [0x828C0650..0x828C0670)
	// 828C0650: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0654: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 828C0658: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 828C065C: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828C0660: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C0664: 419A000C  beq cr6, 0x828c0670
	if ctx.cr[6].eq {
	pc = 0x828C0670; continue 'dispatch;
	}
	// 828C0668: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828C066C: 4B95B6CD  bl 0x8221bd38
	ctx.lr = 0x828C0670;
	sub_8221BD38(ctx, base);
	pc = 0x828C0670; continue 'dispatch;
            }
            0x828C0670 => {
    //   block [0x828C0670..0x828C0678)
	// 828C0670: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C0674: 409AFFDC  bne cr6, 0x828c0650
	if !ctx.cr[6].eq {
	pc = 0x828C0650; continue 'dispatch;
	}
	pc = 0x828C0678; continue 'dispatch;
            }
            0x828C0678 => {
    //   block [0x828C0678..0x828C0688)
	// 828C0678: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C067C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C0680: 419A0008  beq cr6, 0x828c0688
	if ctx.cr[6].eq {
	pc = 0x828C0688; continue 'dispatch;
	}
	// 828C0684: 4B95B6B5  bl 0x8221bd38
	ctx.lr = 0x828C0688;
	sub_8221BD38(ctx, base);
	pc = 0x828C0688; continue 'dispatch;
            }
            0x828C0688 => {
    //   block [0x828C0688..0x828C069C)
	// 828C0688: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C068C: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C0690: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C0694: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C0698: 483E8DC4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C06A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C06A0 size=164
    let mut pc: u32 = 0x828C06A0;
    'dispatch: loop {
        match pc {
            0x828C06A0 => {
    //   block [0x828C06A0..0x828C06D0)
	// 828C06A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C06A4: 483E8D65  bl 0x82ca9408
	ctx.lr = 0x828C06A8;
	sub_82CA93D0(ctx, base);
	// 828C06A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C06AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C06B0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C06B4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C06B8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C06BC: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 828C06C0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C06C4: 4199000C  bgt cr6, 0x828c06d0
	if ctx.cr[6].gt {
	pc = 0x828C06D0; continue 'dispatch;
	}
	// 828C06C8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C06CC: 4800031D  bl 0x828c09e8
	ctx.lr = 0x828C06D0;
	sub_828C09E8(ctx, base);
	pc = 0x828C06D0; continue 'dispatch;
            }
            0x828C06D0 => {
    //   block [0x828C06D0..0x828C06E0)
	// 828C06D0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C06D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C06D8: 409A0008  bne cr6, 0x828c06e0
	if !ctx.cr[6].eq {
	pc = 0x828C06E0; continue 'dispatch;
	}
	// 828C06DC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x828C06E0; continue 'dispatch;
            }
            0x828C06E0 => {
    //   block [0x828C06E0..0x828C0708)
	// 828C06E0: 3BABFFFF  addi r29, r11, -1
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	// 828C06E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C06E8: 57BE103A  slwi r30, r29, 2
	ctx.r[30].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 828C06EC: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828C06F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C06F4: 409A0014  bne cr6, 0x828c0708
	if !ctx.cr[6].eq {
	pc = 0x828C0708; continue 'dispatch;
	}
	// 828C06F8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C06FC: 4B95EB5D  bl 0x8221f258
	ctx.lr = 0x828C0700;
	sub_8221F258(ctx, base);
	// 828C0700: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0704: 7C6BF12E  stwx r3, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[3].u32) };
	pc = 0x828C0708; continue 'dispatch;
            }
            0x828C0708 => {
    //   block [0x828C0708..0x828C072C)
	// 828C0708: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C070C: 7FCBF02E  lwzx r30, r11, r30
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828C0710: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C0714: 419A0018  beq cr6, 0x828c072c
	if ctx.cr[6].eq {
	pc = 0x828C072C; continue 'dispatch;
	}
	// 828C0718: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C071C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C0720: 4B8D6651  bl 0x82196d70
	ctx.lr = 0x828C0724;
	sub_82196D70(ctx, base);
	// 828C0724: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0728: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x828C072C; continue 'dispatch;
            }
            0x828C072C => {
    //   block [0x828C072C..0x828C0744)
	// 828C072C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C0730: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 828C0734: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C0738: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828C073C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C0740: 483E8D18  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C0748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C0748 size=148
    let mut pc: u32 = 0x828C0748;
    'dispatch: loop {
        match pc {
            0x828C0748 => {
    //   block [0x828C0748..0x828C0788)
	// 828C0748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C074C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C0750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C0754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C0758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C075C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C0760: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C0764: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C0768: 419A005C  beq cr6, 0x828c07c4
	if ctx.cr[6].eq {
	pc = 0x828C07C4; continue 'dispatch;
	}
	// 828C076C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C0770: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0774: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 828C0778: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C077C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C0780: 41990008  bgt cr6, 0x828c0788
	if ctx.cr[6].gt {
	pc = 0x828C0788; continue 'dispatch;
	}
	// 828C0784: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	pc = 0x828C0788; continue 'dispatch;
            }
            0x828C0788 => {
    //   block [0x828C0788..0x828C07C4)
	// 828C0788: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C078C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C0790: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828C0794: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 828C0798: 7FC9502E  lwzx r30, r9, r10
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828C079C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C07A0: 90FE0000  stw r7, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828C07A4: 4B8D3695  bl 0x82193e38
	ctx.lr = 0x828C07A8;
	sub_82193E38(ctx, base);
	// 828C07A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C07AC: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C07B0: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C07B4: 3566FFFF  addic. r11, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C07B8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828C07BC: 40820008  bne 0x828c07c4
	if !ctx.cr[0].eq {
	pc = 0x828C07C4; continue 'dispatch;
	}
	// 828C07C0: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x828C07C4; continue 'dispatch;
            }
            0x828C07C4 => {
    //   block [0x828C07C4..0x828C07DC)
	// 828C07C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C07C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C07CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C07D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C07D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C07D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C07E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C07E0 size=516
    let mut pc: u32 = 0x828C07E0;
    'dispatch: loop {
        match pc {
            0x828C07E0 => {
    //   block [0x828C07E0..0x828C080C)
	// 828C07E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C07E4: 483E8C19  bl 0x82ca93fc
	ctx.lr = 0x828C07E8;
	sub_82CA93D0(ctx, base);
	// 828C07E8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C07EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C07F0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828C07F4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C07F8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C07FC: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C0800: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C0804: 40990008  ble cr6, 0x828c080c
	if !ctx.cr[6].gt {
	pc = 0x828C080C; continue 'dispatch;
	}
	// 828C0808: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C080C; continue 'dispatch;
            }
            0x828C080C => {
    //   block [0x828C080C..0x828C0820)
	// 828C080C: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0810: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C0814: 419A000C  beq cr6, 0x828c0820
	if ctx.cr[6].eq {
	pc = 0x828C0820; continue 'dispatch;
	}
	// 828C0818: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828C081C: 419A0008  beq cr6, 0x828c0824
	if ctx.cr[6].eq {
	pc = 0x828C0824; continue 'dispatch;
	}
	pc = 0x828C0820; continue 'dispatch;
            }
            0x828C0820 => {
    //   block [0x828C0820..0x828C0824)
	// 828C0820: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C0824; continue 'dispatch;
            }
            0x828C0824 => {
    //   block [0x828C0824..0x828C0844)
	// 828C0824: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0828: 80860004  lwz r4, 4(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C082C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C0830: 7F6A4850  subf r27, r10, r9
	ctx.r[27].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 828C0834: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C0838: 419A000C  beq cr6, 0x828c0844
	if ctx.cr[6].eq {
	pc = 0x828C0844; continue 'dispatch;
	}
	// 828C083C: 7F041840  cmplw cr6, r4, r3
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828C0840: 419A0008  beq cr6, 0x828c0848
	if ctx.cr[6].eq {
	pc = 0x828C0848; continue 'dispatch;
	}
	pc = 0x828C0844; continue 'dispatch;
            }
            0x828C0844 => {
    //   block [0x828C0844..0x828C0848)
	// 828C0844: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C0848; continue 'dispatch;
            }
            0x828C0848 => {
    //   block [0x828C0848..0x828C0860)
	// 828C0848: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C084C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C0850: 7F895850  subf r28, r9, r11
	ctx.r[28].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C0854: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C0858: 40990008  ble cr6, 0x828c0860
	if !ctx.cr[6].gt {
	pc = 0x828C0860; continue 'dispatch;
	}
	// 828C085C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C0860; continue 'dispatch;
            }
            0x828C0860 => {
    //   block [0x828C0860..0x828C086C)
	// 828C0860: 7F1F2040  cmplw cr6, r31, r4
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828C0864: 419A0008  beq cr6, 0x828c086c
	if ctx.cr[6].eq {
	pc = 0x828C086C; continue 'dispatch;
	}
	// 828C0868: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C086C; continue 'dispatch;
            }
            0x828C086C => {
    //   block [0x828C086C..0x828C08A8)
	// 828C086C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C0870: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 828C0874: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C0878: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828C087C: 7F1B3840  cmplw cr6, r27, r7
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828C0880: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828C0884: 409800B8  bge cr6, 0x828c093c
	if !ctx.cr[6].lt {
	pc = 0x828C093C; continue 'dispatch;
	}
	// 828C0888: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 828C088C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C0890: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C0894: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C0898: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 828C089C: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 828C08A0: 40990008  ble cr6, 0x828c08a8
	if !ctx.cr[6].gt {
	pc = 0x828C08A8; continue 'dispatch;
	}
	// 828C08A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C08A8; continue 'dispatch;
            }
            0x828C08A8 => {
    //   block [0x828C08A8..0x828C08D4)
	// 828C08A8: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 828C08AC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828C08B0: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 828C08B4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828C08B8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828C08BC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C08C0: 48001161  bl 0x828c1a20
	ctx.lr = 0x828C08C4;
	sub_828C1A20(ctx, base);
	// 828C08C4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C08C8: 419A00C8  beq cr6, 0x828c0990
	if ctx.cr[6].eq {
	pc = 0x828C0990; continue 'dispatch;
	}
	// 828C08CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C08D0: 3BAB0B7C  addi r29, r11, 0xb7c
	ctx.r[29].s64 = ctx.r[11].s64 + 2940;
	pc = 0x828C08D4; continue 'dispatch;
            }
            0x828C08D4 => {
    //   block [0x828C08D4..0x828C091C)
	// 828C08D4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C08D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C08DC: 419A0054  beq cr6, 0x828c0930
	if ctx.cr[6].eq {
	pc = 0x828C0930; continue 'dispatch;
	}
	// 828C08E0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C08E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C08E8: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C08EC: 7F2A482E  lwzx r25, r10, r9
	ctx.r[25].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 828C08F0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828C08F4: 93B90000  stw r29, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C08F8: 4B8D3541  bl 0x82193e38
	ctx.lr = 0x828C08FC;
	sub_82193E38(ctx, base);
	// 828C08FC: 93D90004  stw r30, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C0900: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0904: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C0908: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C090C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C0910: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828C0914: 41990008  bgt cr6, 0x828c091c
	if ctx.cr[6].gt {
	pc = 0x828C091C; continue 'dispatch;
	}
	// 828C0918: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	pc = 0x828C091C; continue 'dispatch;
            }
            0x828C091C => {
    //   block [0x828C091C..0x828C0930)
	// 828C091C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C0920: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0924: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828C0928: 40820008  bne 0x828c0930
	if !ctx.cr[0].eq {
	pc = 0x828C0930; continue 'dispatch;
	}
	// 828C092C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	pc = 0x828C0930; continue 'dispatch;
            }
            0x828C0930 => {
    //   block [0x828C0930..0x828C093C)
	// 828C0930: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828C0934: 4082FFA0  bne 0x828c08d4
	if !ctx.cr[0].eq {
	pc = 0x828C08D4; continue 'dispatch;
	}
	// 828C0938: 48000058  b 0x828c0990
	pc = 0x828C0990; continue 'dispatch;
            }
            0x828C093C => {
    //   block [0x828C093C..0x828C0950)
	// 828C093C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 828C0940: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C0944: 91210078  stw r9, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 828C0948: 40990008  ble cr6, 0x828c0950
	if !ctx.cr[6].gt {
	pc = 0x828C0950; continue 'dispatch;
	}
	// 828C094C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C0950; continue 'dispatch;
            }
            0x828C0950 => {
    //   block [0x828C0950..0x828C0980)
	// 828C0950: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 828C0954: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 828C0958: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828C095C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828C0960: 91010068  stw r8, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 828C0964: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C0968: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C096C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C0970: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C0974: 4800118D  bl 0x828c1b00
	ctx.lr = 0x828C0978;
	sub_828C1B00(ctx, base);
	// 828C0978: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C097C: 419A0014  beq cr6, 0x828c0990
	if ctx.cr[6].eq {
	pc = 0x828C0990; continue 'dispatch;
	}
	pc = 0x828C0980; continue 'dispatch;
            }
            0x828C0980 => {
    //   block [0x828C0980..0x828C0990)
	// 828C0980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C0984: 4BFFFDC5  bl 0x828c0748
	ctx.lr = 0x828C0988;
	sub_828C0748(ctx, base);
	// 828C0988: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828C098C: 4082FFF4  bne 0x828c0980
	if !ctx.cr[0].eq {
	pc = 0x828C0980; continue 'dispatch;
	}
	pc = 0x828C0990; continue 'dispatch;
            }
            0x828C0990 => {
    //   block [0x828C0990..0x828C09A8)
	// 828C0990: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C0994: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C0998: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C099C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C09A0: 40990008  ble cr6, 0x828c09a8
	if !ctx.cr[6].gt {
	pc = 0x828C09A8; continue 'dispatch;
	}
	// 828C09A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C09A8; continue 'dispatch;
            }
            0x828C09A8 => {
    //   block [0x828C09A8..0x828C09C8)
	// 828C09A8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C09AC: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828C09B0: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C09B4: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 828C09B8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C09BC: 4199000C  bgt cr6, 0x828c09c8
	if ctx.cr[6].gt {
	pc = 0x828C09C8; continue 'dispatch;
	}
	// 828C09C0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C09C4: 40980008  bge cr6, 0x828c09cc
	if !ctx.cr[6].lt {
	pc = 0x828C09CC; continue 'dispatch;
	}
	pc = 0x828C09C8; continue 'dispatch;
            }
            0x828C09C8 => {
    //   block [0x828C09C8..0x828C09CC)
	// 828C09C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C09CC; continue 'dispatch;
            }
            0x828C09CC => {
    //   block [0x828C09CC..0x828C09E4)
	// 828C09CC: 93FA0004  stw r31, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C09D0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C09D4: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C09D8: 93DA0000  stw r30, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C09DC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828C09E0: 483E8A6C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C09E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C09E8 size=608
    let mut pc: u32 = 0x828C09E8;
    'dispatch: loop {
        match pc {
            0x828C09E8 => {
    //   block [0x828C09E8..0x828C0A68)
	// 828C09E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C09EC: 483E8A11  bl 0x82ca93fc
	ctx.lr = 0x828C09F0;
	sub_82CA93D0(ctx, base);
	// 828C09F0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C09F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C09F8: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 828C09FC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828C0A00: 617F5555  ori r31, r11, 0x5555
	ctx.r[31].u64 = ctx.r[11].u64 | 21845;
	// 828C0A04: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 828C0A08: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0A0C: 7D2AF850  subf r9, r10, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 828C0A10: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828C0A14: 40980064  bge cr6, 0x828c0a78
	if !ctx.cr[6].lt {
	pc = 0x828C0A78; continue 'dispatch;
	}
	// 828C0A18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C0A1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C0A20: 388B2DA8  addi r4, r11, 0x2da8
	ctx.r[4].s64 = ctx.r[11].s64 + 11688;
	// 828C0A24: 4BA3151D  bl 0x822f1f40
	ctx.lr = 0x828C0A28;
	sub_822F1F40(ctx, base);
	// 828C0A28: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C0A2C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C0A30: 4BA31381  bl 0x822f1db0
	ctx.lr = 0x828C0A34;
	sub_822F1DB0(ctx, base);
	// 828C0A34: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828C0A38: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C0A3C: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 828C0A40: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 828C0A44: 4BA313DD  bl 0x822f1e20
	ctx.lr = 0x828C0A48;
	sub_822F1E20(ctx, base);
	// 828C0A48: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 828C0A4C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C0A50: 4BDBAD91  bl 0x8267b7e0
	ctx.lr = 0x828C0A54;
	sub_8267B7E0(ctx, base);
	// 828C0A54: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C0A58: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 828C0A5C: 4198000C  blt cr6, 0x828c0a68
	if ctx.cr[6].lt {
	pc = 0x828C0A68; continue 'dispatch;
	}
	// 828C0A60: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C0A64: 4B95B2D5  bl 0x8221bd38
	ctx.lr = 0x828C0A68;
	sub_8221BD38(ctx, base);
	pc = 0x828C0A68; continue 'dispatch;
            }
            0x828C0A68 => {
    //   block [0x828C0A68..0x828C0A78)
	// 828C0A68: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 828C0A6C: 93210074  stw r25, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 828C0A70: 9B210064  stb r25, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u8 ) };
	// 828C0A74: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	pc = 0x828C0A78; continue 'dispatch;
            }
            0x828C0A78 => {
    //   block [0x828C0A78..0x828C0A90)
	// 828C0A78: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0A7C: 554BF87E  srwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C0A80: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 828C0A84: 4098000C  bge cr6, 0x828c0a90
	if !ctx.cr[6].lt {
	pc = 0x828C0A90; continue 'dispatch;
	}
	// 828C0A88: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 828C0A8C: 4800000C  b 0x828c0a98
	pc = 0x828C0A98; continue 'dispatch;
            }
            0x828C0A90 => {
    //   block [0x828C0A90..0x828C0A98)
	// 828C0A90: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828C0A94: 40990014  ble cr6, 0x828c0aa8
	if !ctx.cr[6].gt {
	pc = 0x828C0AA8; continue 'dispatch;
	}
	pc = 0x828C0A98; continue 'dispatch;
            }
            0x828C0A98 => {
    //   block [0x828C0A98..0x828C0AA8)
	// 828C0A98: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 828C0A9C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C0AA0: 41990008  bgt cr6, 0x828c0aa8
	if ctx.cr[6].gt {
	pc = 0x828C0AA8; continue 'dispatch;
	}
	// 828C0AA4: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	pc = 0x828C0AA8; continue 'dispatch;
            }
            0x828C0AA8 => {
    //   block [0x828C0AA8..0x828C0ABC)
	// 828C0AA8: 83DD000C  lwz r30, 0xc(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C0AAC: 7FEAD215  add. r31, r10, r26
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828C0AB0: 4082000C  bne 0x828c0abc
	if !ctx.cr[0].eq {
	pc = 0x828C0ABC; continue 'dispatch;
	}
	// 828C0AB4: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 828C0AB8: 48000038  b 0x828c0af0
	pc = 0x828C0AF0; continue 'dispatch;
            }
            0x828C0ABC => {
    //   block [0x828C0ABC..0x828C0AF0)
	// 828C0ABC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 828C0AC0: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 828C0AC4: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 828C0AC8: 40980028  bge cr6, 0x828c0af0
	if !ctx.cr[6].lt {
	pc = 0x828C0AF0; continue 'dispatch;
	}
	// 828C0ACC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C0AD0: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 828C0AD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0AD8: 394B1714  addi r10, r11, 0x1714
	ctx.r[10].s64 = ctx.r[11].s64 + 5908;
	// 828C0ADC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C0AE0: 4BA31341  bl 0x822f1e20
	ctx.lr = 0x828C0AE4;
	sub_822F1E20(ctx, base);
	// 828C0AE4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828C0AE8: 39091708  addi r8, r9, 0x1708
	ctx.r[8].s64 = ctx.r[9].s64 + 5896;
	// 828C0AEC: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	pc = 0x828C0AF0; continue 'dispatch;
            }
            0x828C0AF0 => {
    //   block [0x828C0AF0..0x828C0B34)
	// 828C0AF0: 57E3103A  slwi r3, r31, 2
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828C0AF4: 4B95E765  bl 0x8221f258
	ctx.lr = 0x828C0AF8;
	sub_8221F258(ctx, base);
	// 828C0AF8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0AFC: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0B00: 57DF103A  slwi r31, r30, 2
	ctx.r[31].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828C0B04: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C0B08: 7CBF5A14  add r5, r31, r11
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828C0B0C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C0B10: 7C7FDA14  add r3, r31, r27
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[27].u64;
	// 828C0B14: 7D454850  subf r10, r5, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[5].s64;
	// 828C0B18: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C0B1C: 7D0B1671  srawi. r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0B20: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828C0B24: 7F861A14  add r28, r6, r3
	ctx.r[28].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 828C0B28: 4182000C  beq 0x828c0b34
	if ctx.cr[0].eq {
	pc = 0x828C0B34; continue 'dispatch;
	}
	// 828C0B2C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 828C0B30: 483E94F9  bl 0x82caa028
	ctx.lr = 0x828C0B34;
	sub_82CAA028(ctx, base);
	pc = 0x828C0B34; continue 'dispatch;
            }
            0x828C0B34 => {
    //   block [0x828C0B34..0x828C0B64)
	// 828C0B34: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0B38: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828C0B3C: 41990074  bgt cr6, 0x828c0bb0
	if ctx.cr[6].gt {
	pc = 0x828C0BB0; continue 'dispatch;
	}
	// 828C0B40: 7D65F850  subf r11, r5, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 828C0B44: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 828C0B48: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0B4C: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828C0B50: 7FE6E214  add r31, r6, r28
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[28].u64;
	// 828C0B54: 41820010  beq 0x828c0b64
	if ctx.cr[0].eq {
	pc = 0x828C0B64; continue 'dispatch;
	}
	// 828C0B58: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 828C0B5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C0B60: 483E94C9  bl 0x82caa028
	ctx.lr = 0x828C0B64;
	sub_82CAA028(ctx, base);
	pc = 0x828C0B64; continue 'dispatch;
            }
            0x828C0B64 => {
    //   block [0x828C0B64..0x828C0B80)
	// 828C0B64: 7D5ED051  subf. r10, r30, r26
	ctx.r[10].s64 = ctx.r[26].s64 - ctx.r[30].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C0B68: 41820024  beq 0x828c0b8c
	if ctx.cr[0].eq {
	pc = 0x828C0B8C; continue 'dispatch;
	}
	// 828C0B6C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828C0B70: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 828C0B74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C0B78: 419A0014  beq cr6, 0x828c0b8c
	if ctx.cr[6].eq {
	pc = 0x828C0B8C; continue 'dispatch;
	}
	// 828C0B7C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x828C0B80; continue 'dispatch;
            }
            0x828C0B80 => {
    //   block [0x828C0B80..0x828C0B8C)
	// 828C0B80: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C0B84: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C0B88: 4200FFF8  bdnz 0x828c0b80
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828C0B80; continue 'dispatch;
	}
	pc = 0x828C0B8C; continue 'dispatch;
            }
            0x828C0B8C => {
    //   block [0x828C0B8C..0x828C0BA0)
	// 828C0B8C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C0B90: 419A0090  beq cr6, 0x828c0c20
	if ctx.cr[6].eq {
	pc = 0x828C0C20; continue 'dispatch;
	}
	// 828C0B94: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828C0B98: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 828C0B9C: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	pc = 0x828C0BA0; continue 'dispatch;
            }
            0x828C0BA0 => {
    //   block [0x828C0BA0..0x828C0BB0)
	// 828C0BA0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C0BA4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C0BA8: 4200FFF8  bdnz 0x828c0ba0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828C0BA0; continue 'dispatch;
	}
	// 828C0BAC: 48000074  b 0x828c0c20
	pc = 0x828C0C20; continue 'dispatch;
            }
            0x828C0BB0 => {
    //   block [0x828C0BB0..0x828C0BD4)
	// 828C0BB0: 575E103A  slwi r30, r26, 2
	ctx.r[30].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 828C0BB4: 7D65F050  subf r11, r5, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 828C0BB8: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 828C0BBC: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0BC0: 41820014  beq 0x828c0bd4
	if ctx.cr[0].eq {
	pc = 0x828C0BD4; continue 'dispatch;
	}
	// 828C0BC4: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828C0BC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C0BCC: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828C0BD0: 483E9459  bl 0x82caa028
	ctx.lr = 0x828C0BD4;
	sub_82CAA028(ctx, base);
	pc = 0x828C0BD4; continue 'dispatch;
            }
            0x828C0BD4 => {
    //   block [0x828C0BD4..0x828C0C00)
	// 828C0BD4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0BD8: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 828C0BDC: 7D45F850  subf r10, r5, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 828C0BE0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C0BE4: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0BE8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828C0BEC: 7FE6DA14  add r31, r6, r27
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[27].u64;
	// 828C0BF0: 41820010  beq 0x828c0c00
	if ctx.cr[0].eq {
	pc = 0x828C0C00; continue 'dispatch;
	}
	// 828C0BF4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 828C0BF8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C0BFC: 483E942D  bl 0x82caa028
	ctx.lr = 0x828C0C00;
	sub_82CAA028(ctx, base);
	pc = 0x828C0C00; continue 'dispatch;
            }
            0x828C0C00 => {
    //   block [0x828C0C00..0x828C0C14)
	// 828C0C00: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828C0C04: 419A001C  beq cr6, 0x828c0c20
	if ctx.cr[6].eq {
	pc = 0x828C0C20; continue 'dispatch;
	}
	// 828C0C08: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828C0C0C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 828C0C10: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	pc = 0x828C0C14; continue 'dispatch;
            }
            0x828C0C14 => {
    //   block [0x828C0C14..0x828C0C20)
	// 828C0C14: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C0C18: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C0C1C: 4200FFF8  bdnz 0x828c0c14
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828C0C14; continue 'dispatch;
	}
	pc = 0x828C0C20; continue 'dispatch;
            }
            0x828C0C20 => {
    //   block [0x828C0C20..0x828C0C30)
	// 828C0C20: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0C24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C0C28: 419A0008  beq cr6, 0x828c0c30
	if ctx.cr[6].eq {
	pc = 0x828C0C30; continue 'dispatch;
	}
	// 828C0C2C: 4B95B10D  bl 0x8221bd38
	ctx.lr = 0x828C0C30;
	sub_8221BD38(ctx, base);
	pc = 0x828C0C30; continue 'dispatch;
            }
            0x828C0C30 => {
    //   block [0x828C0C30..0x828C0C48)
	// 828C0C30: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0C34: 937D0004  stw r27, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828C0C38: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 828C0C3C: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C0C40: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828C0C44: 483E8808  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C0C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C0C48 size=584
    let mut pc: u32 = 0x828C0C48;
    'dispatch: loop {
        match pc {
            0x828C0C48 => {
    //   block [0x828C0C48..0x828C0C70)
	// 828C0C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C0C4C: 483E87B5  bl 0x82ca9400
	ctx.lr = 0x828C0C50;
	sub_82CA93D0(ctx, base);
	// 828C0C50: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C0C54: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0C58: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C0C5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C0C60: 409A0010  bne cr6, 0x828c0c70
	if !ctx.cr[6].eq {
	pc = 0x828C0C70; continue 'dispatch;
	}
	// 828C0C64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C0C68: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828C0C6C: 48000008  b 0x828c0c74
	pc = 0x828C0C74; continue 'dispatch;
            }
            0x828C0C70 => {
    //   block [0x828C0C70..0x828C0C74)
	// 828C0C70: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C0C74; continue 'dispatch;
            }
            0x828C0C74 => {
    //   block [0x828C0C74..0x828C0CEC)
	// 828C0C74: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0C78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C0C7C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0C80: 4BB0D941  bl 0x823ce5c0
	ctx.lr = 0x828C0C84;
	sub_823CE5C0(ctx, base);
	// 828C0C84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C0C88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0C8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0C90: 4BB0D571  bl 0x823ce200
	ctx.lr = 0x828C0C94;
	sub_823CE200(ctx, base);
	// 828C0C94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C0C98: 4B8F6E81  bl 0x821b7b18
	ctx.lr = 0x828C0C9C;
	sub_821B7B18(ctx, base);
	// 828C0C9C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828C0CA0: 4B95E5B9  bl 0x8221f258
	ctx.lr = 0x828C0CA4;
	sub_8221F258(ctx, base);
	// 828C0CA4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C0CA8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C0CAC: 419A0040  beq cr6, 0x828c0cec
	if ctx.cr[6].eq {
	pc = 0x828C0CEC; continue 'dispatch;
	}
	// 828C0CB0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828C0CB4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C0CB8: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828C0CBC: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C0CC0: 4B95E599  bl 0x8221f258
	ctx.lr = 0x828C0CC4;
	sub_8221F258(ctx, base);
	// 828C0CC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C0CC8: 419A0028  beq cr6, 0x828c0cf0
	if ctx.cr[6].eq {
	pc = 0x828C0CF0; continue 'dispatch;
	}
	// 828C0CCC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C0CD0: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828C0CD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C0CD8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C0CDC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C0CE0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C0CE4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C0CE8: 4800000C  b 0x828c0cf4
	pc = 0x828C0CF4; continue 'dispatch;
            }
            0x828C0CEC => {
    //   block [0x828C0CEC..0x828C0CF0)
	// 828C0CEC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828C0CF0; continue 'dispatch;
            }
            0x828C0CF0 => {
    //   block [0x828C0CF0..0x828C0CF4)
	// 828C0CF0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828C0CF4; continue 'dispatch;
            }
            0x828C0CF4 => {
    //   block [0x828C0CF4..0x828C0DF8)
	// 828C0CF4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C0CF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C0CFC: 419A00FC  beq cr6, 0x828c0df8
	if ctx.cr[6].eq {
	pc = 0x828C0DF8; continue 'dispatch;
	}
	// 828C0D00: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0D04: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C0D08: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0D0C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C0D10: 4B9683F9  bl 0x82229108
	ctx.lr = 0x828C0D14;
	sub_82229108(ctx, base);
	// 828C0D14: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C0D18: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C0D1C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C0D20: 3BCB1BD8  addi r30, r11, 0x1bd8
	ctx.r[30].s64 = ctx.r[11].s64 + 7128;
	// 828C0D24: 4B966B5D  bl 0x82227880
	ctx.lr = 0x828C0D28;
	sub_82227880(ctx, base);
	// 828C0D28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C0D2C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828C0D30: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C0D34: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828C0D38: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C0D3C: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C0D40: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C0D44: 4B8D9D3D  bl 0x8219aa80
	ctx.lr = 0x828C0D48;
	sub_8219AA80(ctx, base);
	// 828C0D48: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828C0D4C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828C0D50: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828C0D54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0D58: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C0D5C: 4BB0D6C5  bl 0x823ce420
	ctx.lr = 0x828C0D60;
	sub_823CE420(ctx, base);
	// 828C0D60: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C0D64: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C0D68: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C0D6C: 4816395D  bl 0x82a246c8
	ctx.lr = 0x828C0D70;
	sub_82A246C8(ctx, base);
	// 828C0D70: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0D74: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C0D78: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828C0D7C: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828C0D80: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0D84: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0D88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C0D8C: 4B96837D  bl 0x82229108
	ctx.lr = 0x828C0D90;
	sub_82229108(ctx, base);
	// 828C0D90: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 828C0D94: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C0D98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C0D9C: 3BEB6D48  addi r31, r11, 0x6d48
	ctx.r[31].s64 = ctx.r[11].s64 + 27976;
	// 828C0DA0: 4B966AE1  bl 0x82227880
	ctx.lr = 0x828C0DA4;
	sub_82227880(ctx, base);
	// 828C0DA4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828C0DA8: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828C0DAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C0DB0: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828C0DB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C0DB8: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C0DBC: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C0DC0: 4B8D9CC1  bl 0x8219aa80
	ctx.lr = 0x828C0DC4;
	sub_8219AA80(ctx, base);
	// 828C0DC4: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828C0DC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0DCC: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828C0DD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0DD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0DD8: 4BB0D649  bl 0x823ce420
	ctx.lr = 0x828C0DDC;
	sub_823CE420(ctx, base);
	// 828C0DDC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0DE0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C0DE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C0DE8: 481638E1  bl 0x82a246c8
	ctx.lr = 0x828C0DEC;
	sub_82A246C8(ctx, base);
	// 828C0DEC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0DF0: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828C0DF4: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x828C0DF8; continue 'dispatch;
            }
            0x828C0DF8 => {
    //   block [0x828C0DF8..0x828C0E08)
	// 828C0DF8: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828C0DFC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C0E00: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828C0E04: 419A0020  beq cr6, 0x828c0e24
	if ctx.cr[6].eq {
	pc = 0x828C0E24; continue 'dispatch;
	}
	pc = 0x828C0E08; continue 'dispatch;
            }
            0x828C0E08 => {
    //   block [0x828C0E08..0x828C0E24)
	// 828C0E08: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C0E0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C0E10: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C0E14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C0E18: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C0E1C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C0E20: 4082FFE8  bne 0x828c0e08
	if !ctx.cr[0].eq {
	pc = 0x828C0E08; continue 'dispatch;
	}
	pc = 0x828C0E24; continue 'dispatch;
            }
            0x828C0E24 => {
    //   block [0x828C0E24..0x828C0E44)
	// 828C0E24: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0E28: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C0E2C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C0E30: 4BA34B19  bl 0x822f5948
	ctx.lr = 0x828C0E34;
	sub_822F5948(ctx, base);
	// 828C0E34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C0E38: 4B8F6CE1  bl 0x821b7b18
	ctx.lr = 0x828C0E3C;
	sub_821B7B18(ctx, base);
	// 828C0E3C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C0E40: 419A0040  beq cr6, 0x828c0e80
	if ctx.cr[6].eq {
	pc = 0x828C0E80; continue 'dispatch;
	}
	pc = 0x828C0E44; continue 'dispatch;
            }
            0x828C0E44 => {
    //   block [0x828C0E44..0x828C0E80)
	// 828C0E44: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C0E48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C0E4C: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C0E50: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C0E54: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C0E58: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C0E5C: 4082FFE8  bne 0x828c0e44
	if !ctx.cr[0].eq {
	pc = 0x828C0E44; continue 'dispatch;
	}
	// 828C0E60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C0E64: 409A001C  bne cr6, 0x828c0e80
	if !ctx.cr[6].eq {
	pc = 0x828C0E80; continue 'dispatch;
	}
	// 828C0E68: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0E6C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0E70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C0E74: 4E800421  bctrl
	ctx.lr = 0x828C0E78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C0E78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C0E7C: 4B95AEBD  bl 0x8221bd38
	ctx.lr = 0x828C0E80;
	sub_8221BD38(ctx, base);
            }
            0x828C0E80 => {
    //   block [0x828C0E80..0x828C0E90)
	// 828C0E80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0E84: 4B8F6C95  bl 0x821b7b18
	ctx.lr = 0x828C0E88;
	sub_821B7B18(ctx, base);
	// 828C0E88: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C0E8C: 483E85C4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C0E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C0E90 size=444
    let mut pc: u32 = 0x828C0E90;
    'dispatch: loop {
        match pc {
            0x828C0E90 => {
    //   block [0x828C0E90..0x828C0EC8)
	// 828C0E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C0E94: 483E8569  bl 0x82ca93fc
	ctx.lr = 0x828C0E98;
	sub_82CA93D0(ctx, base);
	// 828C0E98: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C0E9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C0EA0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C0EA4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C0EA8: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828C0EAC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C0EB0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0EB4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C0EB8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C0EBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C0EC0: 419A0008  beq cr6, 0x828c0ec8
	if ctx.cr[6].eq {
	pc = 0x828C0EC8; continue 'dispatch;
	}
	// 828C0EC4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C0EC8; continue 'dispatch;
            }
            0x828C0EC8 => {
    //   block [0x828C0EC8..0x828C0F2C)
	// 828C0EC8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0ECC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C0ED0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0ED4: 4BB0D6ED  bl 0x823ce5c0
	ctx.lr = 0x828C0ED8;
	sub_823CE5C0(ctx, base);
	// 828C0ED8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C0EDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C0EE0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0EE4: 4BB0D22D  bl 0x823ce110
	ctx.lr = 0x828C0EE8;
	sub_823CE110(ctx, base);
	// 828C0EE8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C0EEC: 4B8F6C2D  bl 0x821b7b18
	ctx.lr = 0x828C0EF0;
	sub_821B7B18(ctx, base);
	// 828C0EF0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C0EF4: 4B95E365  bl 0x8221f258
	ctx.lr = 0x828C0EF8;
	sub_8221F258(ctx, base);
	// 828C0EF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C0EFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C0F00: 419A002C  beq cr6, 0x828c0f2c
	if ctx.cr[6].eq {
	pc = 0x828C0F2C; continue 'dispatch;
	}
	// 828C0F04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C0F08: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828C0F0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C0F10: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C0F14: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C0F18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C0F1C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C0F20: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C0F24: 4B92F31D  bl 0x821f0240
	ctx.lr = 0x828C0F28;
	sub_821F0240(ctx, base);
	// 828C0F28: 48000008  b 0x828c0f30
	pc = 0x828C0F30; continue 'dispatch;
            }
            0x828C0F2C => {
    //   block [0x828C0F2C..0x828C0F30)
	// 828C0F2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x828C0F30; continue 'dispatch;
            }
            0x828C0F30 => {
    //   block [0x828C0F30..0x828C0F54)
	// 828C0F30: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 828C0F34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C0F38: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828C0F3C: 419A0018  beq cr6, 0x828c0f54
	if ctx.cr[6].eq {
	pc = 0x828C0F54; continue 'dispatch;
	}
	// 828C0F40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C0F44: 48143D7D  bl 0x82a04cc0
	ctx.lr = 0x828C0F48;
	sub_82A04CC0(ctx, base);
	// 828C0F48: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C0F4C: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C0F50: 4800000C  b 0x828c0f5c
	pc = 0x828C0F5C; continue 'dispatch;
            }
            0x828C0F54 => {
    //   block [0x828C0F54..0x828C0F5C)
	// 828C0F54: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C0F58: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	pc = 0x828C0F5C; continue 'dispatch;
            }
            0x828C0F5C => {
    //   block [0x828C0F5C..0x828C0F70)
	// 828C0F5C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0F60: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C0F64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C0F68: 419A0008  beq cr6, 0x828c0f70
	if ctx.cr[6].eq {
	pc = 0x828C0F70; continue 'dispatch;
	}
	// 828C0F6C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C0F70; continue 'dispatch;
            }
            0x828C0F70 => {
    //   block [0x828C0F70..0x828C0FF0)
	// 828C0F70: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828C0F74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C0F78: 419A0078  beq cr6, 0x828c0ff0
	if ctx.cr[6].eq {
	pc = 0x828C0FF0; continue 'dispatch;
	}
	// 828C0F7C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C0F80: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C0F84: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C0F88: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C0F8C: 4B96817D  bl 0x82229108
	ctx.lr = 0x828C0F90;
	sub_82229108(ctx, base);
	// 828C0F90: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C0F94: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C0F98: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C0F9C: 3BCB1DA8  addi r30, r11, 0x1da8
	ctx.r[30].s64 = ctx.r[11].s64 + 7592;
	// 828C0FA0: 4B9668E1  bl 0x82227880
	ctx.lr = 0x828C0FA4;
	sub_82227880(ctx, base);
	// 828C0FA4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C0FA8: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 828C0FAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C0FB0: 388A4F40  addi r4, r10, 0x4f40
	ctx.r[4].s64 = ctx.r[10].s64 + 20288;
	// 828C0FB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C0FB8: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C0FBC: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C0FC0: 4B8D9AC1  bl 0x8219aa80
	ctx.lr = 0x828C0FC4;
	sub_8219AA80(ctx, base);
	// 828C0FC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0FC8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C0FCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C0FD0: 4BB0D451  bl 0x823ce420
	ctx.lr = 0x828C0FD4;
	sub_823CE420(ctx, base);
	// 828C0FD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C0FD8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C0FDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C0FE0: 481636E9  bl 0x82a246c8
	ctx.lr = 0x828C0FE4;
	sub_82A246C8(ctx, base);
	// 828C0FE4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C0FE8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C0FEC: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828C0FF0; continue 'dispatch;
            }
            0x828C0FF0 => {
    //   block [0x828C0FF0..0x828C1000)
	// 828C0FF0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828C0FF4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C0FF8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828C0FFC: 419A0020  beq cr6, 0x828c101c
	if ctx.cr[6].eq {
	pc = 0x828C101C; continue 'dispatch;
	}
	pc = 0x828C1000; continue 'dispatch;
            }
            0x828C1000 => {
    //   block [0x828C1000..0x828C101C)
	// 828C1000: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C1004: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C1008: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C100C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C1010: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C1014: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C1018: 4082FFE8  bne 0x828c1000
	if !ctx.cr[0].eq {
	pc = 0x828C1000; continue 'dispatch;
	}
	pc = 0x828C101C; continue 'dispatch;
            }
            0x828C101C => {
    //   block [0x828C101C..0x828C104C)
	// 828C101C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1020: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C1024: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C1028: 4BA34921  bl 0x822f5948
	ctx.lr = 0x828C102C;
	sub_822F5948(ctx, base);
	// 828C102C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1030: 4B8F6AE9  bl 0x821b7b18
	ctx.lr = 0x828C1034;
	sub_821B7B18(ctx, base);
	// 828C1034: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C1038: 4B8F6AE1  bl 0x821b7b18
	ctx.lr = 0x828C103C;
	sub_821B7B18(ctx, base);
	// 828C103C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1040: 4B8F6AD9  bl 0x821b7b18
	ctx.lr = 0x828C1044;
	sub_821B7B18(ctx, base);
	// 828C1044: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C1048: 483E8404  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1050 size=444
    let mut pc: u32 = 0x828C1050;
    'dispatch: loop {
        match pc {
            0x828C1050 => {
    //   block [0x828C1050..0x828C1088)
	// 828C1050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1054: 483E83A9  bl 0x82ca93fc
	ctx.lr = 0x828C1058;
	sub_82CA93D0(ctx, base);
	// 828C1058: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C105C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C1060: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C1064: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C1068: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828C106C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C1070: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1074: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C1078: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C107C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1080: 419A0008  beq cr6, 0x828c1088
	if ctx.cr[6].eq {
	pc = 0x828C1088; continue 'dispatch;
	}
	// 828C1084: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C1088; continue 'dispatch;
            }
            0x828C1088 => {
    //   block [0x828C1088..0x828C10EC)
	// 828C1088: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C108C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C1090: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1094: 4BB0D52D  bl 0x823ce5c0
	ctx.lr = 0x828C1098;
	sub_823CE5C0(ctx, base);
	// 828C1098: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C109C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C10A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C10A4: 4BB0D06D  bl 0x823ce110
	ctx.lr = 0x828C10A8;
	sub_823CE110(ctx, base);
	// 828C10A8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C10AC: 4B8F6A6D  bl 0x821b7b18
	ctx.lr = 0x828C10B0;
	sub_821B7B18(ctx, base);
	// 828C10B0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C10B4: 4B95E1A5  bl 0x8221f258
	ctx.lr = 0x828C10B8;
	sub_8221F258(ctx, base);
	// 828C10B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C10BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C10C0: 419A002C  beq cr6, 0x828c10ec
	if ctx.cr[6].eq {
	pc = 0x828C10EC; continue 'dispatch;
	}
	// 828C10C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C10C8: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828C10CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C10D0: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C10D4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C10D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C10DC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C10E0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C10E4: 4B92F15D  bl 0x821f0240
	ctx.lr = 0x828C10E8;
	sub_821F0240(ctx, base);
	// 828C10E8: 48000008  b 0x828c10f0
	pc = 0x828C10F0; continue 'dispatch;
            }
            0x828C10EC => {
    //   block [0x828C10EC..0x828C10F0)
	// 828C10EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x828C10F0; continue 'dispatch;
            }
            0x828C10F0 => {
    //   block [0x828C10F0..0x828C1114)
	// 828C10F0: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 828C10F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C10F8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828C10FC: 419A0018  beq cr6, 0x828c1114
	if ctx.cr[6].eq {
	pc = 0x828C1114; continue 'dispatch;
	}
	// 828C1100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C1104: 48143BBD  bl 0x82a04cc0
	ctx.lr = 0x828C1108;
	sub_82A04CC0(ctx, base);
	// 828C1108: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C110C: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C1110: 4800000C  b 0x828c111c
	pc = 0x828C111C; continue 'dispatch;
            }
            0x828C1114 => {
    //   block [0x828C1114..0x828C111C)
	// 828C1114: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C1118: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	pc = 0x828C111C; continue 'dispatch;
            }
            0x828C111C => {
    //   block [0x828C111C..0x828C1130)
	// 828C111C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1120: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C1124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1128: 419A0008  beq cr6, 0x828c1130
	if ctx.cr[6].eq {
	pc = 0x828C1130; continue 'dispatch;
	}
	// 828C112C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C1130; continue 'dispatch;
            }
            0x828C1130 => {
    //   block [0x828C1130..0x828C11B0)
	// 828C1130: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828C1134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1138: 419A0078  beq cr6, 0x828c11b0
	if ctx.cr[6].eq {
	pc = 0x828C11B0; continue 'dispatch;
	}
	// 828C113C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1140: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C1144: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1148: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C114C: 4B967FBD  bl 0x82229108
	ctx.lr = 0x828C1150;
	sub_82229108(ctx, base);
	// 828C1150: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C1154: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C1158: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C115C: 3BCB1C18  addi r30, r11, 0x1c18
	ctx.r[30].s64 = ctx.r[11].s64 + 7192;
	// 828C1160: 4B966721  bl 0x82227880
	ctx.lr = 0x828C1164;
	sub_82227880(ctx, base);
	// 828C1164: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C1168: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 828C116C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C1170: 388A4F40  addi r4, r10, 0x4f40
	ctx.r[4].s64 = ctx.r[10].s64 + 20288;
	// 828C1174: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1178: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C117C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C1180: 4B8D9901  bl 0x8219aa80
	ctx.lr = 0x828C1184;
	sub_8219AA80(ctx, base);
	// 828C1184: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1188: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C118C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1190: 4BB0D291  bl 0x823ce420
	ctx.lr = 0x828C1194;
	sub_823CE420(ctx, base);
	// 828C1194: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1198: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C119C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C11A0: 48163529  bl 0x82a246c8
	ctx.lr = 0x828C11A4;
	sub_82A246C8(ctx, base);
	// 828C11A4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C11A8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C11AC: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828C11B0; continue 'dispatch;
            }
            0x828C11B0 => {
    //   block [0x828C11B0..0x828C11C0)
	// 828C11B0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828C11B4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C11B8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828C11BC: 419A0020  beq cr6, 0x828c11dc
	if ctx.cr[6].eq {
	pc = 0x828C11DC; continue 'dispatch;
	}
	pc = 0x828C11C0; continue 'dispatch;
            }
            0x828C11C0 => {
    //   block [0x828C11C0..0x828C11DC)
	// 828C11C0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C11C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C11C8: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C11CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C11D0: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C11D4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C11D8: 4082FFE8  bne 0x828c11c0
	if !ctx.cr[0].eq {
	pc = 0x828C11C0; continue 'dispatch;
	}
	pc = 0x828C11DC; continue 'dispatch;
            }
            0x828C11DC => {
    //   block [0x828C11DC..0x828C120C)
	// 828C11DC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C11E0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C11E4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C11E8: 4BA34761  bl 0x822f5948
	ctx.lr = 0x828C11EC;
	sub_822F5948(ctx, base);
	// 828C11EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C11F0: 4B8F6929  bl 0x821b7b18
	ctx.lr = 0x828C11F4;
	sub_821B7B18(ctx, base);
	// 828C11F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C11F8: 4B8F6921  bl 0x821b7b18
	ctx.lr = 0x828C11FC;
	sub_821B7B18(ctx, base);
	// 828C11FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1200: 4B8F6919  bl 0x821b7b18
	ctx.lr = 0x828C1204;
	sub_821B7B18(ctx, base);
	// 828C1204: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C1208: 483E8244  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1210 size=512
    let mut pc: u32 = 0x828C1210;
    'dispatch: loop {
        match pc {
            0x828C1210 => {
    //   block [0x828C1210..0x828C1248)
	// 828C1210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1214: 483E81E9  bl 0x82ca93fc
	ctx.lr = 0x828C1218;
	sub_82CA93D0(ctx, base);
	// 828C1218: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C121C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C1220: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C1224: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C1228: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828C122C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C1230: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1234: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C1238: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C123C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1240: 419A0008  beq cr6, 0x828c1248
	if ctx.cr[6].eq {
	pc = 0x828C1248; continue 'dispatch;
	}
	// 828C1244: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C1248; continue 'dispatch;
            }
            0x828C1248 => {
    //   block [0x828C1248..0x828C12DC)
	// 828C1248: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C124C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1250: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1254: 4BB0D36D  bl 0x823ce5c0
	ctx.lr = 0x828C1258;
	sub_823CE5C0(ctx, base);
	// 828C1258: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C125C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1260: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1264: 4BB0CEAD  bl 0x823ce110
	ctx.lr = 0x828C1268;
	sub_823CE110(ctx, base);
	// 828C1268: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C126C: 4B8F68AD  bl 0x821b7b18
	ctx.lr = 0x828C1270;
	sub_821B7B18(ctx, base);
	// 828C1270: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C1274: 4B95DFE5  bl 0x8221f258
	ctx.lr = 0x828C1278;
	sub_8221F258(ctx, base);
	// 828C1278: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C127C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C1280: 419A005C  beq cr6, 0x828c12dc
	if ctx.cr[6].eq {
	pc = 0x828C12DC; continue 'dispatch;
	}
	// 828C1284: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C1288: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828C128C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C1290: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C1294: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C1298: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C129C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C12A0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C12A4: 4B92EF9D  bl 0x821f0240
	ctx.lr = 0x828C12A8;
	sub_821F0240(ctx, base);
	// 828C12A8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C12AC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C12B0: 4B95DFA9  bl 0x8221f258
	ctx.lr = 0x828C12B4;
	sub_8221F258(ctx, base);
	// 828C12B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C12B8: 419A0028  beq cr6, 0x828c12e0
	if ctx.cr[6].eq {
	pc = 0x828C12E0; continue 'dispatch;
	}
	// 828C12BC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C12C0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C12C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C12C8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C12CC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C12D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C12D4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C12D8: 4800000C  b 0x828c12e4
	pc = 0x828C12E4; continue 'dispatch;
            }
            0x828C12DC => {
    //   block [0x828C12DC..0x828C12E0)
	// 828C12DC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828C12E0; continue 'dispatch;
            }
            0x828C12E0 => {
    //   block [0x828C12E0..0x828C12E4)
	// 828C12E0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828C12E4; continue 'dispatch;
            }
            0x828C12E4 => {
    //   block [0x828C12E4..0x828C12F8)
	// 828C12E4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C12E8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C12EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C12F0: 419A0008  beq cr6, 0x828c12f8
	if ctx.cr[6].eq {
	pc = 0x828C12F8; continue 'dispatch;
	}
	// 828C12F4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C12F8; continue 'dispatch;
            }
            0x828C12F8 => {
    //   block [0x828C12F8..0x828C1378)
	// 828C12F8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C12FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1300: 419A0078  beq cr6, 0x828c1378
	if ctx.cr[6].eq {
	pc = 0x828C1378; continue 'dispatch;
	}
	// 828C1304: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1308: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C130C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1310: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1314: 4B967DF5  bl 0x82229108
	ctx.lr = 0x828C1318;
	sub_82229108(ctx, base);
	// 828C1318: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C131C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C1320: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1324: 3BCB1F38  addi r30, r11, 0x1f38
	ctx.r[30].s64 = ctx.r[11].s64 + 7992;
	// 828C1328: 4B966559  bl 0x82227880
	ctx.lr = 0x828C132C;
	sub_82227880(ctx, base);
	// 828C132C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C1330: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828C1334: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C1338: 388A8370  addi r4, r10, -0x7c90
	ctx.r[4].s64 = ctx.r[10].s64 + -31888;
	// 828C133C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1340: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C1344: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C1348: 4B8D9739  bl 0x8219aa80
	ctx.lr = 0x828C134C;
	sub_8219AA80(ctx, base);
	// 828C134C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1350: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C1354: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1358: 4BB0D0C9  bl 0x823ce420
	ctx.lr = 0x828C135C;
	sub_823CE420(ctx, base);
	// 828C135C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1360: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C1364: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1368: 48163361  bl 0x82a246c8
	ctx.lr = 0x828C136C;
	sub_82A246C8(ctx, base);
	// 828C136C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1370: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C1374: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828C1378; continue 'dispatch;
            }
            0x828C1378 => {
    //   block [0x828C1378..0x828C1388)
	// 828C1378: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C137C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C1380: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C1384: 419A0020  beq cr6, 0x828c13a4
	if ctx.cr[6].eq {
	pc = 0x828C13A4; continue 'dispatch;
	}
	pc = 0x828C1388; continue 'dispatch;
            }
            0x828C1388 => {
    //   block [0x828C1388..0x828C13A4)
	// 828C1388: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C138C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C1390: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C1394: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C1398: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C139C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C13A0: 4082FFE8  bne 0x828c1388
	if !ctx.cr[0].eq {
	pc = 0x828C1388; continue 'dispatch;
	}
	pc = 0x828C13A4; continue 'dispatch;
            }
            0x828C13A4 => {
    //   block [0x828C13A4..0x828C13C4)
	// 828C13A4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C13A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C13AC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C13B0: 4BA34599  bl 0x822f5948
	ctx.lr = 0x828C13B4;
	sub_822F5948(ctx, base);
	// 828C13B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C13B8: 4B8F6761  bl 0x821b7b18
	ctx.lr = 0x828C13BC;
	sub_821B7B18(ctx, base);
	// 828C13BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C13C0: 419A0040  beq cr6, 0x828c1400
	if ctx.cr[6].eq {
	pc = 0x828C1400; continue 'dispatch;
	}
	pc = 0x828C13C4; continue 'dispatch;
            }
            0x828C13C4 => {
    //   block [0x828C13C4..0x828C1400)
	// 828C13C4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C13C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C13CC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C13D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C13D4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C13D8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C13DC: 4082FFE8  bne 0x828c13c4
	if !ctx.cr[0].eq {
	pc = 0x828C13C4; continue 'dispatch;
	}
	// 828C13E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C13E4: 409A001C  bne cr6, 0x828c1400
	if !ctx.cr[6].eq {
	pc = 0x828C1400; continue 'dispatch;
	}
	// 828C13E8: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C13EC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C13F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C13F4: 4E800421  bctrl
	ctx.lr = 0x828C13F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C13F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C13FC: 4B95A93D  bl 0x8221bd38
	ctx.lr = 0x828C1400;
	sub_8221BD38(ctx, base);
            }
            0x828C1400 => {
    //   block [0x828C1400..0x828C1410)
	// 828C1400: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1404: 4B8F6715  bl 0x821b7b18
	ctx.lr = 0x828C1408;
	sub_821B7B18(ctx, base);
	// 828C1408: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C140C: 483E8040  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1410 size=512
    let mut pc: u32 = 0x828C1410;
    'dispatch: loop {
        match pc {
            0x828C1410 => {
    //   block [0x828C1410..0x828C1448)
	// 828C1410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1414: 483E7FE9  bl 0x82ca93fc
	ctx.lr = 0x828C1418;
	sub_82CA93D0(ctx, base);
	// 828C1418: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C141C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C1420: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C1424: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C1428: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828C142C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C1430: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1434: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C1438: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C143C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1440: 419A0008  beq cr6, 0x828c1448
	if ctx.cr[6].eq {
	pc = 0x828C1448; continue 'dispatch;
	}
	// 828C1444: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C1448; continue 'dispatch;
            }
            0x828C1448 => {
    //   block [0x828C1448..0x828C14DC)
	// 828C1448: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C144C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1450: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1454: 4BB0D16D  bl 0x823ce5c0
	ctx.lr = 0x828C1458;
	sub_823CE5C0(ctx, base);
	// 828C1458: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C145C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1460: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1464: 4BB0CCAD  bl 0x823ce110
	ctx.lr = 0x828C1468;
	sub_823CE110(ctx, base);
	// 828C1468: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C146C: 4B8F66AD  bl 0x821b7b18
	ctx.lr = 0x828C1470;
	sub_821B7B18(ctx, base);
	// 828C1470: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C1474: 4B95DDE5  bl 0x8221f258
	ctx.lr = 0x828C1478;
	sub_8221F258(ctx, base);
	// 828C1478: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C147C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C1480: 419A005C  beq cr6, 0x828c14dc
	if ctx.cr[6].eq {
	pc = 0x828C14DC; continue 'dispatch;
	}
	// 828C1484: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C1488: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828C148C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C1490: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C1494: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C1498: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C149C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C14A0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C14A4: 4B92ED9D  bl 0x821f0240
	ctx.lr = 0x828C14A8;
	sub_821F0240(ctx, base);
	// 828C14A8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C14AC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C14B0: 4B95DDA9  bl 0x8221f258
	ctx.lr = 0x828C14B4;
	sub_8221F258(ctx, base);
	// 828C14B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C14B8: 419A0028  beq cr6, 0x828c14e0
	if ctx.cr[6].eq {
	pc = 0x828C14E0; continue 'dispatch;
	}
	// 828C14BC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C14C0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C14C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C14C8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C14CC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C14D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C14D4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C14D8: 4800000C  b 0x828c14e4
	pc = 0x828C14E4; continue 'dispatch;
            }
            0x828C14DC => {
    //   block [0x828C14DC..0x828C14E0)
	// 828C14DC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828C14E0; continue 'dispatch;
            }
            0x828C14E0 => {
    //   block [0x828C14E0..0x828C14E4)
	// 828C14E0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828C14E4; continue 'dispatch;
            }
            0x828C14E4 => {
    //   block [0x828C14E4..0x828C14F8)
	// 828C14E4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C14E8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C14EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C14F0: 419A0008  beq cr6, 0x828c14f8
	if ctx.cr[6].eq {
	pc = 0x828C14F8; continue 'dispatch;
	}
	// 828C14F4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C14F8; continue 'dispatch;
            }
            0x828C14F8 => {
    //   block [0x828C14F8..0x828C1578)
	// 828C14F8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C14FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1500: 419A0078  beq cr6, 0x828c1578
	if ctx.cr[6].eq {
	pc = 0x828C1578; continue 'dispatch;
	}
	// 828C1504: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1508: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C150C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1510: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1514: 4B967BF5  bl 0x82229108
	ctx.lr = 0x828C1518;
	sub_82229108(ctx, base);
	// 828C1518: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C151C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C1520: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1524: 3BCB20B8  addi r30, r11, 0x20b8
	ctx.r[30].s64 = ctx.r[11].s64 + 8376;
	// 828C1528: 4B966359  bl 0x82227880
	ctx.lr = 0x828C152C;
	sub_82227880(ctx, base);
	// 828C152C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C1530: 3D408278  lis r10, -0x7d88
	ctx.r[10].s64 = -2106064896;
	// 828C1534: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C1538: 388A3318  addi r4, r10, 0x3318
	ctx.r[4].s64 = ctx.r[10].s64 + 13080;
	// 828C153C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1540: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C1544: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C1548: 4B8D9539  bl 0x8219aa80
	ctx.lr = 0x828C154C;
	sub_8219AA80(ctx, base);
	// 828C154C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1550: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C1554: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1558: 4BB0CEC9  bl 0x823ce420
	ctx.lr = 0x828C155C;
	sub_823CE420(ctx, base);
	// 828C155C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1560: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C1564: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1568: 48163161  bl 0x82a246c8
	ctx.lr = 0x828C156C;
	sub_82A246C8(ctx, base);
	// 828C156C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1570: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C1574: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828C1578; continue 'dispatch;
            }
            0x828C1578 => {
    //   block [0x828C1578..0x828C1588)
	// 828C1578: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C157C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C1580: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C1584: 419A0020  beq cr6, 0x828c15a4
	if ctx.cr[6].eq {
	pc = 0x828C15A4; continue 'dispatch;
	}
	pc = 0x828C1588; continue 'dispatch;
            }
            0x828C1588 => {
    //   block [0x828C1588..0x828C15A4)
	// 828C1588: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C158C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C1590: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C1594: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C1598: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C159C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C15A0: 4082FFE8  bne 0x828c1588
	if !ctx.cr[0].eq {
	pc = 0x828C1588; continue 'dispatch;
	}
	pc = 0x828C15A4; continue 'dispatch;
            }
            0x828C15A4 => {
    //   block [0x828C15A4..0x828C15C4)
	// 828C15A4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C15A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C15AC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C15B0: 4BA34399  bl 0x822f5948
	ctx.lr = 0x828C15B4;
	sub_822F5948(ctx, base);
	// 828C15B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C15B8: 4B8F6561  bl 0x821b7b18
	ctx.lr = 0x828C15BC;
	sub_821B7B18(ctx, base);
	// 828C15BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C15C0: 419A0040  beq cr6, 0x828c1600
	if ctx.cr[6].eq {
	pc = 0x828C1600; continue 'dispatch;
	}
	pc = 0x828C15C4; continue 'dispatch;
            }
            0x828C15C4 => {
    //   block [0x828C15C4..0x828C1600)
	// 828C15C4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C15C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C15CC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C15D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C15D4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C15D8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C15DC: 4082FFE8  bne 0x828c15c4
	if !ctx.cr[0].eq {
	pc = 0x828C15C4; continue 'dispatch;
	}
	// 828C15E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C15E4: 409A001C  bne cr6, 0x828c1600
	if !ctx.cr[6].eq {
	pc = 0x828C1600; continue 'dispatch;
	}
	// 828C15E8: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C15EC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C15F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C15F4: 4E800421  bctrl
	ctx.lr = 0x828C15F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C15F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C15FC: 4B95A73D  bl 0x8221bd38
	ctx.lr = 0x828C1600;
	sub_8221BD38(ctx, base);
            }
            0x828C1600 => {
    //   block [0x828C1600..0x828C1610)
	// 828C1600: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1604: 4B8F6515  bl 0x821b7b18
	ctx.lr = 0x828C1608;
	sub_821B7B18(ctx, base);
	// 828C1608: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C160C: 483E7E40  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1610 size=516
    let mut pc: u32 = 0x828C1610;
    'dispatch: loop {
        match pc {
            0x828C1610 => {
    //   block [0x828C1610..0x828C164C)
	// 828C1610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1614: 483E7DE9  bl 0x82ca93fc
	ctx.lr = 0x828C1618;
	sub_82CA93D0(ctx, base);
	// 828C1618: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C161C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C1620: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828C1624: 3D40828C  lis r10, -0x7d74
	ctx.r[10].s64 = -2104754176;
	// 828C1628: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828C162C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C1630: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1634: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C1638: 3BAAF530  addi r29, r10, -0xad0
	ctx.r[29].s64 = ctx.r[10].s64 + -2768;
	// 828C163C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1640: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C1644: 419A0008  beq cr6, 0x828c164c
	if ctx.cr[6].eq {
	pc = 0x828C164C; continue 'dispatch;
	}
	// 828C1648: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C164C; continue 'dispatch;
            }
            0x828C164C => {
    //   block [0x828C164C..0x828C16E0)
	// 828C164C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1650: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1654: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1658: 4BB0CF69  bl 0x823ce5c0
	ctx.lr = 0x828C165C;
	sub_823CE5C0(ctx, base);
	// 828C165C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C1660: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1664: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1668: 4BB0CAA9  bl 0x823ce110
	ctx.lr = 0x828C166C;
	sub_823CE110(ctx, base);
	// 828C166C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1670: 4B8F64A9  bl 0x821b7b18
	ctx.lr = 0x828C1674;
	sub_821B7B18(ctx, base);
	// 828C1674: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C1678: 4B95DBE1  bl 0x8221f258
	ctx.lr = 0x828C167C;
	sub_8221F258(ctx, base);
	// 828C167C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C1680: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C1684: 419A005C  beq cr6, 0x828c16e0
	if ctx.cr[6].eq {
	pc = 0x828C16E0; continue 'dispatch;
	}
	// 828C1688: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C168C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828C1690: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C1694: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C1698: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C169C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C16A0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C16A4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C16A8: 4B92EB99  bl 0x821f0240
	ctx.lr = 0x828C16AC;
	sub_821F0240(ctx, base);
	// 828C16AC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C16B0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C16B4: 4B95DBA5  bl 0x8221f258
	ctx.lr = 0x828C16B8;
	sub_8221F258(ctx, base);
	// 828C16B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C16BC: 419A0028  beq cr6, 0x828c16e4
	if ctx.cr[6].eq {
	pc = 0x828C16E4; continue 'dispatch;
	}
	// 828C16C0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C16C4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C16C8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C16CC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C16D0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C16D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C16D8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C16DC: 4800000C  b 0x828c16e8
	pc = 0x828C16E8; continue 'dispatch;
            }
            0x828C16E0 => {
    //   block [0x828C16E0..0x828C16E4)
	// 828C16E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828C16E4; continue 'dispatch;
            }
            0x828C16E4 => {
    //   block [0x828C16E4..0x828C16E8)
	// 828C16E4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828C16E8; continue 'dispatch;
            }
            0x828C16E8 => {
    //   block [0x828C16E8..0x828C16FC)
	// 828C16E8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C16EC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C16F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C16F4: 419A0008  beq cr6, 0x828c16fc
	if ctx.cr[6].eq {
	pc = 0x828C16FC; continue 'dispatch;
	}
	// 828C16F8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C16FC; continue 'dispatch;
            }
            0x828C16FC => {
    //   block [0x828C16FC..0x828C177C)
	// 828C16FC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C1700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1704: 419A0078  beq cr6, 0x828c177c
	if ctx.cr[6].eq {
	pc = 0x828C177C; continue 'dispatch;
	}
	// 828C1708: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C170C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C1710: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1714: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1718: 4B9679F1  bl 0x82229108
	ctx.lr = 0x828C171C;
	sub_82229108(ctx, base);
	// 828C171C: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C1720: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C1724: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1728: 3BCB2230  addi r30, r11, 0x2230
	ctx.r[30].s64 = ctx.r[11].s64 + 8752;
	// 828C172C: 4B966155  bl 0x82227880
	ctx.lr = 0x828C1730;
	sub_82227880(ctx, base);
	// 828C1730: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C1734: 3D408296  lis r10, -0x7d6a
	ctx.r[10].s64 = -2104098816;
	// 828C1738: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C173C: 388A7468  addi r4, r10, 0x7468
	ctx.r[4].s64 = ctx.r[10].s64 + 29800;
	// 828C1740: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1744: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C1748: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C174C: 4B8D9335  bl 0x8219aa80
	ctx.lr = 0x828C1750;
	sub_8219AA80(ctx, base);
	// 828C1750: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1754: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C1758: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C175C: 4BB0CCC5  bl 0x823ce420
	ctx.lr = 0x828C1760;
	sub_823CE420(ctx, base);
	// 828C1760: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1764: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C1768: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C176C: 48162F5D  bl 0x82a246c8
	ctx.lr = 0x828C1770;
	sub_82A246C8(ctx, base);
	// 828C1770: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1774: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C1778: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828C177C; continue 'dispatch;
            }
            0x828C177C => {
    //   block [0x828C177C..0x828C178C)
	// 828C177C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C1780: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C1784: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C1788: 419A0020  beq cr6, 0x828c17a8
	if ctx.cr[6].eq {
	pc = 0x828C17A8; continue 'dispatch;
	}
	pc = 0x828C178C; continue 'dispatch;
            }
            0x828C178C => {
    //   block [0x828C178C..0x828C17A8)
	// 828C178C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C1790: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C1794: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C1798: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C179C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C17A0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C17A4: 4082FFE8  bne 0x828c178c
	if !ctx.cr[0].eq {
	pc = 0x828C178C; continue 'dispatch;
	}
	pc = 0x828C17A8; continue 'dispatch;
            }
            0x828C17A8 => {
    //   block [0x828C17A8..0x828C17C8)
	// 828C17A8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C17AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C17B0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C17B4: 4BA34195  bl 0x822f5948
	ctx.lr = 0x828C17B8;
	sub_822F5948(ctx, base);
	// 828C17B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C17BC: 4B8F635D  bl 0x821b7b18
	ctx.lr = 0x828C17C0;
	sub_821B7B18(ctx, base);
	// 828C17C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C17C4: 419A0040  beq cr6, 0x828c1804
	if ctx.cr[6].eq {
	pc = 0x828C1804; continue 'dispatch;
	}
	pc = 0x828C17C8; continue 'dispatch;
            }
            0x828C17C8 => {
    //   block [0x828C17C8..0x828C1804)
	// 828C17C8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C17CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C17D0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C17D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C17D8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C17DC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C17E0: 4082FFE8  bne 0x828c17c8
	if !ctx.cr[0].eq {
	pc = 0x828C17C8; continue 'dispatch;
	}
	// 828C17E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C17E8: 409A001C  bne cr6, 0x828c1804
	if !ctx.cr[6].eq {
	pc = 0x828C1804; continue 'dispatch;
	}
	// 828C17EC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C17F0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C17F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C17F8: 4E800421  bctrl
	ctx.lr = 0x828C17FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C17FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C1800: 4B95A539  bl 0x8221bd38
	ctx.lr = 0x828C1804;
	sub_8221BD38(ctx, base);
            }
            0x828C1804 => {
    //   block [0x828C1804..0x828C1814)
	// 828C1804: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1808: 4B8F6311  bl 0x821b7b18
	ctx.lr = 0x828C180C;
	sub_821B7B18(ctx, base);
	// 828C180C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C1810: 483E7C3C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1818 size=516
    let mut pc: u32 = 0x828C1818;
    'dispatch: loop {
        match pc {
            0x828C1818 => {
    //   block [0x828C1818..0x828C1854)
	// 828C1818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C181C: 483E7BE1  bl 0x82ca93fc
	ctx.lr = 0x828C1820;
	sub_82CA93D0(ctx, base);
	// 828C1820: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C1824: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C1828: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828C182C: 3D40828C  lis r10, -0x7d74
	ctx.r[10].s64 = -2104754176;
	// 828C1830: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828C1834: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C1838: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C183C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C1840: 3BAAF958  addi r29, r10, -0x6a8
	ctx.r[29].s64 = ctx.r[10].s64 + -1704;
	// 828C1844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1848: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C184C: 419A0008  beq cr6, 0x828c1854
	if ctx.cr[6].eq {
	pc = 0x828C1854; continue 'dispatch;
	}
	// 828C1850: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C1854; continue 'dispatch;
            }
            0x828C1854 => {
    //   block [0x828C1854..0x828C18E8)
	// 828C1854: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1858: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C185C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1860: 4BB0CD61  bl 0x823ce5c0
	ctx.lr = 0x828C1864;
	sub_823CE5C0(ctx, base);
	// 828C1864: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C1868: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C186C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C1870: 4BB0C8A1  bl 0x823ce110
	ctx.lr = 0x828C1874;
	sub_823CE110(ctx, base);
	// 828C1874: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C1878: 4B8F62A1  bl 0x821b7b18
	ctx.lr = 0x828C187C;
	sub_821B7B18(ctx, base);
	// 828C187C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C1880: 4B95D9D9  bl 0x8221f258
	ctx.lr = 0x828C1884;
	sub_8221F258(ctx, base);
	// 828C1884: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C1888: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C188C: 419A005C  beq cr6, 0x828c18e8
	if ctx.cr[6].eq {
	pc = 0x828C18E8; continue 'dispatch;
	}
	// 828C1890: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C1894: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828C1898: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C189C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C18A0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C18A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C18A8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C18AC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C18B0: 4B92E991  bl 0x821f0240
	ctx.lr = 0x828C18B4;
	sub_821F0240(ctx, base);
	// 828C18B4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C18B8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C18BC: 4B95D99D  bl 0x8221f258
	ctx.lr = 0x828C18C0;
	sub_8221F258(ctx, base);
	// 828C18C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C18C4: 419A0028  beq cr6, 0x828c18ec
	if ctx.cr[6].eq {
	pc = 0x828C18EC; continue 'dispatch;
	}
	// 828C18C8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C18CC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C18D0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C18D4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C18D8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C18DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C18E0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C18E4: 4800000C  b 0x828c18f0
	pc = 0x828C18F0; continue 'dispatch;
            }
            0x828C18E8 => {
    //   block [0x828C18E8..0x828C18EC)
	// 828C18E8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828C18EC; continue 'dispatch;
            }
            0x828C18EC => {
    //   block [0x828C18EC..0x828C18F0)
	// 828C18EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828C18F0; continue 'dispatch;
            }
            0x828C18F0 => {
    //   block [0x828C18F0..0x828C1904)
	// 828C18F0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C18F4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C18F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C18FC: 419A0008  beq cr6, 0x828c1904
	if ctx.cr[6].eq {
	pc = 0x828C1904; continue 'dispatch;
	}
	// 828C1900: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C1904; continue 'dispatch;
            }
            0x828C1904 => {
    //   block [0x828C1904..0x828C1984)
	// 828C1904: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C1908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C190C: 419A0078  beq cr6, 0x828c1984
	if ctx.cr[6].eq {
	pc = 0x828C1984; continue 'dispatch;
	}
	// 828C1910: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1914: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C1918: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C191C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1920: 4B9677E9  bl 0x82229108
	ctx.lr = 0x828C1924;
	sub_82229108(ctx, base);
	// 828C1924: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C1928: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C192C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1930: 3BCB23F8  addi r30, r11, 0x23f8
	ctx.r[30].s64 = ctx.r[11].s64 + 9208;
	// 828C1934: 4B965F4D  bl 0x82227880
	ctx.lr = 0x828C1938;
	sub_82227880(ctx, base);
	// 828C1938: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C193C: 3D40823B  lis r10, -0x7dc5
	ctx.r[10].s64 = -2110062592;
	// 828C1940: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C1944: 388A08A0  addi r4, r10, 0x8a0
	ctx.r[4].s64 = ctx.r[10].s64 + 2208;
	// 828C1948: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C194C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C1950: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C1954: 4B8D912D  bl 0x8219aa80
	ctx.lr = 0x828C1958;
	sub_8219AA80(ctx, base);
	// 828C1958: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C195C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C1960: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1964: 4BB0CABD  bl 0x823ce420
	ctx.lr = 0x828C1968;
	sub_823CE420(ctx, base);
	// 828C1968: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C196C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C1970: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C1974: 48162D55  bl 0x82a246c8
	ctx.lr = 0x828C1978;
	sub_82A246C8(ctx, base);
	// 828C1978: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C197C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C1980: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828C1984; continue 'dispatch;
            }
            0x828C1984 => {
    //   block [0x828C1984..0x828C1994)
	// 828C1984: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C1988: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C198C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C1990: 419A0020  beq cr6, 0x828c19b0
	if ctx.cr[6].eq {
	pc = 0x828C19B0; continue 'dispatch;
	}
	pc = 0x828C1994; continue 'dispatch;
            }
            0x828C1994 => {
    //   block [0x828C1994..0x828C19B0)
	// 828C1994: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C1998: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C199C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C19A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C19A4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C19A8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C19AC: 4082FFE8  bne 0x828c1994
	if !ctx.cr[0].eq {
	pc = 0x828C1994; continue 'dispatch;
	}
	pc = 0x828C19B0; continue 'dispatch;
            }
            0x828C19B0 => {
    //   block [0x828C19B0..0x828C19D0)
	// 828C19B0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C19B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C19B8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C19BC: 4BA33F8D  bl 0x822f5948
	ctx.lr = 0x828C19C0;
	sub_822F5948(ctx, base);
	// 828C19C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C19C4: 4B8F6155  bl 0x821b7b18
	ctx.lr = 0x828C19C8;
	sub_821B7B18(ctx, base);
	// 828C19C8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C19CC: 419A0040  beq cr6, 0x828c1a0c
	if ctx.cr[6].eq {
	pc = 0x828C1A0C; continue 'dispatch;
	}
	pc = 0x828C19D0; continue 'dispatch;
            }
            0x828C19D0 => {
    //   block [0x828C19D0..0x828C1A0C)
	// 828C19D0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C19D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C19D8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C19DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C19E0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C19E4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C19E8: 4082FFE8  bne 0x828c19d0
	if !ctx.cr[0].eq {
	pc = 0x828C19D0; continue 'dispatch;
	}
	// 828C19EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C19F0: 409A001C  bne cr6, 0x828c1a0c
	if !ctx.cr[6].eq {
	pc = 0x828C1A0C; continue 'dispatch;
	}
	// 828C19F4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C19F8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C19FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C1A00: 4E800421  bctrl
	ctx.lr = 0x828C1A04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C1A04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C1A08: 4B95A331  bl 0x8221bd38
	ctx.lr = 0x828C1A0C;
	sub_8221BD38(ctx, base);
            }
            0x828C1A0C => {
    //   block [0x828C1A0C..0x828C1A1C)
	// 828C1A0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C1A10: 4B8F6109  bl 0x821b7b18
	ctx.lr = 0x828C1A14;
	sub_821B7B18(ctx, base);
	// 828C1A14: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C1A18: 483E7A34  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1A20 size=220
    let mut pc: u32 = 0x828C1A20;
    'dispatch: loop {
        match pc {
            0x828C1A20 => {
    //   block [0x828C1A20..0x828C1A68)
	// 828C1A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1A24: 483E79E9  bl 0x82ca940c
	ctx.lr = 0x828C1A28;
	sub_82CA93D0(ctx, base);
	// 828C1A28: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C1A2C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C1A30: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1A34: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 828C1A38: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1A3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C1A40: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1A44: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1A48: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1A4C: 7D674050  subf r11, r7, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 828C1A50: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1A54: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C1A58: 7D2B00D0  neg r9, r11
	ctx.r[9].s64 = -ctx.r[11].s64;
	// 828C1A5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1A60: 409A0008  bne cr6, 0x828c1a68
	if !ctx.cr[6].eq {
	pc = 0x828C1A68; continue 'dispatch;
	}
	// 828C1A64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C1A68; continue 'dispatch;
            }
            0x828C1A68 => {
    //   block [0x828C1A68..0x828C1A88)
	// 828C1A68: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C1A6C: 7D292A14  add r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 828C1A70: 80CA0010  lwz r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C1A74: 7CC65A14  add r6, r6, r11
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 828C1A78: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C1A7C: 4199000C  bgt cr6, 0x828c1a88
	if ctx.cr[6].gt {
	pc = 0x828C1A88; continue 'dispatch;
	}
	// 828C1A80: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C1A84: 40980008  bge cr6, 0x828c1a8c
	if !ctx.cr[6].lt {
	pc = 0x828C1A8C; continue 'dispatch;
	}
	pc = 0x828C1A88; continue 'dispatch;
            }
            0x828C1A88 => {
    //   block [0x828C1A88..0x828C1A8C)
	// 828C1A88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C1A8C; continue 'dispatch;
            }
            0x828C1A8C => {
    //   block [0x828C1A8C..0x828C1AFC)
	// 828C1A8C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828C1A90: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 828C1A94: 3BA10051  addi r29, r1, 0x51
	ctx.r[29].s64 = ctx.r[1].s64 + 81;
	// 828C1A98: 9081006C  stw r4, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[4].u32 ) };
	// 828C1A9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C1AA0: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 828C1AA4: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 828C1AA8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 828C1AAC: 90E10080  stw r7, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[7].u32 ) };
	// 828C1AB0: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 828C1AB4: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828C1AB8: 997D0000  stb r11, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828C1ABC: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C1AC0: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 828C1AC4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C1AC8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828C1ACC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828C1AD0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C1AD4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C1AD8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828C1ADC: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 828C1AE0: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C1AE4: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828C1AE8: 89010051  lbz r8, 0x51(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828C1AEC: 48000EED  bl 0x828c29d8
	ctx.lr = 0x828C1AF0;
	sub_828C29D8(ctx, base);
	// 828C1AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C1AF4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828C1AF8: 483E7964  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1B00 size=212
    let mut pc: u32 = 0x828C1B00;
    'dispatch: loop {
        match pc {
            0x828C1B00 => {
    //   block [0x828C1B00..0x828C1B40)
	// 828C1B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1B04: 483E7909  bl 0x82ca940c
	ctx.lr = 0x828C1B08;
	sub_82CA93D0(ctx, base);
	// 828C1B08: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C1B0C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C1B10: 81050008  lwz r8, 8(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1B14: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1B18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C1B1C: 80C60008  lwz r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1B20: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1B24: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1B28: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1B2C: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C1B30: 7D274050  subf r9, r7, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 828C1B34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1B38: 409A0008  bne cr6, 0x828c1b40
	if !ctx.cr[6].eq {
	pc = 0x828C1B40; continue 'dispatch;
	}
	// 828C1B3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C1B40; continue 'dispatch;
            }
            0x828C1B40 => {
    //   block [0x828C1B40..0x828C1B60)
	// 828C1B40: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C1B44: 7D293214  add r9, r9, r6
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[6].u64;
	// 828C1B48: 80AA0010  lwz r5, 0x10(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C1B4C: 7CA55A14  add r5, r5, r11
	ctx.r[5].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 828C1B50: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828C1B54: 4199000C  bgt cr6, 0x828c1b60
	if ctx.cr[6].gt {
	pc = 0x828C1B60; continue 'dispatch;
	}
	// 828C1B58: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C1B5C: 40980008  bge cr6, 0x828c1b64
	if !ctx.cr[6].lt {
	pc = 0x828C1B64; continue 'dispatch;
	}
	pc = 0x828C1B60; continue 'dispatch;
            }
            0x828C1B60 => {
    //   block [0x828C1B60..0x828C1B64)
	// 828C1B60: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C1B64; continue 'dispatch;
            }
            0x828C1B64 => {
    //   block [0x828C1B64..0x828C1BD4)
	// 828C1B64: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828C1B68: 90C10060  stw r6, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u32 ) };
	// 828C1B6C: 3BA10051  addi r29, r1, 0x51
	ctx.r[29].s64 = ctx.r[1].s64 + 81;
	// 828C1B70: 9081006C  stw r4, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[4].u32 ) };
	// 828C1B74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C1B78: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 828C1B7C: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 828C1B80: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 828C1B84: 90E10080  stw r7, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[7].u32 ) };
	// 828C1B88: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 828C1B8C: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828C1B90: 997D0000  stb r11, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828C1B94: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C1B98: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 828C1B9C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C1BA0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828C1BA4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828C1BA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C1BAC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C1BB0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828C1BB4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 828C1BB8: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C1BBC: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828C1BC0: 89010051  lbz r8, 0x51(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 828C1BC4: 48000F55  bl 0x828c2b18
	ctx.lr = 0x828C1BC8;
	sub_828C2B18(ctx, base);
	// 828C1BC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C1BCC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828C1BD0: 483E788C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C1BD8 size=56
    let mut pc: u32 = 0x828C1BD8;
    'dispatch: loop {
        match pc {
            0x828C1BD8 => {
    //   block [0x828C1BD8..0x828C1BF4)
	// 828C1BD8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C1BDC: 419A0018  beq cr6, 0x828c1bf4
	if ctx.cr[6].eq {
	pc = 0x828C1BF4; continue 'dispatch;
	}
	// 828C1BE0: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C1BE4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C1BE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1BEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1BF0: 409A0008  bne cr6, 0x828c1bf8
	if !ctx.cr[6].eq {
	pc = 0x828C1BF8; continue 'dispatch;
	}
	pc = 0x828C1BF4; continue 'dispatch;
            }
            0x828C1BF4 => {
    //   block [0x828C1BF4..0x828C1BF8)
	// 828C1BF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C1BF8; continue 'dispatch;
            }
            0x828C1BF8 => {
    //   block [0x828C1BF8..0x828C1C10)
	// 828C1BF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C1BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1C00: 419A0010  beq cr6, 0x828c1c10
	if ctx.cr[6].eq {
		sub_828C1C10(ctx, base);
		return;
	}
	// 828C1C04: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C1C08: 55631FFE  rlwinm r3, r11, 3, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 828C1C0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C1C10 size=8
    let mut pc: u32 = 0x828C1C10;
    'dispatch: loop {
        match pc {
            0x828C1C10 => {
    //   block [0x828C1C10..0x828C1C18)
	// 828C1C10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C1C14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1C18 size=396
    let mut pc: u32 = 0x828C1C18;
    'dispatch: loop {
        match pc {
            0x828C1C18 => {
    //   block [0x828C1C18..0x828C1C44)
	// 828C1C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C1C20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C1C24: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C1C28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1C2C: 419A0018  beq cr6, 0x828c1c44
	if ctx.cr[6].eq {
	pc = 0x828C1C44; continue 'dispatch;
	}
	// 828C1C30: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C1C34: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C1C38: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C1C3C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C1C40: 409A0008  bne cr6, 0x828c1c48
	if !ctx.cr[6].eq {
	pc = 0x828C1C48; continue 'dispatch;
	}
	pc = 0x828C1C44; continue 'dispatch;
            }
            0x828C1C44 => {
    //   block [0x828C1C44..0x828C1C48)
	// 828C1C44: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828C1C48; continue 'dispatch;
            }
            0x828C1C48 => {
    //   block [0x828C1C48..0x828C1C94)
	// 828C1C48: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C1C4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1C50: 419A0140  beq cr6, 0x828c1d90
	if ctx.cr[6].eq {
	pc = 0x828C1D90; continue 'dispatch;
	}
	// 828C1C54: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C1C58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C1C5C: 55281FFE  rlwinm r8, r9, 3, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 828C1C60: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C1C64: 419A00F8  beq cr6, 0x828c1d5c
	if ctx.cr[6].eq {
	pc = 0x828C1D5C; continue 'dispatch;
	}
	// 828C1C68: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C1C6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1C70: 419A0024  beq cr6, 0x828c1c94
	if ctx.cr[6].eq {
	pc = 0x828C1C94; continue 'dispatch;
	}
	// 828C1C74: 892A003D  lbz r9, 0x3d(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(61 as u32) ) } as u64;
	// 828C1C78: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C1C7C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828C1C80: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C1C84: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1C88: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C1C8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1C90: 480000D0  b 0x828c1d60
	pc = 0x828C1D60; continue 'dispatch;
            }
            0x828C1C94 => {
    //   block [0x828C1C94..0x828C1CB4)
	// 828C1C94: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C1C98: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C1C9C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C1CA0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C1CA4: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C1CA8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C1CAC: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C1CB0: 40810054  ble 0x828c1d04
	if !ctx.cr[0].gt {
	pc = 0x828C1D04; continue 'dispatch;
	}
	pc = 0x828C1CB4; continue 'dispatch;
            }
            0x828C1CB4 => {
    //   block [0x828C1CB4..0x828C1CD4)
	// 828C1CB4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C1CB8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C1CBC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C1CC0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1CC4: 2F07003D  cmpwi cr6, r7, 0x3d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 61, &mut ctx.xer);
	// 828C1CC8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C1CCC: 41980008  blt cr6, 0x828c1cd4
	if ctx.cr[6].lt {
	pc = 0x828C1CD4; continue 'dispatch;
	}
	// 828C1CD0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828C1CD4; continue 'dispatch;
            }
            0x828C1CD4 => {
    //   block [0x828C1CD4..0x828C1CF0)
	// 828C1CD4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C1CD8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C1CDC: 419A0014  beq cr6, 0x828c1cf0
	if ctx.cr[6].eq {
	pc = 0x828C1CF0; continue 'dispatch;
	}
	// 828C1CE0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C1CE4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C1CE8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C1CEC: 4800000C  b 0x828c1cf8
	pc = 0x828C1CF8; continue 'dispatch;
            }
            0x828C1CF0 => {
    //   block [0x828C1CF0..0x828C1CF8)
	// 828C1CF0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C1CF4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C1CF8; continue 'dispatch;
            }
            0x828C1CF8 => {
    //   block [0x828C1CF8..0x828C1D04)
	// 828C1CF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C1CFC: 4199FFB8  bgt cr6, 0x828c1cb4
	if ctx.cr[6].gt {
	pc = 0x828C1CB4; continue 'dispatch;
	}
	// 828C1D00: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C1D04; continue 'dispatch;
            }
            0x828C1D04 => {
    //   block [0x828C1D04..0x828C1D20)
	// 828C1D04: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C1D08: 419A0040  beq cr6, 0x828c1d48
	if ctx.cr[6].eq {
	pc = 0x828C1D48; continue 'dispatch;
	}
	// 828C1D0C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1D10: 2F0B003D  cmpwi cr6, r11, 0x3d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 61, &mut ctx.xer);
	// 828C1D14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1D18: 41990008  bgt cr6, 0x828c1d20
	if ctx.cr[6].gt {
	pc = 0x828C1D20; continue 'dispatch;
	}
	// 828C1D1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C1D20; continue 'dispatch;
            }
            0x828C1D20 => {
    //   block [0x828C1D20..0x828C1D48)
	// 828C1D20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C1D24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1D28: 409A0020  bne cr6, 0x828c1d48
	if !ctx.cr[6].eq {
	pc = 0x828C1D48; continue 'dispatch;
	}
	// 828C1D2C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C1D30: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C1D34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C1D38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1D3C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C1D40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1D44: 4800001C  b 0x828c1d60
	pc = 0x828C1D60; continue 'dispatch;
            }
            0x828C1D48 => {
    //   block [0x828C1D48..0x828C1D5C)
	// 828C1D48: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C1D4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1D50: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C1D54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1D58: 48000008  b 0x828c1d60
	pc = 0x828C1D60; continue 'dispatch;
            }
            0x828C1D5C => {
    //   block [0x828C1D5C..0x828C1D60)
	// 828C1D5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C1D60; continue 'dispatch;
            }
            0x828C1D60 => {
    //   block [0x828C1D60..0x828C1D90)
	// 828C1D60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C1D64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1D68: 419A0028  beq cr6, 0x828c1d90
	if ctx.cr[6].eq {
	pc = 0x828C1D90; continue 'dispatch;
	}
	// 828C1D6C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1D70: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828C1D74: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828C1D78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C1D7C: 4E800421  bctrl
	ctx.lr = 0x828C1D80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C1D80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C1D84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C1D88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C1D8C: 4E800020  blr
	return;
            }
            0x828C1D90 => {
    //   block [0x828C1D90..0x828C1DA4)
	// 828C1D90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C1D94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C1D98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C1D9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C1DA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C1DA8 size=396
    let mut pc: u32 = 0x828C1DA8;
    'dispatch: loop {
        match pc {
            0x828C1DA8 => {
    //   block [0x828C1DA8..0x828C1DD4)
	// 828C1DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1DAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C1DB0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C1DB4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C1DB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1DBC: 419A0018  beq cr6, 0x828c1dd4
	if ctx.cr[6].eq {
	pc = 0x828C1DD4; continue 'dispatch;
	}
	// 828C1DC0: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C1DC4: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C1DC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C1DCC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C1DD0: 409A0008  bne cr6, 0x828c1dd8
	if !ctx.cr[6].eq {
	pc = 0x828C1DD8; continue 'dispatch;
	}
	pc = 0x828C1DD4; continue 'dispatch;
            }
            0x828C1DD4 => {
    //   block [0x828C1DD4..0x828C1DD8)
	// 828C1DD4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828C1DD8; continue 'dispatch;
            }
            0x828C1DD8 => {
    //   block [0x828C1DD8..0x828C1E24)
	// 828C1DD8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C1DDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1DE0: 419A0140  beq cr6, 0x828c1f20
	if ctx.cr[6].eq {
	pc = 0x828C1F20; continue 'dispatch;
	}
	// 828C1DE4: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C1DE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C1DEC: 55281FFE  rlwinm r8, r9, 3, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 828C1DF0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C1DF4: 419A00F8  beq cr6, 0x828c1eec
	if ctx.cr[6].eq {
	pc = 0x828C1EEC; continue 'dispatch;
	}
	// 828C1DF8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C1DFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1E00: 419A0024  beq cr6, 0x828c1e24
	if ctx.cr[6].eq {
	pc = 0x828C1E24; continue 'dispatch;
	}
	// 828C1E04: 892A003D  lbz r9, 0x3d(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(61 as u32) ) } as u64;
	// 828C1E08: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C1E0C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828C1E10: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C1E14: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1E18: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C1E1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1E20: 480000D0  b 0x828c1ef0
	pc = 0x828C1EF0; continue 'dispatch;
            }
            0x828C1E24 => {
    //   block [0x828C1E24..0x828C1E44)
	// 828C1E24: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C1E28: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C1E2C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C1E30: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C1E34: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C1E38: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C1E3C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C1E40: 40810054  ble 0x828c1e94
	if !ctx.cr[0].gt {
	pc = 0x828C1E94; continue 'dispatch;
	}
	pc = 0x828C1E44; continue 'dispatch;
            }
            0x828C1E44 => {
    //   block [0x828C1E44..0x828C1E64)
	// 828C1E44: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C1E48: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C1E4C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C1E50: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1E54: 2F07003D  cmpwi cr6, r7, 0x3d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 61, &mut ctx.xer);
	// 828C1E58: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C1E5C: 41980008  blt cr6, 0x828c1e64
	if ctx.cr[6].lt {
	pc = 0x828C1E64; continue 'dispatch;
	}
	// 828C1E60: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828C1E64; continue 'dispatch;
            }
            0x828C1E64 => {
    //   block [0x828C1E64..0x828C1E80)
	// 828C1E64: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C1E68: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C1E6C: 419A0014  beq cr6, 0x828c1e80
	if ctx.cr[6].eq {
	pc = 0x828C1E80; continue 'dispatch;
	}
	// 828C1E70: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C1E74: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C1E78: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C1E7C: 4800000C  b 0x828c1e88
	pc = 0x828C1E88; continue 'dispatch;
            }
            0x828C1E80 => {
    //   block [0x828C1E80..0x828C1E88)
	// 828C1E80: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C1E84: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C1E88; continue 'dispatch;
            }
            0x828C1E88 => {
    //   block [0x828C1E88..0x828C1E94)
	// 828C1E88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C1E8C: 4199FFB8  bgt cr6, 0x828c1e44
	if ctx.cr[6].gt {
	pc = 0x828C1E44; continue 'dispatch;
	}
	// 828C1E90: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C1E94; continue 'dispatch;
            }
            0x828C1E94 => {
    //   block [0x828C1E94..0x828C1EB0)
	// 828C1E94: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C1E98: 419A0040  beq cr6, 0x828c1ed8
	if ctx.cr[6].eq {
	pc = 0x828C1ED8; continue 'dispatch;
	}
	// 828C1E9C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1EA0: 2F0B003D  cmpwi cr6, r11, 0x3d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 61, &mut ctx.xer);
	// 828C1EA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1EA8: 41990008  bgt cr6, 0x828c1eb0
	if ctx.cr[6].gt {
	pc = 0x828C1EB0; continue 'dispatch;
	}
	// 828C1EAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C1EB0; continue 'dispatch;
            }
            0x828C1EB0 => {
    //   block [0x828C1EB0..0x828C1ED8)
	// 828C1EB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C1EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1EB8: 409A0020  bne cr6, 0x828c1ed8
	if !ctx.cr[6].eq {
	pc = 0x828C1ED8; continue 'dispatch;
	}
	// 828C1EBC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C1EC0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C1EC4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C1EC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1ECC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C1ED0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1ED4: 4800001C  b 0x828c1ef0
	pc = 0x828C1EF0; continue 'dispatch;
            }
            0x828C1ED8 => {
    //   block [0x828C1ED8..0x828C1EEC)
	// 828C1ED8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C1EDC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1EE0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C1EE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1EE8: 48000008  b 0x828c1ef0
	pc = 0x828C1EF0; continue 'dispatch;
            }
            0x828C1EEC => {
    //   block [0x828C1EEC..0x828C1EF0)
	// 828C1EEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C1EF0; continue 'dispatch;
            }
            0x828C1EF0 => {
    //   block [0x828C1EF0..0x828C1F20)
	// 828C1EF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C1EF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1EF8: 419A0028  beq cr6, 0x828c1f20
	if ctx.cr[6].eq {
	pc = 0x828C1F20; continue 'dispatch;
	}
	// 828C1EFC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C1F00: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828C1F04: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828C1F08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C1F0C: 4E800421  bctrl
	ctx.lr = 0x828C1F10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C1F10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C1F14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C1F18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C1F1C: 4E800020  blr
	return;
            }
            0x828C1F20 => {
    //   block [0x828C1F20..0x828C1F34)
	// 828C1F20: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C1F24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C1F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C1F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C1F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C1F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C1F38 size=380
    let mut pc: u32 = 0x828C1F38;
    'dispatch: loop {
        match pc {
            0x828C1F38 => {
    //   block [0x828C1F38..0x828C1F60)
	// 828C1F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C1F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C1F40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C1F44: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C1F48: 419A0018  beq cr6, 0x828c1f60
	if ctx.cr[6].eq {
	pc = 0x828C1F60; continue 'dispatch;
	}
	// 828C1F4C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C1F50: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C1F54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C1F58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C1F5C: 409A0008  bne cr6, 0x828c1f64
	if !ctx.cr[6].eq {
	pc = 0x828C1F64; continue 'dispatch;
	}
	pc = 0x828C1F60; continue 'dispatch;
            }
            0x828C1F60 => {
    //   block [0x828C1F60..0x828C1F64)
	// 828C1F60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C1F64; continue 'dispatch;
            }
            0x828C1F64 => {
    //   block [0x828C1F64..0x828C1FAC)
	// 828C1F64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C1F68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1F6C: 419A0130  beq cr6, 0x828c209c
	if ctx.cr[6].eq {
	pc = 0x828C209C; continue 'dispatch;
	}
	// 828C1F70: 81440028  lwz r10, 0x28(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C1F74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C1F78: 55491FFE  rlwinm r9, r10, 3, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 828C1F7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C1F80: 419A00EC  beq cr6, 0x828c206c
	if ctx.cr[6].eq {
	pc = 0x828C206C; continue 'dispatch;
	}
	// 828C1F84: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C1F88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C1F8C: 419A0020  beq cr6, 0x828c1fac
	if ctx.cr[6].eq {
	pc = 0x828C1FAC; continue 'dispatch;
	}
	// 828C1F90: 894B003D  lbz r10, 0x3d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(61 as u32) ) } as u64;
	// 828C1F94: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C1F98: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828C1F9C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C1FA0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C1FA4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C1FA8: 480000C8  b 0x828c2070
	pc = 0x828C2070; continue 'dispatch;
            }
            0x828C1FAC => {
    //   block [0x828C1FAC..0x828C1FCC)
	// 828C1FAC: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C1FB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C1FB4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C1FB8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C1FBC: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C1FC0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C1FC4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C1FC8: 40810054  ble 0x828c201c
	if !ctx.cr[0].gt {
	pc = 0x828C201C; continue 'dispatch;
	}
	pc = 0x828C1FCC; continue 'dispatch;
            }
            0x828C1FCC => {
    //   block [0x828C1FCC..0x828C1FEC)
	// 828C1FCC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C1FD0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C1FD4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C1FD8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C1FDC: 2F07003D  cmpwi cr6, r7, 0x3d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 61, &mut ctx.xer);
	// 828C1FE0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C1FE4: 41980008  blt cr6, 0x828c1fec
	if ctx.cr[6].lt {
	pc = 0x828C1FEC; continue 'dispatch;
	}
	// 828C1FE8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828C1FEC; continue 'dispatch;
            }
            0x828C1FEC => {
    //   block [0x828C1FEC..0x828C2008)
	// 828C1FEC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C1FF0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C1FF4: 419A0014  beq cr6, 0x828c2008
	if ctx.cr[6].eq {
	pc = 0x828C2008; continue 'dispatch;
	}
	// 828C1FF8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C1FFC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C2000: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C2004: 4800000C  b 0x828c2010
	pc = 0x828C2010; continue 'dispatch;
            }
            0x828C2008 => {
    //   block [0x828C2008..0x828C2010)
	// 828C2008: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C200C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C2010; continue 'dispatch;
            }
            0x828C2010 => {
    //   block [0x828C2010..0x828C201C)
	// 828C2010: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C2014: 4199FFB8  bgt cr6, 0x828c1fcc
	if ctx.cr[6].gt {
	pc = 0x828C1FCC; continue 'dispatch;
	}
	// 828C2018: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C201C; continue 'dispatch;
            }
            0x828C201C => {
    //   block [0x828C201C..0x828C2038)
	// 828C201C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C2020: 419A003C  beq cr6, 0x828c205c
	if ctx.cr[6].eq {
	pc = 0x828C205C; continue 'dispatch;
	}
	// 828C2024: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2028: 2F0B003D  cmpwi cr6, r11, 0x3d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 61, &mut ctx.xer);
	// 828C202C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C2030: 41990008  bgt cr6, 0x828c2038
	if ctx.cr[6].gt {
	pc = 0x828C2038; continue 'dispatch;
	}
	// 828C2034: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C2038; continue 'dispatch;
            }
            0x828C2038 => {
    //   block [0x828C2038..0x828C205C)
	// 828C2038: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C203C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2040: 409A001C  bne cr6, 0x828c205c
	if !ctx.cr[6].eq {
	pc = 0x828C205C; continue 'dispatch;
	}
	// 828C2044: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C2048: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C204C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C2050: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C2054: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2058: 48000018  b 0x828c2070
	pc = 0x828C2070; continue 'dispatch;
            }
            0x828C205C => {
    //   block [0x828C205C..0x828C206C)
	// 828C205C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C2060: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C2064: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2068: 48000008  b 0x828c2070
	pc = 0x828C2070; continue 'dispatch;
            }
            0x828C206C => {
    //   block [0x828C206C..0x828C2070)
	// 828C206C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828C2070; continue 'dispatch;
            }
            0x828C2070 => {
    //   block [0x828C2070..0x828C209C)
	// 828C2070: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C2074: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C2078: 419A0024  beq cr6, 0x828c209c
	if ctx.cr[6].eq {
	pc = 0x828C209C; continue 'dispatch;
	}
	// 828C207C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2080: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C2084: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C2088: 4E800421  bctrl
	ctx.lr = 0x828C208C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C208C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2090: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2094: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2098: 4E800020  blr
	return;
            }
            0x828C209C => {
    //   block [0x828C209C..0x828C20B4)
	// 828C209C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C20A0: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C20A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C20A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C20AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C20B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C20B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C20B8 size=376
    let mut pc: u32 = 0x828C20B8;
    'dispatch: loop {
        match pc {
            0x828C20B8 => {
    //   block [0x828C20B8..0x828C20E4)
	// 828C20B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C20BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C20C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C20C4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C20C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C20CC: 419A0018  beq cr6, 0x828c20e4
	if ctx.cr[6].eq {
	pc = 0x828C20E4; continue 'dispatch;
	}
	// 828C20D0: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C20D4: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C20D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C20DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C20E0: 409A0008  bne cr6, 0x828c20e8
	if !ctx.cr[6].eq {
	pc = 0x828C20E8; continue 'dispatch;
	}
	pc = 0x828C20E4; continue 'dispatch;
            }
            0x828C20E4 => {
    //   block [0x828C20E4..0x828C20E8)
	// 828C20E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828C20E8; continue 'dispatch;
            }
            0x828C20E8 => {
    //   block [0x828C20E8..0x828C2134)
	// 828C20E8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C20EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C20F0: 419A0130  beq cr6, 0x828c2220
	if ctx.cr[6].eq {
	pc = 0x828C2220; continue 'dispatch;
	}
	// 828C20F4: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C20F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C20FC: 55281FFE  rlwinm r8, r9, 3, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 828C2100: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C2104: 419A00F8  beq cr6, 0x828c21fc
	if ctx.cr[6].eq {
	pc = 0x828C21FC; continue 'dispatch;
	}
	// 828C2108: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C210C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C2110: 419A0024  beq cr6, 0x828c2134
	if ctx.cr[6].eq {
	pc = 0x828C2134; continue 'dispatch;
	}
	// 828C2114: 892A003D  lbz r9, 0x3d(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(61 as u32) ) } as u64;
	// 828C2118: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C211C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828C2120: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C2124: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2128: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C212C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C2130: 480000D0  b 0x828c2200
	pc = 0x828C2200; continue 'dispatch;
            }
            0x828C2134 => {
    //   block [0x828C2134..0x828C2154)
	// 828C2134: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C2138: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C213C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C2140: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C2144: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C2148: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C214C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C2150: 40810054  ble 0x828c21a4
	if !ctx.cr[0].gt {
	pc = 0x828C21A4; continue 'dispatch;
	}
	pc = 0x828C2154; continue 'dispatch;
            }
            0x828C2154 => {
    //   block [0x828C2154..0x828C2174)
	// 828C2154: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C2158: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C215C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C2160: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2164: 2F07003D  cmpwi cr6, r7, 0x3d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 61, &mut ctx.xer);
	// 828C2168: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C216C: 41980008  blt cr6, 0x828c2174
	if ctx.cr[6].lt {
	pc = 0x828C2174; continue 'dispatch;
	}
	// 828C2170: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828C2174; continue 'dispatch;
            }
            0x828C2174 => {
    //   block [0x828C2174..0x828C2190)
	// 828C2174: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C2178: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C217C: 419A0014  beq cr6, 0x828c2190
	if ctx.cr[6].eq {
	pc = 0x828C2190; continue 'dispatch;
	}
	// 828C2180: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C2184: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C2188: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C218C: 4800000C  b 0x828c2198
	pc = 0x828C2198; continue 'dispatch;
            }
            0x828C2190 => {
    //   block [0x828C2190..0x828C2198)
	// 828C2190: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C2194: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C2198; continue 'dispatch;
            }
            0x828C2198 => {
    //   block [0x828C2198..0x828C21A4)
	// 828C2198: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C219C: 4199FFB8  bgt cr6, 0x828c2154
	if ctx.cr[6].gt {
	pc = 0x828C2154; continue 'dispatch;
	}
	// 828C21A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C21A4; continue 'dispatch;
            }
            0x828C21A4 => {
    //   block [0x828C21A4..0x828C21C0)
	// 828C21A4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C21A8: 419A0040  beq cr6, 0x828c21e8
	if ctx.cr[6].eq {
	pc = 0x828C21E8; continue 'dispatch;
	}
	// 828C21AC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C21B0: 2F0B003D  cmpwi cr6, r11, 0x3d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 61, &mut ctx.xer);
	// 828C21B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C21B8: 41990008  bgt cr6, 0x828c21c0
	if ctx.cr[6].gt {
	pc = 0x828C21C0; continue 'dispatch;
	}
	// 828C21BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C21C0; continue 'dispatch;
            }
            0x828C21C0 => {
    //   block [0x828C21C0..0x828C21E8)
	// 828C21C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C21C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C21C8: 409A0020  bne cr6, 0x828c21e8
	if !ctx.cr[6].eq {
	pc = 0x828C21E8; continue 'dispatch;
	}
	// 828C21CC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C21D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C21D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C21D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C21DC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C21E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C21E4: 4800001C  b 0x828c2200
	pc = 0x828C2200; continue 'dispatch;
            }
            0x828C21E8 => {
    //   block [0x828C21E8..0x828C21FC)
	// 828C21E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C21EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C21F0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C21F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C21F8: 48000008  b 0x828c2200
	pc = 0x828C2200; continue 'dispatch;
            }
            0x828C21FC => {
    //   block [0x828C21FC..0x828C2200)
	// 828C21FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C2200; continue 'dispatch;
            }
            0x828C2200 => {
    //   block [0x828C2200..0x828C2220)
	// 828C2200: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C2204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2208: 419A0018  beq cr6, 0x828c2220
	if ctx.cr[6].eq {
	pc = 0x828C2220; continue 'dispatch;
	}
	// 828C220C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2210: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828C2214: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828C2218: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C221C: 4E800421  bctrl
	ctx.lr = 0x828C2220;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C2220 => {
    //   block [0x828C2220..0x828C2230)
	// 828C2220: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2224: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2228: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C222C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2230 size=456
    let mut pc: u32 = 0x828C2230;
    'dispatch: loop {
        match pc {
            0x828C2230 => {
    //   block [0x828C2230..0x828C2268)
	// 828C2230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2238: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C223C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2240: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2244: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C2248: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C224C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828C2250: 419A0018  beq cr6, 0x828c2268
	if ctx.cr[6].eq {
	pc = 0x828C2268; continue 'dispatch;
	}
	// 828C2254: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C2258: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C225C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C2260: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C2264: 409A0008  bne cr6, 0x828c226c
	if !ctx.cr[6].eq {
	pc = 0x828C226C; continue 'dispatch;
	}
	pc = 0x828C2268; continue 'dispatch;
            }
            0x828C2268 => {
    //   block [0x828C2268..0x828C226C)
	// 828C2268: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828C226C; continue 'dispatch;
            }
            0x828C226C => {
    //   block [0x828C226C..0x828C22B4)
	// 828C226C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C2270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2274: 419A0160  beq cr6, 0x828c23d4
	if ctx.cr[6].eq {
	pc = 0x828C23D4; continue 'dispatch;
	}
	// 828C2278: 81450028  lwz r10, 0x28(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C227C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828C2280: 55491FFE  rlwinm r9, r10, 3, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 828C2284: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C2288: 419A00E8  beq cr6, 0x828c2370
	if ctx.cr[6].eq {
	pc = 0x828C2370; continue 'dispatch;
	}
	// 828C228C: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C2290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2294: 419A0020  beq cr6, 0x828c22b4
	if ctx.cr[6].eq {
	pc = 0x828C22B4; continue 'dispatch;
	}
	// 828C2298: 894B003D  lbz r10, 0x3d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(61 as u32) ) } as u64;
	// 828C229C: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C22A0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828C22A4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C22A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C22AC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C22B0: 480000C4  b 0x828c2374
	pc = 0x828C2374; continue 'dispatch;
            }
            0x828C22B4 => {
    //   block [0x828C22B4..0x828C22D0)
	// 828C22B4: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C22B8: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C22BC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C22C0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C22C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C22C8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C22CC: 40810054  ble 0x828c2320
	if !ctx.cr[0].gt {
	pc = 0x828C2320; continue 'dispatch;
	}
	pc = 0x828C22D0; continue 'dispatch;
            }
            0x828C22D0 => {
    //   block [0x828C22D0..0x828C22F0)
	// 828C22D0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C22D4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C22D8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C22DC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C22E0: 2F07003D  cmpwi cr6, r7, 0x3d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 61, &mut ctx.xer);
	// 828C22E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C22E8: 41980008  blt cr6, 0x828c22f0
	if ctx.cr[6].lt {
	pc = 0x828C22F0; continue 'dispatch;
	}
	// 828C22EC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x828C22F0; continue 'dispatch;
            }
            0x828C22F0 => {
    //   block [0x828C22F0..0x828C230C)
	// 828C22F0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C22F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C22F8: 419A0014  beq cr6, 0x828c230c
	if ctx.cr[6].eq {
	pc = 0x828C230C; continue 'dispatch;
	}
	// 828C22FC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C2300: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C2304: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C2308: 4800000C  b 0x828c2314
	pc = 0x828C2314; continue 'dispatch;
            }
            0x828C230C => {
    //   block [0x828C230C..0x828C2314)
	// 828C230C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C2310: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C2314; continue 'dispatch;
            }
            0x828C2314 => {
    //   block [0x828C2314..0x828C2320)
	// 828C2314: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C2318: 4199FFB8  bgt cr6, 0x828c22d0
	if ctx.cr[6].gt {
	pc = 0x828C22D0; continue 'dispatch;
	}
	// 828C231C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C2320; continue 'dispatch;
            }
            0x828C2320 => {
    //   block [0x828C2320..0x828C233C)
	// 828C2320: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C2324: 419A003C  beq cr6, 0x828c2360
	if ctx.cr[6].eq {
	pc = 0x828C2360; continue 'dispatch;
	}
	// 828C2328: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C232C: 2F0B003D  cmpwi cr6, r11, 0x3d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 61, &mut ctx.xer);
	// 828C2330: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C2334: 41990008  bgt cr6, 0x828c233c
	if ctx.cr[6].gt {
	pc = 0x828C233C; continue 'dispatch;
	}
	// 828C2338: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828C233C; continue 'dispatch;
            }
            0x828C233C => {
    //   block [0x828C233C..0x828C2360)
	// 828C233C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C2340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2344: 409A001C  bne cr6, 0x828c2360
	if !ctx.cr[6].eq {
	pc = 0x828C2360; continue 'dispatch;
	}
	// 828C2348: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C234C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C2350: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C2354: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C2358: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C235C: 48000018  b 0x828c2374
	pc = 0x828C2374; continue 'dispatch;
            }
            0x828C2360 => {
    //   block [0x828C2360..0x828C2370)
	// 828C2360: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C2364: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C2368: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C236C: 48000008  b 0x828c2374
	pc = 0x828C2374; continue 'dispatch;
            }
            0x828C2370 => {
    //   block [0x828C2370..0x828C2374)
	// 828C2370: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x828C2374; continue 'dispatch;
            }
            0x828C2374 => {
    //   block [0x828C2374..0x828C23AC)
	// 828C2374: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C2378: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C237C: 419A0058  beq cr6, 0x828c23d4
	if ctx.cr[6].eq {
	pc = 0x828C23D4; continue 'dispatch;
	}
	// 828C2380: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2384: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828C2388: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C238C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C2390: 4E800421  bctrl
	ctx.lr = 0x828C2394;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C2394: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2398: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C239C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C23A0: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C23A4: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C23A8: 419A0020  beq cr6, 0x828c23c8
	if ctx.cr[6].eq {
	pc = 0x828C23C8; continue 'dispatch;
	}
            }
            0x828C23AC => {
    //   block [0x828C23AC..0x828C23C8)
	// 828C23AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C23B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C23B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C23B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C23BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C23C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C23C4: 4082FFE8  bne 0x828c23ac
	if !ctx.cr[0].eq {
	pc = 0x828C23AC; continue 'dispatch;
	}
	pc = 0x828C23C8; continue 'dispatch;
            }
            0x828C23C8 => {
    //   block [0x828C23C8..0x828C23D4)
	// 828C23C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C23CC: 4B8F574D  bl 0x821b7b18
	ctx.lr = 0x828C23D0;
	sub_821B7B18(ctx, base);
	// 828C23D0: 4800000C  b 0x828c23dc
	pc = 0x828C23DC; continue 'dispatch;
            }
            0x828C23D4 => {
    //   block [0x828C23D4..0x828C23DC)
	// 828C23D4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C23D8: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x828C23DC; continue 'dispatch;
            }
            0x828C23DC => {
    //   block [0x828C23DC..0x828C23F8)
	// 828C23DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C23E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C23E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C23E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C23EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C23F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C23F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C23F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C23F8 size=372
    let mut pc: u32 = 0x828C23F8;
    'dispatch: loop {
        match pc {
            0x828C23F8 => {
    //   block [0x828C23F8..0x828C2420)
	// 828C23F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C23FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2400: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2404: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C2408: 419A0018  beq cr6, 0x828c2420
	if ctx.cr[6].eq {
	pc = 0x828C2420; continue 'dispatch;
	}
	// 828C240C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C2410: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C2414: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C2418: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C241C: 409A0008  bne cr6, 0x828c2424
	if !ctx.cr[6].eq {
	pc = 0x828C2424; continue 'dispatch;
	}
	pc = 0x828C2420; continue 'dispatch;
            }
            0x828C2420 => {
    //   block [0x828C2420..0x828C2424)
	// 828C2420: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C2424; continue 'dispatch;
            }
            0x828C2424 => {
    //   block [0x828C2424..0x828C246C)
	// 828C2424: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C2428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C242C: 419A012C  beq cr6, 0x828c2558
	if ctx.cr[6].eq {
	pc = 0x828C2558; continue 'dispatch;
	}
	// 828C2430: 81440028  lwz r10, 0x28(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C2434: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C2438: 55491FFE  rlwinm r9, r10, 3, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 828C243C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C2440: 419A00E8  beq cr6, 0x828c2528
	if ctx.cr[6].eq {
	pc = 0x828C2528; continue 'dispatch;
	}
	// 828C2444: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C2448: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C244C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2450: 419A001C  beq cr6, 0x828c246c
	if ctx.cr[6].eq {
	pc = 0x828C246C; continue 'dispatch;
	}
	// 828C2454: 896B003D  lbz r11, 0x3d(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(61 as u32) ) } as u64;
	// 828C2458: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828C245C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C2460: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2464: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C2468: 480000C4  b 0x828c252c
	pc = 0x828C252C; continue 'dispatch;
            }
            0x828C246C => {
    //   block [0x828C246C..0x828C2488)
	// 828C246C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C2470: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C2474: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C2478: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C247C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C2480: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C2484: 40810054  ble 0x828c24d8
	if !ctx.cr[0].gt {
	pc = 0x828C24D8; continue 'dispatch;
	}
	pc = 0x828C2488; continue 'dispatch;
            }
            0x828C2488 => {
    //   block [0x828C2488..0x828C24A8)
	// 828C2488: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C248C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C2490: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C2494: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2498: 2F07003D  cmpwi cr6, r7, 0x3d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 61, &mut ctx.xer);
	// 828C249C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C24A0: 41980008  blt cr6, 0x828c24a8
	if ctx.cr[6].lt {
	pc = 0x828C24A8; continue 'dispatch;
	}
	// 828C24A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828C24A8; continue 'dispatch;
            }
            0x828C24A8 => {
    //   block [0x828C24A8..0x828C24C4)
	// 828C24A8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C24AC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C24B0: 419A0014  beq cr6, 0x828c24c4
	if ctx.cr[6].eq {
	pc = 0x828C24C4; continue 'dispatch;
	}
	// 828C24B4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C24B8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C24BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C24C0: 4800000C  b 0x828c24cc
	pc = 0x828C24CC; continue 'dispatch;
            }
            0x828C24C4 => {
    //   block [0x828C24C4..0x828C24CC)
	// 828C24C4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C24C8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C24CC; continue 'dispatch;
            }
            0x828C24CC => {
    //   block [0x828C24CC..0x828C24D8)
	// 828C24CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C24D0: 4199FFB8  bgt cr6, 0x828c2488
	if ctx.cr[6].gt {
	pc = 0x828C2488; continue 'dispatch;
	}
	// 828C24D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C24D8; continue 'dispatch;
            }
            0x828C24D8 => {
    //   block [0x828C24D8..0x828C24F4)
	// 828C24D8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C24DC: 419A003C  beq cr6, 0x828c2518
	if ctx.cr[6].eq {
	pc = 0x828C2518; continue 'dispatch;
	}
	// 828C24E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C24E4: 2F0B003D  cmpwi cr6, r11, 0x3d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 61, &mut ctx.xer);
	// 828C24E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C24EC: 41990008  bgt cr6, 0x828c24f4
	if ctx.cr[6].gt {
	pc = 0x828C24F4; continue 'dispatch;
	}
	// 828C24F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C24F4; continue 'dispatch;
            }
            0x828C24F4 => {
    //   block [0x828C24F4..0x828C2518)
	// 828C24F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C24F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C24FC: 409A001C  bne cr6, 0x828c2518
	if !ctx.cr[6].eq {
	pc = 0x828C2518; continue 'dispatch;
	}
	// 828C2500: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C2504: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C2508: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C250C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C2510: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2514: 48000018  b 0x828c252c
	pc = 0x828C252C; continue 'dispatch;
            }
            0x828C2518 => {
    //   block [0x828C2518..0x828C2528)
	// 828C2518: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C251C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C2520: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2524: 48000008  b 0x828c252c
	pc = 0x828C252C; continue 'dispatch;
            }
            0x828C2528 => {
    //   block [0x828C2528..0x828C252C)
	// 828C2528: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828C252C; continue 'dispatch;
            }
            0x828C252C => {
    //   block [0x828C252C..0x828C2558)
	// 828C252C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C2530: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C2534: 419A0024  beq cr6, 0x828c2558
	if ctx.cr[6].eq {
	pc = 0x828C2558; continue 'dispatch;
	}
	// 828C2538: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C253C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C2540: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C2544: 4E800421  bctrl
	ctx.lr = 0x828C2548;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C2548: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C254C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2550: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2554: 4E800020  blr
	return;
            }
            0x828C2558 => {
    //   block [0x828C2558..0x828C256C)
	// 828C2558: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C255C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C2570 size=396
    let mut pc: u32 = 0x828C2570;
    'dispatch: loop {
        match pc {
            0x828C2570 => {
    //   block [0x828C2570..0x828C25D4)
	// 828C2570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2574: 483E6E85  bl 0x82ca93f8
	ctx.lr = 0x828C2578;
	sub_82CA93D0(ctx, base);
	// 828C2578: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828C257C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2580: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C2584: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C2588: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 828C258C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C2590: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 828C2594: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C2598: 485C6AE9  bl 0x82e89080
	ctx.lr = 0x828C259C;
	sub_82E89080(ctx, base);
	// 828C259C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C25A0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C25A4: 485C4DAD  bl 0x82e87350
	ctx.lr = 0x828C25A8;
	sub_82E87350(ctx, base);
	// 828C25A8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828C25AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C25B0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 828C25B4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828C25B8: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 828C25BC: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C25C0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828C25C4: 419A0010  beq cr6, 0x828c25d4
	if ctx.cr[6].eq {
	pc = 0x828C25D4; continue 'dispatch;
	}
	// 828C25C8: 4B99E3F1  bl 0x822609b8
	ctx.lr = 0x828C25CC;
	sub_822609B8(ctx, base);
	// 828C25CC: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C25D0: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	pc = 0x828C25D4; continue 'dispatch;
            }
            0x828C25D4 => {
    //   block [0x828C25D4..0x828C25E8)
	// 828C25D4: C1BF003C  lfs f13, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C25D8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828C25DC: 4098000C  bge cr6, 0x828c25e8
	if !ctx.cr[6].lt {
	pc = 0x828C25E8; continue 'dispatch;
	}
	// 828C25E0: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 828C25E4: 4800002C  b 0x828c2610
	pc = 0x828C2610; continue 'dispatch;
            }
            0x828C25E8 => {
    //   block [0x828C25E8..0x828C2604)
	// 828C25E8: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C25EC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828C25F0: 40980014  bge cr6, 0x828c2604
	if !ctx.cr[6].lt {
	pc = 0x828C2604; continue 'dispatch;
	}
	// 828C25F4: 7F79DB78  mr r25, r27
	ctx.r[25].u64 = ctx.r[27].u64;
	// 828C25F8: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 828C25FC: 409A0014  bne cr6, 0x828c2610
	if !ctx.cr[6].eq {
	pc = 0x828C2610; continue 'dispatch;
	}
	// 828C2600: 4800000C  b 0x828c260c
	pc = 0x828C260C; continue 'dispatch;
            }
            0x828C2604 => {
    //   block [0x828C2604..0x828C260C)
	// 828C2604: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828C2608: 40990008  ble cr6, 0x828c2610
	if !ctx.cr[6].gt {
	pc = 0x828C2610; continue 'dispatch;
	}
	pc = 0x828C260C; continue 'dispatch;
            }
            0x828C260C => {
    //   block [0x828C260C..0x828C2610)
	// 828C260C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828C2610; continue 'dispatch;
            }
            0x828C2610 => {
    //   block [0x828C2610..0x828C263C)
	// 828C2610: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 828C2614: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2618: 409A00AC  bne cr6, 0x828c26c4
	if !ctx.cr[6].eq {
	pc = 0x828C26C4; continue 'dispatch;
	}
	// 828C261C: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 828C2620: 409A0060  bne cr6, 0x828c2680
	if !ctx.cr[6].eq {
	pc = 0x828C2680; continue 'dispatch;
	}
	// 828C2624: 4B99E395  bl 0x822609b8
	ctx.lr = 0x828C2628;
	sub_822609B8(ctx, base);
	// 828C2628: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C262C: 485BF025  bl 0x82e81650
	ctx.lr = 0x828C2630;
	sub_82E81650(ctx, base);
	// 828C2630: 897D006C  lbz r11, 0x6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C2634: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828C2638: 419A008C  beq cr6, 0x828c26c4
	if ctx.cr[6].eq {
	pc = 0x828C26C4; continue 'dispatch;
	}
	pc = 0x828C263C; continue 'dispatch;
            }
            0x828C263C => {
    //   block [0x828C263C..0x828C2680)
	// 828C263C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2640: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C2644: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 828C2648: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C264C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2650: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828C2654: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C2658: 4E800421  bctrl
	ctx.lr = 0x828C265C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C265C: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C2660: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C2664: 409A0050  bne cr6, 0x828c26b4
	if !ctx.cr[6].eq {
	pc = 0x828C26B4; continue 'dispatch;
	}
	// 828C2668: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C266C: 485BEFE5  bl 0x82e81650
	ctx.lr = 0x828C2670;
	sub_82E81650(ctx, base);
	// 828C2670: 897D006C  lbz r11, 0x6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C2674: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828C2678: 409AFFC4  bne cr6, 0x828c263c
	if !ctx.cr[6].eq {
	pc = 0x828C263C; continue 'dispatch;
	}
	// 828C267C: 48000048  b 0x828c26c4
	pc = 0x828C26C4; continue 'dispatch;
            }
            0x828C2680 => {
    //   block [0x828C2680..0x828C2688)
	// 828C2680: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 828C2684: 409A0040  bne cr6, 0x828c26c4
	if !ctx.cr[6].eq {
	pc = 0x828C26C4; continue 'dispatch;
	}
	pc = 0x828C2688; continue 'dispatch;
            }
            0x828C2688 => {
    //   block [0x828C2688..0x828C26B4)
	// 828C2688: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C268C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C2690: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 828C2694: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C2698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C269C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828C26A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C26A4: 4E800421  bctrl
	ctx.lr = 0x828C26A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C26A8: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C26AC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C26B0: 419AFFD8  beq cr6, 0x828c2688
	if ctx.cr[6].eq {
	pc = 0x828C2688; continue 'dispatch;
	}
            }
            0x828C26B4 => {
    //   block [0x828C26B4..0x828C26C4)
	// 828C26B4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C26B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C26BC: 419A0008  beq cr6, 0x828c26c4
	if ctx.cr[6].eq {
	pc = 0x828C26C4; continue 'dispatch;
	}
	// 828C26C0: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	pc = 0x828C26C4; continue 'dispatch;
            }
            0x828C26C4 => {
    //   block [0x828C26C4..0x828C26FC)
	// 828C26C4: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C26C8: 57CAE8FE  srwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shr(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C26CC: 57C9077E  clrlwi r9, r30, 0x1d
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000007u64;
	// 828C26D0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828C26D4: 7F684830  slw r8, r27, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[27].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 828C26D8: 7CEA58AE  lbzx r7, r10, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C26DC: 7D063838  and r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 828C26E0: 7CC50034  cntlzw r5, r6
	ctx.r[5].u64 = if ctx.r[6].u32 == 0 { 32 } else { ctx.r[6].u32.leading_zeros() as u64 };
	// 828C26E4: 54A4DFFE  rlwinm r4, r5, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 828C26E8: 688B0001  xori r11, r4, 1
	ctx.r[11].u64 = ctx.r[4].u64 ^ 1;
	// 828C26EC: 99780000  stb r11, 0(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828C26F0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C26F4: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828C26F8: 483E6D50  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C2700 size=84
    let mut pc: u32 = 0x828C2700;
    'dispatch: loop {
        match pc {
            0x828C2700 => {
    //   block [0x828C2700..0x828C2730)
	// 828C2700: 81640064  lwz r11, 0x64(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C2704: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2708: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 828C270C: 409A0040  bne cr6, 0x828c274c
	if !ctx.cr[6].eq {
	pc = 0x828C274C; continue 'dispatch;
	}
	// 828C2710: 81050064  lwz r8, 0x64(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C2714: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828C2718: 419A0034  beq cr6, 0x828c274c
	if ctx.cr[6].eq {
	pc = 0x828C274C; continue 'dispatch;
	}
	// 828C271C: 81230080  lwz r9, 0x80(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 828C2720: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C2724: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C2728: 419A0024  beq cr6, 0x828c274c
	if ctx.cr[6].eq {
	pc = 0x828C274C; continue 'dispatch;
	}
	// 828C272C: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	pc = 0x828C2730; continue 'dispatch;
            }
            0x828C2730 => {
    //   block [0x828C2730..0x828C274C)
	// 828C2730: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2734: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C2738: 419A001C  beq cr6, 0x828c2754
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x828C2754);
		return;
	}
	// 828C273C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C2740: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C2744: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C2748: 4198FFE8  blt cr6, 0x828c2730
	if ctx.cr[6].lt {
	pc = 0x828C2730; continue 'dispatch;
	}
	pc = 0x828C274C; continue 'dispatch;
            }
            0x828C274C => {
    //   block [0x828C274C..0x828C2754)
	// 828C274C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C2750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C2760 size=172
    let mut pc: u32 = 0x828C2760;
    'dispatch: loop {
        match pc {
            0x828C2760 => {
    //   block [0x828C2760..0x828C2790)
	// 828C2760: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 828C2764: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2768: 81640064  lwz r11, 0x64(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C276C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828C2770: 409A004C  bne cr6, 0x828c27bc
	if !ctx.cr[6].eq {
	pc = 0x828C27BC; continue 'dispatch;
	}
	// 828C2774: 80E30080  lwz r7, 0x80(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 828C2778: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C277C: 80C50064  lwz r6, 0x64(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C2780: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C2784: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C2788: 419A0034  beq cr6, 0x828c27bc
	if ctx.cr[6].eq {
	pc = 0x828C27BC; continue 'dispatch;
	}
	// 828C278C: 81030078  lwz r8, 0x78(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	pc = 0x828C2790; continue 'dispatch;
            }
            0x828C2790 => {
    //   block [0x828C2790..0x828C27AC)
	// 828C2790: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2798: 419A0014  beq cr6, 0x828c27ac
	if ctx.cr[6].eq {
	pc = 0x828C27AC; continue 'dispatch;
	}
	// 828C279C: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C27A0: 419A0028  beq cr6, 0x828c27c8
	if ctx.cr[6].eq {
	pc = 0x828C27C8; continue 'dispatch;
	}
	// 828C27A4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828C27A8: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x828C27AC; continue 'dispatch;
            }
            0x828C27AC => {
    //   block [0x828C27AC..0x828C27BC)
	// 828C27AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C27B0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 828C27B4: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 828C27B8: 4198FFD8  blt cr6, 0x828c2790
	if ctx.cr[6].lt {
	pc = 0x828C2790; continue 'dispatch;
	}
	pc = 0x828C27BC; continue 'dispatch;
            }
            0x828C27BC => {
    //   block [0x828C27BC..0x828C27C8)
	// 828C27BC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 828C27C0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 828C27C4: 4E800020  blr
	return;
            }
            0x828C27C8 => {
    //   block [0x828C27C8..0x828C280C)
	// 828C27C8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C27CC: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 828C27D0: 81060008  lwz r8, 8(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C27D4: 80E4006C  lwz r7, 0x6c(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C27D8: 80C5006C  lwz r6, 0x6c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C27DC: 80A30070  lwz r5, 0x70(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C27E0: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C27E4: 80680004  lwz r3, 4(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C27E8: 7D443850  subf r10, r4, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[4].s64;
	// 828C27EC: 7D033050  subf r8, r3, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[3].s64;
	// 828C27F0: 7CEA5B96  divwu r7, r10, r11
	ctx.r[7].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 828C27F4: 7D485B96  divwu r10, r8, r11
	ctx.r[10].u32 = ctx.r[8].u32 / ctx.r[11].u32;
	// 828C27F8: 7D6729D6  mullw r11, r7, r5
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 828C27FC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C2800: 7C6B4A14  add r3, r11, r9
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828C2804: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 828C2808: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C2810 size=456
    let mut pc: u32 = 0x828C2810;
    'dispatch: loop {
        match pc {
            0x828C2810 => {
    //   block [0x828C2810..0x828C28AC)
	// 828C2810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2814: 483E6BBD  bl 0x82ca93d0
	ctx.lr = 0x828C2818;
	sub_82CA93D0(ctx, base);
	// 828C2818: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C281C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2820: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828C2824: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 828C2828: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 828C282C: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 828C2830: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 828C2834: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2838: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 828C283C: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 828C2840: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828C2844: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C2848: 813A6C10  lwz r9, 0x6c10(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27664 as u32) ) } as u64;
	// 828C284C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C2850: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C2854: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 828C2858: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 828C285C: 93FA6C10  stw r31, 0x6c10(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 828C2860: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C2864: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2868: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 828C286C: 82A90064  lwz r21, 0x64(r9)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C2870: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 828C2874: 4B9A31B5  bl 0x82265a28
	ctx.lr = 0x828C2878;
	sub_82265A28(ctx, base);
	// 828C2878: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C287C: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 828C2880: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 828C2884: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C2888: 40990148  ble cr6, 0x828c29d0
	if !ctx.cr[6].gt {
	pc = 0x828C29D0; continue 'dispatch;
	}
	// 828C288C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828C2890: 7E96A378  mr r22, r20
	ctx.r[22].u64 = ctx.r[20].u64;
	// 828C2894: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C2898: 3A0BFFFF  addi r16, r11, -1
	ctx.r[16].s64 = ctx.r[11].s64 + -1;
	// 828C289C: 81C10064  lwz r14, 0x64(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C28A0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828C28A4: 39EAFFFF  addi r15, r10, -1
	ctx.r[15].s64 = ctx.r[10].s64 + -1;
	// 828C28A8: 3A2BA2F8  addi r17, r11, -0x5d08
	ctx.r[17].s64 = ctx.r[11].s64 + -23816;
	pc = 0x828C28AC; continue 'dispatch;
            }
            0x828C28AC => {
    //   block [0x828C28AC..0x828C28EC)
	// 828C28AC: 39710004  addi r11, r17, 4
	ctx.r[11].s64 = ctx.r[17].s64 + 4;
	// 828C28B0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828C28B4: 7D16582E  lwzx r8, r22, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C28B8: 7D5C4630  sraw r28, r10, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 828C28BC: 7DCA4630  sraw r10, r14, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[14].s32 < 0) && ((ctx.r[14].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[14].s32 >> tmp.u32) as i64;
	// 828C28C0: 7E0B4630  sraw r11, r16, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[16].s32 < 0) && ((ctx.r[16].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[16].s32 >> tmp.u32) as i64;
	// 828C28C4: 3B2B0001  addi r25, r11, 1
	ctx.r[25].s64 = ctx.r[11].s64 + 1;
	// 828C28C8: 7DEB4630  sraw r11, r15, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[15].s32 < 0) && ((ctx.r[15].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[15].s32 >> tmp.u32) as i64;
	// 828C28CC: 7E7CC851  subf. r19, r28, r25
	ctx.r[19].s64 = ctx.r[25].s64 - ctx.r[28].s64;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 828C28D0: 3A4B0001  addi r18, r11, 1
	ctx.r[18].s64 = ctx.r[11].s64 + 1;
	// 828C28D4: 418200E0  beq 0x828c29b4
	if ctx.cr[0].eq {
	pc = 0x828C29B4; continue 'dispatch;
	}
	// 828C28D8: 7D6A9051  subf. r11, r10, r18
	ctx.r[11].s64 = ctx.r[18].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C28DC: 418200D8  beq 0x828c29b4
	if ctx.cr[0].eq {
	pc = 0x828C29B4; continue 'dispatch;
	}
	// 828C28E0: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 828C28E4: 7F0A9000  cmpw cr6, r10, r18
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828C28E8: 409800CC  bge cr6, 0x828c29b4
	if !ctx.cr[6].lt {
	pc = 0x828C29B4; continue 'dispatch;
	}
	pc = 0x828C28EC; continue 'dispatch;
            }
            0x828C28EC => {
    //   block [0x828C28EC..0x828C2920)
	// 828C28EC: 81750008  lwz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C28F0: 7F1CC800  cmpw cr6, r28, r25
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[25].s32, &mut ctx.xer);
	// 828C28F4: 81550018  lwz r10, 0x18(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C28F8: 7D745A14  add r11, r20, r11
	ctx.r[11].u64 = ctx.r[20].u64 + ctx.r[11].u64;
	// 828C28FC: 7D4AB214  add r10, r10, r22
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[22].u64;
	// 828C2900: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2904: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2908: 7D69B9D6  mullw r11, r9, r23
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[23].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 828C290C: 7D0BE214  add r8, r11, r28
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 828C2910: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C2914: 7F6B5214  add r27, r11, r10
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C2918: 40980088  bge cr6, 0x828c29a0
	if !ctx.cr[6].lt {
	pc = 0x828C29A0; continue 'dispatch;
	}
	// 828C291C: 7E789B78  mr r24, r19
	ctx.r[24].u64 = ctx.r[19].u64;
	pc = 0x828C2920; continue 'dispatch;
            }
            0x828C2920 => {
    //   block [0x828C2920..0x828C292C)
	// 828C2920: 83DB0000  lwz r30, 0(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2924: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C2928: 419A006C  beq cr6, 0x828c2994
	if ctx.cr[6].eq {
	pc = 0x828C2994; continue 'dispatch;
	}
	pc = 0x828C292C; continue 'dispatch;
            }
            0x828C292C => {
    //   block [0x828C292C..0x828C2984)
	// 828C292C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2930: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C2934: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828C2938: 40980050  bge cr6, 0x828c2988
	if !ctx.cr[6].lt {
	pc = 0x828C2988; continue 'dispatch;
	}
	// 828C293C: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 828C2940: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2944: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C294C: 4B940C95  bl 0x822035e0
	ctx.lr = 0x828C2950;
	sub_822035E0(ctx, base);
	// 828C2950: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C2954: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2958: 419A002C  beq cr6, 0x828c2984
	if ctx.cr[6].eq {
	pc = 0x828C2984; continue 'dispatch;
	}
	// 828C295C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C2960: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2964: 4BC4DAC5  bl 0x82510428
	ctx.lr = 0x828C2968;
	sub_82510428(ctx, base);
	// 828C2968: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C296C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2970: 419A0014  beq cr6, 0x828c2984
	if ctx.cr[6].eq {
	pc = 0x828C2984; continue 'dispatch;
	}
	// 828C2974: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828C2978: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C297C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2980: 48286DD1  bl 0x82b49750
	ctx.lr = 0x828C2984;
	sub_82B49750(ctx, base);
	pc = 0x828C2984; continue 'dispatch;
            }
            0x828C2984 => {
    //   block [0x828C2984..0x828C2988)
	// 828C2984: 83FA6C10  lwz r31, 0x6c10(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x828C2988; continue 'dispatch;
            }
            0x828C2988 => {
    //   block [0x828C2988..0x828C2994)
	// 828C2988: 83DE0004  lwz r30, 4(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C298C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C2990: 409AFF9C  bne cr6, 0x828c292c
	if !ctx.cr[6].eq {
	pc = 0x828C292C; continue 'dispatch;
	}
	pc = 0x828C2994; continue 'dispatch;
            }
            0x828C2994 => {
    //   block [0x828C2994..0x828C29A0)
	// 828C2994: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 828C2998: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 828C299C: 4082FF84  bne 0x828c2920
	if !ctx.cr[0].eq {
	pc = 0x828C2920; continue 'dispatch;
	}
	pc = 0x828C29A0; continue 'dispatch;
            }
            0x828C29A0 => {
    //   block [0x828C29A0..0x828C29B4)
	// 828C29A0: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 828C29A4: 7F179000  cmpw cr6, r23, r18
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[18].s32, &mut ctx.xer);
	// 828C29A8: 4198FF44  blt cr6, 0x828c28ec
	if ctx.cr[6].lt {
	pc = 0x828C28EC; continue 'dispatch;
	}
	// 828C29AC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C29B0: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x828C29B4; continue 'dispatch;
            }
            0x828C29B4 => {
    //   block [0x828C29B4..0x828C29D0)
	// 828C29B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C29B8: 3A940014  addi r20, r20, 0x14
	ctx.r[20].s64 = ctx.r[20].s64 + 20;
	// 828C29BC: 3AD60010  addi r22, r22, 0x10
	ctx.r[22].s64 = ctx.r[22].s64 + 16;
	// 828C29C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C29C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C29C8: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828C29CC: 4198FEE0  blt cr6, 0x828c28ac
	if ctx.cr[6].lt {
	pc = 0x828C28AC; continue 'dispatch;
	}
	pc = 0x828C29D0; continue 'dispatch;
            }
            0x828C29D0 => {
    //   block [0x828C29D0..0x828C29D8)
	// 828C29D0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828C29D4: 483E6A4C  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C29D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C29D8 size=316
    let mut pc: u32 = 0x828C29D8;
    'dispatch: loop {
        match pc {
            0x828C29D8 => {
    //   block [0x828C29D8..0x828C29F4)
	// 828C29D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C29DC: 483E6A25  bl 0x82ca9400
	ctx.lr = 0x828C29E0;
	sub_82CA93D0(ctx, base);
	// 828C29E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C29E4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C29E8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828C29EC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828C29F0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	pc = 0x828C29F4; continue 'dispatch;
            }
            0x828C29F4 => {
    //   block [0x828C29F4..0x828C2A1C)
	// 828C29F4: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C29F8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C29FC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C2A00: 419A00F0  beq cr6, 0x828c2af0
	if ctx.cr[6].eq {
	pc = 0x828C2AF0; continue 'dispatch;
	}
	// 828C2A04: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2A08: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828C2A0C: 915C0008  stw r10, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C2A10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2A14: 409A0008  bne cr6, 0x828c2a1c
	if !ctx.cr[6].eq {
	pc = 0x828C2A1C; continue 'dispatch;
	}
	// 828C2A18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C2A1C; continue 'dispatch;
            }
            0x828C2A1C => {
    //   block [0x828C2A1C..0x828C2A34)
	// 828C2A1C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C2A20: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C2A24: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 828C2A28: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C2A2C: 41980008  blt cr6, 0x828c2a34
	if ctx.cr[6].lt {
	pc = 0x828C2A34; continue 'dispatch;
	}
	// 828C2A30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C2A34; continue 'dispatch;
            }
            0x828C2A34 => {
    //   block [0x828C2A34..0x828C2A44)
	// 828C2A34: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2A38: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C2A3C: 41990008  bgt cr6, 0x828c2a44
	if ctx.cr[6].gt {
	pc = 0x828C2A44; continue 'dispatch;
	}
	// 828C2A40: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	pc = 0x828C2A44; continue 'dispatch;
            }
            0x828C2A44 => {
    //   block [0x828C2A44..0x828C2A6C)
	// 828C2A44: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2A48: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C2A4C: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2A50: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2A54: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828C2A58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2A5C: 7FE8482E  lwzx r31, r8, r9
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 828C2A60: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C2A64: 409A0008  bne cr6, 0x828c2a6c
	if !ctx.cr[6].eq {
	pc = 0x828C2A6C; continue 'dispatch;
	}
	// 828C2A68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C2A6C; continue 'dispatch;
            }
            0x828C2A6C => {
    //   block [0x828C2A6C..0x828C2A84)
	// 828C2A6C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C2A70: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C2A74: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 828C2A78: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C2A7C: 41980008  blt cr6, 0x828c2a84
	if ctx.cr[6].lt {
	pc = 0x828C2A84; continue 'dispatch;
	}
	// 828C2A80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C2A84; continue 'dispatch;
            }
            0x828C2A84 => {
    //   block [0x828C2A84..0x828C2A94)
	// 828C2A84: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2A88: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C2A8C: 41990008  bgt cr6, 0x828c2a94
	if ctx.cr[6].gt {
	pc = 0x828C2A94; continue 'dispatch;
	}
	// 828C2A90: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	pc = 0x828C2A94; continue 'dispatch;
            }
            0x828C2A94 => {
    //   block [0x828C2A94..0x828C2AD0)
	// 828C2A94: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2A98: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C2A9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2AA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2AA4: 7FC9402E  lwzx r30, r9, r8
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828C2AA8: 419A0030  beq cr6, 0x828c2ad8
	if ctx.cr[6].eq {
	pc = 0x828C2AD8; continue 'dispatch;
	}
	// 828C2AAC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2AB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C2AB4: 419A001C  beq cr6, 0x828c2ad0
	if ctx.cr[6].eq {
	pc = 0x828C2AD0; continue 'dispatch;
	}
	// 828C2AB8: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828C2ABC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C2AC0: 4B951DD9  bl 0x82214898
	ctx.lr = 0x828C2AC4;
	sub_82214898(ctx, base);
	// 828C2AC4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2AC8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C2ACC: 4BFFFF28  b 0x828c29f4
	pc = 0x828C29F4; continue 'dispatch;
            }
            0x828C2AD0 => {
    //   block [0x828C2AD0..0x828C2AD8)
	// 828C2AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2AD4: 4B8D1365  bl 0x82193e38
	ctx.lr = 0x828C2AD8;
	sub_82193E38(ctx, base);
	pc = 0x828C2AD8; continue 'dispatch;
            }
            0x828C2AD8 => {
    //   block [0x828C2AD8..0x828C2AF0)
	// 828C2AD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C2ADC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C2AE0: 4B951DB9  bl 0x82214898
	ctx.lr = 0x828C2AE4;
	sub_82214898(ctx, base);
	// 828C2AE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2AE8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C2AEC: 4BFFFF08  b 0x828c29f4
	pc = 0x828C29F4; continue 'dispatch;
            }
            0x828C2AF0 => {
    //   block [0x828C2AF0..0x828C2B14)
	// 828C2AF0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2AF4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C2AF8: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2AFC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C2B00: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C2B04: 917B0004  stw r11, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C2B08: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C2B0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C2B10: 483E6940  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2B18 size=308
    let mut pc: u32 = 0x828C2B18;
    'dispatch: loop {
        match pc {
            0x828C2B18 => {
    //   block [0x828C2B18..0x828C2B34)
	// 828C2B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2B1C: 483E68E5  bl 0x82ca9400
	ctx.lr = 0x828C2B20;
	sub_82CA93D0(ctx, base);
	// 828C2B20: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2B24: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C2B28: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C2B2C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C2B30: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	pc = 0x828C2B34; continue 'dispatch;
            }
            0x828C2B34 => {
    //   block [0x828C2B34..0x828C2B54)
	// 828C2B34: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2B38: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2B3C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C2B40: 419A00E8  beq cr6, 0x828c2c28
	if ctx.cr[6].eq {
	pc = 0x828C2C28; continue 'dispatch;
	}
	// 828C2B44: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2B48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2B4C: 409A0008  bne cr6, 0x828c2b54
	if !ctx.cr[6].eq {
	pc = 0x828C2B54; continue 'dispatch;
	}
	// 828C2B50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C2B54; continue 'dispatch;
            }
            0x828C2B54 => {
    //   block [0x828C2B54..0x828C2B6C)
	// 828C2B54: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C2B58: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C2B5C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 828C2B60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C2B64: 41980008  blt cr6, 0x828c2b6c
	if ctx.cr[6].lt {
	pc = 0x828C2B6C; continue 'dispatch;
	}
	// 828C2B68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C2B6C; continue 'dispatch;
            }
            0x828C2B6C => {
    //   block [0x828C2B6C..0x828C2B7C)
	// 828C2B6C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2B70: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C2B74: 41990008  bgt cr6, 0x828c2b7c
	if ctx.cr[6].gt {
	pc = 0x828C2B7C; continue 'dispatch;
	}
	// 828C2B78: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	pc = 0x828C2B7C; continue 'dispatch;
            }
            0x828C2B7C => {
    //   block [0x828C2B7C..0x828C2B9C)
	// 828C2B7C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2B80: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C2B84: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2B88: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2B90: 7FC9402E  lwzx r30, r9, r8
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828C2B94: 409A0008  bne cr6, 0x828c2b9c
	if !ctx.cr[6].eq {
	pc = 0x828C2B9C; continue 'dispatch;
	}
	// 828C2B98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C2B9C; continue 'dispatch;
            }
            0x828C2B9C => {
    //   block [0x828C2B9C..0x828C2BB4)
	// 828C2B9C: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C2BA0: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C2BA4: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 828C2BA8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C2BAC: 41980008  blt cr6, 0x828c2bb4
	if ctx.cr[6].lt {
	pc = 0x828C2BB4; continue 'dispatch;
	}
	// 828C2BB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C2BB4; continue 'dispatch;
            }
            0x828C2BB4 => {
    //   block [0x828C2BB4..0x828C2BC4)
	// 828C2BB4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2BB8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C2BBC: 41990008  bgt cr6, 0x828c2bc4
	if ctx.cr[6].gt {
	pc = 0x828C2BC4; continue 'dispatch;
	}
	// 828C2BC0: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	pc = 0x828C2BC4; continue 'dispatch;
            }
            0x828C2BC4 => {
    //   block [0x828C2BC4..0x828C2BF0)
	// 828C2BC4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2BC8: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C2BCC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2BD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2BD4: 7FE9402E  lwzx r31, r9, r8
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828C2BD8: 419A0020  beq cr6, 0x828c2bf8
	if ctx.cr[6].eq {
	pc = 0x828C2BF8; continue 'dispatch;
	}
	// 828C2BDC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2BE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C2BE4: 419A000C  beq cr6, 0x828c2bf0
	if ctx.cr[6].eq {
	pc = 0x828C2BF0; continue 'dispatch;
	}
	// 828C2BE8: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828C2BEC: 48000010  b 0x828c2bfc
	pc = 0x828C2BFC; continue 'dispatch;
            }
            0x828C2BF0 => {
    //   block [0x828C2BF0..0x828C2BF8)
	// 828C2BF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C2BF4: 4B8D1245  bl 0x82193e38
	ctx.lr = 0x828C2BF8;
	sub_82193E38(ctx, base);
	pc = 0x828C2BF8; continue 'dispatch;
            }
            0x828C2BF8 => {
    //   block [0x828C2BF8..0x828C2BFC)
	// 828C2BF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x828C2BFC; continue 'dispatch;
            }
            0x828C2BFC => {
    //   block [0x828C2BFC..0x828C2C28)
	// 828C2BFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2C00: 4B951C99  bl 0x82214898
	ctx.lr = 0x828C2C04;
	sub_82214898(ctx, base);
	// 828C2C04: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2C08: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C2C0C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2C10: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 828C2C14: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C2C18: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2C1C: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 828C2C20: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C2C24: 4BFFFF10  b 0x828c2b34
	pc = 0x828C2B34; continue 'dispatch;
            }
            0x828C2C28 => {
    //   block [0x828C2C28..0x828C2C4C)
	// 828C2C28: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2C2C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C2C30: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2C34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C2C38: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C2C3C: 917B0004  stw r11, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C2C40: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C2C44: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C2C48: 483E6808  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C2C50 size=168
    let mut pc: u32 = 0x828C2C50;
    'dispatch: loop {
        match pc {
            0x828C2C50 => {
    //   block [0x828C2C50..0x828C2CF8)
	// 828C2C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2C54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2C58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2C5C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828C2C60: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2CF8 size=84
    let mut pc: u32 = 0x828C2CF8;
    'dispatch: loop {
        match pc {
            0x828C2CF8 => {
    //   block [0x828C2CF8..0x828C2D38)
	// 828C2CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2D00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2D04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2D08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C2D0C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828C2D10: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828C2D14: 392B39E0  addi r9, r11, 0x39e0
	ctx.r[9].s64 = ctx.r[11].s64 + 14816;
	// 828C2D18: 390A279C  addi r8, r10, 0x279c
	ctx.r[8].s64 = ctx.r[10].s64 + 10140;
	// 828C2D1C: 548707FE  clrlwi r7, r4, 0x1f
	ctx.r[7].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 828C2D20: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 828C2D24: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C2D28: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C2D2C: 419A000C  beq cr6, 0x828c2d38
	if ctx.cr[6].eq {
	pc = 0x828C2D38; continue 'dispatch;
	}
	// 828C2D30: 4B959009  bl 0x8221bd38
	ctx.lr = 0x828C2D34;
	sub_8221BD38(ctx, base);
	// 828C2D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x828C2D38; continue 'dispatch;
            }
            0x828C2D38 => {
    //   block [0x828C2D38..0x828C2D4C)
	// 828C2D38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2D3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2D40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2D44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C2D48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C2D50 size=172
    let mut pc: u32 = 0x828C2D50;
    'dispatch: loop {
        match pc {
            0x828C2D50 => {
    //   block [0x828C2D50..0x828C2DFC)
	// 828C2D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2D54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2D58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2D5C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2D60: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 828C2D64: C0040090  lfs f0, 0x90(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C2D68: 39400070  li r10, 0x70
	ctx.r[10].s64 = 112;
	// 828C2D6C: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 828C2D70: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828C2D74: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 828C2D78: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C2E00 size=184
    let mut pc: u32 = 0x828C2E00;
    'dispatch: loop {
        match pc {
            0x828C2E00 => {
    //   block [0x828C2E00..0x828C2EB8)
	// 828C2E00: 39600070  li r11, 0x70
	ctx.r[11].s64 = 112;
	// 828C2E04: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 828C2E08: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 828C2E0C: 38A1FFF0  addi r5, r1, -0x10
	ctx.r[5].s64 = ctx.r[1].s64 + -16;
	// 828C2E10: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C2EB8 size=8
    let mut pc: u32 = 0x828C2EB8;
    'dispatch: loop {
        match pc {
            0x828C2EB8 => {
    //   block [0x828C2EB8..0x828C2EC0)
	// 828C2EB8: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828C2EBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2EC0 size=116
    let mut pc: u32 = 0x828C2EC0;
    'dispatch: loop {
        match pc {
            0x828C2EC0 => {
    //   block [0x828C2EC0..0x828C2EFC)
	// 828C2EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2EC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2EC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2ECC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2ED0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C2ED4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828C2ED8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C2EDC: 392B0DE4  addi r9, r11, 0xde4
	ctx.r[9].s64 = ctx.r[11].s64 + 3556;
	// 828C2EE0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C2EE4: 995F0004  stb r10, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 828C2EE8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C2EEC: 4B95C36D  bl 0x8221f258
	ctx.lr = 0x828C2EF0;
	sub_8221F258(ctx, base);
	// 828C2EF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C2EF4: 419A0008  beq cr6, 0x828c2efc
	if ctx.cr[6].eq {
	pc = 0x828C2EFC; continue 'dispatch;
	}
	// 828C2EF8: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x828C2EFC; continue 'dispatch;
            }
            0x828C2EFC => {
    //   block [0x828C2EFC..0x828C2F08)
	// 828C2EFC: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C2F00: 41820008  beq 0x828c2f08
	if ctx.cr[0].eq {
	pc = 0x828C2F08; continue 'dispatch;
	}
	// 828C2F04: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x828C2F08; continue 'dispatch;
            }
            0x828C2F08 => {
    //   block [0x828C2F08..0x828C2F34)
	// 828C2F08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C2F0C: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 828C2F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2F14: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828C2F18: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 828C2F1C: 997F0018  stb r11, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 828C2F20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2F24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2F28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2F2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C2F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2F38 size=88
    let mut pc: u32 = 0x828C2F38;
    'dispatch: loop {
        match pc {
            0x828C2F38 => {
    //   block [0x828C2F38..0x828C2F7C)
	// 828C2F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2F40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2F44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2F48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C2F4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2F50: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2F54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C2F58: 4E800421  bctrl
	ctx.lr = 0x828C2F5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C2F5C: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828C2F60: 81696B08  lwz r11, 0x6b08(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C2F64: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C2F68: 4BB19C79  bl 0x823dcbe0
	ctx.lr = 0x828C2F6C;
	sub_823DCBE0(ctx, base);
	// 828C2F6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C2F70: 419A000C  beq cr6, 0x828c2f7c
	if ctx.cr[6].eq {
	pc = 0x828C2F7C; continue 'dispatch;
	}
	// 828C2F74: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 828C2F78: 4812B039  bl 0x829edfb0
	ctx.lr = 0x828C2F7C;
	sub_829EDFB0(ctx, base);
            }
            0x828C2F7C => {
    //   block [0x828C2F7C..0x828C2F90)
	// 828C2F7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2F80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2F84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2F88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C2F8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C2F90 size=8
    let mut pc: u32 = 0x828C2F90;
    'dispatch: loop {
        match pc {
            0x828C2F90 => {
    //   block [0x828C2F90..0x828C2F98)
	// 828C2F90: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 828C2F94: 4BEDDE84  b 0x827a0e18
	sub_827A0E18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2F98 size=268
    let mut pc: u32 = 0x828C2F98;
    'dispatch: loop {
        match pc {
            0x828C2F98 => {
    //   block [0x828C2F98..0x828C2FBC)
	// 828C2F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2F9C: 483E6465  bl 0x82ca9400
	ctx.lr = 0x828C2FA0;
	sub_82CA93D0(ctx, base);
	// 828C2FA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2FA4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828C2FA8: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 828C2FAC: 3BBA0008  addi r29, r26, 8
	ctx.r[29].s64 = ctx.r[26].s64 + 8;
	// 828C2FB0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828C2FB4: 817A000C  lwz r11, 0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C2FB8: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C2FBC; continue 'dispatch;
            }
            0x828C2FBC => {
    //   block [0x828C2FBC..0x828C2FCC)
	// 828C2FBC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2FC0: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828C2FC4: 419A0008  beq cr6, 0x828c2fcc
	if ctx.cr[6].eq {
	pc = 0x828C2FCC; continue 'dispatch;
	}
	// 828C2FC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C2FCC; continue 'dispatch;
            }
            0x828C2FCC => {
    //   block [0x828C2FCC..0x828C2FEC)
	// 828C2FCC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C2FD0: 419A0064  beq cr6, 0x828c3034
	if ctx.cr[6].eq {
	pc = 0x828C3034; continue 'dispatch;
	}
	// 828C2FD4: 817C6B08  lwz r11, 0x6b08(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C2FD8: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2FDC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C2FE0: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C2FE4: 409A0008  bne cr6, 0x828c2fec
	if !ctx.cr[6].eq {
	pc = 0x828C2FEC; continue 'dispatch;
	}
	// 828C2FE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C2FEC; continue 'dispatch;
            }
            0x828C2FEC => {
    //   block [0x828C2FEC..0x828C301C)
	// 828C2FEC: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C2FF0: 4BB19BF1  bl 0x823dcbe0
	ctx.lr = 0x828C2FF4;
	sub_823DCBE0(ctx, base);
	// 828C2FF4: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C2FF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C2FFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C3000: 419A001C  beq cr6, 0x828c301c
	if ctx.cr[6].eq {
	pc = 0x828C301C; continue 'dispatch;
	}
	// 828C3004: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C3008: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 828C300C: 41810010  bgt 0x828c301c
	if ctx.cr[0].gt {
	pc = 0x828C301C; continue 'dispatch;
	}
	// 828C3010: 937F0040  stw r27, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[27].u32 ) };
	// 828C3014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3018: 4812A661  bl 0x829ed678
	ctx.lr = 0x828C301C;
	sub_829ED678(ctx, base);
	pc = 0x828C301C; continue 'dispatch;
            }
            0x828C301C => {
    //   block [0x828C301C..0x828C302C)
	// 828C301C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3020: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C3024: 409A0008  bne cr6, 0x828c302c
	if !ctx.cr[6].eq {
	pc = 0x828C302C; continue 'dispatch;
	}
	// 828C3028: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C302C; continue 'dispatch;
            }
            0x828C302C => {
    //   block [0x828C302C..0x828C3034)
	// 828C302C: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3030: 4BFFFF8C  b 0x828c2fbc
	pc = 0x828C2FBC; continue 'dispatch;
            }
            0x828C3034 => {
    //   block [0x828C3034..0x828C3064)
	// 828C3034: 897A0018  lbz r11, 0x18(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C3038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C303C: 419A0060  beq cr6, 0x828c309c
	if ctx.cr[6].eq {
	pc = 0x828C309C; continue 'dispatch;
	}
	// 828C3040: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C3044: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3048: 419A0050  beq cr6, 0x828c3098
	if ctx.cr[6].eq {
	pc = 0x828C3098; continue 'dispatch;
	}
	// 828C304C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3050: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C3054: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3058: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C305C: 409A0008  bne cr6, 0x828c3064
	if !ctx.cr[6].eq {
	pc = 0x828C3064; continue 'dispatch;
	}
	// 828C3060: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C3064; continue 'dispatch;
            }
            0x828C3064 => {
    //   block [0x828C3064..0x828C3084)
	// 828C3064: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C3068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C306C: 419A0030  beq cr6, 0x828c309c
	if ctx.cr[6].eq {
	pc = 0x828C309C; continue 'dispatch;
	}
	// 828C3070: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C3074: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C3078: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C307C: 41990008  bgt cr6, 0x828c3084
	if ctx.cr[6].gt {
	pc = 0x828C3084; continue 'dispatch;
	}
	// 828C3080: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x828C3084; continue 'dispatch;
            }
            0x828C3084 => {
    //   block [0x828C3084..0x828C3098)
	// 828C3084: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C3088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C308C: 409A0010  bne cr6, 0x828c309c
	if !ctx.cr[6].eq {
	pc = 0x828C309C; continue 'dispatch;
	}
	// 828C3090: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C3094: 480003F5  bl 0x828c3488
	ctx.lr = 0x828C3098;
	sub_828C3488(ctx, base);
	pc = 0x828C3098; continue 'dispatch;
            }
            0x828C3098 => {
    //   block [0x828C3098..0x828C309C)
	// 828C3098: 9B7A0018  stb r27, 0x18(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	pc = 0x828C309C; continue 'dispatch;
            }
            0x828C309C => {
    //   block [0x828C309C..0x828C30A4)
	// 828C309C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C30A0: 483E63B0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C30A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C30A8 size=420
    let mut pc: u32 = 0x828C30A8;
    'dispatch: loop {
        match pc {
            0x828C30A8 => {
    //   block [0x828C30A8..0x828C3104)
	// 828C30A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C30AC: 483E6349  bl 0x82ca93f4
	ctx.lr = 0x828C30B0;
	sub_82CA93D0(ctx, base);
	// 828C30B0: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 828C30B4: 483EAC25  bl 0x82cadcd8
	ctx.lr = 0x828C30B8;
	sub_82CADCA0(ctx, base);
	// 828C30B8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C30BC: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828C30C0: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 828C30C4: 2F04001B  cmpwi cr6, r4, 0x1b
	ctx.cr[6].compare_i32(ctx.r[4].s32, 27, &mut ctx.xer);
	// 828C30C8: 409A0174  bne cr6, 0x828c323c
	if !ctx.cr[6].eq {
	pc = 0x828C323C; continue 'dispatch;
	}
	// 828C30CC: 8177000C  lwz r11, 0xc(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C30D0: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 828C30D4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828C30D8: 3BB70008  addi r29, r23, 8
	ctx.r[29].s64 = ctx.r[23].s64 + 8;
	// 828C30DC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828C30E0: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 828C30E4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C30E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C30EC: C38A0FF0  lfs f28, 0xff0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4080 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828C30F0: 3B6B9484  addi r27, r11, -0x6b7c
	ctx.r[27].s64 = ctx.r[11].s64 + -27516;
	// 828C30F4: CBA90DF0  lfd f29, 0xdf0(r9)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3568 as u32) ) };
	// 828C30F8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 828C30FC: 3B4B0E68  addi r26, r11, 0xe68
	ctx.r[26].s64 = ctx.r[11].s64 + 3688;
	// 828C3100: C3DB0000  lfs f30, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x828C3104; continue 'dispatch;
            }
            0x828C3104 => {
    //   block [0x828C3104..0x828C3114)
	// 828C3104: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3108: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828C310C: 419A0008  beq cr6, 0x828c3114
	if ctx.cr[6].eq {
	pc = 0x828C3114; continue 'dispatch;
	}
	// 828C3110: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C3114; continue 'dispatch;
            }
            0x828C3114 => {
    //   block [0x828C3114..0x828C3134)
	// 828C3114: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C3118: 419A00DC  beq cr6, 0x828c31f4
	if ctx.cr[6].eq {
	pc = 0x828C31F4; continue 'dispatch;
	}
	// 828C311C: 817C6B08  lwz r11, 0x6b08(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C3120: 2B180002  cmplwi cr6, r24, 2
	ctx.cr[6].compare_u32(ctx.r[24].u32, 2 as u32, &mut ctx.xer);
	// 828C3124: 83EB0038  lwz r31, 0x38(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C3128: 409A000C  bne cr6, 0x828c3134
	if !ctx.cr[6].eq {
	pc = 0x828C3134; continue 'dispatch;
	}
	// 828C312C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C3130: 48000008  b 0x828c3138
	pc = 0x828C3138; continue 'dispatch;
            }
            0x828C3134 => {
    //   block [0x828C3134..0x828C3138)
	// 828C3134: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	pc = 0x828C3138; continue 'dispatch;
            }
            0x828C3138 => {
    //   block [0x828C3138..0x828C317C)
	// 828C3138: E96B0018  ld r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 828C313C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828C3140: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C3144: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3148: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 828C314C: 4B93B35D  bl 0x821fe4a8
	ctx.lr = 0x828C3150;
	sub_821FE4A8(ctx, base);
	// 828C3150: C1A10050  lfs f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C3154: FFE00818  frsp f31, f1
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 828C3158: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828C315C: FC206850  fneg f1, f13
	ctx.f[1].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 828C3160: 4B93B349  bl 0x821fe4a8
	ctx.lr = 0x828C3164;
	sub_821FE4A8(ctx, base);
	// 828C3164: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 828C3168: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828C316C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 828C3170: 4099000C  ble cr6, 0x828c317c
	if !ctx.cr[6].gt {
	pc = 0x828C317C; continue 'dispatch;
	}
	// 828C3174: C01B2324  lfs f0, 0x2324(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8996 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3178: 48000020  b 0x828c3198
	pc = 0x828C3198; continue 'dispatch;
            }
            0x828C317C => {
    //   block [0x828C317C..0x828C3198)
	// 828C317C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 828C3180: 7D600026  mfcr r11
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[11].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 828C3184: 556ADF7A  rlwinm r10, r11, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C3188: 5569F77A  rlwinm r9, r11, 0x1e, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 828C318C: 7D484B78  or r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 828C3190: 7C1A442E  lfsx f0, r26, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3194: FC00E7AE  fsel f0, f0, f30, f28
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[28].f64 };
	pc = 0x828C3198; continue 'dispatch;
            }
            0x828C3198 => {
    //   block [0x828C3198..0x828C31B0)
	// 828C3198: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C319C: EC1F002A  fadds f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 828C31A0: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828C31A4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C31A8: 409A0008  bne cr6, 0x828c31b0
	if !ctx.cr[6].eq {
	pc = 0x828C31B0; continue 'dispatch;
	}
	// 828C31AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C31B0; continue 'dispatch;
            }
            0x828C31B0 => {
    //   block [0x828C31B0..0x828C31DC)
	// 828C31B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C31B4: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C31B8: 4BB19A29  bl 0x823dcbe0
	ctx.lr = 0x828C31BC;
	sub_823DCBE0(ctx, base);
	// 828C31BC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C31C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C31C4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C31C8: 4812A5C1  bl 0x829ed788
	ctx.lr = 0x828C31CC;
	sub_829ED788(ctx, base);
	// 828C31CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C31D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C31D4: 419A0008  beq cr6, 0x828c31dc
	if ctx.cr[6].eq {
	pc = 0x828C31DC; continue 'dispatch;
	}
	// 828C31D8: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	pc = 0x828C31DC; continue 'dispatch;
            }
            0x828C31DC => {
    //   block [0x828C31DC..0x828C31EC)
	// 828C31DC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C31E0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C31E4: 409A0008  bne cr6, 0x828c31ec
	if !ctx.cr[6].eq {
	pc = 0x828C31EC; continue 'dispatch;
	}
	// 828C31E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C31EC; continue 'dispatch;
            }
            0x828C31EC => {
    //   block [0x828C31EC..0x828C31F4)
	// 828C31EC: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C31F0: 4BFFFF14  b 0x828c3104
	pc = 0x828C3104; continue 'dispatch;
            }
            0x828C31F4 => {
    //   block [0x828C31F4..0x828C323C)
	// 828C31F4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828C31F8: 48000291  bl 0x828c3488
	ctx.lr = 0x828C31FC;
	sub_828C3488(ctx, base);
	// 828C31FC: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 828C3200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3204: 419A0038  beq cr6, 0x828c323c
	if ctx.cr[6].eq {
	pc = 0x828C323C; continue 'dispatch;
	}
	// 828C3208: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C320C: 809C6B08  lwz r4, 0x6b08(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C3210: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C3214: 38AB7E20  addi r5, r11, 0x7e20
	ctx.r[5].s64 = ctx.r[11].s64 + 32288;
	// 828C3218: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C321C: 4BAAEC65  bl 0x82371e80
	ctx.lr = 0x828C3220;
	sub_82371E80(ctx, base);
	// 828C3220: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C3224: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C3228: 419A0014  beq cr6, 0x828c323c
	if ctx.cr[6].eq {
	pc = 0x828C323C; continue 'dispatch;
	}
	// 828C322C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3230: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3234: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C3238: 4E800421  bctrl
	ctx.lr = 0x828C323C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C323C => {
    //   block [0x828C323C..0x828C324C)
	// 828C323C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828C3240: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 828C3244: 483EAAE1  bl 0x82cadd24
	ctx.lr = 0x828C3248;
	sub_82CADCEC(ctx, base);
	// 828C3248: 483E61FC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3250 size=264
    let mut pc: u32 = 0x828C3250;
    'dispatch: loop {
        match pc {
            0x828C3250 => {
    //   block [0x828C3250..0x828C32E0)
	// 828C3250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3254: 483E61B5  bl 0x82ca9408
	ctx.lr = 0x828C3258;
	sub_82CA93D0(ctx, base);
	// 828C3258: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C325C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C3260: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C3264: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C3268: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828C326C: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C3270: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C3274: 4BB1996D  bl 0x823dcbe0
	ctx.lr = 0x828C3278;
	sub_823DCBE0(ctx, base);
	// 828C3278: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C327C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C3280: 419A00C8  beq cr6, 0x828c3348
	if ctx.cr[6].eq {
	pc = 0x828C3348; continue 'dispatch;
	}
	// 828C3284: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C3288: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C328C: 4B92CFB5  bl 0x821f0240
	ctx.lr = 0x828C3290;
	sub_821F0240(ctx, base);
	// 828C3290: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3294: 4BB63505  bl 0x82426798
	ctx.lr = 0x828C3298;
	sub_82426798(ctx, base);
	// 828C3298: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C329C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C32A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C32A4: 4B92CF9D  bl 0x821f0240
	ctx.lr = 0x828C32A8;
	sub_821F0240(ctx, base);
	// 828C32A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C32AC: 4BB634ED  bl 0x82426798
	ctx.lr = 0x828C32B0;
	sub_82426798(ctx, base);
	// 828C32B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C32B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C32B8: 419A0090  beq cr6, 0x828c3348
	if ctx.cr[6].eq {
	pc = 0x828C3348; continue 'dispatch;
	}
	// 828C32BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C32C0: 419A0088  beq cr6, 0x828c3348
	if ctx.cr[6].eq {
	pc = 0x828C3348; continue 'dispatch;
	}
	// 828C32C4: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 828C32C8: 4B95BF91  bl 0x8221f258
	ctx.lr = 0x828C32CC;
	sub_8221F258(ctx, base);
	// 828C32CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C32D0: 419A0010  beq cr6, 0x828c32e0
	if ctx.cr[6].eq {
	pc = 0x828C32E0; continue 'dispatch;
	}
	// 828C32D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C32D8: 4812A299  bl 0x829ed570
	ctx.lr = 0x828C32DC;
	sub_829ED570(ctx, base);
	// 828C32DC: 48000008  b 0x828c32e4
	pc = 0x828C32E4; continue 'dispatch;
            }
            0x828C32E0 => {
    //   block [0x828C32E0..0x828C32E4)
	// 828C32E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x828C32E4; continue 'dispatch;
            }
            0x828C32E4 => {
    //   block [0x828C32E4..0x828C32FC)
	// 828C32E4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828C32E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C32EC: 419A0010  beq cr6, 0x828c32fc
	if ctx.cr[6].eq {
	pc = 0x828C32FC; continue 'dispatch;
	}
	// 828C32F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C32F4: 481419CD  bl 0x82a04cc0
	ctx.lr = 0x828C32F8;
	sub_82A04CC0(ctx, base);
	// 828C32F8: 4800000C  b 0x828c3304
	pc = 0x828C3304; continue 'dispatch;
            }
            0x828C32FC => {
    //   block [0x828C32FC..0x828C3304)
	// 828C32FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C3300: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x828C3304; continue 'dispatch;
            }
            0x828C3304 => {
    //   block [0x828C3304..0x828C3348)
	// 828C3304: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C3308: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C330C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C3310: 4812AAD9  bl 0x829edde8
	ctx.lr = 0x828C3314;
	sub_829EDDE8(ctx, base);
	// 828C3314: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C3318: 387C0008  addi r3, r28, 8
	ctx.r[3].s64 = ctx.r[28].s64 + 8;
	// 828C331C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C3320: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 828C3324: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828C3328: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C332C: 4BD5A7BD  bl 0x8261dae8
	ctx.lr = 0x828C3330;
	sub_8261DAE8(ctx, base);
	// 828C3330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3334: 4B8F47E5  bl 0x821b7b18
	ctx.lr = 0x828C3338;
	sub_821B7B18(ctx, base);
	// 828C3338: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C333C: 995C0018  stb r10, 0x18(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 828C3340: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C3344: 483E6114  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x828C3348 => {
    //   block [0x828C3348..0x828C3358)
	// 828C3348: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C334C: 997C0018  stb r11, 0x18(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 828C3350: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C3354: 483E6104  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3358 size=148
    let mut pc: u32 = 0x828C3358;
    'dispatch: loop {
        match pc {
            0x828C3358 => {
    //   block [0x828C3358..0x828C3390)
	// 828C3358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C335C: 483E60AD  bl 0x82ca9408
	ctx.lr = 0x828C3360;
	sub_82CA93D0(ctx, base);
	// 828C3360: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3364: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C3368: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C336C: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C3370: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C3374: 4BB1986D  bl 0x823dcbe0
	ctx.lr = 0x828C3378;
	sub_823DCBE0(ctx, base);
	// 828C3378: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C337C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C3380: 419A0064  beq cr6, 0x828c33e4
	if ctx.cr[6].eq {
	pc = 0x828C33E4; continue 'dispatch;
	}
	// 828C3384: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C3388: 3BDC0008  addi r30, r28, 8
	ctx.r[30].s64 = ctx.r[28].s64 + 8;
	// 828C338C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C3390; continue 'dispatch;
            }
            0x828C3390 => {
    //   block [0x828C3390..0x828C33A0)
	// 828C3390: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3394: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828C3398: 419A0008  beq cr6, 0x828c33a0
	if ctx.cr[6].eq {
	pc = 0x828C33A0; continue 'dispatch;
	}
	// 828C339C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C33A0; continue 'dispatch;
            }
            0x828C33A0 => {
    //   block [0x828C33A0..0x828C33B8)
	// 828C33A0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C33A4: 419A0038  beq cr6, 0x828c33dc
	if ctx.cr[6].eq {
	pc = 0x828C33DC; continue 'dispatch;
	}
	// 828C33A8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C33AC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C33B0: 409A0008  bne cr6, 0x828c33b8
	if !ctx.cr[6].eq {
	pc = 0x828C33B8; continue 'dispatch;
	}
	// 828C33B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C33B8; continue 'dispatch;
            }
            0x828C33B8 => {
    //   block [0x828C33B8..0x828C33D4)
	// 828C33B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C33BC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C33C0: 4812AB11  bl 0x829eded0
	ctx.lr = 0x828C33C4;
	sub_829EDED0(ctx, base);
	// 828C33C4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C33C8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C33CC: 409A0008  bne cr6, 0x828c33d4
	if !ctx.cr[6].eq {
	pc = 0x828C33D4; continue 'dispatch;
	}
	// 828C33D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C33D4; continue 'dispatch;
            }
            0x828C33D4 => {
    //   block [0x828C33D4..0x828C33DC)
	// 828C33D4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C33D8: 4BFFFFB8  b 0x828c3390
	pc = 0x828C3390; continue 'dispatch;
            }
            0x828C33DC => {
    //   block [0x828C33DC..0x828C33E4)
	// 828C33DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C33E0: 997C0018  stb r11, 0x18(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	pc = 0x828C33E4; continue 'dispatch;
            }
            0x828C33E4 => {
    //   block [0x828C33E4..0x828C33EC)
	// 828C33E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C33E8: 483E6070  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C33F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C33F0 size=148
    let mut pc: u32 = 0x828C33F0;
    'dispatch: loop {
        match pc {
            0x828C33F0 => {
    //   block [0x828C33F0..0x828C341C)
	// 828C33F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C33F4: 483E6019  bl 0x82ca940c
	ctx.lr = 0x828C33F8;
	sub_82CA93D0(ctx, base);
	// 828C33F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C33FC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828C3400: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C3404: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C340C: 419A0010  beq cr6, 0x828c341c
	if ctx.cr[6].eq {
	pc = 0x828C341C; continue 'dispatch;
	}
	// 828C3410: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3414: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C3418: 409A0014  bne cr6, 0x828c342c
	if !ctx.cr[6].eq {
	pc = 0x828C342C; continue 'dispatch;
	}
	pc = 0x828C341C; continue 'dispatch;
            }
            0x828C341C => {
    //   block [0x828C341C..0x828C342C)
	// 828C341C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C3420: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 828C3424: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C3428: 483E6034  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x828C342C => {
    //   block [0x828C342C..0x828C347C)
	// 828C342C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C3430: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C3434: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C3438: 4BB197A9  bl 0x823dcbe0
	ctx.lr = 0x828C343C;
	sub_823DCBE0(ctx, base);
	// 828C343C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C3440: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C3444: 419A0038  beq cr6, 0x828c347c
	if ctx.cr[6].eq {
	pc = 0x828C347C; continue 'dispatch;
	}
	// 828C3448: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C344C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3450: 4B92CDF1  bl 0x821f0240
	ctx.lr = 0x828C3454;
	sub_821F0240(ctx, base);
	// 828C3454: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3458: 4BB63341  bl 0x82426798
	ctx.lr = 0x828C345C;
	sub_82426798(ctx, base);
	// 828C345C: 907E0014  stw r3, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 828C3460: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C3464: 419A0018  beq cr6, 0x828c347c
	if ctx.cr[6].eq {
	pc = 0x828C347C; continue 'dispatch;
	}
	// 828C3468: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C346C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3470: 4BB62DF1  bl 0x82426260
	ctx.lr = 0x828C3474;
	sub_82426260(ctx, base);
	// 828C3474: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3478: 4BFFFEE1  bl 0x828c3358
	ctx.lr = 0x828C347C;
	sub_828C3358(ctx, base);
	pc = 0x828C347C; continue 'dispatch;
            }
            0x828C347C => {
    //   block [0x828C347C..0x828C3484)
	// 828C347C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C3480: 483E5FDC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C3488 size=580
    let mut pc: u32 = 0x828C3488;
    'dispatch: loop {
        match pc {
            0x828C3488 => {
    //   block [0x828C3488..0x828C34F4)
	// 828C3488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C348C: 483E5F71  bl 0x82ca93fc
	ctx.lr = 0x828C3490;
	sub_82CA93D0(ctx, base);
	// 828C3490: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 828C3494: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 828C3498: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828C349C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C34A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C34A4: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C34A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C34AC: 419A020C  beq cr6, 0x828c36b8
	if ctx.cr[6].eq {
	pc = 0x828C36B8; continue 'dispatch;
	}
	// 828C34B0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C34B4: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C34B8: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C34BC: 4BB19725  bl 0x823dcbe0
	ctx.lr = 0x828C34C0;
	sub_823DCBE0(ctx, base);
	// 828C34C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C34C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C34C8: 419A01F0  beq cr6, 0x828c36b8
	if ctx.cr[6].eq {
	pc = 0x828C36B8; continue 'dispatch;
	}
	// 828C34CC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C34D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C34D4: 40990034  ble cr6, 0x828c3508
	if !ctx.cr[6].gt {
	pc = 0x828C3508; continue 'dispatch;
	}
	// 828C34D8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C34DC: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 828C34E0: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C34E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C34E8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C34EC: 409A0008  bne cr6, 0x828c34f4
	if !ctx.cr[6].eq {
	pc = 0x828C34F4; continue 'dispatch;
	}
	// 828C34F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C34F4; continue 'dispatch;
            }
            0x828C34F4 => {
    //   block [0x828C34F4..0x828C3508)
	// 828C34F4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C34F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C34FC: 419A000C  beq cr6, 0x828c3508
	if ctx.cr[6].eq {
	pc = 0x828C3508; continue 'dispatch;
	}
	// 828C3500: 896B0024  lbz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C3504: 48000008  b 0x828c350c
	pc = 0x828C350C; continue 'dispatch;
            }
            0x828C3508 => {
    //   block [0x828C3508..0x828C350C)
	// 828C3508: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C350C; continue 'dispatch;
            }
            0x828C350C => {
    //   block [0x828C350C..0x828C35C0)
	// 828C350C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C3510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3514: 419A0180  beq cr6, 0x828c3694
	if ctx.cr[6].eq {
	pc = 0x828C3694; continue 'dispatch;
	}
	// 828C3518: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C351C: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C3520: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C3524: 388B30AC  addi r4, r11, 0x30ac
	ctx.r[4].s64 = ctx.r[11].s64 + 12460;
	// 828C3528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C352C: 4B9699A5  bl 0x8222ced0
	ctx.lr = 0x828C3530;
	sub_8222CED0(ctx, base);
	// 828C3530: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C3534: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C3538: 4BB63069  bl 0x824265a0
	ctx.lr = 0x828C353C;
	sub_824265A0(ctx, base);
	// 828C353C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C3540: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C3544: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C3548: 388A30B4  addi r4, r10, 0x30b4
	ctx.r[4].s64 = ctx.r[10].s64 + 12468;
	// 828C354C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C3550: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C3554: 4B96997D  bl 0x8222ced0
	ctx.lr = 0x828C3558;
	sub_8222CED0(ctx, base);
	// 828C3558: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C355C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C3560: 4BB63041  bl 0x824265a0
	ctx.lr = 0x828C3564;
	sub_824265A0(ctx, base);
	// 828C3564: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828C3568: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828C356C: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C3570: 388930C0  addi r4, r9, 0x30c0
	ctx.r[4].s64 = ctx.r[9].s64 + 12480;
	// 828C3574: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C3578: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C357C: 4B969955  bl 0x8222ced0
	ctx.lr = 0x828C3580;
	sub_8222CED0(ctx, base);
	// 828C3580: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C3584: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C3588: 4BB63019  bl 0x824265a0
	ctx.lr = 0x828C358C;
	sub_824265A0(ctx, base);
	// 828C358C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C3590: 811E0010  lwz r8, 0x10(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C3594: 3B2BBE08  addi r25, r11, -0x41f8
	ctx.r[25].s64 = ctx.r[11].s64 + -16888;
	// 828C3598: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C359C: C3B9D67C  lfs f29, -0x2984(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-10628 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828C35A0: 40990034  ble cr6, 0x828c35d4
	if !ctx.cr[6].gt {
	pc = 0x828C35D4; continue 'dispatch;
	}
	// 828C35A4: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C35A8: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 828C35AC: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C35B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C35B4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C35B8: 409A0008  bne cr6, 0x828c35c0
	if !ctx.cr[6].eq {
	pc = 0x828C35C0; continue 'dispatch;
	}
	// 828C35BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C35C0; continue 'dispatch;
            }
            0x828C35C0 => {
    //   block [0x828C35C0..0x828C35D4)
	// 828C35C0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C35C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C35C8: 419A000C  beq cr6, 0x828c35d4
	if ctx.cr[6].eq {
	pc = 0x828C35D4; continue 'dispatch;
	}
	// 828C35CC: C3EB0020  lfs f31, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C35D0: 48000008  b 0x828c35d8
	pc = 0x828C35D8; continue 'dispatch;
            }
            0x828C35D4 => {
    //   block [0x828C35D4..0x828C35D8)
	// 828C35D4: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	pc = 0x828C35D8; continue 'dispatch;
            }
            0x828C35D8 => {
    //   block [0x828C35D8..0x828C3614)
	// 828C35D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C35DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C35E0: 4BB637A1  bl 0x82426d80
	ctx.lr = 0x828C35E4;
	sub_82426D80(ctx, base);
	// 828C35E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C35E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C35EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C35F0: 4BB63791  bl 0x82426d80
	ctx.lr = 0x828C35F4;
	sub_82426D80(ctx, base);
	// 828C35F4: C3D9D688  lfs f30, -0x2978(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-10616 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828C35F8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C35FC: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 828C3600: 409A0014  bne cr6, 0x828c3614
	if !ctx.cr[6].eq {
	pc = 0x828C3614; continue 'dispatch;
	}
	// 828C3604: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 828C3608: 419A0054  beq cr6, 0x828c365c
	if ctx.cr[6].eq {
	pc = 0x828C365C; continue 'dispatch;
	}
	// 828C360C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C3610: 48000040  b 0x828c3650
	pc = 0x828C3650; continue 'dispatch;
            }
            0x828C3614 => {
    //   block [0x828C3614..0x828C3634)
	// 828C3614: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 828C3618: 409A002C  bne cr6, 0x828c3644
	if !ctx.cr[6].eq {
	pc = 0x828C3644; continue 'dispatch;
	}
	// 828C361C: 2B1D0002  cmplwi cr6, r29, 2
	ctx.cr[6].compare_u32(ctx.r[29].u32, 2 as u32, &mut ctx.xer);
	// 828C3620: 419A0014  beq cr6, 0x828c3634
	if ctx.cr[6].eq {
	pc = 0x828C3634; continue 'dispatch;
	}
	// 828C3624: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828C3628: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C362C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C3630: 4BB63579  bl 0x82426ba8
	ctx.lr = 0x828C3634;
	sub_82426BA8(ctx, base);
	pc = 0x828C3634; continue 'dispatch;
            }
            0x828C3634 => {
    //   block [0x828C3634..0x828C3644)
	// 828C3634: 2B1B0001  cmplwi cr6, r27, 1
	ctx.cr[6].compare_u32(ctx.r[27].u32, 1 as u32, &mut ctx.xer);
	// 828C3638: 419A003C  beq cr6, 0x828c3674
	if ctx.cr[6].eq {
	pc = 0x828C3674; continue 'dispatch;
	}
	// 828C363C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C3640: 48000028  b 0x828c3668
	pc = 0x828C3668; continue 'dispatch;
            }
            0x828C3644 => {
    //   block [0x828C3644..0x828C3650)
	// 828C3644: 2B1D0002  cmplwi cr6, r29, 2
	ctx.cr[6].compare_u32(ctx.r[29].u32, 2 as u32, &mut ctx.xer);
	// 828C3648: 419A0014  beq cr6, 0x828c365c
	if ctx.cr[6].eq {
	pc = 0x828C365C; continue 'dispatch;
	}
	// 828C364C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	pc = 0x828C3650; continue 'dispatch;
            }
            0x828C3650 => {
    //   block [0x828C3650..0x828C365C)
	// 828C3650: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3654: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C3658: 4BB63551  bl 0x82426ba8
	ctx.lr = 0x828C365C;
	sub_82426BA8(ctx, base);
	pc = 0x828C365C; continue 'dispatch;
            }
            0x828C365C => {
    //   block [0x828C365C..0x828C3668)
	// 828C365C: 2B1B0002  cmplwi cr6, r27, 2
	ctx.cr[6].compare_u32(ctx.r[27].u32, 2 as u32, &mut ctx.xer);
	// 828C3660: 419A0014  beq cr6, 0x828c3674
	if ctx.cr[6].eq {
	pc = 0x828C3674; continue 'dispatch;
	}
	// 828C3664: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	pc = 0x828C3668; continue 'dispatch;
            }
            0x828C3668 => {
    //   block [0x828C3668..0x828C3674)
	// 828C3668: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C366C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C3670: 4BB63539  bl 0x82426ba8
	ctx.lr = 0x828C3674;
	sub_82426BA8(ctx, base);
	pc = 0x828C3674; continue 'dispatch;
            }
            0x828C3674 => {
    //   block [0x828C3674..0x828C3694)
	// 828C3674: EDBEF828  fsubs f13, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 828C3678: C0190000  lfs f0, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C367C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3680: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C3684: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828C3688: 4BB63799  bl 0x82426e20
	ctx.lr = 0x828C368C;
	sub_82426E20(ctx, base);
	// 828C368C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C3690: 4800001C  b 0x828c36ac
	pc = 0x828C36AC; continue 'dispatch;
            }
            0x828C3694 => {
    //   block [0x828C3694..0x828C36AC)
	// 828C3694: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C3698: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C369C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C36A0: C02BBE08  lfs f1, -0x41f8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16888 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C36A4: 4BB6377D  bl 0x82426e20
	ctx.lr = 0x828C36A8;
	sub_82426E20(ctx, base);
	// 828C36A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	pc = 0x828C36AC; continue 'dispatch;
            }
            0x828C36AC => {
    //   block [0x828C36AC..0x828C36B8)
	// 828C36AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C36B0: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C36B4: 4BB62BAD  bl 0x82426260
	ctx.lr = 0x828C36B8;
	sub_82426260(ctx, base);
	pc = 0x828C36B8; continue 'dispatch;
            }
            0x828C36B8 => {
    //   block [0x828C36B8..0x828C36CC)
	// 828C36B8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828C36BC: CBA1FFA8  lfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828C36C0: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828C36C4: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 828C36C8: 483E5D84  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C36D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C36D0 size=120
    let mut pc: u32 = 0x828C36D0;
    'dispatch: loop {
        match pc {
            0x828C36D0 => {
    //   block [0x828C36D0..0x828C3748)
	// 828C36D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C36D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C36D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C36DC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828C36E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C36E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C36E8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828C36EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C36F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C36F4: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828C36F8: 997F0001  stb r11, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 828C36FC: 4B95B32D  bl 0x8221ea28
	ctx.lr = 0x828C3700;
	sub_8221EA28(ctx, base);
	// 828C3700: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C3704: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 828C3708: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C370C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828C3710: C80B70A0  lfd f0, 0x70a0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(28832 as u32) ) };
	// 828C3714: C9AA70A8  lfd f13, 0x70a8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(28840 as u32) ) };
	// 828C3718: FD4B0028  fsub f10, f11, f0
	ctx.f[10].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 828C371C: FD2A6824  fdiv f9, f10, f13
	ctx.f[9].f64 = ctx.f[10].f64 / ctx.f[13].f64;
	// 828C3720: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 828C3724: D11F0004  stfs f8, 4(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828C3728: ECE8F82A  fadds f7, f8, f31
	ctx.f[7].f64 = ((ctx.f[8].f64 + ctx.f[31].f64) as f32) as f64;
	// 828C372C: D0FF0008  stfs f7, 8(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828C3730: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C3734: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C3738: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C373C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C3740: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C3744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C3748 size=128
    let mut pc: u32 = 0x828C3748;
    'dispatch: loop {
        match pc {
            0x828C3748 => {
    //   block [0x828C3748..0x828C37B0)
	// 828C3748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C374C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C3750: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C3754: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3758: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C375C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 828C3760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3764: 419A004C  beq cr6, 0x828c37b0
	if ctx.cr[6].eq {
	pc = 0x828C37B0; continue 'dispatch;
	}
	// 828C3768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C376C: 4B95B2BD  bl 0x8221ea28
	ctx.lr = 0x828C3770;
	sub_8221EA28(ctx, base);
	// 828C3770: C9610050  lfd f11, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C3774: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 828C3778: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C377C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828C3780: C13F0008  lfs f9, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828C3784: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828C3788: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828C378C: C80B70A0  lfd f0, 0x70a0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(28832 as u32) ) };
	// 828C3790: C9AA70A8  lfd f13, 0x70a8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(28840 as u32) ) };
	// 828C3794: C1899484  lfs f12, -0x6b7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C3798: FD0A0028  fsub f8, f10, f0
	ctx.f[8].f64 = ctx.f[10].f64 - ctx.f[0].f64;
	// 828C379C: FCE86824  fdiv f7, f8, f13
	ctx.f[7].f64 = ctx.f[8].f64 / ctx.f[13].f64;
	// 828C37A0: FCC03818  frsp f6, f7
	ctx.f[6].f64 = (ctx.f[7].f64 as f32) as f64;
	// 828C37A4: ECA93028  fsubs f5, f9, f6
	ctx.f[5].f64 = (((ctx.f[9].f64 - ctx.f[6].f64) as f32) as f64);
	// 828C37A8: FF056000  fcmpu cr6, f5, f12
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[12].f64);
	// 828C37AC: 40990008  ble cr6, 0x828c37b4
	if !ctx.cr[6].gt {
	pc = 0x828C37B4; continue 'dispatch;
	}
	pc = 0x828C37B0; continue 'dispatch;
            }
            0x828C37B0 => {
    //   block [0x828C37B0..0x828C37B4)
	// 828C37B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x828C37B4; continue 'dispatch;
            }
            0x828C37B4 => {
    //   block [0x828C37B4..0x828C37C8)
	// 828C37B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C37B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C37BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C37C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C37C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C37C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C37C8 size=328
    let mut pc: u32 = 0x828C37C8;
    'dispatch: loop {
        match pc {
            0x828C37C8 => {
    //   block [0x828C37C8..0x828C3814)
	// 828C37C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C37CC: 483E5C41  bl 0x82ca940c
	ctx.lr = 0x828C37D0;
	sub_82CA93D0(ctx, base);
	// 828C37D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C37D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C37D8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C37DC: 897F0029  lbz r11, 0x29(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(41 as u32) ) } as u64;
	// 828C37E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C37E4: 419A0030  beq cr6, 0x828c3814
	if ctx.cr[6].eq {
	pc = 0x828C3814; continue 'dispatch;
	}
	// 828C37E8: C01F001C  lfs f0, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C37EC: C1BF0018  lfs f13, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C37F0: C19F002C  lfs f12, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C37F4: C17F0010  lfs f11, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828C37F8: C15F0030  lfs f10, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828C37FC: ED2C6AFA  fmadds f9, f12, f11, f13
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 828C3800: C11F0014  lfs f8, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828C3804: ECEA023A  fmadds f7, f10, f8, f0
	ctx.f[7].f64 = (((ctx.f[10].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 828C3808: D13F0018  stfs f9, 0x18(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828C380C: D0FF001C  stfs f7, 0x1c(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828C3810: 4800002C  b 0x828c383c
	pc = 0x828C383C; continue 'dispatch;
            }
            0x828C3814 => {
    //   block [0x828C3814..0x828C383C)
	// 828C3814: 3BDF0034  addi r30, r31, 0x34
	ctx.r[30].s64 = ctx.r[31].s64 + 52;
	// 828C3818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C381C: 4BFFFF2D  bl 0x828c3748
	ctx.lr = 0x828C3820;
	sub_828C3748(ctx, base);
	// 828C3820: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C3824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3828: 419A0014  beq cr6, 0x828c383c
	if ctx.cr[6].eq {
	pc = 0x828C383C; continue 'dispatch;
	}
	// 828C382C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C3830: 9BBE0000  stb r29, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828C3834: 9BBE0001  stb r29, 1(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1 as u32), ctx.r[29].u8 ) };
	// 828C3838: 997F0029  stb r11, 0x29(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(41 as u32), ctx.r[11].u8 ) };
	pc = 0x828C383C; continue 'dispatch;
            }
            0x828C383C => {
    //   block [0x828C383C..0x828C388C)
	// 828C383C: E93F0018  ld r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 828C3840: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C3844: E91F0020  ld r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	// 828C3848: 394BB46C  addi r10, r11, -0x4b94
	ctx.r[10].s64 = ctx.r[11].s64 + -19348;
	// 828C384C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828C3850: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3854: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 828C3858: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C385C: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C3860: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828C3864: ED4B6028  fsubs f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 828C3868: ED2D0028  fsubs f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 828C386C: C00AE060  lfs f0, -0x1fa0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3870: FD005210  fabs f8, f10
	ctx.f[8].u64 = ctx.f[10].u64 & !0x8000_0000_0000_0000u64;
	// 828C3874: FDA04A10  fabs f13, f9
	ctx.f[13].u64 = ctx.f[9].u64 & !0x8000_0000_0000_0000u64;
	// 828C3878: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 828C387C: 40980010  bge cr6, 0x828c388c
	if !ctx.cr[6].lt {
	pc = 0x828C388C; continue 'dispatch;
	}
	// 828C3880: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828C3884: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C3888: 41980008  blt cr6, 0x828c3890
	if ctx.cr[6].lt {
	pc = 0x828C3890; continue 'dispatch;
	}
	pc = 0x828C388C; continue 'dispatch;
            }
            0x828C388C => {
    //   block [0x828C388C..0x828C3890)
	// 828C388C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828C3890; continue 'dispatch;
            }
            0x828C3890 => {
    //   block [0x828C3890..0x828C3908)
	// 828C3890: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C3894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3898: 409A0070  bne cr6, 0x828c3908
	if !ctx.cr[6].eq {
	pc = 0x828C3908; continue 'dispatch;
	}
	// 828C389C: E97F0020  ld r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	// 828C38A0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828C38A4: E91F0018  ld r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 828C38A8: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C38AC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 828C38B0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C38B4: C1210054  lfs f9, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828C38B8: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 828C38BC: C0C10064  lfs f6, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 828C38C0: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 828C38C4: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828C38C8: C141005C  lfs f10, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828C38CC: 81696B08  lwz r11, 0x6b08(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C38D0: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C38D4: C10B0080  lfs f8, 0x80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828C38D8: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 828C38DC: C1810060  lfs f12, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C38E0: EC8C6828  fsubs f4, f12, f13
	ctx.f[4].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 828C38E4: ECA64828  fsubs f5, f6, f9
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[9].f64) as f32) as f64);
	// 828C38E8: EC4401F2  fmuls f2, f4, f7
	ctx.f[2].f64 = (((ctx.f[4].f64 * ctx.f[7].f64) as f32) as f64);
	// 828C38EC: EC6501F2  fmuls f3, f5, f7
	ctx.f[3].f64 = (((ctx.f[5].f64 * ctx.f[7].f64) as f32) as f64);
	// 828C38F0: EC0B102A  fadds f0, f11, f2
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[2].f64) as f32) as f64;
	// 828C38F4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828C38F8: EC23502A  fadds f1, f3, f10
	ctx.f[1].f64 = ((ctx.f[3].f64 + ctx.f[10].f64) as f32) as f64;
	// 828C38FC: D0210064  stfs f1, 0x64(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828C3900: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828C3904: F8DF0020  std r6, 0x20(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[6].u64 ) };
	pc = 0x828C3908; continue 'dispatch;
            }
            0x828C3908 => {
    //   block [0x828C3908..0x828C3910)
	// 828C3908: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C390C: 483E5B50  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C3910 size=220
    let mut pc: u32 = 0x828C3910;
    'dispatch: loop {
        match pc {
            0x828C3910 => {
    //   block [0x828C3910..0x828C3940)
	// 828C3910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C3918: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C391C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828C3920: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3924: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C3928: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C392C: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 828C3930: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C3934: 409A000C  bne cr6, 0x828c3940
	if !ctx.cr[6].eq {
	pc = 0x828C3940; continue 'dispatch;
	}
	// 828C3938: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C393C: 48000008  b 0x828c3944
	pc = 0x828C3944; continue 'dispatch;
            }
            0x828C3940 => {
    //   block [0x828C3940..0x828C3944)
	// 828C3940: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	pc = 0x828C3944; continue 'dispatch;
            }
            0x828C3944 => {
    //   block [0x828C3944..0x828C39D4)
	// 828C3944: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C3948: E92B0018  ld r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 828C394C: CBEA0DF0  lfd f31, 0xdf0(r10)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3568 as u32) ) };
	// 828C3950: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 828C3954: C0210050  lfs f1, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C3958: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 828C395C: 4B93AB4D  bl 0x821fe4a8
	ctx.lr = 0x828C3960;
	sub_821FE4A8(ctx, base);
	// 828C3960: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3964: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C3968: FD800818  frsp f12, f1
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 828C396C: ED600372  fmuls f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 828C3970: C0210054  lfs f1, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C3974: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 828C3978: EFEB0332  fmuls f31, f11, f12
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 828C397C: 4B93AB2D  bl 0x821fe4a8
	ctx.lr = 0x828C3980;
	sub_821FE4A8(ctx, base);
	// 828C3980: C15F000C  lfs f10, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828C3984: FD200818  frsp f9, f1
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 828C3988: C11F0004  lfs f8, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828C398C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C3990: ECEA0232  fmuls f7, f10, f8
	ctx.f[7].f64 = (((ctx.f[10].f64 * ctx.f[8].f64) as f32) as f64);
	// 828C3994: C0DF0018  lfs f6, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 828C3998: 396BD5C8  addi r11, r11, -0x2a38
	ctx.r[11].s64 = ctx.r[11].s64 + -10808;
	// 828C399C: C0BF001C  lfs f5, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 828C39A0: 891F0028  lbz r8, 0x28(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C39A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C39A8: 98FF0029  stb r7, 0x29(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(41 as u32), ctx.r[7].u8 ) };
	// 828C39AC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C39B0: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C39B4: EC9F303A  fmadds f4, f31, f0, f6
	ctx.f[4].f64 = (((ctx.f[31].f64 * ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64);
	// 828C39B8: D09F0018  stfs f4, 0x18(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828C39BC: EC672A7A  fmadds f3, f7, f9, f5
	ctx.f[3].f64 = (((ctx.f[7].f64 * ctx.f[9].f64 + ctx.f[5].f64) as f32) as f64);
	// 828C39C0: D07F001C  stfs f3, 0x1c(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828C39C4: 419A0010  beq cr6, 0x828c39d4
	if ctx.cr[6].eq {
	pc = 0x828C39D4; continue 'dispatch;
	}
	// 828C39C8: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 828C39CC: C02BE1DC  lfs f1, -0x1e24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7716 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C39D0: 4BFFFD01  bl 0x828c36d0
	ctx.lr = 0x828C39D4;
	sub_828C36D0(ctx, base);
	pc = 0x828C39D4; continue 'dispatch;
            }
            0x828C39D4 => {
    //   block [0x828C39D4..0x828C39EC)
	// 828C39D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C39D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C39DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C39E0: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C39E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C39E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C39F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C39F0 size=320
    let mut pc: u32 = 0x828C39F0;
    'dispatch: loop {
        match pc {
            0x828C39F0 => {
    //   block [0x828C39F0..0x828C3A2C)
	// 828C39F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C39F4: 483E5A15  bl 0x82ca9408
	ctx.lr = 0x828C39F8;
	sub_82CA93D0(ctx, base);
	// 828C39F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C39FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C3A00: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C3A04: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C3A08: 419A0120  beq cr6, 0x828c3b28
	if ctx.cr[6].eq {
	pc = 0x828C3B28; continue 'dispatch;
	}
	// 828C3A0C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828C3A10: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C3A14: 3B8BFFDF  addi r28, r11, -0x21
	ctx.r[28].s64 = ctx.r[11].s64 + -33;
	// 828C3A18: 816AC844  lwz r11, -0x37bc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14268 as u32) ) } as u64;
	// 828C3A1C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828C3A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3A24: 419A0008  beq cr6, 0x828c3a2c
	if ctx.cr[6].eq {
	pc = 0x828C3A2C; continue 'dispatch;
	}
	// 828C3A28: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C3A2C; continue 'dispatch;
            }
            0x828C3A2C => {
    //   block [0x828C3A2C..0x828C3A5C)
	// 828C3A2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C3A30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3A34: 4BEBF9E5  bl 0x82783418
	ctx.lr = 0x828C3A38;
	sub_82783418(ctx, base);
	// 828C3A38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C3A3C: 817D007C  lwz r11, 0x7c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 828C3A40: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3A44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C3A48: 419A0014  beq cr6, 0x828c3a5c
	if ctx.cr[6].eq {
	pc = 0x828C3A5C; continue 'dispatch;
	}
	// 828C3A4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C3A50: 48000589  bl 0x828c3fd8
	ctx.lr = 0x828C3A54;
	sub_828C3FD8(ctx, base);
	// 828C3A54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3A58: 917D007C  stw r11, 0x7c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	pc = 0x828C3A5C; continue 'dispatch;
            }
            0x828C3A5C => {
    //   block [0x828C3A5C..0x828C3A74)
	// 828C3A5C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C3A60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C3A64: 816BC848  lwz r11, -0x37b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14264 as u32) ) } as u64;
	// 828C3A68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3A6C: 419A0008  beq cr6, 0x828c3a74
	if ctx.cr[6].eq {
	pc = 0x828C3A74; continue 'dispatch;
	}
	// 828C3A70: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C3A74; continue 'dispatch;
            }
            0x828C3A74 => {
    //   block [0x828C3A74..0x828C3A98)
	// 828C3A74: 38BD0050  addi r5, r29, 0x50
	ctx.r[5].s64 = ctx.r[29].s64 + 80;
	// 828C3A78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3A7C: 4BBF8955  bl 0x824bc3d0
	ctx.lr = 0x828C3A80;
	sub_824BC3D0(ctx, base);
	// 828C3A80: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C3A84: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C3A88: 816BC84C  lwz r11, -0x37b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14260 as u32) ) } as u64;
	// 828C3A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3A90: 419A0008  beq cr6, 0x828c3a98
	if ctx.cr[6].eq {
	pc = 0x828C3A98; continue 'dispatch;
	}
	// 828C3A94: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C3A98; continue 'dispatch;
            }
            0x828C3A98 => {
    //   block [0x828C3A98..0x828C3ABC)
	// 828C3A98: 38BD0060  addi r5, r29, 0x60
	ctx.r[5].s64 = ctx.r[29].s64 + 96;
	// 828C3A9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3AA0: 4BBF8931  bl 0x824bc3d0
	ctx.lr = 0x828C3AA4;
	sub_824BC3D0(ctx, base);
	// 828C3AA4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C3AA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C3AAC: 816BC850  lwz r11, -0x37b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 828C3AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3AB4: 419A0008  beq cr6, 0x828c3abc
	if ctx.cr[6].eq {
	pc = 0x828C3ABC; continue 'dispatch;
	}
	// 828C3AB8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C3ABC; continue 'dispatch;
            }
            0x828C3ABC => {
    //   block [0x828C3ABC..0x828C3AE0)
	// 828C3ABC: 38BD0070  addi r5, r29, 0x70
	ctx.r[5].s64 = ctx.r[29].s64 + 112;
	// 828C3AC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3AC4: 4BAE992D  bl 0x823ad3f0
	ctx.lr = 0x828C3AC8;
	sub_823AD3F0(ctx, base);
	// 828C3AC8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C3ACC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C3AD0: 816BC854  lwz r11, -0x37ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14252 as u32) ) } as u64;
	// 828C3AD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3AD8: 419A0008  beq cr6, 0x828c3ae0
	if ctx.cr[6].eq {
	pc = 0x828C3AE0; continue 'dispatch;
	}
	// 828C3ADC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C3AE0; continue 'dispatch;
            }
            0x828C3AE0 => {
    //   block [0x828C3AE0..0x828C3B10)
	// 828C3AE0: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828C3AE4: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828C3AE8: 4B930271  bl 0x821f3d58
	ctx.lr = 0x828C3AEC;
	sub_821F3D58(ctx, base);
	// 828C3AEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C3AF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3AF4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828C3AF8: 4813CBD1  bl 0x82a006c8
	ctx.lr = 0x828C3AFC;
	sub_82A006C8(ctx, base);
	// 828C3AFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C3B00: 419A0010  beq cr6, 0x828c3b10
	if ctx.cr[6].eq {
	pc = 0x828C3B10; continue 'dispatch;
	}
	// 828C3B04: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3B08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C3B0C: 4800000C  b 0x828c3b18
	pc = 0x828C3B18; continue 'dispatch;
            }
            0x828C3B10 => {
    //   block [0x828C3B10..0x828C3B18)
	// 828C3B10: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C3B14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C3B18; continue 'dispatch;
            }
            0x828C3B18 => {
    //   block [0x828C3B18..0x828C3B28)
	// 828C3B18: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C3B1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3B20: 419A0008  beq cr6, 0x828c3b28
	if ctx.cr[6].eq {
	pc = 0x828C3B28; continue 'dispatch;
	}
	// 828C3B24: 915D0078  stw r10, 0x78(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	pc = 0x828C3B28; continue 'dispatch;
            }
            0x828C3B28 => {
    //   block [0x828C3B28..0x828C3B30)
	// 828C3B28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C3B2C: 483E592C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3B30 size=324
    let mut pc: u32 = 0x828C3B30;
    'dispatch: loop {
        match pc {
            0x828C3B30 => {
    //   block [0x828C3B30..0x828C3B78)
	// 828C3B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3B34: 483E58D9  bl 0x82ca940c
	ctx.lr = 0x828C3B38;
	sub_82CA93D0(ctx, base);
	// 828C3B38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3B3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C3B40: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C3B44: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 828C3B48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3B4C: 38EAF11C  addi r7, r10, -0xee4
	ctx.r[7].s64 = ctx.r[10].s64 + -3812;
	// 828C3B50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3B54: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C3B58: 4B8EE9A1  bl 0x821b24f8
	ctx.lr = 0x828C3B5C;
	sub_821B24F8(ctx, base);
	// 828C3B5C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828C3B60: 4B9E5E89  bl 0x822a99e8
	ctx.lr = 0x828C3B64;
	sub_822A99E8(ctx, base);
	// 828C3B64: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 828C3B68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C3B6C: 39267088  addi r9, r6, 0x7088
	ctx.r[9].s64 = ctx.r[6].s64 + 28808;
	// 828C3B70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C3B74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	pc = 0x828C3B78; continue 'dispatch;
            }
            0x828C3B78 => {
    //   block [0x828C3B78..0x828C3BA4)
	// 828C3B78: 7D6000A6  mfmsr r11
	ctx.r[11].u64 = ctx.msr;
	// 828C3B7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C3B80: 7CA04828  lwarx r5, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 828C3B84: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 828C3B88: 7CA0492D  stwcx. r5, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C3B8C: 7D610164  mtmsrd r11, 1
	ctx.msr = (ctx.r[11].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C3B90: 4082FFE8  bne 0x828c3b78
	if !ctx.cr[0].eq {
	pc = 0x828C3B78; continue 'dispatch;
	}
	// 828C3B94: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C3B98: 419A000C  beq cr6, 0x828c3ba4
	if ctx.cr[6].eq {
	pc = 0x828C3BA4; continue 'dispatch;
	}
	// 828C3B9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C3BA0: 4BFFFE51  bl 0x828c39f0
	ctx.lr = 0x828C3BA4;
	sub_828C39F0(ctx, base);
	pc = 0x828C3BA4; continue 'dispatch;
            }
            0x828C3BA4 => {
    //   block [0x828C3BA4..0x828C3BD0)
	// 828C3BA4: 817D007C  lwz r11, 0x7c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 828C3BA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3BAC: 419900B8  bgt cr6, 0x828c3c64
	if ctx.cr[6].gt {
	pc = 0x828C3C64; continue 'dispatch;
	}
	// 828C3BB0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828C3BB4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C3BB8: 3BCBFFDF  addi r30, r11, -0x21
	ctx.r[30].s64 = ctx.r[11].s64 + -33;
	// 828C3BBC: 816AC858  lwz r11, -0x37a8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14248 as u32) ) } as u64;
	// 828C3BC0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828C3BC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3BC8: 419A0008  beq cr6, 0x828c3bd0
	if ctx.cr[6].eq {
	pc = 0x828C3BD0; continue 'dispatch;
	}
	// 828C3BCC: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C3BD0; continue 'dispatch;
            }
            0x828C3BD0 => {
    //   block [0x828C3BD0..0x828C3C04)
	// 828C3BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3BD4: 4B8EE925  bl 0x821b24f8
	ctx.lr = 0x828C3BD8;
	sub_821B24F8(ctx, base);
	// 828C3BD8: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828C3BDC: 4B9E5E0D  bl 0x822a99e8
	ctx.lr = 0x828C3BE0;
	sub_822A99E8(ctx, base);
	// 828C3BE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C3BE4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C3BE8: 409A0038  bne cr6, 0x828c3c20
	if !ctx.cr[6].eq {
	pc = 0x828C3C20; continue 'dispatch;
	}
	// 828C3BEC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C3BF0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828C3BF4: 816BC85C  lwz r11, -0x37a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14244 as u32) ) } as u64;
	// 828C3BF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3BFC: 419A0008  beq cr6, 0x828c3c04
	if ctx.cr[6].eq {
	pc = 0x828C3C04; continue 'dispatch;
	}
	// 828C3C00: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C3C04; continue 'dispatch;
            }
            0x828C3C04 => {
    //   block [0x828C3C04..0x828C3C20)
	// 828C3C04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3C08: 4B8EE8F1  bl 0x821b24f8
	ctx.lr = 0x828C3C0C;
	sub_821B24F8(ctx, base);
	// 828C3C0C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828C3C10: 4B9E5DD9  bl 0x822a99e8
	ctx.lr = 0x828C3C14;
	sub_822A99E8(ctx, base);
	// 828C3C14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C3C18: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C3C1C: 419A0048  beq cr6, 0x828c3c64
	if ctx.cr[6].eq {
	pc = 0x828C3C64; continue 'dispatch;
	}
	pc = 0x828C3C20; continue 'dispatch;
            }
            0x828C3C20 => {
    //   block [0x828C3C20..0x828C3C38)
	// 828C3C20: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C3C24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C3C28: 816BC860  lwz r11, -0x37a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14240 as u32) ) } as u64;
	// 828C3C2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3C30: 419A0008  beq cr6, 0x828c3c38
	if ctx.cr[6].eq {
	pc = 0x828C3C38; continue 'dispatch;
	}
	// 828C3C34: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C3C38; continue 'dispatch;
            }
            0x828C3C38 => {
    //   block [0x828C3C38..0x828C3C64)
	// 828C3C38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C3C3C: 4BEBF7DD  bl 0x82783418
	ctx.lr = 0x828C3C40;
	sub_82783418(ctx, base);
	// 828C3C40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C3C44: 817D007C  lwz r11, 0x7c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 828C3C48: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3C4C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C3C50: 419A0014  beq cr6, 0x828c3c64
	if ctx.cr[6].eq {
	pc = 0x828C3C64; continue 'dispatch;
	}
	// 828C3C54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C3C58: 48000381  bl 0x828c3fd8
	ctx.lr = 0x828C3C5C;
	sub_828C3FD8(ctx, base);
	// 828C3C5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3C60: 917D007C  stw r11, 0x7c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	pc = 0x828C3C64; continue 'dispatch;
            }
            0x828C3C64 => {
    //   block [0x828C3C64..0x828C3C74)
	// 828C3C64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3C68: 4B951171  bl 0x82214dd8
	ctx.lr = 0x828C3C6C;
	sub_82214DD8(ctx, base);
	// 828C3C6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C3C70: 483E57EC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C3C78 size=860
    let mut pc: u32 = 0x828C3C78;
    'dispatch: loop {
        match pc {
            0x828C3C78 => {
    //   block [0x828C3C78..0x828C3D18)
	// 828C3C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3C7C: 483E578D  bl 0x82ca9408
	ctx.lr = 0x828C3C80;
	sub_82CA93D0(ctx, base);
	// 828C3C80: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 828C3C84: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828C3C88: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3C8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C3C90: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828C3C94: 3B9D007C  addi r28, r29, 0x7c
	ctx.r[28].s64 = ctx.r[29].s64 + 124;
	// 828C3C98: 817D007C  lwz r11, 0x7c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 828C3C9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3CA0: 40990324  ble cr6, 0x828c3fc4
	if !ctx.cr[6].gt {
	pc = 0x828C3FC4; continue 'dispatch;
	}
	// 828C3CA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C3CA8: 4B92C599  bl 0x821f0240
	ctx.lr = 0x828C3CAC;
	sub_821F0240(ctx, base);
	// 828C3CAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C3CB0: 4BB62AE9  bl 0x82426798
	ctx.lr = 0x828C3CB4;
	sub_82426798(ctx, base);
	// 828C3CB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C3CB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C3CBC: 419A0308  beq cr6, 0x828c3fc4
	if ctx.cr[6].eq {
	pc = 0x828C3FC4; continue 'dispatch;
	}
	// 828C3CC0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C3CC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3CC8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C3CCC: 4BB616D5  bl 0x824253a0
	ctx.lr = 0x828C3CD0;
	sub_824253A0(ctx, base);
	// 828C3CD0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C3CD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3CD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C3CDC: 4BB618FD  bl 0x824255d8
	ctx.lr = 0x828C3CE0;
	sub_824255D8(ctx, base);
	// 828C3CE0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C3CE4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3CE8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C3CEC: 394B9490  addi r10, r11, -0x6b70
	ctx.r[10].s64 = ctx.r[11].s64 + -27504;
	// 828C3CF0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C3CF4: C3CB9490  lfs f30, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828C3CF8: C3EAFFF4  lfs f31, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C3CFC: 419A0144  beq cr6, 0x828c3e40
	if ctx.cr[6].eq {
	pc = 0x828C3E40; continue 'dispatch;
	}
	// 828C3D00: 817D0078  lwz r11, 0x78(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C3D04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C3D08: 40990010  ble cr6, 0x828c3d18
	if !ctx.cr[6].gt {
	pc = 0x828C3D18; continue 'dispatch;
	}
	// 828C3D0C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828C3D10: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828C3D14: 40990008  ble cr6, 0x828c3d1c
	if !ctx.cr[6].gt {
	pc = 0x828C3D1C; continue 'dispatch;
	}
	pc = 0x828C3D18; continue 'dispatch;
            }
            0x828C3D18 => {
    //   block [0x828C3D18..0x828C3D1C)
	// 828C3D18: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x828C3D1C; continue 'dispatch;
            }
            0x828C3D1C => {
    //   block [0x828C3D1C..0x828C3D58)
	// 828C3D1C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C3D20: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 828C3D24: 419900C8  bgt cr6, 0x828c3dec
	if ctx.cr[6].gt {
	pc = 0x828C3DEC; continue 'dispatch;
	}
	// 828C3D28: 3D80828C  lis r12, -0x7d74
	ctx.r[12].s64 = -2104754176;
	// 828C3D2C: 398C3D40  addi r12, r12, 0x3d40
	ctx.r[12].s64 = ctx.r[12].s64 + 15680;
	// 828C3D30: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 828C3D34: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 828C3D38: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 828C3D3C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x828C3D58; continue 'dispatch;
		},
		1 => {
	pc = 0x828C3D8C; continue 'dispatch;
		},
		2 => {
	pc = 0x828C3DB8; continue 'dispatch;
		},
		3 => {
	pc = 0x828C3D58; continue 'dispatch;
		},
		4 => {
	pc = 0x828C3D8C; continue 'dispatch;
		},
		5 => {
	pc = 0x828C3DB8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 828C3D40: 828C3D58  lwz r20, 0x3d58(r12)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(15704 as u32) ) } as u64;
	// 828C3D44: 828C3D8C  lwz r20, 0x3d8c(r12)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(15756 as u32) ) } as u64;
	// 828C3D48: 828C3DB8  lwz r20, 0x3db8(r12)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(15800 as u32) ) } as u64;
	// 828C3D4C: 828C3D58  lwz r20, 0x3d58(r12)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(15704 as u32) ) } as u64;
	// 828C3D50: 828C3D8C  lwz r20, 0x3d8c(r12)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(15756 as u32) ) } as u64;
	// 828C3D54: 828C3DB8  lwz r20, 0x3db8(r12)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(15800 as u32) ) } as u64;
            }
            0x828C3D58 => {
    //   block [0x828C3D58..0x828C3D8C)
	// 828C3D58: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C3D5C: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C3D60: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828C3D64: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C3D68: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828C3D6C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828C3D70: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3D74: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828C3D78: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C3D7C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828C3D80: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 828C3D84: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828C3D88: 48000088  b 0x828c3e10
	pc = 0x828C3E10; continue 'dispatch;
            }
            0x828C3D8C => {
    //   block [0x828C3D8C..0x828C3DB8)
	// 828C3D8C: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C3D90: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828C3D94: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C3D98: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C3D9C: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828C3DA0: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C3DA4: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3DA8: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 828C3DAC: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828C3DB0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828C3DB4: 48000054  b 0x828c3e08
	pc = 0x828C3E08; continue 'dispatch;
            }
            0x828C3DB8 => {
    //   block [0x828C3DB8..0x828C3DEC)
	// 828C3DB8: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C3DBC: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C3DC0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828C3DC4: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828C3DC8: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C3DCC: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828C3DD0: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C3DD4: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 828C3DD8: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C3DDC: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828C3DE0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828C3DE4: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828C3DE8: 48000028  b 0x828c3e10
	pc = 0x828C3E10; continue 'dispatch;
            }
            0x828C3DEC => {
    //   block [0x828C3DEC..0x828C3E08)
	// 828C3DEC: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828C3DF0: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828C3DF4: 81210070  lwz r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C3DF8: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828C3DFC: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 828C3E00: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C3E04: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	pc = 0x828C3E08; continue 'dispatch;
            }
            0x828C3E08 => {
    //   block [0x828C3E08..0x828C3E10)
	// 828C3E08: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828C3E0C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	pc = 0x828C3E10; continue 'dispatch;
            }
            0x828C3E10 => {
    //   block [0x828C3E10..0x828C3E40)
	// 828C3E10: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C3E14: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828C3E18: 4815FC49  bl 0x82a23a60
	ctx.lr = 0x828C3E1C;
	sub_82A23A60(ctx, base);
	// 828C3E1C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828C3E20: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C3E24: 4B8EC245  bl 0x821b0068
	ctx.lr = 0x828C3E28;
	sub_821B0068(ctx, base);
	// 828C3E28: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828C3E2C: E9230008  ld r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 828C3E30: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 828C3E34: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 828C3E38: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 828C3E3C: 4800002C  b 0x828c3e68
	pc = 0x828C3E68; continue 'dispatch;
            }
            0x828C3E40 => {
    //   block [0x828C3E40..0x828C3E68)
	// 828C3E40: D3C10050  stfs f30, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C3E44: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C3E48: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828C3E4C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 828C3E50: 390A9160  addi r8, r10, -0x6ea0
	ctx.r[8].s64 = ctx.r[10].s64 + -28320;
	pc = 0x828C3E68; continue 'dispatch;
            }
            0x828C3E68 => {
    //   block [0x828C3E68..0x828C3FC4)
	// 828C3E68: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C3E6C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C3E70: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828C3E74: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 828C3E78: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828C3E7C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 828C3E80: 38E99150  addi r7, r9, -0x6eb0
	ctx.r[7].s64 = ctx.r[9].s64 + -28336;
	// 828C3E84: 38C89140  addi r6, r8, -0x6ec0
	ctx.r[6].s64 = ctx.r[8].s64 + -28352;
	// 828C3E88: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 828C3E8C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 828C3E90: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	pc = 0x828C3FC4; continue 'dispatch;
            }
            0x828C3FC4 => {
    //   block [0x828C3FC4..0x828C3FD4)
	// 828C3FC4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828C3FC8: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828C3FCC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828C3FD0: 483E5488  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3FD8 size=120
    let mut pc: u32 = 0x828C3FD8;
    'dispatch: loop {
        match pc {
            0x828C3FD8 => {
    //   block [0x828C3FD8..0x828C4034)
	// 828C3FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3FDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C3FE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C3FE4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3FE8: 89630040  lbz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C3FEC: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 828C3FF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3FF4: 419A0048  beq cr6, 0x828c403c
	if ctx.cr[6].eq {
	pc = 0x828C403C; continue 'dispatch;
	}
	// 828C3FF8: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828C3FFC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C4000: 995F0030  stb r10, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 828C4004: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 828C4008: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C400C: 419A0028  beq cr6, 0x828c4034
	if ctx.cr[6].eq {
	pc = 0x828C4034; continue 'dispatch;
	}
	// 828C4010: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C4014: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C4018: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 828C401C: 386B0090  addi r3, r11, 0x90
	ctx.r[3].s64 = ctx.r[11].s64 + 144;
	// 828C4020: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 828C4024: 814B0094  lwz r10, 0x94(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 828C4028: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828C402C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C4030: 481D3339  bl 0x82a97368
	ctx.lr = 0x828C4034;
	sub_82A97368(ctx, base);
	pc = 0x828C4034; continue 'dispatch;
            }
            0x828C4034 => {
    //   block [0x828C4034..0x828C403C)
	// 828C4034: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 828C4038: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	pc = 0x828C403C; continue 'dispatch;
            }
            0x828C403C => {
    //   block [0x828C403C..0x828C4050)
	// 828C403C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4040: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4044: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4048: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C404C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4068 size=424
    let mut pc: u32 = 0x828C4068;
    'dispatch: loop {
        match pc {
            0x828C4068 => {
    //   block [0x828C4068..0x828C4210)
	// 828C4068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C406C: 483E53A1  bl 0x82ca940c
	ctx.lr = 0x828C4070;
	sub_82CA93D0(ctx, base);
	// 828C4070: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4074: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C4078: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C407C: 3BABA1F0  addi r29, r11, -0x5e10
	ctx.r[29].s64 = ctx.r[11].s64 + -24080;
	// 828C4080: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C4084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4088: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C408C: 4B968E45  bl 0x8222ced0
	ctx.lr = 0x828C4090;
	sub_8222CED0(ctx, base);
	// 828C4090: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4094: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C4098: 48000861  bl 0x828c48f8
	ctx.lr = 0x828C409C;
	sub_828C48F8(ctx, base);
	// 828C409C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C40A0: 4B950D39  bl 0x82214dd8
	ctx.lr = 0x828C40A4;
	sub_82214DD8(ctx, base);
	// 828C40A4: 3D40822D  lis r10, -0x7dd3
	ctx.r[10].s64 = -2110980096;
	// 828C40A8: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828C40AC: 390A1A30  addi r8, r10, 0x1a30
	ctx.r[8].s64 = ctx.r[10].s64 + 6704;
	// 828C40B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C40B4: 38893140  addi r4, r9, 0x3140
	ctx.r[4].s64 = ctx.r[9].s64 + 12608;
	// 828C40B8: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 828C40BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C40C0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828C40C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C40C8: 4B968E09  bl 0x8222ced0
	ctx.lr = 0x828C40CC;
	sub_8222CED0(ctx, base);
	// 828C40CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C40D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C40D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C40D8: 4B968DF9  bl 0x8222ced0
	ctx.lr = 0x828C40DC;
	sub_8222CED0(ctx, base);
	// 828C40DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C40E0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828C40E4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C40E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C40EC: 48000A55  bl 0x828c4b40
	ctx.lr = 0x828C40F0;
	sub_828C4B40(ctx, base);
	// 828C40F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C40F4: 4B950CE5  bl 0x82214dd8
	ctx.lr = 0x828C40F8;
	sub_82214DD8(ctx, base);
	// 828C40F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C40FC: 4B950CDD  bl 0x82214dd8
	ctx.lr = 0x828C4100;
	sub_82214DD8(ctx, base);
	// 828C4100: 3CE0828C  lis r7, -0x7d74
	ctx.r[7].s64 = -2104754176;
	// 828C4104: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828C4108: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828C410C: 386748E0  addi r3, r7, 0x48e0
	ctx.r[3].s64 = ctx.r[7].s64 + 18656;
	// 828C4110: 38863150  addi r4, r6, 0x3150
	ctx.r[4].s64 = ctx.r[6].s64 + 12624;
	// 828C4114: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 828C4118: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C411C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4120: 4B968DB1  bl 0x8222ced0
	ctx.lr = 0x828C4124;
	sub_8222CED0(ctx, base);
	// 828C4124: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C4128: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C412C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C4130: 4B968DA1  bl 0x8222ced0
	ctx.lr = 0x828C4134;
	sub_8222CED0(ctx, base);
	// 828C4134: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4138: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C413C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C4140: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C4144: 480009FD  bl 0x828c4b40
	ctx.lr = 0x828C4148;
	sub_828C4B40(ctx, base);
	// 828C4148: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C414C: 4B950C8D  bl 0x82214dd8
	ctx.lr = 0x828C4150;
	sub_82214DD8(ctx, base);
	// 828C4150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4154: 4B950C85  bl 0x82214dd8
	ctx.lr = 0x828C4158;
	sub_82214DD8(ctx, base);
	// 828C4158: 3D60831C  lis r11, -0x7ce4
	ctx.r[11].s64 = -2095316992;
	// 828C415C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C4160: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828C4164: 392BC060  addi r9, r11, -0x3fa0
	ctx.r[9].s64 = ctx.r[11].s64 + -16288;
	// 828C4168: 388A3158  addi r4, r10, 0x3158
	ctx.r[4].s64 = ctx.r[10].s64 + 12632;
	// 828C416C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C4170: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 828C4174: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4178: 4B968D59  bl 0x8222ced0
	ctx.lr = 0x828C417C;
	sub_8222CED0(ctx, base);
	// 828C417C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C4180: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C4184: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C4188: 4B968D49  bl 0x8222ced0
	ctx.lr = 0x828C418C;
	sub_8222CED0(ctx, base);
	// 828C418C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C4190: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C4194: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C4198: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C419C: 48000BB5  bl 0x828c4d50
	ctx.lr = 0x828C41A0;
	sub_828C4D50(ctx, base);
	// 828C41A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C41A4: 4B950C35  bl 0x82214dd8
	ctx.lr = 0x828C41A8;
	sub_82214DD8(ctx, base);
	// 828C41A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C41AC: 4B950C2D  bl 0x82214dd8
	ctx.lr = 0x828C41B0;
	sub_82214DD8(ctx, base);
	// 828C41B0: 3D00828C  lis r8, -0x7d74
	ctx.r[8].s64 = -2104754176;
	// 828C41B4: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828C41B8: 38C84050  addi r6, r8, 0x4050
	ctx.r[6].s64 = ctx.r[8].s64 + 16464;
	// 828C41BC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828C41C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C41C4: 38873164  addi r4, r7, 0x3164
	ctx.r[4].s64 = ctx.r[7].s64 + 12644;
	// 828C41C8: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 828C41CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C41D0: 4B968D01  bl 0x8222ced0
	ctx.lr = 0x828C41D4;
	sub_8222CED0(ctx, base);
	// 828C41D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C41D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C41DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C41E0: 4B968CF1  bl 0x8222ced0
	ctx.lr = 0x828C41E4;
	sub_8222CED0(ctx, base);
	// 828C41E4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C41E8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C41EC: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C41F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C41F4: 48000D6D  bl 0x828c4f60
	ctx.lr = 0x828C41F8;
	sub_828C4F60(ctx, base);
	// 828C41F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C41FC: 4B950BDD  bl 0x82214dd8
	ctx.lr = 0x828C4200;
	sub_82214DD8(ctx, base);
	// 828C4200: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4204: 4B950BD5  bl 0x82214dd8
	ctx.lr = 0x828C4208;
	sub_82214DD8(ctx, base);
	// 828C4208: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C420C: 483E5250  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4210 size=432
    let mut pc: u32 = 0x828C4210;
    'dispatch: loop {
        match pc {
            0x828C4210 => {
    //   block [0x828C4210..0x828C4290)
	// 828C4210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4218: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C421C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4220: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4224: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C4228: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828C422C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C4230: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828C4234: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828C4238: 69280001  xori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 ^ 1;
	// 828C423C: 5507063E  clrlwi r7, r8, 0x18
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 828C4240: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C4244: 419A0154  beq cr6, 0x828c4398
	if ctx.cr[6].eq {
	pc = 0x828C4398; continue 'dispatch;
	}
	// 828C4248: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C424C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C4250: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 828C4254: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828C4258: 5549E7FE  rlwinm r9, r10, 0x1c, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 828C425C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C4260: 419A00F4  beq cr6, 0x828c4354
	if ctx.cr[6].eq {
	pc = 0x828C4354; continue 'dispatch;
	}
	// 828C4264: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C4268: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C426C: 419A0024  beq cr6, 0x828c4290
	if ctx.cr[6].eq {
	pc = 0x828C4290; continue 'dispatch;
	}
	// 828C4270: 894A0084  lbz r10, 0x84(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(132 as u32) ) } as u64;
	// 828C4274: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C4278: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828C427C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C4280: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4284: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828C4288: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C428C: 480000CC  b 0x828c4358
	pc = 0x828C4358; continue 'dispatch;
            }
            0x828C4290 => {
    //   block [0x828C4290..0x828C42AC)
	// 828C4290: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C4294: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C4298: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 828C429C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C42A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C42A4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C42A8: 40810054  ble 0x828c42fc
	if !ctx.cr[0].gt {
	pc = 0x828C42FC; continue 'dispatch;
	}
	pc = 0x828C42AC; continue 'dispatch;
            }
            0x828C42AC => {
    //   block [0x828C42AC..0x828C42CC)
	// 828C42AC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C42B0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C42B4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C42B8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C42BC: 2F070084  cmpwi cr6, r7, 0x84
	ctx.cr[6].compare_i32(ctx.r[7].s32, 132, &mut ctx.xer);
	// 828C42C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C42C4: 41980008  blt cr6, 0x828c42cc
	if ctx.cr[6].lt {
	pc = 0x828C42CC; continue 'dispatch;
	}
	// 828C42C8: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	pc = 0x828C42CC; continue 'dispatch;
            }
            0x828C42CC => {
    //   block [0x828C42CC..0x828C42E8)
	// 828C42CC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C42D0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C42D4: 419A0014  beq cr6, 0x828c42e8
	if ctx.cr[6].eq {
	pc = 0x828C42E8; continue 'dispatch;
	}
	// 828C42D8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C42DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C42E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C42E4: 4800000C  b 0x828c42f0
	pc = 0x828C42F0; continue 'dispatch;
            }
            0x828C42E8 => {
    //   block [0x828C42E8..0x828C42F0)
	// 828C42E8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C42EC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C42F0; continue 'dispatch;
            }
            0x828C42F0 => {
    //   block [0x828C42F0..0x828C42FC)
	// 828C42F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C42F4: 4199FFB8  bgt cr6, 0x828c42ac
	if ctx.cr[6].gt {
	pc = 0x828C42AC; continue 'dispatch;
	}
	// 828C42F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C42FC; continue 'dispatch;
            }
            0x828C42FC => {
    //   block [0x828C42FC..0x828C4318)
	// 828C42FC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C4300: 419A0040  beq cr6, 0x828c4340
	if ctx.cr[6].eq {
	pc = 0x828C4340; continue 'dispatch;
	}
	// 828C4304: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4308: 2F0B0084  cmpwi cr6, r11, 0x84
	ctx.cr[6].compare_i32(ctx.r[11].s32, 132, &mut ctx.xer);
	// 828C430C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C4310: 41990008  bgt cr6, 0x828c4318
	if ctx.cr[6].gt {
	pc = 0x828C4318; continue 'dispatch;
	}
	// 828C4314: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x828C4318; continue 'dispatch;
            }
            0x828C4318 => {
    //   block [0x828C4318..0x828C4340)
	// 828C4318: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C431C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4320: 409A0020  bne cr6, 0x828c4340
	if !ctx.cr[6].eq {
	pc = 0x828C4340; continue 'dispatch;
	}
	// 828C4324: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C4328: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C432C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C4330: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4334: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828C4338: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C433C: 4800001C  b 0x828c4358
	pc = 0x828C4358; continue 'dispatch;
            }
            0x828C4340 => {
    //   block [0x828C4340..0x828C4354)
	// 828C4340: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C4344: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4348: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 828C434C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C4350: 48000008  b 0x828c4358
	pc = 0x828C4358; continue 'dispatch;
            }
            0x828C4354 => {
    //   block [0x828C4354..0x828C4358)
	// 828C4354: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x828C4358; continue 'dispatch;
            }
            0x828C4358 => {
    //   block [0x828C4358..0x828C4398)
	// 828C4358: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C435C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4360: 419A0038  beq cr6, 0x828c4398
	if ctx.cr[6].eq {
	pc = 0x828C4398; continue 'dispatch;
	}
	// 828C4364: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C4368: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 828C436C: 4802A6CD  bl 0x828eea38
	ctx.lr = 0x828C4370;
	sub_828EEA38(ctx, base);
	// 828C4370: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C4374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4378: 419A0020  beq cr6, 0x828c4398
	if ctx.cr[6].eq {
	pc = 0x828C4398; continue 'dispatch;
	}
	// 828C437C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828C4380: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 828C4384: 4802A6B5  bl 0x828eea38
	ctx.lr = 0x828C4388;
	sub_828EEA38(ctx, base);
	// 828C4388: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C438C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4390: 409A0008  bne cr6, 0x828c4398
	if !ctx.cr[6].eq {
	pc = 0x828C4398; continue 'dispatch;
	}
	// 828C4394: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	pc = 0x828C4398; continue 'dispatch;
            }
            0x828C4398 => {
    //   block [0x828C4398..0x828C43A8)
	// 828C4398: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C439C: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 828C43A0: 419A0008  beq cr6, 0x828c43a8
	if ctx.cr[6].eq {
	pc = 0x828C43A8; continue 'dispatch;
	}
	// 828C43A4: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	pc = 0x828C43A8; continue 'dispatch;
            }
            0x828C43A8 => {
    //   block [0x828C43A8..0x828C43C0)
	// 828C43A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C43AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C43B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C43B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C43B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C43BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C43C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C43C0 size=392
    let mut pc: u32 = 0x828C43C0;
    'dispatch: loop {
        match pc {
            0x828C43C0 => {
    //   block [0x828C43C0..0x828C4418)
	// 828C43C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C43C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C43C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C43CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C43D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C43D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C43D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C43DC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C43E0: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 828C43E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C43E8: 419A00F8  beq cr6, 0x828c44e0
	if ctx.cr[6].eq {
	pc = 0x828C44E0; continue 'dispatch;
	}
	// 828C43EC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C43F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C43F4: 419A0024  beq cr6, 0x828c4418
	if ctx.cr[6].eq {
	pc = 0x828C4418; continue 'dispatch;
	}
	// 828C43F8: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 828C43FC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C4400: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828C4404: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C4408: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C440C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828C4410: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C4414: 480000D4  b 0x828c44e8
	pc = 0x828C44E8; continue 'dispatch;
            }
            0x828C4418 => {
    //   block [0x828C4418..0x828C4438)
	// 828C4418: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C441C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C4420: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C4424: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C4428: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C442C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C4430: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C4434: 40810054  ble 0x828c4488
	if !ctx.cr[0].gt {
	pc = 0x828C4488; continue 'dispatch;
	}
	pc = 0x828C4438; continue 'dispatch;
            }
            0x828C4438 => {
    //   block [0x828C4438..0x828C4458)
	// 828C4438: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C443C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C4440: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C4444: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4448: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 828C444C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C4450: 41980008  blt cr6, 0x828c4458
	if ctx.cr[6].lt {
	pc = 0x828C4458; continue 'dispatch;
	}
	// 828C4454: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828C4458; continue 'dispatch;
            }
            0x828C4458 => {
    //   block [0x828C4458..0x828C4474)
	// 828C4458: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C445C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C4460: 419A0014  beq cr6, 0x828c4474
	if ctx.cr[6].eq {
	pc = 0x828C4474; continue 'dispatch;
	}
	// 828C4464: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C4468: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C446C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C4470: 4800000C  b 0x828c447c
	pc = 0x828C447C; continue 'dispatch;
            }
            0x828C4474 => {
    //   block [0x828C4474..0x828C447C)
	// 828C4474: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C4478: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C447C; continue 'dispatch;
            }
            0x828C447C => {
    //   block [0x828C447C..0x828C4488)
	// 828C447C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C4480: 4199FFB8  bgt cr6, 0x828c4438
	if ctx.cr[6].gt {
	pc = 0x828C4438; continue 'dispatch;
	}
	// 828C4484: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C4488; continue 'dispatch;
            }
            0x828C4488 => {
    //   block [0x828C4488..0x828C44A4)
	// 828C4488: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C448C: 419A0040  beq cr6, 0x828c44cc
	if ctx.cr[6].eq {
	pc = 0x828C44CC; continue 'dispatch;
	}
	// 828C4490: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4494: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 828C4498: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C449C: 41990008  bgt cr6, 0x828c44a4
	if ctx.cr[6].gt {
	pc = 0x828C44A4; continue 'dispatch;
	}
	// 828C44A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C44A4; continue 'dispatch;
            }
            0x828C44A4 => {
    //   block [0x828C44A4..0x828C44CC)
	// 828C44A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C44A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C44AC: 409A0020  bne cr6, 0x828c44cc
	if !ctx.cr[6].eq {
	pc = 0x828C44CC; continue 'dispatch;
	}
	// 828C44B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C44B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C44B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C44BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C44C0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828C44C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C44C8: 48000020  b 0x828c44e8
	pc = 0x828C44E8; continue 'dispatch;
            }
            0x828C44CC => {
    //   block [0x828C44CC..0x828C44E0)
	// 828C44CC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C44D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C44D4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828C44D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C44DC: 4800000C  b 0x828c44e8
	pc = 0x828C44E8; continue 'dispatch;
            }
            0x828C44E0 => {
    //   block [0x828C44E0..0x828C44E8)
	// 828C44E0: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C44E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C44E8; continue 'dispatch;
            }
            0x828C44E8 => {
    //   block [0x828C44E8..0x828C4524)
	// 828C44E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C44EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C44F0: 419A0034  beq cr6, 0x828c4524
	if ctx.cr[6].eq {
	pc = 0x828C4524; continue 'dispatch;
	}
	// 828C44F4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828C44F8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C44FC: 388B2EEC  addi r4, r11, 0x2eec
	ctx.r[4].s64 = ctx.r[11].s64 + 12012;
	// 828C4500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4504: 4B9689CD  bl 0x8222ced0
	ctx.lr = 0x828C4508;
	sub_8222CED0(ctx, base);
	// 828C4508: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828C450C: 38BE0014  addi r5, r30, 0x14
	ctx.r[5].s64 = ctx.r[30].s64 + 20;
	// 828C4510: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 828C4514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4518: 4B979F11  bl 0x8223e428
	ctx.lr = 0x828C451C;
	sub_8223E428(ctx, base);
	// 828C451C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4520: 4B9508B9  bl 0x82214dd8
	ctx.lr = 0x828C4524;
	sub_82214DD8(ctx, base);
	pc = 0x828C4524; continue 'dispatch;
            }
            0x828C4524 => {
    //   block [0x828C4524..0x828C4548)
	// 828C4524: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C4528: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C452C: 4BAC8F8D  bl 0x8238d4b8
	ctx.lr = 0x828C4530;
	sub_8238D4B8(ctx, base);
	// 828C4530: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4534: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4538: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C453C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C4540: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4548 size=312
    let mut pc: u32 = 0x828C4548;
    'dispatch: loop {
        match pc {
            0x828C4548 => {
    //   block [0x828C4548..0x828C4590)
	// 828C4548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C454C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4550: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4554: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4558: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C455C: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 828C4560: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C4564: 419A00EC  beq cr6, 0x828c4650
	if ctx.cr[6].eq {
	pc = 0x828C4650; continue 'dispatch;
	}
	// 828C4568: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C456C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C4570: 419A0020  beq cr6, 0x828c4590
	if ctx.cr[6].eq {
	pc = 0x828C4590; continue 'dispatch;
	}
	// 828C4574: 892A0013  lbz r9, 0x13(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 828C4578: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C457C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828C4580: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C4584: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4588: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C458C: 480000CC  b 0x828c4658
	pc = 0x828C4658; continue 'dispatch;
            }
            0x828C4590 => {
    //   block [0x828C4590..0x828C45B0)
	// 828C4590: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C4594: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C4598: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C459C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C45A0: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C45A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C45A8: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C45AC: 40810054  ble 0x828c4600
	if !ctx.cr[0].gt {
	pc = 0x828C4600; continue 'dispatch;
	}
	pc = 0x828C45B0; continue 'dispatch;
            }
            0x828C45B0 => {
    //   block [0x828C45B0..0x828C45D0)
	// 828C45B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C45B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C45B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C45BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C45C0: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 828C45C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C45C8: 41980008  blt cr6, 0x828c45d0
	if ctx.cr[6].lt {
	pc = 0x828C45D0; continue 'dispatch;
	}
	// 828C45CC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828C45D0; continue 'dispatch;
            }
            0x828C45D0 => {
    //   block [0x828C45D0..0x828C45EC)
	// 828C45D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C45D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C45D8: 419A0014  beq cr6, 0x828c45ec
	if ctx.cr[6].eq {
	pc = 0x828C45EC; continue 'dispatch;
	}
	// 828C45DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C45E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C45E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C45E8: 4800000C  b 0x828c45f4
	pc = 0x828C45F4; continue 'dispatch;
            }
            0x828C45EC => {
    //   block [0x828C45EC..0x828C45F4)
	// 828C45EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C45F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C45F4; continue 'dispatch;
            }
            0x828C45F4 => {
    //   block [0x828C45F4..0x828C4600)
	// 828C45F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C45F8: 4199FFB8  bgt cr6, 0x828c45b0
	if ctx.cr[6].gt {
	pc = 0x828C45B0; continue 'dispatch;
	}
	// 828C45FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C4600; continue 'dispatch;
            }
            0x828C4600 => {
    //   block [0x828C4600..0x828C461C)
	// 828C4600: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C4604: 419A003C  beq cr6, 0x828c4640
	if ctx.cr[6].eq {
	pc = 0x828C4640; continue 'dispatch;
	}
	// 828C4608: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C460C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 828C4610: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C4614: 41990008  bgt cr6, 0x828c461c
	if ctx.cr[6].gt {
	pc = 0x828C461C; continue 'dispatch;
	}
	// 828C4618: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C461C; continue 'dispatch;
            }
            0x828C461C => {
    //   block [0x828C461C..0x828C4640)
	// 828C461C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C4620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4624: 409A001C  bne cr6, 0x828c4640
	if !ctx.cr[6].eq {
	pc = 0x828C4640; continue 'dispatch;
	}
	// 828C4628: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C462C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4630: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C4634: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C4638: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C463C: 4800001C  b 0x828c4658
	pc = 0x828C4658; continue 'dispatch;
            }
            0x828C4640 => {
    //   block [0x828C4640..0x828C4650)
	// 828C4640: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C4644: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4648: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C464C: 4800000C  b 0x828c4658
	pc = 0x828C4658; continue 'dispatch;
            }
            0x828C4650 => {
    //   block [0x828C4650..0x828C4658)
	// 828C4650: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C4654: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828C4658; continue 'dispatch;
            }
            0x828C4658 => {
    //   block [0x828C4658..0x828C4670)
	// 828C4658: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C465C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C4660: 419A0010  beq cr6, 0x828c4670
	if ctx.cr[6].eq {
	pc = 0x828C4670; continue 'dispatch;
	}
	// 828C4664: 38830014  addi r4, r3, 0x14
	ctx.r[4].s64 = ctx.r[3].s64 + 20;
	// 828C4668: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C466C: 4BC9FA15  bl 0x82564080
	ctx.lr = 0x828C4670;
	sub_82564080(ctx, base);
	pc = 0x828C4670; continue 'dispatch;
            }
            0x828C4670 => {
    //   block [0x828C4670..0x828C4680)
	// 828C4670: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C4674: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4678: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C467C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4680 size=424
    let mut pc: u32 = 0x828C4680;
    'dispatch: loop {
        match pc {
            0x828C4680 => {
    //   block [0x828C4680..0x828C46B0)
	// 828C4680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4684: 483E4D89  bl 0x82ca940c
	ctx.lr = 0x828C4688;
	sub_82CA93D0(ctx, base);
	// 828C4688: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C468C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C4690: 83C60000  lwz r30, 0(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4694: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C4698: 3BEB0CA0  addi r31, r11, 0xca0
	ctx.r[31].s64 = ctx.r[11].s64 + 3232;
	// 828C469C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C46A0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C46A4: 409A003C  bne cr6, 0x828c46e0
	if !ctx.cr[6].eq {
	pc = 0x828C46E0; continue 'dispatch;
	}
	// 828C46A8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828C46AC: 396BA3E4  addi r11, r11, -0x5c1c
	ctx.r[11].s64 = ctx.r[11].s64 + -23580;
	pc = 0x828C46B0; continue 'dispatch;
            }
            0x828C46B0 => {
    //   block [0x828C46B0..0x828C46D4)
	// 828C46B0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C46B4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C46B8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C46BC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C46C0: 419A0014  beq cr6, 0x828c46d4
	if ctx.cr[6].eq {
	pc = 0x828C46D4; continue 'dispatch;
	}
	// 828C46C4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C46C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C46CC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C46D0: 419AFFE0  beq cr6, 0x828c46b0
	if ctx.cr[6].eq {
	pc = 0x828C46B0; continue 'dispatch;
	}
	pc = 0x828C46D4; continue 'dispatch;
            }
            0x828C46D4 => {
    //   block [0x828C46D4..0x828C46E0)
	// 828C46D4: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828C46D8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C46DC: 48000018  b 0x828c46f4
	pc = 0x828C46F4; continue 'dispatch;
            }
            0x828C46E0 => {
    //   block [0x828C46E0..0x828C46F4)
	// 828C46E0: 388BA3E4  addi r4, r11, -0x5c1c
	ctx.r[4].s64 = ctx.r[11].s64 + -23580;
	// 828C46E4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C46E8: 4B9A9111  bl 0x8226d7f8
	ctx.lr = 0x828C46EC;
	sub_8226D7F8(ctx, base);
	// 828C46EC: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828C46F0: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x828C46F4; continue 'dispatch;
            }
            0x828C46F4 => {
    //   block [0x828C46F4..0x828C4720)
	// 828C46F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C46F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C46FC: 419A0024  beq cr6, 0x828c4720
	if ctx.cr[6].eq {
	pc = 0x828C4720; continue 'dispatch;
	}
	// 828C4700: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4704: 397DFFF4  addi r11, r29, -0xc
	ctx.r[11].s64 = ctx.r[29].s64 + -12;
	// 828C4708: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 828C470C: 419A0114  beq cr6, 0x828c4820
	if ctx.cr[6].eq {
	pc = 0x828C4820; continue 'dispatch;
	}
	// 828C4710: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 828C4714: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828C4718: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C471C: 483E4D40  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x828C4720 => {
    //   block [0x828C4720..0x828C4734)
	// 828C4720: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C4724: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C4728: 409A003C  bne cr6, 0x828c4764
	if !ctx.cr[6].eq {
	pc = 0x828C4764; continue 'dispatch;
	}
	// 828C472C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828C4730: 396BA3EC  addi r11, r11, -0x5c14
	ctx.r[11].s64 = ctx.r[11].s64 + -23572;
	pc = 0x828C4734; continue 'dispatch;
            }
            0x828C4734 => {
    //   block [0x828C4734..0x828C4758)
	// 828C4734: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4738: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C473C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C4740: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C4744: 419A0014  beq cr6, 0x828c4758
	if ctx.cr[6].eq {
	pc = 0x828C4758; continue 'dispatch;
	}
	// 828C4748: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C474C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C4750: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C4754: 419AFFE0  beq cr6, 0x828c4734
	if ctx.cr[6].eq {
	pc = 0x828C4734; continue 'dispatch;
	}
	pc = 0x828C4758; continue 'dispatch;
            }
            0x828C4758 => {
    //   block [0x828C4758..0x828C4764)
	// 828C4758: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828C475C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C4760: 48000018  b 0x828c4778
	pc = 0x828C4778; continue 'dispatch;
            }
            0x828C4764 => {
    //   block [0x828C4764..0x828C4778)
	// 828C4764: 388BA3EC  addi r4, r11, -0x5c14
	ctx.r[4].s64 = ctx.r[11].s64 + -23572;
	// 828C4768: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C476C: 4B9A908D  bl 0x8226d7f8
	ctx.lr = 0x828C4770;
	sub_8226D7F8(ctx, base);
	// 828C4770: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828C4774: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x828C4778; continue 'dispatch;
            }
            0x828C4778 => {
    //   block [0x828C4778..0x828C47A4)
	// 828C4778: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C477C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4780: 419A0024  beq cr6, 0x828c47a4
	if ctx.cr[6].eq {
	pc = 0x828C47A4; continue 'dispatch;
	}
	// 828C4784: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4788: 397DFFF4  addi r11, r29, -0xc
	ctx.r[11].s64 = ctx.r[29].s64 + -12;
	// 828C478C: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 828C4790: 419A0090  beq cr6, 0x828c4820
	if ctx.cr[6].eq {
	pc = 0x828C4820; continue 'dispatch;
	}
	// 828C4794: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 828C4798: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828C479C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C47A0: 483E4CBC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x828C47A4 => {
    //   block [0x828C47A4..0x828C47B8)
	// 828C47A4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C47A8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C47AC: 409A003C  bne cr6, 0x828c47e8
	if !ctx.cr[6].eq {
	pc = 0x828C47E8; continue 'dispatch;
	}
	// 828C47B0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828C47B4: 396BA3F4  addi r11, r11, -0x5c0c
	ctx.r[11].s64 = ctx.r[11].s64 + -23564;
	pc = 0x828C47B8; continue 'dispatch;
            }
            0x828C47B8 => {
    //   block [0x828C47B8..0x828C47DC)
	// 828C47B8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C47BC: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C47C0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C47C4: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C47C8: 419A0014  beq cr6, 0x828c47dc
	if ctx.cr[6].eq {
	pc = 0x828C47DC; continue 'dispatch;
	}
	// 828C47CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C47D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C47D4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C47D8: 419AFFE0  beq cr6, 0x828c47b8
	if ctx.cr[6].eq {
	pc = 0x828C47B8; continue 'dispatch;
	}
	pc = 0x828C47DC; continue 'dispatch;
            }
            0x828C47DC => {
    //   block [0x828C47DC..0x828C47E8)
	// 828C47DC: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828C47E0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C47E4: 48000018  b 0x828c47fc
	pc = 0x828C47FC; continue 'dispatch;
            }
            0x828C47E8 => {
    //   block [0x828C47E8..0x828C47FC)
	// 828C47E8: 388BA3F4  addi r4, r11, -0x5c0c
	ctx.r[4].s64 = ctx.r[11].s64 + -23564;
	// 828C47EC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C47F0: 4B9A9009  bl 0x8226d7f8
	ctx.lr = 0x828C47F4;
	sub_8226D7F8(ctx, base);
	// 828C47F4: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828C47F8: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x828C47FC; continue 'dispatch;
            }
            0x828C47FC => {
    //   block [0x828C47FC..0x828C4820)
	// 828C47FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C4800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4804: 419A001C  beq cr6, 0x828c4820
	if ctx.cr[6].eq {
	pc = 0x828C4820; continue 'dispatch;
	}
	// 828C4808: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C480C: 397DFFF4  addi r11, r29, -0xc
	ctx.r[11].s64 = ctx.r[29].s64 + -12;
	// 828C4810: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 828C4814: 419A000C  beq cr6, 0x828c4820
	if ctx.cr[6].eq {
	pc = 0x828C4820; continue 'dispatch;
	}
	// 828C4818: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C481C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x828C4820; continue 'dispatch;
            }
            0x828C4820 => {
    //   block [0x828C4820..0x828C4828)
	// 828C4820: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4824: 483E4C38  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4828 size=184
    let mut pc: u32 = 0x828C4828;
    'dispatch: loop {
        match pc {
            0x828C4828 => {
    //   block [0x828C4828..0x828C48E0)
	// 828C4828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C482C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4830: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C4834: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4838: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C483C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C4840: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C4844: 390B0B7C  addi r8, r11, 0xb7c
	ctx.r[8].s64 = ctx.r[11].s64 + 2940;
	// 828C4848: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828C484C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C4850: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828C4854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4858: 3BFE0020  addi r31, r30, 0x20
	ctx.r[31].s64 = ctx.r[30].s64 + 32;
	// 828C485C: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 828C4860: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C4864: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828C4868: 4B950031  bl 0x82214898
	ctx.lr = 0x828C486C;
	sub_82214898(ctx, base);
	// 828C486C: 80FE0024  lwz r7, 0x24(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C4870: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828C4874: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828C4878: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	// 828C487C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828C4880: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C4884: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 828C4888: 80870000  lwz r4, 0(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C488C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C4890: 90810064  stw r4, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 828C4894: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828C4898: 4BE68EB9  bl 0x8272d750
	ctx.lr = 0x828C489C;
	sub_8272D750(ctx, base);
	// 828C489C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C48A0: E8C10068  ld r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828C48A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C48A8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C48AC: E8AB0000  ld r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828C48B0: 4BE68891  bl 0x8272d140
	ctx.lr = 0x828C48B4;
	sub_8272D140(ctx, base);
	// 828C48B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C48B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C48BC: 392A0B7C  addi r9, r10, 0xb7c
	ctx.r[9].s64 = ctx.r[10].s64 + 2940;
	// 828C48C0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C48C4: 4B8CF575  bl 0x82193e38
	ctx.lr = 0x828C48C8;
	sub_82193E38(ctx, base);
	// 828C48C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C48CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C48D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C48D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C48D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C48DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C48F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C48F8 size=584
    let mut pc: u32 = 0x828C48F8;
    'dispatch: loop {
        match pc {
            0x828C48F8 => {
    //   block [0x828C48F8..0x828C4920)
	// 828C48F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C48FC: 483E4B05  bl 0x82ca9400
	ctx.lr = 0x828C4900;
	sub_82CA93D0(ctx, base);
	// 828C4900: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4904: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4908: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C490C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4910: 409A0010  bne cr6, 0x828c4920
	if !ctx.cr[6].eq {
	pc = 0x828C4920; continue 'dispatch;
	}
	// 828C4914: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C4918: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828C491C: 48000008  b 0x828c4924
	pc = 0x828C4924; continue 'dispatch;
            }
            0x828C4920 => {
    //   block [0x828C4920..0x828C4924)
	// 828C4920: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C4924; continue 'dispatch;
            }
            0x828C4924 => {
    //   block [0x828C4924..0x828C499C)
	// 828C4924: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4928: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C492C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4930: 4BB09C91  bl 0x823ce5c0
	ctx.lr = 0x828C4934;
	sub_823CE5C0(ctx, base);
	// 828C4934: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C4938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C493C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4940: 4BB098C1  bl 0x823ce200
	ctx.lr = 0x828C4944;
	sub_823CE200(ctx, base);
	// 828C4944: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4948: 4B8F31D1  bl 0x821b7b18
	ctx.lr = 0x828C494C;
	sub_821B7B18(ctx, base);
	// 828C494C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828C4950: 4B95A909  bl 0x8221f258
	ctx.lr = 0x828C4954;
	sub_8221F258(ctx, base);
	// 828C4954: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C4958: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C495C: 419A0040  beq cr6, 0x828c499c
	if ctx.cr[6].eq {
	pc = 0x828C499C; continue 'dispatch;
	}
	// 828C4960: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828C4964: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C4968: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828C496C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C4970: 4B95A8E9  bl 0x8221f258
	ctx.lr = 0x828C4974;
	sub_8221F258(ctx, base);
	// 828C4974: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C4978: 419A0028  beq cr6, 0x828c49a0
	if ctx.cr[6].eq {
	pc = 0x828C49A0; continue 'dispatch;
	}
	// 828C497C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C4980: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828C4984: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4988: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C498C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C4990: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C4994: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C4998: 4800000C  b 0x828c49a4
	pc = 0x828C49A4; continue 'dispatch;
            }
            0x828C499C => {
    //   block [0x828C499C..0x828C49A0)
	// 828C499C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828C49A0; continue 'dispatch;
            }
            0x828C49A0 => {
    //   block [0x828C49A0..0x828C49A4)
	// 828C49A0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828C49A4; continue 'dispatch;
            }
            0x828C49A4 => {
    //   block [0x828C49A4..0x828C4AA8)
	// 828C49A4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C49A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C49AC: 419A00FC  beq cr6, 0x828c4aa8
	if ctx.cr[6].eq {
	pc = 0x828C4AA8; continue 'dispatch;
	}
	// 828C49B0: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C49B4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C49B8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C49BC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C49C0: 4B964749  bl 0x82229108
	ctx.lr = 0x828C49C4;
	sub_82229108(ctx, base);
	// 828C49C4: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C49C8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C49CC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C49D0: 3BCB5170  addi r30, r11, 0x5170
	ctx.r[30].s64 = ctx.r[11].s64 + 20848;
	// 828C49D4: 4B962EAD  bl 0x82227880
	ctx.lr = 0x828C49D8;
	sub_82227880(ctx, base);
	// 828C49D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C49DC: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828C49E0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C49E4: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828C49E8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C49EC: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C49F0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C49F4: 4B8D608D  bl 0x8219aa80
	ctx.lr = 0x828C49F8;
	sub_8219AA80(ctx, base);
	// 828C49F8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828C49FC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828C4A00: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828C4A04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4A08: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C4A0C: 4BB09A15  bl 0x823ce420
	ctx.lr = 0x828C4A10;
	sub_823CE420(ctx, base);
	// 828C4A10: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C4A14: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C4A18: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C4A1C: 4815FCAD  bl 0x82a246c8
	ctx.lr = 0x828C4A20;
	sub_82A246C8(ctx, base);
	// 828C4A20: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4A24: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C4A28: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828C4A2C: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828C4A30: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4A34: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4A38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4A3C: 4B9646CD  bl 0x82229108
	ctx.lr = 0x828C4A40;
	sub_82229108(ctx, base);
	// 828C4A40: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 828C4A44: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C4A48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4A4C: 3BEB6B58  addi r31, r11, 0x6b58
	ctx.r[31].s64 = ctx.r[11].s64 + 27480;
	// 828C4A50: 4B962E31  bl 0x82227880
	ctx.lr = 0x828C4A54;
	sub_82227880(ctx, base);
	// 828C4A54: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828C4A58: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828C4A5C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C4A60: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828C4A64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4A68: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C4A6C: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C4A70: 4B8D6011  bl 0x8219aa80
	ctx.lr = 0x828C4A74;
	sub_8219AA80(ctx, base);
	// 828C4A74: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828C4A78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C4A7C: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828C4A80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4A84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4A88: 4BB09999  bl 0x823ce420
	ctx.lr = 0x828C4A8C;
	sub_823CE420(ctx, base);
	// 828C4A8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4A90: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C4A94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4A98: 4815FC31  bl 0x82a246c8
	ctx.lr = 0x828C4A9C;
	sub_82A246C8(ctx, base);
	// 828C4A9C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4AA0: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828C4AA4: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x828C4AA8; continue 'dispatch;
            }
            0x828C4AA8 => {
    //   block [0x828C4AA8..0x828C4AB8)
	// 828C4AA8: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828C4AAC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C4AB0: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828C4AB4: 419A0020  beq cr6, 0x828c4ad4
	if ctx.cr[6].eq {
	pc = 0x828C4AD4; continue 'dispatch;
	}
	pc = 0x828C4AB8; continue 'dispatch;
            }
            0x828C4AB8 => {
    //   block [0x828C4AB8..0x828C4AD4)
	// 828C4AB8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C4ABC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4AC0: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C4AC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C4AC8: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C4ACC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4AD0: 4082FFE8  bne 0x828c4ab8
	if !ctx.cr[0].eq {
	pc = 0x828C4AB8; continue 'dispatch;
	}
	pc = 0x828C4AD4; continue 'dispatch;
            }
            0x828C4AD4 => {
    //   block [0x828C4AD4..0x828C4AF4)
	// 828C4AD4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4AD8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C4ADC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C4AE0: 4BA30E69  bl 0x822f5948
	ctx.lr = 0x828C4AE4;
	sub_822F5948(ctx, base);
	// 828C4AE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4AE8: 4B8F3031  bl 0x821b7b18
	ctx.lr = 0x828C4AEC;
	sub_821B7B18(ctx, base);
	// 828C4AEC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C4AF0: 419A0040  beq cr6, 0x828c4b30
	if ctx.cr[6].eq {
	pc = 0x828C4B30; continue 'dispatch;
	}
	pc = 0x828C4AF4; continue 'dispatch;
            }
            0x828C4AF4 => {
    //   block [0x828C4AF4..0x828C4B30)
	// 828C4AF4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C4AF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4AFC: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C4B00: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C4B04: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C4B08: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4B0C: 4082FFE8  bne 0x828c4af4
	if !ctx.cr[0].eq {
	pc = 0x828C4AF4; continue 'dispatch;
	}
	// 828C4B10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C4B14: 409A001C  bne cr6, 0x828c4b30
	if !ctx.cr[6].eq {
	pc = 0x828C4B30; continue 'dispatch;
	}
	// 828C4B18: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4B1C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4B20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4B24: 4E800421  bctrl
	ctx.lr = 0x828C4B28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4B28: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C4B2C: 4B95720D  bl 0x8221bd38
	ctx.lr = 0x828C4B30;
	sub_8221BD38(ctx, base);
            }
            0x828C4B30 => {
    //   block [0x828C4B30..0x828C4B40)
	// 828C4B30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4B34: 4B8F2FE5  bl 0x821b7b18
	ctx.lr = 0x828C4B38;
	sub_821B7B18(ctx, base);
	// 828C4B38: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C4B3C: 483E4914  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4B40 size=528
    let mut pc: u32 = 0x828C4B40;
    'dispatch: loop {
        match pc {
            0x828C4B40 => {
    //   block [0x828C4B40..0x828C4B78)
	// 828C4B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4B44: 483E48B9  bl 0x82ca93fc
	ctx.lr = 0x828C4B48;
	sub_82CA93D0(ctx, base);
	// 828C4B48: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4B4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C4B50: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C4B54: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C4B58: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828C4B5C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C4B60: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4B64: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C4B68: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C4B6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4B70: 419A0008  beq cr6, 0x828c4b78
	if ctx.cr[6].eq {
	pc = 0x828C4B78; continue 'dispatch;
	}
	// 828C4B74: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C4B78; continue 'dispatch;
            }
            0x828C4B78 => {
    //   block [0x828C4B78..0x828C4C1C)
	// 828C4B78: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4B7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4B80: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4B84: 4BB09A3D  bl 0x823ce5c0
	ctx.lr = 0x828C4B88;
	sub_823CE5C0(ctx, base);
	// 828C4B88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C4B8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4B90: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4B94: 4BB0957D  bl 0x823ce110
	ctx.lr = 0x828C4B98;
	sub_823CE110(ctx, base);
	// 828C4B98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4B9C: 4B8F2F7D  bl 0x821b7b18
	ctx.lr = 0x828C4BA0;
	sub_821B7B18(ctx, base);
	// 828C4BA0: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828C4BA4: 4B95A6B5  bl 0x8221f258
	ctx.lr = 0x828C4BA8;
	sub_8221F258(ctx, base);
	// 828C4BA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C4BAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4BB0: 419A006C  beq cr6, 0x828c4c1c
	if ctx.cr[6].eq {
	pc = 0x828C4C1C; continue 'dispatch;
	}
	// 828C4BB4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828C4BB8: FBBF0010  std r29, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u64 ) };
	// 828C4BBC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C4BC0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C4BC4: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 828C4BC8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4BCC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828C4BD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C4BD4: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C4BD8: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828C4BDC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C4BE0: F8FF0008  std r7, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 828C4BE4: 4B92B65D  bl 0x821f0240
	ctx.lr = 0x828C4BE8;
	sub_821F0240(ctx, base);
	// 828C4BE8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C4BEC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C4BF0: 4B95A669  bl 0x8221f258
	ctx.lr = 0x828C4BF4;
	sub_8221F258(ctx, base);
	// 828C4BF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C4BF8: 419A0028  beq cr6, 0x828c4c20
	if ctx.cr[6].eq {
	pc = 0x828C4C20; continue 'dispatch;
	}
	// 828C4BFC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C4C00: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C4C04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4C08: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C4C0C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C4C10: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C4C14: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C4C18: 4800000C  b 0x828c4c24
	pc = 0x828C4C24; continue 'dispatch;
            }
            0x828C4C1C => {
    //   block [0x828C4C1C..0x828C4C20)
	// 828C4C1C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828C4C20; continue 'dispatch;
            }
            0x828C4C20 => {
    //   block [0x828C4C20..0x828C4C24)
	// 828C4C20: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828C4C24; continue 'dispatch;
            }
            0x828C4C24 => {
    //   block [0x828C4C24..0x828C4C38)
	// 828C4C24: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4C28: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C4C2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4C30: 419A0008  beq cr6, 0x828c4c38
	if ctx.cr[6].eq {
	pc = 0x828C4C38; continue 'dispatch;
	}
	// 828C4C34: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C4C38; continue 'dispatch;
            }
            0x828C4C38 => {
    //   block [0x828C4C38..0x828C4CB8)
	// 828C4C38: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C4C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4C40: 419A0078  beq cr6, 0x828c4cb8
	if ctx.cr[6].eq {
	pc = 0x828C4CB8; continue 'dispatch;
	}
	// 828C4C44: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4C48: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C4C4C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4C50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4C54: 4B9644B5  bl 0x82229108
	ctx.lr = 0x828C4C58;
	sub_82229108(ctx, base);
	// 828C4C58: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C4C5C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C4C60: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4C64: 3BCB51B0  addi r30, r11, 0x51b0
	ctx.r[30].s64 = ctx.r[11].s64 + 20912;
	// 828C4C68: 4B962C19  bl 0x82227880
	ctx.lr = 0x828C4C6C;
	sub_82227880(ctx, base);
	// 828C4C6C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C4C70: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828C4C74: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C4C78: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828C4C7C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4C80: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C4C84: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C4C88: 4B8D5DF9  bl 0x8219aa80
	ctx.lr = 0x828C4C8C;
	sub_8219AA80(ctx, base);
	// 828C4C8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4C90: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C4C94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4C98: 4BB09789  bl 0x823ce420
	ctx.lr = 0x828C4C9C;
	sub_823CE420(ctx, base);
	// 828C4C9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4CA0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C4CA4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4CA8: 4815FA21  bl 0x82a246c8
	ctx.lr = 0x828C4CAC;
	sub_82A246C8(ctx, base);
	// 828C4CAC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4CB0: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C4CB4: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828C4CB8; continue 'dispatch;
            }
            0x828C4CB8 => {
    //   block [0x828C4CB8..0x828C4CC8)
	// 828C4CB8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C4CBC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C4CC0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C4CC4: 419A0020  beq cr6, 0x828c4ce4
	if ctx.cr[6].eq {
	pc = 0x828C4CE4; continue 'dispatch;
	}
	pc = 0x828C4CC8; continue 'dispatch;
            }
            0x828C4CC8 => {
    //   block [0x828C4CC8..0x828C4CE4)
	// 828C4CC8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C4CCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4CD0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C4CD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C4CD8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C4CDC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4CE0: 4082FFE8  bne 0x828c4cc8
	if !ctx.cr[0].eq {
	pc = 0x828C4CC8; continue 'dispatch;
	}
	pc = 0x828C4CE4; continue 'dispatch;
            }
            0x828C4CE4 => {
    //   block [0x828C4CE4..0x828C4D04)
	// 828C4CE4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4CE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C4CEC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C4CF0: 4BA30C59  bl 0x822f5948
	ctx.lr = 0x828C4CF4;
	sub_822F5948(ctx, base);
	// 828C4CF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4CF8: 4B8F2E21  bl 0x821b7b18
	ctx.lr = 0x828C4CFC;
	sub_821B7B18(ctx, base);
	// 828C4CFC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C4D00: 419A0040  beq cr6, 0x828c4d40
	if ctx.cr[6].eq {
	pc = 0x828C4D40; continue 'dispatch;
	}
	pc = 0x828C4D04; continue 'dispatch;
            }
            0x828C4D04 => {
    //   block [0x828C4D04..0x828C4D40)
	// 828C4D04: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C4D08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4D0C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C4D10: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C4D14: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C4D18: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4D1C: 4082FFE8  bne 0x828c4d04
	if !ctx.cr[0].eq {
	pc = 0x828C4D04; continue 'dispatch;
	}
	// 828C4D20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C4D24: 409A001C  bne cr6, 0x828c4d40
	if !ctx.cr[6].eq {
	pc = 0x828C4D40; continue 'dispatch;
	}
	// 828C4D28: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4D2C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4D30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4D34: 4E800421  bctrl
	ctx.lr = 0x828C4D38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4D38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C4D3C: 4B956FFD  bl 0x8221bd38
	ctx.lr = 0x828C4D40;
	sub_8221BD38(ctx, base);
            }
            0x828C4D40 => {
    //   block [0x828C4D40..0x828C4D50)
	// 828C4D40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4D44: 4B8F2DD5  bl 0x821b7b18
	ctx.lr = 0x828C4D48;
	sub_821B7B18(ctx, base);
	// 828C4D48: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C4D4C: 483E4700  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4D50 size=528
    let mut pc: u32 = 0x828C4D50;
    'dispatch: loop {
        match pc {
            0x828C4D50 => {
    //   block [0x828C4D50..0x828C4D88)
	// 828C4D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4D54: 483E46A9  bl 0x82ca93fc
	ctx.lr = 0x828C4D58;
	sub_82CA93D0(ctx, base);
	// 828C4D58: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4D5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C4D60: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C4D64: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C4D68: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828C4D6C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C4D70: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4D74: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C4D78: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C4D7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4D80: 419A0008  beq cr6, 0x828c4d88
	if ctx.cr[6].eq {
	pc = 0x828C4D88; continue 'dispatch;
	}
	// 828C4D84: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C4D88; continue 'dispatch;
            }
            0x828C4D88 => {
    //   block [0x828C4D88..0x828C4E2C)
	// 828C4D88: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4D8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4D90: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4D94: 4BB0982D  bl 0x823ce5c0
	ctx.lr = 0x828C4D98;
	sub_823CE5C0(ctx, base);
	// 828C4D98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C4D9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4DA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4DA4: 4BB0936D  bl 0x823ce110
	ctx.lr = 0x828C4DA8;
	sub_823CE110(ctx, base);
	// 828C4DA8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4DAC: 4B8F2D6D  bl 0x821b7b18
	ctx.lr = 0x828C4DB0;
	sub_821B7B18(ctx, base);
	// 828C4DB0: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828C4DB4: 4B95A4A5  bl 0x8221f258
	ctx.lr = 0x828C4DB8;
	sub_8221F258(ctx, base);
	// 828C4DB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C4DBC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4DC0: 419A006C  beq cr6, 0x828c4e2c
	if ctx.cr[6].eq {
	pc = 0x828C4E2C; continue 'dispatch;
	}
	// 828C4DC4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828C4DC8: FBBF0010  std r29, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u64 ) };
	// 828C4DCC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C4DD0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C4DD4: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 828C4DD8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4DDC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828C4DE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C4DE4: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C4DE8: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828C4DEC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C4DF0: F8FF0008  std r7, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 828C4DF4: 4B92B44D  bl 0x821f0240
	ctx.lr = 0x828C4DF8;
	sub_821F0240(ctx, base);
	// 828C4DF8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C4DFC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C4E00: 4B95A459  bl 0x8221f258
	ctx.lr = 0x828C4E04;
	sub_8221F258(ctx, base);
	// 828C4E04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C4E08: 419A0028  beq cr6, 0x828c4e30
	if ctx.cr[6].eq {
	pc = 0x828C4E30; continue 'dispatch;
	}
	// 828C4E0C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C4E10: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C4E14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4E18: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C4E1C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C4E20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C4E24: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C4E28: 4800000C  b 0x828c4e34
	pc = 0x828C4E34; continue 'dispatch;
            }
            0x828C4E2C => {
    //   block [0x828C4E2C..0x828C4E30)
	// 828C4E2C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828C4E30; continue 'dispatch;
            }
            0x828C4E30 => {
    //   block [0x828C4E30..0x828C4E34)
	// 828C4E30: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828C4E34; continue 'dispatch;
            }
            0x828C4E34 => {
    //   block [0x828C4E34..0x828C4E48)
	// 828C4E34: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4E38: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C4E3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4E40: 419A0008  beq cr6, 0x828c4e48
	if ctx.cr[6].eq {
	pc = 0x828C4E48; continue 'dispatch;
	}
	// 828C4E44: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C4E48; continue 'dispatch;
            }
            0x828C4E48 => {
    //   block [0x828C4E48..0x828C4EC8)
	// 828C4E48: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C4E4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4E50: 419A0078  beq cr6, 0x828c4ec8
	if ctx.cr[6].eq {
	pc = 0x828C4EC8; continue 'dispatch;
	}
	// 828C4E54: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4E58: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C4E5C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4E60: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4E64: 4B9642A5  bl 0x82229108
	ctx.lr = 0x828C4E68;
	sub_82229108(ctx, base);
	// 828C4E68: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C4E6C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C4E70: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4E74: 3BCB51B0  addi r30, r11, 0x51b0
	ctx.r[30].s64 = ctx.r[11].s64 + 20912;
	// 828C4E78: 4B962A09  bl 0x82227880
	ctx.lr = 0x828C4E7C;
	sub_82227880(ctx, base);
	// 828C4E7C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C4E80: 3D408295  lis r10, -0x7d6b
	ctx.r[10].s64 = -2104164352;
	// 828C4E84: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C4E88: 388AC430  addi r4, r10, -0x3bd0
	ctx.r[4].s64 = ctx.r[10].s64 + -15312;
	// 828C4E8C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4E90: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C4E94: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C4E98: 4B8D5BE9  bl 0x8219aa80
	ctx.lr = 0x828C4E9C;
	sub_8219AA80(ctx, base);
	// 828C4E9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4EA0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C4EA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4EA8: 4BB09579  bl 0x823ce420
	ctx.lr = 0x828C4EAC;
	sub_823CE420(ctx, base);
	// 828C4EAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4EB0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C4EB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C4EB8: 4815F811  bl 0x82a246c8
	ctx.lr = 0x828C4EBC;
	sub_82A246C8(ctx, base);
	// 828C4EBC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4EC0: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C4EC4: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828C4EC8; continue 'dispatch;
            }
            0x828C4EC8 => {
    //   block [0x828C4EC8..0x828C4ED8)
	// 828C4EC8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C4ECC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C4ED0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C4ED4: 419A0020  beq cr6, 0x828c4ef4
	if ctx.cr[6].eq {
	pc = 0x828C4EF4; continue 'dispatch;
	}
	pc = 0x828C4ED8; continue 'dispatch;
            }
            0x828C4ED8 => {
    //   block [0x828C4ED8..0x828C4EF4)
	// 828C4ED8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C4EDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4EE0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C4EE4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C4EE8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C4EEC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4EF0: 4082FFE8  bne 0x828c4ed8
	if !ctx.cr[0].eq {
	pc = 0x828C4ED8; continue 'dispatch;
	}
	pc = 0x828C4EF4; continue 'dispatch;
            }
            0x828C4EF4 => {
    //   block [0x828C4EF4..0x828C4F14)
	// 828C4EF4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4EF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C4EFC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C4F00: 4BA30A49  bl 0x822f5948
	ctx.lr = 0x828C4F04;
	sub_822F5948(ctx, base);
	// 828C4F04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4F08: 4B8F2C11  bl 0x821b7b18
	ctx.lr = 0x828C4F0C;
	sub_821B7B18(ctx, base);
	// 828C4F0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C4F10: 419A0040  beq cr6, 0x828c4f50
	if ctx.cr[6].eq {
	pc = 0x828C4F50; continue 'dispatch;
	}
	pc = 0x828C4F14; continue 'dispatch;
            }
            0x828C4F14 => {
    //   block [0x828C4F14..0x828C4F50)
	// 828C4F14: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C4F18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4F1C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C4F20: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C4F24: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C4F28: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C4F2C: 4082FFE8  bne 0x828c4f14
	if !ctx.cr[0].eq {
	pc = 0x828C4F14; continue 'dispatch;
	}
	// 828C4F30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C4F34: 409A001C  bne cr6, 0x828c4f50
	if !ctx.cr[6].eq {
	pc = 0x828C4F50; continue 'dispatch;
	}
	// 828C4F38: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4F3C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4F40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4F44: 4E800421  bctrl
	ctx.lr = 0x828C4F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4F48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C4F4C: 4B956DED  bl 0x8221bd38
	ctx.lr = 0x828C4F50;
	sub_8221BD38(ctx, base);
            }
            0x828C4F50 => {
    //   block [0x828C4F50..0x828C4F60)
	// 828C4F50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4F54: 4B8F2BC5  bl 0x821b7b18
	ctx.lr = 0x828C4F58;
	sub_821B7B18(ctx, base);
	// 828C4F58: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C4F5C: 483E44F0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4F60 size=528
    let mut pc: u32 = 0x828C4F60;
    'dispatch: loop {
        match pc {
            0x828C4F60 => {
    //   block [0x828C4F60..0x828C4F98)
	// 828C4F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4F64: 483E4499  bl 0x82ca93fc
	ctx.lr = 0x828C4F68;
	sub_82CA93D0(ctx, base);
	// 828C4F68: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4F6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C4F70: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C4F74: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C4F78: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 828C4F7C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C4F80: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4F84: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828C4F88: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C4F8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4F90: 419A0008  beq cr6, 0x828c4f98
	if ctx.cr[6].eq {
	pc = 0x828C4F98; continue 'dispatch;
	}
	// 828C4F94: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C4F98; continue 'dispatch;
            }
            0x828C4F98 => {
    //   block [0x828C4F98..0x828C503C)
	// 828C4F98: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4F9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4FA0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4FA4: 4BB0961D  bl 0x823ce5c0
	ctx.lr = 0x828C4FA8;
	sub_823CE5C0(ctx, base);
	// 828C4FA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C4FAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C4FB0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4FB4: 4BB0915D  bl 0x823ce110
	ctx.lr = 0x828C4FB8;
	sub_823CE110(ctx, base);
	// 828C4FB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4FBC: 4B8F2B5D  bl 0x821b7b18
	ctx.lr = 0x828C4FC0;
	sub_821B7B18(ctx, base);
	// 828C4FC0: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828C4FC4: 4B95A295  bl 0x8221f258
	ctx.lr = 0x828C4FC8;
	sub_8221F258(ctx, base);
	// 828C4FC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C4FCC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4FD0: 419A006C  beq cr6, 0x828c503c
	if ctx.cr[6].eq {
	pc = 0x828C503C; continue 'dispatch;
	}
	// 828C4FD4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828C4FD8: FBBF0008  std r29, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 828C4FDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C4FE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C4FE4: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 828C4FE8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4FEC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828C4FF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C4FF4: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C4FF8: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828C4FFC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C5000: F8FF0010  std r7, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 828C5004: 4B92B23D  bl 0x821f0240
	ctx.lr = 0x828C5008;
	sub_821F0240(ctx, base);
	// 828C5008: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C500C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C5010: 4B95A249  bl 0x8221f258
	ctx.lr = 0x828C5014;
	sub_8221F258(ctx, base);
	// 828C5014: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C5018: 419A0028  beq cr6, 0x828c5040
	if ctx.cr[6].eq {
	pc = 0x828C5040; continue 'dispatch;
	}
	// 828C501C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C5020: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C5024: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C5028: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C502C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C5030: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C5034: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C5038: 4800000C  b 0x828c5044
	pc = 0x828C5044; continue 'dispatch;
            }
            0x828C503C => {
    //   block [0x828C503C..0x828C5040)
	// 828C503C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828C5040; continue 'dispatch;
            }
            0x828C5040 => {
    //   block [0x828C5040..0x828C5044)
	// 828C5040: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828C5044; continue 'dispatch;
            }
            0x828C5044 => {
    //   block [0x828C5044..0x828C5058)
	// 828C5044: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5048: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C504C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5050: 419A0008  beq cr6, 0x828c5058
	if ctx.cr[6].eq {
	pc = 0x828C5058; continue 'dispatch;
	}
	// 828C5054: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C5058; continue 'dispatch;
            }
            0x828C5058 => {
    //   block [0x828C5058..0x828C50D8)
	// 828C5058: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C505C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5060: 419A0078  beq cr6, 0x828c50d8
	if ctx.cr[6].eq {
	pc = 0x828C50D8; continue 'dispatch;
	}
	// 828C5064: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5068: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C506C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5070: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C5074: 4B964095  bl 0x82229108
	ctx.lr = 0x828C5078;
	sub_82229108(ctx, base);
	// 828C5078: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C507C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C5080: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C5084: 3BCB5328  addi r30, r11, 0x5328
	ctx.r[30].s64 = ctx.r[11].s64 + 21288;
	// 828C5088: 4B9627F9  bl 0x82227880
	ctx.lr = 0x828C508C;
	sub_82227880(ctx, base);
	// 828C508C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C5090: 3D40825F  lis r10, -0x7da1
	ctx.r[10].s64 = -2107703296;
	// 828C5094: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C5098: 388A8BA8  addi r4, r10, -0x7458
	ctx.r[4].s64 = ctx.r[10].s64 + -29784;
	// 828C509C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C50A0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C50A4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C50A8: 4B8D59D9  bl 0x8219aa80
	ctx.lr = 0x828C50AC;
	sub_8219AA80(ctx, base);
	// 828C50AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C50B0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C50B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C50B8: 4BB09369  bl 0x823ce420
	ctx.lr = 0x828C50BC;
	sub_823CE420(ctx, base);
	// 828C50BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C50C0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C50C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C50C8: 4815F601  bl 0x82a246c8
	ctx.lr = 0x828C50CC;
	sub_82A246C8(ctx, base);
	// 828C50CC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C50D0: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C50D4: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828C50D8; continue 'dispatch;
            }
            0x828C50D8 => {
    //   block [0x828C50D8..0x828C50E8)
	// 828C50D8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C50DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C50E0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C50E4: 419A0020  beq cr6, 0x828c5104
	if ctx.cr[6].eq {
	pc = 0x828C5104; continue 'dispatch;
	}
	pc = 0x828C50E8; continue 'dispatch;
            }
            0x828C50E8 => {
    //   block [0x828C50E8..0x828C5104)
	// 828C50E8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C50EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C50F0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C50F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C50F8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C50FC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C5100: 4082FFE8  bne 0x828c50e8
	if !ctx.cr[0].eq {
	pc = 0x828C50E8; continue 'dispatch;
	}
	pc = 0x828C5104; continue 'dispatch;
            }
            0x828C5104 => {
    //   block [0x828C5104..0x828C5124)
	// 828C5104: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5108: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C510C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C5110: 4BA30839  bl 0x822f5948
	ctx.lr = 0x828C5114;
	sub_822F5948(ctx, base);
	// 828C5114: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5118: 4B8F2A01  bl 0x821b7b18
	ctx.lr = 0x828C511C;
	sub_821B7B18(ctx, base);
	// 828C511C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C5120: 419A0040  beq cr6, 0x828c5160
	if ctx.cr[6].eq {
	pc = 0x828C5160; continue 'dispatch;
	}
	pc = 0x828C5124; continue 'dispatch;
            }
            0x828C5124 => {
    //   block [0x828C5124..0x828C5160)
	// 828C5124: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C5128: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C512C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C5130: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C5134: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C5138: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C513C: 4082FFE8  bne 0x828c5124
	if !ctx.cr[0].eq {
	pc = 0x828C5124; continue 'dispatch;
	}
	// 828C5140: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C5144: 409A001C  bne cr6, 0x828c5160
	if !ctx.cr[6].eq {
	pc = 0x828C5160; continue 'dispatch;
	}
	// 828C5148: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C514C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5150: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C5154: 4E800421  bctrl
	ctx.lr = 0x828C5158;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C5158: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C515C: 4B956BDD  bl 0x8221bd38
	ctx.lr = 0x828C5160;
	sub_8221BD38(ctx, base);
            }
            0x828C5160 => {
    //   block [0x828C5160..0x828C5170)
	// 828C5160: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C5164: 4B8F29B5  bl 0x821b7b18
	ctx.lr = 0x828C5168;
	sub_821B7B18(ctx, base);
	// 828C5168: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C516C: 483E42E0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5170 size=56
    let mut pc: u32 = 0x828C5170;
    'dispatch: loop {
        match pc {
            0x828C5170 => {
    //   block [0x828C5170..0x828C518C)
	// 828C5170: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C5174: 419A0018  beq cr6, 0x828c518c
	if ctx.cr[6].eq {
	pc = 0x828C518C; continue 'dispatch;
	}
	// 828C5178: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C517C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C5180: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C5184: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C5188: 409A0008  bne cr6, 0x828c5190
	if !ctx.cr[6].eq {
	pc = 0x828C5190; continue 'dispatch;
	}
	pc = 0x828C518C; continue 'dispatch;
            }
            0x828C518C => {
    //   block [0x828C518C..0x828C5190)
	// 828C518C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C5190; continue 'dispatch;
            }
            0x828C5190 => {
    //   block [0x828C5190..0x828C51A8)
	// 828C5190: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C5194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5198: 419A0010  beq cr6, 0x828c51a8
	if ctx.cr[6].eq {
		sub_828C51A8(ctx, base);
		return;
	}
	// 828C519C: 81640030  lwz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 828C51A0: 5563EFFE  rlwinm r3, r11, 0x1d, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828C51A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C51A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C51A8 size=8
    let mut pc: u32 = 0x828C51A8;
    'dispatch: loop {
        match pc {
            0x828C51A8 => {
    //   block [0x828C51A8..0x828C51B0)
	// 828C51A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C51AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C51B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C51B0 size=376
    let mut pc: u32 = 0x828C51B0;
    'dispatch: loop {
        match pc {
            0x828C51B0 => {
    //   block [0x828C51B0..0x828C51D8)
	// 828C51B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C51B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C51B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C51BC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C51C0: 419A0018  beq cr6, 0x828c51d8
	if ctx.cr[6].eq {
	pc = 0x828C51D8; continue 'dispatch;
	}
	// 828C51C4: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C51C8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C51CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C51D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C51D4: 409A0008  bne cr6, 0x828c51dc
	if !ctx.cr[6].eq {
	pc = 0x828C51DC; continue 'dispatch;
	}
	pc = 0x828C51D8; continue 'dispatch;
            }
            0x828C51D8 => {
    //   block [0x828C51D8..0x828C51DC)
	// 828C51D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C51DC; continue 'dispatch;
            }
            0x828C51DC => {
    //   block [0x828C51DC..0x828C5224)
	// 828C51DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C51E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C51E4: 419A0130  beq cr6, 0x828c5314
	if ctx.cr[6].eq {
	pc = 0x828C5314; continue 'dispatch;
	}
	// 828C51E8: 81440030  lwz r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 828C51EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C51F0: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828C51F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C51F8: 419A00E8  beq cr6, 0x828c52e0
	if ctx.cr[6].eq {
	pc = 0x828C52E0; continue 'dispatch;
	}
	// 828C51FC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C5200: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C5204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5208: 419A001C  beq cr6, 0x828c5224
	if ctx.cr[6].eq {
	pc = 0x828C5224; continue 'dispatch;
	}
	// 828C520C: 896B0063  lbz r11, 0x63(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(99 as u32) ) } as u64;
	// 828C5210: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828C5214: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C5218: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C521C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C5220: 480000C4  b 0x828c52e4
	pc = 0x828C52E4; continue 'dispatch;
            }
            0x828C5224 => {
    //   block [0x828C5224..0x828C5240)
	// 828C5224: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C5228: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C522C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C5230: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C5234: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C5238: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C523C: 40810054  ble 0x828c5290
	if !ctx.cr[0].gt {
	pc = 0x828C5290; continue 'dispatch;
	}
	pc = 0x828C5240; continue 'dispatch;
            }
            0x828C5240 => {
    //   block [0x828C5240..0x828C5260)
	// 828C5240: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C5244: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C5248: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C524C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5250: 2F070063  cmpwi cr6, r7, 0x63
	ctx.cr[6].compare_i32(ctx.r[7].s32, 99, &mut ctx.xer);
	// 828C5254: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C5258: 41980008  blt cr6, 0x828c5260
	if ctx.cr[6].lt {
	pc = 0x828C5260; continue 'dispatch;
	}
	// 828C525C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828C5260; continue 'dispatch;
            }
            0x828C5260 => {
    //   block [0x828C5260..0x828C527C)
	// 828C5260: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C5264: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C5268: 419A0014  beq cr6, 0x828c527c
	if ctx.cr[6].eq {
	pc = 0x828C527C; continue 'dispatch;
	}
	// 828C526C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C5270: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C5274: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C5278: 4800000C  b 0x828c5284
	pc = 0x828C5284; continue 'dispatch;
            }
            0x828C527C => {
    //   block [0x828C527C..0x828C5284)
	// 828C527C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C5280: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C5284; continue 'dispatch;
            }
            0x828C5284 => {
    //   block [0x828C5284..0x828C5290)
	// 828C5284: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C5288: 4199FFB8  bgt cr6, 0x828c5240
	if ctx.cr[6].gt {
	pc = 0x828C5240; continue 'dispatch;
	}
	// 828C528C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C5290; continue 'dispatch;
            }
            0x828C5290 => {
    //   block [0x828C5290..0x828C52AC)
	// 828C5290: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C5294: 419A003C  beq cr6, 0x828c52d0
	if ctx.cr[6].eq {
	pc = 0x828C52D0; continue 'dispatch;
	}
	// 828C5298: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C529C: 2F0B0063  cmpwi cr6, r11, 0x63
	ctx.cr[6].compare_i32(ctx.r[11].s32, 99, &mut ctx.xer);
	// 828C52A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C52A4: 41990008  bgt cr6, 0x828c52ac
	if ctx.cr[6].gt {
	pc = 0x828C52AC; continue 'dispatch;
	}
	// 828C52A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C52AC; continue 'dispatch;
            }
            0x828C52AC => {
    //   block [0x828C52AC..0x828C52D0)
	// 828C52AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C52B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C52B4: 409A001C  bne cr6, 0x828c52d0
	if !ctx.cr[6].eq {
	pc = 0x828C52D0; continue 'dispatch;
	}
	// 828C52B8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C52BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C52C0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C52C4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C52C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C52CC: 48000018  b 0x828c52e4
	pc = 0x828C52E4; continue 'dispatch;
            }
            0x828C52D0 => {
    //   block [0x828C52D0..0x828C52E0)
	// 828C52D0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C52D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C52D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C52DC: 48000008  b 0x828c52e4
	pc = 0x828C52E4; continue 'dispatch;
            }
            0x828C52E0 => {
    //   block [0x828C52E0..0x828C52E4)
	// 828C52E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828C52E4; continue 'dispatch;
            }
            0x828C52E4 => {
    //   block [0x828C52E4..0x828C5314)
	// 828C52E4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C52E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C52EC: 419A0028  beq cr6, 0x828c5314
	if ctx.cr[6].eq {
	pc = 0x828C5314; continue 'dispatch;
	}
	// 828C52F0: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C52F4: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C52F8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C52FC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828C5300: 4E800421  bctrl
	ctx.lr = 0x828C5304;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C5304: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C5308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C530C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C5310: 4E800020  blr
	return;
            }
            0x828C5314 => {
    //   block [0x828C5314..0x828C5328)
	// 828C5314: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C5318: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C531C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C5320: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C5324: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C5328 size=380
    let mut pc: u32 = 0x828C5328;
    'dispatch: loop {
        match pc {
            0x828C5328 => {
    //   block [0x828C5328..0x828C5354)
	// 828C5328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C532C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5330: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5334: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C5338: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C533C: 419A0018  beq cr6, 0x828c5354
	if ctx.cr[6].eq {
	pc = 0x828C5354; continue 'dispatch;
	}
	// 828C5340: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C5344: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C5348: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C534C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C5350: 409A0008  bne cr6, 0x828c5358
	if !ctx.cr[6].eq {
	pc = 0x828C5358; continue 'dispatch;
	}
	pc = 0x828C5354; continue 'dispatch;
            }
            0x828C5354 => {
    //   block [0x828C5354..0x828C5358)
	// 828C5354: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828C5358; continue 'dispatch;
            }
            0x828C5358 => {
    //   block [0x828C5358..0x828C53A4)
	// 828C5358: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C535C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C5360: 419A0134  beq cr6, 0x828c5494
	if ctx.cr[6].eq {
	pc = 0x828C5494; continue 'dispatch;
	}
	// 828C5364: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828C5368: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C536C: 5528EFFE  rlwinm r8, r9, 0x1d, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 828C5370: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C5374: 419A00F8  beq cr6, 0x828c546c
	if ctx.cr[6].eq {
	pc = 0x828C546C; continue 'dispatch;
	}
	// 828C5378: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C537C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C5380: 419A0024  beq cr6, 0x828c53a4
	if ctx.cr[6].eq {
	pc = 0x828C53A4; continue 'dispatch;
	}
	// 828C5384: 892A0063  lbz r9, 0x63(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(99 as u32) ) } as u64;
	// 828C5388: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C538C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828C5390: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C5394: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5398: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C539C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C53A0: 480000D0  b 0x828c5470
	pc = 0x828C5470; continue 'dispatch;
            }
            0x828C53A4 => {
    //   block [0x828C53A4..0x828C53C4)
	// 828C53A4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C53A8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C53AC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C53B0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C53B4: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C53B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C53BC: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C53C0: 40810054  ble 0x828c5414
	if !ctx.cr[0].gt {
	pc = 0x828C5414; continue 'dispatch;
	}
	pc = 0x828C53C4; continue 'dispatch;
            }
            0x828C53C4 => {
    //   block [0x828C53C4..0x828C53E4)
	// 828C53C4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C53C8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C53CC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C53D0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C53D4: 2F070063  cmpwi cr6, r7, 0x63
	ctx.cr[6].compare_i32(ctx.r[7].s32, 99, &mut ctx.xer);
	// 828C53D8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C53DC: 41980008  blt cr6, 0x828c53e4
	if ctx.cr[6].lt {
	pc = 0x828C53E4; continue 'dispatch;
	}
	// 828C53E0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828C53E4; continue 'dispatch;
            }
            0x828C53E4 => {
    //   block [0x828C53E4..0x828C5400)
	// 828C53E4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C53E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C53EC: 419A0014  beq cr6, 0x828c5400
	if ctx.cr[6].eq {
	pc = 0x828C5400; continue 'dispatch;
	}
	// 828C53F0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C53F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C53F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C53FC: 4800000C  b 0x828c5408
	pc = 0x828C5408; continue 'dispatch;
            }
            0x828C5400 => {
    //   block [0x828C5400..0x828C5408)
	// 828C5400: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C5404: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C5408; continue 'dispatch;
            }
            0x828C5408 => {
    //   block [0x828C5408..0x828C5414)
	// 828C5408: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C540C: 4199FFB8  bgt cr6, 0x828c53c4
	if ctx.cr[6].gt {
	pc = 0x828C53C4; continue 'dispatch;
	}
	// 828C5410: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C5414; continue 'dispatch;
            }
            0x828C5414 => {
    //   block [0x828C5414..0x828C5430)
	// 828C5414: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C5418: 419A0040  beq cr6, 0x828c5458
	if ctx.cr[6].eq {
	pc = 0x828C5458; continue 'dispatch;
	}
	// 828C541C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5420: 2F0B0063  cmpwi cr6, r11, 0x63
	ctx.cr[6].compare_i32(ctx.r[11].s32, 99, &mut ctx.xer);
	// 828C5424: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C5428: 41990008  bgt cr6, 0x828c5430
	if ctx.cr[6].gt {
	pc = 0x828C5430; continue 'dispatch;
	}
	// 828C542C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C5430; continue 'dispatch;
            }
            0x828C5430 => {
    //   block [0x828C5430..0x828C5458)
	// 828C5430: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C5434: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5438: 409A0020  bne cr6, 0x828c5458
	if !ctx.cr[6].eq {
	pc = 0x828C5458; continue 'dispatch;
	}
	// 828C543C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C5440: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C5444: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C5448: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C544C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C5450: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C5454: 4800001C  b 0x828c5470
	pc = 0x828C5470; continue 'dispatch;
            }
            0x828C5458 => {
    //   block [0x828C5458..0x828C546C)
	// 828C5458: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C545C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5460: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C5464: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C5468: 48000008  b 0x828c5470
	pc = 0x828C5470; continue 'dispatch;
            }
            0x828C546C => {
    //   block [0x828C546C..0x828C5470)
	// 828C546C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C5470; continue 'dispatch;
            }
            0x828C5470 => {
    //   block [0x828C5470..0x828C5494)
	// 828C5470: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C5474: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5478: 419A001C  beq cr6, 0x828c5494
	if ctx.cr[6].eq {
	pc = 0x828C5494; continue 'dispatch;
	}
	// 828C547C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C5480: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828C5484: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C5488: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C548C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828C5490: 4E800421  bctrl
	ctx.lr = 0x828C5494;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C5494 => {
    //   block [0x828C5494..0x828C54A4)
	// 828C5494: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C5498: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C549C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C54A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C54A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C54A8 size=384
    let mut pc: u32 = 0x828C54A8;
    'dispatch: loop {
        match pc {
            0x828C54A8 => {
    //   block [0x828C54A8..0x828C5628)
	// 828C54A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C54AC: 483E3F61  bl 0x82ca940c
	ctx.lr = 0x828C54B0;
	sub_82CA93D0(ctx, base);
	// 828C54B0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828C54B4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828C54B8: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C5628 size=296
    let mut pc: u32 = 0x828C5628;
    'dispatch: loop {
        match pc {
            0x828C5628 => {
    //   block [0x828C5628..0x828C5750)
	// 828C5628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C562C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5630: DBC1FFE8  stfd f30, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 828C5634: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 828C5638: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C563C: 8083007C  lwz r4, 0x7c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 828C5640: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828C5644: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 828C5648: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C564C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5650: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C5654: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C5658: 4E800421  bctrl
	ctx.lr = 0x828C565C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C565C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828C5660: E8690000  ld r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 828C5664: E8890008  ld r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 828C5668: 4B9304F1  bl 0x821f5b58
	ctx.lr = 0x828C566C;
	sub_821F5B58(ctx, base);
	// 828C566C: FDA0F050  fneg f13, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 828C5670: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C5674: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 828C5678: 394B9490  addi r10, r11, -0x6b70
	ctx.r[10].s64 = ctx.r[11].s64 + -27504;
	// 828C567C: 38E80E68  addi r7, r8, 0xe68
	ctx.r[7].s64 = ctx.r[8].s64 + 3688;
	// 828C5680: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828C5684: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 828C5688: C00AFFF4  lfs f0, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5750 size=336
    let mut pc: u32 = 0x828C5750;
    'dispatch: loop {
        match pc {
            0x828C5750 => {
    //   block [0x828C5750..0x828C58A0)
	// 828C5750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5758: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C575C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C5760: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828C5764: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C58A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C58A0 size=376
    let mut pc: u32 = 0x828C58A0;
    'dispatch: loop {
        match pc {
            0x828C58A0 => {
    //   block [0x828C58A0..0x828C5918)
	// 828C58A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C58A4: 483E3B65  bl 0x82ca9408
	ctx.lr = 0x828C58A8;
	sub_82CA93D0(ctx, base);
	// 828C58A8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828C58AC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C58B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C58B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C58B8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C58BC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C58C0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C58C4: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C58C8: 388A3194  addi r4, r10, 0x3194
	ctx.r[4].s64 = ctx.r[10].s64 + 12692;
	// 828C58CC: D3FF0184  stfs f31, 0x184(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 828C58D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C58D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C58D8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C58DC: 4BBEA6C5  bl 0x824affa0
	ctx.lr = 0x828C58E0;
	sub_824AFFA0(ctx, base);
	// 828C58E0: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C58E4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C58E8: 419A0048  beq cr6, 0x828c5930
	if ctx.cr[6].eq {
	pc = 0x828C5930; continue 'dispatch;
	}
	// 828C58EC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C58F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C58F4: 419A003C  beq cr6, 0x828c5930
	if ctx.cr[6].eq {
	pc = 0x828C5930; continue 'dispatch;
	}
	// 828C58F8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828C58FC: 419A002C  beq cr6, 0x828c5928
	if ctx.cr[6].eq {
	pc = 0x828C5928; continue 'dispatch;
	}
	// 828C5900: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 828C5904: 419A001C  beq cr6, 0x828c5920
	if ctx.cr[6].eq {
	pc = 0x828C5920; continue 'dispatch;
	}
	// 828C5908: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828C590C: 419A000C  beq cr6, 0x828c5918
	if ctx.cr[6].eq {
	pc = 0x828C5918; continue 'dispatch;
	}
	// 828C5910: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C5914: 48000018  b 0x828c592c
	pc = 0x828C592C; continue 'dispatch;
            }
            0x828C5918 => {
    //   block [0x828C5918..0x828C5920)
	// 828C5918: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 828C591C: 48000010  b 0x828c592c
	pc = 0x828C592C; continue 'dispatch;
            }
            0x828C5920 => {
    //   block [0x828C5920..0x828C5928)
	// 828C5920: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 828C5924: 48000008  b 0x828c592c
	pc = 0x828C592C; continue 'dispatch;
            }
            0x828C5928 => {
    //   block [0x828C5928..0x828C592C)
	// 828C5928: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	pc = 0x828C592C; continue 'dispatch;
            }
            0x828C592C => {
    //   block [0x828C592C..0x828C5930)
	// 828C592C: B17F002A  sth r11, 0x2a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(42 as u32), ctx.r[11].u16 ) };
	pc = 0x828C5930; continue 'dispatch;
            }
            0x828C5930 => {
    //   block [0x828C5930..0x828C59B8)
	// 828C5930: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828C5934: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828C5938: 3BDF018C  addi r30, r31, 0x18c
	ctx.r[30].s64 = ctx.r[31].s64 + 396;
	// 828C593C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C5940: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5944: C00B94D4  lfs f0, -0x6b2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27436 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C5948: C1AA94D8  lfs f13, -0x6b28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27432 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C594C: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 828C5950: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C5954: 4BC9A9BD  bl 0x82560310
	ctx.lr = 0x828C5958;
	sub_82560310(ctx, base);
	// 828C5958: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 828C595C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C5960: 387F018D  addi r3, r31, 0x18d
	ctx.r[3].s64 = ctx.r[31].s64 + 397;
	// 828C5964: C00994DC  lfs f0, -0x6b24(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C5968: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C596C: 4BC9A9A5  bl 0x82560310
	ctx.lr = 0x828C5970;
	sub_82560310(ctx, base);
	// 828C5970: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 828C5974: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C5978: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C597C: 388847E0  addi r4, r8, 0x47e0
	ctx.r[4].s64 = ctx.r[8].s64 + 18400;
	// 828C5980: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C5984: 4BAE7A6D  bl 0x823ad3f0
	ctx.lr = 0x828C5988;
	sub_823AD3F0(ctx, base);
	// 828C5988: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C598C: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 828C5990: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C5994: 419A0024  beq cr6, 0x828c59b8
	if ctx.cr[6].eq {
	pc = 0x828C59B8; continue 'dispatch;
	}
	// 828C5998: C01D9A80  lfs f0, -0x6580(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C599C: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C59A0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828C59A4: 40990014  ble cr6, 0x828c59b8
	if !ctx.cr[6].gt {
	pc = 0x828C59B8; continue 'dispatch;
	}
	// 828C59A8: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C59AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C59B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C59B4: 4BC9A95D  bl 0x82560310
	ctx.lr = 0x828C59B8;
	sub_82560310(ctx, base);
	pc = 0x828C59B8; continue 'dispatch;
            }
            0x828C59B8 => {
    //   block [0x828C59B8..0x828C5A0C)
	// 828C59B8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C59BC: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C59C0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828C59C4: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828C59C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C59CC: 388931A8  addi r4, r9, 0x31a8
	ctx.r[4].s64 = ctx.r[9].s64 + 12712;
	// 828C59D0: C00B6B7C  lfs f0, 0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C59D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C59D8: C1AA94D0  lfs f13, -0x6b30(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27440 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C59DC: 3BDF0080  addi r30, r31, 0x80
	ctx.r[30].s64 = ctx.r[31].s64 + 128;
	// 828C59E0: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828C59E4: D1BF0084  stfs f13, 0x84(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828C59E8: 4BAE7A09  bl 0x823ad3f0
	ctx.lr = 0x828C59EC;
	sub_823AD3F0(ctx, base);
	// 828C59EC: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C59F0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C59F4: 419A0018  beq cr6, 0x828c5a0c
	if ctx.cr[6].eq {
	pc = 0x828C5A0C; continue 'dispatch;
	}
	// 828C59F8: C01D9A80  lfs f0, -0x6580(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C59FC: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C5A00: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828C5A04: 40990008  ble cr6, 0x828c5a0c
	if !ctx.cr[6].gt {
	pc = 0x828C5A0C; continue 'dispatch;
	}
	// 828C5A08: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x828C5A0C; continue 'dispatch;
            }
            0x828C5A0C => {
    //   block [0x828C5A0C..0x828C5A18)
	// 828C5A0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C5A10: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828C5A14: 483E3A44  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5A18 size=1168
    let mut pc: u32 = 0x828C5A18;
    'dispatch: loop {
        match pc {
            0x828C5A18 => {
    //   block [0x828C5A18..0x828C5EA8)
	// 828C5A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5A1C: 483E39C1  bl 0x82ca93dc
	ctx.lr = 0x828C5A20;
	sub_82CA93D0(ctx, base);
	// 828C5A20: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C5EA8 size=164
    let mut pc: u32 = 0x828C5EA8;
    'dispatch: loop {
        match pc {
            0x828C5EA8 => {
    //   block [0x828C5EA8..0x828C5EF0)
	// 828C5EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5EAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5EB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C5EB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5EB8: 80840038  lwz r4, 0x38(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C5EBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C5EC0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C5EC4: 419A002C  beq cr6, 0x828c5ef0
	if ctx.cr[6].eq {
	pc = 0x828C5EF0; continue 'dispatch;
	}
	// 828C5EC8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5ECC: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828C5ED0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C5ED4: 4E800421  bctrl
	ctx.lr = 0x828C5ED8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C5ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5EDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C5EE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C5EE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C5EE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C5EEC: 4E800020  blr
	return;
            }
            0x828C5EF0 => {
    //   block [0x828C5EF0..0x828C5F4C)
	// 828C5EF0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C5EF4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828C5EF8: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 828C5EFC: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 828C5F00: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828C5F04: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C5F08: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5F50 size=28
    let mut pc: u32 = 0x828C5F50;
    'dispatch: loop {
        match pc {
            0x828C5F50 => {
    //   block [0x828C5F50..0x828C5F6C)
	// 828C5F50: 80630038  lwz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C5F54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C5F58: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 828C5F5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5F60: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C5F64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C5F68: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5F6C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5F6C size=4
    let mut pc: u32 = 0x828C5F6C;
    'dispatch: loop {
        match pc {
            0x828C5F6C => {
    //   block [0x828C5F6C..0x828C5F70)
	// 828C5F6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5F70 size=28
    let mut pc: u32 = 0x828C5F70;
    'dispatch: loop {
        match pc {
            0x828C5F70 => {
    //   block [0x828C5F70..0x828C5F8C)
	// 828C5F70: 80630038  lwz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C5F74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C5F78: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 828C5F7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5F80: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C5F84: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C5F88: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5F8C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5F8C size=4
    let mut pc: u32 = 0x828C5F8C;
    'dispatch: loop {
        match pc {
            0x828C5F8C => {
    //   block [0x828C5F8C..0x828C5F90)
	// 828C5F8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C5F90 size=228
    let mut pc: u32 = 0x828C5F90;
    'dispatch: loop {
        match pc {
            0x828C5F90 => {
    //   block [0x828C5F90..0x828C5FC8)
	// 828C5F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5F94: 483E3475  bl 0x82ca9408
	ctx.lr = 0x828C5F98;
	sub_82CA93D0(ctx, base);
	// 828C5F98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5F9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C5FA0: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C5FA4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 828C5FA8: 419A00BC  beq cr6, 0x828c6064
	if ctx.cr[6].eq {
	pc = 0x828C6064; continue 'dispatch;
	}
	// 828C5FAC: 809E0038  lwz r4, 0x38(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C5FB0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C5FB4: 419A0014  beq cr6, 0x828c5fc8
	if ctx.cr[6].eq {
	pc = 0x828C5FC8; continue 'dispatch;
	}
	// 828C5FB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5FBC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C5FC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C5FC4: 4E800421  bctrl
	ctx.lr = 0x828C5FC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C5FC8 => {
    //   block [0x828C5FC8..0x828C5FEC)
	// 828C5FC8: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C5FCC: 3BBE0040  addi r29, r30, 0x40
	ctx.r[29].s64 = ctx.r[30].s64 + 64;
	// 828C5FD0: 815E0044  lwz r10, 0x44(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C5FD4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C5FD8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828C5FDC: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828C5FE0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828C5FE4: 419A0080  beq cr6, 0x828c6064
	if ctx.cr[6].eq {
	pc = 0x828C6064; continue 'dispatch;
	}
	// 828C5FE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x828C5FEC; continue 'dispatch;
            }
            0x828C5FEC => {
    //   block [0x828C5FEC..0x828C600C)
	// 828C5FEC: 817E0044  lwz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C5FF0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828C5FF4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5FF8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5FFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C6000: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C6004: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828C6008: 419A0020  beq cr6, 0x828c6028
	if ctx.cr[6].eq {
	pc = 0x828C6028; continue 'dispatch;
	}
	pc = 0x828C600C; continue 'dispatch;
            }
            0x828C600C => {
    //   block [0x828C600C..0x828C6028)
	// 828C600C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C6010: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C6014: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C6018: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C601C: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C6020: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C6024: 4082FFE8  bne 0x828c600c
	if !ctx.cr[0].eq {
	pc = 0x828C600C; continue 'dispatch;
	}
	pc = 0x828C6028; continue 'dispatch;
            }
            0x828C6028 => {
    //   block [0x828C6028..0x828C6064)
	// 828C6028: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C602C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6030: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C6034: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6038: 4E800421  bctrl
	ctx.lr = 0x828C603C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C603C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6040: 4B8F1AD9  bl 0x821b7b18
	ctx.lr = 0x828C6044;
	sub_821B7B18(ctx, base);
	// 828C6044: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C6048: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C604C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 828C6050: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828C6054: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C6058: 7CE61E70  srawi r6, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 828C605C: 7F1C3040  cmplw cr6, r28, r6
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C6060: 409AFF8C  bne cr6, 0x828c5fec
	if !ctx.cr[6].eq {
	pc = 0x828C5FEC; continue 'dispatch;
	}
            }
            0x828C6064 => {
    //   block [0x828C6064..0x828C6074)
	// 828C6064: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6068: 4BD96321  bl 0x8265c388
	ctx.lr = 0x828C606C;
	sub_8265C388(ctx, base);
	// 828C606C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C6070: 483E33E8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6078 size=240
    let mut pc: u32 = 0x828C6078;
    'dispatch: loop {
        match pc {
            0x828C6078 => {
    //   block [0x828C6078..0x828C60DC)
	// 828C6078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C607C: 483E3389  bl 0x82ca9404
	ctx.lr = 0x828C6080;
	sub_82CA93D0(ctx, base);
	// 828C6080: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6084: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C6088: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C608C: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C6090: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C6094: 409A00C0  bne cr6, 0x828c6154
	if !ctx.cr[6].eq {
	pc = 0x828C6154; continue 'dispatch;
	}
	// 828C6098: 809B0038  lwz r4, 0x38(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C609C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C60A0: 419A00B4  beq cr6, 0x828c6154
	if ctx.cr[6].eq {
	pc = 0x828C6154; continue 'dispatch;
	}
	// 828C60A4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C60A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C60AC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C60B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C60B4: 4E800421  bctrl
	ctx.lr = 0x828C60B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C60B8: 813B0048  lwz r9, 0x48(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C60BC: 811B0044  lwz r8, 0x44(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C60C0: 3BDB0040  addi r30, r27, 0x40
	ctx.r[30].s64 = ctx.r[27].s64 + 64;
	// 828C60C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C60C8: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C60CC: 54E60038  rlwinm r6, r7, 0, 0, 0x1c
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 828C60D0: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 828C60D4: 419A0080  beq cr6, 0x828c6154
	if ctx.cr[6].eq {
	pc = 0x828C6154; continue 'dispatch;
	}
	// 828C60D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
            }
            0x828C60DC => {
    //   block [0x828C60DC..0x828C60FC)
	// 828C60DC: 817B0044  lwz r11, 0x44(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C60E0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 828C60E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C60E8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C60EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C60F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C60F4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828C60F8: 419A0020  beq cr6, 0x828c6118
	if ctx.cr[6].eq {
	pc = 0x828C6118; continue 'dispatch;
	}
	pc = 0x828C60FC; continue 'dispatch;
            }
            0x828C60FC => {
    //   block [0x828C60FC..0x828C6118)
	// 828C60FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C6100: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C6104: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C6108: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C610C: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C6110: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C6114: 4082FFE8  bne 0x828c60fc
	if !ctx.cr[0].eq {
	pc = 0x828C60FC; continue 'dispatch;
	}
	pc = 0x828C6118; continue 'dispatch;
            }
            0x828C6118 => {
    //   block [0x828C6118..0x828C6154)
	// 828C6118: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C611C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C6120: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C6124: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6128: 4E800421  bctrl
	ctx.lr = 0x828C612C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C612C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6130: 4B8F19E9  bl 0x821b7b18
	ctx.lr = 0x828C6134;
	sub_821B7B18(ctx, base);
	// 828C6134: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C6138: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C613C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828C6140: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 828C6144: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C6148: 7CE61E70  srawi r6, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 828C614C: 7F1D3040  cmplw cr6, r29, r6
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C6150: 409AFF8C  bne cr6, 0x828c60dc
	if !ctx.cr[6].eq {
	pc = 0x828C60DC; continue 'dispatch;
	}
            }
            0x828C6154 => {
    //   block [0x828C6154..0x828C6168)
	// 828C6154: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C6158: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C615C: 4BD96125  bl 0x8265c280
	ctx.lr = 0x828C6160;
	sub_8265C280(ctx, base);
	// 828C6160: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C6164: 483E32F0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6168 size=164
    let mut pc: u32 = 0x828C6168;
    'dispatch: loop {
        match pc {
            0x828C6168 => {
    //   block [0x828C6168..0x828C6198)
	// 828C6168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C616C: 483E3299  bl 0x82ca9404
	ctx.lr = 0x828C6170;
	sub_82CA93D0(ctx, base);
	// 828C6170: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6174: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C6178: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828C617C: 807C0038  lwz r3, 0x38(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C6180: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C6184: 419A0014  beq cr6, 0x828c6198
	if ctx.cr[6].eq {
	pc = 0x828C6198; continue 'dispatch;
	}
	// 828C6188: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C618C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C6190: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6194: 4E800421  bctrl
	ctx.lr = 0x828C6198;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C6198 => {
    //   block [0x828C6198..0x828C61BC)
	// 828C6198: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C619C: 3BFC0040  addi r31, r28, 0x40
	ctx.r[31].s64 = ctx.r[28].s64 + 64;
	// 828C61A0: 815C0044  lwz r10, 0x44(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C61A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C61A8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828C61AC: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828C61B0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828C61B4: 419A0044  beq cr6, 0x828c61f8
	if ctx.cr[6].eq {
	pc = 0x828C61F8; continue 'dispatch;
	}
	// 828C61B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x828C61BC; continue 'dispatch;
            }
            0x828C61BC => {
    //   block [0x828C61BC..0x828C61F8)
	// 828C61BC: 817C0044  lwz r11, 0x44(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C61C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C61C4: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828C61C8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C61CC: 812A0028  lwz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C61D0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828C61D4: 4E800421  bctrl
	ctx.lr = 0x828C61D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C61D8: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C61DC: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C61E0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828C61E4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828C61E8: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 828C61EC: 7CC51E70  srawi r5, r6, 3
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 3) as i64;
	// 828C61F0: 7F1D2840  cmplw cr6, r29, r5
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828C61F4: 409AFFC8  bne cr6, 0x828c61bc
	if !ctx.cr[6].eq {
	pc = 0x828C61BC; continue 'dispatch;
	}
            }
            0x828C61F8 => {
    //   block [0x828C61F8..0x828C620C)
	// 828C61F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C61FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C6200: 4BD95CA1  bl 0x8265bea0
	ctx.lr = 0x828C6204;
	sub_8265BEA0(ctx, base);
	// 828C6204: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C6208: 483E324C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6210 size=152
    let mut pc: u32 = 0x828C6210;
    'dispatch: loop {
        match pc {
            0x828C6210 => {
    //   block [0x828C6210..0x828C623C)
	// 828C6210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6214: 483E31F5  bl 0x82ca9408
	ctx.lr = 0x828C6218;
	sub_82CA93D0(ctx, base);
	// 828C6218: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C621C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C6220: 807C0038  lwz r3, 0x38(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C6224: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C6228: 419A0014  beq cr6, 0x828c623c
	if ctx.cr[6].eq {
	pc = 0x828C623C; continue 'dispatch;
	}
	// 828C622C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6230: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C6234: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6238: 4E800421  bctrl
	ctx.lr = 0x828C623C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C623C => {
    //   block [0x828C623C..0x828C6260)
	// 828C623C: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C6240: 3BFC0040  addi r31, r28, 0x40
	ctx.r[31].s64 = ctx.r[28].s64 + 64;
	// 828C6244: 815C0044  lwz r10, 0x44(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C6248: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C624C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828C6250: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 828C6254: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828C6258: 419A0040  beq cr6, 0x828c6298
	if ctx.cr[6].eq {
	pc = 0x828C6298; continue 'dispatch;
	}
	// 828C625C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x828C6260; continue 'dispatch;
            }
            0x828C6260 => {
    //   block [0x828C6260..0x828C6298)
	// 828C6260: 817C0044  lwz r11, 0x44(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C6264: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828C6268: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C626C: 812A002C  lwz r9, 0x2c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C6270: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828C6274: 4E800421  bctrl
	ctx.lr = 0x828C6278;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C6278: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C627C: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6280: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828C6284: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828C6288: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 828C628C: 7CC51E70  srawi r5, r6, 3
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 3) as i64;
	// 828C6290: 7F1D2840  cmplw cr6, r29, r5
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828C6294: 409AFFCC  bne cr6, 0x828c6260
	if !ctx.cr[6].eq {
	pc = 0x828C6260; continue 'dispatch;
	}
            }
            0x828C6298 => {
    //   block [0x828C6298..0x828C62A8)
	// 828C6298: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C629C: 4BD95CD5  bl 0x8265bf70
	ctx.lr = 0x828C62A0;
	sub_8265BF70(ctx, base);
	// 828C62A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C62A4: 483E31B4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C62A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C62A8 size=120
    let mut pc: u32 = 0x828C62A8;
    'dispatch: loop {
        match pc {
            0x828C62A8 => {
    //   block [0x828C62A8..0x828C6320)
	// 828C62A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C62AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C62B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C62B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C62B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C62BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C62C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C62C4: 4BD95E5D  bl 0x8265c120
	ctx.lr = 0x828C62C8;
	sub_8265C120(ctx, base);
	// 828C62C8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C62CC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828C62D0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C62D4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C62D8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C62DC: 80680018  lwz r3, 0x18(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C62E0: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C62E4: 80C70058  lwz r6, 0x58(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C62E8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 828C62EC: 4E800421  bctrl
	ctx.lr = 0x828C62F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C62F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C62F4: 80BF0038  lwz r5, 0x38(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C62F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C62FC: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828C6300: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6304: 4E800421  bctrl
	ctx.lr = 0x828C6308;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C6308: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C630C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C6310: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6314: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C6318: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C631C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6320 size=844
    let mut pc: u32 = 0x828C6320;
    'dispatch: loop {
        match pc {
            0x828C6320 => {
    //   block [0x828C6320..0x828C635C)
	// 828C6320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6324: 483E30C9  bl 0x82ca93ec
	ctx.lr = 0x828C6328;
	sub_82CA93D0(ctx, base);
	// 828C6328: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C632C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828C6330: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828C6334: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 828C6338: 7F55D378  mr r21, r26
	ctx.r[21].u64 = ctx.r[26].u64;
	// 828C633C: 81780014  lwz r11, 0x14(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C6340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C6344: 419A0018  beq cr6, 0x828c635c
	if ctx.cr[6].eq {
	pc = 0x828C635C; continue 'dispatch;
	}
	// 828C6348: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C634C: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 828C6350: 812A0038  lwz r9, 0x38(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C6354: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828C6358: 4E800421  bctrl
	ctx.lr = 0x828C635C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C635C => {
    //   block [0x828C635C..0x828C63B8)
	// 828C635C: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 828C6360: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 828C6364: B341005C  sth r26, 0x5c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u16 ) };
	// 828C6368: 3B780038  addi r27, r24, 0x38
	ctx.r[27].s64 = ctx.r[24].s64 + 56;
	// 828C636C: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 828C6370: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 828C6374: B3410054  sth r26, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u16 ) };
	// 828C6378: B161005E  sth r11, 0x5e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(94 as u32), ctx.r[11].u16 ) };
	// 828C637C: B1610056  sth r11, 0x56(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[11].u16 ) };
	// 828C6380: 80780038  lwz r3, 0x38(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C6384: 4BF8CECD  bl 0x82853250
	ctx.lr = 0x828C6388;
	sub_82853250(ctx, base);
	// 828C6388: 81580038  lwz r10, 0x38(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C638C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 828C6390: 7F57D378  mr r23, r26
	ctx.r[23].u64 = ctx.r[26].u64;
	// 828C6394: 83EA002C  lwz r31, 0x2c(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C6398: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C639C: 419A0148  beq cr6, 0x828c64e4
	if ctx.cr[6].eq {
	pc = 0x828C64E4; continue 'dispatch;
	}
	// 828C63A0: A17F01F4  lhz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 828C63A4: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 828C63A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C63AC: 419A0068  beq cr6, 0x828c6414
	if ctx.cr[6].eq {
	pc = 0x828C6414; continue 'dispatch;
	}
	// 828C63B0: A161005C  lhz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C63B4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x828C63B8; continue 'dispatch;
            }
            0x828C63B8 => {
    //   block [0x828C63B8..0x828C63E0)
	// 828C63B8: A141005E  lhz r10, 0x5e(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(94 as u32) ) } as u64;
	// 828C63BC: 5569043E  clrlwi r9, r11, 0x10
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 828C63C0: 839F01F0  lwz r28, 0x1f0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(496 as u32) ) } as u64;
	// 828C63C4: 554804BE  clrlwi r8, r10, 0x12
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00003FFFu64;
	// 828C63C8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828C63CC: 409A0014  bne cr6, 0x828c63e0
	if !ctx.cr[6].eq {
	pc = 0x828C63E0; continue 'dispatch;
	}
	// 828C63D0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828C63D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C63D8: 48495041  bl 0x82d5b418
	ctx.lr = 0x828C63DC;
	sub_82D5B418(ctx, base);
	// 828C63DC: A161005C  lhz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x828C63E0; continue 'dispatch;
            }
            0x828C63E0 => {
    //   block [0x828C63E0..0x828C6414)
	// 828C63E0: 7D5EE02E  lwzx r10, r30, r28
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 828C63E4: 556913BA  rlwinm r9, r11, 2, 0xe, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 828C63E8: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C63EC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828C63F0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 828C63F4: 7D49412E  stwx r10, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 828C63F8: A161005C  lhz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C63FC: 38CB0001  addi r6, r11, 1
	ctx.r[6].s64 = ctx.r[11].s64 + 1;
	// 828C6400: 54CB043E  clrlwi r11, r6, 0x10
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 828C6404: B161005C  sth r11, 0x5c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u16 ) };
	// 828C6408: A0BF01F4  lhz r5, 0x1f4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 828C640C: 7F1D2840  cmplw cr6, r29, r5
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828C6410: 409AFFA8  bne cr6, 0x828c63b8
	if !ctx.cr[6].eq {
	pc = 0x828C63B8; continue 'dispatch;
	}
	pc = 0x828C6414; continue 'dispatch;
            }
            0x828C6414 => {
    //   block [0x828C6414..0x828C6430)
	// 828C6414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6418: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 828C641C: 48000295  bl 0x828c66b0
	ctx.lr = 0x828C6420;
	sub_828C66B0(ctx, base);
	// 828C6420: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C6428: 419A0070  beq cr6, 0x828c6498
	if ctx.cr[6].eq {
	pc = 0x828C6498; continue 'dispatch;
	}
	// 828C642C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x828C6430; continue 'dispatch;
            }
            0x828C6430 => {
    //   block [0x828C6430..0x828C645C)
	// 828C6430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6434: 4800027D  bl 0x828c66b0
	ctx.lr = 0x828C6438;
	sub_828C66B0(ctx, base);
	// 828C6438: A1610056  lhz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 828C643C: A1010054  lhz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C6440: 556904BE  clrlwi r9, r11, 0x12
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00003FFFu64;
	// 828C6444: 83830000  lwz r28, 0(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6448: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C644C: 409A0010  bne cr6, 0x828c645c
	if !ctx.cr[6].eq {
	pc = 0x828C645C; continue 'dispatch;
	}
	// 828C6450: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828C6454: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6458: 48494FC1  bl 0x82d5b418
	ctx.lr = 0x828C645C;
	sub_82D5B418(ctx, base);
	pc = 0x828C645C; continue 'dispatch;
            }
            0x828C645C => {
    //   block [0x828C645C..0x828C6498)
	// 828C645C: A1610054  lhz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C6460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6464: 7D5EE02E  lwzx r10, r30, r28
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 828C6468: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 828C646C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C6470: 5568103E  rotlwi r8, r11, 2
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 828C6474: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 828C6478: 7D48492E  stwx r10, r8, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 828C647C: A1610054  lhz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C6480: 38CB0001  addi r6, r11, 1
	ctx.r[6].s64 = ctx.r[11].s64 + 1;
	// 828C6484: B0C10054  sth r6, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u16 ) };
	// 828C6488: 48000229  bl 0x828c66b0
	ctx.lr = 0x828C648C;
	sub_828C66B0(ctx, base);
	// 828C648C: A0830004  lhz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6490: 7F1D2040  cmplw cr6, r29, r4
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828C6494: 409AFF9C  bne cr6, 0x828c6430
	if !ctx.cr[6].eq {
	pc = 0x828C6430; continue 'dispatch;
	}
	pc = 0x828C6498; continue 'dispatch;
            }
            0x828C6498 => {
    //   block [0x828C6498..0x828C64D0)
	// 828C6498: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828C649C: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828C64A0: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 828C64A4: 7D6A5A15  add. r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C64A8: 418201BC  beq 0x828c6664
	if ctx.cr[0].eq {
	pc = 0x828C6664; continue 'dispatch;
	}
	// 828C64AC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C64B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C64B4: 419A01B0  beq cr6, 0x828c6664
	if ctx.cr[6].eq {
	pc = 0x828C6664; continue 'dispatch;
	}
	// 828C64B8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C64BC: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C64C0: 55690672  rlwinm r9, r11, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C64C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C64C8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C64CC: 409A0008  bne cr6, 0x828c64d4
	if !ctx.cr[6].eq {
	pc = 0x828C64D4; continue 'dispatch;
	}
	pc = 0x828C64D0; continue 'dispatch;
            }
            0x828C64D0 => {
    //   block [0x828C64D0..0x828C64D4)
	// 828C64D0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x828C64D4; continue 'dispatch;
            }
            0x828C64D4 => {
    //   block [0x828C64D4..0x828C64E4)
	// 828C64D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C64D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C64DC: 419A0008  beq cr6, 0x828c64e4
	if ctx.cr[6].eq {
	pc = 0x828C64E4; continue 'dispatch;
	}
	// 828C64E0: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	pc = 0x828C64E4; continue 'dispatch;
            }
            0x828C64E4 => {
    //   block [0x828C64E4..0x828C651C)
	// 828C64E4: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C64E8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C64EC: 83D90000  lwz r30, 0(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C64F0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828C64F4: 419A0028  beq cr6, 0x828c651c
	if ctx.cr[6].eq {
	pc = 0x828C651C; continue 'dispatch;
	}
	// 828C64F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C64FC: 4B8F161D  bl 0x821b7b18
	ctx.lr = 0x828C6500;
	sub_821B7B18(ctx, base);
	// 828C6500: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C6504: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C6508: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C650C: 419A0010  beq cr6, 0x828c651c
	if ctx.cr[6].eq {
	pc = 0x828C651C; continue 'dispatch;
	}
	// 828C6510: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6514: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C6518: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x828C651C; continue 'dispatch;
            }
            0x828C651C => {
    //   block [0x828C651C..0x828C6538)
	// 828C651C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6520: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 828C6524: A121005C  lhz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C6528: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C652C: 83AB002C  lwz r29, 0x2c(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C6530: 419A002C  beq cr6, 0x828c655c
	if ctx.cr[6].eq {
	pc = 0x828C655C; continue 'dispatch;
	}
	// 828C6534: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x828C6538; continue 'dispatch;
            }
            0x828C6538 => {
    //   block [0x828C6538..0x828C655C)
	// 828C6538: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C653C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C6540: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C6544: 484BF41D  bl 0x82d85960
	ctx.lr = 0x828C6548;
	sub_82D85960(ctx, base);
	// 828C6548: A121005C  lhz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C654C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828C6550: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 828C6554: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C6558: 409AFFE0  bne cr6, 0x828c6538
	if !ctx.cr[6].eq {
	pc = 0x828C6538; continue 'dispatch;
	}
	pc = 0x828C655C; continue 'dispatch;
            }
            0x828C655C => {
    //   block [0x828C655C..0x828C6570)
	// 828C655C: A1410054  lhz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C6560: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 828C6564: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C6568: 419A002C  beq cr6, 0x828c6594
	if ctx.cr[6].eq {
	pc = 0x828C6594; continue 'dispatch;
	}
	// 828C656C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	pc = 0x828C6570; continue 'dispatch;
            }
            0x828C6570 => {
    //   block [0x828C6570..0x828C6594)
	// 828C6570: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C6574: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C6578: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C657C: 484BF97D  bl 0x82d85ef8
	ctx.lr = 0x828C6580;
	sub_82D85EF8(ctx, base);
	// 828C6580: A1210054  lhz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C6584: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828C6588: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 828C658C: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C6590: 409AFFE0  bne cr6, 0x828c6570
	if !ctx.cr[6].eq {
	pc = 0x828C6570; continue 'dispatch;
	}
	pc = 0x828C6594; continue 'dispatch;
            }
            0x828C6594 => {
    //   block [0x828C6594..0x828C6604)
	// 828C6594: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C6598: 83FB0000  lwz r31, 0(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C659C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828C65A0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C65A4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C65A8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C65AC: 80680018  lwz r3, 0x18(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C65B0: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C65B4: 80C70058  lwz r6, 0x58(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C65B8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 828C65BC: 4E800421  bctrl
	ctx.lr = 0x828C65C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C65C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C65C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C65C8: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828C65CC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C65D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C65D4: 4E800421  bctrl
	ctx.lr = 0x828C65D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C65D8: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C65DC: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 828C65E0: 8109002C  lwz r8, 0x2c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C65E4: 92E8000C  stw r23, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[23].u32 ) };
	// 828C65E8: 419A001C  beq cr6, 0x828c6604
	if ctx.cr[6].eq {
	pc = 0x828C6604; continue 'dispatch;
	}
	// 828C65EC: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C65F0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828C65F4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828C65F8: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828C65FC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6600: 4E800421  bctrl
	ctx.lr = 0x828C6604;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C6604 => {
    //   block [0x828C6604..0x828C6630)
	// 828C6604: A1610056  lhz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 828C6608: 556A0020  rlwinm r10, r11, 0, 0, 0x10
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C660C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C6610: 409A0020  bne cr6, 0x828c6630
	if !ctx.cr[6].eq {
	pc = 0x828C6630; continue 'dispatch;
	}
	// 828C6614: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6618: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 828C661C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 828C6620: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C6624: 5565143A  rlwinm r5, r11, 2, 0x10, 0x1d
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 828C6628: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828C662C: 4848EC9D  bl 0x82d552c8
	ctx.lr = 0x828C6630;
	sub_82D552C8(ctx, base);
	pc = 0x828C6630; continue 'dispatch;
            }
            0x828C6630 => {
    //   block [0x828C6630..0x828C665C)
	// 828C6630: A161005E  lhz r11, 0x5e(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(94 as u32) ) } as u64;
	// 828C6634: 556A0020  rlwinm r10, r11, 0, 0, 0x10
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C6638: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C663C: 409A0020  bne cr6, 0x828c665c
	if !ctx.cr[6].eq {
	pc = 0x828C665C; continue 'dispatch;
	}
	// 828C6640: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6644: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 828C6648: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 828C664C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C6650: 5565143A  rlwinm r5, r11, 2, 0x10, 0x1d
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 828C6654: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828C6658: 4848EC71  bl 0x82d552c8
	ctx.lr = 0x828C665C;
	sub_82D552C8(ctx, base);
	pc = 0x828C665C; continue 'dispatch;
            }
            0x828C665C => {
    //   block [0x828C665C..0x828C6664)
	// 828C665C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828C6660: 483E2DDC  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x828C6664 => {
    //   block [0x828C6664..0x828C666C)
	// 828C6664: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828C6668: 4BFFFE68  b 0x828c64d0
	pc = 0x828C64D0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C6670 size=28
    let mut pc: u32 = 0x828C6670;
    'dispatch: loop {
        match pc {
            0x828C6670 => {
    //   block [0x828C6670..0x828C668C)
	// 828C6670: 80630038  lwz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C6674: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C6678: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 828C667C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6680: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C6684: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6688: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C668C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C668C size=4
    let mut pc: u32 = 0x828C668C;
    'dispatch: loop {
        match pc {
            0x828C668C => {
    //   block [0x828C668C..0x828C6690)
	// 828C668C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C6690 size=28
    let mut pc: u32 = 0x828C6690;
    'dispatch: loop {
        match pc {
            0x828C6690 => {
    //   block [0x828C6690..0x828C66AC)
	// 828C6690: 80630038  lwz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C6694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C6698: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 828C669C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C66A0: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828C66A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C66A8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C66AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C66AC size=4
    let mut pc: u32 = 0x828C66AC;
    'dispatch: loop {
        match pc {
            0x828C66AC => {
    //   block [0x828C66AC..0x828C66B0)
	// 828C66AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C66B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C66B0 size=172
    let mut pc: u32 = 0x828C66B0;
    'dispatch: loop {
        match pc {
            0x828C66B0 => {
    //   block [0x828C66B0..0x828C6700)
	// 828C66B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C66B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C66B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C66BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C66C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C66C4: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 828C66C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C66CC: 409A0078  bne cr6, 0x828c6744
	if !ctx.cr[6].eq {
	pc = 0x828C6744; continue 'dispatch;
	}
	// 828C66D0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C66D4: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 828C66D8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C66DC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C66E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C66E4: 419A001C  beq cr6, 0x828c6700
	if ctx.cr[6].eq {
	pc = 0x828C6700; continue 'dispatch;
	}
	// 828C66E8: 8143004C  lwz r10, 0x4c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C66EC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828C66F0: 9143004C  stw r10, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 828C66F4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C66F8: 91230048  stw r9, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[9].u32 ) };
	// 828C66FC: 48000010  b 0x828c670c
	pc = 0x828C670C; continue 'dispatch;
            }
            0x828C6700 => {
    //   block [0x828C6700..0x828C670C)
	// 828C6700: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828C6704: 4848E94D  bl 0x82d55050
	ctx.lr = 0x828C6708;
	sub_82D55050(ctx, base);
	// 828C6708: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x828C670C; continue 'dispatch;
            }
            0x828C670C => {
    //   block [0x828C670C..0x828C673C)
	// 828C670C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C6710: 419A002C  beq cr6, 0x828c673c
	if ctx.cr[6].eq {
	pc = 0x828C673C; continue 'dispatch;
	}
	// 828C6714: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 828C6718: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C671C: 614A8000  ori r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 32768;
	// 828C6720: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C6724: B12B0004  sth r9, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 828C6728: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 828C672C: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C6730: B12B000C  sth r9, 0xc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u16 ) };
	// 828C6734: B14B000E  sth r10, 0xe(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(14 as u32), ctx.r[10].u16 ) };
	// 828C6738: 48000008  b 0x828c6740
	pc = 0x828C6740; continue 'dispatch;
            }
            0x828C673C => {
    //   block [0x828C673C..0x828C6740)
	// 828C673C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C6740; continue 'dispatch;
            }
            0x828C6740 => {
    //   block [0x828C6740..0x828C6744)
	// 828C6740: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	pc = 0x828C6744; continue 'dispatch;
            }
            0x828C6744 => {
    //   block [0x828C6744..0x828C675C)
	// 828C6744: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 828C6748: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C674C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C6750: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6754: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C6758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828C6760 size=20
    let mut pc: u32 = 0x828C6760;
    'dispatch: loop {
        match pc {
            0x828C6760 => {
    //   block [0x828C6760..0x828C6774)
	// 828C6760: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828C6764: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C6768: D0040014  stfs f0, 0x14(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828C676C: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828C6770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C6778 size=420
    let mut pc: u32 = 0x828C6778;
    'dispatch: loop {
        match pc {
            0x828C6778 => {
    //   block [0x828C6778..0x828C691C)
	// 828C6778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C677C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6780: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C6784: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 828C6788: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828C678C: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C6920 size=356
    let mut pc: u32 = 0x828C6920;
    'dispatch: loop {
        match pc {
            0x828C6920 => {
    //   block [0x828C6920..0x828C6A84)
	// 828C6920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6924: 483E2AE9  bl 0x82ca940c
	ctx.lr = 0x828C6928;
	sub_82CA93D0(ctx, base);
	// 828C6928: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6A88 size=1136
    let mut pc: u32 = 0x828C6A88;
    'dispatch: loop {
        match pc {
            0x828C6A88 => {
    //   block [0x828C6A88..0x828C6AE8)
	// 828C6A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6A8C: 483E2975  bl 0x82ca9400
	ctx.lr = 0x828C6A90;
	sub_82CA93D0(ctx, base);
	// 828C6A90: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828C6A94: 9421FDE0  stwu r1, -0x220(r1)
	ea = ctx.r[1].u32.wrapping_add(-544 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6A98: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C6A9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C6AA0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C6AA4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828C6AA8: 556AD7FE  rlwinm r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 828C6AAC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C6AB0: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 828C6AB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C6AB8: 419A00F4  beq cr6, 0x828c6bac
	if ctx.cr[6].eq {
	pc = 0x828C6BAC; continue 'dispatch;
	}
	// 828C6ABC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C6AC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C6AC4: 419A0024  beq cr6, 0x828c6ae8
	if ctx.cr[6].eq {
	pc = 0x828C6AE8; continue 'dispatch;
	}
	// 828C6AC8: 894B0006  lbz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C6ACC: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C6AD0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828C6AD4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C6AD8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6ADC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828C6AE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C6AE4: 480000CC  b 0x828c6bb0
	pc = 0x828C6BB0; continue 'dispatch;
            }
            0x828C6AE8 => {
    //   block [0x828C6AE8..0x828C6B04)
	// 828C6AE8: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C6AEC: 80A4004C  lwz r5, 0x4c(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C6AF0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C6AF4: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 828C6AF8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C6AFC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C6B00: 40810054  ble 0x828c6b54
	if !ctx.cr[0].gt {
	pc = 0x828C6B54; continue 'dispatch;
	}
	pc = 0x828C6B04; continue 'dispatch;
            }
            0x828C6B04 => {
    //   block [0x828C6B04..0x828C6B24)
	// 828C6B04: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C6B08: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C6B0C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C6B10: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6B14: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 828C6B18: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C6B1C: 41980008  blt cr6, 0x828c6b24
	if ctx.cr[6].lt {
	pc = 0x828C6B24; continue 'dispatch;
	}
	// 828C6B20: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x828C6B24; continue 'dispatch;
            }
            0x828C6B24 => {
    //   block [0x828C6B24..0x828C6B40)
	// 828C6B24: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C6B28: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C6B2C: 419A0014  beq cr6, 0x828c6b40
	if ctx.cr[6].eq {
	pc = 0x828C6B40; continue 'dispatch;
	}
	// 828C6B30: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C6B34: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C6B38: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C6B3C: 4800000C  b 0x828c6b48
	pc = 0x828C6B48; continue 'dispatch;
            }
            0x828C6B40 => {
    //   block [0x828C6B40..0x828C6B48)
	// 828C6B40: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C6B44: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C6B48; continue 'dispatch;
            }
            0x828C6B48 => {
    //   block [0x828C6B48..0x828C6B54)
	// 828C6B48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C6B4C: 4199FFB8  bgt cr6, 0x828c6b04
	if ctx.cr[6].gt {
	pc = 0x828C6B04; continue 'dispatch;
	}
	// 828C6B50: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C6B54; continue 'dispatch;
            }
            0x828C6B54 => {
    //   block [0x828C6B54..0x828C6B70)
	// 828C6B54: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828C6B58: 419A0040  beq cr6, 0x828c6b98
	if ctx.cr[6].eq {
	pc = 0x828C6B98; continue 'dispatch;
	}
	// 828C6B5C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6B60: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 828C6B64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C6B68: 41990008  bgt cr6, 0x828c6b70
	if ctx.cr[6].gt {
	pc = 0x828C6B70; continue 'dispatch;
	}
	// 828C6B6C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828C6B70; continue 'dispatch;
            }
            0x828C6B70 => {
    //   block [0x828C6B70..0x828C6B98)
	// 828C6B70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C6B74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C6B78: 409A0020  bne cr6, 0x828c6b98
	if !ctx.cr[6].eq {
	pc = 0x828C6B98; continue 'dispatch;
	}
	// 828C6B7C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C6B80: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C6B84: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C6B88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6B8C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828C6B90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C6B94: 4800001C  b 0x828c6bb0
	pc = 0x828C6BB0; continue 'dispatch;
            }
            0x828C6B98 => {
    //   block [0x828C6B98..0x828C6BAC)
	// 828C6B98: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828C6B9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6BA0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828C6BA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C6BA8: 48000008  b 0x828c6bb0
	pc = 0x828C6BB0; continue 'dispatch;
            }
            0x828C6BAC => {
    //   block [0x828C6BAC..0x828C6BB0)
	// 828C6BAC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828C6BB0; continue 'dispatch;
            }
            0x828C6BB0 => {
    //   block [0x828C6BB0..0x828C6E98)
	// 828C6BB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C6BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C6BB8: 419A0330  beq cr6, 0x828c6ee8
	if ctx.cr[6].eq {
	pc = 0x828C6EE8; continue 'dispatch;
	}
	// 828C6BBC: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6BC0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C6BC4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828C6BC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6BCC: 83DD0094  lwz r30, 0x94(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 828C6BD0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C6BD4: 4B93970D  bl 0x822002e0
	ctx.lr = 0x828C6BD8;
	sub_822002E0(ctx, base);
	// 828C6BD8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C6BDC: 83610060  lwz r27, 0x60(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828C6BE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C6BE4: 419A02BC  beq cr6, 0x828c6ea0
	if ctx.cr[6].eq {
	pc = 0x828C6EA0; continue 'dispatch;
	}
	// 828C6BE8: 39610088  addi r11, r1, 0x88
	ctx.r[11].s64 = ctx.r[1].s64 + 136;
	// 828C6BEC: 93E100AC  stw r31, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[31].u32 ) };
	// 828C6BF0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C6BF4: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 828C6BF8: 93E100B4  stw r31, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[31].u32 ) };
	// 828C6BFC: 39210098  addi r9, r1, 0x98
	ctx.r[9].s64 = ctx.r[1].s64 + 152;
	// 828C6C00: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 828C6C04: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 828C6C08: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828C6C0C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C6C10: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C6C14: 38E838C0  addi r7, r8, 0x38c0
	ctx.r[7].s64 = ctx.r[8].s64 + 14528;
	// 828C6C18: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C6C1C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C6C20: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C6C24: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C6C28: 93E90000  stw r31, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C6C2C: 93E90004  stw r31, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C6C30: 93E90008  stw r31, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C6C34: 93E9000C  stw r31, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C6C38: 90E10080  stw r7, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[7].u32 ) };
	// 828C6C3C: 93E10110  stw r31, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[31].u32 ) };
	// 828C6C40: 93E10114  stw r31, 0x114(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), ctx.r[31].u32 ) };
	// 828C6C44: 93E10118  stw r31, 0x118(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[31].u32 ) };
	// 828C6C48: 9BE100B8  stb r31, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u8 ) };
	// 828C6C4C: 9BE100B9  stb r31, 0xb9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(185 as u32), ctx.r[31].u8 ) };
	// 828C6C50: 9BE100BA  stb r31, 0xba(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(186 as u32), ctx.r[31].u8 ) };
	// 828C6C54: 9BE100E8  stb r31, 0xe8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[31].u8 ) };
	// 828C6C58: 9BE100E9  stb r31, 0xe9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(233 as u32), ctx.r[31].u8 ) };
	// 828C6C5C: 482B1265  bl 0x82b77ec0
	ctx.lr = 0x828C6C60;
	sub_82B77EC0(ctx, base);
	// 828C6C60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C6C64: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C6C68: 4B8EE8A1  bl 0x821b5508
	ctx.lr = 0x828C6C6C;
	sub_821B5508(ctx, base);
	// 828C6C6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6C70: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 828C6C74: 419A0224  beq cr6, 0x828c6e98
	if ctx.cr[6].eq {
	pc = 0x828C6E98; continue 'dispatch;
	}
	// 828C6C78: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C6C7C: 81410110  lwz r10, 0x110(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) } as u64;
	// 828C6C80: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 828C6C84: 7D1F5A14  add r8, r31, r11
	ctx.r[8].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 828C6C88: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 828C6C8C: 550B2036  slwi r11, r8, 4
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C6C90: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 828C6C94: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x828C6E98; continue 'dispatch;
            }
            0x828C6E98 => {
    //   block [0x828C6E98..0x828C6EA0)
	// 828C6E98: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C6E9C: 4BCB5665  bl 0x8257c500
	ctx.lr = 0x828C6EA0;
	sub_8257C500(ctx, base);
	pc = 0x828C6EA0; continue 'dispatch;
            }
            0x828C6EA0 => {
    //   block [0x828C6EA0..0x828C6EE8)
	// 828C6EA0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828C6EA4: 419A0044  beq cr6, 0x828c6ee8
	if ctx.cr[6].eq {
	pc = 0x828C6EE8; continue 'dispatch;
	}
	// 828C6EA8: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828C6EAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C6EB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C6EB4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C6EB8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828C6EBC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C6EC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C6EC4: 4082FFE8  bne 0x828c6eac
	if !ctx.cr[0].eq {
	pc = 0x828C6EAC; continue 'dispatch;
	}
	// 828C6EC8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828C6ECC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C6ED0: 409A0018  bne cr6, 0x828c6ee8
	if !ctx.cr[6].eq {
	pc = 0x828C6EE8; continue 'dispatch;
	}
	// 828C6ED4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6ED8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C6EDC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6EE0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C6EE4: 4E800421  bctrl
	ctx.lr = 0x828C6EE8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C6EE8 => {
    //   block [0x828C6EE8..0x828C6EF8)
	// 828C6EE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C6EEC: 38210220  addi r1, r1, 0x220
	ctx.r[1].s64 = ctx.r[1].s64 + 544;
	// 828C6EF0: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 828C6EF4: 483E255C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6EF8 size=268
    let mut pc: u32 = 0x828C6EF8;
    'dispatch: loop {
        match pc {
            0x828C6EF8 => {
    //   block [0x828C6EF8..0x828C6F5C)
	// 828C6EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6EFC: 483E250D  bl 0x82ca9408
	ctx.lr = 0x828C6F00;
	sub_82CA93D0(ctx, base);
	// 828C6F00: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828C6F04: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6F08: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C6F0C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828C6F10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6F14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C6F18: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828C6F1C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C6F20: 388B0F70  addi r4, r11, 0xf70
	ctx.r[4].s64 = ctx.r[11].s64 + 3952;
	// 828C6F24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6F28: 4B965FA9  bl 0x8222ced0
	ctx.lr = 0x828C6F2C;
	sub_8222CED0(ctx, base);
	// 828C6F2C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828C6F30: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C6F34: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C6F38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6F3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6F40: 4BFFFB49  bl 0x828c6a88
	ctx.lr = 0x828C6F44;
	sub_828C6A88(ctx, base);
	// 828C6F44: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C6F48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6F4C: 4B94DE8D  bl 0x82214dd8
	ctx.lr = 0x828C6F50;
	sub_82214DD8(ctx, base);
	// 828C6F50: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 828C6F54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C6F58: 419A0014  beq cr6, 0x828c6f6c
	if ctx.cr[6].eq {
	pc = 0x828C6F6C; continue 'dispatch;
	}
	pc = 0x828C6F5C; continue 'dispatch;
            }
            0x828C6F5C => {
    //   block [0x828C6F5C..0x828C6F6C)
	// 828C6F5C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828C6F60: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C6F64: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828C6F68: 483E24F0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x828C6F6C => {
    //   block [0x828C6F6C..0x828C7004)
	// 828C6F6C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C6F70: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C6F74: 388B31CC  addi r4, r11, 0x31cc
	ctx.r[4].s64 = ctx.r[11].s64 + 12748;
	// 828C6F78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6F7C: 4B965F55  bl 0x8222ced0
	ctx.lr = 0x828C6F80;
	sub_8222CED0(ctx, base);
	// 828C6F80: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828C6F84: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C6F88: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C6F8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6F90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6F94: 4BFFFAF5  bl 0x828c6a88
	ctx.lr = 0x828C6F98;
	sub_828C6A88(ctx, base);
	// 828C6F98: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C6F9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6FA0: 4B94DE39  bl 0x82214dd8
	ctx.lr = 0x828C6FA4;
	sub_82214DD8(ctx, base);
	// 828C6FA4: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 828C6FA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C6FAC: 409AFFB0  bne cr6, 0x828c6f5c
	if !ctx.cr[6].eq {
	pc = 0x828C6F5C; continue 'dispatch;
	}
	// 828C6FB0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828C6FB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C6FB8: 388B7550  addi r4, r11, 0x7550
	ctx.r[4].s64 = ctx.r[11].s64 + 30032;
	// 828C6FBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6FC0: 4B965F11  bl 0x8222ced0
	ctx.lr = 0x828C6FC4;
	sub_8222CED0(ctx, base);
	// 828C6FC4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828C6FC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C6FCC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C6FD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6FD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6FD8: 4BFFFAB1  bl 0x828c6a88
	ctx.lr = 0x828C6FDC;
	sub_828C6A88(ctx, base);
	// 828C6FDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6FE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6FE4: 4B94DDF5  bl 0x82214dd8
	ctx.lr = 0x828C6FE8;
	sub_82214DD8(ctx, base);
	// 828C6FE8: 57EA063E  clrlwi r10, r31, 0x18
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828C6FEC: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 828C6FF0: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828C6FF4: 69030001  xori r3, r8, 1
	ctx.r[3].u64 = ctx.r[8].u64 ^ 1;
	// 828C6FF8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C6FFC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828C7000: 483E2458  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7008 size=456
    let mut pc: u32 = 0x828C7008;
    'dispatch: loop {
        match pc {
            0x828C7008 => {
    //   block [0x828C7008..0x828C71B8)
	// 828C7008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C700C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7010: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7014: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828C7018: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C701C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7020: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 828C7024: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7028: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C702C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C7030: 4E800421  bctrl
	ctx.lr = 0x828C7034;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C7034: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C7038: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C703C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C7040: 419A0178  beq cr6, 0x828c71b8
	if ctx.cr[6].eq {
	pc = 0x828C71B8; continue 'dispatch;
	}
	// 828C7044: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C7048: 4BE559A9  bl 0x8271c9f0
	ctx.lr = 0x828C704C;
	sub_8271C9F0(ctx, base);
	// 828C704C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C7050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7054: 419A0164  beq cr6, 0x828c71b8
	if ctx.cr[6].eq {
	pc = 0x828C71B8; continue 'dispatch;
	}
	// 828C7058: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C705C: 808B0038  lwz r4, 0x38(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828C7060: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C7064: 419A0154  beq cr6, 0x828c71b8
	if ctx.cr[6].eq {
	pc = 0x828C71B8; continue 'dispatch;
	}
	// 828C7068: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C706C: 4BCB5125  bl 0x8257c190
	ctx.lr = 0x828C7070;
	sub_8257C190(ctx, base);
	// 828C7070: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 828C7074: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828C7078: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
            }
            0x828C71B8 => {
    //   block [0x828C71B8..0x828C71D0)
	// 828C71B8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828C71BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C71C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C71C4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C71C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C71CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C71D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C71D0 size=60
    let mut pc: u32 = 0x828C71D0;
    'dispatch: loop {
        match pc {
            0x828C71D0 => {
    //   block [0x828C71D0..0x828C720C)
	// 828C71D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C71D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C71D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C71DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C71E0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828C71E4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C71E8: 388B3C1C  addi r4, r11, 0x3c1c
	ctx.r[4].s64 = ctx.r[11].s64 + 15388;
	// 828C71EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C71F0: 4B965CE1  bl 0x8222ced0
	ctx.lr = 0x828C71F4;
	sub_8222CED0(ctx, base);
	// 828C71F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C71F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C71FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7200: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7204: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7208: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7210 size=892
    let mut pc: u32 = 0x828C7210;
    'dispatch: loop {
        match pc {
            0x828C7210 => {
    //   block [0x828C7210..0x828C7298)
	// 828C7210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7214: 483E21ED  bl 0x82ca9400
	ctx.lr = 0x828C7218;
	sub_82CA93D0(ctx, base);
	// 828C7218: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C721C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828C7220: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C7224: 3B7A000C  addi r27, r26, 0xc
	ctx.r[27].s64 = ctx.r[26].s64 + 12;
	// 828C7228: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C722C: 4BAC3F6D  bl 0x8238b198
	ctx.lr = 0x828C7230;
	sub_8238B198(ctx, base);
	// 828C7230: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C7234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7238: 419A034C  beq cr6, 0x828c7584
	if ctx.cr[6].eq {
	pc = 0x828C7584; continue 'dispatch;
	}
	// 828C723C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C7240: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7244: 4BA8418D  bl 0x8234b3d0
	ctx.lr = 0x828C7248;
	sub_8234B3D0(ctx, base);
	// 828C7248: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C724C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C7250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7254: 419A0100  beq cr6, 0x828c7354
	if ctx.cr[6].eq {
	pc = 0x828C7354; continue 'dispatch;
	}
	// 828C7258: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C725C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828C7260: 4B8ACBD9  bl 0x82173e38
	ctx.lr = 0x828C7264;
	sub_82173E38(ctx, base);
	// 828C7264: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C7268: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C726C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C7270: 419A00D8  beq cr6, 0x828c7348
	if ctx.cr[6].eq {
	pc = 0x828C7348; continue 'dispatch;
	}
	// 828C7274: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C7278: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C727C: 419A001C  beq cr6, 0x828c7298
	if ctx.cr[6].eq {
	pc = 0x828C7298; continue 'dispatch;
	}
	// 828C7280: 894B003F  lbz r10, 0x3f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(63 as u32) ) } as u64;
	// 828C7284: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C7288: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828C728C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C7290: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7294: 480000B0  b 0x828c7344
	pc = 0x828C7344; continue 'dispatch;
            }
            0x828C7298 => {
    //   block [0x828C7298..0x828C72B4)
	// 828C7298: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C729C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C72A0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C72A4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C72A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C72AC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C72B0: 40810054  ble 0x828c7304
	if !ctx.cr[0].gt {
	pc = 0x828C7304; continue 'dispatch;
	}
	pc = 0x828C72B4; continue 'dispatch;
            }
            0x828C72B4 => {
    //   block [0x828C72B4..0x828C72D4)
	// 828C72B4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C72B8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C72BC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C72C0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C72C4: 2F07003F  cmpwi cr6, r7, 0x3f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 63, &mut ctx.xer);
	// 828C72C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C72CC: 41980008  blt cr6, 0x828c72d4
	if ctx.cr[6].lt {
	pc = 0x828C72D4; continue 'dispatch;
	}
	// 828C72D0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x828C72D4; continue 'dispatch;
            }
            0x828C72D4 => {
    //   block [0x828C72D4..0x828C72F0)
	// 828C72D4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C72D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C72DC: 419A0014  beq cr6, 0x828c72f0
	if ctx.cr[6].eq {
	pc = 0x828C72F0; continue 'dispatch;
	}
	// 828C72E0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C72E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C72E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C72EC: 4800000C  b 0x828c72f8
	pc = 0x828C72F8; continue 'dispatch;
            }
            0x828C72F0 => {
    //   block [0x828C72F0..0x828C72F8)
	// 828C72F0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C72F4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C72F8; continue 'dispatch;
            }
            0x828C72F8 => {
    //   block [0x828C72F8..0x828C7304)
	// 828C72F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C72FC: 4199FFB8  bgt cr6, 0x828c72b4
	if ctx.cr[6].gt {
	pc = 0x828C72B4; continue 'dispatch;
	}
	// 828C7300: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C7304; continue 'dispatch;
            }
            0x828C7304 => {
    //   block [0x828C7304..0x828C7320)
	// 828C7304: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C7308: 419A0034  beq cr6, 0x828c733c
	if ctx.cr[6].eq {
	pc = 0x828C733C; continue 'dispatch;
	}
	// 828C730C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7310: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 828C7314: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C7318: 41990008  bgt cr6, 0x828c7320
	if ctx.cr[6].gt {
	pc = 0x828C7320; continue 'dispatch;
	}
	// 828C731C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828C7320; continue 'dispatch;
            }
            0x828C7320 => {
    //   block [0x828C7320..0x828C733C)
	// 828C7320: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C7324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7328: 409A0014  bne cr6, 0x828c733c
	if !ctx.cr[6].eq {
	pc = 0x828C733C; continue 'dispatch;
	}
	// 828C732C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C7330: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828C7334: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C7338: 48000008  b 0x828c7340
	pc = 0x828C7340; continue 'dispatch;
            }
            0x828C733C => {
    //   block [0x828C733C..0x828C7340)
	// 828C733C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x828C7340; continue 'dispatch;
            }
            0x828C7340 => {
    //   block [0x828C7340..0x828C7344)
	// 828C7340: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x828C7344; continue 'dispatch;
            }
            0x828C7344 => {
    //   block [0x828C7344..0x828C7348)
	// 828C7344: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x828C7348; continue 'dispatch;
            }
            0x828C7348 => {
    //   block [0x828C7348..0x828C7354)
	// 828C7348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C734C: 809A0004  lwz r4, 4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7350: 48020DA9  bl 0x828e80f8
	ctx.lr = 0x828C7354;
	sub_828E80F8(ctx, base);
	pc = 0x828C7354; continue 'dispatch;
            }
            0x828C7354 => {
    //   block [0x828C7354..0x828C73F8)
	// 828C7354: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C7358: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 828C735C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C7360: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7364: 394B3214  addi r10, r11, 0x3214
	ctx.r[10].s64 = ctx.r[11].s64 + 12820;
	// 828C7368: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828C736C: 4B93B9ED  bl 0x82202d58
	ctx.lr = 0x828C7370;
	sub_82202D58(ctx, base);
	// 828C7370: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C7374: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 828C7378: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828C737C: 3BAB0B7C  addi r29, r11, 0xb7c
	ctx.r[29].s64 = ctx.r[11].s64 + 2940;
	// 828C7380: 39092B90  addi r8, r9, 0x2b90
	ctx.r[8].s64 = ctx.r[9].s64 + 11152;
	// 828C7384: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828C7388: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C738C: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 828C7390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7394: 4B94D505  bl 0x82214898
	ctx.lr = 0x828C7398;
	sub_82214898(ctx, base);
	// 828C7398: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C739C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C73A0: 4BC0AB29  bl 0x824d1ec8
	ctx.lr = 0x828C73A4;
	sub_824D1EC8(ctx, base);
	// 828C73A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C73A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C73AC: 3BCB0B7C  addi r30, r11, 0xb7c
	ctx.r[30].s64 = ctx.r[11].s64 + 2940;
	// 828C73B0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C73B4: 4B8CCA85  bl 0x82193e38
	ctx.lr = 0x828C73B8;
	sub_82193E38(ctx, base);
	// 828C73B8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C73BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C73C0: 419A0038  beq cr6, 0x828c73f8
	if ctx.cr[6].eq {
	pc = 0x828C73F8; continue 'dispatch;
	}
	// 828C73C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C73C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C73CC: 419A0080  beq cr6, 0x828c744c
	if ctx.cr[6].eq {
	pc = 0x828C744C; continue 'dispatch;
	}
	// 828C73D0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C73D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C73D8: 419A0020  beq cr6, 0x828c73f8
	if ctx.cr[6].eq {
	pc = 0x828C73F8; continue 'dispatch;
	}
	// 828C73DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C73E0: 4B8ACA59  bl 0x82173e38
	ctx.lr = 0x828C73E4;
	sub_82173E38(ctx, base);
	// 828C73E4: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C73E8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C73EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C73F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C73F4: 409A0008  bne cr6, 0x828c73fc
	if !ctx.cr[6].eq {
	pc = 0x828C73FC; continue 'dispatch;
	}
	pc = 0x828C73F8; continue 'dispatch;
            }
            0x828C73F8 => {
    //   block [0x828C73F8..0x828C73FC)
	// 828C73F8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828C73FC; continue 'dispatch;
            }
            0x828C73FC => {
    //   block [0x828C73FC..0x828C744C)
	// 828C73FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C7400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7404: 419A0180  beq cr6, 0x828c7584
	if ctx.cr[6].eq {
	pc = 0x828C7584; continue 'dispatch;
	}
	// 828C7408: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C740C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828C7410: 4B8ACA29  bl 0x82173e38
	ctx.lr = 0x828C7414;
	sub_82173E38(ctx, base);
	// 828C7414: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C7418: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C741C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C7420: 419A00F0  beq cr6, 0x828c7510
	if ctx.cr[6].eq {
	pc = 0x828C7510; continue 'dispatch;
	}
	// 828C7424: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C7428: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C742C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7430: 419A0028  beq cr6, 0x828c7458
	if ctx.cr[6].eq {
	pc = 0x828C7458; continue 'dispatch;
	}
	// 828C7434: 896B003F  lbz r11, 0x3f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(63 as u32) ) } as u64;
	// 828C7438: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828C743C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C7440: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C7444: 83EA0004  lwz r31, 4(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7448: 480000CC  b 0x828c7514
	pc = 0x828C7514; continue 'dispatch;
            }
            0x828C744C => {
    //   block [0x828C744C..0x828C7458)
	// 828C744C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7450: 4B8CC9E9  bl 0x82193e38
	ctx.lr = 0x828C7454;
	sub_82193E38(ctx, base);
	// 828C7454: 4BFFFFA4  b 0x828c73f8
	pc = 0x828C73F8; continue 'dispatch;
            }
            0x828C7458 => {
    //   block [0x828C7458..0x828C7470)
	// 828C7458: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C745C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C7460: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C7464: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C7468: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C746C: 40810054  ble 0x828c74c0
	if !ctx.cr[0].gt {
	pc = 0x828C74C0; continue 'dispatch;
	}
	pc = 0x828C7470; continue 'dispatch;
            }
            0x828C7470 => {
    //   block [0x828C7470..0x828C7490)
	// 828C7470: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C7474: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C7478: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C747C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7480: 2F07003F  cmpwi cr6, r7, 0x3f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 63, &mut ctx.xer);
	// 828C7484: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C7488: 41980008  blt cr6, 0x828c7490
	if ctx.cr[6].lt {
	pc = 0x828C7490; continue 'dispatch;
	}
	// 828C748C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x828C7490; continue 'dispatch;
            }
            0x828C7490 => {
    //   block [0x828C7490..0x828C74AC)
	// 828C7490: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C7494: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C7498: 419A0014  beq cr6, 0x828c74ac
	if ctx.cr[6].eq {
	pc = 0x828C74AC; continue 'dispatch;
	}
	// 828C749C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C74A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C74A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C74A8: 4800000C  b 0x828c74b4
	pc = 0x828C74B4; continue 'dispatch;
            }
            0x828C74AC => {
    //   block [0x828C74AC..0x828C74B4)
	// 828C74AC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C74B0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C74B4; continue 'dispatch;
            }
            0x828C74B4 => {
    //   block [0x828C74B4..0x828C74C0)
	// 828C74B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C74B8: 4199FFB8  bgt cr6, 0x828c7470
	if ctx.cr[6].gt {
	pc = 0x828C7470; continue 'dispatch;
	}
	// 828C74BC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C74C0; continue 'dispatch;
            }
            0x828C74C0 => {
    //   block [0x828C74C0..0x828C74DC)
	// 828C74C0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C74C4: 419A003C  beq cr6, 0x828c7500
	if ctx.cr[6].eq {
	pc = 0x828C7500; continue 'dispatch;
	}
	// 828C74C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C74CC: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 828C74D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C74D4: 41990008  bgt cr6, 0x828c74dc
	if ctx.cr[6].gt {
	pc = 0x828C74DC; continue 'dispatch;
	}
	// 828C74D8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828C74DC; continue 'dispatch;
            }
            0x828C74DC => {
    //   block [0x828C74DC..0x828C7500)
	// 828C74DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C74E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C74E4: 409A001C  bne cr6, 0x828c7500
	if !ctx.cr[6].eq {
	pc = 0x828C7500; continue 'dispatch;
	}
	// 828C74E8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C74EC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828C74F0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C74F4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C74F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C74FC: 48000018  b 0x828c7514
	pc = 0x828C7514; continue 'dispatch;
            }
            0x828C7500 => {
    //   block [0x828C7500..0x828C7510)
	// 828C7500: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C7504: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7508: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C750C: 48000008  b 0x828c7514
	pc = 0x828C7514; continue 'dispatch;
            }
            0x828C7510 => {
    //   block [0x828C7510..0x828C7514)
	// 828C7510: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828C7514; continue 'dispatch;
            }
            0x828C7514 => {
    //   block [0x828C7514..0x828C7540)
	// 828C7514: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C7518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C751C: 409A0024  bne cr6, 0x828c7540
	if !ctx.cr[6].eq {
	pc = 0x828C7540; continue 'dispatch;
	}
	// 828C7520: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C7524: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7528: 3BEB9510  addi r31, r11, -0x6af0
	ctx.r[31].s64 = ctx.r[11].s64 + -27376;
	// 828C752C: 4B8AC90D  bl 0x82173e38
	ctx.lr = 0x828C7530;
	sub_82173E38(ctx, base);
	// 828C7530: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C7534: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C7538: 4BAC5831  bl 0x8238cd68
	ctx.lr = 0x828C753C;
	sub_8238CD68(ctx, base);
	// 828C753C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x828C7540; continue 'dispatch;
            }
            0x828C7540 => {
    //   block [0x828C7540..0x828C7584)
	// 828C7540: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C7544: 419A0040  beq cr6, 0x828c7584
	if ctx.cr[6].eq {
	pc = 0x828C7584; continue 'dispatch;
	}
	// 828C7548: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828C754C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7550: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828C7554: 809A0004  lwz r4, 4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7558: 4B94D341  bl 0x82214898
	ctx.lr = 0x828C755C;
	sub_82214898(ctx, base);
	// 828C755C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C7560: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C7564: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C7568: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 828C756C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828C7570: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828C7574: 4BB8EBA5  bl 0x82456118
	ctx.lr = 0x828C7578;
	sub_82456118(ctx, base);
	// 828C7578: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C757C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7580: 4B8CC8B9  bl 0x82193e38
	ctx.lr = 0x828C7584;
	sub_82193E38(ctx, base);
	pc = 0x828C7584; continue 'dispatch;
            }
            0x828C7584 => {
    //   block [0x828C7584..0x828C758C)
	// 828C7584: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C7588: 483E1EC8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7598 size=256
    let mut pc: u32 = 0x828C7598;
    'dispatch: loop {
        match pc {
            0x828C7598 => {
    //   block [0x828C7598..0x828C760C)
	// 828C7598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C759C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C75A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C75A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C75A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C75AC: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C75B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C75B4: 409A00D0  bne cr6, 0x828c7684
	if !ctx.cr[6].eq {
	pc = 0x828C7684; continue 'dispatch;
	}
	// 828C75B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C75BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C75C0: 4B912DF1  bl 0x821da3b0
	ctx.lr = 0x828C75C4;
	sub_821DA3B0(ctx, base);
	// 828C75C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C75C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C75CC: 419A00B8  beq cr6, 0x828c7684
	if ctx.cr[6].eq {
	pc = 0x828C7684; continue 'dispatch;
	}
	// 828C75D0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C75D4: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828C75D8: 386B31F4  addi r3, r11, 0x31f4
	ctx.r[3].s64 = ctx.r[11].s64 + 12788;
	// 828C75DC: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828C75E0: 4B92C779  bl 0x821f3d58
	ctx.lr = 0x828C75E4;
	sub_821F3D58(ctx, base);
	// 828C75E4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828C75E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C75EC: 4B8EAF0D  bl 0x821b24f8
	ctx.lr = 0x828C75F0;
	sub_821B24F8(ctx, base);
	// 828C75F0: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828C75F4: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 828C75F8: 481390D1  bl 0x82a006c8
	ctx.lr = 0x828C75FC;
	sub_82A006C8(ctx, base);
	// 828C75FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C7600: 419A000C  beq cr6, 0x828c760c
	if ctx.cr[6].eq {
	pc = 0x828C760C; continue 'dispatch;
	}
	// 828C7604: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7608: 48000008  b 0x828c7610
	pc = 0x828C7610; continue 'dispatch;
            }
            0x828C760C => {
    //   block [0x828C760C..0x828C7610)
	// 828C760C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C7610; continue 'dispatch;
            }
            0x828C7610 => {
    //   block [0x828C7610..0x828C7664)
	// 828C7610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7614: 419A0068  beq cr6, 0x828c767c
	if ctx.cr[6].eq {
	pc = 0x828C767C; continue 'dispatch;
	}
	// 828C7618: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828C761C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C7620: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C7624: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C7628: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C762C: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828C7630: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C7634: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C7638: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C763C: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7640: 4B99CE49  bl 0x82264488
	ctx.lr = 0x828C7644;
	sub_82264488(ctx, base);
	// 828C7644: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C7648: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C764C: 419A0018  beq cr6, 0x828c7664
	if ctx.cr[6].eq {
	pc = 0x828C7664; continue 'dispatch;
	}
	// 828C7650: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C7654: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C7658: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C765C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C7660: 409A0008  bne cr6, 0x828c7668
	if !ctx.cr[6].eq {
	pc = 0x828C7668; continue 'dispatch;
	}
	pc = 0x828C7664; continue 'dispatch;
            }
            0x828C7664 => {
    //   block [0x828C7664..0x828C7668)
	// 828C7664: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C7668; continue 'dispatch;
            }
            0x828C7668 => {
    //   block [0x828C7668..0x828C767C)
	// 828C7668: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C766C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7670: 419A000C  beq cr6, 0x828c767c
	if ctx.cr[6].eq {
	pc = 0x828C767C; continue 'dispatch;
	}
	// 828C7674: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7678: 4BFFFB99  bl 0x828c7210
	ctx.lr = 0x828C767C;
	sub_828C7210(ctx, base);
	pc = 0x828C767C; continue 'dispatch;
            }
            0x828C767C => {
    //   block [0x828C767C..0x828C7684)
	// 828C767C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C7680: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	pc = 0x828C7684; continue 'dispatch;
            }
            0x828C7684 => {
    //   block [0x828C7684..0x828C7698)
	// 828C7684: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7688: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C768C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7690: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7698 size=416
    let mut pc: u32 = 0x828C7698;
    'dispatch: loop {
        match pc {
            0x828C7698 => {
    //   block [0x828C7698..0x828C76E8)
	// 828C7698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C769C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C76A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C76A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C76A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C76AC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C76B0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C76B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C76B8: 419A0084  beq cr6, 0x828c773c
	if ctx.cr[6].eq {
	pc = 0x828C773C; continue 'dispatch;
	}
	// 828C76BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C76C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C76C4: 419A0074  beq cr6, 0x828c7738
	if ctx.cr[6].eq {
	pc = 0x828C7738; continue 'dispatch;
	}
	// 828C76C8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C76CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C76D0: 419A0018  beq cr6, 0x828c76e8
	if ctx.cr[6].eq {
	pc = 0x828C76E8; continue 'dispatch;
	}
	// 828C76D4: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C76D8: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C76DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C76E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C76E4: 409A0008  bne cr6, 0x828c76ec
	if !ctx.cr[6].eq {
	pc = 0x828C76EC; continue 'dispatch;
	}
	pc = 0x828C76E8; continue 'dispatch;
            }
            0x828C76E8 => {
    //   block [0x828C76E8..0x828C76EC)
	// 828C76E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828C76EC; continue 'dispatch;
            }
            0x828C76EC => {
    //   block [0x828C76EC..0x828C7738)
	// 828C76EC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C76F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C76F4: 419A0130  beq cr6, 0x828c7824
	if ctx.cr[6].eq {
	pc = 0x828C7824; continue 'dispatch;
	}
	// 828C76F8: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C76FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C7700: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C7704: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C7708: 419A0104  beq cr6, 0x828c780c
	if ctx.cr[6].eq {
	pc = 0x828C780C; continue 'dispatch;
	}
	// 828C770C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C7710: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C7714: 419A0030  beq cr6, 0x828c7744
	if ctx.cr[6].eq {
	pc = 0x828C7744; continue 'dispatch;
	}
	// 828C7718: 892A003F  lbz r9, 0x3f(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(63 as u32) ) } as u64;
	// 828C771C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C7720: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828C7724: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C7728: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C772C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C7730: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C7734: 480000DC  b 0x828c7810
	pc = 0x828C7810; continue 'dispatch;
            }
            0x828C7738 => {
    //   block [0x828C7738..0x828C773C)
	// 828C7738: 4B8CC701  bl 0x82193e38
	ctx.lr = 0x828C773C;
	sub_82193E38(ctx, base);
	pc = 0x828C773C; continue 'dispatch;
            }
            0x828C773C => {
    //   block [0x828C773C..0x828C7744)
	// 828C773C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7740: 4BFFFFA8  b 0x828c76e8
	pc = 0x828C76E8; continue 'dispatch;
            }
            0x828C7744 => {
    //   block [0x828C7744..0x828C7764)
	// 828C7744: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C7748: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C774C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C7750: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C7754: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C7758: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C775C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7760: 40810054  ble 0x828c77b4
	if !ctx.cr[0].gt {
	pc = 0x828C77B4; continue 'dispatch;
	}
	pc = 0x828C7764; continue 'dispatch;
            }
            0x828C7764 => {
    //   block [0x828C7764..0x828C7784)
	// 828C7764: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C7768: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C776C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C7770: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7774: 2F07003F  cmpwi cr6, r7, 0x3f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 63, &mut ctx.xer);
	// 828C7778: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C777C: 41980008  blt cr6, 0x828c7784
	if ctx.cr[6].lt {
	pc = 0x828C7784; continue 'dispatch;
	}
	// 828C7780: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828C7784; continue 'dispatch;
            }
            0x828C7784 => {
    //   block [0x828C7784..0x828C77A0)
	// 828C7784: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C7788: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C778C: 419A0014  beq cr6, 0x828c77a0
	if ctx.cr[6].eq {
	pc = 0x828C77A0; continue 'dispatch;
	}
	// 828C7790: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C7794: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C7798: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C779C: 4800000C  b 0x828c77a8
	pc = 0x828C77A8; continue 'dispatch;
            }
            0x828C77A0 => {
    //   block [0x828C77A0..0x828C77A8)
	// 828C77A0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C77A4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C77A8; continue 'dispatch;
            }
            0x828C77A8 => {
    //   block [0x828C77A8..0x828C77B4)
	// 828C77A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C77AC: 4199FFB8  bgt cr6, 0x828c7764
	if ctx.cr[6].gt {
	pc = 0x828C7764; continue 'dispatch;
	}
	// 828C77B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C77B4; continue 'dispatch;
            }
            0x828C77B4 => {
    //   block [0x828C77B4..0x828C77D0)
	// 828C77B4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C77B8: 419A0040  beq cr6, 0x828c77f8
	if ctx.cr[6].eq {
	pc = 0x828C77F8; continue 'dispatch;
	}
	// 828C77BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C77C0: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 828C77C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C77C8: 41990008  bgt cr6, 0x828c77d0
	if ctx.cr[6].gt {
	pc = 0x828C77D0; continue 'dispatch;
	}
	// 828C77CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C77D0; continue 'dispatch;
            }
            0x828C77D0 => {
    //   block [0x828C77D0..0x828C77F8)
	// 828C77D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C77D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C77D8: 409A0020  bne cr6, 0x828c77f8
	if !ctx.cr[6].eq {
	pc = 0x828C77F8; continue 'dispatch;
	}
	// 828C77DC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C77E0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C77E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C77E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C77EC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C77F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C77F4: 4800001C  b 0x828c7810
	pc = 0x828C7810; continue 'dispatch;
            }
            0x828C77F8 => {
    //   block [0x828C77F8..0x828C780C)
	// 828C77F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C77FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7800: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C7804: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C7808: 48000008  b 0x828c7810
	pc = 0x828C7810; continue 'dispatch;
            }
            0x828C780C => {
    //   block [0x828C780C..0x828C7810)
	// 828C780C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C7810; continue 'dispatch;
            }
            0x828C7810 => {
    //   block [0x828C7810..0x828C7824)
	// 828C7810: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C7814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7818: 419A000C  beq cr6, 0x828c7824
	if ctx.cr[6].eq {
	pc = 0x828C7824; continue 'dispatch;
	}
	// 828C781C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7820: 480208D9  bl 0x828e80f8
	ctx.lr = 0x828C7824;
	sub_828E80F8(ctx, base);
	pc = 0x828C7824; continue 'dispatch;
            }
            0x828C7824 => {
    //   block [0x828C7824..0x828C7838)
	// 828C7824: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C782C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7830: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7834: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7838 size=244
    let mut pc: u32 = 0x828C7838;
    'dispatch: loop {
        match pc {
            0x828C7838 => {
    //   block [0x828C7838..0x828C792C)
	// 828C7838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C783C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C7844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7848: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C784C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C7850: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7854: 3BCB31FC  addi r30, r11, 0x31fc
	ctx.r[30].s64 = ctx.r[11].s64 + 12796;
	// 828C7858: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C785C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7860: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C7864: 4B96566D  bl 0x8222ced0
	ctx.lr = 0x828C7868;
	sub_8222CED0(ctx, base);
	// 828C7868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C786C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C7870: 480000C1  bl 0x828c7930
	ctx.lr = 0x828C7874;
	sub_828C7930(ctx, base);
	// 828C7874: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7878: 4B94D561  bl 0x82214dd8
	ctx.lr = 0x828C787C;
	sub_82214DD8(ctx, base);
	// 828C787C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828C7880: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C7884: 388A3208  addi r4, r10, 0x3208
	ctx.r[4].s64 = ctx.r[10].s64 + 12808;
	// 828C7888: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C788C: 4B965645  bl 0x8222ced0
	ctx.lr = 0x828C7890;
	sub_8222CED0(ctx, base);
	// 828C7890: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C7894: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C7898: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C789C: 4B965635  bl 0x8222ced0
	ctx.lr = 0x828C78A0;
	sub_8222CED0(ctx, base);
	// 828C78A0: 3D20828C  lis r9, -0x7d74
	ctx.r[9].s64 = -2104754176;
	// 828C78A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C78A8: 38C97210  addi r6, r9, 0x7210
	ctx.r[6].s64 = ctx.r[9].s64 + 29200;
	// 828C78AC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828C78B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C78B4: 480002C5  bl 0x828c7b78
	ctx.lr = 0x828C78B8;
	sub_828C7B78(ctx, base);
	// 828C78B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C78BC: 4B94D51D  bl 0x82214dd8
	ctx.lr = 0x828C78C0;
	sub_82214DD8(ctx, base);
	// 828C78C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C78C4: 4B94D515  bl 0x82214dd8
	ctx.lr = 0x828C78C8;
	sub_82214DD8(ctx, base);
	// 828C78C8: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828C78CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C78D0: 3888D16C  addi r4, r8, -0x2e94
	ctx.r[4].s64 = ctx.r[8].s64 + -11924;
	// 828C78D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C78D8: 4B9655F9  bl 0x8222ced0
	ctx.lr = 0x828C78DC;
	sub_8222CED0(ctx, base);
	// 828C78DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C78E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C78E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C78E8: 4B9655E9  bl 0x8222ced0
	ctx.lr = 0x828C78EC;
	sub_8222CED0(ctx, base);
	// 828C78EC: 3CE0822A  lis r7, -0x7dd6
	ctx.r[7].s64 = -2111176704;
	// 828C78F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C78F4: 38C7EE78  addi r6, r7, -0x1188
	ctx.r[6].s64 = ctx.r[7].s64 + -4488;
	// 828C78F8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C78FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7900: 48000481  bl 0x828c7d80
	ctx.lr = 0x828C7904;
	sub_828C7D80(ctx, base);
	// 828C7904: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C7908: 4B94D4D1  bl 0x82214dd8
	ctx.lr = 0x828C790C;
	sub_82214DD8(ctx, base);
	// 828C790C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7910: 4B94D4C9  bl 0x82214dd8
	ctx.lr = 0x828C7914;
	sub_82214DD8(ctx, base);
	// 828C7914: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7918: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C791C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7920: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C7924: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7928: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7930 size=584
    let mut pc: u32 = 0x828C7930;
    'dispatch: loop {
        match pc {
            0x828C7930 => {
    //   block [0x828C7930..0x828C7958)
	// 828C7930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7934: 483E1ACD  bl 0x82ca9400
	ctx.lr = 0x828C7938;
	sub_82CA93D0(ctx, base);
	// 828C7938: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C793C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7940: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C7944: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7948: 409A0010  bne cr6, 0x828c7958
	if !ctx.cr[6].eq {
	pc = 0x828C7958; continue 'dispatch;
	}
	// 828C794C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C7950: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828C7954: 48000008  b 0x828c795c
	pc = 0x828C795C; continue 'dispatch;
            }
            0x828C7958 => {
    //   block [0x828C7958..0x828C795C)
	// 828C7958: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C795C; continue 'dispatch;
            }
            0x828C795C => {
    //   block [0x828C795C..0x828C79D4)
	// 828C795C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7960: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C7964: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7968: 4BB06C59  bl 0x823ce5c0
	ctx.lr = 0x828C796C;
	sub_823CE5C0(ctx, base);
	// 828C796C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C7970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7974: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7978: 4BB06889  bl 0x823ce200
	ctx.lr = 0x828C797C;
	sub_823CE200(ctx, base);
	// 828C797C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C7980: 4B8F0199  bl 0x821b7b18
	ctx.lr = 0x828C7984;
	sub_821B7B18(ctx, base);
	// 828C7984: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828C7988: 4B9578D1  bl 0x8221f258
	ctx.lr = 0x828C798C;
	sub_8221F258(ctx, base);
	// 828C798C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C7990: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C7994: 419A0040  beq cr6, 0x828c79d4
	if ctx.cr[6].eq {
	pc = 0x828C79D4; continue 'dispatch;
	}
	// 828C7998: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828C799C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C79A0: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 828C79A4: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C79A8: 4B9578B1  bl 0x8221f258
	ctx.lr = 0x828C79AC;
	sub_8221F258(ctx, base);
	// 828C79AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C79B0: 419A0028  beq cr6, 0x828c79d8
	if ctx.cr[6].eq {
	pc = 0x828C79D8; continue 'dispatch;
	}
	// 828C79B4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C79B8: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828C79BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C79C0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C79C4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C79C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C79CC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C79D0: 4800000C  b 0x828c79dc
	pc = 0x828C79DC; continue 'dispatch;
            }
            0x828C79D4 => {
    //   block [0x828C79D4..0x828C79D8)
	// 828C79D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828C79D8; continue 'dispatch;
            }
            0x828C79D8 => {
    //   block [0x828C79D8..0x828C79DC)
	// 828C79D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828C79DC; continue 'dispatch;
            }
            0x828C79DC => {
    //   block [0x828C79DC..0x828C7AE0)
	// 828C79DC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C79E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C79E4: 419A00FC  beq cr6, 0x828c7ae0
	if ctx.cr[6].eq {
	pc = 0x828C7AE0; continue 'dispatch;
	}
	// 828C79E8: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C79EC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C79F0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C79F4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C79F8: 4B961711  bl 0x82229108
	ctx.lr = 0x828C79FC;
	sub_82229108(ctx, base);
	// 828C79FC: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C7A00: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C7A04: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C7A08: 3BCB7F88  addi r30, r11, 0x7f88
	ctx.r[30].s64 = ctx.r[11].s64 + 32648;
	// 828C7A0C: 4B95FE75  bl 0x82227880
	ctx.lr = 0x828C7A10;
	sub_82227880(ctx, base);
	// 828C7A10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C7A14: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 828C7A18: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C7A1C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828C7A20: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C7A24: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C7A28: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C7A2C: 4B8D3055  bl 0x8219aa80
	ctx.lr = 0x828C7A30;
	sub_8219AA80(ctx, base);
	// 828C7A30: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828C7A34: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828C7A38: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828C7A3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7A40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C7A44: 4BB069DD  bl 0x823ce420
	ctx.lr = 0x828C7A48;
	sub_823CE420(ctx, base);
	// 828C7A48: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C7A4C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C7A50: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C7A54: 4815CC75  bl 0x82a246c8
	ctx.lr = 0x828C7A58;
	sub_82A246C8(ctx, base);
	// 828C7A58: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C7A5C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C7A60: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828C7A64: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828C7A68: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7A6C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7A70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7A74: 4B961695  bl 0x82229108
	ctx.lr = 0x828C7A78;
	sub_82229108(ctx, base);
	// 828C7A78: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 828C7A7C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C7A80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7A84: 3BEB6548  addi r31, r11, 0x6548
	ctx.r[31].s64 = ctx.r[11].s64 + 25928;
	// 828C7A88: 4B95FDF9  bl 0x82227880
	ctx.lr = 0x828C7A8C;
	sub_82227880(ctx, base);
	// 828C7A8C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828C7A90: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 828C7A94: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C7A98: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 828C7A9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7AA0: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C7AA4: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828C7AA8: 4B8D2FD9  bl 0x8219aa80
	ctx.lr = 0x828C7AAC;
	sub_8219AA80(ctx, base);
	// 828C7AAC: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 828C7AB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C7AB4: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 828C7AB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7ABC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7AC0: 4BB06961  bl 0x823ce420
	ctx.lr = 0x828C7AC4;
	sub_823CE420(ctx, base);
	// 828C7AC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7AC8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C7ACC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7AD0: 4815CBF9  bl 0x82a246c8
	ctx.lr = 0x828C7AD4;
	sub_82A246C8(ctx, base);
	// 828C7AD4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C7AD8: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 828C7ADC: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x828C7AE0; continue 'dispatch;
            }
            0x828C7AE0 => {
    //   block [0x828C7AE0..0x828C7AF0)
	// 828C7AE0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828C7AE4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C7AE8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828C7AEC: 419A0020  beq cr6, 0x828c7b0c
	if ctx.cr[6].eq {
	pc = 0x828C7B0C; continue 'dispatch;
	}
	pc = 0x828C7AF0; continue 'dispatch;
            }
            0x828C7AF0 => {
    //   block [0x828C7AF0..0x828C7B0C)
	// 828C7AF0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C7AF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7AF8: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C7AFC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C7B00: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C7B04: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7B08: 4082FFE8  bne 0x828c7af0
	if !ctx.cr[0].eq {
	pc = 0x828C7AF0; continue 'dispatch;
	}
	pc = 0x828C7B0C; continue 'dispatch;
            }
            0x828C7B0C => {
    //   block [0x828C7B0C..0x828C7B2C)
	// 828C7B0C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7B10: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C7B14: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C7B18: 4BA2DE31  bl 0x822f5948
	ctx.lr = 0x828C7B1C;
	sub_822F5948(ctx, base);
	// 828C7B1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C7B20: 4B8EFFF9  bl 0x821b7b18
	ctx.lr = 0x828C7B24;
	sub_821B7B18(ctx, base);
	// 828C7B24: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C7B28: 419A0040  beq cr6, 0x828c7b68
	if ctx.cr[6].eq {
	pc = 0x828C7B68; continue 'dispatch;
	}
	pc = 0x828C7B2C; continue 'dispatch;
            }
            0x828C7B2C => {
    //   block [0x828C7B2C..0x828C7B68)
	// 828C7B2C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C7B30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7B34: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C7B38: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C7B3C: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C7B40: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7B44: 4082FFE8  bne 0x828c7b2c
	if !ctx.cr[0].eq {
	pc = 0x828C7B2C; continue 'dispatch;
	}
	// 828C7B48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7B4C: 409A001C  bne cr6, 0x828c7b68
	if !ctx.cr[6].eq {
	pc = 0x828C7B68; continue 'dispatch;
	}
	// 828C7B50: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C7B54: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7B58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C7B5C: 4E800421  bctrl
	ctx.lr = 0x828C7B60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C7B60: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C7B64: 4B9541D5  bl 0x8221bd38
	ctx.lr = 0x828C7B68;
	sub_8221BD38(ctx, base);
            }
            0x828C7B68 => {
    //   block [0x828C7B68..0x828C7B78)
	// 828C7B68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7B6C: 4B8EFFAD  bl 0x821b7b18
	ctx.lr = 0x828C7B70;
	sub_821B7B18(ctx, base);
	// 828C7B70: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C7B74: 483E18DC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7B78 size=516
    let mut pc: u32 = 0x828C7B78;
    'dispatch: loop {
        match pc {
            0x828C7B78 => {
    //   block [0x828C7B78..0x828C7BB4)
	// 828C7B78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7B7C: 483E1881  bl 0x82ca93fc
	ctx.lr = 0x828C7B80;
	sub_82CA93D0(ctx, base);
	// 828C7B80: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7B84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C7B88: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828C7B8C: 3D40828C  lis r10, -0x7d74
	ctx.r[10].s64 = -2104754176;
	// 828C7B90: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828C7B94: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C7B98: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7B9C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C7BA0: 3BAA7210  addi r29, r10, 0x7210
	ctx.r[29].s64 = ctx.r[10].s64 + 29200;
	// 828C7BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7BA8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C7BAC: 419A0008  beq cr6, 0x828c7bb4
	if ctx.cr[6].eq {
	pc = 0x828C7BB4; continue 'dispatch;
	}
	// 828C7BB0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C7BB4; continue 'dispatch;
            }
            0x828C7BB4 => {
    //   block [0x828C7BB4..0x828C7C48)
	// 828C7BB4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7BB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C7BBC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7BC0: 4BB06A01  bl 0x823ce5c0
	ctx.lr = 0x828C7BC4;
	sub_823CE5C0(ctx, base);
	// 828C7BC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C7BC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C7BCC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7BD0: 4BB06541  bl 0x823ce110
	ctx.lr = 0x828C7BD4;
	sub_823CE110(ctx, base);
	// 828C7BD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C7BD8: 4B8EFF41  bl 0x821b7b18
	ctx.lr = 0x828C7BDC;
	sub_821B7B18(ctx, base);
	// 828C7BDC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C7BE0: 4B957679  bl 0x8221f258
	ctx.lr = 0x828C7BE4;
	sub_8221F258(ctx, base);
	// 828C7BE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7BE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C7BEC: 419A005C  beq cr6, 0x828c7c48
	if ctx.cr[6].eq {
	pc = 0x828C7C48; continue 'dispatch;
	}
	// 828C7BF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C7BF4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828C7BF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C7BFC: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C7C00: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C7C04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C7C08: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C7C0C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C7C10: 4B928631  bl 0x821f0240
	ctx.lr = 0x828C7C14;
	sub_821F0240(ctx, base);
	// 828C7C14: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C7C18: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C7C1C: 4B95763D  bl 0x8221f258
	ctx.lr = 0x828C7C20;
	sub_8221F258(ctx, base);
	// 828C7C20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C7C24: 419A0028  beq cr6, 0x828c7c4c
	if ctx.cr[6].eq {
	pc = 0x828C7C4C; continue 'dispatch;
	}
	// 828C7C28: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C7C2C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C7C30: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C7C34: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C7C38: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C7C3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C7C40: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C7C44: 4800000C  b 0x828c7c50
	pc = 0x828C7C50; continue 'dispatch;
            }
            0x828C7C48 => {
    //   block [0x828C7C48..0x828C7C4C)
	// 828C7C48: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828C7C4C; continue 'dispatch;
            }
            0x828C7C4C => {
    //   block [0x828C7C4C..0x828C7C50)
	// 828C7C4C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828C7C50; continue 'dispatch;
            }
            0x828C7C50 => {
    //   block [0x828C7C50..0x828C7C64)
	// 828C7C50: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7C54: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C7C58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7C5C: 419A0008  beq cr6, 0x828c7c64
	if ctx.cr[6].eq {
	pc = 0x828C7C64; continue 'dispatch;
	}
	// 828C7C60: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C7C64; continue 'dispatch;
            }
            0x828C7C64 => {
    //   block [0x828C7C64..0x828C7CE4)
	// 828C7C64: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C7C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7C6C: 419A0078  beq cr6, 0x828c7ce4
	if ctx.cr[6].eq {
	pc = 0x828C7CE4; continue 'dispatch;
	}
	// 828C7C70: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7C74: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C7C78: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7C7C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7C80: 4B961489  bl 0x82229108
	ctx.lr = 0x828C7C84;
	sub_82229108(ctx, base);
	// 828C7C84: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828C7C88: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C7C8C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7C90: 3BCB7FC8  addi r30, r11, 0x7fc8
	ctx.r[30].s64 = ctx.r[11].s64 + 32712;
	// 828C7C94: 4B95FBED  bl 0x82227880
	ctx.lr = 0x828C7C98;
	sub_82227880(ctx, base);
	// 828C7C98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C7C9C: 3D408278  lis r10, -0x7d88
	ctx.r[10].s64 = -2106064896;
	// 828C7CA0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C7CA4: 388A3318  addi r4, r10, 0x3318
	ctx.r[4].s64 = ctx.r[10].s64 + 13080;
	// 828C7CA8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7CAC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C7CB0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C7CB4: 4B8D2DCD  bl 0x8219aa80
	ctx.lr = 0x828C7CB8;
	sub_8219AA80(ctx, base);
	// 828C7CB8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7CBC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C7CC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C7CC4: 4BB0675D  bl 0x823ce420
	ctx.lr = 0x828C7CC8;
	sub_823CE420(ctx, base);
	// 828C7CC8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7CCC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C7CD0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7CD4: 4815C9F5  bl 0x82a246c8
	ctx.lr = 0x828C7CD8;
	sub_82A246C8(ctx, base);
	// 828C7CD8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C7CDC: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C7CE0: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828C7CE4; continue 'dispatch;
            }
            0x828C7CE4 => {
    //   block [0x828C7CE4..0x828C7CF4)
	// 828C7CE4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C7CE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C7CEC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C7CF0: 419A0020  beq cr6, 0x828c7d10
	if ctx.cr[6].eq {
	pc = 0x828C7D10; continue 'dispatch;
	}
	pc = 0x828C7CF4; continue 'dispatch;
            }
            0x828C7CF4 => {
    //   block [0x828C7CF4..0x828C7D10)
	// 828C7CF4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C7CF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7CFC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C7D00: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C7D04: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C7D08: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7D0C: 4082FFE8  bne 0x828c7cf4
	if !ctx.cr[0].eq {
	pc = 0x828C7CF4; continue 'dispatch;
	}
	pc = 0x828C7D10; continue 'dispatch;
            }
            0x828C7D10 => {
    //   block [0x828C7D10..0x828C7D30)
	// 828C7D10: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7D14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C7D18: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C7D1C: 4BA2DC2D  bl 0x822f5948
	ctx.lr = 0x828C7D20;
	sub_822F5948(ctx, base);
	// 828C7D20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7D24: 4B8EFDF5  bl 0x821b7b18
	ctx.lr = 0x828C7D28;
	sub_821B7B18(ctx, base);
	// 828C7D28: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C7D2C: 419A0040  beq cr6, 0x828c7d6c
	if ctx.cr[6].eq {
	pc = 0x828C7D6C; continue 'dispatch;
	}
	pc = 0x828C7D30; continue 'dispatch;
            }
            0x828C7D30 => {
    //   block [0x828C7D30..0x828C7D6C)
	// 828C7D30: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C7D34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7D38: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C7D3C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C7D40: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C7D44: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7D48: 4082FFE8  bne 0x828c7d30
	if !ctx.cr[0].eq {
	pc = 0x828C7D30; continue 'dispatch;
	}
	// 828C7D4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7D50: 409A001C  bne cr6, 0x828c7d6c
	if !ctx.cr[6].eq {
	pc = 0x828C7D6C; continue 'dispatch;
	}
	// 828C7D54: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C7D58: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7D5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C7D60: 4E800421  bctrl
	ctx.lr = 0x828C7D64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C7D64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C7D68: 4B953FD1  bl 0x8221bd38
	ctx.lr = 0x828C7D6C;
	sub_8221BD38(ctx, base);
            }
            0x828C7D6C => {
    //   block [0x828C7D6C..0x828C7D7C)
	// 828C7D6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C7D70: 4B8EFDA9  bl 0x821b7b18
	ctx.lr = 0x828C7D74;
	sub_821B7B18(ctx, base);
	// 828C7D74: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C7D78: 483E16D4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7D80 size=516
    let mut pc: u32 = 0x828C7D80;
    'dispatch: loop {
        match pc {
            0x828C7D80 => {
    //   block [0x828C7D80..0x828C7DBC)
	// 828C7D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7D84: 483E1679  bl 0x82ca93fc
	ctx.lr = 0x828C7D88;
	sub_82CA93D0(ctx, base);
	// 828C7D88: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7D8C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C7D90: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828C7D94: 3D40822A  lis r10, -0x7dd6
	ctx.r[10].s64 = -2111176704;
	// 828C7D98: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 828C7D9C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C7DA0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7DA4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C7DA8: 3BAAEE78  addi r29, r10, -0x1188
	ctx.r[29].s64 = ctx.r[10].s64 + -4488;
	// 828C7DAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7DB0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C7DB4: 419A0008  beq cr6, 0x828c7dbc
	if ctx.cr[6].eq {
	pc = 0x828C7DBC; continue 'dispatch;
	}
	// 828C7DB8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C7DBC; continue 'dispatch;
            }
            0x828C7DBC => {
    //   block [0x828C7DBC..0x828C7E50)
	// 828C7DBC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7DC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C7DC4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7DC8: 4BB067F9  bl 0x823ce5c0
	ctx.lr = 0x828C7DCC;
	sub_823CE5C0(ctx, base);
	// 828C7DCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C7DD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C7DD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7DD8: 4BB06339  bl 0x823ce110
	ctx.lr = 0x828C7DDC;
	sub_823CE110(ctx, base);
	// 828C7DDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C7DE0: 4B8EFD39  bl 0x821b7b18
	ctx.lr = 0x828C7DE4;
	sub_821B7B18(ctx, base);
	// 828C7DE4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C7DE8: 4B957471  bl 0x8221f258
	ctx.lr = 0x828C7DEC;
	sub_8221F258(ctx, base);
	// 828C7DEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7DF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C7DF4: 419A005C  beq cr6, 0x828c7e50
	if ctx.cr[6].eq {
	pc = 0x828C7E50; continue 'dispatch;
	}
	// 828C7DF8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828C7DFC: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828C7E00: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C7E04: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 828C7E08: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C7E0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C7E10: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C7E14: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828C7E18: 4B928429  bl 0x821f0240
	ctx.lr = 0x828C7E1C;
	sub_821F0240(ctx, base);
	// 828C7E1C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C7E20: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828C7E24: 4B957435  bl 0x8221f258
	ctx.lr = 0x828C7E28;
	sub_8221F258(ctx, base);
	// 828C7E28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C7E2C: 419A0028  beq cr6, 0x828c7e54
	if ctx.cr[6].eq {
	pc = 0x828C7E54; continue 'dispatch;
	}
	// 828C7E30: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828C7E34: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828C7E38: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C7E3C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828C7E40: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C7E44: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C7E48: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C7E4C: 4800000C  b 0x828c7e58
	pc = 0x828C7E58; continue 'dispatch;
            }
            0x828C7E50 => {
    //   block [0x828C7E50..0x828C7E54)
	// 828C7E50: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828C7E54; continue 'dispatch;
            }
            0x828C7E54 => {
    //   block [0x828C7E54..0x828C7E58)
	// 828C7E54: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828C7E58; continue 'dispatch;
            }
            0x828C7E58 => {
    //   block [0x828C7E58..0x828C7E6C)
	// 828C7E58: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7E5C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828C7E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7E64: 419A0008  beq cr6, 0x828c7e6c
	if ctx.cr[6].eq {
	pc = 0x828C7E6C; continue 'dispatch;
	}
	// 828C7E68: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C7E6C; continue 'dispatch;
            }
            0x828C7E6C => {
    //   block [0x828C7E6C..0x828C7EEC)
	// 828C7E6C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C7E70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7E74: 419A0078  beq cr6, 0x828c7eec
	if ctx.cr[6].eq {
	pc = 0x828C7EEC; continue 'dispatch;
	}
	// 828C7E78: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7E7C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828C7E80: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7E84: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7E88: 4B961281  bl 0x82229108
	ctx.lr = 0x828C7E8C;
	sub_82229108(ctx, base);
	// 828C7E8C: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828C7E90: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 828C7E94: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7E98: 3BCB8140  addi r30, r11, -0x7ec0
	ctx.r[30].s64 = ctx.r[11].s64 + -32448;
	// 828C7E9C: 4B95F9E5  bl 0x82227880
	ctx.lr = 0x828C7EA0;
	sub_82227880(ctx, base);
	// 828C7EA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C7EA4: 3D40823B  lis r10, -0x7dc5
	ctx.r[10].s64 = -2110062592;
	// 828C7EA8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C7EAC: 388A08A0  addi r4, r10, 0x8a0
	ctx.r[4].s64 = ctx.r[10].s64 + 2208;
	// 828C7EB0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7EB4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C7EB8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828C7EBC: 4B8D2BC5  bl 0x8219aa80
	ctx.lr = 0x828C7EC0;
	sub_8219AA80(ctx, base);
	// 828C7EC0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7EC4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C7EC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C7ECC: 4BB06555  bl 0x823ce420
	ctx.lr = 0x828C7ED0;
	sub_823CE420(ctx, base);
	// 828C7ED0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7ED4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828C7ED8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C7EDC: 4815C7ED  bl 0x82a246c8
	ctx.lr = 0x828C7EE0;
	sub_82A246C8(ctx, base);
	// 828C7EE0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C7EE4: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 828C7EE8: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828C7EEC; continue 'dispatch;
            }
            0x828C7EEC => {
    //   block [0x828C7EEC..0x828C7EFC)
	// 828C7EEC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C7EF0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C7EF4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828C7EF8: 419A0020  beq cr6, 0x828c7f18
	if ctx.cr[6].eq {
	pc = 0x828C7F18; continue 'dispatch;
	}
	pc = 0x828C7EFC; continue 'dispatch;
            }
            0x828C7EFC => {
    //   block [0x828C7EFC..0x828C7F18)
	// 828C7EFC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C7F00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7F04: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C7F08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C7F0C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C7F10: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7F14: 4082FFE8  bne 0x828c7efc
	if !ctx.cr[0].eq {
	pc = 0x828C7EFC; continue 'dispatch;
	}
	pc = 0x828C7F18; continue 'dispatch;
            }
            0x828C7F18 => {
    //   block [0x828C7F18..0x828C7F38)
	// 828C7F18: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7F1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C7F20: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 828C7F24: 4BA2DA25  bl 0x822f5948
	ctx.lr = 0x828C7F28;
	sub_822F5948(ctx, base);
	// 828C7F28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7F2C: 4B8EFBED  bl 0x821b7b18
	ctx.lr = 0x828C7F30;
	sub_821B7B18(ctx, base);
	// 828C7F30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C7F34: 419A0040  beq cr6, 0x828c7f74
	if ctx.cr[6].eq {
	pc = 0x828C7F74; continue 'dispatch;
	}
	pc = 0x828C7F38; continue 'dispatch;
            }
            0x828C7F38 => {
    //   block [0x828C7F38..0x828C7F74)
	// 828C7F38: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C7F3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7F40: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C7F44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C7F48: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C7F4C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C7F50: 4082FFE8  bne 0x828c7f38
	if !ctx.cr[0].eq {
	pc = 0x828C7F38; continue 'dispatch;
	}
	// 828C7F54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7F58: 409A001C  bne cr6, 0x828c7f74
	if !ctx.cr[6].eq {
	pc = 0x828C7F74; continue 'dispatch;
	}
	// 828C7F5C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C7F60: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7F64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C7F68: 4E800421  bctrl
	ctx.lr = 0x828C7F6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C7F6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C7F70: 4B953DC9  bl 0x8221bd38
	ctx.lr = 0x828C7F74;
	sub_8221BD38(ctx, base);
            }
            0x828C7F74 => {
    //   block [0x828C7F74..0x828C7F84)
	// 828C7F74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C7F78: 4B8EFBA1  bl 0x821b7b18
	ctx.lr = 0x828C7F7C;
	sub_821B7B18(ctx, base);
	// 828C7F7C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C7F80: 483E14CC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C7F88 size=56
    let mut pc: u32 = 0x828C7F88;
    'dispatch: loop {
        match pc {
            0x828C7F88 => {
    //   block [0x828C7F88..0x828C7FA4)
	// 828C7F88: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C7F8C: 419A0018  beq cr6, 0x828c7fa4
	if ctx.cr[6].eq {
	pc = 0x828C7FA4; continue 'dispatch;
	}
	// 828C7F90: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C7F94: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C7F98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C7F9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C7FA0: 409A0008  bne cr6, 0x828c7fa8
	if !ctx.cr[6].eq {
	pc = 0x828C7FA8; continue 'dispatch;
	}
	pc = 0x828C7FA4; continue 'dispatch;
            }
            0x828C7FA4 => {
    //   block [0x828C7FA4..0x828C7FA8)
	// 828C7FA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C7FA8; continue 'dispatch;
            }
            0x828C7FA8 => {
    //   block [0x828C7FA8..0x828C7FC0)
	// 828C7FA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C7FAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7FB0: 419A0010  beq cr6, 0x828c7fc0
	if ctx.cr[6].eq {
		sub_828C7FC0(ctx, base);
		return;
	}
	// 828C7FB4: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C7FB8: 556307FE  clrlwi r3, r11, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 828C7FBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C7FC0 size=8
    let mut pc: u32 = 0x828C7FC0;
    'dispatch: loop {
        match pc {
            0x828C7FC0 => {
    //   block [0x828C7FC0..0x828C7FC8)
	// 828C7FC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C7FC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7FC8 size=376
    let mut pc: u32 = 0x828C7FC8;
    'dispatch: loop {
        match pc {
            0x828C7FC8 => {
    //   block [0x828C7FC8..0x828C7FF4)
	// 828C7FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7FD0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7FD4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C7FD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7FDC: 419A0018  beq cr6, 0x828c7ff4
	if ctx.cr[6].eq {
	pc = 0x828C7FF4; continue 'dispatch;
	}
	// 828C7FE0: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C7FE4: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C7FE8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C7FEC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C7FF0: 409A0008  bne cr6, 0x828c7ff8
	if !ctx.cr[6].eq {
	pc = 0x828C7FF8; continue 'dispatch;
	}
	pc = 0x828C7FF4; continue 'dispatch;
            }
            0x828C7FF4 => {
    //   block [0x828C7FF4..0x828C7FF8)
	// 828C7FF4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828C7FF8; continue 'dispatch;
            }
            0x828C7FF8 => {
    //   block [0x828C7FF8..0x828C8044)
	// 828C7FF8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C7FFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C8000: 419A0130  beq cr6, 0x828c8130
	if ctx.cr[6].eq {
	pc = 0x828C8130; continue 'dispatch;
	}
	// 828C8004: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C8008: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C800C: 552807FE  clrlwi r8, r9, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 828C8010: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C8014: 419A00F8  beq cr6, 0x828c810c
	if ctx.cr[6].eq {
	pc = 0x828C810C; continue 'dispatch;
	}
	// 828C8018: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C801C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C8020: 419A0024  beq cr6, 0x828c8044
	if ctx.cr[6].eq {
	pc = 0x828C8044; continue 'dispatch;
	}
	// 828C8024: 892A0040  lbz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C8028: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C802C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 828C8030: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C8034: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8038: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C803C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C8040: 480000D0  b 0x828c8110
	pc = 0x828C8110; continue 'dispatch;
            }
            0x828C8044 => {
    //   block [0x828C8044..0x828C8064)
	// 828C8044: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C8048: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C804C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C8050: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C8054: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C8058: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C805C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C8060: 40810054  ble 0x828c80b4
	if !ctx.cr[0].gt {
	pc = 0x828C80B4; continue 'dispatch;
	}
	pc = 0x828C8064; continue 'dispatch;
            }
            0x828C8064 => {
    //   block [0x828C8064..0x828C8084)
	// 828C8064: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C8068: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C806C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C8070: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8074: 2F070040  cmpwi cr6, r7, 0x40
	ctx.cr[6].compare_i32(ctx.r[7].s32, 64, &mut ctx.xer);
	// 828C8078: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C807C: 41980008  blt cr6, 0x828c8084
	if ctx.cr[6].lt {
	pc = 0x828C8084; continue 'dispatch;
	}
	// 828C8080: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828C8084; continue 'dispatch;
            }
            0x828C8084 => {
    //   block [0x828C8084..0x828C80A0)
	// 828C8084: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C8088: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C808C: 419A0014  beq cr6, 0x828c80a0
	if ctx.cr[6].eq {
	pc = 0x828C80A0; continue 'dispatch;
	}
	// 828C8090: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C8094: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C8098: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C809C: 4800000C  b 0x828c80a8
	pc = 0x828C80A8; continue 'dispatch;
            }
            0x828C80A0 => {
    //   block [0x828C80A0..0x828C80A8)
	// 828C80A0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C80A4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C80A8; continue 'dispatch;
            }
            0x828C80A8 => {
    //   block [0x828C80A8..0x828C80B4)
	// 828C80A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C80AC: 4199FFB8  bgt cr6, 0x828c8064
	if ctx.cr[6].gt {
	pc = 0x828C8064; continue 'dispatch;
	}
	// 828C80B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C80B4; continue 'dispatch;
            }
            0x828C80B4 => {
    //   block [0x828C80B4..0x828C80D0)
	// 828C80B4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C80B8: 419A0040  beq cr6, 0x828c80f8
	if ctx.cr[6].eq {
	pc = 0x828C80F8; continue 'dispatch;
	}
	// 828C80BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C80C0: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 828C80C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C80C8: 41990008  bgt cr6, 0x828c80d0
	if ctx.cr[6].gt {
	pc = 0x828C80D0; continue 'dispatch;
	}
	// 828C80CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C80D0; continue 'dispatch;
            }
            0x828C80D0 => {
    //   block [0x828C80D0..0x828C80F8)
	// 828C80D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C80D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C80D8: 409A0020  bne cr6, 0x828c80f8
	if !ctx.cr[6].eq {
	pc = 0x828C80F8; continue 'dispatch;
	}
	// 828C80DC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C80E0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C80E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C80E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C80EC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C80F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C80F4: 4800001C  b 0x828c8110
	pc = 0x828C8110; continue 'dispatch;
            }
            0x828C80F8 => {
    //   block [0x828C80F8..0x828C810C)
	// 828C80F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C80FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8100: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828C8104: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C8108: 48000008  b 0x828c8110
	pc = 0x828C8110; continue 'dispatch;
            }
            0x828C810C => {
    //   block [0x828C810C..0x828C8110)
	// 828C810C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C8110; continue 'dispatch;
            }
            0x828C8110 => {
    //   block [0x828C8110..0x828C8130)
	// 828C8110: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C8114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8118: 419A0018  beq cr6, 0x828c8130
	if ctx.cr[6].eq {
	pc = 0x828C8130; continue 'dispatch;
	}
	// 828C811C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8120: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828C8124: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828C8128: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C812C: 4E800421  bctrl
	ctx.lr = 0x828C8130;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C8130 => {
    //   block [0x828C8130..0x828C8140)
	// 828C8130: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C8134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C813C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8140 size=372
    let mut pc: u32 = 0x828C8140;
    'dispatch: loop {
        match pc {
            0x828C8140 => {
    //   block [0x828C8140..0x828C8168)
	// 828C8140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8148: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C814C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828C8150: 419A0018  beq cr6, 0x828c8168
	if ctx.cr[6].eq {
	pc = 0x828C8168; continue 'dispatch;
	}
	// 828C8154: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C8158: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C815C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C8160: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C8164: 409A0008  bne cr6, 0x828c816c
	if !ctx.cr[6].eq {
	pc = 0x828C816C; continue 'dispatch;
	}
	pc = 0x828C8168; continue 'dispatch;
            }
            0x828C8168 => {
    //   block [0x828C8168..0x828C816C)
	// 828C8168: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C816C; continue 'dispatch;
            }
            0x828C816C => {
    //   block [0x828C816C..0x828C81B4)
	// 828C816C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C8170: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8174: 419A012C  beq cr6, 0x828c82a0
	if ctx.cr[6].eq {
	pc = 0x828C82A0; continue 'dispatch;
	}
	// 828C8178: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C817C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C8180: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 828C8184: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C8188: 419A00E8  beq cr6, 0x828c8270
	if ctx.cr[6].eq {
	pc = 0x828C8270; continue 'dispatch;
	}
	// 828C818C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C8190: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 828C8194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8198: 419A001C  beq cr6, 0x828c81b4
	if ctx.cr[6].eq {
	pc = 0x828C81B4; continue 'dispatch;
	}
	// 828C819C: 896B0040  lbz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C81A0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 828C81A4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C81A8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C81AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C81B0: 480000C4  b 0x828c8274
	pc = 0x828C8274; continue 'dispatch;
            }
            0x828C81B4 => {
    //   block [0x828C81B4..0x828C81D0)
	// 828C81B4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C81B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C81BC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C81C0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828C81C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C81C8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C81CC: 40810054  ble 0x828c8220
	if !ctx.cr[0].gt {
	pc = 0x828C8220; continue 'dispatch;
	}
	pc = 0x828C81D0; continue 'dispatch;
            }
            0x828C81D0 => {
    //   block [0x828C81D0..0x828C81F0)
	// 828C81D0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828C81D4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C81D8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828C81DC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C81E0: 2F070040  cmpwi cr6, r7, 0x40
	ctx.cr[6].compare_i32(ctx.r[7].s32, 64, &mut ctx.xer);
	// 828C81E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828C81E8: 41980008  blt cr6, 0x828c81f0
	if ctx.cr[6].lt {
	pc = 0x828C81F0; continue 'dispatch;
	}
	// 828C81EC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828C81F0; continue 'dispatch;
            }
            0x828C81F0 => {
    //   block [0x828C81F0..0x828C820C)
	// 828C81F0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828C81F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C81F8: 419A0014  beq cr6, 0x828c820c
	if ctx.cr[6].eq {
	pc = 0x828C820C; continue 'dispatch;
	}
	// 828C81FC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828C8200: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828C8204: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C8208: 4800000C  b 0x828c8214
	pc = 0x828C8214; continue 'dispatch;
            }
            0x828C820C => {
    //   block [0x828C820C..0x828C8214)
	// 828C820C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828C8210: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828C8214; continue 'dispatch;
            }
            0x828C8214 => {
    //   block [0x828C8214..0x828C8220)
	// 828C8214: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C8218: 4199FFB8  bgt cr6, 0x828c81d0
	if ctx.cr[6].gt {
	pc = 0x828C81D0; continue 'dispatch;
	}
	// 828C821C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828C8220; continue 'dispatch;
            }
            0x828C8220 => {
    //   block [0x828C8220..0x828C823C)
	// 828C8220: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828C8224: 419A003C  beq cr6, 0x828c8260
	if ctx.cr[6].eq {
	pc = 0x828C8260; continue 'dispatch;
	}
	// 828C8228: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C822C: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 828C8230: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C8234: 41990008  bgt cr6, 0x828c823c
	if ctx.cr[6].gt {
	pc = 0x828C823C; continue 'dispatch;
	}
	// 828C8238: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C823C; continue 'dispatch;
            }
            0x828C823C => {
    //   block [0x828C823C..0x828C8260)
	// 828C823C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C8240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8244: 409A001C  bne cr6, 0x828c8260
	if !ctx.cr[6].eq {
	pc = 0x828C8260; continue 'dispatch;
	}
	// 828C8248: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C824C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C8250: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828C8254: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C8258: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C825C: 48000018  b 0x828c8274
	pc = 0x828C8274; continue 'dispatch;
            }
            0x828C8260 => {
    //   block [0x828C8260..0x828C8270)
	// 828C8260: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828C8264: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C8268: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C826C: 48000008  b 0x828c8274
	pc = 0x828C8274; continue 'dispatch;
            }
            0x828C8270 => {
    //   block [0x828C8270..0x828C8274)
	// 828C8270: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828C8274; continue 'dispatch;
            }
            0x828C8274 => {
    //   block [0x828C8274..0x828C82A0)
	// 828C8274: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828C8278: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C827C: 419A0024  beq cr6, 0x828c82a0
	if ctx.cr[6].eq {
	pc = 0x828C82A0; continue 'dispatch;
	}
	// 828C8280: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C8284: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C8288: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C828C: 4E800421  bctrl
	ctx.lr = 0x828C8290;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C8290: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C8294: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8298: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C829C: 4E800020  blr
	return;
            }
            0x828C82A0 => {
    //   block [0x828C82A0..0x828C82B4)
	// 828C82A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C82A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C82A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C82AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C82B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C82B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C82B8 size=72
    let mut pc: u32 = 0x828C82B8;
    'dispatch: loop {
        match pc {
            0x828C82B8 => {
    //   block [0x828C82B8..0x828C82EC)
	// 828C82B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C82BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C82C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C82C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C82C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C82CC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C82D0: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 828C82D4: 392B3268  addi r9, r11, 0x3268
	ctx.r[9].s64 = ctx.r[11].s64 + 12904;
	// 828C82D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C82DC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C82E0: 419A000C  beq cr6, 0x828c82ec
	if ctx.cr[6].eq {
	pc = 0x828C82EC; continue 'dispatch;
	}
	// 828C82E4: 4B953A55  bl 0x8221bd38
	ctx.lr = 0x828C82E8;
	sub_8221BD38(ctx, base);
	// 828C82E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x828C82EC; continue 'dispatch;
            }
            0x828C82EC => {
    //   block [0x828C82EC..0x828C8300)
	// 828C82EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C82F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C82F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C82F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C82FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8300 size=308
    let mut pc: u32 = 0x828C8300;
    'dispatch: loop {
        match pc {
            0x828C8300 => {
    //   block [0x828C8300..0x828C8338)
	// 828C8300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8304: 483E10F1  bl 0x82ca93f4
	ctx.lr = 0x828C8308;
	sub_82CA93D0(ctx, base);
	// 828C8308: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C830C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C8310: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 828C8314: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828C8318: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 828C831C: 419A0100  beq cr6, 0x828c841c
	if ctx.cr[6].eq {
	pc = 0x828C841C; continue 'dispatch;
	}
	// 828C8320: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C8324: 8317000C  lwz r24, 0xc(r23)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C8328: 83990004  lwz r28, 4(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C832C: 83B90008  lwz r29, 8(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C8330: 3B6B0CA0  addi r27, r11, 0xca0
	ctx.r[27].s64 = ctx.r[11].s64 + 3232;
	// 828C8334: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	pc = 0x828C8338; continue 'dispatch;
            }
            0x828C8338 => {
    //   block [0x828C8338..0x828C8354)
	// 828C8338: 574B103A  slwi r11, r26, 2
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C833C: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828C8340: 7D4BC02E  lwzx r10, r11, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 828C8344: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8348: 4099000C  ble cr6, 0x828c8354
	if !ctx.cr[6].gt {
	pc = 0x828C8354; continue 'dispatch;
	}
	// 828C834C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 828C8350: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C8354; continue 'dispatch;
            }
            0x828C8354 => {
    //   block [0x828C8354..0x828C836C)
	// 828C8354: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828C8358: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828C835C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C8360: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828C8364: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828C8368: 419A007C  beq cr6, 0x828c83e4
	if ctx.cr[6].eq {
	pc = 0x828C83E4; continue 'dispatch;
	}
	pc = 0x828C836C; continue 'dispatch;
            }
            0x828C836C => {
    //   block [0x828C836C..0x828C8380)
	// 828C836C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8374: 409A0038  bne cr6, 0x828c83ac
	if !ctx.cr[6].eq {
	pc = 0x828C83AC; continue 'dispatch;
	}
	// 828C8378: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828C837C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828C8380; continue 'dispatch;
            }
            0x828C8380 => {
    //   block [0x828C8380..0x828C83A4)
	// 828C8380: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8384: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8388: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C838C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C8390: 419A0014  beq cr6, 0x828c83a4
	if ctx.cr[6].eq {
	pc = 0x828C83A4; continue 'dispatch;
	}
	// 828C8394: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C8398: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C839C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C83A0: 419AFFE0  beq cr6, 0x828c8380
	if ctx.cr[6].eq {
	pc = 0x828C8380; continue 'dispatch;
	}
	pc = 0x828C83A4; continue 'dispatch;
            }
            0x828C83A4 => {
    //   block [0x828C83A4..0x828C83AC)
	// 828C83A4: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828C83A8: 48000014  b 0x828c83bc
	pc = 0x828C83BC; continue 'dispatch;
            }
            0x828C83AC => {
    //   block [0x828C83AC..0x828C83BC)
	// 828C83AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C83B0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C83B4: 4B9A5445  bl 0x8226d7f8
	ctx.lr = 0x828C83B8;
	sub_8226D7F8(ctx, base);
	// 828C83B8: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	pc = 0x828C83BC; continue 'dispatch;
            }
            0x828C83BC => {
    //   block [0x828C83BC..0x828C83D8)
	// 828C83BC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C83C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C83C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C83C8: 409A0010  bne cr6, 0x828c83d8
	if !ctx.cr[6].eq {
	pc = 0x828C83D8; continue 'dispatch;
	}
	// 828C83CC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 828C83D0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828C83D4: 409AFF98  bne cr6, 0x828c836c
	if !ctx.cr[6].eq {
	pc = 0x828C836C; continue 'dispatch;
	}
	pc = 0x828C83D8; continue 'dispatch;
            }
            0x828C83D8 => {
    //   block [0x828C83D8..0x828C83E4)
	// 828C83D8: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828C83DC: 40990008  ble cr6, 0x828c83e4
	if !ctx.cr[6].gt {
	pc = 0x828C83E4; continue 'dispatch;
	}
	// 828C83E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C83E4; continue 'dispatch;
            }
            0x828C83E4 => {
    //   block [0x828C83E4..0x828C83F8)
	// 828C83E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C83E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C83EC: 419A000C  beq cr6, 0x828c83f8
	if ctx.cr[6].eq {
	pc = 0x828C83F8; continue 'dispatch;
	}
	// 828C83F0: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 828C83F4: 419A0008  beq cr6, 0x828c83fc
	if ctx.cr[6].eq {
	pc = 0x828C83FC; continue 'dispatch;
	}
	pc = 0x828C83F8; continue 'dispatch;
            }
            0x828C83F8 => {
    //   block [0x828C83F8..0x828C83FC)
	// 828C83F8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C83FC; continue 'dispatch;
            }
            0x828C83FC => {
    //   block [0x828C83FC..0x828C841C)
	// 828C83FC: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828C8400: 409A0028  bne cr6, 0x828c8428
	if !ctx.cr[6].eq {
	pc = 0x828C8428; continue 'dispatch;
	}
	// 828C8404: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8408: 574A083C  slwi r10, r26, 1
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C840C: 7D2A5A2E  lhzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C8410: 7D3A0734  extsh r26, r9
	ctx.r[26].s64 = ctx.r[9].s16 as i64;
	// 828C8414: 2F1AFFFF  cmpwi cr6, r26, -1
	ctx.cr[6].compare_i32(ctx.r[26].s32, -1, &mut ctx.xer);
	// 828C8418: 409AFF20  bne cr6, 0x828c8338
	if !ctx.cr[6].eq {
	pc = 0x828C8338; continue 'dispatch;
	}
	pc = 0x828C841C; continue 'dispatch;
            }
            0x828C841C => {
    //   block [0x828C841C..0x828C8428)
	// 828C841C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C8420: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C8424: 483E1020  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x828C8428 => {
    //   block [0x828C8428..0x828C8434)
	// 828C8428: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828C842C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C8430: 483E1014  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8438 size=320
    let mut pc: u32 = 0x828C8438;
    'dispatch: loop {
        match pc {
            0x828C8438 => {
    //   block [0x828C8438..0x828C8474)
	// 828C8438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C843C: 483E0FB9  bl 0x82ca93f4
	ctx.lr = 0x828C8440;
	sub_82CA93D0(ctx, base);
	// 828C8440: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8444: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C8448: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828C844C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 828C8450: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 828C8454: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C845C: 419A0104  beq cr6, 0x828c8560
	if ctx.cr[6].eq {
	pc = 0x828C8560; continue 'dispatch;
	}
	// 828C8460: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828C8464: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C8468: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 828C846C: 3AEA7088  addi r23, r10, 0x7088
	ctx.r[23].s64 = ctx.r[10].s64 + 28808;
	// 828C8470: 3B4BFFDF  addi r26, r11, -0x21
	ctx.r[26].s64 = ctx.r[11].s64 + -33;
	pc = 0x828C8474; continue 'dispatch;
            }
            0x828C8474 => {
    //   block [0x828C8474..0x828C84A0)
	// 828C8474: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8478: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C847C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8480: 7FCBE82E  lwzx r30, r11, r29
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 828C8484: 809E0070  lwz r4, 0x70(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C8488: 4B964A49  bl 0x8222ced0
	ctx.lr = 0x828C848C;
	sub_8222CED0(ctx, base);
	// 828C848C: 80F80000  lwz r7, 0(r24)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8490: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 828C8494: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C8498: 419A0008  beq cr6, 0x828c84a0
	if ctx.cr[6].eq {
	pc = 0x828C84A0; continue 'dispatch;
	}
	// 828C849C: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x828C84A0; continue 'dispatch;
            }
            0x828C84A0 => {
    //   block [0x828C84A0..0x828C84B4)
	// 828C84A0: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C84A4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 828C84A8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C84AC: 419A0008  beq cr6, 0x828c84b4
	if ctx.cr[6].eq {
	pc = 0x828C84B4; continue 'dispatch;
	}
	// 828C84B0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x828C84B4; continue 'dispatch;
            }
            0x828C84B4 => {
    //   block [0x828C84B4..0x828C84CC)
	// 828C84B4: 7D2B5051  subf. r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C84B8: 41800058  blt 0x828c8510
	if ctx.cr[0].lt {
	pc = 0x828C8510; continue 'dispatch;
	}
	// 828C84BC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C84C0: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828C84C4: 419A0008  beq cr6, 0x828c84cc
	if ctx.cr[6].eq {
	pc = 0x828C84CC; continue 'dispatch;
	}
	// 828C84C8: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C84CC; continue 'dispatch;
            }
            0x828C84CC => {
    //   block [0x828C84CC..0x828C84DC)
	// 828C84CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C84D0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 828C84D4: 419A0008  beq cr6, 0x828c84dc
	if ctx.cr[6].eq {
	pc = 0x828C84DC; continue 'dispatch;
	}
	// 828C84D8: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C84DC; continue 'dispatch;
            }
            0x828C84DC => {
    //   block [0x828C84DC..0x828C84E0)
	// 828C84DC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x828C84E0; continue 'dispatch;
            }
            0x828C84E0 => {
    //   block [0x828C84E0..0x828C8504)
	// 828C84E0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C84E4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C84E8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C84EC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C84F0: 419A0014  beq cr6, 0x828c8504
	if ctx.cr[6].eq {
	pc = 0x828C8504; continue 'dispatch;
	}
	// 828C84F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C84F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C84FC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C8500: 419AFFE0  beq cr6, 0x828c84e0
	if ctx.cr[6].eq {
	pc = 0x828C84E0; continue 'dispatch;
	}
	pc = 0x828C8504; continue 'dispatch;
            }
            0x828C8504 => {
    //   block [0x828C8504..0x828C8510)
	// 828C8504: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828C8508: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C850C: 48000008  b 0x828c8514
	pc = 0x828C8514; continue 'dispatch;
            }
            0x828C8510 => {
    //   block [0x828C8510..0x828C8514)
	// 828C8510: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	pc = 0x828C8514; continue 'dispatch;
            }
            0x828C8514 => {
    //   block [0x828C8514..0x828C8520)
	// 828C8514: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8518: 4B8FE251  bl 0x821c6768
	ctx.lr = 0x828C851C;
	sub_821C6768(ctx, base);
	// 828C851C: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	pc = 0x828C8520; continue 'dispatch;
            }
            0x828C8520 => {
    //   block [0x828C8520..0x828C8560)
	// 828C8520: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828C8524: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8528: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828C852C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828C8530: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8534: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8538: 4082FFE8  bne 0x828c8520
	if !ctx.cr[0].eq {
	pc = 0x828C8520; continue 'dispatch;
	}
	// 828C853C: 57E8063E  clrlwi r8, r31, 0x18
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828C8540: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828C8544: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C8548: 409A0024  bne cr6, 0x828c856c
	if !ctx.cr[6].eq {
	pc = 0x828C856C; continue 'dispatch;
	}
	// 828C854C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8550: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 828C8554: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 828C8558: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C855C: 409AFF18  bne cr6, 0x828c8474
	if !ctx.cr[6].eq {
	pc = 0x828C8474; continue 'dispatch;
	}
	pc = 0x828C8560; continue 'dispatch;
            }
            0x828C8560 => {
    //   block [0x828C8560..0x828C856C)
	// 828C8560: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C8564: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C8568: 483E0EDC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x828C856C => {
    //   block [0x828C856C..0x828C8578)
	// 828C856C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C8570: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C8574: 483E0ED0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8578 size=100
    let mut pc: u32 = 0x828C8578;
    'dispatch: loop {
        match pc {
            0x828C8578 => {
    //   block [0x828C8578..0x828C85B4)
	// 828C8578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C857C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8584: F8610080  std r3, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u64 ) };
	// 828C8588: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C858C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828C8590: 388BC864  addi r4, r11, -0x379c
	ctx.r[4].s64 = ctx.r[11].s64 + -14236;
	// 828C8594: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C8598: 4B9CA481  bl 0x82292a18
	ctx.lr = 0x828C859C;
	sub_82292A18(ctx, base);
	// 828C859C: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828C85A0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 828C85A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C85A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C85AC: 409A0008  bne cr6, 0x828c85b4
	if !ctx.cr[6].eq {
	pc = 0x828C85B4; continue 'dispatch;
	}
	// 828C85B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C85B4; continue 'dispatch;
            }
            0x828C85B4 => {
    //   block [0x828C85B4..0x828C85C8)
	// 828C85B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C85B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C85BC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C85C0: 409A0008  bne cr6, 0x828c85c8
	if !ctx.cr[6].eq {
	pc = 0x828C85C8; continue 'dispatch;
	}
	// 828C85C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C85C8; continue 'dispatch;
            }
            0x828C85C8 => {
    //   block [0x828C85C8..0x828C85DC)
	// 828C85C8: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 828C85CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C85D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C85D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C85D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C85E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C85E0 size=308
    let mut pc: u32 = 0x828C85E0;
    'dispatch: loop {
        match pc {
            0x828C85E0 => {
    //   block [0x828C85E0..0x828C863C)
	// 828C85E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C85E4: 483E0E1D  bl 0x82ca9400
	ctx.lr = 0x828C85E8;
	sub_82CA93D0(ctx, base);
	// 828C85E8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C85EC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C85F0: 786A0020  clrldi r10, r3, 0x20
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 828C85F4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828C85F8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828C85FC: 3BEBC864  addi r31, r11, -0x379c
	ctx.r[31].s64 = ctx.r[11].s64 + -14236;
	// 828C8600: 813C0014  lwz r9, 0x14(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C8604: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828C8608: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C860C: 792907E6  rldicr r9, r9, 0x20, 0x3f
	ctx.r[9].u64 = (ctx.r[9].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 828C8610: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8614: 7FC95214  add r30, r9, r10
	ctx.r[30].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 828C8618: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 828C861C: 4B9CA3FD  bl 0x82292a18
	ctx.lr = 0x828C8620;
	sub_82292A18(ctx, base);
	// 828C8620: E9030000  ld r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828C8624: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 828C8628: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C862C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8630: 419A000C  beq cr6, 0x828c863c
	if ctx.cr[6].eq {
	pc = 0x828C863C; continue 'dispatch;
	}
	// 828C8634: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828C8638: 419A0008  beq cr6, 0x828c8640
	if ctx.cr[6].eq {
	pc = 0x828C8640; continue 'dispatch;
	}
	pc = 0x828C863C; continue 'dispatch;
            }
            0x828C863C => {
    //   block [0x828C863C..0x828C8640)
	// 828C863C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C8640; continue 'dispatch;
            }
            0x828C8640 => {
    //   block [0x828C8640..0x828C8698)
	// 828C8640: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8644: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C8648: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C864C: 409A00BC  bne cr6, 0x828c8708
	if !ctx.cr[6].eq {
	pc = 0x828C8708; continue 'dispatch;
	}
	// 828C8650: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 828C8654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8658: 815C002C  lwz r10, 0x2c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C865C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C8660: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828C8664: 7D3F1E70  srawi r31, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828C8668: 48002671  bl 0x828cacd8
	ctx.lr = 0x828C866C;
	sub_828CACD8(ctx, base);
	// 828C866C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C8670: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C8674: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828C8678: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C867C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C8680: 4B9E49F9  bl 0x822ad078
	ctx.lr = 0x828C8684;
	sub_822AD078(ctx, base);
	// 828C8684: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828C8688: 419A004C  beq cr6, 0x828c86d4
	if ctx.cr[6].eq {
	pc = 0x828C86D4; continue 'dispatch;
	}
	// 828C868C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C8690: 419A0038  beq cr6, 0x828c86c8
	if ctx.cr[6].eq {
	pc = 0x828C86C8; continue 'dispatch;
	}
	// 828C8694: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x828C8698; continue 'dispatch;
            }
            0x828C8698 => {
    //   block [0x828C8698..0x828C86C8)
	// 828C8698: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C869C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C86A0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828C86A4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828C86A8: 48000071  bl 0x828c8718
	ctx.lr = 0x828C86AC;
	sub_828C8718(ctx, base);
	// 828C86AC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C86B0: 7C690734  extsh r9, r3
	ctx.r[9].s64 = ctx.r[3].s16 as i64;
	// 828C86B4: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828C86B8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 828C86BC: 7D2BE92E  stwx r9, r11, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[9].u32) };
	// 828C86C0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 828C86C4: 4082FFD4  bne 0x828c8698
	if !ctx.cr[0].eq {
	pc = 0x828C8698; continue 'dispatch;
	}
	pc = 0x828C86C8; continue 'dispatch;
            }
            0x828C86C8 => {
    //   block [0x828C86C8..0x828C86D4)
	// 828C86C8: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C86CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C86D0: 483E0D80  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x828C86D4 => {
    //   block [0x828C86D4..0x828C86E4)
	// 828C86D4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828C86D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C86DC: 419AFFEC  beq cr6, 0x828c86c8
	if ctx.cr[6].eq {
	pc = 0x828C86C8; continue 'dispatch;
	}
	// 828C86E0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x828C86E4; continue 'dispatch;
            }
            0x828C86E4 => {
    //   block [0x828C86E4..0x828C8708)
	// 828C86E4: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C86E8: 7D69512E  stwx r11, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 828C86EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C86F0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828C86F4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828C86F8: 409AFFEC  bne cr6, 0x828c86e4
	if !ctx.cr[6].eq {
	pc = 0x828C86E4; continue 'dispatch;
	}
	// 828C86FC: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C8700: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C8704: 483E0D4C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x828C8708 => {
    //   block [0x828C8708..0x828C8714)
	// 828C8708: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C870C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C8710: 483E0D40  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8718 size=456
    let mut pc: u32 = 0x828C8718;
    'dispatch: loop {
        match pc {
            0x828C8718 => {
    //   block [0x828C8718..0x828C8748)
	// 828C8718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C871C: 483E0CE9  bl 0x82ca9404
	ctx.lr = 0x828C8720;
	sub_82CA93D0(ctx, base);
	// 828C8720: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8724: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C8728: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828C872C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C8730: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C8734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8738: 419A0164  beq cr6, 0x828c889c
	if ctx.cr[6].eq {
	pc = 0x828C889C; continue 'dispatch;
	}
	// 828C873C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C8740: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C8744: 3BCBFFDF  addi r30, r11, -0x21
	ctx.r[30].s64 = ctx.r[11].s64 + -33;
	pc = 0x828C8748; continue 'dispatch;
            }
            0x828C8748 => {
    //   block [0x828C8748..0x828C8774)
	// 828C8748: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C874C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C8750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8754: 7D5F582E  lwzx r10, r31, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C8758: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C875C: 4B964775  bl 0x8222ced0
	ctx.lr = 0x828C8760;
	sub_8222CED0(ctx, base);
	// 828C8760: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8764: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C8768: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C876C: 419A0008  beq cr6, 0x828c8774
	if ctx.cr[6].eq {
	pc = 0x828C8774; continue 'dispatch;
	}
	// 828C8770: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x828C8774; continue 'dispatch;
            }
            0x828C8774 => {
    //   block [0x828C8774..0x828C8788)
	// 828C8774: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C8778: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C877C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C8780: 419A0008  beq cr6, 0x828c8788
	if ctx.cr[6].eq {
	pc = 0x828C8788; continue 'dispatch;
	}
	// 828C8784: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x828C8788; continue 'dispatch;
            }
            0x828C8788 => {
    //   block [0x828C8788..0x828C87A0)
	// 828C8788: 7D2B5051  subf. r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C878C: 41800058  blt 0x828c87e4
	if ctx.cr[0].lt {
	pc = 0x828C87E4; continue 'dispatch;
	}
	// 828C8790: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C8794: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828C8798: 419A0008  beq cr6, 0x828c87a0
	if ctx.cr[6].eq {
	pc = 0x828C87A0; continue 'dispatch;
	}
	// 828C879C: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C87A0; continue 'dispatch;
            }
            0x828C87A0 => {
    //   block [0x828C87A0..0x828C87B0)
	// 828C87A0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C87A4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828C87A8: 419A0008  beq cr6, 0x828c87b0
	if ctx.cr[6].eq {
	pc = 0x828C87B0; continue 'dispatch;
	}
	// 828C87AC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C87B0; continue 'dispatch;
            }
            0x828C87B0 => {
    //   block [0x828C87B0..0x828C87B4)
	// 828C87B0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x828C87B4; continue 'dispatch;
            }
            0x828C87B4 => {
    //   block [0x828C87B4..0x828C87D8)
	// 828C87B4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C87B8: 88CA0000  lbz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C87BC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C87C0: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 828C87C4: 419A0014  beq cr6, 0x828c87d8
	if ctx.cr[6].eq {
	pc = 0x828C87D8; continue 'dispatch;
	}
	// 828C87C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C87CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C87D0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C87D4: 419AFFE0  beq cr6, 0x828c87b4
	if ctx.cr[6].eq {
	pc = 0x828C87B4; continue 'dispatch;
	}
	pc = 0x828C87D8; continue 'dispatch;
            }
            0x828C87D8 => {
    //   block [0x828C87D8..0x828C87E4)
	// 828C87D8: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828C87DC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C87E0: 48000008  b 0x828c87e8
	pc = 0x828C87E8; continue 'dispatch;
            }
            0x828C87E4 => {
    //   block [0x828C87E4..0x828C87E8)
	// 828C87E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C87E8; continue 'dispatch;
            }
            0x828C87E8 => {
    //   block [0x828C87E8..0x828C8804)
	// 828C87E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C87EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C87F0: 409A00B8  bne cr6, 0x828c88a8
	if !ctx.cr[6].eq {
	pc = 0x828C88A8; continue 'dispatch;
	}
	// 828C87F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C87F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C87FC: 419A0008  beq cr6, 0x828c8804
	if ctx.cr[6].eq {
	pc = 0x828C8804; continue 'dispatch;
	}
	// 828C8800: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x828C8804; continue 'dispatch;
            }
            0x828C8804 => {
    //   block [0x828C8804..0x828C8814)
	// 828C8804: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C8808: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C880C: 419A0008  beq cr6, 0x828c8814
	if ctx.cr[6].eq {
	pc = 0x828C8814; continue 'dispatch;
	}
	// 828C8810: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x828C8814; continue 'dispatch;
            }
            0x828C8814 => {
    //   block [0x828C8814..0x828C882C)
	// 828C8814: 7D2B5051  subf. r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C8818: 41800058  blt 0x828c8870
	if ctx.cr[0].lt {
	pc = 0x828C8870; continue 'dispatch;
	}
	// 828C881C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828C8820: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828C8824: 419A0008  beq cr6, 0x828c882c
	if ctx.cr[6].eq {
	pc = 0x828C882C; continue 'dispatch;
	}
	// 828C8828: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C882C; continue 'dispatch;
            }
            0x828C882C => {
    //   block [0x828C882C..0x828C883C)
	// 828C882C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828C8830: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828C8834: 419A0008  beq cr6, 0x828c883c
	if ctx.cr[6].eq {
	pc = 0x828C883C; continue 'dispatch;
	}
	// 828C8838: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828C883C; continue 'dispatch;
            }
            0x828C883C => {
    //   block [0x828C883C..0x828C8840)
	// 828C883C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x828C8840; continue 'dispatch;
            }
            0x828C8840 => {
    //   block [0x828C8840..0x828C8864)
	// 828C8840: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8844: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8848: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C884C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C8850: 419A0014  beq cr6, 0x828c8864
	if ctx.cr[6].eq {
	pc = 0x828C8864; continue 'dispatch;
	}
	// 828C8854: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C8858: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C885C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C8860: 419AFFE0  beq cr6, 0x828c8840
	if ctx.cr[6].eq {
	pc = 0x828C8840; continue 'dispatch;
	}
	pc = 0x828C8864; continue 'dispatch;
            }
            0x828C8864 => {
    //   block [0x828C8864..0x828C8870)
	// 828C8864: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828C8868: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C886C: 48000008  b 0x828c8874
	pc = 0x828C8874; continue 'dispatch;
            }
            0x828C8870 => {
    //   block [0x828C8870..0x828C8874)
	// 828C8870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C8874; continue 'dispatch;
            }
            0x828C8874 => {
    //   block [0x828C8874..0x828C889C)
	// 828C8874: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C8878: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C887C: 409A002C  bne cr6, 0x828c88a8
	if !ctx.cr[6].eq {
	pc = 0x828C88A8; continue 'dispatch;
	}
	// 828C8880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8884: 4B94C555  bl 0x82214dd8
	ctx.lr = 0x828C8888;
	sub_82214DD8(ctx, base);
	// 828C8888: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C888C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 828C8890: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 828C8894: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C8898: 409AFEB0  bne cr6, 0x828c8748
	if !ctx.cr[6].eq {
	pc = 0x828C8748; continue 'dispatch;
	}
	pc = 0x828C889C; continue 'dispatch;
            }
            0x828C889C => {
    //   block [0x828C889C..0x828C88A8)
	// 828C889C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 828C88A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C88A4: 483E0BB0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x828C88A8 => {
    //   block [0x828C88A8..0x828C88B8)
	// 828C88A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C88AC: 4B8FDEBD  bl 0x821c6768
	ctx.lr = 0x828C88B0;
	sub_821C6768(ctx, base);
	// 828C88B0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828C88B4: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x828C88B8; continue 'dispatch;
            }
            0x828C88B8 => {
    //   block [0x828C88B8..0x828C88E0)
	// 828C88B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C88BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C88C0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C88C4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828C88C8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C88CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C88D0: 4082FFE8  bne 0x828c88b8
	if !ctx.cr[0].eq {
	pc = 0x828C88B8; continue 'dispatch;
	}
	// 828C88D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C88D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C88DC: 483E0B78  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C88E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C88E0 size=80
    let mut pc: u32 = 0x828C88E0;
    'dispatch: loop {
        match pc {
            0x828C88E0 => {
    //   block [0x828C88E0..0x828C8918)
	// 828C88E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C88E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C88E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C88EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C88F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C88F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C88F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C88FC: 48000035  bl 0x828c8930
	ctx.lr = 0x828C8900;
	sub_828C8930(ctx, base);
	// 828C8900: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828C8904: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C890C: 419A000C  beq cr6, 0x828c8918
	if ctx.cr[6].eq {
	pc = 0x828C8918; continue 'dispatch;
	}
	// 828C8910: 4B953429  bl 0x8221bd38
	ctx.lr = 0x828C8914;
	sub_8221BD38(ctx, base);
	// 828C8914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x828C8918; continue 'dispatch;
            }
            0x828C8918 => {
    //   block [0x828C8918..0x828C8930)
	// 828C8918: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C891C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8920: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8924: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C8928: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C892C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8930 size=236
    let mut pc: u32 = 0x828C8930;
    'dispatch: loop {
        match pc {
            0x828C8930 => {
    //   block [0x828C8930..0x828C899C)
	// 828C8930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8938: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C893C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8940: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8948: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C894C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C8950: 394B32C0  addi r10, r11, 0x32c0
	ctx.r[10].s64 = ctx.r[11].s64 + 12992;
	// 828C8954: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C8958: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C895C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8960: 419A0040  beq cr6, 0x828c89a0
	if ctx.cr[6].eq {
	pc = 0x828C89A0; continue 'dispatch;
	}
	// 828C8964: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C896C: 419A0030  beq cr6, 0x828c899c
	if ctx.cr[6].eq {
	pc = 0x828C899C; continue 'dispatch;
	}
	// 828C8970: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C8974: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C8978: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C897C: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C8980: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C8984: 409A0018  bne cr6, 0x828c899c
	if !ctx.cr[6].eq {
	pc = 0x828C899C; continue 'dispatch;
	}
	// 828C8988: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C898C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C8990: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8994: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C8998: 4E800421  bctrl
	ctx.lr = 0x828C899C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C899C => {
    //   block [0x828C899C..0x828C89A0)
	// 828C899C: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	pc = 0x828C89A0; continue 'dispatch;
            }
            0x828C89A0 => {
    //   block [0x828C89A0..0x828C89E4)
	// 828C89A0: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828C89A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C89A8: 419A0040  beq cr6, 0x828c89e8
	if ctx.cr[6].eq {
	pc = 0x828C89E8; continue 'dispatch;
	}
	// 828C89AC: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C89B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C89B4: 419A0030  beq cr6, 0x828c89e4
	if ctx.cr[6].eq {
	pc = 0x828C89E4; continue 'dispatch;
	}
	// 828C89B8: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C89BC: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C89C0: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C89C4: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C89C8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C89CC: 409A0018  bne cr6, 0x828c89e4
	if !ctx.cr[6].eq {
	pc = 0x828C89E4; continue 'dispatch;
	}
	// 828C89D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C89D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C89D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C89DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C89E0: 4E800421  bctrl
	ctx.lr = 0x828C89E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C89E4 => {
    //   block [0x828C89E4..0x828C89E8)
	// 828C89E4: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	pc = 0x828C89E8; continue 'dispatch;
            }
            0x828C89E8 => {
    //   block [0x828C89E8..0x828C8A1C)
	// 828C89E8: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828C89EC: 4B8EF12D  bl 0x821b7b18
	ctx.lr = 0x828C89F0;
	sub_821B7B18(ctx, base);
	// 828C89F0: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828C89F4: 4B8EF125  bl 0x821b7b18
	ctx.lr = 0x828C89F8;
	sub_821B7B18(ctx, base);
	// 828C89F8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C89FC: 394B3268  addi r10, r11, 0x3268
	ctx.r[10].s64 = ctx.r[11].s64 + 12904;
	// 828C8A00: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C8A04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C8A08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8A0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8A10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C8A14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C8A18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C8A20 size=16
    let mut pc: u32 = 0x828C8A20;
    'dispatch: loop {
        match pc {
            0x828C8A20 => {
    //   block [0x828C8A20..0x828C8A30)
	// 828C8A20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C8A24: 99630024  stb r11, 0x24(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 828C8A28: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C8A2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8A30 size=412
    let mut pc: u32 = 0x828C8A30;
    'dispatch: loop {
        match pc {
            0x828C8A30 => {
    //   block [0x828C8A30..0x828C8A98)
	// 828C8A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8A34: 483E09D1  bl 0x82ca9404
	ctx.lr = 0x828C8A38;
	sub_82CA93D0(ctx, base);
	// 828C8A38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8A3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C8A40: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8A44: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 828C8A48: 3F608000  lis r27, -0x8000
	ctx.r[27].s64 = -2147483648;
	// 828C8A4C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C8A50: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C8A54: 7D7CE82E  lwzx r11, r28, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 828C8A58: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C8A5C: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C8A60: 7D48DB78  or r8, r10, r27
	ctx.r[8].u64 = ctx.r[10].u64 | ctx.r[27].u64;
	// 828C8A64: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 828C8A68: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C8A6C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828C8A70: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C8A74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C8A78: 419A0020  beq cr6, 0x828c8a98
	if ctx.cr[6].eq {
	pc = 0x828C8A98; continue 'dispatch;
	}
	// 828C8A7C: 812B005C  lwz r9, 0x5c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C8A80: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828C8A84: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 828C8A88: 912B005C  stw r9, 0x5c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 828C8A8C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8A90: 910B0058  stw r8, 0x58(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 828C8A94: 48000010  b 0x828c8aa4
	pc = 0x828C8AA4; continue 'dispatch;
            }
            0x828C8A98 => {
    //   block [0x828C8A98..0x828C8AA4)
	// 828C8A98: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828C8A9C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C8AA0: 4848C5B1  bl 0x82d55050
	ctx.lr = 0x828C8AA4;
	sub_82D55050(ctx, base);
	pc = 0x828C8AA4; continue 'dispatch;
            }
            0x828C8AA4 => {
    //   block [0x828C8AA4..0x828C8AC4)
	// 828C8AA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8AA8: 419A001C  beq cr6, 0x828c8ac4
	if ctx.cr[6].eq {
	pc = 0x828C8AC4; continue 'dispatch;
	}
	// 828C8AAC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828C8AB0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C8AB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C8AB8: 4849AE01  bl 0x82d638b8
	ctx.lr = 0x828C8ABC;
	sub_82D638B8(ctx, base);
	// 828C8ABC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C8AC0: 48000008  b 0x828c8ac8
	pc = 0x828C8AC8; continue 'dispatch;
            }
            0x828C8AC4 => {
    //   block [0x828C8AC4..0x828C8AC8)
	// 828C8AC4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x828C8AC8; continue 'dispatch;
            }
            0x828C8AC8 => {
    //   block [0x828C8AC8..0x828C8B08)
	// 828C8AC8: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 828C8ACC: 4BD4969D  bl 0x82612168
	ctx.lr = 0x828C8AD0;
	sub_82612168(ctx, base);
	// 828C8AD0: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C8AD4: 4849B32D  bl 0x82d63e00
	ctx.lr = 0x828C8AD8;
	sub_82D63E00(ctx, base);
	// 828C8AD8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C8ADC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C8AE0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C8AE4: 409A0024  bne cr6, 0x828c8b08
	if !ctx.cr[6].eq {
	pc = 0x828C8B08; continue 'dispatch;
	}
	// 828C8AE8: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 828C8AEC: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 828C8AF0: 556B087C  rlwinm r11, r11, 1, 1, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 828C8AF4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C8AF8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 828C8AFC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C8B00: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 828C8B04: 4848C7C5  bl 0x82d552c8
	ctx.lr = 0x828C8B08;
	sub_82D552C8(ctx, base);
	pc = 0x828C8B08; continue 'dispatch;
            }
            0x828C8B08 => {
    //   block [0x828C8B08..0x828C8B54)
	// 828C8B08: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828C8B0C: 7D7CE82E  lwzx r11, r28, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 828C8B10: 83EA0008  lwz r31, 8(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C8B14: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C8B18: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C8B1C: 7D27DB78  or r7, r9, r27
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[27].u64;
	// 828C8B20: 90E10068  stw r7, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u32 ) };
	// 828C8B24: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 828C8B28: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 828C8B2C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C8B30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C8B34: 419A0020  beq cr6, 0x828c8b54
	if ctx.cr[6].eq {
	pc = 0x828C8B54; continue 'dispatch;
	}
	// 828C8B38: 812B005C  lwz r9, 0x5c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C8B3C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828C8B40: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 828C8B44: 912B005C  stw r9, 0x5c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 828C8B48: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8B4C: 910B0058  stw r8, 0x58(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 828C8B50: 48000010  b 0x828c8b60
	pc = 0x828C8B60; continue 'dispatch;
            }
            0x828C8B54 => {
    //   block [0x828C8B54..0x828C8B60)
	// 828C8B54: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828C8B58: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828C8B5C: 4848C4F5  bl 0x82d55050
	ctx.lr = 0x828C8B60;
	sub_82D55050(ctx, base);
	pc = 0x828C8B60; continue 'dispatch;
            }
            0x828C8B60 => {
    //   block [0x828C8B60..0x828C8B80)
	// 828C8B60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8B64: 419A001C  beq cr6, 0x828c8b80
	if ctx.cr[6].eq {
	pc = 0x828C8B80; continue 'dispatch;
	}
	// 828C8B68: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828C8B6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C8B70: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C8B74: 4849AD45  bl 0x82d638b8
	ctx.lr = 0x828C8B78;
	sub_82D638B8(ctx, base);
	// 828C8B78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C8B7C: 48000008  b 0x828c8b84
	pc = 0x828C8B84; continue 'dispatch;
            }
            0x828C8B80 => {
    //   block [0x828C8B80..0x828C8B84)
	// 828C8B80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x828C8B84; continue 'dispatch;
            }
            0x828C8B84 => {
    //   block [0x828C8B84..0x828C8BC4)
	// 828C8B84: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828C8B88: 4BD495E1  bl 0x82612168
	ctx.lr = 0x828C8B8C;
	sub_82612168(ctx, base);
	// 828C8B8C: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C8B90: 4849B271  bl 0x82d63e00
	ctx.lr = 0x828C8B94;
	sub_82D63E00(ctx, base);
	// 828C8B94: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828C8B98: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C8B9C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C8BA0: 409A0024  bne cr6, 0x828c8bc4
	if !ctx.cr[6].eq {
	pc = 0x828C8BC4; continue 'dispatch;
	}
	// 828C8BA4: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 828C8BA8: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 828C8BAC: 556B087C  rlwinm r11, r11, 1, 1, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 828C8BB0: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828C8BB4: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 828C8BB8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C8BBC: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 828C8BC0: 4848C709  bl 0x82d552c8
	ctx.lr = 0x828C8BC4;
	sub_82D552C8(ctx, base);
	pc = 0x828C8BC4; continue 'dispatch;
            }
            0x828C8BC4 => {
    //   block [0x828C8BC4..0x828C8BCC)
	// 828C8BC4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C8BC8: 483E088C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C8BD0 size=8
    let mut pc: u32 = 0x828C8BD0;
    'dispatch: loop {
        match pc {
            0x828C8BD0 => {
    //   block [0x828C8BD0..0x828C8BD8)
	// 828C8BD0: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 828C8BD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8BD8 size=156
    let mut pc: u32 = 0x828C8BD8;
    'dispatch: loop {
        match pc {
            0x828C8BD8 => {
    //   block [0x828C8BD8..0x828C8C38)
	// 828C8BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8BDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8BE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C8BE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8BE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8BEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C8BF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C8BF4: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C8BF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8BFC: 419A003C  beq cr6, 0x828c8c38
	if ctx.cr[6].eq {
	pc = 0x828C8C38; continue 'dispatch;
	}
	// 828C8C00: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8C08: 419A0030  beq cr6, 0x828c8c38
	if ctx.cr[6].eq {
	pc = 0x828C8C38; continue 'dispatch;
	}
	// 828C8C0C: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C8C10: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C8C14: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C8C18: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C8C1C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C8C20: 409A0018  bne cr6, 0x828c8c38
	if !ctx.cr[6].eq {
	pc = 0x828C8C38; continue 'dispatch;
	}
	// 828C8C24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8C28: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C8C2C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8C30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C8C34: 4E800421  bctrl
	ctx.lr = 0x828C8C38;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C8C38 => {
    //   block [0x828C8C38..0x828C8C5C)
	// 828C8C38: 93FE0018  stw r31, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 828C8C3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C8C40: 419A001C  beq cr6, 0x828c8c5c
	if ctx.cr[6].eq {
	pc = 0x828C8C5C; continue 'dispatch;
	}
	// 828C8C44: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8C4C: 419A0010  beq cr6, 0x828c8c5c
	if ctx.cr[6].eq {
	pc = 0x828C8C5C; continue 'dispatch;
	}
	// 828C8C50: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C8C54: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 828C8C58: B15F0006  sth r10, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	pc = 0x828C8C5C; continue 'dispatch;
            }
            0x828C8C5C => {
    //   block [0x828C8C5C..0x828C8C74)
	// 828C8C5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C8C60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8C64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8C68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C8C6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C8C70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8C78 size=156
    let mut pc: u32 = 0x828C8C78;
    'dispatch: loop {
        match pc {
            0x828C8C78 => {
    //   block [0x828C8C78..0x828C8CD8)
	// 828C8C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8C80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C8C84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8C88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8C8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C8C90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C8C94: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828C8C98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8C9C: 419A003C  beq cr6, 0x828c8cd8
	if ctx.cr[6].eq {
	pc = 0x828C8CD8; continue 'dispatch;
	}
	// 828C8CA0: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8CA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8CA8: 419A0030  beq cr6, 0x828c8cd8
	if ctx.cr[6].eq {
	pc = 0x828C8CD8; continue 'dispatch;
	}
	// 828C8CAC: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C8CB0: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C8CB4: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C8CB8: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C8CBC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C8CC0: 409A0018  bne cr6, 0x828c8cd8
	if !ctx.cr[6].eq {
	pc = 0x828C8CD8; continue 'dispatch;
	}
	// 828C8CC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8CC8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C8CCC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8CD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C8CD4: 4E800421  bctrl
	ctx.lr = 0x828C8CD8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C8CD8 => {
    //   block [0x828C8CD8..0x828C8CFC)
	// 828C8CD8: 93FE001C  stw r31, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 828C8CDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C8CE0: 419A001C  beq cr6, 0x828c8cfc
	if ctx.cr[6].eq {
	pc = 0x828C8CFC; continue 'dispatch;
	}
	// 828C8CE4: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8CE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8CEC: 419A0010  beq cr6, 0x828c8cfc
	if ctx.cr[6].eq {
	pc = 0x828C8CFC; continue 'dispatch;
	}
	// 828C8CF0: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C8CF4: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 828C8CF8: B15F0006  sth r10, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	pc = 0x828C8CFC; continue 'dispatch;
            }
            0x828C8CFC => {
    //   block [0x828C8CFC..0x828C8D14)
	// 828C8CFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C8D00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8D04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8D08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C8D0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C8D10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8D18 size=224
    let mut pc: u32 = 0x828C8D18;
    'dispatch: loop {
        match pc {
            0x828C8D18 => {
    //   block [0x828C8D18..0x828C8D60)
	// 828C8D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8D20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C8D24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8D28: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828C8D2C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8D30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8D34: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828C8D38: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828C8D3C: 4B9B4C75  bl 0x8227d9b0
	ctx.lr = 0x828C8D40;
	sub_8227D9B0(ctx, base);
	// 828C8D40: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C8D44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8D48: 419A0020  beq cr6, 0x828c8d68
	if ctx.cr[6].eq {
	pc = 0x828C8D68; continue 'dispatch;
	}
	// 828C8D4C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828C8D50: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 828C8D54: 419A000C  beq cr6, 0x828c8d60
	if ctx.cr[6].eq {
	pc = 0x828C8D60; continue 'dispatch;
	}
	// 828C8D58: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828C8D5C: 409A000C  bne cr6, 0x828c8d68
	if !ctx.cr[6].eq {
	pc = 0x828C8D68; continue 'dispatch;
	}
	pc = 0x828C8D60; continue 'dispatch;
            }
            0x828C8D60 => {
    //   block [0x828C8D60..0x828C8D68)
	// 828C8D60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C8D64: 48000008  b 0x828c8d6c
	pc = 0x828C8D6C; continue 'dispatch;
            }
            0x828C8D68 => {
    //   block [0x828C8D68..0x828C8D6C)
	// 828C8D68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828C8D6C; continue 'dispatch;
            }
            0x828C8D6C => {
    //   block [0x828C8D6C..0x828C8D9C)
	// 828C8D6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828C8D70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8D74: 419A0068  beq cr6, 0x828c8ddc
	if ctx.cr[6].eq {
	pc = 0x828C8DDC; continue 'dispatch;
	}
	// 828C8D78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C8D7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C8D80: 4B9B4B29  bl 0x8227d8a8
	ctx.lr = 0x828C8D84;
	sub_8227D8A8(ctx, base);
	// 828C8D84: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C8D88: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C8D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8D90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C8D94: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828C8D98: 419A0020  beq cr6, 0x828c8db8
	if ctx.cr[6].eq {
	pc = 0x828C8DB8; continue 'dispatch;
	}
	pc = 0x828C8D9C; continue 'dispatch;
            }
            0x828C8D9C => {
    //   block [0x828C8D9C..0x828C8DB8)
	// 828C8D9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8DA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8DA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8DA8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8DAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8DB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8DB4: 4082FFE8  bne 0x828c8d9c
	if !ctx.cr[0].eq {
	pc = 0x828C8D9C; continue 'dispatch;
	}
	pc = 0x828C8DB8; continue 'dispatch;
            }
            0x828C8DB8 => {
    //   block [0x828C8DB8..0x828C8DDC)
	// 828C8DB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8DBC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C8DC0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828C8DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8DC8: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C8DCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C8DD0: 4E800421  bctrl
	ctx.lr = 0x828C8DD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C8DD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8DD8: 4B8EED41  bl 0x821b7b18
	ctx.lr = 0x828C8DDC;
	sub_821B7B18(ctx, base);
            }
            0x828C8DDC => {
    //   block [0x828C8DDC..0x828C8DF8)
	// 828C8DDC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C8DE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8DE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8DE8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828C8DEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C8DF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C8DF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8DF8 size=136
    let mut pc: u32 = 0x828C8DF8;
    'dispatch: loop {
        match pc {
            0x828C8DF8 => {
    //   block [0x828C8DF8..0x828C8E34)
	// 828C8DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8E00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8E04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8E08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8E0C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C8E10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8E14: 419A0058  beq cr6, 0x828c8e6c
	if ctx.cr[6].eq {
	pc = 0x828C8E6C; continue 'dispatch;
	}
	// 828C8E18: 4B9B4B99  bl 0x8227d9b0
	ctx.lr = 0x828C8E1C;
	sub_8227D9B0(ctx, base);
	// 828C8E1C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C8E20: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C8E24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8E28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C8E2C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828C8E30: 419A0020  beq cr6, 0x828c8e50
	if ctx.cr[6].eq {
	pc = 0x828C8E50; continue 'dispatch;
	}
	pc = 0x828C8E34; continue 'dispatch;
            }
            0x828C8E34 => {
    //   block [0x828C8E34..0x828C8E50)
	// 828C8E34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8E38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8E3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8E40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8E44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8E48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8E4C: 4082FFE8  bne 0x828c8e34
	if !ctx.cr[0].eq {
	pc = 0x828C8E34; continue 'dispatch;
	}
	pc = 0x828C8E50; continue 'dispatch;
            }
            0x828C8E50 => {
    //   block [0x828C8E50..0x828C8E6C)
	// 828C8E50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8E58: 814B0060  lwz r10, 0x60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 828C8E5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C8E60: 4E800421  bctrl
	ctx.lr = 0x828C8E64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C8E64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8E68: 4B8EECB1  bl 0x821b7b18
	ctx.lr = 0x828C8E6C;
	sub_821B7B18(ctx, base);
            }
            0x828C8E6C => {
    //   block [0x828C8E6C..0x828C8E80)
	// 828C8E6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C8E70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8E74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8E78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C8E7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8E80 size=656
    let mut pc: u32 = 0x828C8E80;
    'dispatch: loop {
        match pc {
            0x828C8E80 => {
    //   block [0x828C8E80..0x828C8EB4)
	// 828C8E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8E84: 483E0561  bl 0x82ca93e4
	ctx.lr = 0x828C8E88;
	sub_82CA93D0(ctx, base);
	// 828C8E88: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8E8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8E90: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828C8E94: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 828C8E98: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828C8E9C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C8EA0: 83BF0010  lwz r29, 0x10(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C8EA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8EA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C8EAC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828C8EB0: 419A0020  beq cr6, 0x828c8ed0
	if ctx.cr[6].eq {
	pc = 0x828C8ED0; continue 'dispatch;
	}
	pc = 0x828C8EB4; continue 'dispatch;
            }
            0x828C8EB4 => {
    //   block [0x828C8EB4..0x828C8ED0)
	// 828C8EB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8EB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8EBC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8EC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8EC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8EC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8ECC: 4082FFE8  bne 0x828c8eb4
	if !ctx.cr[0].eq {
	pc = 0x828C8EB4; continue 'dispatch;
	}
	pc = 0x828C8ED0; continue 'dispatch;
            }
            0x828C8ED0 => {
    //   block [0x828C8ED0..0x828C8F1C)
	// 828C8ED0: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 828C8ED4: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8ED8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C8EDC: 4B9B49CD  bl 0x8227d8a8
	ctx.lr = 0x828C8EE0;
	sub_8227D8A8(ctx, base);
	// 828C8EE0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C8EE4: 817C0068  lwz r11, 0x68(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) } as u64;
	// 828C8EE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C8EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8EF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C8EF4: 4E800421  bctrl
	ctx.lr = 0x828C8EF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C8EF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8EFC: 4B8EEC1D  bl 0x821b7b18
	ctx.lr = 0x828C8F00;
	sub_821B7B18(ctx, base);
	// 828C8F00: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C8F04: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C8F08: 3A9F0008  addi r20, r31, 8
	ctx.r[20].s64 = ctx.r[31].s64 + 8;
	// 828C8F0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8F10: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828C8F14: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 828C8F18: 419A0020  beq cr6, 0x828c8f38
	if ctx.cr[6].eq {
	pc = 0x828C8F38; continue 'dispatch;
	}
            }
            0x828C8F1C => {
    //   block [0x828C8F1C..0x828C8F38)
	// 828C8F1C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8F20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8F24: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8F28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8F2C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8F30: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8F34: 4082FFE8  bne 0x828c8f1c
	if !ctx.cr[0].eq {
	pc = 0x828C8F1C; continue 'dispatch;
	}
	pc = 0x828C8F38; continue 'dispatch;
            }
            0x828C8F38 => {
    //   block [0x828C8F38..0x828C8F50)
	// 828C8F38: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8F3C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8F44: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C8F48: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828C8F4C: 419A0020  beq cr6, 0x828c8f6c
	if ctx.cr[6].eq {
	pc = 0x828C8F6C; continue 'dispatch;
	}
	pc = 0x828C8F50; continue 'dispatch;
            }
            0x828C8F50 => {
    //   block [0x828C8F50..0x828C8F6C)
	// 828C8F50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8F54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8F58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8F5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8F60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8F64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8F68: 4082FFE8  bne 0x828c8f50
	if !ctx.cr[0].eq {
	pc = 0x828C8F50; continue 'dispatch;
	}
	pc = 0x828C8F6C; continue 'dispatch;
            }
            0x828C8F6C => {
    //   block [0x828C8F6C..0x828C8FEC)
	// 828C8F6C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 828C8F70: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 828C8F74: 4849DCDD  bl 0x82d66c50
	ctx.lr = 0x828C8F78;
	sub_82D66C50(ctx, base);
	// 828C8F78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8F7C: 4B8EEB9D  bl 0x821b7b18
	ctx.lr = 0x828C8F80;
	sub_821B7B18(ctx, base);
	// 828C8F80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C8F84: 4B8EEB95  bl 0x821b7b18
	ctx.lr = 0x828C8F88;
	sub_821B7B18(ctx, base);
	// 828C8F88: E87F0028  ld r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	// 828C8F8C: 4BFFF5ED  bl 0x828c8578
	ctx.lr = 0x828C8F90;
	sub_828C8578(ctx, base);
	// 828C8F90: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C8F94: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8F98: 3AA00030  li r21, 0x30
	ctx.r[21].s64 = 48;
	// 828C8F9C: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 828C8FA0: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 828C8FA4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828C8FA8: 7D2AABD7  divw. r9, r10, r21
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[21].s32;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C8FAC: 4182015C  beq 0x828c9108
	if ctx.cr[0].eq {
	pc = 0x828C9108; continue 'dispatch;
	}
	// 828C8FB0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C8FB4: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 828C8FB8: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 828C8FBC: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 828C8FC0: 3B400020  li r26, 0x20
	ctx.r[26].s64 = 32;
	// 828C8FC4: 81730004  lwz r11, 4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8FC8: 7C98582E  lwzx r4, r24, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C8FCC: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 828C8FD0: 419A009C  beq cr6, 0x828c906c
	if ctx.cr[6].eq {
	pc = 0x828C906C; continue 'dispatch;
	}
	// 828C8FD4: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8FD8: 80740000  lwz r3, 0(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8FDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8FE0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828C8FE4: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 828C8FE8: 419A0020  beq cr6, 0x828c9008
	if ctx.cr[6].eq {
	pc = 0x828C9008; continue 'dispatch;
	}
	pc = 0x828C8FEC; continue 'dispatch;
            }
            0x828C8FEC => {
    //   block [0x828C8FEC..0x828C9008)
	// 828C8FEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8FF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8FF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8FF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8FFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C9000: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C9004: 4082FFE8  bne 0x828c8fec
	if !ctx.cr[0].eq {
	pc = 0x828C8FEC; continue 'dispatch;
	}
	pc = 0x828C9008; continue 'dispatch;
            }
            0x828C9008 => {
    //   block [0x828C9008..0x828C9034)
	// 828C9008: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 828C900C: 7D4B20AE  lbzx r10, r11, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 828C9010: 554907BC  rlwinm r9, r10, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C9014: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C9018: 409A001C  bne cr6, 0x828c9034
	if !ctx.cr[6].eq {
	pc = 0x828C9034; continue 'dispatch;
	}
	// 828C901C: 548A083C  slwi r10, r4, 1
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C9020: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C9024: 7D445214  add r10, r4, r10
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 828C9028: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C902C: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828C9030: 4800000C  b 0x828c903c
	pc = 0x828C903C; continue 'dispatch;
            }
            0x828C9034 => {
    //   block [0x828C9034..0x828C903C)
	// 828C9034: 4849A9AD  bl 0x82d639e0
	ctx.lr = 0x828C9038;
	sub_82D639E0(ctx, base);
	// 828C9038: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x828C903C; continue 'dispatch;
            }
            0x828C903C => {
    //   block [0x828C903C..0x828C906C)
	// 828C903C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C9040: 4B8EEAD9  bl 0x821b7b18
	ctx.lr = 0x828C9044;
	sub_821B7B18(ctx, base);
	// 828C9044: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9048: E93F0010  ld r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 828C904C: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 828C9050: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 828C9054: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 828C9058: E91F0018  ld r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 828C905C: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	pc = 0x828C906C; continue 'dispatch;
            }
            0x828C906C => {
    //   block [0x828C906C..0x828C9108)
	// 828C906C: 8176002C  lwz r11, 0x2c(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(44 as u32) ) } as u64;
	// 828C9070: 7D6BB82E  lwzx r11, r11, r23
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 828C9074: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 828C9078: 419A0068  beq cr6, 0x828c90e0
	if ctx.cr[6].eq {
	pc = 0x828C90E0; continue 'dispatch;
	}
	// 828C907C: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C9080: 81560090  lwz r10, 0x90(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C9084: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C9088: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828C908C: 7FEAEA14  add r31, r10, r29
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 828C9090: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828C9094: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	pc = 0x828C9108; continue 'dispatch;
            }
            0x828C9108 => {
    //   block [0x828C9108..0x828C9110)
	// 828C9108: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 828C910C: 483E0328  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C9110 size=80
    let mut pc: u32 = 0x828C9110;
    'dispatch: loop {
        match pc {
            0x828C9110 => {
    //   block [0x828C9110..0x828C9148)
	// 828C9110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C9118: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C911C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C9120: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C9124: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C9128: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C912C: 48000035  bl 0x828c9160
	ctx.lr = 0x828C9130;
	sub_828C9160(ctx, base);
	// 828C9130: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828C9134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C913C: 419A000C  beq cr6, 0x828c9148
	if ctx.cr[6].eq {
	pc = 0x828C9148; continue 'dispatch;
	}
	// 828C9140: 4B952BF9  bl 0x8221bd38
	ctx.lr = 0x828C9144;
	sub_8221BD38(ctx, base);
	// 828C9144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x828C9148; continue 'dispatch;
            }
            0x828C9148 => {
    //   block [0x828C9148..0x828C9160)
	// 828C9148: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C914C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C9150: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C9154: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C9158: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C915C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C9160 size=332
    let mut pc: u32 = 0x828C9160;
    'dispatch: loop {
        match pc {
            0x828C9160 => {
    //   block [0x828C9160..0x828C91D4)
	// 828C9160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9164: 483E02A1  bl 0x82ca9404
	ctx.lr = 0x828C9168;
	sub_82CA93D0(ctx, base);
	// 828C9168: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C916C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C9170: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C9174: 3BDD0098  addi r30, r29, 0x98
	ctx.r[30].s64 = ctx.r[29].s64 + 152;
	// 828C9178: 394B6418  addi r10, r11, 0x6418
	ctx.r[10].s64 = ctx.r[11].s64 + 25624;
	// 828C917C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C9180: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C9184: 4B8EE995  bl 0x821b7b18
	ctx.lr = 0x828C9188;
	sub_821B7B18(ctx, base);
	// 828C9188: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828C918C: 937D0098  stw r27, 0x98(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(152 as u32), ctx.r[27].u32 ) };
	// 828C9190: 807D0094  lwz r3, 0x94(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 828C9194: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C9198: 419A003C  beq cr6, 0x828c91d4
	if ctx.cr[6].eq {
	pc = 0x828C91D4; continue 'dispatch;
	}
	// 828C919C: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C91A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C91A4: 419A0030  beq cr6, 0x828c91d4
	if ctx.cr[6].eq {
	pc = 0x828C91D4; continue 'dispatch;
	}
	// 828C91A8: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C91AC: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C91B0: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C91B4: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C91B8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C91BC: 409A0018  bne cr6, 0x828c91d4
	if !ctx.cr[6].eq {
	pc = 0x828C91D4; continue 'dispatch;
	}
	// 828C91C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C91C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C91C8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C91CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C91D0: 4E800421  bctrl
	ctx.lr = 0x828C91D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C91D4 => {
    //   block [0x828C91D4..0x828C91EC)
	// 828C91D4: 815D0050  lwz r10, 0x50(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C91D8: 3B9D0048  addi r28, r29, 0x48
	ctx.r[28].s64 = ctx.r[29].s64 + 72;
	// 828C91DC: 817D004C  lwz r11, 0x4c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 828C91E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C91E4: 40990008  ble cr6, 0x828c91ec
	if !ctx.cr[6].gt {
	pc = 0x828C91EC; continue 'dispatch;
	}
	// 828C91E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C91EC; continue 'dispatch;
            }
            0x828C91EC => {
    //   block [0x828C91EC..0x828C9200)
	// 828C91EC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C91F0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C91F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C91F8: 40990008  ble cr6, 0x828c9200
	if !ctx.cr[6].gt {
	pc = 0x828C9200; continue 'dispatch;
	}
	// 828C91FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C9200; continue 'dispatch;
            }
            0x828C9200 => {
    //   block [0x828C9200..0x828C9234)
	// 828C9200: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C9204: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828C9208: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C920C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828C9210: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C9214: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C9218: 480020E1  bl 0x828cb2f8
	ctx.lr = 0x828C921C;
	sub_828CB2F8(ctx, base);
	// 828C921C: 815D0040  lwz r10, 0x40(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C9220: 3BFD0038  addi r31, r29, 0x38
	ctx.r[31].s64 = ctx.r[29].s64 + 56;
	// 828C9224: 817D003C  lwz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 828C9228: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C922C: 40990008  ble cr6, 0x828c9234
	if !ctx.cr[6].gt {
	pc = 0x828C9234; continue 'dispatch;
	}
	// 828C9230: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C9234; continue 'dispatch;
            }
            0x828C9234 => {
    //   block [0x828C9234..0x828C9248)
	// 828C9234: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828C9238: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C923C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828C9240: 40990008  ble cr6, 0x828c9248
	if !ctx.cr[6].gt {
	pc = 0x828C9248; continue 'dispatch;
	}
	// 828C9244: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C9248; continue 'dispatch;
            }
            0x828C9248 => {
    //   block [0x828C9248..0x828C9280)
	// 828C9248: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C924C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C9250: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C9254: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C9258: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C925C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C9260: 4BF2F629  bl 0x827f8888
	ctx.lr = 0x828C9264;
	sub_827F8888(ctx, base);
	// 828C9264: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C9268: 4B8EE8B1  bl 0x821b7b18
	ctx.lr = 0x828C926C;
	sub_821B7B18(ctx, base);
	// 828C926C: 807D0088  lwz r3, 0x88(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(136 as u32) ) } as u64;
	// 828C9270: 3BDD0084  addi r30, r29, 0x84
	ctx.r[30].s64 = ctx.r[29].s64 + 132;
	// 828C9274: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C9278: 419A0008  beq cr6, 0x828c9280
	if ctx.cr[6].eq {
	pc = 0x828C9280; continue 'dispatch;
	}
	// 828C927C: 4B952ABD  bl 0x8221bd38
	ctx.lr = 0x828C9280;
	sub_8221BD38(ctx, base);
	pc = 0x828C9280; continue 'dispatch;
            }
            0x828C9280 => {
    //   block [0x828C9280..0x828C92AC)
	// 828C9280: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828C9284: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C9288: 937E0008  stw r27, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828C928C: 937E000C  stw r27, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 828C9290: 4BB13599  bl 0x823dc828
	ctx.lr = 0x828C9294;
	sub_823DC828(ctx, base);
	// 828C9294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9298: 4BB13591  bl 0x823dc828
	ctx.lr = 0x828C929C;
	sub_823DC828(ctx, base);
	// 828C929C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C92A0: 4BFFF691  bl 0x828c8930
	ctx.lr = 0x828C92A4;
	sub_828C8930(ctx, base);
	// 828C92A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C92A8: 483E01AC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C92B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C92B0 size=3340
    let mut pc: u32 = 0x828C92B0;
    'dispatch: loop {
        match pc {
            0x828C92B0 => {
    //   block [0x828C92B0..0x828C936C)
	// 828C92B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C92B4: 483E011D  bl 0x82ca93d0
	ctx.lr = 0x828C92B8;
	sub_82CA93D0(ctx, base);
	// 828C92B8: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C92BC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 828C92C0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828C92C4: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 828C92C8: 7D364B78  mr r22, r9
	ctx.r[22].u64 = ctx.r[9].u64;
	// 828C92CC: 93410284  stw r26, 0x284(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(644 as u32), ctx.r[26].u32 ) };
	// 828C92D0: 386BB078  addi r3, r11, -0x4f88
	ctx.r[3].s64 = ctx.r[11].s64 + -20360;
	// 828C92D4: 92E10294  stw r23, 0x294(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(660 as u32), ctx.r[23].u32 ) };
	// 828C92D8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828C92DC: 92C102B4  stw r22, 0x2b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(692 as u32), ctx.r[22].u32 ) };
	// 828C92E0: 7CD33378  mr r19, r6
	ctx.r[19].u64 = ctx.r[6].u64;
	// 828C92E4: 7CF13B78  mr r17, r7
	ctx.r[17].u64 = ctx.r[7].u64;
	// 828C92E8: 7D124378  mr r18, r8
	ctx.r[18].u64 = ctx.r[8].u64;
	// 828C92EC: 4848C465  bl 0x82d55750
	ctx.lr = 0x828C92F0;
	sub_82D55750(ctx, base);
	// 828C92F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C92F4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C92F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C92FC: 484A81DD  bl 0x82d714d8
	ctx.lr = 0x828C9300;
	sub_82D714D8(ctx, base);
	// 828C9300: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C9304: 419A0CB0  beq cr6, 0x828c9fb4
	if ctx.cr[6].eq {
	pc = 0x828C9FB4; continue 'dispatch;
	}
	// 828C9308: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C930C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9310: 419A0CA4  beq cr6, 0x828c9fb4
	if ctx.cr[6].eq {
	pc = 0x828C9FB4; continue 'dispatch;
	}
	// 828C9314: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C9318: 39C00000  li r14, 0
	ctx.r[14].s64 = 0;
	// 828C931C: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 828C9320: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 828C9324: 910100A8  stw r8, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 828C9328: 908100A0  stw r4, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u32 ) };
	// 828C932C: 81EB0000  lwz r15, 0(r11)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9330: 3BEF0008  addi r31, r15, 8
	ctx.r[31].s64 = ctx.r[15].s64 + 8;
	// 828C9334: 83CF000C  lwz r30, 0xc(r15)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C9338: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828C933C: 40990030  ble cr6, 0x828c936c
	if !ctx.cr[6].gt {
	pc = 0x828C936C; continue 'dispatch;
	}
	// 828C9340: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9344: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 828C9348: 57C4103A  slwi r4, r30, 2
	ctx.r[4].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828C934C: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 828C9350: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C9354: 4848BEF5  bl 0x82d55248
	ctx.lr = 0x828C9358;
	sub_82D55248(ctx, base);
	// 828C9358: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C935C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9360: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 828C9364: 908100A0  stw r4, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u32 ) };
	// 828C9368: 910100A8  stw r8, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	pc = 0x828C936C; continue 'dispatch;
            }
            0x828C936C => {
    //   block [0x828C936C..0x828C9388)
	// 828C936C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9370: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828C9374: 93C100A4  stw r30, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 828C9378: 40990028  ble cr6, 0x828c93a0
	if !ctx.cr[6].gt {
	pc = 0x828C93A0; continue 'dispatch;
	}
	// 828C937C: 7D245050  subf r9, r4, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 828C9380: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828C9384: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x828C9388; continue 'dispatch;
            }
            0x828C9388 => {
    //   block [0x828C9388..0x828C93A0)
	// 828C9388: 7CE9582E  lwzx r7, r9, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C938C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C9390: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828C9394: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C9398: 4082FFF0  bne 0x828c9388
	if !ctx.cr[0].eq {
	pc = 0x828C9388; continue 'dispatch;
	}
	// 828C939C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	pc = 0x828C93A0; continue 'dispatch;
            }
            0x828C93A0 => {
    //   block [0x828C93A0..0x828C93D0)
	// 828C93A0: 409A0030  bne cr6, 0x828c93d0
	if !ctx.cr[6].eq {
	pc = 0x828C93D0; continue 'dispatch;
	}
	// 828C93A4: 550B0000  rlwinm r11, r8, 0, 0, 0
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 828C93A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C93AC: 409A0C08  bne cr6, 0x828c9fb4
	if !ctx.cr[6].eq {
	pc = 0x828C9FB4; continue 'dispatch;
	}
	// 828C93B0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C93B4: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 828C93B8: 5505103A  slwi r5, r8, 2
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 828C93BC: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 828C93C0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C93C4: 4848BF05  bl 0x82d552c8
	ctx.lr = 0x828C93C8;
	sub_82D552C8(ctx, base);
	// 828C93C8: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 828C93CC: 483E0054  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            0x828C93D0 => {
    //   block [0x828C93D0..0x828C94BC)
	// 828C93D0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 828C93D4: 3BAB79E4  addi r29, r11, 0x79e4
	ctx.r[29].s64 = ctx.r[11].s64 + 31204;
	// 828C93D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C93DC: 4848C375  bl 0x82d55750
	ctx.lr = 0x828C93E0;
	sub_82D55750(ctx, base);
	// 828C93E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C93E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C93E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C93EC: 484A80ED  bl 0x82d714d8
	ctx.lr = 0x828C93F0;
	sub_82D714D8(ctx, base);
	// 828C93F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C93F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C93F8: 4848C359  bl 0x82d55750
	ctx.lr = 0x828C93FC;
	sub_82D55750(ctx, base);
	// 828C93FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9400: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C9404: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C9408: 484A80D1  bl 0x82d714d8
	ctx.lr = 0x828C940C;
	sub_82D714D8(ctx, base);
	// 828C940C: 830D0000  lwz r24, 0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9410: 3B200004  li r25, 4
	ctx.r[25].s64 = 4;
	// 828C9414: 82030008  lwz r16, 8(r3)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C9418: 38A0003A  li r5, 0x3a
	ctx.r[5].s64 = 58;
	// 828C941C: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 828C9420: 3BA30008  addi r29, r3, 8
	ctx.r[29].s64 = ctx.r[3].s64 + 8;
	// 828C9424: 93010078  stw r24, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[24].u32 ) };
	// 828C9428: 7C79C02E  lwzx r3, r25, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 828C942C: 4848BE1D  bl 0x82d55248
	ctx.lr = 0x828C9430;
	sub_82D55248(ctx, base);
	// 828C9430: 3B800038  li r28, 0x38
	ctx.r[28].s64 = 56;
	// 828C9434: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 828C9438: B3830004  sth r28, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u16 ) };
	// 828C943C: 4849D87D  bl 0x82d66cb8
	ctx.lr = 0x828C9440;
	sub_82D66CB8(ctx, base);
	// 828C9440: 7D59C02E  lwzx r10, r25, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 828C9444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C9448: 38A0003A  li r5, 0x3a
	ctx.r[5].s64 = 58;
	// 828C944C: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 828C9450: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828C9454: 4848BDF5  bl 0x82d55248
	ctx.lr = 0x828C9458;
	sub_82D55248(ctx, base);
	// 828C9458: B3830004  sth r28, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u16 ) };
	// 828C945C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C9460: 4849D859  bl 0x82d66cb8
	ctx.lr = 0x828C9464;
	sub_82D66CB8(ctx, base);
	// 828C9464: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C9468: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C946C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C9470: 4BFFF769  bl 0x828c8bd8
	ctx.lr = 0x828C9474;
	sub_828C8BD8(ctx, base);
	// 828C9474: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C9478: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C947C: 4BFFF7FD  bl 0x828c8c78
	ctx.lr = 0x828C9480;
	sub_828C8C78(ctx, base);
	// 828C9480: A13F0004  lhz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9484: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C9488: 419A0034  beq cr6, 0x828c94bc
	if ctx.cr[6].eq {
	pc = 0x828C94BC; continue 'dispatch;
	}
	// 828C948C: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C9490: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C9494: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C9498: B13F0006  sth r9, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C949C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C94A0: 409A001C  bne cr6, 0x828c94bc
	if !ctx.cr[6].eq {
	pc = 0x828C94BC; continue 'dispatch;
	}
	// 828C94A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C94A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C94AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C94B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C94B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C94B8: 4E800421  bctrl
	ctx.lr = 0x828C94BC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C94BC => {
    //   block [0x828C94BC..0x828C94F8)
	// 828C94BC: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C94C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C94C4: 419A0034  beq cr6, 0x828c94f8
	if ctx.cr[6].eq {
	pc = 0x828C94F8; continue 'dispatch;
	}
	// 828C94C8: A17D0006  lhz r11, 6(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C94CC: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C94D0: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C94D4: B13D0006  sth r9, 6(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C94D8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C94DC: 409A001C  bne cr6, 0x828c94f8
	if !ctx.cr[6].eq {
	pc = 0x828C94F8; continue 'dispatch;
	}
	// 828C94E0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C94E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C94E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C94EC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C94F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C94F4: 4E800421  bctrl
	ctx.lr = 0x828C94F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C94F8 => {
    //   block [0x828C94F8..0x828C9580)
	// 828C94F8: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 828C94FC: 7E489378  mr r8, r18
	ctx.r[8].u64 = ctx.r[18].u64;
	// 828C9500: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 828C9504: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 828C9508: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 828C950C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C9510: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C9514: 4BFFF51D  bl 0x828c8a30
	ctx.lr = 0x828C9518;
	sub_828C8A30(ctx, base);
	// 828C9518: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828C951C: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828C9520: 386B3220  addi r3, r11, 0x3220
	ctx.r[3].s64 = ctx.r[11].s64 + 12832;
	// 828C9524: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828C9528: 3BFA0080  addi r31, r26, 0x80
	ctx.r[31].s64 = ctx.r[26].s64 + 128;
	// 828C952C: 4B92A82D  bl 0x821f3d58
	ctx.lr = 0x828C9530;
	sub_821F3D58(ctx, base);
	// 828C9530: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9534: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828C9538: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C953C: 48136E75  bl 0x82a003b0
	ctx.lr = 0x828C9540;
	sub_82A003B0(ctx, base);
	// 828C9540: 91C100B4  stw r14, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[14].u32 ) };
	// 828C9544: 91C100B8  stw r14, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[14].u32 ) };
	// 828C9548: 3A9A0038  addi r20, r26, 0x38
	ctx.r[20].s64 = ctx.r[26].s64 + 56;
	// 828C954C: 91C100BC  stw r14, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[14].u32 ) };
	// 828C9550: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C9554: 91C10050  stw r14, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[14].u32 ) };
	// 828C9558: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C955C: 91C10054  stw r14, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[14].u32 ) };
	// 828C9560: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 828C9564: 48001C6D  bl 0x828cb1d0
	ctx.lr = 0x828C9568;
	sub_828CB1D0(ctx, base);
	// 828C9568: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 828C956C: 4B955CED  bl 0x8221f258
	ctx.lr = 0x828C9570;
	sub_8221F258(ctx, base);
	// 828C9570: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C9574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9578: 419A0008  beq cr6, 0x828c9580
	if ctx.cr[6].eq {
	pc = 0x828C9580; continue 'dispatch;
	}
	// 828C957C: 91CB0000  stw r14, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[14].u32 ) };
	pc = 0x828C9580; continue 'dispatch;
            }
            0x828C9580 => {
    //   block [0x828C9580..0x828C958C)
	// 828C9580: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C9584: 41820008  beq 0x828c958c
	if ctx.cr[0].eq {
	pc = 0x828C958C; continue 'dispatch;
	}
	// 828C9588: 91CA0000  stw r14, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[14].u32 ) };
	pc = 0x828C958C; continue 'dispatch;
            }
            0x828C958C => {
    //   block [0x828C958C..0x828C9598)
	// 828C958C: 354B0008  addic. r10, r11, 8
	ctx.xer.ca = (ctx.r[11].u32 > (!(8 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C9590: 41820008  beq 0x828c9598
	if ctx.cr[0].eq {
	pc = 0x828C9598; continue 'dispatch;
	}
	// 828C9594: 91CA0000  stw r14, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[14].u32 ) };
	pc = 0x828C9598; continue 'dispatch;
            }
            0x828C9598 => {
    //   block [0x828C9598..0x828C9624)
	// 828C9598: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C959C: 99CB0015  stb r14, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[14].u8 ) };
	// 828C95A0: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 828C95A4: 7C79C02E  lwzx r3, r25, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 828C95A8: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 828C95AC: 57C4103A  slwi r4, r30, 2
	ctx.r[4].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828C95B0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828C95B4: 994B0015  stb r10, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 828C95B8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C95BC: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C95C0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C95C4: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C95C8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C95CC: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C95D0: 91C10060  stw r14, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[14].u32 ) };
	// 828C95D4: 4848BC75  bl 0x82d55248
	ctx.lr = 0x828C95D8;
	sub_82D55248(ctx, base);
	// 828C95D8: 90610090  stw r3, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 828C95DC: 93C10094  stw r30, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 828C95E0: 3ADA0084  addi r22, r26, 0x84
	ctx.r[22].s64 = ctx.r[26].s64 + 132;
	// 828C95E4: 93C10098  stw r30, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 828C95E8: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 828C95EC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 828C95F0: 80900010  lwz r4, 0x10(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C95F4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828C95F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C95FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828C9600: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C9604: 48001DED  bl 0x828cb3f0
	ctx.lr = 0x828C9608;
	sub_828CB3F0(ctx, base);
	// 828C9608: 81300010  lwz r9, 0x10(r16)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C960C: 7DDA7378  mr r26, r14
	ctx.r[26].u64 = ctx.r[14].u64;
	// 828C9610: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C9614: 419A01F8  beq cr6, 0x828c980c
	if ctx.cr[6].eq {
	pc = 0x828C980C; continue 'dispatch;
	}
	// 828C9618: 56353032  slwi r21, r17, 6
	ctx.r[21].u32 = ctx.r[17].u32.wrapping_shl(6);
	ctx.r[21].u64 = ctx.r[21].u32 as u64;
	// 828C961C: 7DD87378  mr r24, r14
	ctx.r[24].u64 = ctx.r[14].u64;
	// 828C9620: 7DD77378  mr r23, r14
	ctx.r[23].u64 = ctx.r[14].u64;
	pc = 0x828C9624; continue 'dispatch;
            }
            0x828C9624 => {
    //   block [0x828C9624..0x828C965C)
	// 828C9624: 8170000C  lwz r11, 0xc(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C9628: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828C962C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C9630: 7D57582E  lwzx r10, r23, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C9634: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9638: 4B963899  bl 0x8222ced0
	ctx.lr = 0x828C963C;
	sub_8222CED0(ctx, base);
	// 828C963C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C9640: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828C9644: 4BFFEDF5  bl 0x828c8438
	ctx.lr = 0x828C9648;
	sub_828C8438(ctx, base);
	// 828C9648: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C964C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828C9650: 409A000C  bne cr6, 0x828c965c
	if !ctx.cr[6].eq {
	pc = 0x828C965C; continue 'dispatch;
	}
	// 828C9654: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 828C9658: 7F6BB82E  lwzx r27, r11, r23
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	pc = 0x828C965C; continue 'dispatch;
            }
            0x828C965C => {
    //   block [0x828C965C..0x828C96C4)
	// 828C965C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828C9660: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828C9664: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828C9668: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 828C966C: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 828C9670: 7E7F9B78  mr r31, r19
	ctx.r[31].u64 = ctx.r[19].u64;
	// 828C9674: 7E599378  mr r25, r18
	ctx.r[25].u64 = ctx.r[18].u64;
	// 828C9678: 4BFFEC89  bl 0x828c8300
	ctx.lr = 0x828C967C;
	sub_828C8300(ctx, base);
	// 828C967C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828C9680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9684: 419A0040  beq cr6, 0x828c96c4
	if ctx.cr[6].eq {
	pc = 0x828C96C4; continue 'dispatch;
	}
	// 828C9688: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C968C: 809B0070  lwz r4, 0x70(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C9690: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 828C9694: 3BE00007  li r31, 7
	ctx.r[31].s64 = 7;
	// 828C9698: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 828C969C: 4849B575  bl 0x82d64c10
	ctx.lr = 0x828C96A0;
	sub_82D64C10(ctx, base);
	// 828C96A0: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 828C96A4: 81500004  lwz r10, 4(r16)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C96A8: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828C96AC: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 828C96B0: 7D09522E  lhzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828C96B4: 7D0B0734  extsh r11, r8
	ctx.r[11].s64 = ctx.r[8].s16 as i64;
	// 828C96B8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 828C96BC: 419A0008  beq cr6, 0x828c96c4
	if ctx.cr[6].eq {
	pc = 0x828C96C4; continue 'dispatch;
	}
	// 828C96C0: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	pc = 0x828C96C4; continue 'dispatch;
            }
            0x828C96C4 => {
    //   block [0x828C96C4..0x828C9708)
	// 828C96C4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C96C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C96CC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C96D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C96D4: 4E800421  bctrl
	ctx.lr = 0x828C96D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C96D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C96DC: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828C96E0: 4B955B79  bl 0x8221f258
	ctx.lr = 0x828C96E4;
	sub_8221F258(ctx, base);
	// 828C96E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C96E8: 419A0020  beq cr6, 0x828c9708
	if ctx.cr[6].eq {
	pc = 0x828C9708; continue 'dispatch;
	}
	// 828C96EC: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828C96F0: 7E268B78  mr r6, r17
	ctx.r[6].u64 = ctx.r[17].u64;
	// 828C96F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C96F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C96FC: 4BD93D65  bl 0x8265d460
	ctx.lr = 0x828C9700;
	sub_8265D460(ctx, base);
	// 828C9700: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9704: 48000008  b 0x828c970c
	pc = 0x828C970C; continue 'dispatch;
            }
            0x828C9708 => {
    //   block [0x828C9708..0x828C970C)
	// 828C9708: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	pc = 0x828C970C; continue 'dispatch;
            }
            0x828C970C => {
    //   block [0x828C970C..0x828C972C)
	// 828C970C: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9714: 419A0018  beq cr6, 0x828c972c
	if ctx.cr[6].eq {
	pc = 0x828C972C; continue 'dispatch;
	}
	// 828C9718: 81540008  lwz r10, 8(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C971C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828C9720: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828C9724: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C9728: 41980008  blt cr6, 0x828c9730
	if ctx.cr[6].lt {
	pc = 0x828C9730; continue 'dispatch;
	}
	pc = 0x828C972C; continue 'dispatch;
            }
            0x828C972C => {
    //   block [0x828C972C..0x828C9730)
	// 828C972C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C9730; continue 'dispatch;
            }
            0x828C9730 => {
    //   block [0x828C9730..0x828C9748)
	// 828C9730: 7C6BC214  add r3, r11, r24
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 828C9734: 4B9A9925  bl 0x82273058
	ctx.lr = 0x828C9738;
	sub_82273058(ctx, base);
	// 828C9738: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828C973C: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 828C9740: 41990008  bgt cr6, 0x828c9748
	if ctx.cr[6].gt {
	pc = 0x828C9748; continue 'dispatch;
	}
	// 828C9744: 7DC87378  mr r8, r14
	ctx.r[8].u64 = ctx.r[14].u64;
	pc = 0x828C9748; continue 'dispatch;
            }
            0x828C9748 => {
    //   block [0x828C9748..0x828C9758)
	// 828C9748: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828C974C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 828C9750: 41990008  bgt cr6, 0x828c9758
	if ctx.cr[6].gt {
	pc = 0x828C9758; continue 'dispatch;
	}
	// 828C9754: 7DCA7378  mr r10, r14
	ctx.r[10].u64 = ctx.r[14].u64;
	pc = 0x828C9758; continue 'dispatch;
            }
            0x828C9758 => {
    //   block [0x828C9758..0x828C9778)
	// 828C9758: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C975C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9760: 419A0018  beq cr6, 0x828c9778
	if ctx.cr[6].eq {
	pc = 0x828C9778; continue 'dispatch;
	}
	// 828C9764: 81340008  lwz r9, 8(r20)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C9768: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 828C976C: 7CE91E70  srawi r9, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 828C9770: 7F1A4840  cmplw cr6, r26, r9
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C9774: 41980008  blt cr6, 0x828c977c
	if ctx.cr[6].lt {
	pc = 0x828C977C; continue 'dispatch;
	}
	pc = 0x828C9778; continue 'dispatch;
            }
            0x828C9778 => {
    //   block [0x828C9778..0x828C977C)
	// 828C9778: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C977C; continue 'dispatch;
            }
            0x828C977C => {
    //   block [0x828C977C..0x828C97D8)
	// 828C977C: 7EA94378  or r9, r21, r8
	ctx.r[9].u64 = ctx.r[21].u64 | ctx.r[8].u64;
	// 828C9780: 7C6BC02E  lwzx r3, r11, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 828C9784: 55282834  slwi r8, r9, 5
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828C9788: 7D075378  or r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 | ctx.r[10].u64;
	// 828C978C: 54E62834  slwi r6, r7, 5
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(5);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828C9790: 7CC4FB78  or r4, r6, r31
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[31].u64;
	// 828C9794: 4BF89B25  bl 0x828532b8
	ctx.lr = 0x828C9798;
	sub_828532B8(ctx, base);
	// 828C9798: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 828C979C: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 828C97A0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828C97A4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C97A8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828C97AC: 4BAA134D  bl 0x8236aaf8
	ctx.lr = 0x828C97B0;
	sub_8236AAF8(ctx, base);
	// 828C97B0: 80A10090  lwz r5, 0x90(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C97B4: 7FC5B92E  stwx r30, r5, r23
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[23].u32), ctx.r[30].u32) };
	// 828C97B8: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C97BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C97C0: 419A0018  beq cr6, 0x828c97d8
	if ctx.cr[6].eq {
	pc = 0x828C97D8; continue 'dispatch;
	}
	// 828C97C4: 81560008  lwz r10, 8(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C97C8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828C97CC: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828C97D0: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C97D4: 41980008  blt cr6, 0x828c97dc
	if ctx.cr[6].lt {
	pc = 0x828C97DC; continue 'dispatch;
	}
	pc = 0x828C97D8; continue 'dispatch;
            }
            0x828C97D8 => {
    //   block [0x828C97D8..0x828C97DC)
	// 828C97D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C97DC; continue 'dispatch;
            }
            0x828C97DC => {
    //   block [0x828C97DC..0x828C980C)
	// 828C97DC: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 828C97E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C97E4: 9321006C  stw r25, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 828C97E8: E9410068  ld r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828C97EC: 7D4BC12A  stdx r10, r11, r24
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32), ctx.r[10].u64) };
	// 828C97F0: 4B94B5E9  bl 0x82214dd8
	ctx.lr = 0x828C97F4;
	sub_82214DD8(ctx, base);
	// 828C97F4: 81300010  lwz r9, 0x10(r16)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C97F8: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 828C97FC: 3AF70004  addi r23, r23, 4
	ctx.r[23].s64 = ctx.r[23].s64 + 4;
	// 828C9800: 3B180008  addi r24, r24, 8
	ctx.r[24].s64 = ctx.r[24].s64 + 8;
	// 828C9804: 7F1A4840  cmplw cr6, r26, r9
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C9808: 409AFE1C  bne cr6, 0x828c9624
	if !ctx.cr[6].eq {
	pc = 0x828C9624; continue 'dispatch;
	}
	pc = 0x828C980C; continue 'dispatch;
            }
            0x828C980C => {
    //   block [0x828C980C..0x828C9848)
	// 828C980C: 836F0018  lwz r27, 0x18(r15)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C9810: 3BEF0014  addi r31, r15, 0x14
	ctx.r[31].s64 = ctx.r[15].s64 + 20;
	// 828C9814: 7DD47378  mr r20, r14
	ctx.r[20].u64 = ctx.r[14].u64;
	// 828C9818: 3E408000  lis r18, -0x8000
	ctx.r[18].s64 = -2147483648;
	// 828C981C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 828C9820: 40990028  ble cr6, 0x828c9848
	if !ctx.cr[6].gt {
	pc = 0x828C9848; continue 'dispatch;
	}
	// 828C9824: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C9828: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 828C982C: 5764103A  slwi r4, r27, 2
	ctx.r[4].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828C9830: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 828C9834: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828C9838: 4848BA11  bl 0x82d55248
	ctx.lr = 0x828C983C;
	sub_82D55248(ctx, base);
	// 828C983C: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9840: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 828C9844: 7F72DB78  mr r18, r27
	ctx.r[18].u64 = ctx.r[27].u64;
	pc = 0x828C9848; continue 'dispatch;
            }
            0x828C9848 => {
    //   block [0x828C9848..0x828C9860)
	// 828C9848: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C984C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 828C9850: 40990024  ble cr6, 0x828c9874
	if !ctx.cr[6].gt {
	pc = 0x828C9874; continue 'dispatch;
	}
	// 828C9854: 7D345050  subf r9, r20, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[20].s64;
	// 828C9858: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 828C985C: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	pc = 0x828C9860; continue 'dispatch;
            }
            0x828C9860 => {
    //   block [0x828C9860..0x828C9874)
	// 828C9860: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C9864: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C9868: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C986C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C9870: 4082FFF0  bne 0x828c9860
	if !ctx.cr[0].eq {
	pc = 0x828C9860; continue 'dispatch;
	}
	pc = 0x828C9874; continue 'dispatch;
            }
            0x828C9874 => {
    //   block [0x828C9874..0x828C98E4)
	// 828C9874: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C9878: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 828C987C: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 828C9880: 5764103A  slwi r4, r27, 2
	ctx.r[4].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828C9884: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828C9888: 4848B9C1  bl 0x82d55248
	ctx.lr = 0x828C988C;
	sub_82D55248(ctx, base);
	// 828C988C: 90610080  stw r3, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 828C9890: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 828C9894: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 828C9898: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C989C: 93610088  stw r27, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[27].u32 ) };
	// 828C98A0: 91C10068  stw r14, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[14].u32 ) };
	// 828C98A4: 91C1006C  stw r14, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[14].u32 ) };
	// 828C98A8: 81210284  lwz r9, 0x284(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(644 as u32) ) } as u64;
	// 828C98AC: 3AE90048  addi r23, r9, 0x48
	ctx.r[23].s64 = ctx.r[9].s64 + 72;
	// 828C98B0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828C98B4: 4BF2F7BD  bl 0x827f9070
	ctx.lr = 0x828C98B8;
	sub_827F9070(ctx, base);
	// 828C98B8: 7DD97378  mr r25, r14
	ctx.r[25].u64 = ctx.r[14].u64;
	// 828C98BC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828C98C0: 419A021C  beq cr6, 0x828c9adc
	if ctx.cr[6].eq {
	pc = 0x828C9ADC; continue 'dispatch;
	}
	// 828C98C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C98C8: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C98CC: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 828C98D0: 7DDA7378  mr r26, r14
	ctx.r[26].u64 = ctx.r[14].u64;
	// 828C98D4: 7DD87378  mr r24, r14
	ctx.r[24].u64 = ctx.r[14].u64;
	// 828C98D8: 3ACB0B7C  addi r22, r11, 0xb7c
	ctx.r[22].s64 = ctx.r[11].s64 + 2940;
	// 828C98DC: 3AAA1360  addi r21, r10, 0x1360
	ctx.r[21].s64 = ctx.r[10].s64 + 4960;
	// 828C98E0: 3A600001  li r19, 1
	ctx.r[19].s64 = 1;
	pc = 0x828C98E4; continue 'dispatch;
            }
            0x828C98E4 => {
    //   block [0x828C98E4..0x828C9928)
	// 828C98E4: 7FF4D02E  lwzx r31, r20, r26
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 828C98E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C98EC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C98F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C98F4: 7DDD7378  mr r29, r14
	ctx.r[29].u64 = ctx.r[14].u64;
	// 828C98F8: 7DDE7378  mr r30, r14
	ctx.r[30].u64 = ctx.r[14].u64;
	// 828C98FC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C9900: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C9904: 4BAABB7D  bl 0x82375480
	ctx.lr = 0x828C9908;
	sub_82375480(ctx, base);
	// 828C9908: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828C990C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 828C9910: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C9914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9918: 419A0010  beq cr6, 0x828c9928
	if ctx.cr[6].eq {
	pc = 0x828C9928; continue 'dispatch;
	}
	// 828C991C: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 828C9920: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C9924: 419A0008  beq cr6, 0x828c992c
	if ctx.cr[6].eq {
	pc = 0x828C992C; continue 'dispatch;
	}
	pc = 0x828C9928; continue 'dispatch;
            }
            0x828C9928 => {
    //   block [0x828C9928..0x828C992C)
	// 828C9928: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C992C; continue 'dispatch;
            }
            0x828C992C => {
    //   block [0x828C992C..0x828C9944)
	// 828C992C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C9930: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828C9934: 419A0024  beq cr6, 0x828c9958
	if ctx.cr[6].eq {
	pc = 0x828C9958; continue 'dispatch;
	}
	// 828C9938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C993C: 409A0008  bne cr6, 0x828c9944
	if !ctx.cr[6].eq {
	pc = 0x828C9944; continue 'dispatch;
	}
	// 828C9940: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C9944; continue 'dispatch;
            }
            0x828C9944 => {
    //   block [0x828C9944..0x828C9954)
	// 828C9944: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9948: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C994C: 409A0008  bne cr6, 0x828c9954
	if !ctx.cr[6].eq {
	pc = 0x828C9954; continue 'dispatch;
	}
	// 828C9950: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C9954; continue 'dispatch;
            }
            0x828C9954 => {
    //   block [0x828C9954..0x828C9958)
	// 828C9954: 83AA0010  lwz r29, 0x10(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	pc = 0x828C9958; continue 'dispatch;
            }
            0x828C9958 => {
    //   block [0x828C9958..0x828C9990)
	// 828C9958: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C995C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C9960: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C9964: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C9968: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C996C: 4BAABB15  bl 0x82375480
	ctx.lr = 0x828C9970;
	sub_82375480(ctx, base);
	// 828C9970: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828C9974: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 828C9978: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C997C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C9980: 419A0010  beq cr6, 0x828c9990
	if ctx.cr[6].eq {
	pc = 0x828C9990; continue 'dispatch;
	}
	// 828C9984: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 828C9988: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C998C: 419A0008  beq cr6, 0x828c9994
	if ctx.cr[6].eq {
	pc = 0x828C9994; continue 'dispatch;
	}
	pc = 0x828C9990; continue 'dispatch;
            }
            0x828C9990 => {
    //   block [0x828C9990..0x828C9994)
	// 828C9990: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C9994; continue 'dispatch;
            }
            0x828C9994 => {
    //   block [0x828C9994..0x828C99AC)
	// 828C9994: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C9998: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828C999C: 419A0024  beq cr6, 0x828c99c0
	if ctx.cr[6].eq {
	pc = 0x828C99C0; continue 'dispatch;
	}
	// 828C99A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C99A4: 409A0008  bne cr6, 0x828c99ac
	if !ctx.cr[6].eq {
	pc = 0x828C99AC; continue 'dispatch;
	}
	// 828C99A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C99AC; continue 'dispatch;
            }
            0x828C99AC => {
    //   block [0x828C99AC..0x828C99BC)
	// 828C99AC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C99B0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C99B4: 409A0008  bne cr6, 0x828c99bc
	if !ctx.cr[6].eq {
	pc = 0x828C99BC; continue 'dispatch;
	}
	// 828C99B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C99BC; continue 'dispatch;
            }
            0x828C99BC => {
    //   block [0x828C99BC..0x828C99C0)
	// 828C99BC: 83CB0010  lwz r30, 0x10(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	pc = 0x828C99C0; continue 'dispatch;
            }
            0x828C99C0 => {
    //   block [0x828C99C0..0x828C9A3C)
	// 828C99C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C99C4: 419A0104  beq cr6, 0x828c9ac8
	if ctx.cr[6].eq {
	pc = 0x828C9AC8; continue 'dispatch;
	}
	// 828C99C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C99CC: 419A00FC  beq cr6, 0x828c9ac8
	if ctx.cr[6].eq {
	pc = 0x828C9AC8; continue 'dispatch;
	}
	// 828C99D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C99D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C99D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C99DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C99E0: 484BD871  bl 0x82d87250
	ctx.lr = 0x828C99E4;
	sub_82D87250(ctx, base);
	// 828C99E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C99E8: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828C99EC: 4B95586D  bl 0x8221f258
	ctx.lr = 0x828C99F0;
	sub_8221F258(ctx, base);
	// 828C99F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C99F4: 419A0050  beq cr6, 0x828c9a44
	if ctx.cr[6].eq {
	pc = 0x828C9A44; continue 'dispatch;
	}
	// 828C99F8: 91C30004  stw r14, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[14].u32 ) };
	// 828C99FC: 91C30008  stw r14, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[14].u32 ) };
	// 828C9A00: 91C3000C  stw r14, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[14].u32 ) };
	// 828C9A04: 91C30010  stw r14, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[14].u32 ) };
	// 828C9A08: 91C30018  stw r14, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[14].u32 ) };
	// 828C9A0C: 92C30014  stw r22, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[22].u32 ) };
	// 828C9A10: 91C30020  stw r14, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[14].u32 ) };
	// 828C9A14: 91C30024  stw r14, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[14].u32 ) };
	// 828C9A18: 91C30028  stw r14, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[14].u32 ) };
	// 828C9A1C: 92A30000  stw r21, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 828C9A20: 93A3002C  stw r29, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[29].u32 ) };
	// 828C9A24: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9A28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9A2C: 419A0010  beq cr6, 0x828c9a3c
	if ctx.cr[6].eq {
	pc = 0x828C9A3C; continue 'dispatch;
	}
	// 828C9A30: A17D0006  lhz r11, 6(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C9A34: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 828C9A38: B15D0006  sth r10, 6(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	pc = 0x828C9A3C; continue 'dispatch;
            }
            0x828C9A3C => {
    //   block [0x828C9A3C..0x828C9A44)
	// 828C9A3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C9A40: 48000008  b 0x828c9a48
	pc = 0x828C9A48; continue 'dispatch;
            }
            0x828C9A44 => {
    //   block [0x828C9A44..0x828C9A48)
	// 828C9A44: 7DDE7378  mr r30, r14
	ctx.r[30].u64 = ctx.r[14].u64;
	pc = 0x828C9A48; continue 'dispatch;
            }
            0x828C9A48 => {
    //   block [0x828C9A48..0x828C9A68)
	// 828C9A48: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9A4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9A50: 419A0018  beq cr6, 0x828c9a68
	if ctx.cr[6].eq {
	pc = 0x828C9A68; continue 'dispatch;
	}
	// 828C9A54: 81570008  lwz r10, 8(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C9A58: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828C9A5C: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828C9A60: 7F195040  cmplw cr6, r25, r10
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C9A64: 41980008  blt cr6, 0x828c9a6c
	if ctx.cr[6].lt {
	pc = 0x828C9A6C; continue 'dispatch;
	}
	pc = 0x828C9A68; continue 'dispatch;
            }
            0x828C9A68 => {
    //   block [0x828C9A68..0x828C9A6C)
	// 828C9A68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828C9A6C; continue 'dispatch;
            }
            0x828C9A6C => {
    //   block [0x828C9A6C..0x828C9AB4)
	// 828C9A6C: 7FEBC214  add r31, r11, r24
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 828C9A70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9A74: 4B8EE0A5  bl 0x821b7b18
	ctx.lr = 0x828C9A78;
	sub_821B7B18(ctx, base);
	// 828C9A78: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C9A7C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C9A80: 419A003C  beq cr6, 0x828c9abc
	if ctx.cr[6].eq {
	pc = 0x828C9ABC; continue 'dispatch;
	}
	// 828C9A84: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C9A88: 4B9557D1  bl 0x8221f258
	ctx.lr = 0x828C9A8C;
	sub_8221F258(ctx, base);
	// 828C9A8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C9A90: 419A0024  beq cr6, 0x828c9ab4
	if ctx.cr[6].eq {
	pc = 0x828C9AB4; continue 'dispatch;
	}
	// 828C9A94: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9A98: 3D208253  lis r9, -0x7dad
	ctx.r[9].s64 = -2108489728;
	// 828C9A9C: 92630000  stw r19, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[19].u32 ) };
	// 828C9AA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C9AA4: 39099238  addi r8, r9, -0x6dc8
	ctx.r[8].s64 = ctx.r[9].s64 + -28104;
	// 828C9AA8: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 828C9AAC: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C9AB0: 48000008  b 0x828c9ab8
	pc = 0x828C9AB8; continue 'dispatch;
            }
            0x828C9AB4 => {
    //   block [0x828C9AB4..0x828C9AB8)
	// 828C9AB4: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	pc = 0x828C9AB8; continue 'dispatch;
            }
            0x828C9AB8 => {
    //   block [0x828C9AB8..0x828C9ABC)
	// 828C9AB8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x828C9ABC; continue 'dispatch;
            }
            0x828C9ABC => {
    //   block [0x828C9ABC..0x828C9AC8)
	// 828C9ABC: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 828C9AC0: 7FABD12E  stwx r29, r11, r26
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32), ctx.r[29].u32) };
	// 828C9AC4: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x828C9AC8; continue 'dispatch;
            }
            0x828C9AC8 => {
    //   block [0x828C9AC8..0x828C9ADC)
	// 828C9AC8: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 828C9ACC: 3B180008  addi r24, r24, 8
	ctx.r[24].s64 = ctx.r[24].s64 + 8;
	// 828C9AD0: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 828C9AD4: 7F19D840  cmplw cr6, r25, r27
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828C9AD8: 409AFE0C  bne cr6, 0x828c98e4
	if !ctx.cr[6].eq {
	pc = 0x828C98E4; continue 'dispatch;
	}
	pc = 0x828C9ADC; continue 'dispatch;
            }
            0x828C9ADC => {
    //   block [0x828C9ADC..0x828C9B28)
	// 828C9ADC: 83410078  lwz r26, 0x78(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C9AE0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 828C9AE4: 38A0000E  li r5, 0xe
	ctx.r[5].s64 = 14;
	// 828C9AE8: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 828C9AEC: 7C6BD02E  lwzx r3, r11, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 828C9AF0: 4848B759  bl 0x82d55248
	ctx.lr = 0x828C9AF4;
	sub_82D55248(ctx, base);
	// 828C9AF4: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 828C9AF8: 7E068378  mr r6, r16
	ctx.r[6].u64 = ctx.r[16].u64;
	// 828C9AFC: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828C9B00: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828C9B04: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828C9B08: 485A37D1  bl 0x82e6d2d8
	ctx.lr = 0x828C9B0C;
	sub_82E6D2D8(ctx, base);
	// 828C9B0C: 83A10284  lwz r29, 0x284(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(644 as u32) ) } as u64;
	// 828C9B10: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828C9B14: 7DDF7378  mr r31, r14
	ctx.r[31].u64 = ctx.r[14].u64;
	// 828C9B18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C9B1C: 907D0094  stw r3, 0x94(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 828C9B20: 419A0028  beq cr6, 0x828c9b48
	if ctx.cr[6].eq {
	pc = 0x828C9B48; continue 'dispatch;
	}
	// 828C9B24: 7DDE7378  mr r30, r14
	ctx.r[30].u64 = ctx.r[14].u64;
	pc = 0x828C9B28; continue 'dispatch;
            }
            0x828C9B28 => {
    //   block [0x828C9B28..0x828C9B48)
	// 828C9B28: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828C9B2C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828C9B30: 484B68B1  bl 0x82d803e0
	ctx.lr = 0x828C9B34;
	sub_82D803E0(ctx, base);
	// 828C9B34: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828C9B38: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828C9B3C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 828C9B40: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C9B44: 409AFFE4  bne cr6, 0x828c9b28
	if !ctx.cr[6].eq {
	pc = 0x828C9B28; continue 'dispatch;
	}
	pc = 0x828C9B48; continue 'dispatch;
            }
            0x828C9B48 => {
    //   block [0x828C9B48..0x828C9B5C)
	// 828C9B48: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828C9B4C: 7DDE7378  mr r30, r14
	ctx.r[30].u64 = ctx.r[14].u64;
	// 828C9B50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9B54: 419A005C  beq cr6, 0x828c9bb0
	if ctx.cr[6].eq {
	pc = 0x828C9BB0; continue 'dispatch;
	}
	// 828C9B58: 7DDF7378  mr r31, r14
	ctx.r[31].u64 = ctx.r[14].u64;
	pc = 0x828C9B5C; continue 'dispatch;
            }
            0x828C9B5C => {
    //   block [0x828C9B5C..0x828C9B9C)
	// 828C9B5C: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 828C9B60: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828C9B64: A1430004  lhz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9B68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C9B6C: 419A0030  beq cr6, 0x828c9b9c
	if ctx.cr[6].eq {
	pc = 0x828C9B9C; continue 'dispatch;
	}
	// 828C9B70: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 828C9B74: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 828C9B78: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 828C9B7C: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 828C9B80: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C9B84: 409A0018  bne cr6, 0x828c9b9c
	if !ctx.cr[6].eq {
	pc = 0x828C9B9C; continue 'dispatch;
	}
	// 828C9B88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9B8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C9B90: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9B94: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C9B98: 4E800421  bctrl
	ctx.lr = 0x828C9B9C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828C9B9C => {
    //   block [0x828C9B9C..0x828C9BB0)
	// 828C9B9C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828C9BA0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828C9BA4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 828C9BA8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C9BAC: 409AFFB0  bne cr6, 0x828c9b5c
	if !ctx.cr[6].eq {
	pc = 0x828C9B5C; continue 'dispatch;
	}
	pc = 0x828C9BB0; continue 'dispatch;
            }
            0x828C9BB0 => {
    //   block [0x828C9BB0..0x828C9FB4)
	// 828C9BB0: 83810294  lwz r28, 0x294(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(660 as u32) ) } as u64;
	// 828C9BB4: 3BDD0060  addi r30, r29, 0x60
	ctx.r[30].s64 = ctx.r[29].s64 + 96;
	// 828C9BB8: 3BFD0070  addi r31, r29, 0x70
	ctx.r[31].s64 = ctx.r[29].s64 + 112;
	// 828C9BBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C9BC0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828C9BC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9BC8: 4BFFBB89  bl 0x828c5750
	ctx.lr = 0x828C9BCC;
	sub_828C5750(ctx, base);
	// 828C9BCC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C9BD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C9BD4: 806102B4  lwz r3, 0x2b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(692 as u32) ) } as u64;
	// 828C9BD8: 4BAC4EF9  bl 0x8238ead0
	ctx.lr = 0x828C9BDC;
	sub_8238EAD0(ctx, base);
	// 828C9BDC: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	pc = 0x828C9FB4; continue 'dispatch;
            }
            0x828C9FB4 => {
    //   block [0x828C9FB4..0x828C9FBC)
	// 828C9FB4: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 828C9FB8: 483DF468  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C9FC0 size=272
    let mut pc: u32 = 0x828C9FC0;
    'dispatch: loop {
        match pc {
            0x828C9FC0 => {
    //   block [0x828C9FC0..0x828C9FDC)
	// 828C9FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9FC4: 483DF445  bl 0x82ca9408
	ctx.lr = 0x828C9FC8;
	sub_82CA93D0(ctx, base);
	// 828C9FC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C9FCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C9FD0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C9FD4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C9FD8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828C9FDC; continue 'dispatch;
            }
            0x828C9FDC => {
    //   block [0x828C9FDC..0x828C9FF4)
	// 828C9FDC: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828C9FE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9FE4: 419A0010  beq cr6, 0x828c9ff4
	if ctx.cr[6].eq {
	pc = 0x828C9FF4; continue 'dispatch;
	}
	// 828C9FE8: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C9FEC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828C9FF0: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x828C9FF4; continue 'dispatch;
            }
            0x828C9FF4 => {
    //   block [0x828C9FF4..0x828CA01C)
	// 828C9FF4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C9FF8: 419A004C  beq cr6, 0x828ca044
	if ctx.cr[6].eq {
	pc = 0x828CA044; continue 'dispatch;
	}
	// 828C9FFC: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA004: 419A0018  beq cr6, 0x828ca01c
	if ctx.cr[6].eq {
	pc = 0x828CA01C; continue 'dispatch;
	}
	// 828CA008: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA00C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA010: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA014: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA018: 41980008  blt cr6, 0x828ca020
	if ctx.cr[6].lt {
	pc = 0x828CA020; continue 'dispatch;
	}
	pc = 0x828CA01C; continue 'dispatch;
            }
            0x828CA01C => {
    //   block [0x828CA01C..0x828CA020)
	// 828CA01C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828CA020; continue 'dispatch;
            }
            0x828CA020 => {
    //   block [0x828CA020..0x828CA044)
	// 828CA020: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA024: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CA028: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA02C: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CA030: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828CA034: 4E800421  bctrl
	ctx.lr = 0x828CA038;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA038: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828CA03C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA040: 4BFFFF9C  b 0x828c9fdc
	pc = 0x828C9FDC; continue 'dispatch;
            }
            0x828CA044 => {
    //   block [0x828CA044..0x828CA05C)
	// 828CA044: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828CA048: 894B6B5F  lbz r10, 0x6b5f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27487 as u32) ) } as u64;
	// 828CA04C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828CA050: 419A0074  beq cr6, 0x828ca0c4
	if ctx.cr[6].eq {
	pc = 0x828CA0C4; continue 'dispatch;
	}
	// 828CA054: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828CA058: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828CA05C; continue 'dispatch;
            }
            0x828CA05C => {
    //   block [0x828CA05C..0x828CA074)
	// 828CA05C: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CA060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA064: 419A0010  beq cr6, 0x828ca074
	if ctx.cr[6].eq {
	pc = 0x828CA074; continue 'dispatch;
	}
	// 828CA068: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CA06C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA070: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x828CA074; continue 'dispatch;
            }
            0x828CA074 => {
    //   block [0x828CA074..0x828CA09C)
	// 828CA074: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA078: 419A004C  beq cr6, 0x828ca0c4
	if ctx.cr[6].eq {
	pc = 0x828CA0C4; continue 'dispatch;
	}
	// 828CA07C: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CA080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA084: 419A0018  beq cr6, 0x828ca09c
	if ctx.cr[6].eq {
	pc = 0x828CA09C; continue 'dispatch;
	}
	// 828CA088: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CA08C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA090: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA094: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA098: 41980008  blt cr6, 0x828ca0a0
	if ctx.cr[6].lt {
	pc = 0x828CA0A0; continue 'dispatch;
	}
	pc = 0x828CA09C; continue 'dispatch;
            }
            0x828CA09C => {
    //   block [0x828CA09C..0x828CA0A0)
	// 828CA09C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828CA0A0; continue 'dispatch;
            }
            0x828CA0A0 => {
    //   block [0x828CA0A0..0x828CA0C4)
	// 828CA0A0: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA0A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CA0A8: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA0AC: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CA0B0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828CA0B4: 4E800421  bctrl
	ctx.lr = 0x828CA0B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA0B8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828CA0BC: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA0C0: 4BFFFF9C  b 0x828ca05c
	pc = 0x828CA05C; continue 'dispatch;
            }
            0x828CA0C4 => {
    //   block [0x828CA0C4..0x828CA0D0)
	// 828CA0C4: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828CA0C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CA0CC: 483DF38C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA0D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA0D0 size=288
    let mut pc: u32 = 0x828CA0D0;
    'dispatch: loop {
        match pc {
            0x828CA0D0 => {
    //   block [0x828CA0D0..0x828CA0F8)
	// 828CA0D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA0D4: 483DF335  bl 0x82ca9408
	ctx.lr = 0x828CA0D8;
	sub_82CA93D0(ctx, base);
	// 828CA0D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA0DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CA0E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828CA0E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA0E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CA0EC: 419A00F4  beq cr6, 0x828ca1e0
	if ctx.cr[6].eq {
	pc = 0x828CA1E0; continue 'dispatch;
	}
	// 828CA0F0: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828CA0F4: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	pc = 0x828CA0F8; continue 'dispatch;
            }
            0x828CA0F8 => {
    //   block [0x828CA0F8..0x828CA10C)
	// 828CA0F8: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CA0FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA100: 409A000C  bne cr6, 0x828ca10c
	if !ctx.cr[6].eq {
	pc = 0x828CA10C; continue 'dispatch;
	}
	// 828CA104: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828CA108: 48000010  b 0x828ca118
	pc = 0x828CA118; continue 'dispatch;
            }
            0x828CA10C => {
    //   block [0x828CA10C..0x828CA118)
	// 828CA10C: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CA110: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA114: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x828CA118; continue 'dispatch;
            }
            0x828CA118 => {
    //   block [0x828CA118..0x828CA144)
	// 828CA118: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA11C: 419A004C  beq cr6, 0x828ca168
	if ctx.cr[6].eq {
	pc = 0x828CA168; continue 'dispatch;
	}
	// 828CA120: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828CA124: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA12C: 419A0018  beq cr6, 0x828ca144
	if ctx.cr[6].eq {
	pc = 0x828CA144; continue 'dispatch;
	}
	// 828CA130: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CA134: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA138: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA13C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA140: 41980008  blt cr6, 0x828ca148
	if ctx.cr[6].lt {
	pc = 0x828CA148; continue 'dispatch;
	}
	pc = 0x828CA144; continue 'dispatch;
            }
            0x828CA144 => {
    //   block [0x828CA144..0x828CA148)
	// 828CA144: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828CA148; continue 'dispatch;
            }
            0x828CA148 => {
    //   block [0x828CA148..0x828CA168)
	// 828CA148: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA14C: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA150: 812A0028  lwz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CA154: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828CA158: 4E800421  bctrl
	ctx.lr = 0x828CA15C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA15C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828CA160: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA164: 4BFFFF94  b 0x828ca0f8
	pc = 0x828CA0F8; continue 'dispatch;
            }
            0x828CA168 => {
    //   block [0x828CA168..0x828CA170)
	// 828CA168: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828CA16C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	pc = 0x828CA170; continue 'dispatch;
            }
            0x828CA170 => {
    //   block [0x828CA170..0x828CA184)
	// 828CA170: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA174: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA178: 409A000C  bne cr6, 0x828ca184
	if !ctx.cr[6].eq {
	pc = 0x828CA184; continue 'dispatch;
	}
	// 828CA17C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828CA180: 48000010  b 0x828ca190
	pc = 0x828CA190; continue 'dispatch;
            }
            0x828CA184 => {
    //   block [0x828CA184..0x828CA190)
	// 828CA184: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA188: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA18C: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x828CA190; continue 'dispatch;
            }
            0x828CA190 => {
    //   block [0x828CA190..0x828CA1BC)
	// 828CA190: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA194: 419A004C  beq cr6, 0x828ca1e0
	if ctx.cr[6].eq {
	pc = 0x828CA1E0; continue 'dispatch;
	}
	// 828CA198: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA19C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA1A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA1A4: 419A0018  beq cr6, 0x828ca1bc
	if ctx.cr[6].eq {
	pc = 0x828CA1BC; continue 'dispatch;
	}
	// 828CA1A8: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA1AC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA1B0: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA1B4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA1B8: 41980008  blt cr6, 0x828ca1c0
	if ctx.cr[6].lt {
	pc = 0x828CA1C0; continue 'dispatch;
	}
	pc = 0x828CA1BC; continue 'dispatch;
            }
            0x828CA1BC => {
    //   block [0x828CA1BC..0x828CA1C0)
	// 828CA1BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828CA1C0; continue 'dispatch;
            }
            0x828CA1C0 => {
    //   block [0x828CA1C0..0x828CA1E0)
	// 828CA1C0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA1C4: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA1C8: 812A0028  lwz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CA1CC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828CA1D0: 4E800421  bctrl
	ctx.lr = 0x828CA1D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA1D4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828CA1D8: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA1DC: 4BFFFF94  b 0x828ca170
	pc = 0x828CA170; continue 'dispatch;
            }
            0x828CA1E0 => {
    //   block [0x828CA1E0..0x828CA1F0)
	// 828CA1E0: 9B9F0024  stb r28, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[28].u8 ) };
	// 828CA1E4: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828CA1E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CA1EC: 483DF26C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA1F0 size=172
    let mut pc: u32 = 0x828CA1F0;
    'dispatch: loop {
        match pc {
            0x828CA1F0 => {
    //   block [0x828CA1F0..0x828CA214)
	// 828CA1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA1F4: 483DF219  bl 0x82ca940c
	ctx.lr = 0x828CA1F8;
	sub_82CA93D0(ctx, base);
	// 828CA1F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA1FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CA200: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CA204: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828CA208: 419A0088  beq cr6, 0x828ca290
	if ctx.cr[6].eq {
	pc = 0x828CA290; continue 'dispatch;
	}
	// 828CA20C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828CA210: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828CA214; continue 'dispatch;
            }
            0x828CA214 => {
    //   block [0x828CA214..0x828CA22C)
	// 828CA214: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA21C: 419A0010  beq cr6, 0x828ca22c
	if ctx.cr[6].eq {
	pc = 0x828CA22C; continue 'dispatch;
	}
	// 828CA220: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA224: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA228: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x828CA22C; continue 'dispatch;
            }
            0x828CA22C => {
    //   block [0x828CA22C..0x828CA254)
	// 828CA22C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA230: 419A0060  beq cr6, 0x828ca290
	if ctx.cr[6].eq {
	pc = 0x828CA290; continue 'dispatch;
	}
	// 828CA234: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA238: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA23C: 419A0018  beq cr6, 0x828ca254
	if ctx.cr[6].eq {
	pc = 0x828CA254; continue 'dispatch;
	}
	// 828CA240: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA244: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA248: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA24C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA250: 41980008  blt cr6, 0x828ca258
	if ctx.cr[6].lt {
	pc = 0x828CA258; continue 'dispatch;
	}
	pc = 0x828CA254; continue 'dispatch;
            }
            0x828CA254 => {
    //   block [0x828CA254..0x828CA258)
	// 828CA254: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828CA258; continue 'dispatch;
            }
            0x828CA258 => {
    //   block [0x828CA258..0x828CA284)
	// 828CA258: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA25C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA260: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828CA264: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CA268: 4E800421  bctrl
	ctx.lr = 0x828CA26C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA26C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828CA270: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828CA274: 409A0010  bne cr6, 0x828ca284
	if !ctx.cr[6].eq {
	pc = 0x828CA284; continue 'dispatch;
	}
	// 828CA278: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828CA27C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA280: 4BFFFF94  b 0x828ca214
	pc = 0x828CA214; continue 'dispatch;
            }
            0x828CA284 => {
    //   block [0x828CA284..0x828CA290)
	// 828CA284: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828CA288: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CA28C: 483DF1D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x828CA290 => {
    //   block [0x828CA290..0x828CA29C)
	// 828CA290: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CA294: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CA298: 483DF1C4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CA2A0 size=24
    let mut pc: u32 = 0x828CA2A0;
    'dispatch: loop {
        match pc {
            0x828CA2A0 => {
    //   block [0x828CA2A0..0x828CA2B8)
	// 828CA2A0: E9440060  ld r10, 0x60(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(96 as u32) ) };
	// 828CA2A4: 39640060  addi r11, r4, 0x60
	ctx.r[11].s64 = ctx.r[4].s64 + 96;
	// 828CA2A8: E9240068  ld r9, 0x68(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(104 as u32) ) };
	// 828CA2AC: F9430000  std r10, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 828CA2B0: F9230008  std r9, 8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 828CA2B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CA2C0 size=204
    let mut pc: u32 = 0x828CA2C0;
    'dispatch: loop {
        match pc {
            0x828CA2C0 => {
    //   block [0x828CA2C0..0x828CA38C)
	// 828CA2C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA2C4: 483DF149  bl 0x82ca940c
	ctx.lr = 0x828CA2C8;
	sub_82CA93D0(ctx, base);
	// 828CA2C8: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA390 size=376
    let mut pc: u32 = 0x828CA390;
    'dispatch: loop {
        match pc {
            0x828CA390 => {
    //   block [0x828CA390..0x828CA3C0)
	// 828CA390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA394: 483DF065  bl 0x82ca93f8
	ctx.lr = 0x828CA398;
	sub_82CA93D0(ctx, base);
	// 828CA398: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA39C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828CA3A0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828CA3A4: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CA3A8: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828CA3AC: 419A0150  beq cr6, 0x828ca4fc
	if ctx.cr[6].eq {
	pc = 0x828CA4FC; continue 'dispatch;
	}
	// 828CA3B0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828CA3B4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828CA3B8: 3B000004  li r24, 4
	ctx.r[24].s64 = 4;
	// 828CA3BC: 3B200006  li r25, 6
	ctx.r[25].s64 = 6;
	pc = 0x828CA3C0; continue 'dispatch;
            }
            0x828CA3C0 => {
    //   block [0x828CA3C0..0x828CA3D8)
	// 828CA3C0: 817C003C  lwz r11, 0x3c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA3C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA3C8: 419A0010  beq cr6, 0x828ca3d8
	if ctx.cr[6].eq {
	pc = 0x828CA3D8; continue 'dispatch;
	}
	// 828CA3CC: 815C0040  lwz r10, 0x40(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA3D0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA3D4: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x828CA3D8; continue 'dispatch;
            }
            0x828CA3D8 => {
    //   block [0x828CA3D8..0x828CA400)
	// 828CA3D8: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA3DC: 419A0120  beq cr6, 0x828ca4fc
	if ctx.cr[6].eq {
	pc = 0x828CA4FC; continue 'dispatch;
	}
	// 828CA3E0: 83FC003C  lwz r31, 0x3c(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA3E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CA3E8: 419A0018  beq cr6, 0x828ca400
	if ctx.cr[6].eq {
	pc = 0x828CA400; continue 'dispatch;
	}
	// 828CA3EC: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA3F0: 7D5F5850  subf r10, r31, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 828CA3F4: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828CA3F8: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA3FC: 41980008  blt cr6, 0x828ca404
	if ctx.cr[6].lt {
	pc = 0x828CA404; continue 'dispatch;
	}
	pc = 0x828CA400; continue 'dispatch;
            }
            0x828CA400 => {
    //   block [0x828CA400..0x828CA404)
	// 828CA400: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828CA404; continue 'dispatch;
            }
            0x828CA404 => {
    //   block [0x828CA404..0x828CA448)
	// 828CA404: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 828CA408: 409A0040  bne cr6, 0x828ca448
	if !ctx.cr[6].eq {
	pc = 0x828CA448; continue 'dispatch;
	}
	// 828CA40C: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828CA410: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CA414: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA418: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CA41C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CA420: 4E800421  bctrl
	ctx.lr = 0x828CA424;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA424: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828CA428: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828CA42C: 93030008  stw r24, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 828CA430: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA434: 5124801E  rlwimi r4, r9, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[9].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 828CA438: 4BF88E81  bl 0x828532b8
	ctx.lr = 0x828CA43C;
	sub_828532B8(ctx, base);
	// 828CA43C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 828CA440: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA444: 4BFFFF7C  b 0x828ca3c0
	pc = 0x828CA3C0; continue 'dispatch;
            }
            0x828CA448 => {
    //   block [0x828CA448..0x828CA48C)
	// 828CA448: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 828CA44C: 409A0040  bne cr6, 0x828ca48c
	if !ctx.cr[6].eq {
	pc = 0x828CA48C; continue 'dispatch;
	}
	// 828CA450: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828CA454: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828CA458: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA45C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CA460: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CA464: 4E800421  bctrl
	ctx.lr = 0x828CA468;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA468: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828CA46C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828CA470: 93230008  stw r25, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 828CA474: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA478: 5124801E  rlwimi r4, r9, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[9].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 828CA47C: 4BF88E3D  bl 0x828532b8
	ctx.lr = 0x828CA480;
	sub_828532B8(ctx, base);
	// 828CA480: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 828CA484: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA488: 4BFFFF38  b 0x828ca3c0
	pc = 0x828CA3C0; continue 'dispatch;
            }
            0x828CA48C => {
    //   block [0x828CA48C..0x828CA4B4)
	// 828CA48C: 2F1A0004  cmpwi cr6, r26, 4
	ctx.cr[6].compare_i32(ctx.r[26].s32, 4, &mut ctx.xer);
	// 828CA490: 409A0060  bne cr6, 0x828ca4f0
	if !ctx.cr[6].eq {
	pc = 0x828CA4F0; continue 'dispatch;
	}
	// 828CA494: 83DC0088  lwz r30, 0x88(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) } as u64;
	// 828CA498: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828CA49C: 419A0018  beq cr6, 0x828ca4b4
	if ctx.cr[6].eq {
	pc = 0x828CA4B4; continue 'dispatch;
	}
	// 828CA4A0: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CA4A4: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 828CA4A8: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 828CA4AC: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA4B0: 41980008  blt cr6, 0x828ca4b8
	if ctx.cr[6].lt {
	pc = 0x828CA4B8; continue 'dispatch;
	}
	pc = 0x828CA4B4; continue 'dispatch;
            }
            0x828CA4B4 => {
    //   block [0x828CA4B4..0x828CA4B8)
	// 828CA4B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828CA4B8; continue 'dispatch;
            }
            0x828CA4B8 => {
    //   block [0x828CA4B8..0x828CA4F0)
	// 828CA4B8: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828CA4BC: 7D7DF214  add r11, r29, r30
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 828CA4C0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA4C4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA4C8: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CA4CC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828CA4D0: 4E800421  bctrl
	ctx.lr = 0x828CA4D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA4D4: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828CA4D8: 7D1DF02E  lwzx r8, r29, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 828CA4DC: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA4E0: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828CA4E4: 54E6801E  slwi r6, r7, 0x10
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(16);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828CA4E8: 7CC44378  or r4, r6, r8
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[8].u64;
	// 828CA4EC: 4BF88DCD  bl 0x828532b8
	ctx.lr = 0x828CA4F0;
	sub_828532B8(ctx, base);
            }
            0x828CA4F0 => {
    //   block [0x828CA4F0..0x828CA4FC)
	// 828CA4F0: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 828CA4F4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA4F8: 4BFFFEC8  b 0x828ca3c0
	pc = 0x828CA3C0; continue 'dispatch;
            }
            0x828CA4FC => {
    //   block [0x828CA4FC..0x828CA508)
	// 828CA4FC: 935C0020  stw r26, 0x20(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 828CA500: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828CA504: 483DEF44  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA508 size=88
    let mut pc: u32 = 0x828CA508;
    'dispatch: loop {
        match pc {
            0x828CA508 => {
    //   block [0x828CA508..0x828CA560)
	// 828CA508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA50C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CA510: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CA514: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA518: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CA51C: 39600070  li r11, 0x70
	ctx.r[11].s64 = 112;
	// 828CA520: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828CA524: E89F0060  ld r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA560 size=112
    let mut pc: u32 = 0x828CA560;
    'dispatch: loop {
        match pc {
            0x828CA560 => {
    //   block [0x828CA560..0x828CA5D0)
	// 828CA560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CA568: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CA56C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA570: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
	// 828CA574: F88100F0  std r4, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[4].u64 ) };
	// 828CA578: F8A100F8  std r5, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[5].u64 ) };
	// 828CA57C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CA580: 39400070  li r10, 0x70
	ctx.r[10].s64 = 112;
	// 828CA584: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828CA588: 391F0060  addi r8, r31, 0x60
	ctx.r[8].s64 = ctx.r[31].s64 + 96;
	// 828CA58C: E8EB0000  ld r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828CA590: E92B0008  ld r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 828CA594: F93F0068  std r9, 0x68(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA5D0 size=140
    let mut pc: u32 = 0x828CA5D0;
    'dispatch: loop {
        match pc {
            0x828CA5D0 => {
    //   block [0x828CA5D0..0x828CA5EC)
	// 828CA5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA5D4: 483DEE35  bl 0x82ca9408
	ctx.lr = 0x828CA5D8;
	sub_82CA93D0(ctx, base);
	// 828CA5D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA5DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CA5E0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828CA5E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CA5E8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828CA5EC; continue 'dispatch;
            }
            0x828CA5EC => {
    //   block [0x828CA5EC..0x828CA604)
	// 828CA5EC: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA5F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA5F4: 419A0010  beq cr6, 0x828ca604
	if ctx.cr[6].eq {
	pc = 0x828CA604; continue 'dispatch;
	}
	// 828CA5F8: 815E0040  lwz r10, 0x40(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA5FC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA600: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x828CA604; continue 'dispatch;
            }
            0x828CA604 => {
    //   block [0x828CA604..0x828CA62C)
	// 828CA604: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA608: 419A004C  beq cr6, 0x828ca654
	if ctx.cr[6].eq {
	pc = 0x828CA654; continue 'dispatch;
	}
	// 828CA60C: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA614: 419A0018  beq cr6, 0x828ca62c
	if ctx.cr[6].eq {
	pc = 0x828CA62C; continue 'dispatch;
	}
	// 828CA618: 815E0040  lwz r10, 0x40(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA61C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA620: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA624: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA628: 41980008  blt cr6, 0x828ca630
	if ctx.cr[6].lt {
	pc = 0x828CA630; continue 'dispatch;
	}
	pc = 0x828CA62C; continue 'dispatch;
            }
            0x828CA62C => {
    //   block [0x828CA62C..0x828CA630)
	// 828CA62C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828CA630; continue 'dispatch;
            }
            0x828CA630 => {
    //   block [0x828CA630..0x828CA654)
	// 828CA630: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA634: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CA638: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA63C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828CA640: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CA644: 4E800421  bctrl
	ctx.lr = 0x828CA648;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA648: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828CA64C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA650: 4BFFFF9C  b 0x828ca5ec
	pc = 0x828CA5EC; continue 'dispatch;
            }
            0x828CA654 => {
    //   block [0x828CA654..0x828CA65C)
	// 828CA654: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CA658: 483DEE00  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CA660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CA660 size=132
    let mut pc: u32 = 0x828CA660;
    'dispatch: loop {
        match pc {
            0x828CA660 => {
    //   block [0x828CA660..0x828CA678)
	// 828CA660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CA664: 483DEDA9  bl 0x82ca940c
	ctx.lr = 0x828CA668;
	sub_82CA93D0(ctx, base);
	// 828CA668: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CA66C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CA670: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828CA674: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828CA678; continue 'dispatch;
            }
            0x828CA678 => {
    //   block [0x828CA678..0x828CA690)
	// 828CA678: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA680: 419A0010  beq cr6, 0x828ca690
	if ctx.cr[6].eq {
	pc = 0x828CA690; continue 'dispatch;
	}
	// 828CA684: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA688: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA68C: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x828CA690; continue 'dispatch;
            }
            0x828CA690 => {
    //   block [0x828CA690..0x828CA6B8)
	// 828CA690: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828CA694: 419A0048  beq cr6, 0x828ca6dc
	if ctx.cr[6].eq {
	pc = 0x828CA6DC; continue 'dispatch;
	}
	// 828CA698: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CA69C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA6A0: 419A0018  beq cr6, 0x828ca6b8
	if ctx.cr[6].eq {
	pc = 0x828CA6B8; continue 'dispatch;
	}
	// 828CA6A4: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CA6A8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828CA6AC: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 828CA6B0: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828CA6B4: 41980008  blt cr6, 0x828ca6bc
	if ctx.cr[6].lt {
	pc = 0x828CA6BC; continue 'dispatch;
	}
	pc = 0x828CA6B8; continue 'dispatch;
            }
            0x828CA6B8 => {
    //   block [0x828CA6B8..0x828CA6BC)
	// 828CA6B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828CA6BC; continue 'dispatch;
            }
            0x828CA6BC => {
    //   block [0x828CA6BC..0x828CA6DC)
	// 828CA6BC: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA6C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA6C4: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CA6C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CA6CC: 4E800421  bctrl
	ctx.lr = 0x828CA6D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA6D0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828CA6D4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 828CA6D8: 4BFFFFA0  b 0x828ca678
	pc = 0x828CA678; continue 'dispatch;
            }
            0x828CA6DC => {
    //   block [0x828CA6DC..0x828CA6E4)
	// 828CA6DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CA6E0: 483DED7C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


